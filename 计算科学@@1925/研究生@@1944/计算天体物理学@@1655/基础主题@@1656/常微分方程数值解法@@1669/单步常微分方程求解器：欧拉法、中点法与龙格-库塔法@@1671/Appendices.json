{"hands_on_practices": [{"introduction": "在将数值方法应用于尚无解析解的复杂物理问题之前，验证我们代码的正确性是至关重要的一步。本练习将指导您完成一个核心的验证任务：在一个具有已知解析解的天体物理模型（星系盘中的周转运动近似）上，通过经验性地测量方法的收敛阶来确认您的求解器实现是否符合其理论精度。通过这种“步长加倍”的实验，您可以建立对您所实现的欧拉法、中点法和龙格-库塔法的信心。[@problem_id:3534397]", "problem": "您将设计并实现一个计算实验，通过步长加倍法，为一个源于计算天体物理学的已知解析解，经验性地验证单步常微分方程（ODE）求解器的收敛阶。物理模型是银盘中小径向振荡的周转圆近似，该模型可简化为一个遵循牛顿第二定律的一维简谐振子。其运动方程为\n$$\nm \\,\\frac{d^2 y}{dt^2} \\;=\\; -\\,k\\,y,\n$$\n其中 $m$ 是质量，$k$ 是等效弹簧常数。通过 $k = m\\,\\omega^2$ 定义周转角频率 $\\omega$，该系统可以用状态向量 $u(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$ 写成一阶形式\n$$\n\\frac{d}{dt}\\begin{bmatrix} y \\\\ v \\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix} v \\\\ -\\,\\omega^2\\,y \\end{bmatrix}.\n$$\n对于初始条件 $y(0)=y_0$ 和 $v(0)=v_0$，其精确解为\n$$\ny(t) \\;=\\; y_0 \\cos(\\omega t) \\;+\\; \\frac{v_0}{\\omega}\\,\\sin(\\omega t),\\quad\nv(t) \\;=\\; -\\,y_0\\,\\omega\\,\\sin(\\omega t) \\;+\\; v_0 \\cos(\\omega t).\n$$\n\n您的任务是：\n- 实现三种应用于上述系统的显式单步ODE求解器：前向欧拉法、显式中点法和经典四阶龙格-库塔法。\n- 对每种方法，设计一个步长加倍实验来估计观测到的全局收敛率 $p_{\\mathrm{obs}}$。设 $T$ 为最终时间，$N$ 为步长 $h = T/N$ 下的步数，$2N$ 为步长 $h/2$ 下的步数。如果 $E_h$ 表示用步长 $h$ 计算的在时间 $T$ 的全局误差，$E_{h/2}$ 表示用步长 $h/2$ 计算的误差，则估计\n$$\np_{\\mathrm{obs}} \\;=\\; \\log_2\\!\\left(\\frac{E_h}{E_{h/2}}\\right).\n$$\n- 为了避免位置和速度之间的单位不一致，将时间 $t$ 的误差定义为状态空间中缩放后的欧几里得范数，\n$$\n\\|e(t)\\| \\;=\\; \\sqrt{\\;\\big(y_{\\mathrm{num}}(t) - y_{\\mathrm{exact}}(t)\\big)^2 \\;+\\; \\left(\\frac{v_{\\mathrm{num}}(t) - v_{\\mathrm{exact}}(t)}{\\omega}\\right)^2\\;}.\n$$\n使用此 $\\|e(T)\\|$ 作为 $E_h$ 和 $E_{h/2}$。\n\n角度单位必须是弧度，时间单位是秒，位置单位是米，速度单位是米/秒。观测到的收敛率 $p_{\\mathrm{obs}}$ 是无量纲的，应以浮点数形式报告。\n\n实现您的程序以运行以下测试套件，并以指定的最终格式为每个案例输出观测到的收敛率。\n\n测试套件（每一项是一个元组，指定了方法、角频率（弧度/秒）、最终时间（秒）、初始位置（米）、初始速度（米/秒）以及粗略步数 $N$）：\n- 案例 1：$\\big(\\text{欧拉法},\\, \\omega=1.0,\\, T=2\\pi,\\, y_0=1.0,\\, v_0=0.0,\\, N=200\\big)$。\n- 案例 2：$\\big(\\text{中点法},\\, \\omega=2.0,\\, T=\\pi,\\, y_0=1.0,\\, v_0=0.3,\\, N=240\\big)$。\n- 案例 3：$\\big(\\text{RK4},\\, \\omega=1.5,\\, T=\\tfrac{4\\pi}{1.5},\\, y_0=1.0,\\, v_0=0.0,\\, N=120\\big)$。\n- 案例 4（用于前渐近行为的粗分辨率边缘案例）：$\\big(\\text{欧拉法},\\, \\omega=1.0,\\, T=2\\pi,\\, y_0=1.0,\\, v_0=0.0,\\, N=20\\big)$。\n\n您的程序应：\n- 对于每个案例，使用 $N$ 步计算 $E_h$，使用 $2N$ 步计算 $E_{h/2}$，然后如上计算 $p_{\\mathrm{obs}}$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $\\big[\\;p_1,p_2,p_3,p_4\\;\\big]$。\n\n您的输出必须是四个浮点值 $\\big[p_1,p_2,p_3,p_4\\big]$ 的列表，按上述案例的顺序打印在单行上。不应打印任何其他文本。", "solution": "该问题要求对三种显式单步常微分方程（ODE）求解器——前向欧拉法、显式中点法和经典四阶龙格-库塔（RK4）法——的收敛阶进行经验性验证。测试模型是一个一维简谐振子，它代表了周转圆近似下银盘中的小径向振荡。\n\n该物理系统由二阶常微分方程 $m \\frac{d^2 y}{dt^2} = -k y$ 描述。通过定义角频率 $\\omega = \\sqrt{k/m}$，该方程可重写为 $\\frac{d^2 y}{dt^2} = -\\omega^2 y$。为了数值求解，我们将其转换为一个由两个一阶常微分方程组成的系统。设状态向量为 $u(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$，其中 $v(t) = \\frac{dy}{dt}$ 是速度。该系统则由下式给出：\n$$\n\\frac{du}{dt} = \\frac{d}{dt}\\begin{bmatrix} y \\\\ v \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\omega^2 y \\end{bmatrix} = f(u)\n$$\n这是一个形式为 $\\frac{du}{dt} = f(u)$ 的自治系统，因为等式右侧不显式依赖于时间 $t$。我们将使用初始条件 $u(0) = u_0 = \\begin{bmatrix} y_0 \\\\ v_0 \\end{bmatrix}$ 来求解该系统。\n\n对于每种数值方法，我们生成一个状态序列 $u_0, u_1, \\dots, u_N$，这些状态近似了在离散时间点 $t_n = n h$ 上的真实解，其中 $h = T/N$ 是步长，$N$ 是总步数，$T$ 是最终积分时间。\n\n三种求解器从 $u_n$ 到 $u_{n+1}$ 的单步实现如下：\n\n1.  **前向欧拉法：** 这是一种一阶方法（$p=1$）。其更新规则源自 $u(t_{n+1})$ 在 $t_n$ 附近的一阶泰勒展开：\n    $$\n    u_{n+1} = u_n + h f(u_n)\n    $$\n    对我们的特定系统，这变为：\n    $$\n    \\begin{bmatrix} y_{n+1} \\\\ v_{n+1} \\end{bmatrix} = \\begin{bmatrix} y_n \\\\ v_n \\end{bmatrix} + h \\begin{bmatrix} v_n \\\\ -\\omega^2 y_n \\end{bmatrix} = \\begin{bmatrix} y_n + h v_n \\\\ v_n - h \\omega^2 y_n \\end{bmatrix}\n    $$\n\n2.  **显式中点法：** 这是一种二阶方法（$p=2$），是一种两级龙格-库塔法。它首先使用大小为 $h/2$ 的前向欧拉步来估计区间中点 $t_n + h/2$ 处的状态，然后使用该中点的斜率来执行从 $t_n$ 到 $t_{n+1}$ 的完整一步：\n    $$\n    k_1 = f(u_n)\n    $$\n    $$\n    k_2 = f(u_n + \\frac{h}{2} k_1)\n    $$\n    $$\n    u_{n+1} = u_n + h k_2\n    $$\n\n3.  **经典四阶龙格-库塔（RK4）法：** 这是一种四阶方法（$p=4$），也是一种广泛使用的四级显式龙格-库塔法。它使用区间 $[t_n, t_{n+1}]$ 内四个斜率估计值的加权平均：\n    $$\n    k_1 = f(u_n)\n    $$\n    $$\n    k_2 = f(u_n + \\frac{h}{2} k_1)\n    $$\n    $$\n    k_3 = f(u_n + \\frac{h}{2} k_2)\n    $$\n    $$\n    k_4 = f(u_n + h k_3)\n    $$\n    $$\n    u_{n+1} = u_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n\n为了经验性地确定收敛阶 $p$，我们使用步长加倍法。对于一个 $p$ 阶方法，在固定的最终时间 $T$ 处的全局误差 $E$ 预计与步长的 $p$ 次方成正比，即对于足够小的 $h$ 有 $E \\approx C h^p$。我们计算数值解及其误差两次：一次使用粗步长 $h = T/N$ 得到误差 $E_h$，一次使用细步长 $h/2 = T/(2N)$ 得到误差 $E_{h/2}$。这些误差的比率为：\n$$\n\\frac{E_h}{E_{h/2}} \\approx \\frac{C h^p}{C (h/2)^p} = 2^p\n$$\n解出 $p$，我们得到观测到的收敛阶：\n$$\np_{\\mathrm{obs}} = \\log_2\\left(\\frac{E_h}{E_{h/2}}\\right)\n$$\n最终时间 $T$ 处的误差是通过将数值解 $u_{\\mathrm{num}}(T) = \\begin{bmatrix} y_{\\mathrm{num}}(T), v_{\\mathrm{num}}(T) \\end{bmatrix}^T$ 与精确解析解进行比较来计算的：\n$$\ny_{\\mathrm{exact}}(t) = y_0 \\cos(\\omega t) + \\frac{v_0}{\\omega}\\sin(\\omega t)\n$$\n$$\nv_{\\mathrm{exact}}(t) = -y_0\\,\\omega\\,\\sin(\\omega t) + v_0 \\cos(\\omega t)\n$$\n问题为误差向量 $e(T) = u_{\\mathrm{num}}(T) - u_{\\mathrm{exact}}(T)$ 指定了一个缩放后的欧几里得范数：\n$$\nE = \\|e(T)\\| = \\sqrt{\\big(y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)\\big)^2 + \\left(\\frac{v_{\\mathrm{num}}(T) - v_{\\mathrm{exact}}(T)}{\\omega}\\right)^2}\n$$\n这种缩放使得误差的两个分量（位置和速度）在量纲上保持一致，因为平方根内的两项都具有长度单位。\n\n每个测试案例的总体算法如下：\n1.  设置参数：方法、$\\omega$、$T$、$u_0$ 和粗略步数 $N$。\n2.  使用指定方法和 $N$ 步，从 $t=0$ 积分到 $t=T$，得到 $u_{\\mathrm{num}, h}(T)$。\n3.  使用相同方法和 $2N$ 步，从 $t=0$ 积分到 $t=T$，得到 $u_{\\mathrm{num}, h/2}(T)$。\n4.  计算精确解 $u_{\\mathrm{exact}}(T)$。\n5.  使用提供的误差范数计算误差 $E_h$ 和 $E_{h/2}$。\n6.  计算观测到的收敛率 $p_{\\mathrm{obs}} = \\log_2(E_h/E_{h/2})$。\n\n对问题陈述中提供的所有四个测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed convergence order for Euler, Midpoint, and RK4 methods\n    applied to the simple harmonic oscillator equation.\n    \"\"\"\n\n    # --- Define ODE system and its exact solution ---\n\n    def f_sho(t, u, omega_sq):\n        \"\"\"RHS of the simple harmonic oscillator ODE system: u' = f(t, u).\"\"\"\n        y, v = u\n        return np.array([v, -omega_sq * y])\n\n    def exact_solution(t, u0, omega):\n        \"\"\"Exact solution of the simple harmonic oscillator.\"\"\"\n        y0, v0 = u0\n        y_t = y0 * np.cos(omega * t) + (v0 / omega) * np.sin(omega * t)\n        v_t = -y0 * omega * np.sin(omega * t) + v0 * np.cos(omega * t)\n        return np.array([y_t, v_t])\n\n    # --- Define single-step ODE solvers ---\n\n    def euler_step(f, t, u, h, omega_sq):\n        \"\"\"Performs a single forward Euler step.\"\"\"\n        return u + h * f(t, u, omega_sq)\n\n    def midpoint_step(f, t, u, h, omega_sq):\n        \"\"\"Performs a single explicit midpoint method step.\"\"\"\n        k1 = f(t, u, omega_sq)\n        k2 = f(t + h / 2.0, u + (h / 2.0) * k1, omega_sq)\n        return u + h * k2\n\n    def rk4_step(f, t, u, h, omega_sq):\n        \"\"\"Performs a single classical 4th-order Runge-Kutta step.\"\"\"\n        k1 = f(t, u, omega_sq)\n        k2 = f(t + h / 2.0, u + (h / 2.0) * k1, omega_sq)\n        k3 = f(t + h / 2.0, u + (h / 2.0) * k2, omega_sq)\n        k4 = f(t + h, u + h * k3, omega_sq)\n        return u + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + 4.0 * k4)\n\n    # --- Define the integration driver ---\n\n    def integrate(step_func, u0, omega, T, N):\n        \"\"\"Integrates the ODE from t=0 to T using N steps.\"\"\"\n        h = T / N\n        u = u0.copy()\n        omega_sq = omega**2\n        for i in range(N):\n            t = i * h\n            u = step_func(f_sho, t, u, h, omega_sq)\n        return u\n\n    # --- Define the error calculation function ---\n\n    def calculate_error(u_num, u_exact, omega):\n        \"\"\"Calculates the error using the specified scaled norm.\"\"\"\n        err_y = u_num[0] - u_exact[0]\n        err_v = u_num[1] - u_exact[1]\n        norm_sq = err_y**2 + (err_v / omega)**2\n        return np.sqrt(norm_sq)\n\n    # --- Test suite definition ---\n\n    test_cases = [\n        # (Method Name, omega, T, y0, v0, N_coarse)\n        ('Euler', 1.0, 2.0 * np.pi, 1.0, 0.0, 200),\n        ('Midpoint', 2.0, np.pi, 1.0, 0.3, 240),\n        ('RK4', 1.5, 4.0 * np.pi / 1.5, 1.0, 0.0, 120),\n        ('Euler', 1.0, 2.0 * np.pi, 1.0, 0.0, 20),\n    ]\n\n    solver_map = {\n        'Euler': euler_step,\n        'Midpoint': midpoint_step,\n        'RK4': rk4_step,\n    }\n\n    results = []\n    for case in test_cases:\n        method_name, omega, T, y0, v0, N_coarse = case\n\n        u0 = np.array([y0, v0])\n        step_func = solver_map[method_name]\n\n        # Integrate with coarse step size h = T / N_coarse\n        u_num_h = integrate(step_func, u0, omega, T, N_coarse)\n\n        # Integrate with fine step size h/2 = T / (2*N_coarse)\n        u_num_h2 = integrate(step_func, u0, omega, T, 2 * N_coarse)\n\n        # Calculate exact solution at T\n        u_exact_T = exact_solution(T, u0, omega)\n\n        # Calculate errors for both resolutions\n        E_h = calculate_error(u_num_h, u_exact_T, omega)\n        E_h2 = calculate_error(u_num_h2, u_exact_T, omega)\n\n        # Estimate the observed convergence order\n        # Handle the case where E_h2 is zero to avoid division by zero\n        if E_h2 == 0.0:\n            p_obs = np.inf if E_h > 0.0 else 0.0\n        else:\n            p_obs = np.log2(E_h / E_h2)\n        \n        results.append(p_obs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3534397"}, {"introduction": "在验证了求解器的数值行为之后，我们转向一个更深刻的问题：数值离散化如何影响物理守恒定律。对于像引力这样的保守力所主导的天体物理系统，能量是一个基本守恒量，但显式数值积分方法通常会破坏这一定律。本练习通过分析最简单的显式方法——前向欧拉法——在开普勒二体问题中的单步能量误差，让您亲身体验这一现象，并从第一性原理推导该误差的主导项。[@problem_id:3534420]", "problem": "考虑笛卡尔坐标系中的引力二体问题，其中一个点质量在位于原点的固定主天体的引力作用下运动。使用无量纲单位，其中引力常数 $G$ 与主天体质量 $M$ 的乘积满足 $G M = 1$，并设运动粒子的质量为单位质量 $m = 1$。在时间 $t$ 的状态由位置 $x \\in \\mathbb{R}^2$ 和速度 $v \\in \\mathbb{R}^2$ 给出。作为常微分方程 (ODE) 的运动方程源于牛顿引力定律和运动学关系，即 $ \\dot{x} = v $ 和 $ \\dot{v} = - x / \\lVert x \\rVert^3 $。比机械能定义为 $ E(x,v) = \\frac{1}{2} \\lVert v \\rVert^2 - \\frac{1}{\\lVert x \\rVert} $，它沿着该常微分方程的精确解是恒定的。\n\n您的任务是从给定的初始状态 $(x_0, v_0)$ 开始，实现一个步长为 $h  0$ 的显式前向欧拉步：\n- 使用 $ x_1 = x_0 + h \\, v_0 $ 更新位置。\n- 使用 $ v_1 = v_0 + h \\left( - \\frac{x_0}{\\lVert x_0 \\rVert^3} \\right) $ 更新速度。\n然后计算精确的单步能量误差 $ \\Delta E_{\\mathrm{exact}}(h) = E(x_1, v_1) - E(x_0, v_0) $。\n\n此外，通过对与欧拉更新复合的能量泛函进行泰勒展开，从第一性原理推导出能量误差的主阶估计 $ \\Delta E_{\\mathrm{approx}}(h) $，并将其实现为 $h$ 和初始状态 $(x_0, v_0)$ 的函数。不要假设任何预先推导的公式；纯粹根据上述定义和基本定律推导此近似值。\n\n在每种情况下，使用以下初始状态和步长的测试套件，对给定的 $h$ 值评估 $ \\Delta E_{\\mathrm{exact}}(h) $ 和 $ \\Delta E_{\\mathrm{approx}}(h) $。所有量都必须视为无量纲量，且所有能量误差都必须以无量纲单位报告。\n\n- 情况1（单位半径的圆形轨道）：$ x_0 = [1, 0] $，$ v_0 = [0, 1] $，步长 $ h \\in \\{ 0, 10^{-4}, 10^{-2}, 10^{-1} \\} $。\n- 情况2（有界偏心轨道，混合径向-切向速度）：$ x_0 = [1, 0] $，$ v_0 = [0.2, 1.3] $，步长 $ h \\in \\{ 0, 10^{-4}, 10^{-2}, 5 \\cdot 10^{-2} \\} $。\n- 情况3（近抛物线能量，以径向为主）：$ x_0 = [1, 0] $，$ v_0 = [1.4, 0] $，步长 $ h \\in \\{ 0, 10^{-4}, 10^{-2}, 5 \\cdot 10^{-2} \\} $。\n- 情况4（小半径的强场圆形轨道）：$ x_0 = [0.1, 0] $，$ v_0 = [0, \\sqrt{10}] $，步长 $ h \\in \\{ 0, 10^{-4}, 10^{-3} \\} $。\n\n您的程序必须：\n- 按规定实现单步显式欧拉法。\n- 对每个提供的 $h$ 计算并返回 $ \\Delta E_{\\mathrm{exact}}(h) $ 和您推导出的 $ \\Delta E_{\\mathrm{approx}}(h) $。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个记录子列表。每条记录必须是列表 $ [h, \\Delta E_{\\mathrm{exact}}(h), \\Delta E_{\\mathrm{approx}}(h)] $。因此，整体输出结构必须是 $ [\\mathrm{case}_1, \\mathrm{case}_2, \\mathrm{case}_3, \\mathrm{case}_4] $，其中 $ \\mathrm{case}_i $ 是该情况的记录列表。所有条目必须是浮点数，且能量误差必须如上文所定义，使用无量纲单位。", "solution": "用户请求一个计算天体物理学问题的解决方案，该问题涉及使用前向欧拉方法解决引力二体问题。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n- **系统**：引力二体问题，质量为 $M$ 的主天体固定在原点，质量为 $m=1$ 的粒子在运动。\n- **单位**：无量纲，引力常数 $G$ 满足 $GM=1$。\n- **状态**：位置 $x \\in \\mathbb{R}^2$，速度 $v \\in \\mathbb{R}^2$。\n- **运动方程**：$\\dot{x} = v$, $\\dot{v} = -x / \\lVert x \\rVert^3$。\n- **比机械能**：$E(x, v) = \\frac{1}{2} \\lVert v \\rVert^2 - \\frac{1}{\\lVert x \\rVert}$，对于精确解而言，这是一个守恒量。\n- **数值方法**：步长为 $h$ 的单步显式前向欧拉法。\n  - 位置更新：$x_1 = x_0 + h v_0$。\n  - 速度更新：$v_1 = v_0 + h (-x_0 / \\lVert x_0 \\rVert^3)$。\n- **任务1**：计算精确单步能量误差 $\\Delta E_{\\mathrm{exact}}(h) = E(x_1, v_1) - E(x_0, v_0)$。\n- **任务2**：从第一性原理出发，使用泰勒展开推导并计算能量误差的主阶估计 $\\Delta E_{\\mathrm{approx}}(h)$。\n- **测试套件**：\n  - 情况1：$x_0 = [1, 0]$，$v_0 = [0, 1]$，$h \\in \\{0, 10^{-4}, 10^{-2}, 10^{-1}\\}$。\n  - 情况2：$x_0 = [1, 0]$，$v_0 = [0.2, 1.3]$，$h \\in \\{0, 10^{-4}, 10^{-2}, 5 \\cdot 10^{-2}\\}$。\n  - 情况3：$x_0 = [1, 0]$，$v_0 = [1.4, 0]$，$h \\in \\{0, 10^{-4}, 10^{-2}, 5 \\cdot 10^{-2}\\}$。\n  - 情况4：$x_0 = [0.1, 0]$，$v_0 = [0, \\sqrt{10}]$，$h \\in \\{0, 10^{-4}, 10^{-3}\\}$。\n- **输出格式**：一个表示列表的列表的列表的单行字符串：`[case1_results, case2_results, ...]`，其中 `case_i_results` 是 `[h, \\Delta E_{\\mathrm{exact}}(h), \\Delta E_{\\mathrm{approx}}(h)]` 记录的列表。\n\n**步骤2：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题以无量纲单位描述了开普勒问题，这是天体力学的基石。运动方程和比机械能的定义是标准且正确的。\n- **适定性**：问题定义明确。初始条件已指定，常微分方程是标准的，数值方法是显式的。每个任务都存在唯一的数值结果。初始位置 $x_0$ 绝不为零向量，从而避免了力项中的奇点。\n- **客观性**：问题以精确的数学和算法术语陈述，没有任何主观性或模糊性。\n- **缺陷分析**：\n  1. 问题不违反科学原理。\n  2. 问题与计算天体物理学中数值常微分方程求解器的主题直接相关。\n  3. 设置是完整且自洽的。\n  4. 使用无量纲单位是标准做法，并且在科学上是有效的。\n  5. 结构清晰，要求进行确定且可验证的计算。\n  6. 核心任务，即推导主阶误差，是数值分析中一项不平凡的练习，需要实质性的推理。\n  7. 结果是可以通过数值方法验证的。\n\n**步骤3：结论与行动**\n\n问题是有效的。将提供完整的解决方案。\n\n### 基于原理的设计与推导\n\n解决方案需要两个部分：一个欧拉步后能量误差的直接计算，以及此误差的主阶近似的推导和计算。\n\n**1. 欧拉步与精确能量误差计算**\n\n给定初始状态 $(x_0, v_0)$ 和步长 $h$，一个前向欧拉步后的状态是：\n$x_1 = x_0 + h v_0$\n$v_1 = v_0 + h a_0$，其中 $a_0 = -\\frac{x_0}{\\lVert x_0 \\rVert^3}$ 是初始加速度。\n\n初始能量为 $E_0 = E(x_0, v_0) = \\frac{1}{2} \\lVert v_0 \\rVert^2 - \\frac{1}{\\lVert x_0 \\rVert}$。\n一步之后的能量为 $E_1 = E(x_1, v_1) = \\frac{1}{2} \\lVert v_1 \\rVert^2 - \\frac{1}{\\lVert x_1 \\rVert}$。\n精确的单步能量误差定义为 $\\Delta E_{\\mathrm{exact}}(h) = E_1 - E_0$。这通过直接应用这些公式来实现。\n\n**2. 主阶能量误差估计的推导**\n\n我们为能量误差 $\\Delta E(h) = E(x_1(h), v_1(h)) - E(x_0, v_0)$ 寻求一个近似 $\\Delta E_{\\mathrm{approx}}(h)$，该近似能在 $h \\to 0$ 时捕捉其主阶行为。我们将通过在 $h=0$ 附近对 $E(x_1(h), v_1(h))$ 进行泰勒展开来找到它。\n\n在时间 $h$ 的能量是：\n$$E(h) = E(x_1, v_1) = \\frac{1}{2} \\lVert v_0 + h a_0 \\rVert^2 - \\frac{1}{\\lVert x_0 + h v_0 \\rVert}$$\n我们将每一项按 $h$ 的幂次展开。\n\n动能项：\n$$ \\frac{1}{2} \\lVert v_1 \\rVert^2 = \\frac{1}{2} (v_0 + h a_0) \\cdot (v_0 + h a_0) = \\frac{1}{2} (\\lVert v_0 \\rVert^2 + 2h(v_0 \\cdot a_0) + h^2 \\lVert a_0 \\rVert^2) $$\n$$ \\frac{1}{2} \\lVert v_1 \\rVert^2 = \\frac{1}{2}\\lVert v_0 \\rVert^2 + h (v_0 \\cdot a_0) + \\frac{h^2}{2} \\lVert a_0 \\rVert^2 $$\n\n势能项，$U(x) = -1/\\lVert x \\rVert$。我们在 $h=0$ 附近展开 $U(x_1) = U(x_0 + h v_0)$：\n$$ U(x_1) \\approx U(x_0) + h \\frac{d}{dh}U(x_0 + h v_0)\\bigg|_{h=0} + \\frac{h^2}{2} \\frac{d^2}{dh^2}U(x_0 + h v_0)\\bigg|_{h=0} $$\n一阶导数是：\n$$ \\frac{d}{dh} U(x_0 + h v_0) = \\nabla_x U(x_0 + h v_0) \\cdot v_0 $$\n其中 $\\nabla_x U = \\nabla_x(-\\lVert x \\rVert^{-1}) = x / \\lVert x \\rVert^3 = -a(x)$。\n在 $h=0$ 时，这得到 $\\nabla_x U(x_0) \\cdot v_0 = (x_0 / \\lVert x_0 \\rVert^3) \\cdot v_0 = -a_0 \\cdot v_0$。\n\n二阶导数是：\n$$ \\frac{d^2}{dh^2} U(x_0 + h v_0) = v_0^T H_U(x_0+hv_0) v_0 $$\n其中 $H_U$ 是 $U(x)$ 的海森矩阵。\n$H_U = \\frac{\\partial}{\\partial x} \\left( \\frac{x}{\\lVert x \\rVert^3} \\right) = \\frac{I}{\\lVert x \\rVert^3} - \\frac{3 x x^T}{\\lVert x \\rVert^5}$。\n在 $h=0$ 处求值：\n$$ \\frac{d^2}{dh^2}\\bigg|_{h=0} = v_0^T H_U(x_0) v_0 = v_0^T \\left( \\frac{I}{\\lVert x_0 \\rVert^3} - \\frac{3 x_0 x_0^T}{\\lVert x_0 \\rVert^5} \\right) v_0 = \\frac{\\lVert v_0 \\rVert^2}{\\lVert x_0 \\rVert^3} - \\frac{3(x_0 \\cdot v_0)^2}{\\lVert x_0 \\rVert^5} $$\n\n合并所有项得到总能量 $E(h)$：\n$$ E(h) = \\left( \\frac{1}{2}\\lVert v_0 \\rVert^2 + h (v_0 \\cdot a_0) + \\frac{h^2}{2} \\lVert a_0 \\rVert^2 \\right) + \\left( U(x_0) + h (-a_0 \\cdot v_0) + \\frac{h^2}{2} \\left[ \\frac{\\lVert v_0 \\rVert^2}{\\lVert x_0 \\rVert^3} - \\frac{3(x_0 \\cdot v_0)^2}{\\lVert x_0 \\rVert^5} \\right] \\right) + O(h^3) $$\n\n按 $h$ 的幂次分组各项：\n- $h^0$: $\\frac{1}{2}\\lVert v_0 \\rVert^2 + U(x_0) = E(x_0, v_0) = E_0$。\n- $h^1$: $h (v_0 \\cdot a_0 - a_0 \\cdot v_0) = 0$。$O(h)$ 项消失了。这是该系统和积分器的一个已知属性。\n- $h^2$: $\\frac{h^2}{2} \\left( \\lVert a_0 \\rVert^2 + \\frac{\\lVert v_0 \\rVert^2}{\\lVert x_0 \\rVert^3} - \\frac{3(x_0 \\cdot v_0)^2}{\\lVert x_0 \\rVert^5} \\right)$。\n\n能量误差为 $\\Delta E(h) = E(h) - E_0$。主阶项是 $O(h^2)$ 项。因此，我们的近似为：\n$$ \\Delta E_{\\mathrm{approx}}(h) = \\frac{h^2}{2} \\left( \\lVert a_0 \\rVert^2 + \\frac{\\lVert v_0 \\rVert^2}{\\lVert x_0 \\rVert^3} - \\frac{3(x_0 \\cdot v_0)^2}{\\lVert x_0 \\rVert^5} \\right) $$\n代入 $\\lVert a_0 \\rVert^2 = \\lVert -x_0/\\lVert x_0 \\rVert^3 \\rVert^2 = 1/\\lVert x_0 \\rVert^4$：\n$$ \\Delta E_{\\mathrm{approx}}(h) = \\frac{h^2}{2} \\left( \\frac{1}{\\lVert x_0 \\rVert^4} + \\frac{\\lVert v_0 \\rVert^2}{\\lVert x_0 \\rVert^3} - \\frac{3(x_0 \\cdot v_0)^2}{\\lVert x_0 \\rVert^5} \\right) $$\n这个表达式可以直接使用初始状态 $(x_0, v_0)$ 来实现。\n\n**3. 实现**\n\n该实现将包含一个函数，该函数为每个测试用例遍历给定的步长 $h$。对于每个 $h$，它使用上述公式计算 $\\Delta E_{\\mathrm{exact}}(h)$ 和 $\\Delta E_{\\mathrm{approx}}(h)$。对于 $h=0$ 的情况需要特殊处理，此时两个误差都恰好为 $0$。所有用例的结果被收集并格式化为指定的字符串格式。使用 `numpy` 进行高效的向量运算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational two-body problem for given test cases using a single\n    forward Euler step, calculating both the exact and approximate energy errors.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'x0': [1.0, 0.0], 'v0': [0.0, 1.0], 'hs': [0.0, 1e-4, 1e-2, 1e-1]},\n        {'x0': [1.0, 0.0], 'v0': [0.2, 1.3], 'hs': [0.0, 1e-4, 1e-2, 5e-2]},\n        {'x0': [1.0, 0.0], 'v0': [1.4, 0.0], 'hs': [0.0, 1e-4, 1e-2, 5e-2]},\n        {'x0': [0.1, 0.0], 'v0': [0.0, np.sqrt(10)], 'hs': [0.0, 1e-4, 1e-3]},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        x0_list, v0_list, hs = case['x0'], case['v0'], case['hs']\n        x0 = np.array(x0_list, dtype=np.float64)\n        v0 = np.array(v0_list, dtype=np.float64)\n        \n        case_results = []\n        for h in hs:\n            if h == 0.0:\n                # For h=0, there is no step, so the error is zero.\n                case_results.append([0.0, 0.0, 0.0])\n                continue\n\n            # --- Initial State Calculations ---\n            r0_norm = np.linalg.norm(x0)\n            v0_norm_sq = np.dot(v0, v0)\n            \n            # Initial energy E_0\n            E0 = 0.5 * v0_norm_sq - 1.0 / r0_norm\n            \n            # --- Forward Euler Step ---\n            # Initial acceleration a_0 = -x_0 / ||x_0||^3\n            a0 = -x0 / r0_norm**3\n            \n            # Update position and velocity\n            x1 = x0 + h * v0\n            v1 = v0 + h * a0\n            \n            # --- Exact One-step Energy Error Calculation ---\n            r1_norm = np.linalg.norm(x1)\n            v1_norm_sq = np.dot(v1, v1)\n\n            # Energy after one step E_1\n            E1 = 0.5 * v1_norm_sq - 1.0 / r1_norm\n            \n            # Exact error Delta_E_exact = E_1 - E_0\n            delta_E_exact = E1 - E0\n            \n            # --- Leading-order Approximate Energy Error Calculation ---\n            # The derived formula is:\n            # Delta_E_approx = (h^2/2) * ( 1/r0^4 + ||v0||^2/r0^3 - 3*(x0.v0)^2/r0^5 )\n            \n            x0_dot_v0 = np.dot(x0, v0)\n            \n            term1 = 1.0 / r0_norm**4\n            term2 = v0_norm_sq / r0_norm**3\n            term3 = -3.0 * (x0_dot_v0**2) / r0_norm**5\n            \n            delta_E_approx = 0.5 * h**2 * (term1 + term2 + term3)\n\n            # Store the record for this step size h\n            case_results.append([h, delta_E_exact, delta_E_approx])\n        \n        all_results.append(case_results)\n\n    # Format the output string to match the required specifications, specifically\n    # creating a JSON-like representation without spaces.\n    case_strs = []\n    for case_res in all_results:\n        record_strs = []\n        for record in case_res:\n            # record is [h, delta_E_exact, delta_E_approx]\n            record_strs.append(f\"[{record[0]},{record[1]},{record[2]}]\")\n        case_strs.append(f\"[{','.join(record_strs)}]\")\n            \n    final_output_str = f\"[{','.join(case_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3534420"}, {"introduction": "理解了基本方法的误差来源后，一个自然的问题就是如何改进。本练习将比较几种不同阶数的求解器在模拟轨道运动时的性能，重点关注另一个在中心力场中至关重要的守恒量：角动量。通过在一个椭圆开普勒轨道上对比一阶欧拉法、二阶中点法和四阶经典龙格—库塔法引起的角动量漂移，您将直观地认识到高阶方法在长期积分中保持物理精度的巨大优势。[@problem_id:3534434]", "problem": "考虑平面二体（开普勒）问题，其中一个单位点质量在牛顿引力作用下绕一个固定的中心质量体运行。使用无量纲单位，其中引力常数乘以中心质量为 $G M = 1$。状态是满足以下一阶常微分方程 (ODE) 组的序对 $\\left(\\mathbf{r}(t), \\mathbf{v}(t)\\right) \\in \\mathbb{R}^2 \\times \\mathbb{R}^2$\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\qquad \\frac{d\\mathbf{v}}{dt} = - \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}.\n$$\n关于平面外轴的比角动量（单位质量的角动量）为\n$$\n\\ell(t) = \\left(\\mathbf{r}(t) \\times \\mathbf{v}(t)\\right)_z = x(t)\\,v_y(t) - y(t)\\,v_x(t).\n$$\n根据牛顿第二定律和引力的中心力性质，力矩为零，因此在连续动力学中 $\\ell(t)$ 是精确守恒的。在有限精度计算和使用离散时间单步 ODE 积分器时，$\\ell(t)$ 可能会发生漂移。\n\n您的任务是构建一个数值实验，比较在使用三种单步方法（显式欧拉法、显式中点法（二阶龙格-库塔法）和经典的四阶龙格-库塔法（简写为四阶龙格-库塔法，或 RK4））以相同的固定步长 $h$ 对开普勒椭圆轨道进行积分时，$\\ell(t)$ 的漂移情况。该实验必须作为一个完整的、可运行的程序来实现。\n\n使用以下初始条件设置。将半长轴固定为 $a = 1$，并将粒子置于 $x$ 轴上的近心点，\n$$\n\\mathbf{r}(0) = \\big(a(1-e),\\, 0\\big),\n$$\n初始速度与轨道在正 $y$ 方向相切，\n$$\n\\mathbf{v}(0) = \\left(0,\\, \\sqrt{\\frac{1+e}{a(1-e)}}\\right).\n$$\n在所选的无量纲单位中，$G M = 1$ 且 $a = 1$，轨道周期为 $T = 2\\pi$。对于给定的轨道数 $K \\in \\mathbb{N}$ 和固定的步长 $h  0$，积分 $N = \\left\\lfloor \\frac{K T}{h} \\right\\rfloor$ 步（不要为了精确达到 $K T$ 而走部分步长；精确使用 $N$ 步，步长为 $h$）。对于每个积分器，记录积分过程中的最大相对角动量漂移，\n$$\n\\varepsilon_{\\max} \\equiv \\max_{0 \\leq n \\leq N} \\frac{\\left|\\ell_n - \\ell_0\\right|}{\\left|\\ell_0\\right|},\n$$\n其中 $\\ell_n$ 是经过 $n$ 步后从数值状态计算出的离散角动量，$\\ell_0$ 是从初始状态计算出的。\n\n将这三种积分器实现为一阶系统 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 的单步方法，其中 $\\mathbf{y} = \\left(x, y, v_x, v_y\\right)$，$\\mathbf{f}(\\mathbf{y}) = \\left(v_x, v_y, -x/r^3, -y/r^3\\right)$，而 $r = \\sqrt{x^2 + y^2}$。在每个测试案例中，对所有三种积分器使用相同的固定步长 $h$。\n\n所有量都是无量纲的；不需要物理单位。所有角度（如适用）均以弧度为单位。\n\n测试套件。对以下四个测试案例运行实验，每个案例由偏心率 $e$、步长 $h$ 和轨道数 $K$ 指定：\n\n- 案例 1：$e = 0$，$h = 0.01$，$K = 1$。\n- 案例 2：$e = 0.6$，$h = 0.01$，$K = 1$。\n- 案例 3：$e = 0.6$，$h = 0.03$，$K = 5$。\n- 案例 4：$e = 0.9$，$h = 0.005$，$K = 1$。\n\n对于每个案例，计算并返回一个包含三个浮点数的列表 $[\\varepsilon_{\\max}^{\\text{Euler}}, \\varepsilon_{\\max}^{\\text{Midpoint}}, \\varepsilon_{\\max}^{\\text{RK4}}]$。\n\n最终输出格式。您的程序应生成单行输出，其中包含所有四个案例的结果，形式为一个逗号分隔的列表，该列表包含四个按案例顺序排列的子列表，并用方括号括起来。也就是说，打印的字符串必须具有以下形式\n$[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$\n其中每个 $a_j, b_j, c_j$ 都是一个浮点数。不应打印任何额外的文本或行。", "solution": "用户提供的问题已经过验证，被确定为一个提法恰当、有科学依据且完整的任务。其目标是研究在使用三种不同的单步常微分方程 (ODE) 求解器对开普勒问题进行积分时，比角动量的数值守恒情况。\n\n该问题由二维中心引力场中点质量的运动方程定义。在引力参数 $G M = 1$ 的无量纲单位中，系统的状态由位置向量 $\\mathbf{r}(t) = (x(t), y(t))$ 和速度向量 $\\mathbf{v}(t) = (v_x(t), v_y(t))$ 给出。动力学由以下一阶 ODE 系统控制：\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\qquad \\frac{d\\mathbf{v}}{dt} = - \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}\n$$\n为了便于数值积分，我们将状态表示为 $\\mathbb{R}^4$ 中的单个向量 $\\mathbf{y}(t) = (x(t), y(t), v_x(t), v_y(t))^T$。该 ODE 系统可以写成紧凑形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，其中函数 $\\mathbf{f}: \\mathbb{R}^4 \\to \\mathbb{R}^4$ 定义为：\n$$\n\\mathbf{f}(\\mathbf{y}) = \\begin{pmatrix} v_x \\\\ v_y \\\\ -x / (\\sqrt{x^2+y^2})^3 \\\\ -y / (\\sqrt{x^2+y^2})^3 \\end{pmatrix}\n$$\n比角动量 $\\ell(t)$ 是一个标量，定义为位置和速度叉积的平面外分量：\n$$\n\\ell(t) = (\\mathbf{r}(t) \\times \\mathbf{v}(t))_z = x(t)\\,v_y(t) - y(t)\\,v_x(t)\n$$\n在精确的解析解中，引力的中心力性质保证了力矩为零，因此 $\\ell(t)$ 是一个守恒量。然而，数值积分方法会引入离散化误差，可能导致该值随时间漂移。\n\n该数值实验是为半长轴 $a=1$ 的椭圆轨道设置的。初始位置在正 $x$ 轴上的近心点，$\\mathbf{r}(0) = (1-e, 0)$，其中 $e$ 是偏心率。初始速度垂直于位置向量，$\\mathbf{v}(0) = \\left(0, \\sqrt{\\frac{1+e}{1-e}}\\right)$。因此，初始比角动量 $\\ell_0$ 为：\n$$\n\\ell_0 = x(0) v_y(0) - y(0) v_x(0) = (1-e) \\sqrt{\\frac{1+e}{1-e}} - 0 = \\sqrt{(1-e)(1+e)} = \\sqrt{1-e^2}\n$$\n由于所提供的测试案例使用 $e  1$，所以 $\\ell_0$ 是非零的。对于 $a=1$ 和 $GM=1$，轨道周期为 $T=2\\pi$。积分在 $K$ 个轨道上进行，总步数为 $N = \\lfloor 2\\pi K / h \\rfloor$，使用固定的步长 $h$。\n\n我们将比较三种显式单步方法。设 $\\mathbf{y}_n$ 是在时间 $t_n = n h$ 时对 $\\mathbf{y}(t_n)$ 的数值近似。下一个状态 $\\mathbf{y}_{n+1}$ 的计算方式如下：\n\n1.  **显式欧拉法 (一阶)**：该方法通过在区间开始处沿切线方向走一步来近似求解。\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{f}(\\mathbf{y}_n)\n    $$\n\n2.  **显式中点法 (二阶龙格-库塔法, RK2)**：该方法通过使用在区间中点处评估的斜率来提高精度。\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\\right) \\\\\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{k}_2\n    \\end{aligned}\n    $$\n\n3.  **经典龙格-库塔法 (四阶, RK4)**：这是一种广泛使用的方法，通过使用区间内四个斜率估计值的加权平均来获得更高的精度。\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\\right) \\\\\n    \\mathbf{k}_3 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2\\right) \\\\\n    \\mathbf{k}_4 = \\mathbf{f}\\left(\\mathbf{y}_n + h \\mathbf{k}_3\\right) \\\\\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    \\end{aligned}\n    $$\n\n对于每个积分器和每个测试案例，积分将执行 $N$ 步。在每一步 $n$，从状态 $\\mathbf{y}_n$ 计算数值角动量 $\\ell_n$。性能指标是在整个积分过程中的最大相对角动量漂移：\n$$\n\\varepsilon_{\\max} = \\max_{0 \\leq n \\leq N} \\frac{\\left|\\ell_n - \\ell_0\\right|}{\\left|\\ell_0\\right|}\n$$\n最终输出将包含在四个指定的测试案例中，针对三种积分器计算出的 $\\varepsilon_{\\max}$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Kepler problem for specified test cases, comparing the numerical drift\n    in angular momentum for Euler, Midpoint (RK2), and classical RK4 methods.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (eccentricity, step_size, num_orbits)\n    test_cases = [\n        (0.0, 0.01, 1),\n        (0.6, 0.01, 1),\n        (0.6, 0.03, 5),\n        (0.9, 0.005, 1),\n    ]\n\n    # Nondimensional gravitational parameter and semi-major axis.\n    GM = 1.0\n    a = 1.0\n\n    def f_ode(y):\n        \"\"\"\n        The derivative function dy/dt = f(y) for the Kepler problem.\n        y is the state vector [x, y_pos, v_x, v_y].\n        \"\"\"\n        x, y_pos, v_x, v_y = y\n        # The position vector magnitude r = ||r||.\n        r_norm = np.sqrt(x**2 + y_pos**2)\n        # Avoid division by zero, though not expected for these elliptical orbits.\n        if r_norm == 0:\n            return np.zeros(4)\n        \n        r_norm_cubed = r_norm**3\n        \n        # Acceleration components a = -GM * r / ||r||^3. With GM=1.\n        a_x = -x / r_norm_cubed\n        a_y = -y_pos / r_norm_cubed\n        \n        return np.array([v_x, v_y, a_x, a_y])\n\n    def euler_step(f, y, h):\n        \"\"\"Performs a single step using the explicit Euler method.\"\"\"\n        return y + h * f(y)\n\n    def midpoint_step(f, y, h):\n        \"\"\"Performs a single step using the explicit Midpoint (RK2) method.\"\"\"\n        k1 = f(y)\n        k2 = f(y + 0.5 * h * k1)\n        return y + h * k2\n\n    def rk4_step(f, y, h):\n        \"\"\"Performs a single step using the classical RK4 method.\"\"\"\n        k1 = f(y)\n        k2 = f(y + 0.5 * h * k1)\n        k3 = f(y + 0.5 * h * k2)\n        k4 = f(y + h * k3)\n        return y + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def get_angular_momentum(y):\n        \"\"\"Computes the specific angular momentum from the state vector.\"\"\"\n        x, y_pos, v_x, v_y = y\n        return x * v_y - y_pos * v_x\n\n    all_results = []\n\n    for e, h, K in test_cases:\n        # Orbital period for a=1, GM=1 is T = 2*pi.\n        T = 2.0 * np.pi\n        total_time = K * T\n        num_steps = int(np.floor(total_time / h))\n\n        # Initial conditions at pericenter.\n        r0_x = a * (1.0 - e)\n        # The pericenter velocity for GM=1, a=1\n        v0_y = np.sqrt((1.0 + e) / (1.0 - e))\n        y0 = np.array([r0_x, 0.0, 0.0, v0_y])\n\n        l0 = get_angular_momentum(y0)\n        \n        l0_abs = np.abs(l0)\n        if l0_abs == 0.0:\n            # For a radial trajectory (e=1), drift is ill-defined. This won't happen for test cases.\n            l0_abs = 1.0 # Placeholder to prevent division by zero.\n\n        integrators = [\n            (\"Euler\", euler_step),\n            (\"Midpoint\", midpoint_step),\n            (\"RK4\", rk4_step),\n        ]\n        \n        case_results = []\n        for name, step_func in integrators:\n            y = np.copy(y0)\n            max_rel_drift = 0.0\n\n            for _ in range(num_steps):\n                y = step_func(f_ode, y, h)\n                l_n = get_angular_momentum(y)\n                rel_drift = np.abs(l_n - l0) / l0_abs\n                if rel_drift > max_rel_drift:\n                    max_rel_drift = rel_drift\n            \n            case_results.append(max_rel_drift)\n        \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # [[a1,b1,c1],[a2,b2,c2],[a3,b3,c3],[a4,b4,c4]]\n    sublist_strs = [f\"[{','.join(map(str, sub))}]\" for sub in all_results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```", "id": "3534434"}]}