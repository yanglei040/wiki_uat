{"hands_on_practices": [{"introduction": "此练习将引导您分析数值方法的稳定性，这是解决天体物理学中常见的刚性方程的一项关键技能。通过推导二阶后向差分公式（BDF2）的稳定性区域，您将更深入地理解为何某些隐式方法对于模拟恒星核心闪光等问题至关重要，以及稳定性特性如何决定步长等实际选择。这项实践 [@problem_id:3528288] 将理论分析与天体物理学的实际挑战联系起来。", "problem": "在刚性初值问题中，使用全隐式后向差分格式 (BDF) 方法来推进 Dahlquist 测试方程 $y'(t) = \\lambda y(t)$ 的求解，其中 $\\lambda \\in \\mathbb{C}$ 代表计算天体物理模型中线性化算子的谱。考虑二阶后向差分格式 (BDF2)，其定义为用二阶后向差分近似新时间层 $t_{n+1}$ 处的导数，并使其等于在 $t_{n+1}$ 处计算的右端项：\n$$\\frac{3 y_{n+1} - 4 y_n + y_{n-1}}{2 h} = f(t_{n+1}, y_{n+1}),$$\n其中 $h$ 是恒定步长，对于测试方程，$f(t, y) = \\lambda y$。对于一个线性多步法，其绝对稳定区域是复数 $z = h \\lambda$ 的集合，使得由测试方程导出的递推关系的所有特征根的模都严格小于1，其中零稳定性允许在 $z=0$ 处存在一个值为1的单根。\n\n任务1：通过假设存在一个模为单位1的特征根，推导 BDF2 绝对稳定边界的精确参数表达式，并将边界表示为 $z(\\varphi)$，其中 $\\varphi \\in [0, 2\\pi)$ 是以弧度为单位的角度。\n\n任务2：在简并核闪模拟中，扩散主导的热响应可以局域线性化为 $y'(t) = -\\Lambda y(t)$，其中 $\\Lambda > 0$，反映了在时间尺度 $\\Lambda^{-1}$ 上温度扰动的强阻尼。为保证操作鲁棒性，要求此刚性模式的每步数值放大因子的模至多为 $r = 0.2$。利用 BDF2 在测试方程上的递推关系，求出保证对实负数 $z = - h \\Lambda$ 满足此每步阻尼要求的最小步长 $h_{\\min}$。计算当 $\\Lambda = 2.0 \\times 10^{3}\\ \\text{s}^{-1}$ 时的 $h_{\\min}$，并将您的数值答案四舍五入到四位有效数字。用秒表示 $h_{\\min}$。\n\n您的最终答案必须包括：\n- 稳定边界关于弧度 $\\varphi$ 的精确解析表达式 $z(\\varphi)$。\n- 四舍五入到四位有效数字的 $h_{\\min}$ 的数值（以秒为单位）。", "solution": "该问题已经过验证，并被确定为一个应用于计算天体物理学的、适定的、有科学依据的数值分析问题。\n\n该问题分为两个任务。第一个任务是推导二阶后向差分格式 (BDF2) 的绝对稳定边界。第二个任务是应用一个特定的阻尼要求，来确定给定刚性常微分方程 (ODE) 的最小步长。\n\n**任务1：绝对稳定边界的推导**\n\nBDF2 方法由以下递推关系给出：\n$$ \\frac{3 y_{n+1} - 4 y_n + y_{n-1}}{2 h} = f(t_{n+1}, y_{n+1}) $$\n我们使用 Dahlquist 测试方程 $y'(t) = \\lambda y(t)$（其中 $\\lambda \\in \\mathbb{C}$）来分析此方法。对于该方程，右端项为 $f(t_{n+1}, y_{n+1}) = \\lambda y_{n+1}$。将此代入 BDF2 公式可得：\n$$ \\frac{3 y_{n+1} - 4 y_n + y_{n-1}}{2 h} = \\lambda y_{n+1} $$\n乘以 $2h$ 并按时间步重排各项可得：\n$$ 3 y_{n+1} - 4 y_n + y_{n-1} = 2h\\lambda y_{n+1} $$\n$$ (3 - 2h\\lambda) y_{n+1} - 4 y_n + y_{n-1} = 0 $$\n令 $z = h\\lambda$。该递推关系可写为：\n$$ (3 - 2z) y_{n+1} - 4 y_n + y_{n-1} = 0 $$\n为求此线性常系数差分方程的特征根，我们代入拟设 $y_k = \\xi^k$：\n$$ (3 - 2z) \\xi^{n+1} - 4 \\xi^n + \\xi^{n-1} = 0 $$\n两边同除以 $\\xi^{n-1}$（假设 $\\xi \\neq 0$），我们得到放大因子 $\\xi$ 的特征多项式：\n$$ (3 - 2z) \\xi^2 - 4 \\xi + 1 = 0 $$\n绝对稳定边界是 $z \\in \\mathbb{C}$ 的集合，其中至少有一个特征根 $\\xi$ 的模为1。因此，我们设 $\\xi = \\exp(i\\varphi)$，其中 $\\varphi \\in [0, 2\\pi)$ 是一个实值参数。将此代入特征方程：\n$$ (3 - 2z) (\\exp(i\\varphi))^2 - 4 \\exp(i\\varphi) + 1 = 0 $$\n$$ (3 - 2z) \\exp(i2\\varphi) - 4 \\exp(i\\varphi) + 1 = 0 $$\n现在我们求解 $z$ 作为 $\\varphi$ 的函数：\n$$ 3 \\exp(i2\\varphi) - 2z \\exp(i2\\varphi) - 4 \\exp(i\\varphi) + 1 = 0 $$\n$$ 2z \\exp(i2\\varphi) = 3 \\exp(i2\\varphi) - 4 \\exp(i\\varphi) + 1 $$\n$$ z(\\varphi) = \\frac{3 \\exp(i2\\varphi) - 4 \\exp(i\\varphi) + 1}{2 \\exp(i2\\varphi)} $$\n简化此表达式可得到稳定边界的参数形式：\n$$ z(\\varphi) = \\frac{3}{2} - \\frac{4 \\exp(i\\varphi)}{2 \\exp(i2\\varphi)} + \\frac{1}{2 \\exp(i2\\varphi)} $$\n$$ z(\\varphi) = \\frac{3}{2} - 2 \\exp(-i\\varphi) + \\frac{1}{2} \\exp(-i2\\varphi) $$\n这就是所求的 BDF2 方法的绝对稳定边界的解析表达式。\n\n**任务2：满足阻尼要求的最小步长**\n\n在第二个任务中，我们考虑特定的常微分方程 $y'(t) = -\\Lambda y(t)$，其中 $\\Lambda > 0$。这对应于 $\\lambda = -\\Lambda$ 的 Dahlquist 测试方程。因此，参数 $z$ 是实数且为负：$z = h\\lambda = -h\\Lambda$。\n\n特征方程仍为 $(3 - 2z) \\xi^2 - 4 \\xi + 1 = 0$。代入 $z = -h\\Lambda$：\n$$ (3 + 2h\\Lambda) \\xi^2 - 4 \\xi + 1 = 0 $$\n此二次方程的根 $\\xi$ 即为每步的放大因子：\n$$ \\xi = \\frac{-(-4) \\pm \\sqrt{(-4)^2 - 4(3+2h\\Lambda)(1)}}{2(3+2h\\Lambda)} = \\frac{4 \\pm \\sqrt{16 - 12 - 8h\\Lambda}}{2(3+2h\\Lambda)} = \\frac{4 \\pm \\sqrt{4 - 8h\\Lambda}}{2(3+2h\\Lambda)} $$\n$$ \\xi = \\frac{2 \\pm \\sqrt{1 - 2h\\Lambda}}{3+2h\\Lambda} $$\n根的性质取决于判别式 $1 - 2h\\Lambda$ 的符号。令 $x = h\\Lambda$。由于 $h>0$ 且 $\\Lambda>0$，我们有 $x>0$。\n\n情况1：$1 - 2x \\ge 0$，这意味着 $0  x \\le \\frac{1}{2}$。\n在这种情况下，根是实数。两个根是 $\\xi_1 = \\frac{2 + \\sqrt{1 - 2x}}{3+2x}$ 和 $\\xi_2 = \\frac{2 - \\sqrt{1 - 2x}}{3+2x}$。主导根（模最大的根）是 $\\xi_1$。令 $G(z)$ 为放大因子，则 $|G(z)| = |\\xi_1|$。\n要求是放大因子的模最大为 $r=0.2$。我们来分析函数 $g(x) = \\frac{2 + \\sqrt{1 - 2x}}{3+2x}$ 在 $x \\in (0, \\frac{1}{2}]$ 上的行为。\n当 $x \\to 0$ 时，$g(x) \\to \\frac{2+\\sqrt{1}}{3} = 1$。\n当 $x = \\frac{1}{2}$ 时，$g(\\frac{1}{2}) = \\frac{2+0}{3+1} = \\frac{1}{2} = 0.5$。\n函数 $g(x)$ 在此区间上是单调递减的。由于其最小值为0.5，大于所要求的最大值0.2，因此在 $0  h\\Lambda \\le \\frac{1}{2}$ 的范围内，不存在满足阻尼要求的 $h$ 的解。\n\n情况2：$1 - 2x  0$，这意味着 $x > \\frac{1}{2}$。\n在这种情况下，根是一对共轭复数：\n$$ \\xi = \\frac{2 \\pm i\\sqrt{2x - 1}}{3+2x} $$\n两个根的模是相同的：\n$$ |G(z)| = |\\xi| = \\sqrt{\\left(\\frac{2}{3+2x}\\right)^2 + \\left(\\frac{\\sqrt{2x-1}}{3+2x}\\right)^2} = \\sqrt{\\frac{4 + (2x-1)}{(3+2x)^2}} = \\sqrt{\\frac{3+2x}{(3+2x)^2}} = \\frac{1}{\\sqrt{3+2x}} $$\n阻尼要求是 $|G(z)| \\le r = 0.2$。代回 $x = h\\Lambda$：\n$$ \\frac{1}{\\sqrt{3+2h\\Lambda}} \\le 0.2 $$\n为了求解 $h$，我们可以对两边进行平方（因为两边都是正数）：\n$$ \\frac{1}{3+2h\\Lambda} \\le (0.2)^2 = 0.04 $$\n$$ 1 \\le 0.04(3+2h\\Lambda) $$\n$$ \\frac{1}{0.04} \\le 3+2h\\Lambda $$\n$$ 25 \\le 3+2h\\Lambda $$\n$$ 22 \\le 2h\\Lambda $$\n$$ h\\Lambda \\ge 11 $$\n这意味着步长 $h$ 必须满足 $h \\ge \\frac{11}{\\Lambda}$。这个条件 $h\\Lambda \\ge 11$ 与本情况的假设 $h\\Lambda > \\frac{1}{2}$ 是一致的。\n保证所需阻尼的最小步长 $h_{\\min}$ 是：\n$$ h_{\\min} = \\frac{11}{\\Lambda} $$\n给定 $\\Lambda = 2.0 \\times 10^3\\ \\text{s}^{-1}$。代入此值：\n$$ h_{\\min} = \\frac{11}{2.0 \\times 10^3\\ \\text{s}^{-1}} = 5.5 \\times 10^{-3}\\ \\text{s} $$\n题目要求将答案四舍五入到四位有效数字。\n$$ h_{\\min} = 5.500 \\times 10^{-3}\\ \\text{s} $$\n\n最终答案包括 $z(\\varphi)$ 的表达式和 $h_{\\min}$ 的数值。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{3}{2} - 2\\exp(-i\\varphi) + \\frac{1}{2}\\exp(-i2\\varphi)  5.500 \\times 10^{-3}\n\\end{pmatrix}\n}\n$$", "id": "3528288"}, {"introduction": "许多物理系统都遵循守恒律，但数值求解器并非总能完美地遵守它们。此练习 [@problem_id:3528297] 通过模拟天体物理盘中一个环的进动来探讨这一问题，其中角动量的大小理应是守恒的。您将诊断求解器的容差如何导致非物理的“数值扩散”，这是评估计算结果有效性的一个重要教训。", "problem": "考虑一个几何薄、差动旋转的天体物理盘中的环，其局部单位倾斜方向由一个三维角动量方向向量 $\\mathbf{l}(t;r)$ 建模，该向量是时间 $t$ 和柱面半径 $r$ 的函数。在简化的力矩规定下，方向演化由以下一阶常微分方程 (ODE) 初值问题 (IVP) 近似：\n$$\n\\frac{d\\mathbf{l}}{dt}(t;r)=\\boldsymbol{\\Omega}(r)\\times \\mathbf{l}(t;r)-\\nu\\,\\mathbf{l}(t;r),\n$$\n其中 $\\boldsymbol{\\Omega}(r)$ 是一个给定的局部进动向量，$\\nu$ 是一个线性阻尼系数，$\\times$ 表示向量叉乘。为确保计算天体物理学中的具体性和科学真实性，取\n$$\n\\boldsymbol{\\Omega}(r)=\\Omega_0\\left(\\frac{r}{r_0}\\right)^{-q}\\,\\hat{\\mathbf{z}},\n$$\n其中 $\\Omega_0$ 是一个常数，$r_0$ 是一个参考半径，$q$ 是一个无量纲指数，$\\hat{\\mathbf{z}}$ 是沿 $z$ 轴的单位向量。这些量应使用以下物理单位：$\\Omega_0$ 的单位是弧度/秒，$r$ 和 $r_0$ 的单位是米，$t$ 的单位是秒，$\\nu$ 的单位是 1/秒。角度以弧度为单位。\n\n仅从与计算天体物理学和常微分方程数学分析相关的基本定律和核心定义出发，即 (i) 力矩引起的进动与角动量方向正交，(ii) 叉乘的定义，以及 (iii) 线性阻尼的性质，实现上述初值问题的数值积分器，并设计诊断工具，以评估纯进动条件下模长 $|\\mathbf{l}(t;r)|$ 的守恒性，并在求解器容差放宽时量化倾斜的数值扩散。\n\n使用以下测试套件，它涵盖了一个一般情况、一个阻尼情况和一个容差压力情况，所有情况都使用相同的盘环半径和进动剖面。在所有情况下，初始条件为\n$$\n\\mathbf{l}(0;r)=\\mathbf{l}_0=\\begin{bmatrix} \\frac{3}{5} \\\\ \\frac{4}{5} \\\\ 0 \\end{bmatrix},\n$$\n使得 $|\\mathbf{l}_0|$ 恰好为1。\n\n- 测试用例1（一般“理想路径”进动）：$r=10^{10}\\,\\mathrm{m}$，$r_0=10^{10}\\,\\mathrm{m}$，$\\Omega_0=10^{-5}\\,\\mathrm{rad/s}$，$q=1$，$\\nu=0$，最终时间 $t_f=10^{6}\\,\\mathrm{s}$。使用相对容差 $r_{\\mathrm{tol}}=10^{-9}$ 和绝对容差 $a_{\\mathrm{tol}}=10^{-12}$ 进行积分。计算在区间 $[0,t_f]$ 上模长与1的最大绝对偏差，\n$$\n\\Delta_1=\\max_{t\\in[0,t_f]}\\left||\\mathbf{l}(t;r)|-1\\right|,\n$$\n采样足够密集以有意义地解析轨迹。\n\n- 测试用例2（阻尼一致性检查）：与测试用例1相同的 $r$、$r_0$、$\\Omega_0$ 和 $q$，但 $\\nu=10^{-6}\\,\\mathrm{s}^{-1}$ 且 $t_f=10^{6}\\,\\mathrm{s}$。使用 $r_{\\mathrm{tol}}=10^{-9}$ 和 $a_{\\mathrm{tol}}=10^{-12}$ 进行积分。计算数值得到的最终模长与根据线性阻尼得出的解析模长之间的绝对差，\n$$\n\\Delta_2=\\left||\\mathbf{l}(t_f;r)|-e^{-\\nu t_f}\\right|.\n$$\n\n- 测试用例3（放宽容差下的数值扩散）：与测试用例1相同，但 $r_{\\mathrm{tol}}=10^{-3}$ 且 $a_{\\mathrm{tol}}=10^{-6}$。计算最终时刻模长与1的绝对偏差，\n$$\n\\Delta_3=\\left||\\mathbf{l}(t_f;r)|-1\\right|.\n$$\n\n您的程序必须对每个测试用例使用一致的算法方法进行数值积分，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\Delta_1,\\Delta_2,\\Delta_3]$。每个 $\\Delta_i$ 必须以国际单位制 (SI) 中的实值小数形式输出，角度以弧度为单位，时间以秒为单位。最终输出格式必须严格为\n$$\n[\\Delta_1,\\Delta_2,\\Delta_3].\n$$", "solution": "用户提供了一个来自计算天体物理学的问题，涉及对一个常微分方程 (ODE) 进行数值积分，该方程模拟了天体物理盘中倾斜向量的演化。在尝试求解之前，需要对该问题的科学性和数学合理性进行验证。\n\n### 问题验证\n\n**步骤1：提取的已知条件**\n-   **控制方程**：倾斜向量 $\\mathbf{l}(t;r)$ 的演化由以下一阶初值问题给出：\n    $$ \\frac{d\\mathbf{l}}{dt}(t;r)=\\boldsymbol{\\Omega}(r)\\times \\mathbf{l}(t;r)-\\nu\\,\\mathbf{l}(t;r) $$\n-   **进动向量**：局部进动向量 $\\boldsymbol{\\Omega}(r)$ 定义为：\n    $$ \\boldsymbol{\\Omega}(r)=\\Omega_0\\left(\\frac{r}{r_0}\\right)^{-q}\\,\\hat{\\mathbf{z}} $$\n-   **初始条件**：对于所有测试用例，初始倾斜向量为：\n    $$ \\mathbf{l}(0;r)=\\mathbf{l}_0=\\begin{bmatrix} 3/5 \\\\ 4/5 \\\\ 0 \\end{bmatrix} $$\n    问题正确地指出 $|\\mathbf{l}_0|=1$。\n-   **测试用例1**：\n    -   参数：$r=10^{10}\\,\\mathrm{m}$，$r_0=10^{10}\\,\\mathrm{m}$，$\\Omega_0=10^{-5}\\,\\mathrm{rad/s}$，$q=1$，$\\nu=0\\,\\mathrm{s}^{-1}$。\n    -   积分时间：$t_f=10^{6}\\,\\mathrm{s}$。\n    -   容差：$r_{\\mathrm{tol}}=10^{-9}$，$a_{\\mathrm{tol}}=10^{-12}$。\n    -   诊断量：$\\Delta_1=\\max_{t\\in[0,t_f]}\\left||\\mathbf{l}(t;r)|-1\\right|$。\n-   **测试用例2**：\n    -   参数：$r=10^{10}\\,\\mathrm{m}$，$r_0=10^{10}\\,\\mathrm{m}$，$\\Omega_0=10^{-5}\\,\\mathrm{rad/s}$，$q=1$，$\\nu=10^{-6}\\,\\mathrm{s}^{-1}$。\n    -   积分时间：$t_f=10^{6}\\,\\mathrm{s}$。\n    -   容差：$r_{\\mathrm{tol}}=10^{-9}$，$a_{\\mathrm{tol}}=10^{-12}$。\n    -   诊断量：$\\Delta_2=\\left||\\mathbf{l}(t_f;r)|-e^{-\\nu t_f}\\right|$。\n-   **测试用例3**：\n    -   参数：$r=10^{10}\\,\\mathrm{m}$，$r_0=10^{10}\\,\\mathrm{m}$，$\\Omega_0=10^{-5}\\,\\mathrm{rad/s}$，$q=1$，$\\nu=0\\,\\mathrm{s}^{-1}$。\n    -   积分时间：$t_f=10^{6}\\,\\mathrm{s}$。\n    -   容差：$r_{\\mathrm{tol}}=10^{-3}$，$a_{\\mathrm{tol}}=10^{-6}$。\n    -   诊断量：$\\Delta_3=\\left||\\mathbf{l}(t_f;r)|-1\\right|$。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据**：该控制方程是天体物理学中常用的带阻尼进动的标准模型（例如，翘曲吸积盘、Lense-Thirring 效应）。进动频率对半径的幂律依赖关系也是一个标准的物理模型。数值在天体物理学上是合理的。该问题在科学上是合理的。\n-   **良定性**：该问题是一个一阶线性常微分方程组。右侧项 $f(\\mathbf{l}, t) = \\boldsymbol{\\Omega} \\times \\mathbf{l} - \\nu\\mathbf{l}$ 是作用于 $\\mathbf{l}$ 的线性算子，因此是全局利普希茨连续的。根据 Picard-Lindelöf 定理，对于给定的初值问题，解的存在性和唯一性得到保证。该问题是良定的。\n-   **客观性**：问题以精确、无歧义的数学和物理语言陈述。所有参数和目标都已明确定义。\n-   **一致性与完整性**：为每个测试用例提供了所有必要的参数、初始条件和数值设置。没有矛盾之处。初始向量的模长被正确地陈述为 $|\\mathbf{l}_0|=1$。\n-   **结论**：该问题在所有标准上均有效。它是一个定义明确、有科学依据且在计算天体物理学领域内计算上可行的任务。\n\n**步骤3：裁定与行动**\n该问题是**有效的**。将着手开发解决方案。\n\n### 基于原理的设计与求解\n\n问题的核心是数值求解向量常微分方程，并分析解的模长 $|\\mathbf{l}(t)|$ 的行为。\n\n**1. 模长演化的解析洞察**\n首先，我们从解析上分析模长 $|\\mathbf{l}|$ 的演化。模长平方的时间导数为：\n$$ \\frac{d}{dt} |\\mathbf{l}|^2 = \\frac{d}{dt}(\\mathbf{l} \\cdot \\mathbf{l}) = 2\\mathbf{l} \\cdot \\frac{d\\mathbf{l}}{dt} $$\n代入控制方程：\n$$ \\frac{d}{dt} |\\mathbf{l}|^2 = 2\\mathbf{l} \\cdot (\\boldsymbol{\\Omega} \\times \\mathbf{l} - \\nu\\mathbf{l}) = 2(\\mathbf{l} \\cdot (\\boldsymbol{\\Omega} \\times \\mathbf{l})) - 2\\nu(\\mathbf{l} \\cdot \\mathbf{l}) $$\n向量叉乘的一个基本性质是其结果与其操作数正交。因此，$\\mathbf{l} \\cdot (\\boldsymbol{\\Omega} \\times \\mathbf{l}) = 0$。这在数学上体现了纯进动是一种旋转且不改变向量长度的物理原理。方程简化为：\n$$ \\frac{d}{dt} |\\mathbf{l}|^2 = -2\\nu |\\mathbf{l}|^2 $$\n这是一个关于 $|\\mathbf{l}|^2$ 的可分离一阶常微分方程。令 $M(t) = |\\mathbf{l}(t)|$，我们得到模长本身的解：\n$$ |\\mathbf{l}(t)| = |\\mathbf{l}(0)| e^{-\\nu t} $$\n因为 $|\\mathbf{l(0)}| = 1$，所以有 $|\\mathbf{l}(t)| = e^{-\\nu t}$。这个解析结果是问题诊断的基础：\n-   当 $\\nu=0$ 时（测试用例1和3），模长应守恒：$|\\mathbf{l}(t)|=1$。数值解中的任何偏差都纯粹是数值误差。\n-   当 $\\nu > 0$ 时（测试用例2），模长必须按 $e^{-\\nu t}$ 指数衰减。这为数值解提供了一个精确的基准。\n\n**2. 数值实现策略**\n向量常微分方程必须分解为标量常微分方程组以便进行数值积分。令 $\\mathbf{l} = [l_x, l_y, l_z]^T$ 和 $\\boldsymbol{\\Omega} = [0, 0, \\Omega_z]^T$，其中 $\\Omega_z = \\Omega_0 (r/r_0)^{-q}$。叉乘 $\\boldsymbol{\\Omega} \\times \\mathbf{l}$ 为 $[-\\Omega_z l_y, \\Omega_z l_x, 0]^T$。常微分方程组为：\n$$ \\frac{dl_x}{dt} = -\\Omega_z l_y - \\nu l_x $$\n$$ \\frac{dl_y}{dt} = \\Omega_z l_x - \\nu l_y $$\n$$ \\frac{dl_z}{dt} = - \\nu l_z $$\n这个方程组可以使用标准的数值常微分方程求解器进行积分。`scipy.integrate.solve_ivp` 函数非常适合此任务，因为它实现了鲁棒的自适应步长方法，如 Runge-Kutta-Fehlberg 方法 (`RK45`)。\n\n**3. 测试用例执行计划**\n-   **所有用例**：首先，计算恒定的进动频率 $\\Omega_z = 10^{-5}(10^{10}/10^{10})^{-1} = 10^{-5}\\,\\mathrm{rad/s}$。初始条件为 $\\mathbf{l}_0 = [0.6, 0.8, 0]^T$。\n-   **测试用例1 ($\\Delta_1$)**：使用 $\\nu=0$ 和严格的容差（$r_{\\mathrm{tol}}=10^{-9}, a_{\\mathrm{tol}}=10^{-12}$）进行积分。为了找到模长与1的最大偏差，必须在区间 $[0, t_f]$ 上的密集时间点集上评估解。`solve_ivp` 函数的 `t_eval` 参数将用于此目的。1001个点的采样足以解析轨迹。计算每个采样点 $t_i$ 处的模长 $|\\mathbf{l}(t_i)|$，然后取 $||\\mathbf{l}(t_i)| - 1|$ 的最大值。\n-   **测试用例2 ($\\Delta_2$)**：使用 $\\nu=10^{-6}\\,\\mathrm{s}^{-1}$ 和严格的容差进行积分。在 $t_f$ 处的解析模长为 $e^{-\\nu t_f} = e^{-10^{-6} \\times 10^6} = e^{-1}$。我们计算数值解的模长 $|\\mathbf{l}(t_f)|$ 并求其绝对差 $\\Delta_2 = ||\\mathbf{l}(t_f)| - e^{-1}|$。\n-   **测试用例3 ($\\Delta_3$)**：使用 $\\nu=0$ 但放宽的容差（$r_{\\mathrm{tol}}=10^{-3}, a_{\\mathrm{tol}}=10^{-6}$）进行积分。这样设计是为了揭示数值扩散，即模长不守恒的现象会更明显。诊断量是最终时刻的绝对误差，$\\Delta_3 = ||\\mathbf{l}(t_f)| - 1|$。我们预期 $\\Delta_3$ 会显著大于在 $\\Delta_1$ 中找到的最大误差。\n\n这种结构化方法将底层的物理和数学原理与数值实验的设计直接联系起来，满足了问题的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically integrates the tilt vector evolution equation for three test cases\n    and computes the specified diagnostic quantities.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple: (r, r0, Omega0, q, nu, tf, rtol, atol, case_id)\n    # case_id: 1 for Delta_1, 2 for Delta_2, 3 for Delta_3\n    test_cases = [\n        # Case 1: General precession, tight tolerance\n        (1.0e10, 1.0e10, 1.0e-5, 1.0, 0.0, 1.0e6, 1.0e-9, 1.0e-12, 1),\n        # Case 2: Damping, tight tolerance\n        (1.0e10, 1.0e10, 1.0e-5, 1.0, 1.0e-6, 1.0e6, 1.0e-9, 1.0e-12, 2),\n        # Case 3: General precession, relaxed tolerance\n        (1.0e10, 1.0e10, 1.0e-5, 1.0, 0.0, 1.0e6, 1.0e-3, 1.0e-6, 3),\n    ]\n\n    results = []\n    \n    # Initial condition, a 3D vector.\n    # |l0| = sqrt((3/5)^2 + (4/5)^2) = 1.\n    l0 = np.array([3.0/5.0, 4.0/5.0, 0.0])\n\n    def ode_system(t, l, Omega_z, nu):\n        \"\"\"\n        Defines the right-hand side of the ODE system d(l)/dt.\n        d(l)/dt = Omega x l - nu * l\n        \n        Args:\n            t (float): Time.\n            l (np.ndarray): State vector [lx, ly, lz].\n            Omega_z (float): Precession frequency component.\n            nu (float): Damping coefficient.\n            \n        Returns:\n            np.ndarray: The derivative d(l)/dt.\n        \"\"\"\n        # The precession vector Omega is [0, 0, Omega_z].\n        # The cross product Omega x l is [-Omega_z*ly, Omega_z*lx, 0].\n        cross_product = np.array([\n            -Omega_z * l[1],\n            Omega_z * l[0],\n            0.0\n        ])\n        damping_term = -nu * l\n        return cross_product + damping_term\n\n    for case in test_cases:\n        r, r0, Omega0, q, nu, tf, rtol, atol, case_id = case\n\n        # Calculate the constant precession frequency Omega_z\n        Omega_z = Omega0 * (r / r0)**(-q)\n\n        t_span = [0.0, tf]\n        \n        if case_id == 1:\n            # For Delta_1, we need to find the max deviation over the whole interval.\n            # We sample the solution densely using t_eval.\n            # A sample of 1001 points is sufficient.\n            t_eval = np.linspace(t_span[0], t_span[1], 1001)\n            sol = solve_ivp(\n                ode_system, t_span, l0, args=(Omega_z, nu),\n                method='RK45', rtol=rtol, atol=atol, t_eval=t_eval\n            )\n            # sol.y is a (3, N) array where N is the number of time points.\n            l_t_values = sol.y\n            # Calculate the magnitude at each time point.\n            magnitudes = np.linalg.norm(l_t_values, axis=0)\n            # The analytical magnitude is 1.0 since nu=0.\n            delta = np.max(np.abs(magnitudes - 1.0))\n            results.append(delta)\n\n        elif case_id == 2:\n            # For Delta_2, we compare the final numerical magnitude to the\n            # analytical prediction.\n            sol = solve_ivp(\n                ode_system, t_span, l0, args=(Omega_z, nu),\n                method='RK45', rtol=rtol, atol=atol\n            )\n            # Get the final state vector.\n            l_final = sol.y[:, -1]\n            numerical_mag = np.linalg.norm(l_final)\n            # Analytical magnitude is exp(-nu*t_f) since |l0|=1.\n            analytical_mag = np.exp(-nu * tf)\n            delta = np.abs(numerical_mag - analytical_mag)\n            results.append(delta)\n            \n        elif case_id == 3:\n            # For Delta_3, we find the deviation of the final magnitude from unity\n            # under relaxed tolerances.\n            sol = solve_ivp(\n                ode_system, t_span, l0, args=(Omega_z, nu),\n                method='RK45', rtol=rtol, atol=atol\n            )\n            l_final = sol.y[:, -1]\n            final_mag = np.linalg.norm(l_final)\n            # The analytical magnitude is 1.0 since nu=0.\n            delta = np.abs(final_mag - 1.0)\n            results.append(delta)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3528297"}, {"introduction": "刚性问题，以其巨大的时间尺度差异为特征，是许多天体物理模拟中的主要障碍，尤其是在核反应网络中。这个动手实践 [@problem_id:3528222] 介绍了一种强大的技术——无量纲化——来处理刚性问题。通过实现并比较一个简单网络的标度化和非标度化版本，您将定量地衡量求解器效率和稳定性的显著提升。", "problem": "您的任务是研究一个最小但刚性的核反应网络，并在计算天体物理学的背景下，量化变量的无量纲缩放对常微分方程初值问题的数值影响。目标是从第一性原理推导控制方程，实现原始公式和无量纲缩放公式，用刚性求解器对两者进行积分，并计算可自动测试的量化性能和条件数指标。所有时间必须以秒表示，所有要求的输出都是无量纲实数。\n\n首先从基本原理出发：在充分混合的网络中，物种丰度的时间演化遵循质量作用定律和化学计量守恒。考虑一个三同位素α链，在恒定热力学状态下有以下有效反应：\n- 有效的3α反应生成碳：$3\\, {}^{4}\\mathrm{He} \\rightarrow {}^{12}\\mathrm{C}$。\n- 碳上的α俘获生成氧：${}^{12}\\mathrm{C} + {}^{4}\\mathrm{He} \\rightarrow {}^{16}\\mathrm{O}$。\n\n设动力学变量为每重子的无量纲丰度 $Y_{\\mathrm{He}}(t)$、$Y_{\\mathrm{C}}(t)$ 和 $Y_{\\mathrm{O}}(t)$，它们是非负的，并在指定网络下满足核子数守恒。令 $k_{3\\alpha}$ 表示3α反应的有效速率系数，令 $k_{\\alpha C}$ 表示碳上α俘获的有效速率系数。将 $k_{3\\alpha}$ 和 $k_{\\alpha C}$ 视为常数参数，其量纲的选择应使得以下标准的质量作用形式对于以秒的倒数为单位的生成项是有效的：有效的3α反应速率项与 $Y_{\\mathrm{He}}^{3}$ 成正比，比例常数为 $k_{3\\alpha}$；α俘获速率项与 $Y_{\\mathrm{He}} Y_{\\mathrm{C}}$ 成正比，比例常数为 $k_{\\alpha C}$。仅使用这些定义和化学计量守恒，推导向量 $\\mathbf{y}(t) = \\left[Y_{\\mathrm{He}}(t), Y_{\\mathrm{C}}(t), Y_{\\mathrm{O}}(t)\\right]^{\\top}$ 的常微分方程封闭系统。\n\n通过派生的系统和初始条件 $\\mathbf{y}(t_{0}) = \\mathbf{y}_{0}$，在有限时间区间 $\\left[t_{0}, t_{f}\\right]$ 上定义未缩放的初值问题。对于刚性积分，您必须：\n- 使用后向差分公式(BDF)方法，并提供解析雅可比矩阵 $\\mathbf{J}_{\\mathbf{y}}(t, \\mathbf{y}) = \\partial \\mathbf{f} / \\partial \\mathbf{y}$。\n- 启用密集输出，以在任意中间时间点评估解。\n- 对 $\\left[Y_{\\mathrm{He}}, Y_{\\mathrm{C}}, Y_{\\mathrm{O}}\\right]$ 分别使用 $10^{-9}$ 的相对容差和 $\\left[10^{-18}, 10^{-18}, 10^{-18}\\right]$ 的绝对容差向量。\n\n现在构建一个旨在减小动态范围的无量纲缩放公式。选择一个固定的对角缩放矩阵 $\\mathbf{S} = \\mathrm{diag}\\left(s_{\\mathrm{He}}, s_{\\mathrm{C}}, s_{\\mathrm{O}}\\right)$，其中 $s_{\\mathrm{He}} = 1$，$s_{\\mathrm{C}} = 10^{-6}$，$s_{\\mathrm{O}} = 10^{-12}$。定义缩放变量 $\\mathbf{x}(\\tau) = \\mathbf{S}^{-1} \\mathbf{y}(t)$ 和缩放时间 $\\tau = t / t_{\\mathrm{ref}}$，时间尺度为 $t_{\\mathrm{ref}} = 1 / k_{\\alpha C}$。仅使用链式法则和质量作用形式，以 $\\mathrm{d} \\mathbf{x} / \\mathrm{d} \\tau = \\mathbf{g}(\\mathbf{x})$ 的形式推导变换后的初值问题，并提供解析雅可比矩阵 $\\mathbf{J}_{\\mathbf{x}}(\\mathbf{x}) = \\partial \\mathbf{g} / \\partial \\mathbf{x}$。使用相同的求解器设置，在缩放时间 $\\tau$ 内积分缩放后的系统，并使用适用于缩放系统的解析雅可比矩阵。根据需要，使用 $t = \\tau \\, t_{\\mathrm{ref}}$ 将缩放运行中任何基于时间的诊断信息映射回物理秒。\n\n对于每次运行（未缩放和缩放），计算以下诊断信息：\n- 接受的步长：如果求解器返回接受的时间点 $\\{t_{i}\\}_{i=0}^{N}$，计算接受的步长序列 $\\Delta t_{i} = t_{i+1} - t_{i}$，其中 $i = 0, \\dots, N-1$；计算平均值 $\\overline{\\Delta t}$ 和中位数 $\\widetilde{\\Delta t}$。对于缩放运行，通过乘以 $t_{\\mathrm{ref}}$ 将接受的 $\\tau$ 步长转换为物理秒。所有时间单位均为秒。\n- 隐式线性化的雅可比条件数：对于三个物理时间点 $t_{0}$（初始）、$t_{\\mathrm{mid}} = (t_{0} + t_{f})/2$（中点）和 $t_{f}$（最终），使用该次运行的中位数步长作为 $h$ 值，以及该公式对应的雅可比矩阵，来评估求解器的隐式线性系统矩阵 $\\mathbf{M} = \\mathbf{I} - h \\mathbf{J}$。对于未缩放运行，使用在状态 $\\mathbf{y}(t)$ 处评估的 $\\mathbf{J} = \\mathbf{J}_{\\mathbf{y}}$；对于缩放运行，使用在 $\\mathbf{x}(\\tau)$ 处评估的 $\\mathbf{J} = \\mathbf{J}_{\\mathbf{x}}$，其中 $\\tau = t / t_{\\mathrm{ref}}$。计算这三个时间点上矩阵的 $2$-范数条件数 $\\kappa_{2}(\\mathbf{M})$，然后取这三个值的算术平均值，以获得该次运行的单个条件数指标。\n\n使用以下三个无量纲指标量化每个测试用例中缩放的影响：\n- 平均条件数指标之比 $\\mathcal{R}_{\\kappa} = \\left(\\text{未缩放的平均 } \\kappa_{2}\\right) / \\left(\\text{缩放的平均 } \\kappa_{2}\\right)$。\n- 平均接受的物理步长之比 $\\mathcal{R}_{\\Delta t} = \\left(\\text{缩放的 }\\overline{\\Delta t}\\right) / \\left(\\text{未缩放的 }\\overline{\\Delta t}\\right)$。\n- 函数求值次数之比 $\\mathcal{R}_{\\mathrm{nfev}} = \\left(\\text{未缩放的 nfev}\\right) / \\left(\\text{缩放的 nfev}\\right)$，由求解器报告。\n\n测试套件和参数规格：\n- 所有情况的初始条件：在 $t_{0} = 0$ 秒时，$\\mathbf{y}_{0} = \\left[0.98,\\ 10^{-12},\\ 10^{-20}\\right]^{\\top}$。\n- 情况A（刚性，快速α俘获）：$k_{3\\alpha} = 10^{-4}\\ \\mathrm{s}^{-1}$，$k_{\\alpha C} = 10^{3}\\ \\mathrm{s}^{-1}$，$t_{f} = 10^{-2}$ 秒。\n- 情况B（非常刚性，极快α俘获）：$k_{3\\alpha} = 10^{-6}\\ \\mathrm{s}^{-1}$，$k_{\\alpha C} = 10^{5}\\ \\mathrm{s}^{-1}$，$t_{f} = 10^{-5}$ 秒。\n- 情况C（中等刚性，较慢动力学）：$k_{3\\alpha} = 10^{-2}\\ \\mathrm{s}^{-1}$，$k_{\\alpha C} = 10^{2}\\ \\mathrm{s}^{-1}$，$t_{f} = 10^{-1}$ 秒。\n\n实现要求：\n- 使用后向差分公式(BDF)方法，启用解析雅可比矩阵和密集输出。\n- 使用相对容差 $10^{-9}$ 和绝对容差向量 $\\left[10^{-18}, 10^{-18}, 10^{-18}\\right]$。\n- 对于每种情况，计算如上定义的 $\\mathcal{R}_{\\kappa}$、$\\mathcal{R}_{\\Delta t}$ 和 $\\mathcal{R}_{\\mathrm{nfev}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个列表的列表，每个列表对应一个测试用例，顺序与上述情况相同。每个内部列表必须按顺序包含三个浮点数 $\\left[\\mathcal{R}_{\\kappa}, \\mathcal{R}_{\\Delta t}, \\mathcal{R}_{\\mathrm{nfev}}\\right]$，不带任何单位。确切格式为Python风格的列表字面量，例如：“[[1.23,0.45,3.67],[...],[...]]”。", "solution": "用户提供的问题是在计算天体物理学和数值分析领域中一个定义明确且有科学依据的练习。它要求为一个简化的核反应网络推导并数值求解一个常微分方程(ODE)组。核心任务是比较一个未缩放的公式和一个无量纲的缩放公式，并量化其对数值性能的影响。该问题是自洽的，提供了所有必要的参数、初始条件和指标定义。它遵循了化学动力学（质量作用定律）和刚性ODE数值方法的既定原则。\n\n### 1. 未缩放ODE系统的推导\n\n问题描述了一个包含两个有效反应的三同位素α链：\n1.  3α反应：$3\\, {}^{4}\\mathrm{He} \\rightarrow {}^{12}\\mathrm{C}$\n2.  碳上的α俘获：${}^{12}\\mathrm{C} + {}^{4}\\mathrm{He} \\rightarrow {}^{16}\\mathrm{O}$\n\n状态向量为 $\\mathbf{y}(t) = \\left[Y_{\\mathrm{He}}(t), Y_{\\mathrm{C}}(t), Y_{\\mathrm{O}}(t)\\right]^{\\top}$，代表无量纲丰度。这些丰度的时间演化遵循质量作用定律。\n\n设 $R_1$ 为3α反应的速率，$R_2$ 为α俘获反应的速率。问题陈述，由3α反应生成的 ${}^{12}\\mathrm{C}$ 的生成项为 $k_{3\\alpha} Y_{\\mathrm{He}}^{3}$，由α俘获生成的 ${}^{16}\\mathrm{O}$ 的生成项为 $k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$。这意味着由生成引起的速率变化为 $\\left.dY_{\\mathrm{C}}/dt\\right|_{\\text{prod},1} = k_{3\\alpha} Y_{\\mathrm{He}}^{3}$ 和 $\\left.dY_{\\mathrm{O}}/dt\\right|_{\\text{prod},2} = k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$。\n\n根据反应的化学计量关系，我们可以写出完整的ODE系统 $\\mathrm{d}\\mathbf{y}/\\mathrm{d}t = \\mathbf{f}(\\mathbf{y})$：\n\n对于3α反应（$3\\mathrm{He} \\to \\mathrm{C}$），每生成一个 ${}^{12}\\mathrm{C}$ 核，就会消耗三个 ${}^{4}\\mathrm{He}$ 核。因此：\n$\\frac{\\mathrm{d}Y_{\\mathrm{He}}}{\\mathrm{d}t} \\bigg|_{1} = -3 \\left( \\frac{\\mathrm{d}Y_{\\mathrm{C}}}{\\mathrm{d}t} \\bigg|_{\\text{prod},1} \\right) = -3 k_{3\\alpha} Y_{\\mathrm{He}}^{3}$\n$\\frac{\\mathrm{d}Y_{\\mathrm{C}}}{\\mathrm{d}t} \\bigg|_{1} = +k_{3\\alpha} Y_{\\mathrm{He}}^{3}$\n\n对于α俘获反应（$\\mathrm{C} + \\mathrm{He} \\to \\mathrm{O}$），每生成一个 ${}^{16}\\mathrm{O}$ 核，就会消耗一个 ${}^{12}\\mathrm{C}$ 核和一个 ${}^{4}\\mathrm{He}$ 核。因此：\n$\\frac{\\mathrm{d}Y_{\\mathrm{He}}}{\\mathrm{d}t} \\bigg|_{2} = - \\left( \\frac{\\mathrm{d}Y_{\\mathrm{O}}}{\\mathrm{d}t} \\bigg|_{\\text{prod},2} \\right) = -k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$\n$\\frac{\\mathrm{d}Y_{\\mathrm{C}}}{\\mathrm{d}t} \\bigg|_{2} = - \\left( \\frac{\\mathrm{d}Y_{\\mathrm{O}}}{\\mathrm{d}t} \\bigg|_{\\text{prod},2} \\right) = -k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$\n$\\frac{\\mathrm{d}Y_{\\mathrm{O}}}{\\mathrm{d}t} \\bigg|_{2} = +k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$\n\n合并这些项得到最终的系统：\n$$\n\\frac{\\mathrm{d}Y_{\\mathrm{He}}}{\\mathrm{d}t} = f_1(\\mathbf{y}) = -3 k_{3\\alpha} Y_{\\mathrm{He}}^{3} - k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}\n$$\n$$\n\\frac{\\mathrm{d}Y_{\\mathrm{C}}}{\\mathrm{d}t} = f_2(\\mathbf{y}) = k_{3\\alpha} Y_{\\mathrm{He}}^{3} - k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}\n$$\n$$\n\\frac{\\mathrm{d}Y_{\\mathrm{O}}}{\\mathrm{d}t} = f_3(\\mathbf{y}) = k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}\n$$\n\n雅可比矩阵 $\\mathbf{J}_{\\mathbf{y}} = \\partial \\mathbf{f} / \\partial \\mathbf{y}$ 是：\n$$\n\\mathbf{J}_{\\mathbf{y}} = \n\\begin{pmatrix}\n\\frac{\\partial f_1}{\\partial Y_{\\mathrm{He}}}  \\frac{\\partial f_1}{\\partial Y_{\\mathrm{C}}}  \\frac{\\partial f_1}{\\partial Y_{\\mathrm{O}}} \\\\\n\\frac{\\partial f_2}{\\partial Y_{\\mathrm{He}}}  \\frac{\\partial f_2}{\\partial Y_{\\mathrm{C}}}  \\frac{\\partial f_2}{\\partial Y_{\\mathrm{O}}} \\\\\n\\frac{\\partial f_3}{\\partial Y_{\\mathrm{He}}}  \\frac{\\partial f_3}{\\partial Y_{\\mathrm{C}}}  \\frac{\\partial f_3}{\\partial Y_{\\mathrm{O}}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-9 k_{3\\alpha} Y_{\\mathrm{He}}^{2} - k_{\\alpha C} Y_{\\mathrm{C}}  -k_{\\alpha C} Y_{\\mathrm{He}}  0 \\\\\n3 k_{3\\alpha} Y_{\\mathrm{He}}^{2} - k_{\\alpha C} Y_{\\mathrm{C}}  -k_{\\alpha C} Y_{\\mathrm{He}}  0 \\\\\nk_{\\alpha C} Y_{\\mathrm{C}}  k_{\\alpha C} Y_{\\mathrm{He}}  0\n\\end{pmatrix}\n$$\n\n### 2. 缩放ODE系统的推导\n\n我们引入缩放变量 $\\mathbf{x}(\\tau) = \\mathbf{S}^{-1} \\mathbf{y}(t)$ 和缩放时间 $\\tau = t / t_{\\mathrm{ref}}$，其中 $\\mathbf{S} = \\mathrm{diag}(s_{\\mathrm{He}}, s_{\\mathrm{C}}, s_{\\mathrm{O}})$ 且 $t_{\\mathrm{ref}} = 1 / k_{\\alpha C}$。未缩放的变量为 $\\mathbf{y}(t) = \\mathbf{S} \\mathbf{x}(\\tau)$。\n\n使用链式法则，我们变换导数：\n$$\n\\frac{\\mathrm{d}\\mathbf{y}}{\\mathrm{d}t} = \\frac{\\mathrm{d}(\\mathbf{S}\\mathbf{x})}{\\mathrm{d}t} = \\mathbf{S} \\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}\\tau} \\frac{\\mathrm{d}\\tau}{\\mathrm{d}t} = \\mathbf{S} \\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}\\tau} \\frac{1}{t_{\\mathrm{ref}}}\n$$\n将此代入未缩放的ODE系统 $\\mathrm{d}\\mathbf{y}/\\mathrm{d}t = \\mathbf{f}(\\mathbf{y})$：\n$$\n\\frac{\\mathbf{S}}{t_{\\mathrm{ref}}} \\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}\\tau} = \\mathbf{f}(\\mathbf{S}\\mathbf{x}) \\implies \\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}\\tau} = t_{\\mathrm{ref}} \\mathbf{S}^{-1} \\mathbf{f}(\\mathbf{S}\\mathbf{x})\n$$\n右侧是新的函数 $\\mathbf{g}(\\mathbf{x})$。让我们写出它的分量，代入 $Y_{\\mathrm{He}} = s_{\\mathrm{He}}x_{\\mathrm{He}}$，$Y_{\\mathrm{C}} = s_{\\mathrm{C}}x_{\\mathrm{C}}$，$t_{\\mathrm{ref}} = 1/k_{\\alpha C}$，并定义无量纲比率 $\\gamma = k_{3\\alpha}/k_{\\alpha C}$：\n\n$g_1(x) = \\frac{t_{\\mathrm{ref}}}{s_{\\mathrm{He}}} f_1(\\mathbf{S x}) = \\frac{1}{k_{\\alpha C}s_{\\mathrm{He}}} \\left( -3 k_{3\\alpha} (s_{\\mathrm{He}}x_{\\mathrm{He}})^3 - k_{\\alpha C} (s_{\\mathrm{He}}x_{\\mathrm{He}})(s_{\\mathrm{C}}x_{\\mathrm{C}}) \\right) = -3\\gamma \\frac{s_{\\mathrm{He}}^3}{s_{\\mathrm{He}}} x_{\\mathrm{He}}^3 - \\frac{s_{\\mathrm{He}}s_{\\mathrm{C}}}{s_{\\mathrm{He}}} x_{\\mathrm{He}}x_{\\mathrm{C}}$\n$g_2(x) = \\frac{t_{\\mathrm{ref}}}{s_{\\mathrm{C}}} f_2(\\mathbf{S x}) = \\frac{1}{k_{\\alpha C}s_{\\mathrm{C}}} \\left( k_{3\\alpha} (s_{\\mathrm{He}}x_{\\mathrm{He}})^3 - k_{\\alpha C} (s_{\\mathrm{He}}x_{\\mathrm{He}})(s_{\\mathrm{C}}x_{\\mathrm{C}}) \\right) = \\gamma \\frac{s_{\\mathrm{He}}^3}{s_{\\mathrm{C}}} x_{\\mathrm{He}}^3 - \\frac{s_{\\mathrm{He}}s_{\\mathrm{C}}}{s_{\\mathrm{C}}} x_{\\mathrm{He}}x_{\\mathrm{C}}$\n$g_3(x) = \\frac{t_{\\mathrm{ref}}}{s_{\\mathrm{O}}} f_3(\\mathbf{S x}) = \\frac{1}{k_{\\alpha C}s_{\\mathrm{O}}} \\left( k_{\\alpha C} (s_{\\mathrm{He}}x_{\\mathrm{He}})(s_{\\mathrm{C}}x_{\\mathrm{C}}) \\right) = \\frac{s_{\\mathrm{He}}s_{\\mathrm{C}}}{s_{\\mathrm{O}}} x_{\\mathrm{He}}x_{\\mathrm{C}}$\n\n使用指定的缩放常数 $s_{\\mathrm{He}}=1$，$s_{\\mathrm{C}}=10^{-6}$ 和 $s_{\\mathrm{O}}=10^{-12}$：\n$$\ng_1(\\mathbf{x}) = -3 \\gamma x_{\\mathrm{He}}^{3} - s_{\\mathrm{C}} x_{\\mathrm{He}} x_{\\mathrm{C}}\n$$\n$$\ng_2(\\mathbf{x}) = \\frac{\\gamma}{s_{\\mathrm{C}}} x_{\\mathrm{He}}^{3} - x_{\\mathrm{He}} x_{\\mathrm{C}}\n$$\n$$\ng_3(\\mathbf{x}) = \\frac{s_{\\mathrm{C}}}{s_{\\mathrm{O}}} x_{\\mathrm{He}} x_{\\mathrm{C}}\n$$\n\n缩放系统的雅可比矩阵 $\\mathbf{J}_{\\mathbf{x}} = \\partial \\mathbf{g} / \\partial \\mathbf{x}$ 是：\n$$\n\\mathbf{J}_{\\mathbf{x}} = \n\\begin{pmatrix}\n-9 \\gamma x_{\\mathrm{He}}^{2} - s_{\\mathrm{C}} x_{\\mathrm{C}}  -s_{\\mathrm{C}} x_{\\mathrm{He}}  0 \\\\\n\\frac{3\\gamma}{s_{\\mathrm{C}}} x_{\\mathrm{He}}^{2} - x_{\\mathrm{C}}  -x_{\\mathrm{He}}  0 \\\\\n\\frac{s_{\\mathrm{C}}}{s_{\\mathrm{O}}} x_{\\mathrm{C}}  \\frac{s_{\\mathrm{C}}}{s_{\\mathrm{O}}} x_{\\mathrm{He}}  0\n\\end{pmatrix}\n$$\n\n### 3. 数值积分与诊断\n\n对于每个测试用例，我们使用BDF方法从 $t_0=0$ 到 $t_f$ 求解未缩放和缩放的系统。缩放后的系统从 $\\tau_0=0$ 求解到 $\\tau_f = t_f/t_{\\mathrm{ref}}$。\n为每次运行计算以下诊断信息：\n- **平均和中位步长**：收集接受的步长序列，未缩放运行为 $\\Delta t_i$，缩放运行为 $\\Delta \\tau_i$。为了比较，将缩放后的步长转换为物理时间：$\\Delta t_i^{\\text{scaled}} = \\Delta \\tau_i \\cdot t_{\\mathrm{ref}}$。然后计算平均值 $\\overline{\\Delta t}$ 和中位数 $\\widetilde{\\Delta t}$。\n- **雅可比条件数**：构建矩阵 $\\mathbf{M} = \\mathbf{I} - h \\mathbf{J}$。对于未缩放运行，$\\mathbf{J}=\\mathbf{J}_{\\mathbf{y}}$ 且 $h=\\widetilde{\\Delta t}^{\\text{unscaled}}$。对于缩放运行，$\\mathbf{J}=\\mathbf{J}_{\\mathbf{x}}$ 且 $h=\\widetilde{\\Delta \\tau}^{\\text{scaled}}$。在三个物理时间点（$t_0$, $(t_0+t_f)/2$, $t_f$）及其对应的缩放时间点上评估该矩阵。在每个时间点计算2-范数条件数 $\\kappa_2(\\mathbf{M})$，然后将这三个值取平均。\n- **函数求值次数**：从求解器获取函数求值总次数 `nfev`。\n\n最后，计算三个无量纲比率来量化缩放的影响：\n- $\\mathcal{R}_{\\kappa} = \\left(\\text{未缩放的平均 } \\kappa_{2}\\right) / \\left(\\text{缩放的平均 } \\kappa_{2}\\right)$\n- $\\mathcal{R}_{\\Delta t} = \\left(\\text{缩放的 }\\overline{\\Delta t}\\right) / \\left(\\text{未缩放的 }\\overline{\\Delta t}\\right)$\n- $\\mathcal{R}_{\\mathrm{nfev}} = \\left(\\text{未缩放的 nfev}\\right) / \\left(\\text{缩放的 nfev}\\right)$\n\n实现将遵循这些推导和程序。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# --- Problem Definition: Unscaled System ---\n\ndef f_unscaled(t, y, k_3a, k_ac):\n    \"\"\"RHS of the unscaled ODE system dy/dt = f(t, y).\"\"\"\n    y_he, y_c, y_o = y[0], y[1], y[2]\n    \n    # Reaction rates based on problem definition\n    term_3a = k_3a * y_he**3\n    term_ac = k_ac * y_he * y_c\n    \n    dy_he_dt = -3.0 * term_3a - term_ac\n    dy_c_dt = term_3a - term_ac\n    dy_o_dt = term_ac\n    \n    return np.array([dy_he_dt, dy_c_dt, dy_o_dt])\n\ndef jac_unscaled(t, y, k_3a, k_ac):\n    \"\"\"Jacobian of the unscaled ODE system.\"\"\"\n    y_he, y_c = y[0], y[1]\n    \n    J = np.zeros((3, 3), dtype=np.float64)\n    \n    # df1/dy\n    J[0, 0] = -9.0 * k_3a * y_he**2 - k_ac * y_c\n    J[0, 1] = -k_ac * y_he\n    \n    # df2/dy\n    J[1, 0] = 3.0 * k_3a * y_he**2 - k_ac * y_c\n    J[1, 1] = -k_ac * y_he\n    \n    # df3/dy\n    J[2, 0] = k_ac * y_c\n    J[2, 1] = k_ac * y_he\n    \n    return J\n\n# --- Problem Definition: Scaled System ---\n\n# Scaling constants are fixed for all test cases\nS_DIAG = np.array([1.0, 1e-6, 1e-12])\nS_HE, S_C, S_O = S_DIAG[0], S_DIAG[1], S_DIAG[2]\n\ndef g_scaled(tau, x, gamma):\n    \"\"\"RHS of the scaled ODE system dx/dtau = g(tau, x).\"\"\"\n    x_he, x_c = x[0], x[1]\n    \n    g1 = -3.0 * gamma * x_he**3 - S_C * x_he * x_c\n    g2 = (gamma / S_C) * x_he**3 - x_he * x_c\n    g3 = (S_C / S_O) * x_he * x_c\n    \n    return np.array([g1, g2, g3])\n\ndef jac_scaled(tau, x, gamma):\n    \"\"\"Jacobian of the scaled ODE system.\"\"\"\n    x_he, x_c = x[0], x[1]\n    \n    J = np.zeros((3, 3), dtype=np.float64)\n    \n    # dg1/dx\n    J[0, 0] = -9.0 * gamma * x_he**2 - S_C * x_c\n    J[0, 1] = -S_C * x_he\n    \n    # dg2/dx\n    J[1, 0] = (3.0 * gamma / S_C) * x_he**2 - x_c\n    J[1, 1] = -x_he\n    \n    # dg3/dx\n    J[2, 0] = (S_C / S_O) * x_c\n    J[2, 1] = (S_C / S_O) * x_he\n    \n    return J\n\ndef run_and_analyze(case_params):\n    \"\"\"\n    Runs both unscaled and scaled simulations for a given case and computes metrics.\n    \"\"\"\n    k_3a, k_ac, tf = case_params\n    y0 = np.array([0.98, 1e-12, 1e-20])\n    t0 = 0.0\n    rtol = 1e-9\n    atol = np.array([1e-18, 1e-18, 1e-18])\n    t_span = [t0, tf]\n    t_eval_points = np.array([t0, (t0 + tf) / 2.0, tf])\n\n    # --- Unscaled Run ---\n    unscaled_sol = solve_ivp(\n        fun=f_unscaled,\n        t_span=t_span,\n        y0=y0,\n        method='BDF',\n        jac=jac_unscaled,\n        dense_output=True,\n        rtol=rtol,\n        atol=atol,\n        args=(k_3a, k_ac)\n    )\n\n    unscaled_steps_t = np.diff(unscaled_sol.t)\n    mean_dt_unscaled = np.mean(unscaled_steps_t)\n    median_dt_unscaled = np.median(unscaled_steps_t)\n    nfev_unscaled = unscaled_sol.nfev\n\n    y_at_evals = unscaled_sol.sol(t_eval_points)\n    kappas_unscaled = []\n    for i in range(len(t_eval_points)):\n        y_i = y_at_evals[:, i]\n        J = jac_unscaled(t_eval_points[i], y_i, k_3a, k_ac)\n        M = np.identity(3, dtype=np.float64) - median_dt_unscaled * J\n        kappas_unscaled.append(np.linalg.cond(M, 2))\n    mean_kappa_unscaled = np.mean(kappas_unscaled)\n\n    # --- Scaled Run ---\n    t_ref = 1.0 / k_ac\n    gamma = k_3a / k_ac\n    x0 = y0 / S_DIAG\n    tau_span = [t / t_ref for t in t_span]\n    \n    scaled_sol = solve_ivp(\n        fun=g_scaled,\n        t_span=tau_span,\n        y0=x0,\n        method='BDF',\n        jac=jac_scaled,\n        dense_output=True,\n        rtol=rtol,\n        atol=atol, # Using same atol as per problem statement\n        args=(gamma,)\n    )\n\n    scaled_steps_tau = np.diff(scaled_sol.t)\n    mean_dt_scaled = np.mean(scaled_steps_tau * t_ref)\n    median_dtau_scaled = np.median(scaled_steps_tau) # Step size h is in integration variable units (tau)\n    nfev_scaled = scaled_sol.nfev\n\n    tau_eval_points = t_eval_points / t_ref\n    x_at_evals = scaled_sol.sol(tau_eval_points)\n    kappas_scaled = []\n    for i in range(len(tau_eval_points)):\n        x_i = x_at_evals[:, i]\n        J = jac_scaled(tau_eval_points[i], x_i, gamma)\n        M = np.identity(3, dtype=np.float64) - median_dtau_scaled * J\n        kappas_scaled.append(np.linalg.cond(M, 2))\n    mean_kappa_scaled = np.mean(kappas_scaled)\n\n    # --- Compute Ratios ---\n    # Handle potential division by zero if a metric is zero, though unlikely.\n    R_kappa = mean_kappa_unscaled / mean_kappa_scaled if mean_kappa_scaled != 0 else np.inf\n    R_dt = mean_dt_scaled / mean_dt_unscaled if mean_dt_unscaled != 0 else np.inf\n    R_nfev = float(nfev_unscaled) / float(nfev_scaled) if nfev_scaled != 0 else np.inf\n    \n    return [R_kappa, R_dt, R_nfev]\n\ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    # Test cases: [k_3alpha (s^-1), k_alphaC (s^-1), t_f (s)]\n    test_cases = [\n        # Case A\n        (1e-4, 1e3, 1e-2),\n        # Case B\n        (1e-6, 1e5, 1e-5),\n        # Case C\n        (1e-2, 1e2, 1e-1)\n    ]\n    \n    # Use a high precision for numpy printing to match string formatting\n    np.set_printoptions(precision=16)\n\n    all_results = []\n    for case in test_cases:\n        result_metrics = run_and_analyze(case)\n        all_results.append(result_metrics)\n    \n    # Format according to spec: \"[[1.23,0.45,3.67],[...],[...]]\"\n    # str(list) provides the required formatting.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3528222"}]}