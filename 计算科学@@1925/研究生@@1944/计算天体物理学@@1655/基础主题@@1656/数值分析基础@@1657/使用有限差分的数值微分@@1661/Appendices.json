{"hands_on_practices": [{"introduction": "在数值计算中，仅仅实现一个有效的算法是不够的，我们还必须理解并控制其误差。这个练习将指导你从泰勒展开式出发，推导出一个基本的二阶中心差分公式，并运用理查森外推法 (Richardson extrapolation) 将其精度提升至四阶。通过这个过程 [@problem_id:3525596]，你将掌握一种系统性提高数值解精度的强大技术，这在处理需要高精度梯度估计的天体物理模型时至关重要。", "problem": "在计算天体物理学中，当闭式表达式不可用或计算成本高昂时，通常需要对无量纲模型函数的梯度进行数值估算。考虑无量纲标量函数 $f(x) = \\ln(1+x)$，以及在点 $x_0 = 1$ 处估算其导数 $f'(x)$ 的任务。数值微分的基本依据是导数的定义和泰勒级数展开。从定义 $f'(x_0) = \\lim_{h \\to 0} \\frac{f(x_0+h) - f(x_0-h)}{2h}$ 和关于 $x_0$ 的泰勒展开出发，推导 $f'(x_0)$ 的二阶中心差分公式，识别其主截断误差项，并解释为什么该误差随步长 $h$ 的幂次缩放。然后，使用在两个步长 $h_1$ 和 $h_2$（其中 $h_1 = 2 h_2$）下计算的两个二阶中心差分近似值，通过构造这两个近似值的适当线性组合，推导出一个能够消除主截断误差项的单一组合估计。该组合估计的获得无需假设或使用任何预先给定的简化公式。\n\n编写一个程序，实现所推导的过程，以计算函数 $f(x) = \\ln(1+x)$ 在 $f'(1)$ 处的改进估计值，并使用以下步长测试套件：\n- 情况 A（中等步长）：$h_1 = 10^{-2}$ 和 $h_2 = 5 \\times 10^{-3}$。\n- 情况 B（粗略步长）：$h_1 = 10^{-1}$ 和 $h_2 = 5 \\times 10^{-2}$。\n- 情况 C（极细步长）：$h_1 = 10^{-6}$ 和 $h_2 = 5 \\times 10^{-7}$。\n\n对于每种情况，计算：\n1. 在 $h_1$ 和 $h_2$ 处的二阶中心差分近似值。\n2. 使用推导的线性组合，在 $x_0=1$ 处能够消除主截断误差项的改进导数估计值。\n3. 改进估计值相对于在 $x_0 = 1$ 处求值的精确解析导数 $f'(x) = \\frac{1}{1+x}$（其值为 $\\frac{1}{2}$）的绝对误差。\n\n本问题中的所有量均为无量纲；以无量纲单位报告绝对误差。你的程序应生成单行输出，其中包含三种情况下改进估计值的绝对误差，四舍五入到十二位小数，并以方括号括起来的逗号分隔列表形式呈现（例如，$[e_A,e_B,e_C]$，其中 $e_A$、$e_B$ 和 $e_C$ 分别是情况 A、B 和 C 的绝对误差）。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- **函数：** 无量纲标量函数为 $f(x) = \\ln(1+x)$。\n- **任务：** 在点 $x_0 = 1$ 处估算导数 $f'(x)$。\n- **起点 1 (公式)：** 中心差分的定义以极限形式给出：$f'(x_0) = \\lim_{h \\to 0} \\frac{f(x_0+h) - f(x_0-h)}{2h}$。\n- **起点 2 (方法)：** 使用关于 $x_0$ 的泰勒展开来推导数值公式。\n- **要求 1：** 推导 $f'(x_0)$ 的二阶中心差分公式。\n- **要求 2：** 识别其主截断误差项，并解释其随步长 $h$ 的缩放规律。\n- **要求 3：** 使用步长为 $h_1$ 和 $h_2$（其中 $h_1 = 2 h_2$）的两个近似值，推导一个能够消除主截断误差项的组合估计。\n- **测试用例：**\n    - 情况 A：$h_1 = 10^{-2}$，$h_2 = 5 \\times 10^{-3}$。\n    - 情况 B：$h_1 = 10^{-1}$，$h_2 = 5 \\times 10^{-2}$。\n    - 情况 C：$h_1 = 10^{-6}$，$h_2 = 5 \\times 10^{-7}$。\n- **比较值：** 精确解析导数为 $f'(x) = \\frac{1}{1+x}$，在 $x_0 = 1$ 处其值为 $f'(1) = \\frac{1}{2}$。\n- **输出：** 三种情况下改进估计值的绝对误差，四舍五入到十二位小数，格式为 `[e_A,e_B,e_C]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题牢固地植根于数值分析的基本原理，特别是使用有限差分的数值微分和理查森外推法。使用泰勒级数分析截断误差是该领域的一个标准核心概念。函数 $f(x) = \\ln(1+x)$ 是一个标准的、性质良好的解析函数。该问题是计算科学中的一个经典例子。它在科学上和事实上都是合理的。\n2.  **适定性：** 问题定义清晰。它要求推导一种特定的数值方法，并将其应用于具有指定参数的具体函数。其唯一、稳定且有意义的解的存在性是有保证的。\n3.  **客观性：** 问题以精确、客观和形式化的数学语言陈述。它没有任何歧义、主观性或观点。\n4.  **完整性和一致性：** 问题是自洽的。它提供了函数、求值点、步长、步长之间的关系、用于误差计算的精确值以及精确的输出格式。所有提供的信息都是一致的。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个适定的、有科学依据的数值方法问题。我将继续进行解答。\n\n## 理论推导与求解\n\n目标是首先推导二阶中心差分公式及其误差项，然后利用此结果通过理查森外推法推导更高阶的近似。\n\n### 第 1 部分：二阶中心差分公式的推导\n\n我们从函数 $f(x_0 + h)$ 和 $f(x_0 - h)$ 在点 $x_0$ 附近的泰勒级数展开开始。假设函数 $f$ 足够光滑（对于 $x-1$，$f(x)=\\ln(1+x)$ 满足此条件），我们可以写出：\n$$\nf(x_0 + h) = f(x_0) + h f'(x_0) + \\frac{h^2}{2!} f''(x_0) + \\frac{h^3}{3!} f'''(x_0) + \\frac{h^4}{4!} f^{(4)}(x_0) + \\frac{h^5}{5!} f^{(5)}(x_0) + O(h^6)\n$$\n$$\nf(x_0 - h) = f(x_0) - h f'(x_0) + \\frac{h^2}{2!} f''(x_0) - \\frac{h^3}{3!} f'''(x_0) + \\frac{h^4}{4!} f^{(4)}(x_0) - \\frac{h^5}{5!} f^{(5)}(x_0) + O(h^6)\n$$\n为了分离出一阶导数项 $f'(x_0)$，我们用第一个展开式减去第二个展开式。注意，所有 $h$ 的偶次幂项（包括 $f(x_0)$ 项，即 $h^0$ 项）都将被消掉。\n$$\nf(x_0 + h) - f(x_0 - h) = 2h f'(x_0) + 2 \\frac{h^3}{3!} f'''(x_0) + 2 \\frac{h^5}{5!} f^{(5)}(x_0) + O(h^7)\n$$\n现在，我们重新整理这个方程以求解 $f'(x_0)$：\n$$\n2h f'(x_0) = \\left( f(x_0 + h) - f(x_0 - h) \\right) - \\frac{h^3}{3} f'''(x_0) - \\frac{h^5}{60} f^{(5)}(x_0) - O(h^7)\n$$\n$$\nf'(x_0) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h} - \\frac{h^2}{6} f'''(x_0) - \\frac{h^4}{120} f^{(5)}(x_0) - O(h^6)\n$$\n这个方程揭示了两条关键信息：\n1.  **二阶中心差分公式**是近似式 $D_c(h) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h}$。\n2.  真实导数 $f'(x_0)$ 等于这个近似值加上一系列误差项。**主截断误差项**是 $- \\frac{h^2}{6} f'''(x_0)$。因为这个主误差与 $h^2$ 成正比，所以该近似被称为“二阶精度”。误差的阶为 $O(h^2)$。\n\n### 第 2 部分：通过理查森外推法推导改进估计\n\n设 $A$ 为导数的精确值，即 $A = f'(x_0)$，并用 $D(h)$ 表示中心差分近似 $D_c(h)$。根据上一步的结果，我们可以将该近似表示为 $h^2$ 的幂级数：\n$$\nD(h) = A + C_1 h^2 + C_2 h^4 + C_3 h^6 + \\dots\n$$\n其中 $C_1 = -\\frac{1}{6} f'''(x_0)$，$C_2 = -\\frac{1}{120} f^{(5)}(x_0)$，依此类推。我们有两个用步长 $h_1$ 和 $h_2$（其中 $h_1 = 2h_2$）计算的近似值：\n$$\nD(h_1) = A + C_1 h_1^2 + C_2 h_1^4 + \\dots\n$$\n$$\nD(h_2) = A + C_1 h_2^2 + C_2 h_2^4 + \\dots\n$$\n我们的目标是找到 $D(h_1)$ 和 $D(h_2)$ 的一个线性组合，以消除与 $C_1 h^2$ 成正比的主误差项。设改进后的估计值为 $A_{imp}$。\n我们可以将 $h_1 = 2h_2$ 代入第一个方程：\n$$\nD(h_1) = A + C_1 (2h_2)^2 + C_2 (2h_2)^4 + \\dots = A + 4C_1 h_2^2 + 16C_2 h_2^4 + \\dots\n$$\n我们现在有一个包含两个“未知数”($A$ 和 $C_1$)的方程组：\n1.  $D(h_1) \\approx A + 4C_1 h_2^2$\n2.  $D(h_2) \\approx A + C_1 h_2^2$\n\n为了消去 $C_1$ 项，我们可以将第二个方程乘以 $4$，然后用它减去第一个方程：\n$$\n4D(h_2) - D(h_1) \\approx (4A + 4C_1 h_2^2) - (A + 4C_1 h_2^2)\n$$\n$$\n4D(h_2) - D(h_1) \\approx 3A\n$$\n求解 $A$，我们得到改进估计值的公式：\n$$\nA \\approx A_{imp} = \\frac{4D(h_2) - D(h_1)}{3}\n$$\n这就是所求的组合估计。让我们来分析它的误差。代入完整的级数展开式：\n$$\nA_{imp} = \\frac{4(A + C_1 h_2^2 + C_2 h_2^4 + \\dots) - (A + C_1 h_1^2 + C_2 h_1^4 + \\dots)}{3}\n$$\n使用 $h_1 = 2h_2$:\n$$\nA_{imp} = \\frac{4(A + C_1 h_2^2 + C_2 h_2^4 + \\dots) - (A + 4C_1 h_2^2 + 16C_2 h_2^4 + \\dots)}{3}\n$$\n$$\nA_{imp} = \\frac{(4A - A) + (4C_1 - 4C_1)h_2^2 + (4C_2 - 16C_2)h_2^4 + \\dots}{3}\n$$\n$$\nA_{imp} = \\frac{3A - 12C_2 h_2^4 + \\dots}{3} = A - 4C_2 h_2^4 + \\dots\n$$\n现在主误差项是 $-4C_2 h_2^4$，它与 $h^4$ 成正比。该方法现在是四阶精度的。\n\n### 第 3 部分：算法实现\n\n程序将实现这个推导出的过程。对于每个测试用例 $(h_1, h_2)$：\n1.  定义函数 $f(x) = \\ln(1+x)$ 和点 $x_0 = 1$。精确导数为 $f'(1) = 0.5$。\n2.  定义一个函数来计算中心差分近似 $D(h) = \\frac{f(x_0+h) - f(x_0-h)}{2h}$。\n3.  计算两个二阶近似值：$D_1 = D(h_1)$ 和 $D_2 = D(h_2)$。\n4.  使用推导出的公式计算改进的四阶估计值：$A_{imp} = \\frac{4D_2 - D_1}{3}$。\n5.  计算绝对误差：$E = |A_{imp} - 0.5|$。\n6.  收集所有三种情况的误差，并按照指定格式四舍五入到 $12$ 位小数后打印。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a fourth-order finite difference scheme to estimate\n    the derivative of f(x) = ln(1+x) at x=1.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (moderate steps)\n        (1e-2, 5e-3),\n        # Case B (coarse steps)\n        (1e-1, 5e-2),\n        # Case C (very fine steps)\n        (1e-6, 5e-7),\n    ]\n\n    # Define the point of interest and the function.\n    x0 = 1.0\n    # The function f(x) = ln(1+x)\n    f = lambda x: np.log(1.0 + x)\n\n    # The exact value of the derivative f'(x) = 1/(1+x) at x_0 = 1.\n    exact_derivative = 0.5\n\n    # Helper function for the second-order central difference approximation.\n    def central_difference(h, x_val, func):\n        \"\"\"\n        Computes the second-order central difference approximation for f'(x_val).\n        \"\"\"\n        return (func(x_val + h) - func(x_val - h)) / (2.0 * h)\n\n    # List to store the absolute errors of the improved estimates.\n    absolute_errors = []\n\n    for h1, h2 in test_cases:\n        # 1. Compute the two second-order central difference approximations.\n        # D(h1) is the approximation with the larger step size.\n        d1 = central_difference(h1, x0, f)\n        # D(h2) is the approximation with the smaller step size.\n        d2 = central_difference(h2, x0, f)\n\n        # 2. Compute the improved derivative estimate (Richardson Extrapolation).\n        # This formula was derived to cancel the O(h^2) error term,\n        # resulting in an O(h^4) approximation.\n        improved_estimate = (4.0 * d2 - d1) / 3.0\n\n        # 3. Compute the absolute error of the improved estimate.\n        error = np.abs(improved_estimate - exact_derivative)\n        absolute_errors.append(error)\n\n    # Final print statement in the exact required format.\n    # The errors are rounded to 12 decimal places.\n    print(f\"[{','.join(f'{err:.12f}' for err in absolute_errors)}]\")\n\nsolve()\n```", "id": "3525596"}, {"introduction": "数值微分的一个固有挑战是其对噪声的敏感性，这在处理来自观测或模拟的非理想数据时尤为突出。本练习将让你从第一性原理出发，定量分析一个高阶有限差分算子如何放大输入数据中的白噪声。通过推导导数估计的方差 [@problem_id:3525628]，你将深刻理解步长选择与噪声放大之间的权衡，这是在实践中成功应用数值微分的关键。", "problem": "一个天文台使用星载光度计以均匀的采样步调 $\\Delta t$ 监测一个变源活动星系核的比光度时间序列 $L(t)$。每个离散样本 $L_{i} \\equiv L(t_{i})$ 都受到以仪器为主的白光子噪声的污染，该噪声是零均值的，在样本之间独立，并且每个样本的方差为 $\\sigma^{2}$。为了估计在时间 $t_{i}$ 的瞬时时间导数 $\\frac{dL}{dt}$，你采用由下式定义的 $5$ 点 $4$ 阶中心有限差分算子：\n$$\n\\left.\\frac{dL}{dt}\\right|_{t_{i}} \\approx \\frac{-L_{i+2} + 8 L_{i+1} - 8 L_{i-1} + L_{i-2}}{12\\,\\Delta t}.\n$$\n从独立、零均值随机变量的方差和有限差分估计量的线性结构等基本原理出发，量化方差为 $\\sigma^{2}$ 的白噪声如何通过此导数算子传播，并推导导数估计值方差的闭式解析表达式，该表达式仅用 $\\sigma$ 和 $\\Delta t$ 表示。请以 $\\sigma$ 和 $\\Delta t$ 表示的单个简化符号表达式的形式给出你的最终答案；不要包含单位。", "solution": "该问题是有效的。这是一个在计算天体物理学和统计学中适定的、有科学依据的问题，要求将误差传播的基本原理应用于一个标准的数值微分公式。所有必要的信息都已提供，且术语精确。\n\n任务是确定时间导数估计的方差，我们将其表示为 $\\hat{D}_{i}$。该估计量由应用于带噪声测量值 $L_j$ 的 $5$ 点 $4$ 阶中心有限差分算子给出：\n$$\n\\hat{D}_{i} = \\left.\\frac{dL}{dt}\\right|_{t_{i}} \\approx \\frac{-L_{i+2} + 8 L_{i+1} - 8 L_{i-1} + L_{i-2}}{12\\,\\Delta t}\n$$\n每个测量值 $L_j$ 是一个随机变量。它可以被建模为真实、确定性的比光度 $L_{\\text{true}}(t_j)$ 与一个随机噪声项 $\\epsilon_j$ 的和：\n$$\nL_j = L_{\\text{true}}(t_j) + \\epsilon_j\n$$\n问题陈述，噪声 $\\epsilon_j$ 是零均值的，在样本之间独立，且具有恒定方差 $\\sigma^2$。也就是说，对于任意索引 $j$ 和 $k$：\n$$\nE[\\epsilon_j] = 0\n$$\n$$\n\\text{Var}(\\epsilon_j) = E[\\epsilon_j^2] - (E[\\epsilon_j])^2 = E[\\epsilon_j^2] = \\sigma^2\n$$\n$$\n\\text{Cov}(\\epsilon_j, \\epsilon_k) = 0 \\quad \\text{for} \\quad j \\neq k\n$$\n因此，测量样本 $L_j$ 的方差为：\n$$\n\\text{Var}(L_j) = \\text{Var}(L_{\\text{true}}(t_j) + \\epsilon_j)\n$$\n由于 $L_{\\text{true}}(t_j)$ 是一个确定性（非随机）量，它在方差计算中充当一个常数。一个随机变量加上一个常数的方差等于该随机变量自身的方差。因此：\n$$\n\\text{Var}(L_j) = \\text{Var}(\\epsilon_j) = \\sigma^2\n$$\n导数估计量 $\\hat{D}_{i}$ 是随机变量 $L_{i+2}$、$L_{i+1}$、$L_{i-1}$ 和 $L_{i-2}$ 的线性组合。我们可以将 $\\hat{D}_{i}$ 写成：\n$$\n\\hat{D}_{i} = c_{i+2} L_{i+2} + c_{i+1} L_{i+1} + c_{i-1} L_{i-1} + c_{i-2} L_{i-2}\n$$\n其中系数为：\n$$\nc_{i+2} = \\frac{-1}{12\\,\\Delta t}, \\quad c_{i+1} = \\frac{8}{12\\,\\Delta t}, \\quad c_{i-1} = \\frac{-8}{12\\,\\Delta t}, \\quad c_{i-2} = \\frac{1}{12\\,\\Delta t}\n$$\n方差传播的基本原理指出，对于由系数 $a_j$ 构成的独立随机变量 $X_j$ 的线性组合 $Y = \\sum_j a_j X_j$， $Y$ 的方差由下式给出：\n$$\n\\text{Var}(Y) = \\sum_j a_j^2 \\text{Var}(X_j)\n$$\n在我们的情况中，随机变量是测量值 $L_j$，由于它们的噪声分量 $\\epsilon_j$ 是独立的，所以这些测量值也是独立的。每个 $L_j$ 的方差是 $\\sigma^2$。将此原理应用于我们的估计量 $\\hat{D}_{i}$：\n$$\n\\text{Var}(\\hat{D}_{i}) = c_{i+2}^2 \\text{Var}(L_{i+2}) + c_{i+1}^2 \\text{Var}(L_{i+1}) + c_{i-1}^2 \\text{Var}(L_{i-1}) + c_{i-2}^2 \\text{Var}(L_{i-2})\n$$\n代入这些系数和方差 $\\sigma^2$：\n$$\n\\text{Var}(\\hat{D}_{i}) = \\left(\\frac{-1}{12\\,\\Delta t}\\right)^2 \\sigma^2 + \\left(\\frac{8}{12\\,\\Delta t}\\right)^2 \\sigma^2 + \\left(\\frac{-8}{12\\,\\Delta t}\\right)^2 \\sigma^2 + \\left(\\frac{1}{12\\,\\Delta t}\\right)^2 \\sigma^2\n$$\n我们可以提出公因式 $\\frac{\\sigma^2}{(12\\,\\Delta t)^2}$：\n$$\n\\text{Var}(\\hat{D}_{i}) = \\frac{\\sigma^2}{(12\\,\\Delta t)^2} \\left[ (-1)^2 + 8^2 + (-8)^2 + 1^2 \\right]\n$$\n现在，我们计算系数的平方和：\n$$\n(-1)^2 + 8^2 + (-8)^2 + 1^2 = 1 + 64 + 64 + 1 = 130\n$$\n将这个和代回到方差的表达式中：\n$$\n\\text{Var}(\\hat{D}_{i}) = \\frac{\\sigma^2}{(12\\,\\Delta t)^2} (130) = \\frac{130 \\sigma^2}{144 (\\Delta t)^2}\n$$\n最后，我们简化数值分数 $\\frac{130}{144}$。分子和分母都可以被 $2$ 整除：\n$$\n\\frac{130}{144} = \\frac{65}{72}\n$$\n数字 $65$ 和 $72$ 互质，所以这个分数已是最简形式。导数估计值方差的最终表达式为：\n$$\n\\text{Var}(\\hat{D}_{i}) = \\frac{65 \\sigma^2}{72 (\\Delta t)^2}\n$$\n该表达式量化了输入样本的方差 $\\sigma^2$ 如何通过指定的有限差分算子传播，表明最终的方差被一个数值因子放大，并与时间步长 $\\Delta t$ 的平方成反比。", "answer": "$$\\boxed{\\frac{65 \\sigma^2}{72 \\Delta t^2}}$$", "id": "3525628"}, {"introduction": "有限差分不仅可以用于计算物理量的导数，还能作为一种强大的诊断工具来分析数值模拟的质量。这个练习将数值积分与数值微分相结合，要求你对一个N体问题的哈密顿量（总能量）时间序列进行微分，以计算能量的时间变化率 $dE/dt$。通过分析 $dE/dt$ 的短期噪声与能量的长期漂移之间的关联 [@problem_id:3525662]，你将学会如何利用数值微分来评估和理解时间积分方案的性能，这是计算天体物理学中的一项高级技能。", "problem": "您的任务是设计一个数值实验，在计算天体物理学的背景下，将基本力学原理与数值分析联系起来。从牛顿万有引力定律和哈密顿力学出发，考虑无量纲引力单位下的引力$N$体问题，其中引力常数$G$设为$G=1$。运动方程遵循哈密顿方程，其哈密顿量（总能量）由下式给出\n$$\nH(\\{\\mathbf{x}_i,\\mathbf{v}_i\\}_{i=1}^N) \\;=\\; \\sum_{i=1}^N \\frac{1}{2} m_i \\lVert \\mathbf{v}_i \\rVert^2 \\;-\\; \\sum_{1 \\le i  j \\le N} \\frac{G m_i m_j}{\\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert}.\n$$\n哈密顿量沿着精确解的时间导数恒为零。在离散数值积分器中，在时间点 $t_n = n\\,\\Delta t$ 处沿离散轨道计算的哈密顿量，\n$$\nE_n \\;\\equiv\\; H\\!\\left(\\{\\mathbf{x}_i^{(n)},\\mathbf{v}_i^{(n)}\\}_{i=1}^N\\right),\n$$\n并非严格恒定，其时间导数也非严格为零。在本问题中，您将从离散的哈密顿量时间序列中计算 $\\mathrm{d}E/\\mathrm{d}t$ 的有限差分估计，量化其噪声，并分析该噪声与积分器引起的长期能量漂移之间的相关性。\n\n基本原理和约束条件：\n- 使用牛顿万有引力定律计算加速度，\n$$\n\\mathbf{a}_i \\;=\\; \\sum_{j\\ne i} G m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^3}.\n$$\n- 使用辛速度-Verlet（蛙跳）时间积分器，在总时长 $T$ 内以固定的时间步长 $\\Delta t$ 对系统进行时间演化。\n- 在数值轨道的每个存储时间点 $t_n$ 上计算离散哈密顿量 $E_n$。\n\n估计与分析任务：\n- 从时间序列 $\\{(t_n,E_n)\\}_{n=0}^{N_{\\mathrm{step}}}$ 出发，使用截断误差为 $\\mathcal{O}(\\Delta t^2)$ 阶的中心有限差分格式，计算 $\\mathrm{d}E/\\mathrm{d}t$ 的数值估计。在内部时间索引上构建时间序列 $\\{(\\widehat{\\mathrm{d}E/\\mathrm{d}t})_n\\}$。\n- 定义有限差分噪声水平 $\\sigma_{dE/dt}$ 为中心差分值去除其时间平均值后的标准差，即，\n$$\n\\sigma_{dE/dt} \\;=\\; \\sqrt{\\frac{1}{M}\\sum_{n} \\left( (\\widehat{\\mathrm{d}E/\\mathrm{d}t})_n - \\overline{\\widehat{\\mathrm{d}E/\\mathrm{d}t}} \\right)^2},\n$$\n其中 $M$ 是内部时间索引的数量，$\\overline{\\widehat{\\mathrm{d}E/\\mathrm{d}t}}$ 是在这些内部索引上的时间平均值。\n- 定义长期能量漂移率 $\\alpha$ 为在整个模拟时间区间内，函数 $E(t)-E(0)$ 相对于 $t$ 的斜率（以最小二乘线性回归的意义），以相同的代码单位每单位时间表示。具体来说，$\\alpha$ 是最佳拟合直线 $E(t)-E(0) \\approx \\alpha\\, t + \\beta$ 中 $t$ 的系数。\n\n相关性分析目标：\n- 对于下面测试套件中每个指定的运行族，在一组固定的值上改变 $\\Delta t$，计算相应的配对 $\\big(\\sigma_{dE/dt}, |\\alpha|\\big)$，然后计算皮尔逊相关系数\n$$\nr \\;=\\; \\frac{\\sum_k \\left(\\sigma_{dE/dt}^{(k)} - \\overline{\\sigma}\\right)\\left(|\\alpha|^{(k)} - \\overline{a}\\right)}{\\sqrt{\\sum_k \\left(\\sigma_{dE/dt}^{(k)} - \\overline{\\sigma}\\right)^2}\\sqrt{\\sum_k \\left(|\\alpha|^{(k)} - \\overline{a}\\right)^2}},\n$$\n其中索引 $k$ 遍历 $\\Delta t$ 值的网格，上划线表示对 $k$ 的平均。将 $r$ 报告为一个无量纲实数。\n\n初值问题和单位：\n- 在二维空间中处理 $N=2$ 个天体，以隔离积分和微分效应。对于相对二体运动，设 $m_1 = 1$, $m_2 = 1$, $G=1$ 且半长轴 $a=1$。对于每种情况，按如下方式在离心率为 $e$ 的近心点处初始化系统。设近心点距离为 $r_{\\mathrm{p}} = a(1-e)$。将天体放置在 $x$ 轴上，质心位于原点：\n$$\n\\mathbf{x}_1(0) = \\left(-\\frac{m_2}{m_1+m_2}r_{\\mathrm{p}},\\, 0\\right),\\quad \\mathbf{x}_2(0) = \\left(+\\frac{m_1}{m_1+m_2}r_{\\mathrm{p}},\\, 0\\right).\n$$\n设置与间距垂直的速度以形成所需椭圆。相对近心点速度为\n$$\nv_{\\mathrm{p}} \\;=\\; \\sqrt{\\frac{G(m_1+m_2)\\,(1+e)}{a(1-e)}}.\n$$\n分配质心动量，使总动量为零：\n$$\n\\mathbf{v}_1(0) = \\left(0,\\,-\\frac{m_2}{m_1+m_2} v_{\\mathrm{p}}\\right),\\quad \\mathbf{v}_2(0) = \\left(0,\\,+\\frac{m_1}{m_1+m_2} v_{\\mathrm{p}}\\right).\n$$\n所有量均为无量纲的代码单位；所要求的相关系数是无量纲的，因此最终输出无需报告物理单位。\n\n测试套件：\n- 情况 $\\mathcal{A}$（理想情况，中等偏心）：$e=0.1$，总时间 $T=10$，$\\Delta t \\in \\{0.05,\\,0.025,\\,0.0125,\\,0.00625,\\,0.003125\\}$。\n- 情况 $\\mathcal{B}$（更高偏心，更强的力变化）：$e=0.6$，总时间 $T=10$，$\\Delta t \\in \\{0.025,\\,0.0125,\\,0.00625,\\,0.003125,\\,0.0015625\\}$。\n- 情况 $\\mathcal{C}$（边缘情况，极高偏心）：$e=0.9$，总时间 $T=10$，$\\Delta t \\in \\{0.0125,\\,0.00625,\\,0.003125,\\,0.0015625,\\,0.00078125\\}$。\n\n您的任务：\n- 按描述实现积分器和能量诊断。\n- 对于每种情况，在指定网格上的每个 $\\Delta t$ 值，计算 $\\mathrm{d}E/\\mathrm{d}t$ 的有限差分估计、噪声度量 $\\sigma_{dE/dt}$ 和绝对漂移率 $|\\alpha|$。然后计算在 $\\Delta t$ 网格上的皮尔逊相关系数 $r$。\n- 您的程序应产生单行输出，其中包含三个相关系数，格式为方括号内的逗号分隔列表，顺序为 $[r_{\\mathcal{A}}, r_{\\mathcal{B}}, r_{\\mathcal{C}}]$。每个 $r$ 必须是浮点数。不应打印任何其他文本。\n\n本问题不使用角度测量。如果您选择在内部计算中包含任何中间角度量，它们必须以弧度为单位，但最终输出中不需要任何角度。最终结果都是无量纲的浮点数。数值微分必须使用截断误差为 $\\mathcal{O}(\\Delta t^2)$ 的中心有限差分格式，并且最小二乘斜率必须通过对整个时间序列进行线性回归来计算。", "solution": "所提出的问题是计算天体物理学中一个有效的数值实验。它在科学上基于牛顿力学和哈密顿形式体系，问题设定良好，具有一套完整且一致的参数、定义和任务。其目标是研究使用辛积分器演化的二体系统中，数值能量的短期噪声与长期漂移之间的相关性。\n\n解决方案分四个阶段进行：\n1.  为引力二体问题实现一个数值积分器。\n2.  沿着数值生成的轨道计算系统的能量。\n3.  从能量时间序列中计算两个关键指标：其数值时间导数的噪声和长期漂移率。\n4.  在一系列模拟参数上分析这两个指标之间的相关性。\n\n**1. 系统动力学与数值积分**\n\n该系统由二维平面上的两个质量分别为 $m_1$ 和 $m_2$ 的天体组成，它们通过牛顿万有引力定律相互作用，引力常数 $G$ 设为1。系统在任意时刻的状态由位置 $\\{\\mathbf{x}_1, \\mathbf{x}_2\\}$ 和速度 $\\{\\mathbf{v}_1, \\mathbf{v}_2\\}$ 给出。运动方程由哈密顿量导出，它代表系统的总能量：\n$$\nH(\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{v}_1, \\mathbf{v}_2) = \\underbrace{\\frac{1}{2} m_1 \\lVert \\mathbf{v}_1 \\rVert^2 + \\frac{1}{2} m_2 \\lVert \\mathbf{v}_2 \\rVert^2}_{\\text{动能}} - \\underbrace{\\frac{G m_1 m_2}{\\lVert \\mathbf{x}_1 - \\mathbf{x}_2 \\rVert}}_{\\text{势能}}\n$$\n根据哈密顿方程，或等效地，根据牛顿第二定律与引力，天体 $i$ 的加速度为：\n$$\n\\mathbf{a}_i = \\frac{\\mathrm{d}^2\\mathbf{x}_i}{\\mathrm{d}t^2} = \\sum_{j \\neq i} G m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^3}\n$$\n对于我们的二体系统（$N=2$），这些方程简化为：\n$$\n\\mathbf{a}_1 = G m_2 \\frac{\\mathbf{x}_2 - \\mathbf{x}_1}{\\lVert \\mathbf{x}_2 - \\mathbf{x}_1 \\rVert^3}, \\quad \\mathbf{a}_2 = G m_1 \\frac{\\mathbf{x}_1 - \\mathbf{x}_2}{\\lVert \\mathbf{x}_1 - \\mathbf{x}_2 \\rVert^3} = -\\frac{m_1}{m_2}\\mathbf{a}_1\n$$\n为了在时间上对系统进行演化，我们采用辛速度-Verlet积分器。给定在时间 $t_n = n \\Delta t$ 时的状态 $(\\mathbf{x}^{(n)}, \\mathbf{v}^{(n)})$ 和加速度 $\\mathbf{a}^{(n)} = \\mathbf{a}(\\mathbf{x}^{(n)})$，在时间 $t_{n+1}$ 的状态通过以下三个步骤计算：\n1.  计算半步速度更新： $\\mathbf{v}^{(n+1/2)} = \\mathbf{v}^{(n)} + \\mathbf{a}^{(n)} \\frac{\\Delta t}{2}$。\n2.  将位置更新到完整的下一步： $\\mathbf{x}^{(n+1)} = \\mathbf{x}^{(n)} + \\mathbf{v}^{(n+1/2)} \\Delta t$。\n3.  计算新加速度 $\\mathbf{a}^{(n+1)} = \\mathbf{a}(\\mathbf{x}^{(n+1)})$ 并完成速度更新： $\\mathbf{v}^{(n+1)} = \\mathbf{v}^{(n+1/2)} + \\mathbf{a}^{(n+1)} \\frac{\\Delta t}{2}$。\n\n这个过程重复进行，总时长为 $T$，生成一个离散轨道 $\\{(\\mathbf{x}_i^{(n)}, \\mathbf{v}_i^{(n)})\\}_{n=0}^{N_{\\mathrm{step}}}$，其中 $N_{\\mathrm{step}} = T/\\Delta t$。\n\n**2. 能量时间序列**\n\n在积分的每一步 $n$，我们计算离散哈密顿量 $E_n = H(\\{\\mathbf{x}_i^{(n)}, \\mathbf{v}_i^{(n)}\\})$。这将产生一个总能量的时间序列 $\\{(t_n, E_n)\\}_{n=0}^{N_{\\mathrm{step}}}$。对于精确解，$E(t)$ 将是一个常数。由于离散化，$E_n$ 会出现波动。像速度-Verlet这样的辛积分器以精确守恒一个附近的“影子哈密顿量”而闻名，这导致原始哈密顿量 $H$ 在长时间尺度上表现为有界的振荡误差。\n\n**3. 分析指标：噪声与漂移**\n\n该问题要求从能量时间序列 $E_n$ 中计算两个派生量。\n\n首先，我们使用二阶精度的中心有限差分公式，在时间序列的内部点（$n=1, \\dots, N_{\\mathrm{step}}-1$）上估计能量的时间导数 $\\mathrm{d}E/\\mathrm{d}t$：\n$$\n(\\widehat{\\mathrm{d}E/\\mathrm{d}t})_n = \\frac{E_{n+1} - E_{n-1}}{2\\Delta t}\n$$\n这个数值导数的噪声由度量 $\\sigma_{dE/dt}$ 量化，定义为该序列的总体标准差：\n$$\n\\sigma_{dE/dt} = \\sqrt{\\frac{1}{M}\\sum_{n=1}^{N_{\\mathrm{step}}-1} \\left( (\\widehat{\\mathrm{d}E/\\mathrm{d}t})_n - \\overline{\\widehat{\\mathrm{d}E/\\mathrm{d}t}} \\right)^2}\n$$\n其中 $M=N_{\\mathrm{step}}-1$ 是内部点的数量，上划线表示在这些点上的平均值。\n\n其次，我们量化长期能量漂移率 $\\alpha$。这是通过对能量误差（相对于其初始值 $E_n - E_0$）与时间 $t_n$ 进行线性最小二乘回归得到的。我们找到最能拟合模型 $E(t) - E_0 \\approx \\alpha t + \\beta$ 的斜率 $\\alpha$ 和截距 $\\beta$。问题要求的是这个斜率的绝对值 $|\\alpha|$。\n\n**4. 相关性分析**\n\n核心任务是研究短期噪声度量 $\\sigma_{dE/dt}$ 和长期漂移度量 $|\\alpha|$ 之间的关系。对于由特定轨道偏心率 $e$ 定义的每个测试用例，我们执行一系列模拟，每次模拟都使用来自给定网格的不同时间步长 $\\Delta t$。这将产生一组配对 $(\\sigma_{dE/dt}^{(k)}, |\\alpha|^{(k)})$，其中 $k$ 索引对应于特定 $\\Delta t$ 值的运行。\n\n最后，我们计算这些配对的皮尔逊相关系数 $r$，以量化当 $\\Delta t$ 变化时 $\\sigma_{dE/dt}$ 和 $|\\alpha|$ 之间的线性相关性：\n$$\nr = \\frac{\\sum_k (\\sigma_{dE/dt}^{(k)} - \\overline{\\sigma})(|\\alpha|^{(k)} - \\overline{a})}{\\sqrt{\\sum_k (\\sigma_{dE/dt}^{(k)} - \\overline{\\sigma})^2}\\sqrt{\\sum_k (|\\alpha|^{(k)} - \\overline{a})^2}}\n$$\n其中 $\\overline{\\sigma}$ 是 $\\sigma_{dE/dt}^{(k)}$ 值的平均值，$\\overline{a}$ 是 $|\\alpha|^{(k)}$ 值的平均值。由于速度-Verlet积分中的误差项通常按 $\\Delta t$ 的幂次缩放（具体来说，能量振幅为 $\\mathcal{O}(\\Delta t^2)$，这些派生指标很可能也是如此），因此预计 $\\sigma_{dE/dt}$ 和 $|\\alpha|$ 之间存在强相关性，这应该会产生一个接近 1 的 $r$ 值。\n\n整个过程被封装在一个 Python 脚本中，该脚本自动对指定的三个测试用例进行模拟和分析，最终报告三个相关系数 $[r_{\\mathcal{A}}, r_{\\mathcal{B}}, r_{\\mathcal{C}}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as defined in the problem\nG_CONST = 1.0\nM1 = 1.0\nM2 = 1.0\nA_SEMI_MAJOR = 1.0\n\ndef calculate_energy(positions, velocities):\n    \"\"\"\n    Computes the total energy (Hamiltonian) of the two-body system.\n    \"\"\"\n    masses = np.array([M1, M2])\n    # Kinetic energy: 0.5 * m * v^2 for each body\n    velocity_sq = np.sum(velocities**2, axis=1)\n    kinetic_energy = 0.5 * np.sum(masses * velocity_sq)\n\n    # Potential energy: -G * m1 * m2 / r\n    r_vec = positions[0] - positions[1]\n    r_norm = np.linalg.norm(r_vec)\n    potential_energy = -G_CONST * M1 * M2 / r_norm\n\n    return kinetic_energy + potential_energy\n\ndef calculate_acceleration(positions):\n    \"\"\"\n    Computes the accelerations of the two bodies due to their mutual gravity.\n    \"\"\"\n    accel = np.zeros_like(positions)\n    r_vec_12 = positions[1] - positions[0]  # Vector from body 1 to body 2\n    r_norm_12 = np.linalg.norm(r_vec_12)\n    \n    # Gravitational force F = G*m1*m2/r^2, so a = F/m\n    # a_1 = G * m_2 * (r_2 - r_1) / |r_2 - r_1|^3\n    common_factor = G_CONST / (r_norm_12**3)\n    accel[0] = common_factor * M2 * r_vec_12\n    accel[1] = -common_factor * M1 * r_vec_12\n    \n    return accel\n\ndef run_simulation(eccentricity, total_time, dt):\n    \"\"\"\n    Runs a single N-body simulation using a velocity-Verlet integrator.\n    \n    Args:\n        eccentricity (float): Orbital eccentricity e.\n        total_time (float): Total integration time T.\n        dt (float): Timestep delta_t.\n        \n    Returns:\n        tuple: A tuple containing the time array and the energy time series.\n    \"\"\"\n    # Set up initial conditions at pericenter\n    r_pericenter = A_SEMI_MAJOR * (1.0 - eccentricity)\n    v_pericenter = np.sqrt(G_CONST * (M1 + M2) * (1.0 + eccentricity) / (A_SEMI_MAJOR * (1.0 - eccentricity)))\n    \n    m_total = M1 + M2\n    positions = np.array([\n        [-M2 / m_total * r_pericenter, 0.0],\n        [ M1 / m_total * r_pericenter, 0.0]\n    ])\n    \n    velocities = np.array([\n        [0.0, -M2 / m_total * v_pericenter],\n        [0.0,  M1 / m_total * v_pericenter]\n    ])\n    \n    n_steps = int(total_time / dt)\n    times = np.linspace(0, total_time, n_steps + 1)\n    energies = np.zeros(n_steps + 1)\n    \n    # Store initial state\n    energies[0] = calculate_energy(positions, velocities)\n    accelerations = calculate_acceleration(positions)\n    \n    # Main integration loop using velocity-Verlet\n    for i in range(n_steps):\n        v_half = velocities + accelerations * dt * 0.5\n        positions = positions + v_half * dt\n        accelerations = calculate_acceleration(positions)\n        velocities = v_half + accelerations * dt * 0.5\n        energies[i+1] = calculate_energy(positions, velocities)\n        \n    return times, energies\n\ndef calculate_sigma_dEdt(energies, dt):\n    \"\"\"\n    Computes the noise level of the numerical energy derivative.\n    \"\"\"\n    # Centered finite difference: (E_{n+1} - E_{n-1}) / (2*dt) for interior points\n    dEdt_series = (energies[2:] - energies[:-2]) / (2.0 * dt)\n    \n    # As per problem, use population standard deviation (np.std default)\n    return np.std(dEdt_series)\n\ndef calculate_alpha(times, energies):\n    \"\"\"\n    Computes the long-term energy drift rate via linear regression.\n    \"\"\"\n    E0 = energies[0]\n    delta_E = energies - E0\n    \n    # Linear regression of delta_E vs. time, returns [slope, intercept]\n    alpha, _ = np.polyfit(times, delta_E, 1)\n    return alpha\n\ndef process_case(eccentricity, total_time, dt_values):\n    \"\"\"\n    Processes one test case by running simulations for a grid of timesteps\n    and calculating the final Pearson correlation coefficient.\n    \"\"\"\n    sigma_list = []\n    alpha_list = []\n    \n    for dt in dt_values:\n        times, energies = run_simulation(eccentricity, total_time, dt)\n        \n        sigma_dEdt = calculate_sigma_dEdt(energies, dt)\n        alpha = calculate_alpha(times, energies)\n        \n        sigma_list.append(sigma_dEdt)\n        alpha_list.append(np.abs(alpha))\n\n    # Compute Pearson correlation coefficient between the two lists\n    # np.corrcoef returns the correlation matrix, we need the off-diagonal element\n    correlation_matrix = np.corrcoef(sigma_list, alpha_list)\n    r = correlation_matrix[0, 1]\n    \n    return r\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the final results.\n    \"\"\"\n    # Define the test suite from the problem statement.\n    test_cases = [\n        # Case A\n        {'e': 0.1, 'T': 10, 'dt_values': [0.05, 0.025, 0.0125, 0.00625, 0.003125]},\n        # Case B\n        {'e': 0.6, 'T': 10, 'dt_values': [0.025, 0.0125, 0.00625, 0.003125, 0.0015625]},\n        # Case C\n        {'e': 0.9, 'T': 10, 'dt_values': [0.0125, 0.00625, 0.003125, 0.0015625, 0.00078125]}\n    ]\n\n    results = []\n    for case_params in test_cases:\n        r = process_case(case_params['e'], case_params['T'], case_params['dt_values'])\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3525662"}]}