{"hands_on_practices": [{"introduction": "虽然高阶多项式插值看起来简单直接，但它可能会表现出剧烈的振荡，这个陷阱被称为龙格现象。此练习 [@problem_id:3515473] 使用经典的龙格函数来探究其在使用等距节点时的不稳定性，并展示两种有效的解决方案：使用切比雪夫点优化节点布局，以及改用一种本质上不同的方法——三次样条。理解这一现象对于在任何科学领域中从离散数据可靠地重建函数都至关重要。", "problem": "在计算天体物理学中，从离散样本重建平滑的仪器响应函数或谱线轮廓需要稳健的插值方法。考虑闭区间 $[-1, 1]$ 上的解析测试函数 $f(x) = \\dfrac{1}{1 + 25 x^2}$。众所周知，当在等距节点上使用高阶全局多项式时，此函数会揭示插值不稳定性。请您研究节点布局和插值方案如何影响最大误差。\n\n请编写一个程序，使用 $N = n+1$ 个节点（其中 $n = 10$，因此插值多项式为 $10$ 次）执行以下任务：\n\n1.  使用两组节点集，为 $[-1, 1]$ 上的 $f(x)$ 构建 $10$ 次拉格朗日多项式插值：\n    -   等距节点 $x_i = -1 + \\dfrac{2 i}{n}$，其中 $i = 0, 1, \\dots, n$。\n    -   第二类切比雪夫节点 $x_i = \\cos\\!\\left(\\dfrac{i \\pi}{n}\\right)$，其中 $i = 0, 1, \\dots, n$，角度 $\\pi$ 以弧度为单位。\n2.  使用相同的等距节点，构建一个自然三次样条插值（分段三次多项式，具有连续的一阶和二阶导数，且在端点处的二阶导数为零）。\n3.  对于每个插值函数，在 $[-1, 1]$ 上均匀分布的 $M = 20001$ 个点的密集评估网格上，估计最大绝对插值误差。最大绝对插值误差定义为 $\\max_{x \\in \\mathcal{G}} \\left| f(x) - s(x) \\right|$，其中 $\\mathcal{G}$ 是评估网格，$s(x)$ 是插值函数。\n4.  此外，对于使用等距节点的 $10$ 次拉格朗日多项式，估计其在“边缘区域”（即区间并集 $[-1, -0.9] \\cup [0.9, 1]$）上的最大绝对插值误差。为此边缘区域使用一个密集的评估网格，每个子区间包含 $5001$ 个点（在这两个子区间内均均匀分布）。\n5.  不涉及物理单位。用于计算切比雪夫节点的余弦函数中的角度必须以弧度为单位。\n\n您的测试套件必须包括以下四种情况：\n-   情况 A：在 $[-1, 1]$ 上使用等距节点的 $10$ 次拉格朗日插值；以浮点数形式报告最大绝对误差。\n-   情况 B：在 $[-1, 1]$ 上使用第二类切比雪夫节点的 $10$ 次拉格朗日插值；以浮点数形式报告最大绝对误差。\n-   情况 C：在 $[-1, 1]$ 上使用等距节点的自然三次样条插值；以浮点数形式报告最大绝对误差。\n-   情况 D：使用等距节点的 $10$ 次拉格朗日插值，误差限制在 $[-1, -0.9] \\cup [0.9, 1]$ 内；以浮点数形式报告最大绝对误差。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，\"[resultA,resultB,resultC,resultD]\"），其中每个条目都是十进制格式的浮点数。\n\n最后，在您的解题说明中，通过引用多项式插值误差的结构、节点布局对插值算子增长的影响，以及三次样条的平滑特性和局部性质，来解释观察到的误差差异。", "solution": "该问题要求分析龙格函数 $f(x) = \\dfrac{1}{1 + 25 x^2}$ 在区间 $[-1, 1]$ 上使用不同插值方案和节点分布时的插值误差。我们将比较在等距节点和切比雪夫节点上的拉格朗日多项式插值，以及在等距节点上的自然三次样条插值。分析将基于最大绝对误差 $\\max |f(x) - s(x)|$，其中 $s(x)$ 是插值函数。\n\n多项式插值误差的理论基础由以下公式给出：\n$$E(x) = f(x) - P_n(x) = \\frac{f^{(n+1)}(\\xi_x)}{(n+1)!} \\prod_{i=0}^{n} (x - x_i)$$\n其中 $P_n(x)$ 是 $n$ 次插值多项式，点 $x_i$ 是插值节点，而 $\\xi_x$ 是包含 $x$ 和所有节点 $x_i$ 的最小区间内的一个点。误差是两项的乘积：一项与函数导数相关，即 $\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}$；另一项与节点布局相关，即节点多项式 $\\omega_{n+1}(x) = \\prod_{i=0}^{n} (x - x_i)$。这两项的行为共同决定了插值的准确性。\n\n**情况 A：使用等距节点的拉格朗日插值**\n\n对于这种情况，我们使用一个次数为 $n=10$ 的单一多项式，该多项式穿过 $N=11$ 个等距节点 $x_i = -1 + 2i/10$（其中 $i=0, \\dots, 10$）。龙格函数 $f(x)$ 在实线上是解析的，但其高阶导数增长非常迅速。例如，$f^{(12)}(0)$ 的数量级约为 $10^{11}$。这意味着 $\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}$ 这一项可能会变得非常大。\n\n同时，对于等距节点，节点多项式 $\\omega_{n+1}(x)$ 的量值在 $[-1, 1]$ 上并非均匀。它在区间中心的值相对较小，但向端点方向呈指数级快速增长。函数的大导数与 $|\\omega_{n+1}(x)|$ 在 $x = \\pm 1$ 附近的大量值相结合，导致插值误差在区间边缘变得非常大。这会引起插值函数的剧烈振荡，即所谓的龙格现象。因此，我们预计在这种情况下最大绝对误差会很大。\n\n**情况 D：等距拉格朗日插值的边缘区域误差**\n\n这种情况专门测量情况 A 的最大误差，但将其限制在“边缘区域” $[-1, -0.9] \\cup [0.9, 1]$ 内。正如对情况 A 的解释，龙格现象表现为在插值区间的端点附近集中的大幅振荡和误差。因此，整个区间 $[-1, 1]$ 上的最大误差几乎肯定会出现在这个边缘区域内。我们预计情况 D 的结果将非常接近甚至等同于情况 A 的结果。\n\n**情况 B：使用切比雪夫节点的拉格朗日插值**\n\n这种情况使用相同的 $10$ 次拉格朗日多项式，但使用一组不同的节点：第二类切比雪夫节点，由 $x_i = \\cos(i\\pi/n)$（其中 $i=0, \\dots, n$）给出。这些节点是 $n$ 次切比雪夫多项式 $T_n(x)$ 的极值点。与等距节点不同，切比雪夫节点在区间 $[-1, 1]$ 的端点附近聚集。\n\n这种特定的布局在最小化节点多项式最大绝对值 $\\|\\omega_{n+1}(x)\\|_{\\infty} = \\max_{x \\in [-1,1]} |\\prod_{i=0}^{n} (x-x_i)|$ 的意义上是最优的。通过最小化误差公式中的这个几何因子，即使对于具有较大高阶导数的函数，使用切比雪夫节点的插值也能有效抑制误差的增长。对于任何具有连续一阶导数的函数，该策略保证了当 $n \\to \\infty$ 时插值函数会收敛于原函数。对于龙格函数，节点分布的这种改变显著减少了端点附近的振荡，并与等距节点情况相比，产生了小得多的最大误差。\n\n**情况 C：自然三次样条插值**\n\n三次样条是另一种类型的插值函数。它不是在整个区间上使用单一的高阶多项式，而是使用一系列分段三次多项式，每个子区间 $[x_i, x_{i+1}]$ 对应一个。通过在内部节点上强制函数及其一阶和二阶导数的连续性，这些分段被平滑地连接在一起。“自然”三次样条施加了额外的边界条件，即二阶导数在端点（$x_0$ 和 $x_n$）处为零。\n\n样条的关键优势在于其*局部性*。在给定子区间 $[x_i, x_{i+1}]$ 内的插值函数主要由其紧邻区域的数据点决定。此属性防止了困扰高阶多项式插值的全局误差传播，使样条对龙格现象“免疫”。三次样条的误差与 $h^4 \\max|f^{(4)}(x)|$ 成正比，其中 $h$ 是节点之间的最大间距。对于固定的函数和足够小的 $h$，这保证了良好的逼近效果。考虑到我们使用的是与情况 A 相同的等距节点，样条插值避免了大幅振荡，并预计会产生一个较小的最大误差，对于当前的 $n$ 值，其误差可与切比雪夫多项式插值相媲美甚至更优。样条为平滑数据的插值提供了一种稳定可靠的方法。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator, CubicSpline\n\ndef solve():\n    \"\"\"\n    Computes interpolation errors for the Runge function using different methods.\n    \"\"\"\n    # Define the analytic test function\n    f = lambda x: 1.0 / (1.0 + 25.0 * x**2)\n\n    # --- Common Parameters ---\n    n = 10\n    N = n + 1  # Number of nodes\n    M = 20001  # Number of evaluation points for the full interval\n\n    # --- Evaluation Grids ---\n    # Dense grid for the full interval [-1, 1]\n    x_eval_full = np.linspace(-1.0, 1.0, M)\n    y_true_full = f(x_eval_full)\n\n    # Dense grid for the edge region [-1, -0.9] U [0.9, 1]\n    M_edge_per_interval = 5001\n    x_edge1 = np.linspace(-1.0, -0.9, M_edge_per_interval)\n    x_edge2 = np.linspace(0.9, 1.0, M_edge_per_interval)\n    x_eval_edge = np.concatenate((x_edge1, x_edge2))\n    y_true_edge = f(x_eval_edge)\n\n    # --- Node Sets ---\n    # Equispaced nodes\n    x_equi = np.linspace(-1.0, 1.0, N)\n    y_equi = f(x_equi)\n\n    # Chebyshev nodes of the second kind\n    i_cheby = np.arange(N)\n    x_cheby = np.cos(i_cheby * np.pi / n)\n    y_cheby = f(x_cheby)\n\n    results = []\n\n    # --- Case A: Lagrange with Equispaced Nodes on [-1, 1] ---\n    # This interpolant will also be used for Case D\n    poly_lagrange_equi = BarycentricInterpolator(x_equi, y_equi)\n    y_interp_A = poly_lagrange_equi(x_eval_full)\n    error_A = np.max(np.abs(y_true_full - y_interp_A))\n    results.append(error_A)\n\n    # --- Case B: Lagrange with Chebyshev Nodes on [-1, 1] ---\n    poly_lagrange_cheby = BarycentricInterpolator(x_cheby, y_cheby)\n    y_interp_B = poly_lagrange_cheby(x_eval_full)\n    error_B = np.max(np.abs(y_true_full - y_interp_B))\n    results.append(error_B)\n\n    # --- Case C: Natural Cubic Spline with Equispaced Nodes on [-1, 1] ---\n    spline_natural = CubicSpline(x_equi, y_equi, bc_type='natural')\n    y_interp_C = spline_natural(x_eval_full)\n    error_C = np.max(np.abs(y_true_full - y_interp_C))\n    results.append(error_C)\n\n    # --- Case D: Lagrange with Equispaced Nodes, Error on Edge Region ---\n    # Use the interpolant from Case A, evaluated on the edge grid\n    y_interp_D = poly_lagrange_equi(x_eval_edge)\n    error_D = np.max(np.abs(y_true_edge - y_interp_D))\n    results.append(error_D)\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3515473"}, {"introduction": "见识了样条的稳定性之后，我们现在深入研究它们的构造。三次样条由其数据点和边界条件唯一确定，边界条件指定了其在区间边缘的行为。此练习 [@problem_id:3515414] 比较了“自然”边界条件（当边界信息未知时的常见默认选择）与“钳制”边界条件（使用已知的导数信息），以观察它们对插值精度和光滑度的影响。在边界处的物理行为已知或必须仔细近似的应用中，这种比较至关重要。", "problem": "考虑区间 $[0,1]$ 上的函数 $f(x)=e^{x}$。在计算天体物理学中，插值常用于从离散样本中重构光滑的剖面（例如，对数强度或光谱通量剖面）。两种广泛使用的插值方法是使用 Lagrange 多项式的多项式插值和使用三次样条的分段三次插值。插值函数的曲率具有物理意义，因为它衡量了局部弯曲程度并与光滑度相关；对于一个二阶可导函数 $y(x)$，其平面曲率 $\\kappa(x)$ 定义为\n$$\n\\kappa(x)=\\frac{\\lvert y''(x)\\rvert}{\\left(1+\\left(y'(x)\\right)^{2}\\right)^{3/2}}.\n$$\n三次样条是构造成分段三次多项式，其在节点处满足 $y(x)$、$y'(x)$ 和 $y''(x)$ 的连续性，并在端点处施加边界条件。两种标准的端点条件是：自然边界条件，强制要求 $y''(0)=0$ 和 $y''(1)=0$；以及钳制边界条件，强制要求 $y'(0)=f'(0)$ 和 $y'(1)=f'(1)$，其中 $f'(x)=e^{x}$。\n\n您的任务是实现一个程序，针对 $[0,1]$ 上的几组节点集，在自然和钳制两种边界条件下构造函数 $f(x)=e^{x}$ 的三次样条插值，并比较：\n- 每个样条在 $[0,1]$ 上的最大曲率，以及\n- 最大内部插值误差，定义为 $\\max_{x\\in(0,1)}\\lvert S(x)-f(x)\\rvert$，其中 $S(x)$ 是样条插值函数。\n\n您必须使用一个在 $[0,1]$ 上包含 $M=10001$ 个点的均匀细网格来数值逼近最大值。计算内部误差时必须排除端点 $x=0$ 和 $x=1$。插值节点 $\\{x_{k}\\}_{k=0}^{n-1}$ 必须选择为以下两种方式之一：\n- 均匀节点，$x_{k}=\\frac{k}{n-1}$，或\n- 映射到 $[0,1]$ 上的 Chebyshev 型节点，$x_{k}=\\frac{1}{2}\\left(1-\\cos\\left(\\frac{\\pi k}{n-1}\\right)\\right)$。\n\n对以下每个测试用例，执行以下操作：\n1. 使用给定的节点和样本 $y_{k}=f(x_{k})$，构造自然三次样条和钳制三次样条。\n2. 在细网格上为每个样条计算最大曲率 $\\max_{x\\in[0,1]}\\kappa(x)$。\n3. 在相同的细网格上为每个样条计算最大内部误差 $\\max_{x\\in(0,1)}\\lvert S(x)-f(x)\\rvert$，不包括端点。\n\n测试套件（每个测试用例是一对 $(n,\\text{分布})$）：\n- $(5,\\text{均匀})$\n- $(8,\\text{均匀})$\n- $(8,\\text{chebyshev})$\n- $(17,\\text{均匀})$\n\n所有量均为无量纲；无需物理单位。三角函数中出现的角度以弧度为单位。您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个格式为 $[C_{\\mathrm{nat}},C_{\\mathrm{clamp}},E_{\\mathrm{nat}},E_{\\mathrm{clamp}}]$ 的列表，每个浮点数四舍五入到八位小数。例如，一个有效的整体输出格式是\n$$\n\\big[ [\\ldots,\\ldots,\\ldots,\\ldots], [\\ldots,\\ldots,\\ldots,\\ldots], [\\ldots,\\ldots,\\ldots,\\ldots], [\\ldots,\\ldots,\\ldots,\\ldots] \\big].\n$$", "solution": "用户希望我解决一个涉及三次样条插值的数值问题。\n\n### 第1步：提取已知信息\n- **待插值函数**：$f(x) = e^{x}$\n- **区间**：$[0, 1]$\n- **插值函数类型**：三次样条\n- **样条的边界条件**：\n    1.  **自然**：$y''(0)=0$ 和 $y''(1)=0$\n    2.  **钳制**：$y'(0)=f'(0)$ 和 $y'(1)=f'(1)$，其中 $f'(x)=e^{x}$\n- **平面曲率公式**：$\\kappa(x) = \\frac{\\lvert y''(x)\\rvert}{\\left(1 + (y'(x))^2\\right)^{3/2}}$\n- **性能指标**：\n    1.  **最大曲率**：$\\max_{x\\in[0,1]} \\kappa(x)$\n    2.  **最大内部插值误差**：$\\max_{x\\in(0,1)} \\lvert S(x) - f(x) \\rvert$，其中 $S(x)$ 是样条插值函数。\n- **数值逼近网格**：$[0,1]$ 上的 $M=10001$ 个点的均匀细网格。内部误差不包括端点 $x=0$ 和 $x=1$。\n- **插值节点**：对于一组 $n$ 个节点 $\\{x_k\\}_{k=0}^{n-1}$：\n    1.  **均匀节点**：$x_k = \\frac{k}{n-1}$\n    2.  **Chebyshev 型节点**：$x_k = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{\\pi k}{n-1}\\right)\\right)$\n- **测试套件**：一系列 $(n, \\text{分布})$ 对：\n    - $(5, \\text{均匀})$\n    - $(8, \\text{均匀})$\n    - $(8, \\text{chebyshev})$\n    - $(17, \\text{均匀})$\n- **输出格式**：一个单行，包含一个列表的列表，格式为 `[[C_nat, C_clamp, E_nat, E_clamp], ...]`，每个数字四舍五入到八位小数。\n\n### 第2步：使用提取的已知信息进行验证\n1.  **科学或事实合理性**：该问题基于数值分析这一成熟的数学领域，特别是插值理论。函数 $f(x)=e^x$、三次样条的定义、曲率和节点分布都是标准的、数学上合理的。没有违反任何科学原理。\n2.  **非形式化或不相关**：该问题是形式化的，并直接与插值主题相关，应用于计算科学（例如计算天体物理学）。它不是比喻性的。\n3.  **不完整或矛盾的设置**：该问题是自洽的。它提供了函数、区间、插值方法、具体的边界条件、比较指标、节点生成方案、评估用的数值网格以及测试用例。没有矛盾之处。\n4.  **不切实际或不可行**：该问题在计算上是可行的，并涉及标准的数值程序。数据在物理上和量纲上是一致的（无量纲量）。\n5.  **不适定或结构不良**：该问题是适定的。对于给定的节点集和有效的边界条件，三次样条插值是唯一的。误差和曲率的评估有明确定义。\n6.  **伪深刻、琐碎或同义反复**：该问题需要对数值算法进行非平凡的实现，并需要理解样条插值。这不是一个琐碎的任务。\n7.  **超出科学可验证性**：结果是数值上可复现的，并可以通过独立实现或与已有的数值分析软件进行比较来验证。\n\n### 第3步：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n该问题要求对函数 $f(x)=e^x$ 在区间 $[0,1]$ 上的两种三次样条插值进行比较。比较基于两个关键指标：插值函数的最大曲率（衡量其弯曲程度）和区间内部的最大误差。\n\n三次样条 $S(x)$ 是一个分段三次多项式，定义在由节点 $\\{x_k\\}_{k=0}^{n-1}$ 划分的一组子区间上。它被构造成二阶连续可导，意味着 $S(x)$, $S'(x)$, 和 $S''(x)$ 在所有内部节点上都是连续的。为了唯一地定义样条，需要在整个区间的端点 $x_0$ 和 $x_{n-1}$ 处施加额外的约束。本问题考虑了两种常见的边界条件。\n\n首先，算法根据指定的分布在区间 $[0,1]$ 上生成 $n$ 个插值节点 $\\{x_k\\}_{k=0}^{n-1}$ 的集合：\n- **均匀节点**：$x_k = \\frac{k}{n-1}$，对于 $k=0, 1, \\dots, n-1$。这些节点是等距的。\n- **Chebyshev 节点**：$x_k = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{\\pi k}{n-1}\\right)\\right)$，对于 $k=0, 1, \\dots, n-1$。这些是半圆上等距点在直径上的投影，导致节点分布在端点附近更密集。\n\n在这些节点上，对函数 $f(x)=e^x$进行采样，得到数据点 $(x_k, y_k)$，其中 $y_k=f(x_k)=e^{x_k}$。\n\n接下来，使用这些数据点构造两个三次样条：\n1.  **自然三次样条 ($S_{\\mathrm{nat}}(x)$)**：该样条通过在区间 $[0,1]$ 的端点施加二阶导数为零的条件来定义。由于节点覆盖了整个区间，这对应于 $S_{\\mathrm{nat}}''(0)=0$ 和 $S_{\\mathrm{nat}}''(1)=0$。当没有关于函数在边界处行为的其它信息时，通常使用此条件。\n2.  **钳制三次样条 ($S_{\\mathrm{clamp}}(x)$)**：该样条包含了函数在端点处一阶导数的信息。边界条件被设定为匹配 $f(x)$ 的精确导数，即 $f'(x)=e^x$。因此，条件为 $S_{\\mathrm{clamp}}'(0) = f'(0) = e^0 = 1$ 和 $S_{\\mathrm{clamp}}'(1) = f'(1) = e^1 = e$。\n\n构造好两个样条后，我们评估它们的质量。评估是在一个覆盖区间 $[0,1]$ 的、包含 $M=10001$ 个点的均匀细网格上进行数值计算。\n\n第一个指标是最大曲率 $\\max_{x\\in[0,1]} \\kappa(x)$。插值函数 $S(x)$ 的曲率 $\\kappa(x)$ 由下式给出：\n$$\n\\kappa_S(x) = \\frac{\\lvert S''(x) \\rvert}{\\left(1 + (S'(x))^2\\right)^{3/2}}\n$$\n我们计算每个样条的一阶和二阶导数，在细网格上对它们求值，计算每个网格点的曲率，并找到最大值。该指标突出了插值函数“弯曲”的程度，这是其光滑性的一个关键方面。\n\n第二个指标是最大内部插值误差，定义为 $\\max_{x\\in(0,1)} \\lvert S(x) - f(x) \\rvert$。其计算方法是在同一个细网格上评估样条 $S(x)$ 和真实函数 $f(x)=e^x$，但排除端点 $x=0$ 和 $x=1$。绝对差的最大值给出了远离插值端点的最坏情况误差。\n\n该实现将利用 `scipy.interpolate.CubicSpline` 类。自然边界条件通过 `bc_type='natural'` 指定。钳制边界条件通过提供一个元组的元组来指定，指明每个边界处的导数阶数和值：`bc_type=((1, 1.0), (1, np.e))`。\n\n对问题陈述中指定的每个测试用例 $(n, \\text{分布})$ 重复此过程。每个测试用例得到的四个值——$C_{\\mathrm{nat}}$、$C_{\\mathrm{clamp}}$、$E_{\\mathrm{nat}}$、$E_{\\mathrm{clamp}}$——被收集起来并按指定格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Constructs natural and clamped cubic splines for f(x)=e^x on [0,1]\n    and computes their maximum curvature and maximum interior error for\n    several node configurations.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5, 'uniform'),\n        (8, 'uniform'),\n        (8, 'chebyshev'),\n        (17, 'uniform')\n    ]\n\n    all_results = []\n\n    # Setup for numerical approximation\n    M = 10001\n    # Fine grid for evaluating curvature and error\n    x_fine = np.linspace(0, 1, M)\n    # Interior part of the fine grid for error calculation\n    x_fine_interior = x_fine[1:-1]\n    \n    # Pre-calculate true function values on the grids\n    f_x_interior = np.exp(x_fine_interior)\n\n    for n, dist in test_cases:\n        # 1. Generate interpolation nodes\n        if dist == 'uniform':\n            nodes_x = np.linspace(0, 1, n)\n        elif dist == 'chebyshev':\n            k = np.arange(n)\n            nodes_x = 0.5 * (1 - np.cos(np.pi * k / (n - 1)))\n        \n        # 2. Sample the function at the nodes\n        nodes_y = np.exp(nodes_x)\n\n        # 3. Construct natural cubic spline and evaluate metrics\n        spline_nat = CubicSpline(nodes_x, nodes_y, bc_type='natural')\n        \n        # Derivatives for curvature\n        S1_nat_vals = spline_nat(x_fine, 1)\n        S2_nat_vals = spline_nat(x_fine, 2)\n        \n        # Maximum curvature for natural spline\n        kappa_nat_vals = np.abs(S2_nat_vals) / (1 + S1_nat_vals**2)**1.5\n        C_nat = np.max(kappa_nat_vals)\n        \n        # Maximum interior error for natural spline\n        error_nat_vals = np.abs(spline_nat(x_fine_interior) - f_x_interior)\n        E_nat = np.max(error_nat_vals)\n\n        # 4. Construct clamped cubic spline and evaluate metrics\n        f_prime_0 = 1.0\n        f_prime_1 = np.e\n        spline_clamp = CubicSpline(nodes_x, nodes_y, bc_type=((1, f_prime_0), (1, f_prime_1)))\n        \n        # Derivatives for curvature\n        S1_clamp_vals = spline_clamp(x_fine, 1)\n        S2_clamp_vals = spline_clamp(x_fine, 2)\n        \n        # Maximum curvature for clamped spline\n        kappa_clamp_vals = np.abs(S2_clamp_vals) / (1 + S1_clamp_vals**2)**1.5\n        C_clamp = np.max(kappa_clamp_vals)\n        \n        # Maximum interior error for clamped spline\n        error_clamp_vals = np.abs(spline_clamp(x_fine_interior) - f_x_interior)\n        E_clamp = np.max(error_clamp_vals)\n\n        # 5. Collect results for the current test case\n        case_results = [C_nat, C_clamp, E_nat, E_clamp]\n        all_results.append(case_results)\n\n    # 6. Format the final output string as specified\n    formatted_cases = []\n    for case_res in all_results:\n        formatted_cases.append(f\"[{','.join(f'{val:.8f}' for val in case_res)}]\")\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```", "id": "3515414"}, {"introduction": "在物理建模中，插值函数通常不仅要精确，还必须保持如单调性这样的基本物理属性。此练习 [@problem_id:3515484] 展示了一个天体物理学中的射线追踪场景，其中传播时间必须是视角的一个单调函数。您将看到标准的拉格朗日多项式如何引入不符合物理现实的“伪最小值”，而保形埃尔米特样条（PCHIP）则能正确地维持物理约束，这突显了选择尊重问题底层物理原理的方法的重要性。", "problem": "考虑一个分层的平面平行大气，其折射率模型为 $n(z) = 1 + \\beta \\exp(-z/H)$，其中 $z$ 是以米为单位的海拔高度，$\\beta$ 是一个小的无量纲参数，$H$ 是以米为单位的标高。假设电磁波射线在当地地平线上方以仰角 $\\theta$ 沿直线从 $z=0$ 传播到 $z=z_{\\max}$。设真空中的光速为 $c$。在直线路径假设下，沿路径的传播时间 $T(\\theta)$ 服从路径积分 $T(\\theta) = \\dfrac{1}{c \\sin \\theta} \\int_{0}^{z_{\\max}} n(z)\\,dz$，该积分在折射率较小、弯曲可忽略不计的情况下有效。\n\n您的任务是实现 $T(\\theta)$（作为 $\\theta$ 的函数，在有限数量的节点上采样）的 $C^1$ 三次样条插值，推导能够防止插值函数产生在底层 $T(\\theta)$ 中不存在的虚假多路径极小值的基本条件，并将其与在相同节点上构建的全局拉格朗日多项式插值函数的行为进行比较。在计算天体物理学中，此类插值出现在通过分层介质（例如，行星大气或恒星包层）进行射线追踪时，而虚假极小值可能导致人为的多路径解，从而曲解物理现实。\n\n使用的基本基准和参数：\n- 使用 $c = 3\\times 10^8\\,\\text{m/s}$。\n- 使用 $\\beta = 3\\times 10^{-4}$ 和 $H = 8\\times 10^3\\,\\text{m}$。\n- 使用 $z_{\\max} = 1\\times 10^5\\,\\text{m}$。\n- 计算步骤中的角度必须以弧度为单位；下面输入的节点规范以度为单位给出，在计算前必须转换为弧度。\n\n定义和要求：\n- 精确函数为 $T(\\theta) = \\dfrac{1}{c \\sin \\theta} \\int_{0}^{z_{\\max}} \\left(1 + \\beta e^{-z/H}\\right) dz$。您必须使用此精确的 $T(\\theta)$ 在采样节点上生成数据值；不要对路径进行数值射线追踪。\n- 通过分段三次埃尔米特插值多项式 (PCHIP) 实现一个 $C^1$ 保形三次样条，使用 Fritsch–Carlson 斜率限制，以在采样数据在 $\\theta$ 上是单调时保持单调性。\n- 使用相同的采样节点，实现 $N$ 个节点的 $N-1$ 次全局拉格朗日多项式插值。\n- 从第一性原理出发，推导插值函数和采样的条件，以防止在插值后的 $T(\\theta)$ 上出现虚假的多路径极小值。您的推导必须从单调函数的定义及其导数符号，以及单调数据的三次埃尔米特斜率限制规则开始。将这些与涉及 $T(\\theta)$ 二阶导数和节点间距的界限联系起来，这些界限有助于避免由离散化引起的割线斜率符号变化。这些条件必须以数学和逻辑方式表达；不要依赖超出这些基础的任何快捷公式。\n- 通过在密集网格上对每个插值函数进行采样并检测内部局部极小值（不包括端点），来数值验证虚假极小值的存在与否。虚假极小值定义为这样一个内部点：在该点处，离散导数从负变正，而精确的 $T(\\theta)$ 在该域内没有内部极小值。\n\n测试套件：\n对于每个测试用例，在指定区间上使用等距的度数节点，将它们转换为弧度进行计算，在这些节点上精确计算 $T(\\theta)$，然后构建两种插值函数。对于每种情况，在给定的评估角度（以度为单位）下评估两种插值函数，并计算相对于精确 $T(\\theta)$ 的绝对误差。同时，报告布尔标志，指示当在 $2000$ 个点的密集网格上采样时，每个插值函数是否在区间内表现出至少一个虚假的内部极小值。\n- 情况 A（理想情况）：$\\theta \\in [10^\\circ, 80^\\circ]$，$N=9$ 个节点，评估角度 $\\theta^\\ast = 50^\\circ$。\n- 情况 B（稀疏采样边界）：$\\theta \\in [5^\\circ, 85^\\circ]$，$N=5$ 个节点，评估角度 $\\theta^\\ast = 30^\\circ$。\n- 情况 C（高次全局插值）：$\\theta \\in [5^\\circ, 85^\\circ]$，$N=13$ 个节点，评估角度 $\\theta^\\ast = 20^\\circ$。\n- 情况 D（靠近边缘且节点多）：$\\theta \\in [5^\\circ, 85^\\circ]$，$N=17$ 个节点，评估角度 $\\theta^\\ast = 15^\\circ$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含所有四种情况的汇总结果，形式为一个用方括号括起来的逗号分隔列表。对于每种情况，按顺序输出四项：PCHIP 插值在 $\\theta^\\ast$ 处的绝对误差（浮点数，单位为秒），拉格朗日插值在 $\\theta^\\ast$ 处的绝对误差（浮点数，单位为秒），一个指示 PCHIP 插值是否有任何虚假内部极小值的布尔值，以及一个指示拉格朗日插值是否有任何虚假内部极小值的布尔值。因此，最终输出应总共包含 $16$ 项，按情况 A、情况 B、情况 C 和情况 D 的项目顺序排列。角度必须在内部转换为弧度，所有时间量均以秒为单位。输出必须采用确切格式\n$[r_1,r_2,\\dots,r_{16}]$\n布尔值格式化为 $True$ 或 $False$，浮点数采用标准十进制表示法。", "solution": "该问题陈述经评估是有效的。它在科学上基于分层介质中波传播的物理学和数值分析的原理。折射率模型 $n(z) = 1 + \\beta \\exp(-z/H)$ 是行星大气的一个标准一阶近似。该问题是适定的，提供了所有必要的常数、函数和一组明确的任务。语言是客观的，要求是具体的，允许一个唯一且可验证的解。\n\n**1. 传播时间 $T(\\theta)$ 的解析公式**\n\n问题提供了折射率作为海拔高度 $z$ 的函数：\n$$n(z) = 1 + \\beta e^{-z/H}$$\n在直线路径近似下，射线以恒定仰角 $\\theta$ 从海拔 $z=0$ 传播到 $z=z_{\\max}$ 的传播时间 $T(\\theta)$ 由以下积分给出：\n$$T(\\theta) = \\frac{1}{c \\sin \\theta} \\int_{0}^{z_{\\max}} n(z)\\,dz$$\n首先，我们计算定积分：\n$$ \\int_{0}^{z_{\\max}} \\left(1 + \\beta e^{-z/H}\\right) dz = \\left[z - \\beta H e^{-z/H}\\right]_{0}^{z_{\\max}} $$\n$$ = \\left(z_{\\max} - \\beta H e^{-z_{\\max}/H}\\right) - \\left(0 - \\beta H e^{-0/H}\\right) $$\n$$ = z_{\\max} - \\beta H e^{-z_{\\max}/H} + \\beta H = z_{\\max} + \\beta H \\left(1 - e^{-z_{\\max}/H}\\right) $$\n因此，传播时间函数可以写为：\n$$T(\\theta) = \\frac{K}{\\sin\\theta} = K \\csc\\theta$$\n其中 $K$ 是由大气参数决定的常数：\n$$K = \\frac{z_{\\max} + \\beta H \\left(1 - e^{-z_{\\max}/H}\\right)}{c}$$\n使用给定值：$c = 3\\times 10^8\\,\\text{m/s}$，$\\beta = 3\\times 10^{-4}$，$H = 8\\times 10^3\\,\\text{m}$，以及 $z_{\\max} = 1\\times 10^5\\,\\text{m}$。\n指数为 $-z_{\\max}/H = -10^5 / (8 \\times 10^3) = -12.5$。\n分子为 $10^5 + (3\\times 10^{-4})(8\\times 10^3)(1 - e^{-12.5}) = 100000 + 2.4(1 - e^{-12.5})$。\n$$ K = \\frac{100000 + 2.4(1 - e^{-12.5})}{3 \\times 10^8} \\approx \\frac{100000 + 2.4(1 - 3.72\\times 10^{-6})}{3 \\times 10^8} \\approx 3.3334133... \\times 10^{-4}\\,\\text{s} $$\n\n**2. $T(\\theta)$ 的单调性和凸性分析**\n\n为了理解函数 $T(\\theta)$ 的形状，我们分析其导数。$\\theta$ 的关注域在 $(0, \\pi/2)$ 弧度内，其中三角函数有确定的符号。\n\n一阶导数为：\n$$T'(\\theta) = \\frac{d}{d\\theta}(K \\csc\\theta) = -K \\csc\\theta \\cot\\theta = -K \\frac{\\cos\\theta}{\\sin^2\\theta}$$\n由于 $K > 0$，$\\cos\\theta > 0$，且 $\\sin^2\\theta > 0$ 对于 $\\theta \\in (0, \\pi/2)$，导数 $T'(\\theta)$ 严格为负。这证明了 $T(\\theta)$ 在指定区间上是一个**严格单调递减函数**。因此，精确函数没有内部局部极小值。在插值函数中发现的任何内部极小值，根据定义都是虚假的。\n\n二阶导数为：\n$$T''(\\theta) = -K \\frac{d}{d\\theta}(\\csc\\theta \\cot\\theta) = -K [(\\frac{d}{d\\theta}\\csc\\theta)\\cot\\theta + \\csc\\theta(\\frac{d}{d\\theta}\\cot\\theta)]$$\n$$T''(\\theta) = -K [(- \\csc\\theta \\cot\\theta)\\cot\\theta + \\csc\\theta(-\\csc^2\\theta)] = K[\\csc\\theta\\cot^2\\theta + \\csc^3\\theta]$$\n$$T''(\\theta) = K \\csc\\theta (\\cot^2\\theta + \\csc^2\\theta) = K \\csc\\theta ((\\csc^2\\theta - 1) + \\csc^2\\theta) = K \\csc\\theta (2\\csc^2\\theta - 1)$$\n对于 $\\theta \\in (0, \\pi/2]$，$\\csc\\theta \\ge 1$。因此，$(2\\csc^2\\theta - 1) > 0$。由于 $K > 0$ 和 $\\csc\\theta > 0$，二阶导数 $T''(\\theta)$ 严格为正。这证明了 $T(\\theta)$ 是一个**严格凸函数**。\n\n**3. 防止虚假极小值的条件**\n\n如果插值函数 $P(\\theta)$ 的导数 $P'(\\theta)$ 在一个内部点从负变正，而真实函数的导数 $T'(\\theta)$ 始终为负，那么插值函数中就出现了虚假极小值。\n\n**A. 分段三次埃尔米特插值多项式 (PCHIP)**\nPCHIP 插值函数是一个由分段三次多项式构成的 $C^1$ 函数。在区间 $[\\theta_i, \\theta_{i+1}]$ 上的每一段三次多项式由节点处的函数值 $y_i, y_{i+1}$ 和导数 $d_i, d_{i+1}$ 决定。PCHIP 的关键特性，特别是 Fritsch–Carlson 方法，是其保形属性。\n\n保持单调性的条件基于指定的斜率 $d_i$ 和连接数据点的割线斜率 $\\delta_i = (y_{i+1} - y_i)/(\\theta_{i+1} - \\theta_i)$ 之间的关系。如果数据是单调的（例如，递减，因此所有 $\\delta_i  0$），Fritsch–Carlson 算法保证计算出的节点斜率 $d_i$ 也具有相同的符号（即 $d_i  0$）。\n\n一个三次多项式在区间上单调的充分条件是其在两个端点的导数与端点之间割线斜率的符号相同。PCHIP 算法就是专门为强制执行此条件而设计的。\n\n在我们的问题中，数据点 $( \\theta_i, y_i = T(\\theta_i) )$ 是从一个严格单调递减函数中采样的。因此，数据值序列 $y_i$ 是严格递减的，所有割线斜率 $\\delta_i$ 都是负的。PCHIP 算法根据其构造会选择同样为负的导数估计值 $d_i$，从而确保每一段三次多项式都是单调的。最终得到的全局样条将是单调的。\n\n**PCHIP 结论：** 当应用于单调数据时，PCHIP 算法的本质就防止了虚假极小值的产生。对节点间距或数量没有额外的条件要求。\n\n**B. 全局拉格朗日多项式**\n拉格朗日插值是一个通过所有 $N$ 个数据点的 $N-1$ 次单项式。与 PCHIP 不同，它并非内在保形，并且容易出现龙格现象，即在节点之间出现振荡，特别是对于在等距节点上的高次多项式。\n\n如果插值函数的导数 $L'(\\theta)$ 在一个本应为负的区域内变为正，就会产生虚假极小值。拉格朗日插值 $L(\\theta)$ 与真实函数 $T(\\theta)$ 之间的关系由误差公式给出：\n$$E(\\theta) = T(\\theta) - L(\\theta) = \\frac{T^{(N)}(\\xi)}{N!} \\prod_{i=1}^{N} (\\theta - \\theta_i)$$\n对于插值区间中的某个 $\\xi$。插值函数的导数为 $L'(\\theta) = T'(\\theta) - E'(\\theta)$。如果 $L'(\\theta)=0$ 且 $L''(\\theta)0$，就可能出现虚假极小值。由于 $T'(\\theta)  0$，这要求误差导数 $E'(\\theta)$ 为负，且其大小等于 $T'(\\theta)$（即 $E'(\\theta) = T'(\\theta)$）。\n\n$E'(\\theta)$ 的大小受两个主要因素影响：\n1.  函数的高阶导数 $T^{(N)}(\\theta)$。对于 $T(\\theta) = K\\csc\\theta$，其导数涉及 $\\csc\\theta$ 和 $\\cot\\theta$ 的更高次幂，当 $\\theta \\to 0$ 时，这些导数会变得非常大。\n2.  乘积项 $\\prod(\\theta - \\theta_i)$ 及其导数。对于等距节点，该项的大小在区间边界附近最大。\n\n**拉格朗日结论：** 用一个简单的条件来防止虚假极小值的产生并不容易。相反，在特定情况下，这种行为变得更有可能发生：\n*   **高多项式次数：** 更多的节点 $N$ 导致更高的次数 $N-1$，增加了振荡行为的可能性。\n*   **节点间距：** 已知等距节点会引发龙格现象。\n*   **函数行为：** 在小角度 $\\theta$ 处，$T(\\theta)$ 的高阶导数值很大，这会放大振荡，使得在包含小角度（例如 $5^\\circ$）的测试案例中，虚假极小值更有可能出现。\n\n总之，对于在包含函数导数较大区域的区间上足够多的节点，拉格朗日插值预计将无法保持单调性。\n\n**4. 数值验证策略**\n该解决方案将通过以下步骤实现：\n1.  定义精确传播时间 $T(\\theta)$ 的函数。\n2.  对每个测试案例，生成节点 $(\\theta_i, y_i)$。\n3.  构建 `scipy.interpolate.PchipInterpolator` 和 `scipy.interpolate.lagrange` 插值函数。\n4.  在指定的角度 $\\theta^\\ast$ 处计算两种插值函数及其绝对误差。\n5.  为了检测虚假极小值，每种插值函数在区间上的一个包含 $2000$ 个点的密集网格上进行评估。检查插值序列中是否存在任何增量，即 `y_dense[i+1] > y_dense[i]`。由于精确函数是严格递减的，任何此类增量都表明存在至少一个虚假的内部极小值。一个布尔标志将报告此检查的结果。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator, lagrange\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem by comparing PCHIP and Lagrange methods.\n\n    The solution performs the following steps for each test case:\n    1. Defines physical constants and calculates the analytical form of the travel time T(theta).\n    2. Generates a set of N equally spaced nodes (theta_i, y_i) from the exact function.\n    3. Constructs a PCHIP (shape-preserving) cubic spline interpolant.\n    4. Constructs a global Lagrange polynomial interpolant.\n    5. For each interpolant, it calculates the absolute error at a specific evaluation angle theta*.\n    6. It checks for the presence of spurious interior minima by sampling the interpolant on a\n       dense grid and verifying if the function's monotonicity is violated.\n    7. Aggregates and prints the results in the specified format.\n    \"\"\"\n    # Define physical constants and model parameters\n    c = 3.0e8  # Speed of light in m/s\n    beta = 3.0e-4  # Dimensionless refractive index parameter\n    H = 8.0e3  # Atmospheric scale height in meters\n    z_max = 1.0e5  # Maximum integration altitude in meters\n\n    # Pre-calculate the constant factor K for T(theta) = K / sin(theta)\n    # The integral part is z_max + beta * H * (1 - exp(-z_max / H))\n    integral_val = z_max + beta * H * (1 - np.exp(-z_max / H))\n    K = integral_val / c\n\n    def T_exact(theta_deg):\n        \"\"\"Calculates the exact travel time T for a given angle in degrees.\"\"\"\n        # Ensure input is a float array for vectorized operations\n        theta_deg_arr = np.atleast_1d(theta_deg).astype(float)\n        # Avoid division by zero at 0 or 180 degrees\n        # Very small angles can still lead to large results, which is physically correct\n        theta_rad = np.deg2rad(theta_deg_arr)\n        \n        # Using a mask for invalid angles to avoid warnings and return inf\n        invalid_mask = np.isclose(np.sin(theta_rad), 0.0)\n        result = np.full_like(theta_rad, np.inf)\n        valid_mask = ~invalid_mask\n        result[valid_mask] = K / np.sin(theta_rad[valid_mask])\n        \n        return result[0] if result.size == 1 else result\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (theta_min_deg, theta_max_deg, N_nodes, theta_star_deg)\n        (10.0, 80.0, 9, 50.0),   # Case A\n        (5.0, 85.0, 5, 30.0),    # Case B\n        (5.0, 85.0, 13, 20.0),   # Case C\n        (5.0, 85.0, 17, 15.0),   # Case D\n    ]\n    \n    # Dense grid for checking for spurious minima\n    DENSE_GRID_POINTS = 2000\n\n    results = []\n\n    for case in test_cases:\n        theta_min_deg, theta_max_deg, N, theta_star_deg = case\n\n        # Generate N equally spaced nodes for interpolation\n        theta_nodes_deg = np.linspace(theta_min_deg, theta_max_deg, N)\n        theta_nodes_rad = np.deg2rad(theta_nodes_deg)\n        \n        # Evaluate T at the nodes to get the data values\n        y_nodes = T_exact(theta_nodes_deg)\n\n        # 1. PCHIP Interpolation\n        pchip_interpolator = PchipInterpolator(theta_nodes_rad, y_nodes)\n        \n        # Evaluate at the specified angle theta*\n        theta_star_rad = np.deg2rad(theta_star_deg)\n        pchip_val_at_star = pchip_interpolator(theta_star_rad)\n        \n        # Calculate absolute error\n        exact_val_at_star = T_exact(theta_star_deg)\n        pchip_abs_error = np.abs(pchip_val_at_star - exact_val_at_star)\n\n        # Check for spurious minima in PCHIP interpolant\n        theta_dense_rad = np.linspace(np.deg2rad(theta_min_deg), np.deg2rad(theta_max_deg), DENSE_GRID_POINTS)\n        pchip_dense_vals = pchip_interpolator(theta_dense_rad)\n        # A spurious minimum exists if the function increases at any point,\n        # as the true function is strictly decreasing.\n        pchip_has_spurious_minima = np.any(np.diff(pchip_dense_vals) > 0)\n        \n        # 2. Lagrange Interpolation\n        lagrange_poly = lagrange(theta_nodes_rad, y_nodes)\n\n        # Evaluate at theta*\n        lagrange_val_at_star = lagrange_poly(theta_star_rad)\n        \n        # Calculate absolute error\n        lagrange_abs_error = np.abs(lagrange_val_at_star - exact_val_at_star)\n\n        # Check for spurious minima in Lagrange interpolant\n        lagrange_dense_vals = lagrange_poly(theta_dense_rad)\n        lagrange_has_spurious_minima = np.any(np.diff(lagrange_dense_vals) > 0)\n\n        results.extend([\n            pchip_abs_error,\n            lagrange_abs_error,\n            bool(pchip_has_spurious_minima),\n            bool(lagrange_has_spurious_minima)\n        ])\n    \n    # Format the final output string as a list of comma-separated values\n    formatted_results = [f\"{val}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3515484"}]}