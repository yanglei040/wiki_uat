{"hands_on_practices": [{"introduction": "本次实践将带你追溯牛顿-科茨（Newton-Cotes）求积公式的根源。我们将通过构建并积分一个简单的拉格朗日（Lagrange）插值多项式，从第一性原理推导出最基础的求积法则——梯形法则的权重。这个练习旨在揭示数值积分背后清晰的几何与代数思想，为你理解更高级的求积方法奠定坚实的基础。[@problem_id:3526428]", "problem": "在平面平行恒星大气中的辐射转移中，出射通量可以写成比辐射强度对方向余弦的角度积分。更一般地，计算天体物理学中的许多视线积分可以简化为$\\int_{a}^{b} f(x) \\, dx$形式的一维定积分，这些积分必须在严格控制离散化误差的情况下进行数值计算。\n\n考虑在区间$\\left[a,b\\right]$上具有$n+1$个等距节点（包括端点）的闭合牛顿-科茨求积法则。设节点为$x_{i} = a + i h$，其中$i = 0,1,\\dots,n$，且$h = \\left(b-a\\right)/n$。闭合牛顿-科茨法则通过节点处函数值的加权和来近似积分，其权重经过选择，使得该法则能精确地重现所有次数最高为$n$的多项式的积分。\n\n在此背景下，从基本的多项式插值思想出发定义求积权重：用基于节点的拉格朗日插值多项式表示一个函数，然后对该插值多项式进行积分。然后，特化到$n=1$的情况（两个节点位于端点$x_{0}=a$和$x_{1}=b$），通过显式地对与这两个节点相关联的一阶拉格朗日基函数进行积分，来推导梯形法则的权重。\n\n将你的最终答案表述为一个包含两个梯形权重$\\left[w_{0}\\;\\;w_{1}\\right]$的行向量，作为$a$和$b$的函数。你的最终答案必须是单一的解析表达式。不包含单位。不要四舍五入。", "solution": "该问题是有效的，因为它具有科学依据、提法明确、客观且内部一致。它展示了数值分析中的一个标准推导过程。\n\n目标是为$n=1$的闭合牛顿-科茨求积法则（通常称为梯形法则）推导权重，该法则用于近似定积分$\\int_{a}^{b} f(x) \\, dx$。推导过程是通过对在区间$[a, b]$上近似函数$f(x)$的拉格朗日插值多项式进行积分来完成的。\n\n一个具有$n+1$个节点的通用闭合牛顿-科茨公式将积分近似为这些节点处函数值的加权和：\n$$\n\\int_{a}^{b} f(x) \\, dx \\approx \\sum_{i=0}^{n} w_i f(x_i)\n$$\n节点$x_i$在区间$[a, b]$内等距分布，由$x_i = a + ih$给出，其中$i = 0, 1, \\dots, n$，步长为$h = \\frac{b-a}{n}$。权重$w_i$是通过用一个唯一的、次数至多为$n$的拉格朗日插值多项式$P_n(x)$来近似$f(x)$来确定的，该多项式穿过$n+1$个点$(x_i, f(x_i))$。该多项式由下式给出：\n$$\nP_n(x) = \\sum_{i=0}^{n} f(x_i) L_{n,i}(x)\n$$\n其中$L_{n,i}(x)$是拉格朗日基多项式，定义为：\n$$\nL_{n,i}(x) = \\prod_{\\substack{j=0 \\\\ j \\neq i}}^{n} \\frac{x-x_j}{x_i-x_j}\n$$\n对$f(x)$的这个多项式近似进行积分，得到积分的近似值：\n$$\n\\int_{a}^{b} f(x) \\, dx \\approx \\int_{a}^{b} P_n(x) \\, dx = \\int_{a}^{b} \\sum_{i=0}^{n} f(x_i) L_{n,i}(x) \\, dx\n$$\n由于函数值$f(x_i)$相对于积分变量$x$是常数，我们可以写成：\n$$\n\\int_{a}^{b} P_n(x) \\, dx = \\sum_{i=0}^{n} f(x_i) \\left( \\int_{a}^{b} L_{n,i}(x) \\, dx \\right)\n$$\n通过将其与求积公式$\\sum_{i=0}^{n} w_i f(x_i)$进行比较，我们将权重$w_i$确定为相应拉格朗日基多项式的积分：\n$$\nw_i = \\int_{a}^{b} L_{n,i}(x) \\, dx\n$$\n我们现在特化到$n=1$的情况，这对应于梯形法则。对于$n=1$，我们有$n+1=2$个节点。这些节点是区间的端点：\n$x_0 = a + 0 \\cdot \\frac{b-a}{1} = a$\n$x_1 = a + 1 \\cdot \\frac{b-a}{1} = b$\n\n两个相应的一阶拉格朗日基多项式是：\n$L_{1,0}(x) = \\frac{x-x_1}{x_0-x_1} = \\frac{x-b}{a-b}$\n$L_{1,1}(x) = \\frac{x-x_0}{x_1-x_0} = \\frac{x-a}{b-a}$\n\n现在，我们通过在区间$[a, b]$上对这些基多项式进行积分来计算权重$w_0$和$w_1$。\n\n对于权重$w_0$：\n$$\nw_0 = \\int_{a}^{b} L_{1,0}(x) \\, dx = \\int_{a}^{b} \\frac{x-b}{a-b} \\, dx\n$$\n项$\\frac{1}{a-b}$是一个常数，可以被提出来：\n$$\nw_0 = \\frac{1}{a-b} \\int_{a}^{b} (x-b) \\, dx = \\frac{1}{a-b} \\left[ \\frac{x^2}{2} - bx \\right]_{a}^{b}\n$$\n在积分上下限处计算反导数：\n$$\nw_0 = \\frac{1}{a-b} \\left( \\left(\\frac{b^2}{2} - b \\cdot b\\right) - \\left(\\frac{a^2}{2} - b \\cdot a\\right) \\right)\n$$\n$$\nw_0 = \\frac{1}{a-b} \\left( \\frac{b^2}{2} - b^2 - \\frac{a^2}{2} + ab \\right) = \\frac{1}{a-b} \\left( -\\frac{b^2}{2} - \\frac{a^2}{2} + ab \\right)\n$$\n提出因子$-\\frac{1}{2}$：\n$$\nw_0 = \\frac{1}{a-b} \\left( -\\frac{1}{2} (b^2 + a^2 - 2ab) \\right) = \\frac{1}{-(b-a)} \\left( -\\frac{1}{2} (b-a)^2 \\right)\n$$\n$$\nw_0 = \\frac{b-a}{2}\n$$\n\n对于权重$w_1$：\n$$\nw_1 = \\int_{a}^{b} L_{1,1}(x) \\, dx = \\int_{a}^{b} \\frac{x-a}{b-a} \\, dx\n$$\n项$\\frac{1}{b-a}$是一个常数：\n$$\nw_1 = \\frac{1}{b-a} \\int_{a}^{b} (x-a) \\, dx = \\frac{1}{b-a} \\left[ \\frac{x^2}{2} - ax \\right]_{a}^{b}\n$$\n在上下限处求值：\n$$\nw_1 = \\frac{1}{b-a} \\left( \\left(\\frac{b^2}{2} - a \\cdot b\\right) - \\left(\\frac{a^2}{2} - a \\cdot a\\right) \\right)\n$$\n$$\nw_1 = \\frac{1}{b-a} \\left( \\frac{b^2}{2} - ab - \\frac{a^2}{2} + a^2 \\right) = \\frac{1}{b-a} \\left( \\frac{b^2}{2} - ab + \\frac{a^2}{2} \\right)\n$$\n提出因子$\\frac{1}{2}$：\n$$\nw_1 = \\frac{1}{b-a} \\left( \\frac{1}{2} (b^2 - 2ab + a^2) \\right) = \\frac{1}{b-a} \\left( \\frac{1}{2} (b-a)^2 \\right)\n$$\n$$\nw_1 = \\frac{b-a}{2}\n$$\n因此，梯形法则（$n=1$的闭合牛顿-科茨法则）的权重为$w_0 = \\frac{b-a}{2}$和$w_1 = \\frac{b-a}{2}$。该求积法则是：\n$$\n\\int_{a}^{b} f(x) \\, dx \\approx w_0 f(x_0) + w_1 f(x_1) = \\frac{b-a}{2} f(a) + \\frac{b-a}{2} f(b) = \\frac{b-a}{2} (f(a) + f(b))\n$$\n最终答案是这两个权重的行向量。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{b-a}{2}  \\frac{b-a}{2}\n\\end{pmatrix}\n}\n$$", "id": "3526428"}, {"introduction": "在了解了基于等距节点的牛顿-科茨方法后，我们转向一种更高效的策略：高斯求积（Gaussian quadrature）。本次实践的核心是通过求解一个非线性方程组，来确定三点高斯-勒让德（Gauss-Legendre）求积的节点和权重，使其能够精确积分最高达五次的多项式。通过这个过程，你将亲身体会到优化节点位置如何以最少的函数求值次数，实现惊人的积分精度。[@problem_id:3526485]", "problem": "在计算天体物理学的许多辐射转移计算中，对极角余弦（记为 $\\mu$）的角度积分会出现在矩封闭和通量计算中。当一个量的角度依赖性足够光滑时，它可以用 $\\mu$ 的多项式来精确近似。考虑在区间 $[-1,1]$ 上构造一个求积法则，该法则对于次数最高为 $5$ 的所有 $x$ 的多项式都是精确的，这是 $n=3$ 高斯-勒让德求积的正合定义性质。从高斯求积的定义出发，即选择 $n$ 个节点和权重以精确积分次数最高为 $2n-1$ 的多项式，并仅利用关于对称区间上单项式积分和多项式精确性的基本事实，推导出 $[-1,1]$ 上的 $n=3$ 高斯-勒让德法则的节点 $\\{\\xi_{i}\\}_{i=1}^{3}$ 和权重 $\\{w_{i}\\}_{i=1}^{3}$。然后，验证权重是严格为正的，并且它们的和等于 $2$，这与对常数函数积分的结果一致。以精确的符号形式表示最终的节点和权重。最终答案必须是一个单行矩阵，包含三个节点，后跟三个权重。", "solution": "问题陈述经核实具有科学依据、问题明确且客观。它提出了一个数值分析中的标准可解问题，具有明确的计算天体物理学背景。所有必要信息都已提供，任务是从第一性原理推导出一个已知结果。\n\n目标是确定区间 $[-1, 1]$ 上的一个 $3$ 点数值求积法则的节点 $\\{\\xi_{i}\\}_{i=1}^{3}$ 和权重 $\\{w_{i}\\}_{i=1}^{3}$，该法则对次数最高为 $2n-1 = 2(3)-1 = 5$ 的所有多项式都是精确的。该求积法则的形式为：\n$$\n\\int_{-1}^{1} f(x) dx \\approx \\sum_{i=1}^{3} w_i f(\\xi_i)\n$$\n为使该法则对多项式 $P(x)$ 精确，必须满足以下等式：\n$$\n\\int_{-1}^{1} P(x) dx = \\sum_{i=1}^{3} w_i P(\\xi_i)\n$$\n我们有六个未知数：三个节点 $(\\xi_1, \\xi_2, \\xi_3)$ 和三个权重 $(w_1, w_2, w_3)$。为了求解这些未知数，我们要求该法则对次数最高为 $5$ 的多项式空间的一组基是精确的。单项式基 $\\{x^0, x^1, x^2, x^3, x^4, x^5\\}$ 是一个方便的选择。这产生了一个包含六个方程的方程组：\n$$\n\\int_{-1}^{1} x^k dx = \\sum_{i=1}^{3} w_i \\xi_i^k \\quad \\text{for } k = 0, 1, 2, 3, 4, 5\n$$\n首先，我们计算左侧的积分。对于一般的整数 $k \\ge 0$：\n$$\n\\int_{-1}^{1} x^k dx = \\left[ \\frac{x^{k+1}}{k+1} \\right]_{-1}^{1} = \\frac{1^{k+1} - (-1)^{k+1}}{k+1}\n$$\n如果 $k$ 是奇数，则 $k+1$ 是偶数，积分为 $\\frac{1-1}{k+1} = 0$。\n如果 $k$ 是偶数，则 $k+1$ 是奇数，积分为 $\\frac{1-(-1)}{k+1} = \\frac{2}{k+1}$。\n所需的积分为：\n$k=0: \\int_{-1}^{1} 1 dx = 2$\n$k=1: \\int_{-1}^{1} x dx = 0$\n$k=2: \\int_{-1}^{1} x^2 dx = \\frac{2}{3}$\n$k=3: \\int_{-1}^{1} x^3 dx = 0$\n$k=4: \\int_{-1}^{1} x^4 dx = \\frac{2}{5}$\n$k=5: \\int_{-1}^{1} x^5 dx = 0$\n\n积分区间 $[-1, 1]$ 关于 $x=0$ 对称。此性质强烈暗示节点和权重也应该是对称的。我们对节点进行排序，使得 $\\xi_1  \\xi_2  \\xi_3$。为了对称，我们必须有一个节点在中心，即 $\\xi_2 = 0$，另外两个节点对称地分布在其两侧，即 $\\xi_3 = -\\xi_1$。与对称节点相对应的权重必须相等，因此 $w_3 = w_1$。这将未知数的数量从六个减少到三个：$\\xi_3>0$、$w_1$ 和 $w_2$。\n\n让我们用这些对称性假设重写方程组。节点为 $\\{-\\xi_3, 0, \\xi_3\\}$，权重为 $\\{w_1, w_2, w_1\\}$。\n对于 $k=0$：\n$w_1 (-\\xi_3)^0 + w_2 (0)^0 + w_1 (\\xi_3)^0 = w_1 + w_2 + w_1 = 2w_1 + w_2 = 2$\n对于 $k=1$：\n$w_1 (-\\xi_3)^1 + w_2 (0)^1 + w_1 (\\xi_3)^1 = -w_1\\xi_3 + 0 + w_1\\xi_3 = 0$。这与积分值相符，因此对称性假设是一致的。\n对于 $k=2$：\n$w_1 (-\\xi_3)^2 + w_2 (0)^2 + w_1 (\\xi_3)^2 = w_1\\xi_3^2 + 0 + w_1\\xi_3^2 = 2w_1\\xi_3^2 = \\frac{2}{3}$\n对于 $k=3$：\n$w_1 (-\\xi_3)^3 + w_2 (0)^3 + w_1 (\\xi_3)^3 = -w_1\\xi_3^3 + 0 + w_1\\xi_3^3 = 0$。这也与积分值一致。\n对于 $k=4$：\n$w_1 (-\\xi_3)^4 + w_2 (0)^4 + w_1 (\\xi_3)^4 = w_1\\xi_3^4 + 0 + w_1\\xi_3^4 = 2w_1\\xi_3^4 = \\frac{2}{5}$\n对于 $k=5$：\n$w_1 (-\\xi_3)^5 + w_2 (0)^5 + w_1 (\\xi_3)^5 = -w_1\\xi_3^5 + 0 + w_1\\xi_3^5 = 0$。也与积分值一致。\n\n我们得到了一个关于三个未知数 $\\xi_3$、$w_1$ 和 $w_2$ 的三元非线性方程组：\n1. $2w_1 + w_2 = 2$\n2. $2w_1\\xi_3^2 = \\frac{2}{3} \\implies w_1\\xi_3^2 = \\frac{1}{3}$\n3. $2w_1\\xi_3^4 = \\frac{2}{5} \\implies w_1\\xi_3^4 = \\frac{1}{5}$\n\n我们可以通过将方程(3)除以方程(2)来求解 $\\xi_3$：\n$$\n\\frac{w_1\\xi_3^4}{w_1\\xi_3^2} = \\frac{1/5}{1/3}\n$$\n$$\n\\xi_3^2 = \\frac{3}{5}\n$$\n由于我们选择了 $\\xi_3 > 0$，我们有 $\\xi_3 = \\sqrt{\\frac{3}{5}}$。\n因此，节点为 $\\xi_1 = -\\sqrt{\\frac{3}{5}}$、$\\xi_2 = 0$ 和 $\\xi_3 = \\sqrt{\\frac{3}{5}}$。\n\n现在，我们求解权重。将 $\\xi_3^2 = \\frac{3}{5}$ 代入方程(2)：\n$$\nw_1 \\left(\\frac{3}{5}\\right) = \\frac{1}{3}\n$$\n$$\nw_1 = \\frac{1}{3} \\cdot \\frac{5}{3} = \\frac{5}{9}\n$$\n因为 $w_3 = w_1$，我们有 $w_3 = \\frac{5}{9}$。\n\n最后，使用方程(1)求 $w_2$：\n$$\n2w_1 + w_2 = 2\n$$\n$$\n2\\left(\\frac{5}{9}\\right) + w_2 = 2\n$$\n$$\n\\frac{10}{9} + w_2 = \\frac{18}{9}\n$$\n$$\nw_2 = \\frac{18}{9} - \\frac{10}{9} = \\frac{8}{9}\n$$\n所以节点为 $\\{-\\sqrt{\\frac{3}{5}}, 0, \\sqrt{\\frac{3}{5}}\\}$，对应的权重为 $\\{\\frac{5}{9}, \\frac{8}{9}, \\frac{5}{9}\\}$。\n\n问题要求验证权重是严格为正的，并且它们的和等于 $2$。\n权重为 $w_1=w_3=\\frac{5}{9}$ 和 $w_2=\\frac{8}{9}$。它们显然都是正数。\n权重的和为：\n$$\n\\sum_{i=1}^{3} w_i = w_1 + w_2 + w_3 = \\frac{5}{9} + \\frac{8}{9} + \\frac{5}{9} = \\frac{5+8+5}{9} = \\frac{18}{9} = 2\n$$\n这与常数函数 $f(x)=1$ 的精确积分结果一致，因为 $\\int_{-1}^{1} 1 dx = 2$。\n推导出的节点和权重是正确的。\n\n最终的节点和权重的精确符号形式为：\n节点：$\\xi_1 = -\\sqrt{\\frac{3}{5}}$，$\\xi_2 = 0$，$\\xi_3 = \\sqrt{\\frac{3}{5}}$\n权重：$w_1 = \\frac{5}{9}$，$w_2 = \\frac{8}{9}$，$w_3 = \\frac{5}{9}$", "answer": "$$\n\\boxed{\\begin{pmatrix} -\\sqrt{\\frac{3}{5}}  0  \\sqrt{\\frac{3}{5}}  \\frac{5}{9}  \\frac{8}{9}  \\frac{5}{9} \\end{pmatrix}}\n$$", "id": "3526485"}, {"introduction": "理论上的多项式精度在面对真实物理问题时会遇到怎样的挑战？本实践模拟了天体物理中一个常见的场景：对一个在边界附近急剧变化的函数（如冷却函数）进行积分。你将通过编程比较高阶单区间牛顿-科茨方法、复合辛普森（Simpson）方法以及高斯-勒让德求积方法的性能，并直观地观察“龙格现象”（Runge phenomenon）的发生。这项练习旨在让你深刻理解不同积分策略的适用范围和局限性，并学会在实践中做出明智的选择。[@problem_id:3526442]", "problem": "考虑一个合成积分，它用于模拟计算天体物理冷却模型中归一化热力学变量高端附近的尖锐局部贡献。设该积分为 $$Q=\\int_{0}^{1} f(x)\\,dx,$$ 其中被积函数定义为 $$f(x;\\varepsilon,p)=\\frac{1}{1+\\left(\\frac{1-x}{\\varepsilon}\\right)^{p}},$$ 参数 $\\varepsilon0$ 控制 $x=1$ 附近边界层的宽度，整数 $p\\ge 1$ 控制过渡的陡峭程度。该函数族在 $[0,1]$ 上光滑，有界于 $0\\le f\\le 1$，且对于较小的 $\\varepsilon$，在 $x=1$ 附近具有较大的导数，这对基于等距节点的插值型求积格式构成了挑战。\n\n你的任务是在 $[0,1]$ 上，在固定的函数求值预算下，实现并比较三种求积策略：\n\n- $n_{\\mathrm{NC}}$ 阶的单区间闭式 Newton–Cotes 法则（即在 $[0,1]$ 上使用 $n_{\\mathrm{NC}}+1$ 个等距节点）。\n- 基于 $m$ 个区间上的 Simpson 法则构建的复合低阶 Newton–Cotes 格式，在 $[0,1]$ 上使用 $2m+1$ 个等距节点。\n- 在 $[0,1]$ 上的 $n_{\\mathrm{G}}$ 点 Gauss–Legendre 求积。\n\n所有方法必须使用相同数量的函数求值 $N_{\\mathrm{eval}}$，且 $n_{\\mathrm{NC}}+1=2m+1=n_{\\mathrm{G}}=N_{\\mathrm{eval}}$。你必须选择 $N_{\\mathrm{eval}}=11$，因此 $n_{\\mathrm{NC}}=10$，$m=5$，$n_{\\mathrm{G}}=11$。\n\n为了验证，请使用在特殊情况 $p=1$ 和 $p=2$ 下 $Q$ 的精确解析表达式。这些表达式可通过换元 $u=(1-x)/\\varepsilon$ 得到，具体如下\n$$Q(\\varepsilon,1)=\\varepsilon\\,\\ln\\!\\left(1+\\frac{1}{\\varepsilon}\\right),\\qquad Q(\\varepsilon,2)=\\varepsilon\\,\\arctan\\!\\left(\\frac{1}{\\varepsilon}\\right)。$$\n\n你需要根据多项式插值和正交多项式的基本原理来实现这三种求积方法，不要使用任何自适应加密技术。你可以使用标准数值库来获取高阶闭式 Newton–Cotes 法则和 Gauss–Legendre 法则的权重和节点。\n\n测试集。请对以下参数集评估绝对求积误差 $\\left|Q_{\\mathrm{approx}}-Q_{\\mathrm{exact}}\\right|$：\n- 案例 A: $(\\varepsilon,p)=(0.2,1)$。\n- 案例 B: $(\\varepsilon,p)=(0.01,1)$。\n- 案例 C: $(\\varepsilon,p)=(0.05,2)$。\n- 案例 D: $(\\varepsilon,p)=(1.0,2)$。\n- 案例 E: $(\\varepsilon,p)=(0.001,1)$。\n\n对于每个案例，报告一个包含三个浮点数的列表，这些浮点数分别对应以下方法产生的绝对误差，顺序为：单区间 10 阶闭式 Newton–Cotes，具有 $m=5$ 个区间的复合 Simpson，以及 11 点 Gauss–Legendre。\n\n最终输出格式。你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是针对一个测试案例的包含三个浮点数的列表，顺序为 [案例 A, 案例 B, 案例 C, 案例 D, 案例 E]。例如，一个有效的输出格式是\n\"[[eA1,eA2,eA3],[eB1,eB2,eB3],[eC1,eC2,eC3],[eD1,eD2,eD3],[eE1,eE2,eE3]]\"\n其中每个 $e\\cdot\\cdot$ 是一个浮点数。", "solution": "该问题要求实现并比较三种数值求积方法，用于逼近积分 $Q=\\int_{0}^{1} f(x)\\,dx$，其中被积函数由 $f(x;\\varepsilon,p)=\\frac{1}{1+\\left(\\frac{1-x}{\\varepsilon}\\right)^{p}}$ 给出。这个函数模拟了在 $x=1$ 附近的一个急剧过渡（或边界层），其宽度由 $\\varepsilon0$ 控制。过渡的陡峭程度由整数参数 $p\\ge 1$ 决定。对于较小的 $\\varepsilon$ 值，被积函数的导数在 $x=1$ 附近变得很大，这对数值积分格式构成了挑战，特别是那些基于等距节点的格式。\n\n比较将在每种方法固定 $N_{\\mathrm{eval}}=11$ 次函数求值的预算下进行。这三种方法是：\n1.  $n_{\\mathrm{NC}}=10$ 阶的单区间闭式 Newton–Cotes 法则。\n2.  在 $m=5$ 个区间上的复合 Simpson 法则。\n3.  $n_{\\mathrm{G}}=11$ 点的 Gauss–Legendre 求积。\n\n注意，每种方法的节点数与预算一致：$n_{\\mathrm{NC}}+1 = 10+1=11$，$2m+1 = 2(5)+1=11$，且 $n_{\\mathrm{G}}=11$。\n\n每种方法的准确性通过计算几个测试案例的绝对误差 $|Q_{\\mathrm{approx}}-Q_{\\mathrm{exact}}|$ 来评估。积分的精确值在特殊情况 $p=1$ 和 $p=2$ 下给出，这对应于所有测试案例。\n对于 $p=1$：$Q(\\varepsilon,1)=\\varepsilon\\,\\ln\\!\\left(1+\\frac{1}{\\varepsilon}\\right)$。\n对于 $p=2$：$Q(\\varepsilon,2)=\\varepsilon\\,\\arctan\\!\\left(\\frac{1}{\\varepsilon}\\right)$。\n\n对于较小的 $\\varepsilon$，被积函数 $f(x)$ 在 $x=1$ 附近形成一个尖锐的边界层。使用等距节点的求积格式，如单区间 Newton-Cotes 法则和复合 Simpson 法则，预期表现会较差，因为它们可能无法在这个快速变化的狭窄区域内放置足够的采样点。相比之下，Gauss-Legendre 求积将节点聚集在积分区间的端点附近，预期能通过更好地解析 $x=1$ 处的特征来提供更准确的近似。\n\n下面详细介绍每种方法基于基本原理的实现。\n\n### 方法1：10 阶单区间闭式 Newton–Cotes 法则\n\n该方法通过对一个穿过 $[0,1]$ 区间上 $N_{\\mathrm{eval}}=11$ 个等距点的 $n_{\\mathrm{NC}}=10$ 阶插值多项式进行积分来近似原积分。\n节点由 $x_i = a + i \\cdot h$ 给出，其中 $i=0, 1, \\dots, n_{\\mathrm{NC}}$，区间为 $[a,b]=[0,1]$，步长为 $h=(b-a)/n_{\\mathrm{NC}} = (1-0)/10 = 0.1$。因此，$x_i = i/10$。\n求积公式为：\n$$ Q_{\\mathrm{NC}} = \\int_0^1 f(x) dx \\approx h \\sum_{i=0}^{n_{\\mathrm{NC}}} C_i^{(n_{\\mathrm{NC}})} f(x_i) $$\nNewton-Cotes 系数 $C_i^{(n_{\\mathrm{NC}})}$ 由 Lagrange 基多项式的积分导出。按照许可，这些系数是使用一个标准数值库函数，特别是 `scipy.integrate.newton_cotes` 获得的。对于 $n_{\\mathrm{NC}}=10$ 和区间 $[0,1]$，积分近似值是使用 $h=0.1$ 计算的。\n\n### 方法2：复合 Simpson 法则\n\n该方法将积分区间 $[0,1]$ 划分为 $m=5$ 个等宽的子区间。在每个子区间上，函数由一个二次多项式（Simpson 法则）来近似。\n总节点数为 $N_{\\mathrm{eval}}=2m+1=11$，这些节点与 Newton-Cotes 方法中使用的等距节点相同：$x_i = i/10$，其中 $i=0, \\dots, 10$。相邻节点之间的步长为 $h=1/10$。\n复合 Simpson 法则的公式是：\n$$ Q_{\\mathrm{CS}} = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{j=1}^{m} f(x_{2j-1}) + 2\\sum_{j=1}^{m-1} f(x_{2j}) + f(x_{2m}) \\right] $$\n代入 $m=5$ 和节点索引，公式变为：\n$$ Q_{\\mathrm{CS}} = \\frac{h}{3} \\left[ f(x_0) + 4(f(x_1)+f(x_3)+\\dots+f(x_9)) + 2(f(x_2)+f(x_4)+\\dots+f(x_8)) + f(x_{10}) \\right] $$\n这个公式被直接实现。\n\n### 方法3：11 点 Gauss–Legendre 求积\n\nGauss-Legendre 求积通过将节点优化地放置为 Legendre 多项式的根，从而在给定节点数的情况下提供尽可能高的代数精度。对于一个 $n_{\\mathrm{G}}$ 点法则，它可以精确地对最高 $2n_{\\mathrm{G}}-1$ 次的多项式进行积分。\n标准的 Gauss-Legendre 法则定义在区间 $[-1,1]$ 上：\n$$ \\int_{-1}^1 g(\\xi) d\\xi \\approx \\sum_{i=1}^{n_{\\mathrm{G}}} w_i^{\\mathrm{std}} g(\\xi_i^{\\mathrm{std}}) $$\n其中 $\\xi_i^{\\mathrm{std}}$ 是节点（第 $n_{\\mathrm{G}}$ 阶 Legendre 多项式的根），$w_i^{\\mathrm{std}}$ 是相应的权重。\n为了将其应用于区间 $[a,b]=[0,1]$，我们使用线性变换 $x = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}$，对于 $[0,1]$ 这就变成了 $x = \\frac{1}{2}(\\xi+1)$。微分元变换为 $dx = \\frac{1}{2}d\\xi$。\n积分变为：\n$$ Q_{\\mathrm{GL}} = \\int_0^1 f(x) dx = \\int_{-1}^1 f\\left(\\frac{\\xi+1}{2}\\right) \\frac{1}{2} d\\xi \\approx \\sum_{i=1}^{n_{\\mathrm{G}}} \\left(\\frac{1}{2}w_i^{\\mathrm{std}}\\right) f\\left(\\frac{\\xi_i^{\\mathrm{std}}+1}{2}\\right) $$\n在 $[0,1]$ 上变换后的节点为 $x_i = (\\xi_i^{\\mathrm{std}}+1)/2$，变换后的权重为 $w_i = w_i^{\\mathrm{std}}/2$。对于本问题，$n_{\\mathrm{G}}=11$。标准节点和权重从 `numpy.polynomial.legendre.leggauss` 获取。\n\n### 计算策略\n\n将构建一个 Python 脚本来执行所需的计算。对于由 $(\\varepsilon,p)$ 定义的五个测试案例中的每一个：\n1. 定义具体的被积函数 $f(x)$。\n2. 使用提供的解析公式计算精确积分 $Q_{\\mathrm{exact}}$。\n3. 使用 $N_{\\mathrm{eval}}=11$ 计算三种求积近似值（$Q_{\\mathrm{NC}}$, $Q_{\\mathrm{CS}}$, $Q_{\\mathrm{GL}}$）。\n4. 计算这三种方法的绝对误差并存储在一个列表中。\n5. 最终输出被格式化为这些误差列表的列表，每个测试案例一个，并打印到单行上。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import newton_cotes\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Implements and compares three quadrature strategies on a test integral\n    from computational astrophysics, reporting the absolute errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (epsilon, p), label\n        (0.2, 1, 'A'),\n        (0.01, 1, 'B'),\n        (0.05, 2, 'C'),\n        (1.0, 2, 'D'),\n        (0.001, 1, 'E'),\n    ]\n\n    # Shared parameters for all methods\n    N_eval = 11\n    a, b = 0.0, 1.0\n\n    all_results = []\n\n    for epsilon, p, _ in test_cases:\n        # 1. Define the integrand and exact solution\n        \n        # The integrand f(x; epsilon, p)\n        f = lambda x: 1.0 / (1.0 + ((1.0 - x) / epsilon)**p)\n\n        # The exact analytic solution Q(epsilon, p)\n        if p == 1:\n            Q_exact = epsilon * np.log(1.0 + 1.0 / epsilon)\n        elif p == 2:\n            Q_exact = epsilon * np.arctan(1.0 / epsilon)\n        else:\n            # This case will not be reached with the given test suite\n            raise ValueError(\"No exact solution provided for p != 1 or 2\")\n\n        # 2. Implement and apply the three quadrature methods\n\n        # Method 1: Single-panel closed Newton-Cotes of degree 10\n        n_nc = 10\n        nodes_nc = np.linspace(a, b, N_eval)\n        evals_nc = f(nodes_nc)\n        weights_nc_coeffs, _ = newton_cotes(n_nc)\n        h_nc = (b - a) / n_nc\n        Q_nc = h_nc * np.sum(weights_nc_coeffs * evals_nc)\n\n        # Method 2: Composite Simpson's rule with m=5 panels\n        m = 5\n        # Nodes are the same as for Newton-Cotes\n        nodes_cs = np.linspace(a, b, N_eval)\n        evals_cs = f(nodes_cs)\n        h_cs = (b - a) / (N_eval - 1)\n        Q_cs = (h_cs / 3.0) * (\n            evals_cs[0] + \n            4.0 * np.sum(evals_cs[1:-1:2]) + \n            2.0 * np.sum(evals_cs[2:-1:2]) + \n            evals_cs[-1]\n        )\n        # Note: evals[1:-1:2] is slightly different from problem description's sum limits\n        # but is correct for Python slicing. It selects all odd indices between 0 and N-1.\n\n        # Method 3: 11-point Gauss-Legendre quadrature\n        n_g = 11\n        nodes_gl_std, weights_gl_std = leggauss(n_g)\n        # Transform nodes and weights from [-1, 1] to [a, b] = [0, 1]\n        nodes_gl = 0.5 * (b - a) * nodes_gl_std + 0.5 * (a + b)\n        weights_gl = 0.5 * (b - a) * weights_gl_std\n        evals_gl = f(nodes_gl)\n        Q_gl = np.sum(weights_gl * evals_gl)\n\n        # 3. Calculate absolute errors\n        error_nc = abs(Q_nc - Q_exact)\n        error_cs = abs(Q_cs - Q_exact)\n        error_gl = abs(Q_gl - Q_exact)\n        \n        case_results = [error_nc, error_cs, error_gl]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # Ex: \"[[eA1,eA2,eA3],[eB1,eB2,eB3],...]\"\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3526442"}]}