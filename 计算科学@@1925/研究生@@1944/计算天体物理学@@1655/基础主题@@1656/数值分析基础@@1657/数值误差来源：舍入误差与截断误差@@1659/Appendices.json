{"hands_on_practices": [{"introduction": "理论知识只有通过实践才能得到巩固。本节的第一个练习旨在揭示截断误差和舍入误差之间固有的权衡关系。通过推导数值微分中的最优步长，你将亲身体验“更小并非总是更好”这一反直觉但至关重要的原则，从而对数值误差的来源和行为建立起定量的理解。[@problem_id:3536511]", "problem": "考虑一个处于平衡状态的球对称、无碰撞的暗物质晕。令 $f(x)$ 表示沿穿过该晕的一维坐标 $x$ 采样的光滑标量场，它可以代表质量密度、引力势，或者限制在穿过该晕的视线上的分布函数。假设 $f(x)$ 在一个特征空间尺度 $L$ 上变化，并具有特征振幅 $F$，因此其导数在一般位置满足量纲标度 $|f^{(n)}(x)| \\sim F L^{-n}$。您希望使用对称两点中心差分公式计算某点 $x$ 处的空间导数 $f'(x)$\n$$\nD_{\\Delta x} f(x) \\equiv \\frac{f(x+\\Delta x) - f(x-\\Delta x)}{2 \\Delta x}.\n$$\n假设浮点运算遵循标准模型，单位舍入误差为 $u$，这意味着每次求值返回 $(1+\\delta) f(\\cdot)$，其中 $|\\delta| \\leq u$，并且算术运算会产生同阶的相对误差。在目标点 $x$ 处，通过将三阶导数写为 $|f^{(3)}(x)| = \\alpha F L^{-3}$ 来定义一个无量纲的局部形状参数 $\\alpha$，其中 $\\alpha$ 编码了与纯指数或幂律剖面的偏离，并且在天体物理应用中通常为单位量级。\n\n仅从 $f(x\\pm\\Delta x)$ 的泰勒定理和上述浮点模型出发，分析 $D_{\\Delta x} f(x)$ 中的领头阶截断误差和舍入误差，构建一个将这两个主要误差贡献的量值相加的总误差模型 $E(\\Delta x)$，并确定使 $E(\\Delta x)$ 最小化的步长 $\\Delta x_{\\mathrm{opt}}$。\n\n用 $u$、$L$ 和 $\\alpha$ 将您的 $\\Delta x_{\\mathrm{opt}}$ 最终答案表示为单个闭式解析表达式。不需要数值，最终表达式中也不应包含物理单位。", "solution": "目标是确定对称两点中心差分公式的最优步长 $\\Delta x_{\\mathrm{opt}}$，以最小化总数值误差。总误差由两部分组成：截断误差，它源于用有限差分近似导数；以及舍入误差，这是浮点运算所固有的。我们将分别分析每个误差分量，将它们组合成一个总误差模型，然后关于步长 $\\Delta x$ 对该模型进行最小化。\n\n首先，我们分析截断误差 $E_{\\text{trunc}}$。中心差分公式为：\n$$\nD_{\\Delta x} f(x) = \\frac{f(x+\\Delta x) - f(x-\\Delta x)}{2 \\Delta x}\n$$\n我们使用泰勒定理在点 $x$ 附近展开 $f(x+\\Delta x)$ 和 $f(x-\\Delta x)$。假设 $f(x)$ 足够光滑（至少 $C^3$），我们可以写出：\n$$\nf(x+\\Delta x) = f(x) + \\Delta x f'(x) + \\frac{(\\Delta x)^2}{2} f''(x) + \\frac{(\\Delta x)^3}{6} f^{(3)}(x) + O((\\Delta x)^4)\n$$\n$$\nf(x-\\Delta x) = f(x) - \\Delta x f'(x) + \\frac{(\\Delta x)^2}{2} f''(x) - \\frac{(\\Delta x)^3}{6} f^{(3)}(x) + O((\\Delta x)^4)\n$$\n用第一个展开式减去第二个展开式，得到：\n$$\nf(x+\\Delta x) - f(x-\\Delta x) = 2 \\Delta x f'(x) + \\frac{2 (\\Delta x)^3}{6} f^{(3)}(x) + O((\\Delta x)^5)\n$$\n注意，$\\Delta x$ 的偶次幂项相互抵消。将此结果代入中心差分公式：\n$$\nD_{\\Delta x} f(x) = \\frac{2 \\Delta x f'(x) + \\frac{(\\Delta x)^3}{3} f^{(3)}(x) + O((\\Delta x)^5)}{2 \\Delta x} = f'(x) + \\frac{(\\Delta x)^2}{6} f^{(3)}(x) + O((\\Delta x)^4)\n$$\n截断误差是计算出的近似值与真实导数之间的差，即 $E_{\\text{trunc}}(\\Delta x) = D_{\\Delta x} f(x) - f'(x)$。该误差的领头阶项为：\n$$\nE_{\\text{trunc}}(\\Delta x) \\approx \\frac{(\\Delta x)^2}{6} f^{(3)}(x)\n$$\n因此，截断误差的量值约为 $|E_{\\text{trunc}}(\\Delta x)| \\approx \\frac{(\\Delta x)^2}{6} |f^{(3)}(x)|$。使用问题中对点 $x$ 处三阶导数的定义 $|f^{(3)}(x)| = \\alpha F L^{-3}$，我们有：\n$$\n|E_{\\text{trunc}}(\\Delta x)| \\approx \\frac{\\alpha F}{6 L^3} (\\Delta x)^2\n$$\n此误差随 $\\Delta x$ 的减小而呈平方关系减小。\n\n接下来，我们分析舍入误差 $E_{\\text{round}}$。根据浮点模型，对 $f(y)$ 的求值会产生一个计算值 $\\tilde{f}(y) = f(y)(1+\\delta)$，其中 $|\\delta| \\leq u$ 是单位舍入误差。令 $\\tilde{f}(x+\\Delta x)$ 和 $\\tilde{f}(x-\\Delta x)$ 为函数在采样点的计算值。\n$$\n\\tilde{f}(x+\\Delta x) = f(x+\\Delta x)(1 + \\delta_{1})\n$$\n$$\n\\tilde{f}(x-\\Delta x) = f(x-\\Delta x)(1 + \\delta_{2})\n$$\n其中 $|\\delta_1| \\leq u$ 且 $|\\delta_2| \\leq u$。舍入误差源于这些函数求值的不精确性以及后续的算术运算。在此公式中，舍入误差的主要来源是当 $\\Delta x$ 很小时，在减法 $\\tilde{f}(x+\\Delta x) - \\tilde{f}(x-\\Delta x)$ 过程中可能发生的灾难性相消，因为这两个值非常接近。计算出的分子中的绝对误差是：\n$$\ne_{\\text{num}} = \\tilde{f}(x+\\Delta x) - \\tilde{f}(x-\\Delta x) - (f(x+\\Delta x) - f(x-\\Delta x)) = f(x+\\Delta x)\\delta_{1} - f(x-\\Delta x)\\delta_{2}\n$$\n我们忽略减法运算本身产生的舍入误差，因为它通常小于传播误差。$e_{\\text{num}}$ 的量值由以下不等式界定：\n$$\n|e_{\\text{num}}| \\leq |f(x+\\Delta x)||\\delta_1| + |f(x-\\Delta x)||\\delta_2| \\leq u (|f(x+\\Delta x)| + |f(x-\\Delta x)|)\n$$\n问题指出 $f(x)$ 具有特征振幅 $F$。对于小步长 $\\Delta x \\ll L$，函数值 $f(x\\pm\\Delta x)$ 将与此振幅同量级。因此，我们可以近似 $|f(x\\pm\\Delta x)| \\approx F$。分子舍入误差的界变为 $|e_{\\text{num}}| \\lesssim u(F+F) = 2uF$。这个误差随后通过除以 $2\\Delta x$ 进行传播。因此，最终结果中舍入误差的量值为：\n$$\n|E_{\\text{round}}(\\Delta x)| \\approx \\frac{|e_{\\text{num}}|}{2\\Delta x} \\approx \\frac{2uF}{2\\Delta x} = \\frac{uF}{\\Delta x}\n$$\n此误差随 $\\Delta x$ 的减小而增大。\n\n总误差 $E(\\Delta x)$ 被建模为领头阶截断误差和舍入误差的量值之和：\n$$\nE(\\Delta x) = |E_{\\text{trunc}}(\\Delta x)| + |E_{\\text{round}}(\\Delta x)| \\approx \\frac{\\alpha F}{6 L^3} (\\Delta x)^2 + \\frac{uF}{\\Delta x}\n$$\n为了找到使该总误差最小化的最优步长 $\\Delta x_{\\mathrm{opt}}$，我们将 $E(\\Delta x)$ 对 $\\Delta x$ 求导并令其为零：\n$$\n\\frac{dE}{d(\\Delta x)} = \\frac{d}{d(\\Delta x)} \\left( \\frac{\\alpha F}{6 L^3} (\\Delta x)^2 + \\frac{uF}{\\Delta x} \\right) = 2 \\left( \\frac{\\alpha F}{6 L^3} \\right) \\Delta x - \\frac{uF}{(\\Delta x)^2} = 0\n$$\n$$\n\\frac{\\alpha F}{3 L^3} \\Delta x = \\frac{uF}{(\\Delta x)^2}\n$$\n特征振幅 $F$ 从等式两边消去：\n$$\n\\frac{\\alpha}{3 L^3} \\Delta x = \\frac{u}{(\\Delta x)^2}\n$$\n解出 $\\Delta x$：\n$$\n(\\Delta x)^3 = \\frac{3 u L^3}{\\alpha}\n$$\n对两边取立方根，得到最优步长：\n$$\n\\Delta x_{\\mathrm{opt}} = \\left( \\frac{3 u L^3}{\\alpha} \\right)^{1/3} = L \\left( \\frac{3u}{\\alpha} \\right)^{1/3}\n$$\n此结果给出了平衡递减的截断误差和递增的舍入误差的步长，从而在给定模型下产生最精确的数值导数。", "answer": "$$\n\\boxed{L \\left( \\frac{3u}{\\alpha} \\right)^{1/3}}\n$$", "id": "3536511"}, {"introduction": "在掌握了基本的误差权衡之后，下一个练习将理论付诸实践，要求你构建一个在计算天体物理学中无处不在的工具——自适应网格加密（AMR）的判据。通过编写代码，你将使用理查森外推法（Richardson extrapolation）风格的误差指示器来驱动模拟，并探索当加密容差低于舍入误差构成的“噪声地板”时，计算机会如何做出无效的“虚假加密”决策。这个练习深刻地揭示了在实际算法中，我们能达到的精度极限是由有限精度算术决定的。[@problem_id:3536557]", "problem": "考虑区间 $x \\in [0,1]$ 上的一个一维无量纲标量场 $f(x)$，它代表一个平滑变化的天体物理量（例如，恒星包层模型中的密度或比内能）。自适应网格加密（AMR）被用来高效地解析空间尺度。请基于由有限差分近似构建的局部截断误差指示器来定义自适应网格加密（AMR）的决策。您的目标是构建一个源自截断误差指示器的AMR加密准则，然后分析在何种阈值之下，舍入噪声会触发错误的加密。\n\n基本依据和假设：\n- 使用一维空间导数作为速度的定义，即 $g(x) = \\frac{df}{dx}$，并在点 $x$ 处使用大小为 $h$ 的均匀模板上的二阶中心有限差分来近似 $g(x)$：$g_h(x) = \\frac{f(x+h) - f(x-h)}{2h}$。\n- 对 $f(x+h)$ 和 $f(x-h)$ 在点 $x$ 附近进行泰勒展开，并利用一个经过充分检验的事实：对于足够光滑的 $f(x)$，二阶中心差分的截断误差具有 $O(h^2)$ 的标度关系。\n- 采用 Richardson 风格的自洽性方法：在 $h$ 和 $h/2$ 处形成两个近似值，并使用它们的差异来指示局部截断误差。您可以假设使用双精度浮点运算，其机器舍入误差为 $\\epsilon_{\\mathrm{mach}}$，约等于 $2.220446049250313 \\times 10^{-16}$，但您不能在解析上依赖此确切值，应将其视为一个由浮点实现控制的未知参数。\n- 任何三角函数的角度单位均为弧度。\n\n加密准则的构建：\n- 对于一个以 $x$ 为中心、局部网格间距为 $h$ 的单元格，使用上述中心差分公式计算两个近似值 $g_h(x)$ 和 $g_{h/2}(x)$。\n- 使用 $g_{h/2}(x)$ 和 $g_h(x)$ 之间的差值作为截断误差指示器。如果该指示器超过用户指定的容差 $\\tau$（无量纲），则加密该单元格。\n- 通过将被加密的单元格分裂成两个大小相等的子单元格（每个子单元格的间距为 $h/2$）来进行迭代加密，直到指示器小于或等于 $\\tau$ 或达到最大层级 $L_{\\max}$ 为止。\n\n错误加密分析：\n- 如果在该层级上，理论上仅由截断误差贡献的部分并未超过容差 $\\tau$ 时加密决策被触发，则将该决策定义为错误的。使用二阶中心差分的 $O(h^2)$ 截断定律，其主导项基于三阶导数：对于光滑的 $f(x)$，在点 $x$ 和间距 $h$ 处的纯截断误差大小表现为 $\\left|\\frac{f^{(3)}(x)}{6}\\right| h^2$。\n- 假设 $f(x)$ 足够光滑，以至于 $f^{(3)}(x)$ 在 $[0,1]$ 上存在且连续。\n\n您的程序必须：\n- 在一个覆盖 $[0,1]$ 区间、包含 $N_0$ 个单元格的基础均匀网格上实现上述 AMR 决策过程，并根据需要进行递归加密。\n- 对于给定的容差 $\\tau$，运行加密过程并计数：\n  - 加密决策的总数，以及\n  - 错误决策的数量，其定义为在父单元格上，理论纯截断误差项 $\\left|\\frac{f^{(3)}(x)}{6}\\right| h^2$ 小于或等于 $\\tau$。\n- 对于每个测试用例，确定最小的容差 $\\tau^\\star$，使得错误决策的比例（错误决策数除以总决策数）小于或等于一个指定的可允许错误比例 $\\delta$（将 $\\delta$ 表示为小数，而非百分比）。\n\n测试套件：\n- 在所有情况下，定义域均为 $x \\in [0,1]$，且三角函数使用弧度。\n- 案例 A（光滑，中等振幅）：$f(x) = A \\sin(k x)$，其中 $A = 1.0$，$k = 2\\pi$，$N_0 = 64$，$L_{\\max} = 8$，以及 $\\delta = 0.05$。\n- 案例 B（易受舍入误差影响，微小振幅）：$f(x) = A \\sin(k x)$，其中 $A = 10^{-12}$，$k = 2\\pi$，$N_0 = 64$，$L_{\\max} = 8$，以及 $\\delta = 0.05$。\n- 案例 C（高频内容）：$f(x) = A \\sin(k x)$，其中 $A = 1.0$，$k = 40\\pi$，$N_0 = 128$，$L_{\\max} = 8$，以及 $\\delta = 0.05$。\n\n输出规格：\n- 您的程序必须在一个合理的对数范围内搜索容差 $\\tau$，并使用稳健的搜索方法（例如，在对数标度上进行二分搜索）来为每个案例确定 $\\tau^\\star$。\n- 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为方括号括起来的逗号分隔列表，即 $[\\tau^\\star_{\\text{A}}, \\tau^\\star_{\\text{B}}, \\tau^\\star_{\\text{C}}]$。这些值是无量纲的，应以十进制数打印（科学记数法是可接受的）。", "solution": "用户提供了一个有效的问题陈述。该问题要求基于数值误差指示器构建和分析一个自适应网格加密（AMR）准则，并特别关注舍入误差开始占主导地位并导致虚假的“错误”加密的阈值。\n\n解决方案将分为三个主要部分进行阐述：\n1.  数值误差指示器和理论截断误差的推导。\n2.  分析截断误差和舍入误差之间的相互作用，定义错误加密的机制。\n3.  描述用于模拟 AMR 过程并搜索临界容差阈值 $\\tau^\\star$ 的算法。\n\n### 1. 误差指示器和截断误差\n\n我们的任务是近似标量场 $f(x)$ 的导数 $g(x) = \\frac{df}{dx}$。问题指定在间距为 $h$ 的网格上使用二阶中心有限差分近似：\n$$\ng_h(x) = \\frac{f(x+h) - f(x-h)}{2h}\n$$\n为了理解此近似的误差，我们假设 $f(x)$ 足够光滑以使其三阶导数 $f^{(3)}(x)$ 存在且连续，然后对 $f(x+h)$ 和 $f(x-h)$ 在点 $x$ 附近进行泰勒级数展开。\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + \\frac{h^3}{6}f^{(3)}(x) + \\frac{h^4}{24}f^{(4)}(x) + O(h^5)\n$$\n$$\nf(x-h) = f(x) - hf'(x) + \\frac{h^2}{2}f''(x) - \\frac{h^3}{6}f^{(3)}(x) + \\frac{h^4}{24}f^{(4)}(x) - O(h^5)\n$$\n用第一个展开式减去第二个展开式可得：\n$$\nf(x+h) - f(x-h) = 2hf'(x) + \\frac{h^3}{3}f^{(3)}(x) + O(h^5)\n$$\n两边同除以 $2h$ 并重新整理，得到用真实导数 $f'(x)$ 表示的数值近似 $g_h(x)$ 的表达式：\n$$\ng_h(x) = \\frac{f(x+h) - f(x-h)}{2h} = f'(x) + \\frac{h^2}{6}f^{(3)}(x) + O(h^4)\n$$\n截断误差 $E_T(h)$ 是近似值与真实值 $g(x) = f'(x)$ 之间的差：\n$$\nE_T(h) = g_h(x) - g(x) = \\frac{h^2}{6}f^{(3)}(x) + O(h^4)\n$$\n因此，主阶截断误差为 $E_T(h) \\approx C(x)h^2$，其中 $C(x) = \\frac{f^{(3)}(x)}{6}$。这证实了 $O(h^2)$ 的标度关系。\n\nAMR 加密准则是基于一种 Richardson 风格的误差指示器，该指示器比较在两个不同网格间距 $h$ 和 $h/2$ 上的近似值。让我们写出两者的表达式：\n$$\ng_h(x) = g(x) + C(x)h^2 + O(h^4)\n$$\n$$\ng_{h/2}(x) = g(x) + C(x)\\left(\\frac{h}{2}\\right)^2 + O(h^4) = g(x) + \\frac{1}{4}C(x)h^2 + O(h^4)\n$$\n误差指示器 $\\eta(x, h)$ 定义为这两个近似值之间的差：\n$$\n\\eta(x, h) = g_{h/2}(x) - g_h(x) = \\left(g(x) + \\frac{1}{4}C(x)h^2\\right) - \\left(g(x) + C(x)h^2\\right) + O(h^4) = -\\frac{3}{4}C(x)h^2 + O(h^4)\n$$\n该指示器的量值 $|\\eta(x, h)| = |g_{h/2}(x) - g_h(x)|$ 与父单元格近似的主阶截断误差 $|E_T(h)| \\approx |C(x)|h^2$ 成正比。因此，$|\\eta(x, h)|$ 可作为局部截断误差的一个可计算的代理，这证明了其用作加密准则的合理性。\n\n### 2. 由舍入误差引起的错误加密\n\n上述分析只考虑了截断误差。在采用浮点运算的实际计算中，舍入误差也有贡献。设 $\\tilde{g}_h(x)$ 为计算出的近似值。其总误差是截断误差和舍入误差之和：$E_{total}(h) = E_T(h) + E_R(h)$。\n\n中心差分公式中舍入误差的主要来源是 $f(x)$ 求值过程中表示误差的传播。设 $\\tilde{f}(y) = f(y)(1+\\epsilon_y)$，其中 $|\\epsilon_y| \\le \\epsilon_{\\mathrm{mach}}$ 是机器精度。计算出的差值为：\n$$\n\\tilde{g}_h(x) = \\frac{\\tilde{f}(x+h) - \\tilde{f}(x-h)}{2h} = \\frac{f(x+h)(1+\\epsilon_1) - f(x-h)(1+\\epsilon_2)}{2h}\n$$\n舍入误差分量为 $E_R(h) \\approx \\frac{f(x+h)\\epsilon_1 - f(x-h)\\epsilon_2}{2h}$。假设 $f$ 是光滑的，其量值的上界为：\n$$\n|E_R(h)| \\lesssim \\frac{(|f(x+h)| + |f(x-h)|)\\epsilon_{\\mathrm{mach}}}{2h} \\approx \\frac{|f(x)|\\epsilon_{\\mathrm{mach}}}{h}\n$$\n当 $h \\to 0$ 时，截断误差 $|E_T(h)| \\propto h^2$ 减小，而舍入误差 $|E_R(h)| \\propto h^{-1}$ 增大。总误差 $|E_{total}(h)|$ 在某个最优的 $h$ 值处有一个特征最小值。\n\n当加密被触发，即 $|\\tilde{\\eta}(x,h)|  \\tau$，但理论截断误差已在容差范围内，即 $|C(x)|h^2 \\le \\tau$ 时，我们定义发生了“错误加密”。这里的 $\\tilde{\\eta}$ 是数值计算出的指示器。这种情况发生在 $\\tau$ 被设置得过低，以至于低于指示器的噪声基底时。计算出的指示器 $\\tilde{\\eta}$ 变为由舍入噪声主导，即 $|\\tilde{\\eta}(x,h)| \\approx |E_R(h/2) - E_R(h)|$，这不再反映真实的截断误差。如果这个噪声水平超过了 $\\tau$，即使从截断误差的角度看网格已经足够解析，加密仍会被触发。这导致了计算资源的浪费。\n\n目标是找到最小的容差 $\\tau^\\star$，使得这些错误加密的比例不超过给定的阈值 $\\delta$。这个 $\\tau^\\star$ 代表了在舍入污染变得不可接受之前，可以从 AMR 方案中要求的精度的实际极限。\n\n### 3. 算法实现\n\n该问题通过实现一个两部分的算法来解决：一个 AMR 模拟函数和一个用于寻找 $\\tau^\\star$ 的搜索例程。\n\n**AMR 模拟：**\n一个函数 `run_amr_simulation` 接收物理参数（$A, k$）、网格参数（$N_0, L_{\\max}$）和一个容差 $\\tau$ 作为输入。\n1.  **初始化**：创建一个活动单元格列表，代表覆盖域 $[0,1]$、包含 $N_0$ 个单元格的基础网格。每个单元格由其中心 $x_i = (i+0.5)h_0$、层级 $l=0$ 和间距 $h_0 = 1/N_0$ 定义。\n2.  **迭代**：算法遍历活动单元格列表。对于每个单元格 $(x, l, h)$：\n    a. 如果单元格的层级 $l$ 已达到最大值 $L_{\\max}$，它不能再被加密。\n    b. 计算数值指示器 $|\\tilde{\\eta}| = |\\tilde{g}_{h/2}(x) - \\tilde{g}_h(x)|$。\n    c. 如果 $|\\tilde{\\eta}|  \\tau$，则做出加密决策。\n        i. 总加密计数器递增。\n        ii. 使用 $f(x)$ 的解析三阶导数计算理论截断误差的量值 $|E_{T,theory}| = |\\frac{f^{(3)}(x)}{6}|h^2$。对于 $f(x) = A\\sin(kx)$，其 $f^{(3)}(x) = -Ak^3\\cos(kx)$。\n        iii. 如果 $|E_{T,theory}| \\le \\tau$，该决策被归类为错误的，且错误加密计数器递增。\n        iv. 父单元格被替换为两个在层级 $l+1$、间距为 $h/2$、中心位于 $x \\pm h/4$ 的子单元格。这些子单元格被添加到待处理单元格列表中。\n3.  **输出**：该函数返回总加密数和错误加密数。\n\n**搜索 $\\tau^\\star$：**\n对于每个测试用例，我们必须找到最小的容差 $\\tau^\\star$，使得错误加密比例小于或等于 $\\delta$。\n1.  **单调性**：错误加密比例是 $\\tau$ 的一个单调非增函数。一个较小的 $\\tau$ 会导致总加密次数更多，并且其中更高比例的加密可能是“错误的”（由噪声触发）。\n2.  **二分搜索**：这种单调性使得我们可以使用高效的二分搜索来找到阈值 $\\tau^\\star$。搜索在一个很宽的范围（例如，从 $10^{-20}$ 到 $10^{0}$）内对 $\\tau$ 的对数进行。\n3.  **过程**：\n    a. 初始化一个搜索范围 $[\\log \\tau_{\\min}, \\log \\tau_{\\max}]$。\n    b. 在每一步中，选择一个中点 $\\log \\tau_{\\text{mid}}$ 并计算出相应的 $\\tau_{\\text{mid}} = 10^{\\log \\tau_{\\text{mid}}}$。\n    c. 使用 $\\tau_{\\text{mid}}$ 运行 AMR 模拟以获得错误比例。\n    d. 如果该比例 $\\le \\delta$，则 $\\tau_{\\text{mid}}$ 是一个有效的容差。我们将其存储为一个潜在答案，并通过设置 $\\tau_{\\max} = \\tau_{\\text{mid}}$ 来尝试寻找一个更小的有效容差。\n    e. 如果该比例 $\\delta$，则 $\\tau_{\\text{mid}}$ 太小了。我们必须通过设置 $\\tau_{\\min} = \\tau_{\\text{mid}}$ 来增大它。\n4.  经过足够次数的迭代后，搜索将收敛到所需的 $\\tau^\\star$。对三个测试用例中的每一个都重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f(x, A, k):\n    \"\"\"The scalar field function f(x) = A * sin(k*x).\"\"\"\n    return A * np.sin(k * x)\n\ndef f_ddd(x, A, k):\n    \"\"\"The analytical third derivative of f(x).\"\"\"\n    return -A * k**3 * np.cos(k * x)\n\ndef run_amr_simulation(A, k, N0, Lmax, tau):\n    \"\"\"\n    Simulates the AMR process for a given tolerance tau.\n\n    Args:\n        A (float): Amplitude of the sine function.\n        k (float): Wavenumber of the sine function.\n        N0 (int): Number of cells in the base grid.\n        Lmax (int): Maximum refinement level.\n        tau (float): Refinement tolerance.\n\n    Returns:\n        tuple: (total_refinements, false_refinements)\n    \"\"\"\n    total_refinements = 0\n    false_refinements = 0\n\n    h0 = 1.0 / N0\n    # A list of cells to process, structured as (x_center, level, h).\n    # We use a list as a queue for breadth-first processing.\n    cells_to_process = [( (i + 0.5) * h0, 0, h0) for i in range(N0)]\n\n    head = 0\n    while head  len(cells_to_process):\n        x, level, h = cells_to_process[head]\n        head += 1\n\n        if level >= Lmax:\n            continue\n\n        # Compute numerical derivatives and the error indicator\n        h_half = h / 2.0\n        \n        g_h = (f(x + h, A, k) - f(x - h, A, k)) / (2.0 * h)\n        g_h_half = (f(x + h_half, A, k) - f(x - h_half, A, k)) / (2.0 * h_half)\n\n        indicator = np.abs(g_h_half - g_h)\n\n        # Check refinement criterion\n        if indicator > tau:\n            total_refinements += 1\n\n            # Check for false refinement\n            # The theoretical truncation error for the parent cell is |f'''(x)/6| * h^2\n            theoretical_trunc_err = np.abs(f_ddd(x, A, k) / 6.0) * h**2\n\n            if theoretical_trunc_err = tau:\n                false_refinements += 1\n\n            # Add two child cells to the processing list for further refinement\n            cells_to_process.append((x - h / 4.0, level + 1, h_half))\n            cells_to_process.append((x + h / 4.0, level + 1, h_half))\n\n    return total_refinements, false_refinements\n\ndef find_tau_star(params):\n    \"\"\"\n    Finds the smallest tolerance tau_star satisfying the false fraction condition.\n    \n    Args:\n        params (tuple): A tuple containing all parameters for a test case.\n\n    Returns:\n        float: The calculated smallest tolerance tau_star.\n    \"\"\"\n    A, k, N0, Lmax, delta = params\n\n    # Binary search for tau_star on a logarithmic scale.\n    # The range is chosen to be wide enough for all expected scales.\n    log_tau_min = -30.0\n    log_tau_max = 5.0 \n    tau_star = 10**log_tau_max # Initialize with a safe upper bound.\n\n    # 100 iterations provide ample precision for a binary search.\n    for _ in range(100):\n        log_tau_mid = (log_tau_min + log_tau_max) / 2.0\n        tau_mid = 10**log_tau_mid\n\n        total_ref, false_ref = run_amr_simulation(A, k, N0, Lmax, tau_mid)\n\n        if total_ref == 0:\n            false_fraction = 0.0\n        else:\n            false_fraction = false_ref / total_ref\n\n        if false_fraction = delta:\n            # tau_mid is a valid tolerance. Store it and try for a smaller one.\n            tau_star = tau_mid\n            log_tau_max = log_tau_mid\n        else:\n            # tau_mid is too small. We need a larger tolerance.\n            log_tau_min = log_tau_mid\n\n    return tau_star\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (A, k, N0, Lmax, delta)\n    test_cases = [\n        # Case A: smooth, moderate amplitude\n        (1.0, 2.0 * np.pi, 64, 8, 0.05),\n        # Case B: round-off prone, tiny amplitude\n        (1.0e-12, 2.0 * np.pi, 64, 8, 0.05),\n        # Case C: high-frequency content\n        (1.0, 40.0 * np.pi, 128, 8, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        tau_star = find_tau_star(case)\n        results.append(f\"{tau_star:.6e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3536557"}, {"introduction": "最后一个练习将我们从误差分析提升到算法设计的层面。在高性能计算中，仅仅使用最高精度并非总是最高效的策略。这个练习将引导你设计并分析一种先进的混合精度迭代精化方法，用于求解天体物理学中常见的泊松方程。你将从理论上推导该方法收敛并达到双精度解的条件，这涉及到矩阵的条件数 $\\kappa(A)$ 和不同浮点精度的单位舍入误差，从而深刻理解如何巧妙地利用硬件特性来设计既快速又精确的数值方案。[@problem_id:3536578]", "problem": "考虑计算天体物理学中的引力势，它由有界域上的泊松方程控制。其离散模型导出一个形如 $A x = b$ 的线性系统，其中 $A$ 是一个对称正定（SPD）矩阵。我们研究用于求解 $A x = b$ 的混合精度迭代精化方法，其中主求解过程以单精度执行，但残差和更新在双精度下累积。设 $u_s$ 表示单精度的单位舍入， $u_d$ 表示双精度的单位舍入。假设采用标准的浮点数舍入到最近值。\n\n从以下基本概念出发：\n- 引力势 $\\phi$ 满足 $-\\nabla^2 \\phi = 4 \\pi G \\rho$，其在网格上离散化为一个稀疏 SPD 系统。\n- 对于线性系统 $A x = b$，其 2-范数条件数为 $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$，它控制解对扰动的敏感度。\n- 一个单精度的后向稳定线性求解器返回 $\\tilde{x}$，满足 $(A + \\Delta A)\\tilde{x} = b$，其中 $\\|\\Delta A\\|_2 \\le \\gamma_s u_s \\|A\\|_2$，$\\gamma_s$ 是一个适中的常数。\n- 迭代精化执行 $x_{k+1} = x_k + \\delta_k$，其中校正项 $\\delta_k$ 通过求解 $A \\delta_k \\approx r_k = b - A x_k$ 得到。\n\n任务：\n1. 基于后向误差模型和扰动界，推导在何种关于 $\\kappa_2(A)$、$u_s$ 和 $u_d$ 的条件下，混合精度迭代精化能够产生一个前向误差为 $u_d$ 数量级的解，即 $\\|x - x^\\star\\|_2 / \\|x^\\star\\|_2 \\lesssim C \\,\\kappa_2(A)\\, u_d$（对于一个适中的常数 $C$），其中 $x^\\star$ 是 $A x^\\star = b$ 的精确解。\n2. 实现一个完整、可运行的程序，该程序：\n   - 在一个 $m \\times m$ 的内部网格上，使用标准的五点差分格式，构建单位正方形上带有狄利克雷边界条件的离散二维泊松算子 $A$。设网格间距 $h_x = h_y = 1/(m+1)$，定义一维三对角算子 $T_x$ 和 $T_y$ 为 $T_x = \\operatorname{tridiag}(-1,2,-1)/h_x^2$ 和 $T_y = \\operatorname{tridiag}(-1,2,-1)/h_y^2$，并组装 $A = I \\otimes T_x + T_y \\otimes I$，其中 $I$ 是大小为 $m$ 的单位矩阵，$\\otimes$ 表示克罗内克积。\n   - 使用混合精度迭代精化，其中线性求解 $(A + \\Delta A) z = y$ 使用单精度算术执行，而残差和迭代解在双精度下计算。\n   - 对于截断误差为零的人造数据，选择 $x^\\star$ 为采样离散函数 $x^\\star_{i,j} = \\sin(\\pi x_i)\\sin(\\pi y_j)$，其中 $x_i = i h_x$，$y_j = j h_y$，并设置 $b = A x^\\star$（在双精度下计算）。对于截断误差主导的情况，设置 $b_{i,j} = f(x_i,y_j)$，其中 $f(x,y) = -\\Delta(\\sin(\\pi x)\\sin(\\pi y)) = 2 \\pi^2 \\sin(\\pi x)\\sin(\\pi y)$（各向同性情况），并求解 $A x = b$。\n   - 根据已知的狄利克雷离散拉普拉斯算子的谱精确计算 $\\kappa_2(A)$：设 $s_{\\min} = \\sin^2\\left(\\frac{\\pi}{2(m+1)}\\right)$ 和 $s_{\\max} = \\sin^2\\left(\\frac{\\pi m}{2(m+1)}\\right)$，则极端特征值为 $\\lambda_{\\min} = \\frac{4}{h_x^2} s_{\\min} + \\frac{4}{h_y^2} s_{\\min}$ 和 $\\lambda_{\\max} = \\frac{4}{h_x^2} s_{\\max} + \\frac{4}{h_y^2} s_{\\max}$，因此 $\\kappa_2(A) = \\lambda_{\\max} / \\lambda_{\\min}$。\n   - 为每个测试用例报告：\n     a. 一个布尔值，指示理论判据 $\\kappa_2(A)\\,u_s  1$ 是否成立。\n     b. 一个布尔值，指示所达到的相对前向误差 $\\|x - x^\\star\\|_2 / \\|x^\\star\\|_2$ 是否小于 $10 \\,\\kappa_2(A)\\,u_d$。\n     c. 所达到的相对前向误差（浮点数）。\n\n测试套件：\n- 用例 1：$m = 32$，人造离散右侧项 $b = A x^\\star$。\n- 用例 2：$m = 64$，人造离散右侧项 $b = A x^\\star$。\n- 用例 3：$m = 64$，截断误差情况，其中 $b_{i,j} = 2 \\pi^2 \\sin(\\pi x_i)\\sin(\\pi y_j)$。\n\n角度单位：弧度。所有报告的量均为无量纲。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[$cond\\_ok\\_case1, success\\_case1, error\\_case1, cond\\_ok\\_case2, success\\_case2, error\\_case2, cond\\_ok\\_case3, success\\_case3, error\\_case3$]$。每个布尔值必须是 True 或 False，每个误差值必须是浮点数。", "solution": "该问题要求推导线性系统 $A x = b$ 的混合精度迭代精化的收敛条件和极限精度，然后通过数值实现来验证这些条件。\n\n### 第 1 部分：理论推导\n\n我们分析用于求解线性系统 $A x = b$ 的混合精度迭代精化方案，其中 $A$ 是一个 $N \\times N$ 的对称正定（SPD）矩阵。该方案包括一次单精度的初始求解，随后是精化步骤，其中残差在双精度下计算，校正方程在单精度下求解，解在双精度下更新。设 $x^\\star = A^{-1} b$ 为精确解。\n\n迭代过程定义为：\n$x_{k+1} = x_k + \\delta_k$，对于 $k=0, 1, 2, \\dots$\n\n设 $e_k = x_k - x^\\star$ 为第 $k$ 次迭代的误差。误差更新为 $e_{k+1} = x_{k+1} - x^\\star = (x_k + \\delta_k) - x^\\star = e_k + \\delta_k$。我们分析校正项 $\\delta_k$ 的计算以理解误差的传播。\n\n**1. 残差计算：**\n残差 $r_k = b - A x_k$ 在双精度下计算。设 $fl_d(\\cdot)$ 表示双精度浮点运算，单位舍入为 $u_d$。\n计算出的残差为 $\\hat{r}_k = fl_d(b - A x_k)$。\n精确残差为 $r_k = b - A x_k = A x^\\star - A x_k = -A e_k$。\n$A x_k$ 的计算及随后的减法会引入浮点误差。计算残差中的误差可以界定为：\n$\\hat{r}_k = (b - A x_k) + f_k = -A e_k + f_k$\n其中对于某个小常数 $\\gamma_d$，有 $\\|f_k\\|_2 \\le \\gamma_d u_d (\\|b\\|_2 + \\|A\\|_2 \\|x_k\\|_2)$。假设 $x_k \\approx x^\\star$，这可以简化为 $\\|f_k\\|_2 \\lesssim C_1 u_d \\|A\\|_2 \\|x^\\star\\|_2$，其中 $C_1$ 是一个常数。\n\n**2. 校正求解：**\n校正方程 $A \\delta_k = \\hat{r}_k$ 在单精度下求解。设计算出的校正项为 $\\hat{\\delta}_k$。问题指出单精度求解器是后向稳定的。这意味着 $\\hat{\\delta}_k$ 是一个扰动系统的精确解：\n$(A + \\Delta A_k) \\hat{\\delta}_k = \\hat{r}_k$\n其中扰动 $\\Delta A_k$ 的界为 $\\|\\Delta A_k\\|_2 \\le \\gamma_s u_s \\|A\\|_2$。这里，$u_s$ 是单精度单位舍入，$\\gamma_s$ 是一个适中的常数。该模型假设矩阵 $A$（以双精度存储）在求解时被转换为单精度，并且后向误差是相对于原始矩阵 $A$ 来度量的。\n\n由此，我们可以表示计算出的校正项：\n$\\hat{\\delta}_k = (A + \\Delta A_k)^{-1} \\hat{r}_k = (I + A^{-1} \\Delta A_k)^{-1} A^{-1} \\hat{r}_k$\n\n为使逆 $(I + A^{-1} \\Delta A_k)^{-1}$ 存在，我们需要 $\\|A^{-1} \\Delta A_k\\|_2  1$。\n$\\|A^{-1} \\Delta A_k\\|_2 \\le \\|A^{-1}\\|_2 \\|\\Delta A_k\\|_2 \\le \\|A^{-1}\\|_2 (\\gamma_s u_s \\|A\\|_2) = \\gamma_s u_s \\kappa_2(A)$\n其中 $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$ 是 $A$ 的 2-范数条件数。\n因此，精化步骤有效的关键条件是 $\\gamma_s u_s \\kappa_2(A)  1$。由于 $\\gamma_s$ 是一个小常数，这通常被表述为简化条件 $\\kappa_2(A) u_s  1$。\n\n如果此条件成立，我们可以使用诺伊曼级数展开：当 $\\|E\\| \\ll 1$ 时，$(I + E)^{-1} = I - E + E^2 - \\dots \\approx I - E$。\n$\\hat{\\delta}_k \\approx (I - A^{-1} \\Delta A_k) A^{-1} \\hat{r}_k$\n\n**3. 解的更新：**\n更新 $x_{k+1} = x_k + \\hat{\\delta}_k$ 在双精度下执行。\n新的计算迭代解为 $fl_d(x_k + \\hat{\\delta}_k) = x_k + \\hat{\\delta}_k + h_k$，其中 $\\|h_k\\|_2 \\le u_d \\|x_{k+1}\\|_2 \\approx u_d \\|x^\\star\\|_2$。\n新的误差为 $e_{k+1} = (x_k + \\hat{\\delta}_k + h_k) - x^\\star = e_k + \\hat{\\delta}_k + h_k$。\n\n**4. 误差递推关系：**\n代入 $\\hat{\\delta}_k$ 和 $\\hat{r}_k$ 的表达式：\n$e_{k+1} \\approx e_k + (I - A^{-1} \\Delta A_k) A^{-1} (-A e_k + f_k) + h_k$\n$e_{k+1} \\approx e_k + (I - A^{-1} \\Delta A_k) (-e_k + A^{-1} f_k) + h_k$\n$e_{k+1} \\approx e_k - e_k + A^{-1}f_k + A^{-1}\\Delta A_k e_k - A^{-1}\\Delta A_k A^{-1}f_k + h_k$\n$e_{k+1} \\approx (A^{-1}\\Delta A_k) e_k + A^{-1}f_k + h_k - (A^{-1}\\Delta A_k A^{-1}f_k)$\n\n取范数并忽略高阶项：\n$\\|e_{k+1}\\|_2 \\lesssim \\|A^{-1}\\Delta A_k\\|_2 \\|e_k\\|_2 + \\|A^{-1}\\|_2 \\|f_k\\|_2 + \\|h_k\\|_2$\n$\\|e_{k+1}\\|_2 \\lesssim (\\gamma_s u_s \\kappa_2(A)) \\|e_k\\|_2 + \\|A^{-1}\\|_2 (C_1 u_d \\|A\\|_2 \\|x^\\star\\|_2) + u_d \\|x^\\star\\|_2$\n$\\|e_{k+1}\\|_2 \\lesssim (\\gamma_s u_s \\kappa_2(A)) \\|e_k\\|_2 + (C_1 \\kappa_2(A) + 1) u_d \\|x^\\star\\|_2$\n\n这构成了误差范数的递推关系。收敛的条件，即每一步误差减小的条件，是收缩因子必须小于 1：\n$\\gamma_s u_s \\kappa_2(A)  1$。\n\n**5. 极限精度：**\n如果收敛条件成立，迭代将继续进行直到误差停滞，即 $\\|e_{k+1}\\|_2 \\approx \\|e_k\\|_2 = \\|e_{\\infty}\\|_2$。极限误差 $\\|e_{\\infty}\\|_2$ 的大小由与 $\\|e_k\\|_2$ 无关的项决定。\n$\\|e_{\\infty}\\|_2 \\approx (\\gamma_s u_s \\kappa_2(A)) \\|e_{\\infty}\\|_2 + (C_1 \\kappa_2(A) + 1) u_d \\|x^\\star\\|_2$\n$\\|e_{\\infty}\\|_2 (1 - \\gamma_s u_s \\kappa_2(A)) \\approx (C_1 \\kappa_2(A) + 1) u_d \\|x^\\star\\|_2$\n$\\|e_{\\infty}\\|_2 \\approx \\frac{C_1 \\kappa_2(A) + 1}{1 - \\gamma_s u_s \\kappa_2(A)} u_d \\|x^\\star\\|_2$\n\n由于对于精细离散化，$\\kappa_2(A)$ 通常很大，因此项 $C_1 \\kappa_2(A)$ 在分子中占主导地位。如果收敛相当快（即 $\\gamma_s u_s \\kappa_2(A)$ 不接近 1），则分母接近 1。因此，极限相对前向误差为：\n$\\frac{\\|x_{\\infty} - x^\\star\\|_2}{\\|x^\\star\\|_2} \\lesssim C \\kappa_2(A) u_d$\n对于一个适中的常数 $C \\approx C_1$。这个推导确定了，在条件 $\\kappa_2(A) u_s  1$ 下，混合精度迭代精化可以达到一个与条件数和双精度单位舍入成正比的最终误差，从而有效地通过一系列单精度求解恢复双精度精度。\n\n### 第 2 部分：数值实现策略\n\n程序将实现所述算法并在三种场景下进行测试。\n\n**矩阵和系统构造：**\n- 离散二维拉普拉斯矩阵 $A$ 使用克罗内克积公式 $A = I \\otimes T_x + T_y \\otimes I$ 进行组装。由于 $h_x=h_y=h$，这可以简化为 $A = I_m \\otimes T_m + T_m \\otimes I_m$，其中 $T_m = \\operatorname{tridiag}(-1, 2, -1)/h^2$。为了效率，将使用 `scipy.sparse` 完成此操作。\n- 将保留一个双精度（`float64`）的稀疏版本 $A$，并将其转换为单精度（`float32`）版本，用于校正求解步骤。\n- 条件数 $\\kappa_2(A)$ 使用其极端特征值的给定公式进行解析计算，这对于大型矩阵比数值估计要高效得多。\n\n**问题用例：**\n- **用例 1 和 2（人造解）：** 精确离散解 $x^\\star$ 被设置为一个采样的正弦函数。然后，右侧项被人造为 $b = A x^\\star$。此过程消除了截断误差，因此测得的误差 $\\|x - x^\\star\\|_2 / \\|x^\\star\\|_2$ 仅反映了混合精度求解器的误差。\n- **用例 3（截断误差）：** 右侧项 $b$ 通过采样连续函数 $f(x,y) = 2 \\pi^2 \\sin(\\pi x)\\sin(\\pi y)$ 来设置，该函数是 $-\\nabla^2(\\sin(\\pi x)\\sin(\\pi y))$。用于比较的“精确”解 $x^\\star$ 仍然是采样的正弦函数。在这种情况下，测量的总误差是求解器误差和五点差分格式离散误差（量级为 $O(h^2)$）的总和。由于求解器误差预计非常小（量级为 $\\kappa_2(A)u_d$），总误差将由 $O(h^2)$ 的截断误差主导。此用例旨在演示算法改进被模型级不准确性所掩盖的场景。\n\n**报告：**\n对于每个用例，代码将计算并报告：\n1.  理论收敛判据的有效性：`kappa_2(A) * u_s  1`。\n2.  达到目标精度的成功性：`relative_error  10 * kappa_2(A) * u_d`。因子 $10$ 用于解释各种常数（$\\gamma_s, C_1$）和模型近似。\n3.  所达到的相对前向误差。\n\n实现将遵循清晰的结构，为每个测试用例执行设置、运行精化循环并计算指定的指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef run_problem_case(m, b_type):\n    \"\"\"\n    Solves one test case of the mixed-precision iterative refinement problem.\n\n    Args:\n        m (int): The number of interior grid points in one dimension.\n        b_type (str): The type of right-hand side to use, either 'manufactured'\n                      or 'truncation'.\n\n    Returns:\n        tuple: A tuple containing (cond_ok, success, relative_error).\n    \"\"\"\n    # 1. Define Constants and Setup Grid\n    u_s = np.finfo(np.float32).eps / 2.0\n    u_d = np.finfo(np.float64).eps / 2.0\n    pi = np.pi\n    \n    h = 1.0 / (m + 1)\n    \n    # 2. Construct Sparse Matrix A\n    # A is constructed in double precision (float64) by default\n    T_m = diags([-1, 2, -1], [-1, 0, 1], shape=(m, m), dtype=np.float64) / (h * h)\n    I_m = identity(m, dtype=np.float64)\n    A = kron(I_m, T_m) + kron(T_m, I_m)\n    \n    # Create CSC (Compressed Sparse Column) versions for efficient solving\n    A_csc = A.tocsc()\n    A_s_csc = A_csc.astype(np.float32)\n\n    # 3. Calculate Condition Number Analytically\n    s_min = np.sin(pi / (2.0 * (m + 1)))**2\n    s_max = np.sin(pi * m / (2.0 * (m + 1)))**2\n    # For isotropic case h_x = h_y = h, kappa = s_max/s_min\n    kappa_A = s_max / s_min\n    \n    # 4. Define Exact Solution x_star and Right-Hand Side b\n    # Grid points for function evaluation\n    grid_pts = np.arange(1, m + 1) * h\n    X, Y = np.meshgrid(grid_pts, grid_pts)\n    \n    # The 'true' solution x_star is the sampled continuous function for all cases\n    x_star_2d = np.sin(pi * X) * np.sin(pi * Y)\n    x_star = x_star_2d.flatten().astype(np.float64)\n    \n    if b_type == 'manufactured':\n        # b = A * x_star eliminates truncation error. Computed in double precision.\n        b = A_csc.dot(x_star)\n    elif b_type == 'truncation':\n        # b is the RHS of the continuous PDE. This introduces truncation error.\n        b_2d = 2 * pi**2 * np.sin(pi * X) * np.sin(pi * Y)\n        b = b_2d.flatten().astype(np.float64)\n    else:\n        raise ValueError(\"Invalid b_type specified.\")\n        \n    # 5. Mixed-Precision Iterative Refinement\n    max_refinement_steps = 3\n    \n    # Initial solve in single precision\n    b_s = b.astype(np.float32)\n    x_k = spsolve(A_s_csc, b_s)\n    x_k = x_k.astype(np.float64) # Promote iterate to double precision for storage\n\n    # Refinement loop\n    for _ in range(max_refinement_steps):\n        # Compute residual in double precision\n        r_k = b - A_csc.dot(x_k)\n        \n        # Solve for correction in single precision\n        r_k_s = r_k.astype(np.float32)\n        delta_k = spsolve(A_s_csc, r_k_s)\n        \n        # Update solution in double precision\n        x_k = x_k + delta_k.astype(np.float64)\n    \n    x_computed = x_k\n    \n    # 6. Calculate and Report Metrics\n    cond_ok = (kappa_A * u_s)  1.0\n    \n    # Relative forward error: ||x_computed - x_star|| / ||x_star||\n    norm_x_star = np.linalg.norm(x_star)\n    relative_error = np.linalg.norm(x_computed - x_star) / norm_x_star\n\n    # Check if the error meets the theoretical bound for the solver\n    success = relative_error  (10.0 * kappa_A * u_d)\n    \n    return cond_ok, success, relative_error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 'manufactured'), # Case 1\n        (64, 'manufactured'), # Case 2\n        (64, 'truncation'),   # Case 3\n    ]\n\n    results = []\n    for m, b_type in test_cases:\n        try:\n            cond_ok, success, error = run_problem_case(m, b_type)\n            results.extend([cond_ok, success, error])\n        except Exception as e:\n            # Add placeholders in case of an unexpected error\n            results.extend([False, False, -1.0])\n            print(f\"Error in case (m={m}, b_type='{b_type}'): {e}\")\n\n    # Final print statement in the exact required format.\n    # Convert booleans to Python's True/False strings.\n    formatted_results = [str(r) if isinstance(r, bool) else f\"{r:.6e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3536578"}]}