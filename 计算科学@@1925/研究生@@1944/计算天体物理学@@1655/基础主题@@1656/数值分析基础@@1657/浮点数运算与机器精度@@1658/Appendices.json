{"hands_on_practices": [{"introduction": "在我们深入探讨浮点运算的误差之前，我们必须首先理解数字本身是如何在计算机中表示的。并非所有我们熟悉的实数都能被完美地存储，这个基本事实是许多数值问题的根源。这项实践 [@problem_id:3510985] 将挑战你从第一性原理出发，判断一个大的10的整数次幂是否可以在二进制浮点格式中被精确表示，从而迫使你深入理解有效数字（significand）的二进制结构。", "problem": "在一个用于吸积盘模拟的三维辐射流体力学求解器中，你采用了量纲归一化，这导致通量和不透明度的量级跨越多个数量级。考虑在时间步长稳定性估计中出现的一个特征源振幅，即无量纲标量 $x = 10^{20}$。该代码使用电气和电子工程师协会 (IEEE) 754 binary64 (双精度) 格式，采用“向最接近的值舍入，若与两边距离相等则舍入到偶数”的舍入模式。\n\n从 IEEE 754 binary64 表示的形式化定义（一个符号位、一个偏置值为 $1023$ 的 $11$ 位偏置指数，以及一个对于规格化数带有隐藏前导 $1$ 的 $52$ 位尾数）和规格化数 $x = m \\times 2^{e}$（其中 $m \\in [1,2)$ 且 $e$ 为整数）的结构出发，根据基本原理判断 $x$ 是否可以在 binary64 中被精确表示。仅使用以下基本事实：$10^{20} = 2^{20} \\times 5^{20}$，恒等式 $\\log_{2}(10) = \\ln(10)/\\ln(2)$，以及给定指数附近可表示数的间距。如果 $x$ 不能被精确表示，请指出最邻近的两个可表示的 binary64 数，并给出它们在符号/指数/尾数字段中的 64 位模式。如果 $x$ 可以被精确表示，请给出它在符号/指数/尾数字段中的 64 位模式。你也可以额外提供其十六进制 64 位字。\n\n最后，在“向最接近的值舍入，若与两边距离相等则舍入到偶数”的模式下，计算绝对舍入误差 $| \\operatorname{fl}(x) - x |$。将你的最终答案表示为一个无单位的精确实数。", "solution": "该问题要求分析数字 $x = 10^{20}$ 在 IEEE 754 binary64 (双精度) 浮点格式中的可表示性，并计算其绝对舍入误差。\n\n首先，我们验证问题陈述。\n**第一步：提取已知条件**\n-   要表示的数字是 $x = 10^{20}$。\n-   浮点格式为 IEEE 754 binary64 (双精度)。\n-   舍入模式为“向最接近的值舍入，若与两边距离相等则舍入到偶数”。\n-   Binary64 表示细节：$1$ 个符号位，一个偏置值为 $1023$ 的 $11$ 位偏置指数，以及一个对于规格化数带有隐藏前导 $1$ 的 $52$ 位尾数。\n-   规格化数结构：$v = m \\times 2^{e}$，其中 $m \\in [1, 2)$ 且 $e$ 为整数。\n-   给出的恒等式：$10^{20} = 2^{20} \\times 5^{20}$。\n-   给出的关系式：$\\log_{2}(10) = \\ln(10)/\\ln(2)$。\n-   任务是判断 $x$ 是否可被精确表示，如果是，则找出其位模式（如果不是，则找出其相邻数的模式），并计算绝对舍入误差 $| \\operatorname{fl}(x) - x |$。\n\n**第二步：使用提取的已知条件进行验证**\n该问题具有科学依据，涉及 IEEE 754 标准所定义的浮点算术基本原理。问题提法严谨，提供了确定唯一解所需的所有信息。语言客观而精确。该问题是数值分析和计算科学中的一个标准练习，其天体物理学背景仅仅是上下文。该问题有效。\n\n**第三步：结论与行动**\n问题有效。我们继续进行求解。\n\n一个数 $v$ 如果能写成以下形式，就可以被精确表示为一个规格化的 binary64 浮点数：\n$$v = (-1)^{S} \\times m \\times 2^{e}$$\n其中 $S$ 是符号位（$0$ 表示正，$1$ 表示负），$e$ 是在 $[-1022, 1023]$ 范围内的整数指数，$m$ 是在 $[1, 2)$ 范围内的有效数。有效数 $m$ 必须具有形式为 $m = (1.f_1 f_2 \\dots f_{52})_2 = 1 + \\sum_{i=1}^{52} f_i 2^{-i}$ 的有限二进制表示。这等价于说 $m$ 必须可以写成 $1 + \\frac{F}{2^{52}}$ 的形式，其中 $F$ 是在 $0 \\le F  2^{52}$ 范围内的整数。\n\n我们分析数字 $x = 10^{20}$。\n1.  **符号 (Sign):** $x$ 是正数，所以符号位 $S=0$。\n\n2.  **指数 (Exponent):** 我们将 $x$ 表示为二进制科学记数法，$x = m \\times 2^e$，其中 $1 \\le m  2$。指数 $e$ 可以通过取以 2 为底的对数得到：\n    $$\\log_2(x) = \\log_2(m \\times 2^e) = \\log_2(m) + e$$\n    因为 $1 \\le m  2$，我们有 $0 \\le \\log_2(m)  1$。因此，指数 $e$ 是 $\\log_2(x)$ 的整数部分：\n    $$e = \\lfloor \\log_2(x) \\rfloor = \\lfloor \\log_2(10^{20}) \\rfloor = \\lfloor 20 \\log_2(10) \\rfloor$$\n    使用恒等式 $\\log_2(10) = \\frac{\\ln(10)}{\\ln(2)} \\approx \\frac{2.302585}{0.693147} \\approx 3.321928$，我们得到：\n    $$e = \\lfloor 20 \\times 3.321928\\dots \\rfloor = \\lfloor 66.43856\\dots \\rfloor = 66$$\n    指数 $e=66$ 在 binary64 规格化数的允许范围 $[-1022, 1023]$ 之内。\n\n3.  **有效数 (Significand):** 有效数 $m$ 由下式给出：\n    $$m = \\frac{x}{2^e} = \\frac{10^{20}}{2^{66}}$$\n    使用给出的恒等式 $10^{20} = 2^{20} \\times 5^{20}$：\n    $$m = \\frac{2^{20} \\times 5^{20}}{2^{66}} = \\frac{5^{20}}{2^{46}}$$\n    为了使 $x$ 能够被精确表示，$m$ 必须具有一个最多包含 $52$ 个小数位的有限二进制表示。一个有理数当且仅当其分母是 $2$ 的幂时，才具有有限二进制表示。我们的有效数 $m$ 的形式为 $\\frac{K}{2^N}$，其中 $K=5^{20}$ 且 $N=46$。它是一个二进有理数，因此具有有限二进制表示。所需的小数位数为 $N=46$。由于 binary64 格式提供 $52$ 个小数位，且 $46 \\le 52$，所以该有效数可以被精确表示。\n\n    我们还必须确认 $m$ 在范围 $[1, 2)$ 内：\n    $$1 \\le \\frac{5^{20}}{2^{46}}  2 \\implies 2^{46} \\le 5^{20}  2^{47}$$\n    对所有部分取以 2 为底的对数：\n    $$46 \\le \\log_2(5^{20})  47 \\implies 46 \\le 20 \\log_2(5)  47$$\n    由于 $\\log_2(5) = \\log_2(10) - 1 \\approx 2.321928$，我们有 $20 \\log_2(5) \\approx 46.43856$。不等式 $46 \\le 46.43856  47$ 成立。因此，$m$ 是一个有效的规格化有效数。\n\n由于所有条件都满足，数字 $x=10^{20}$ 可以在 binary64 格式中被精确表示。\n\n现在我们来确定其 64 位模式。\n-   **符号位（1 位）：** $S=0$。\n\n-   **指数场（11 位）：** 真实指数是 $e=66$。偏置指数是 $E_b = e + 1023 = 66 + 1023 = 1089$。我们将 $1089$ 转换为一个 11 位的二进制数：\n    $$1089 = 1024 + 64 + 1 = 2^{10} + 2^6 + 2^0$$\n    其 11 位模式是 `10001000001`。\n\n-   **尾数场（52 位）：** 尾数场存储有效数小数部分的二进制表示，即 $f = m-1$。\n    $$f = m-1 = \\frac{5^{20}}{2^{46}} - 1 = \\frac{5^{20} - 2^{46}}{2^{46}}$$\n    尾数场包含 $f$ 的前 $52$ 位。我们可以通过计算 $F = f \\times 2^{52}$ 来找到这些位所代表的整数值 $F$：\n    $$F = \\left(\\frac{5^{20} - 2^{46}}{2^{46}}\\right) \\times 2^{52} = (5^{20} - 2^{46}) \\times 2^6$$\n    我们计算必要的整数值：\n    $5^{20} = 95367431640625$\n    $2^{46} = 70368744177664$\n    $2^6 = 64$\n    $$F = (95367431640625 - 70368744177664) \\times 64 = 24998687462961 \\times 64 = 1599915997629504$$\n    这个整数 $F$ 必须表示为一个 52 位的二进制数。用十六进制表示，$F = 5\\text{B}0\\text{B}2\\text{E}3\\text{D}84800_{16}$。尾数场的 52 位二进制模式是：\n    `0101101100001011001011100011110110000100100000000000`。\n\n$10^{20}$ 的位模式是：\n-   符号场：`0`\n-   指数场：`10001000001`\n-   尾数场：`0101101100001011001011100011110110000100100000000000`\n\n完整的 64 位字可以通过拼接这些字段以十六进制表示：\n-   `0` (符号) + `10001000001` (指数) + `0101...` (尾数)\n-   `0100` `0100` `0001` `0101` `1011` `0000` `1011` `0010` `1110` `0011` `1101` `1000` `0100` `1000` `0000` `0000`\n-   这对应于十六进制字：`4415B0B2E3D84800`。\n\n最后，我们计算绝对舍入误差 $|\\operatorname{fl}(x) - x|$。由于我们已经证明 $x=10^{20}$ 是可以被精确表示的，它的浮点表示 $\\operatorname{fl}(x)$ 等于 $x$ 本身。\n$$\\operatorname{fl}(10^{20}) = 10^{20}$$\n因此，绝对舍入误差为：\n$$| \\operatorname{fl}(10^{20}) - 10^{20} | = | 10^{20} - 10^{20} | = 0$$\n舍入误差精确为零。", "answer": "$$\\boxed{0}$$", "id": "3510985"}, {"introduction": "了解了数字的表示方式后，下一步是探索其精度的极限。这项实践 [@problem_id:3510974] 将引导你通过数值方法测量机器精度的基本常数——机器 epsilon ($\\varepsilon_{\\mathrm{mach}}$) 和单位舍入误差 ($u$)。随后，你将立即把这一概念应用于天体物理学中的一个经典问题：在计算轨道能量差时发生的灾难性相消（catastrophic cancellation），这是对精度损失的一个生动展示。", "problem": "在计算天体物理学中，数值模拟依赖于浮点运算的行为。电气与电子工程师协会（IEEE）754 标准定义了一个二进制浮点系统，其特征包括基数 $\\,\\beta\\,$、精度 $\\,p\\,$（尾数中的有效位数，对于规格化数包括隐含的前导位），以及一个舍入规则。当采用“向最接近的值舍入，偶数优先”（ties to even）的规则时，靠近 $\\,1\\,$ 的连续规格化浮点数之间的间距为 $\\,\\varepsilon_{\\mathrm{mach}} = \\beta^{1-p}\\,$，而单位舍入误差 $\\,u\\,$（出现在标准舍入模型 $\\,\\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)\\,$ 中的界限，对于基本运算 $\\,\\circ \\in \\{+, -, \\times, \\div\\}\\,$, 有 $\\,|\\delta| \\le u\\,$）为 $\\,u = \\frac{1}{2}\\beta^{1-p}\\,$。\n\n您需要实现一个鲁棒的数值算法，在执行平台上计算两种 IEEE 754 二进制格式的单位舍入误差 $\\,u\\,$ 和机器 epsilon $\\,\\varepsilon_{\\mathrm{mach}}\\,$：\n- Binary64（双精度），其中 $\\,\\beta = 2\\,$ 且 $\\,p = 53\\,$。\n- Binary32（单精度），其中 $\\,\\beta = 2\\,$ 且 $\\,p = 24\\,$。\n\n然后，将您计算出的值与根据 $\\,\\beta\\,$ 和 $\\,p\\,$ 推导出的理论值进行比较，并根据定义和舍入行为解释任何差异。最后，评估机器精度在一个涉及（数值）相消的数值敏感天体物理计算中的影响。\n\n使用的定义：\n- 机器 epsilon $\\,\\varepsilon_{\\mathrm{mach}}\\,$ 是指间隙 $\\,\\operatorname{nextafter}(1, 2) - 1\\,$, 其中 $\\,\\operatorname{nextafter}\\,$ 返回朝向 $\\,2\\,$ 方向的下一个可表示的浮点数。\n- 单位舍入误差 $\\,u\\,$ 是使得 $\\,1 + \\eta\\,$ 舍入后得到一个严格大于 $\\,1\\,$ 的浮点数的最小正数 $\\,\\eta\\,$。在“向最接近的值舍入，偶数优先”的规则下，这个阈值等于 $\\,\\varepsilon_{\\mathrm{mach}}/2\\,$。\n\n算法要求：\n1. 实现一个鲁棒的循环来计算给定浮点类型的 $\\,u\\,$：从 $\\,\\eta = 1\\,$ 开始，重复将 $\\,\\eta\\,$ 折半，直到 $\\,1 + \\eta = 1\\,$；等式成立前的上一个 $\\,\\eta\\,$ 值即为 $\\,u\\,$。此方法必须使用目标数据类型，而不是更高精度的中间变量。\n2. 在目标类型中使用位于 $\\,1\\,$ 的 $\\,\\operatorname{nextafter}\\,$ 函数计算 $\\,\\varepsilon_{\\mathrm{mach}}\\,$，以避免依赖于折半的算术序列。\n3. 对指定的 $\\,(\\beta, p)\\,$，使用 $\\,\\varepsilon_{\\mathrm{th}} = \\beta^{1-p}\\,$ 和 $\\,u_{\\mathrm{th}} = \\frac{1}{2}\\beta^{1-p}\\,$ 计算理论值。\n\n天体物理相消评估：\n考虑在牛顿引力下圆形轨道的单位质量比轨道能，$\\,E(r) = -\\frac{G M}{2 r}\\,$。为了进行此数值评估，设 $\\,G M = 1\\,$，因此 $\\,E(r) = -\\frac{1}{2 r}\\,$，这在这些归一化单位中是无量纲的。半径 $\\,r_1\\,$ 和 $\\,r_2\\,$ 之间的比能量差为\n$$\n\\Delta E = E(r_2) - E(r_1) = -\\frac{1}{2}\\left(\\frac{1}{r_2} - \\frac{1}{r_1}\\right).\n$$\n当 $\\,r_1 \\approx r_2\\,$ 时，用浮点运算直接计算 $\\,\\Delta E\\,$ 会引发相消误差。在标准一阶舍入模型下，通过两次除法和一次减法计算 $\\,\\Delta E\\,$ 的相对误差满足以下界限\n$$\n\\frac{\\left|\\Delta E_{\\mathrm{comp}} - \\Delta E_{\\mathrm{true}}\\right|}{\\left|\\Delta E_{\\mathrm{true}}\\right|} \\;\\lesssim\\; \\left(\\frac{\\left|\\frac{1}{r_1}\\right| + \\left|\\frac{1}{r_2}\\right|}{\\left|\\frac{1}{r_2} - \\frac{1}{r_1}\\right|} + 1\\right) u,\n$$\n忽略 $\\,u\\,$ 的二阶项。您必须对双精度（binary64）格式，在数值上验证此不等式，其误差因子在 $\\,2\\,$ 以内。\n\n测试套件：\n- 测试用例 1 (binary64)：计算绝对误差 $\\,|u_{\\mathrm{num}} - u_{\\mathrm{th}}|\\,$ 和 $\\,|\\varepsilon_{\\mathrm{num}} - \\varepsilon_{\\mathrm{th}}|\\,$。\n- 测试用例 2 (binary32)：计算绝对误差 $\\,|u_{\\mathrm{num}} - u_{\\mathrm{th}}|\\,$ 和 $\\,|\\varepsilon_{\\mathrm{num}} - \\varepsilon_{\\mathrm{th}}|\\,$。\n- 测试用例 3（相消，中等程度）：$\\,r_1 = 10^8\\,$, $\\,r_2 = 10^8 + 1\\,$，使用 binary64 算术计算 $\\,\\Delta E_{\\mathrm{comp}}\\,$ 并使用高精度参考计算 $\\,\\Delta E_{\\mathrm{true}}\\,$，判断测得的 $\\,\\Delta E\\,$ 相对误差是否小于或等于上述界限的 $\\,2\\,$ 倍。\n- 测试用例 4（相消，极端情况）：$\\,r_1 = 1\\,$, $\\,r_2 = \\operatorname{nextafter}(1, 2)\\,$，执行与测试用例 3 相同的界限检查。\n\n高精度参考：\n使用编程语言标准库中的高精度算术来计算 $\\,\\Delta E_{\\mathrm{true}}\\,$，以确保其自身的浮点舍入误差与待评估的 binary64 误差相比可以忽略不计。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[\\;|u_{64,\\mathrm{num}} - u_{64,\\mathrm{th}}|,\\;|\\varepsilon_{64,\\mathrm{num}} - \\varepsilon_{64,\\mathrm{th}}|,\\;|u_{32,\\mathrm{num}} - u_{32,\\mathrm{th}}|,\\;|\\varepsilon_{32,\\mathrm{num}} - \\varepsilon_{32,\\mathrm{th}}|,\\;\\text{bound\\_ok\\_case3},\\;\\text{bound\\_ok\\_case4}\\;],\n$$\n其中前四个条目是浮点数，后两个条目是布尔值。由于归一化 $\\,G M = 1\\,$，不涉及物理单位；所有量都是无量纲的。程序必须是自包含的，且不需要任何输入。", "solution": "该问题是有效的，因为它在科学上基于 IEEE 754 浮点运算和牛顿力学的原理，问题陈述适定（well-posed）且提供了所有必要信息，其表述也是客观的。问题的核心在于实现和验证与机器精度相关的标准定义和误差界限，这是计算科学中的一个基本主题。所提供的用于计算单位舍入误差 $u$ 的算法中看似存在的差异，是一个刻意设计的特性，旨在测试对浮点行为中那些微妙但关键的细节的理解，特别是“向最接近的值舍入，偶数优先”的规则。\n\n解决方案分为两个主要部分。首先，我们为 binary64 和 binary32 两种格式计算机器精度常数，即单位舍入误差 $u$ 和机器 epsilon $\\varepsilon_{\\mathrm{mach}}$，并将数值计算得到的值与它们的理论对应值进行比较。其次，我们使用 binary64 算术评估灾难性相消在一次实际天体物理计算中的影响，并验证一个标准的一阶误差界限。\n\n**第 1 部分：机器精度常数的计算**\n\n问题指定了两种格式：binary64（双精度），基数 $\\beta=2$，精度 $p=53$；以及 binary32（单精度），基数 $\\beta=2$，精度 $p=24$。\n\n机器 epsilon ($\\varepsilon_{\\mathrm{th}}$) 和单位舍入误差 ($u_{\\mathrm{th}}$) 的理论值由这些参数导出：\n- 机器 epsilon: $\\varepsilon_{\\mathrm{th}} = \\beta^{1-p}$。\n- 单位舍入误差: $u_{\\mathrm{th}} = \\frac{1}{2}\\beta^{1-p} = \\beta^{-p}$ (当 $\\beta=2$ 时)。\n\n对于 binary64，可得：\n- $\\varepsilon_{64,\\mathrm{th}} = 2^{1-53} = 2^{-52} \\approx 2.22 \\times 10^{-16}$。\n- $u_{64,\\mathrm{th}} = 2^{-53} \\approx 1.11 \\times 10^{-16}$。\n\n对于 binary32，可得：\n- $\\varepsilon_{32,\\mathrm{th}} = 2^{1-24} = 2^{-23} \\approx 1.19 \\times 10^{-7}$。\n- $u_{32,\\mathrm{th}} = 2^{-24} \\approx 5.96 \\times 10^{-8}$。\n\n这些值的数值计算遵循两种不同的指定算法。\n\n首先，数值机器 epsilon $\\varepsilon_{\\mathrm{num}}$ 使用函数 $\\operatorname{nextafter}(x, y)$ 计算，该函数给出在 $y$ 方向上紧随 $x$ 的下一个可表示浮点数。根据定义，对于 $1$ 附近的规格化数，$\\varepsilon_{\\mathrm{mach}}$ 是从 $1$ 到下一个更大的可表示数之间的距离。因此，我们计算 $\\varepsilon_{\\mathrm{num}} = \\operatorname{nextafter}(1.0, 2.0) - 1.0$。此计算针对 `numpy.float64` 和 `numpy.float32` 两种类型执行。我们期望 $\\varepsilon_{\\mathrm{num}}$ 精确等于 $\\varepsilon_{\\mathrm{th}}$，因为这就是间隙的定义。\n\n其次，数值单位舍入误差 $u_{\\mathrm{num}}$ 通过一个指定的循环算法计算：从 $\\eta = 1$ 开始，并重复将其折半，直到浮点加法 $1+\\eta$ 的计算结果为 $1$。在此等式出现*之前*的迭代中的 $\\eta$ 值被取为 $u_{\\mathrm{num}}$。在 IEEE 754 的“向最接近的值舍入，偶数优先”规则下，对该算法的审慎分析揭示了一个微妙但重要的细节。当 $\\eta$ 正好是两个连续浮点数之间间距的一半时，和 $1.0 + \\eta$ 会出现舍入平局（rounding tie）。对于数字 $1.0$，下一个可表示的值是 $1.0 + \\varepsilon_{\\mathrm{mach}}$。中点是 $1.0 + \\varepsilon_{\\mathrm{mach}}/2 = 1.0 + u_{\\mathrm{th}}$。由于 $1.0$ 的尾数（即 $1.0...0 \\times 2^0$）是偶数，平局打破规则（tie-breaking rule）规定 $1.0 + u_{\\mathrm{th}}$ 向下舍入到 $1.0$。因此，当 $\\eta$ 被折半到 $u_{\\mathrm{th}}$ 的值时，循环条件 $1.0 + \\eta > 1.0$ 将为假。使该条件为真的最后一个 $\\eta$ 值是 $2 \\cdot u_{\\mathrm{th}} = \\varepsilon_{\\mathrm{mach}}$。因此，如上所述的算法返回的是 $\\varepsilon_{\\mathrm{mach}}$。因此，我们预测数值计算出的值，记为 $u_{\\mathrm{num}}$，将等于 $\\varepsilon_{\\mathrm{mach}}$，而不是 $u_{\\mathrm{th}}$。绝对误差 $|u_{\\mathrm{num}} - u_{\\mathrm{th}}|$ 因此将为 $| \\varepsilon_{\\mathrm{mach}} - u_{\\mathrm{th}} | = | 2u_{\\mathrm{th}} - u_{\\mathrm{th}} | = u_{\\mathrm{th}} \\neq 0$。这种差异不是计算中的缺陷，而是对定义模糊性以及浮点舍入精确行为的一个说明。\n\n**第 2 部分：天体物理相消评估**\n\n问题的第二部分研究了在计算比轨道能变化 $\\Delta E = E(r_2) - E(r_1)$ 时的灾难性相消问题，其中在归一化单位下 $E(r) = -1/(2r)$。直接的计算公式是 $\\Delta E_{\\mathrm{comp}} = -0.5 \\times (1/r_2 - 1/r_1)$。当 $r_1 \\approx r_2$ 时，项 $1/r_1$ 和 $1/r_2$几乎相等，它们的相减导致相对精度的显著损失。\n\n问题提供了一个一阶相对误差界：\n$$ \\frac{|\\Delta E_{\\mathrm{comp}} - \\Delta E_{\\mathrm{true}}|}{|\\Delta E_{\\mathrm{true}}|} \\lesssim \\left(\\frac{|1/r_1| + |1/r_2|}{|1/r_2 - 1/r_1|} + 1\\right) u $$\n其中 $u$ 是单位舍入误差，对于 binary64 算术，我们取 $u_{64,\\mathrm{th}} = 2^{-53}$。乘以 $u$ 的项是减法运算的条件数。对于 $r_1, r_2 > 0$，这可以简化为 $C(r_1, r_2) = \\frac{r_1+r_2}{|r_2-r_1|} + 1$。于是该界限近似为 $C(r_1, r_2) \\cdot u$。我们需要在数值上验证这个界限，其误差因子在 $2$ 以内。\n\n为了执行此验证，我们需要三个量：\n1.  $\\Delta E_{\\mathrm{comp}}$：使用朴素公式和 binary64 (`numpy.float64`) 算术计算。\n2.  $\\Delta E_{\\mathrm{true}}$：一个高精度参考值。使用 Python 的 `decimal` 模块以 $100$ 位数字的精度计算，以确保其自身的舍入误差可以忽略不计。\n3.  误差界限：使用简化的条件数和 $u_{64,\\mathrm{th}}$ 计算。\n\n我们在 binary64 中对两个测试用例执行此检查：\n- 用例 3（中等程度相消）：$r_1 = 10^8$， $r_2 = 10^8 + 1$。此处， $|r_2-r_1|=1$，所以条件数很大， $C \\approx 2 \\times 10^8$。\n- 用例 4（极端相消）：$r_1 = 1$， $r_2 = \\operatorname{nextafter}(1, 2) = 1 + \\varepsilon_{64,\\mathrm{mach}}$。此处， $|r_2-r_1| = \\varepsilon_{64,\\mathrm{mach}}$，是可能的最小间隙。条件数达到最大值，$C \\approx 2 / \\varepsilon_{64,\\mathrm{mach}} \\approx 0.9 \\times 10^{16}$。\n\n对于每个用例，我们计算测得的相对误差 $|\\Delta E_{\\mathrm{comp}} - \\Delta E_{\\mathrm{true}}|/|\\Delta E_{\\mathrm{true}}|$，并检查它是否小于或等于理论界限的 $2$ 倍。\n\n最终输出将由第 1 部分的四个绝对误差值和第 2 部分的两个布尔结果组成，格式化为一个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing machine precision constants and assessing\n    numerical cancellation in an astrophysical context.\n    \"\"\"\n\n    # Part 1: Computation of Machine Precision Constants\n\n    def get_constant_from_loop(dtype):\n        \"\"\"\n        Implements the loop-based algorithm described in the problem to find\n        the smallest power of 2, eta, such that 1.0 + eta  1.0. As explained\n        in the solution, this algorithm computes machine epsilon, not unit roundoff.\n        \n        The problem asks for \"the previous eta value (just before equality holds)\".\n        \"\"\"\n        one = dtype(1.0)\n        two = dtype(2.0)\n        eta = dtype(1.0)\n        eta_prev = eta\n        \n        while True:\n            # Under round-to-nearest, ties-to-even, 1.0 + u rounds to 1.0.\n            # So, the loop terminates when eta becomes u or smaller.\n            if one + eta == one:\n                # The previous eta was the last value for which 1.0+eta  1.0.\n                return eta_prev\n            eta_prev = eta\n            eta = eta / two\n\n    # Constants for binary64 (double precision)\n    p64 = 53\n    beta = 2\n    # Theoretical unit roundoff u = 1/2 * beta^(1-p) = beta^(-p) for beta=2\n    u_th_64 = np.float64(beta**(-p64))\n    # Theoretical machine epsilon eps = beta^(1-p)\n    eps_th_64 = np.float64(beta**(1 - p64))\n    \n    # Numerical computation for binary64\n    u_num_64 = get_constant_from_loop(np.float64) # This will be eps_mach\n    eps_num_64 = np.nextafter(np.float64(1), np.float64(2)) - np.float64(1)\n\n    abs_err_u64 = abs(u_num_64 - u_th_64)\n    abs_err_eps64 = abs(eps_num_64 - eps_th_64)\n\n    # Constants for binary32 (single precision)\n    p32 = 24\n    u_th_32 = np.float32(beta**(-p32))\n    eps_th_32 = np.float32(beta**(1 - p32))\n\n    # Numerical computation for binary32\n    u_num_32 = get_constant_from_loop(np.float32) # This will be eps_mach\n    eps_num_32 = np.nextafter(np.float32(1), np.float32(2)) - np.float32(1)\n    \n    abs_err_u32 = abs(u_num_32 - u_th_32)\n    abs_err_eps32 = abs(eps_num_32 - eps_th_32)\n\n    # Part 2: Astrophysical Cancellation Assessment\n\n    # Set precision for high-precision reference calculation\n    getcontext().prec = 100\n\n    def compute_delta_E_naive(r1, r2, dtype):\n        \"\"\"Computes Delta_E using the naive, cancellation-prone formula.\"\"\"\n        r1_f = dtype(r1)\n        r2_f = dtype(r2)\n        return -dtype(0.5) * (dtype(1.0) / r2_f - dtype(1.0) / r1_f)\n\n    def compute_delta_E_true(r1_str, r2_str):\n        \"\"\"Computes Delta_E using high-precision decimal arithmetic.\"\"\"\n        r1_d = Decimal(r1_str)\n        r2_d = Decimal(r2_str)\n        return -Decimal('0.5') * (Decimal('1') / r2_d - Decimal('1') / r1_d)\n\n    def check_error_bound(r1, r2):\n        \"\"\"\n        Verifies the relative error bound for a given test case.\n        Returns True if the measured error is within 2x the theoretical bound.\n        \"\"\"\n        unit_roundoff_64 = u_th_64\n\n        # 1. Compute Delta_E with standard float64 arithmetic\n        delta_E_comp = compute_delta_E_naive(r1, r2, np.float64)\n\n        # 2. Compute high-precision \"true\" Delta_E\n        # Use string representation to avoid float inaccuracies upon conversion\n        delta_E_true_decimal = compute_delta_E_true(str(r1), str(r2))\n        delta_E_true_float = float(delta_E_true_decimal)\n        \n        # 3. Calculate measured relative error\n        if delta_E_true_float == 0.0: return False # Avoid division by zero\n        measured_rel_error = abs(delta_E_comp - delta_E_true_float) / abs(delta_E_true_float)\n\n        # 4. Calculate theoretical error bound\n        r1_f = np.float64(r1)\n        r2_f = np.float64(r2)\n        # Simplified and stable form of the condition number term\n        condition_term = (r1_f + r2_f) / abs(r2_f - r1_f)\n        error_bound = (condition_term + 1.0) * unit_roundoff_64\n\n        # 5. Check if the measured error is within tolerance of the bound\n        return measured_rel_error = 2.0 * error_bound\n\n    # Test Case 3: Cancellation, moderate\n    r1_c3 = 1e8\n    r2_c3 = 1e8 + 1\n    bound_ok_case3 = check_error_bound(r1_c3, r2_c3)\n\n    # Test Case 4: Cancellation, extreme\n    r1_c4 = 1.0\n    # The next representable float64 after 1.0\n    r2_c4 = np.nextafter(np.float64(1.0), np.float64(2.0))\n    bound_ok_case4 = check_error_bound(r1_c4, r2_c4)\n    \n    # Collate results in the specified order\n    results = [\n        abs_err_u64,\n        abs_err_eps64,\n        abs_err_u32,\n        abs_err_eps32,\n        bound_ok_case3,\n        bound_ok_case4\n    ]\n    \n    # Print the final result in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3510974"}, {"introduction": "精度的损失会导致一些令人惊讶的后果，例如基本代数定律的失效。这项实践 [@problem_id:3511001] 揭示了浮点加法不满足结合律，即 $(a+b)+c \\ne a+(b+c)$，尤其是在处理数量级差异巨大的数字时。你将学习一种强大的技术——以最后一位单位（Units in the Last Place, ULPs）的差异来衡量——在比特级别上精确地量化这种偏差。", "problem": "您将实现并评估电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) 754 binary64 格式下的浮点数非结合性。本练习的基础是浮点算术的有限精度模型：实数运算被舍入到固定格式编码中最接近的可表示值，这意味着诸如结合律之类的代数性质不一定成立。您必须基于 binary64 表示法以及向最接近的值舍入、偶数优先（ties to even）的定义进行推理。\n\n任务规范：\n1. 设 $(a,b,c)$ 是以 IEEE 754 binary64 格式表示的实数。使用 binary64 算术计算两个带括号的和 $(a+b)+c$ 和 $a+(b+c)$，并确定它们是否不同。\n2. 将两个 binary64 结果 $x$ 和 $y$ 之间的精确末位单元距离定义为，在有限 binary64 值（包括非规格化数）的全序中，$x$ 和 $y$ 之间不同可表示 binary64 数的整数计数，当 $x=y$ 时为零。形式上，如果 $r(x)$ 表示 $x$ 在有限 binary64 数全序中的序级，则距离为 $\\Delta_{\\mathrm{ulp}}(x,y) = \\lvert r(x) - r(y) \\rvert$。您必须通过操作 $x$ 和 $y$ 的 $64$ 位编码来精确计算 $\\Delta_{\\mathrm{ulp}}(x,y)$，以获得 $r(\\cdot)$。\n3. 所有算术必须在 IEEE 754 binary64 中执行。不涉及物理单位；输出是无单位的整数。\n\n测试套件：\n- 情况 1（正常路径，大数相消）：$(a,b,c) = (1, 10^{16}, -10^{16})$。\n- 情况 2（边界条件，非规格化数敏感性）：$(a,b,c) = (2^{-1074}, 1, -1)$，其中 $2^{-1074}$ 是最小的正非规格化 binary64 数。\n- 情况 3（极端数量级，无溢出）：$(a,b,c) = (10^{-308}, 10^{308}, -10^{308})$。\n\n对于每种情况，计算：\n- 使用 binary64 算术计算的两个结果 $x_{\\mathrm{L}} = (a+b)+c$ 和 $x_{\\mathrm{R}} = a+(b+c)$。\n- 上述定义的精确整数 $\\Delta_{\\mathrm{ulp}}(x_{\\mathrm{L}}, x_{\\mathrm{R}})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含上述情况的三个 $\\Delta_{\\mathrm{ulp}}$ 值，按顺序排列，形式为用方括号括起来的逗号分隔列表。例如，输出必须具有 $\\texttt{[d_1,d_2,d_3]}$ 的形式，其中每个 $d_i$ 都是一个整数。", "solution": "该问题要求分析 IEEE 754 binary64 标准下浮点加法的非结合性。我们必须为三组特定的输入 $(a, b, c)$ 计算表达式 $(a+b)+c$ 和 $a+(b+c)$ 之间的差异。该差异将通过精确的末位单元 (Unit in the Last Place, ULP) 距离来量化，其形式上定义为两个浮点数结果在有限 binary64 数全序中的整数序级的绝对差。\n\n其基本原理是浮点算术是实数算术的一种近似。由于对两个可表示数进行运算的结果本身可能无法精确表示，因此运算会产生舍入误差。在 binary64 中，一个数由一个符号位、一个 $11$ 位指数和一个 $52$ 位小数（尾数）表示，提供大约 $15$ 到 $17$ 位十进制数字的精度。当数量级差异巨大的数相加时，较小数的信息通常会丢失，这种现象被称为吸收或淹没。这种信息丢失是非结合性的根源。\n\n为了量化两个 binary64 数 $x$ 和 $y$ 之间的差异，我们使用 ULP 距离，$\\Delta_{\\mathrm{ulp}}(x,y) = \\lvert r(x) - r(y) \\rvert$。这里，$r(f)$ 是一个函数，它将一个浮点数 $f$ 映射到一个唯一的整数序级，该序级相对于 IEEE 754 中定义的浮点数全序是单调的。在此排序中，数字从 $-\\infty$ 到 $+\\infty$ 排序，并且值得注意的是，$-0  +0$。\n\n为了实现序级函数 $r(f)$，我们操作浮点数 $f$ 的 $64$ 位整数表示，我们将其表示为 $u$。在 Python 中，可以使用 `struct.pack` 和 `struct.unpack` 获得此表示。$64$ 位模式 $u$ 由一个符号位 $S$（第 $63$ 位）、一个指数 $E$（第 $62$-$52$ 位）和一个尾数 $M$（第 $51$-$0$ 位）组成。\n\n整数序级 $r(u)$ 的构造必须在整个有限浮点数范围内是单调的。\n对于正数（包括 $+0$），其符号位为 $0$，无符号整数表示 $u$ 已经正确排序。因此，对于浮点数 $f \\ge 0$，其 $64$ 位表示 $u$ 的 $S=0$，我们可以将其序级定义为：\n$r(u) = u$，对于 $u  2^{63}$。\n这使得 $r(+0.0) = 0$，$r(\\text{最小正非规格化数}) = 1$，依此类推。\n\n对于负数（包括 $-0$），其符号位为 $1$，标准整数表示的顺序与浮点值的顺序相反（例如，$-1.0$ 的位模式大于 $-2.0$ 的位模式）。为了创建一个单一的单调序列，我们将负浮点数映射到负整数序级。浮点数 $-0.0$ 的序级必须紧邻 $+0.0$ 之下，即 $-1$。下一个浮点数，即绝对值最小的负数（值最大），其序级必须为 $-2$，依此类推。$-0.0$ 的位模式为 $u=2^{63}$。对于任何表示为 $u$ 的负浮点数，其序级可以定义为：\n$r(u) = -((u - 2^{63}) + 1)$，对于 $u \\ge 2^{63}$。\n对于 $u=2^{63}$ ($-0.0$)，这得到 $r = -((2^{63}-2^{63})+1) = -1$。对于 $u=2^{63}+1$（绝对值最小的负非规格化数），这得到 $r = -(((2^{63}+1)-2^{63})+1) = -2$。此映射正确地建立了所需的全序。\n\n有了这个序级函数，我们就可以分析这三种测试情况。\n\n情况 1：$(a,b,c) = (1, 10^{16}, -10^{16})$\n设 $a=1.0$，$b=10^{16}$，$c=-10^{16}$。\n$x_{\\mathrm{L}} = (a+b)+c$。第一个和是 $1.0 + 10^{16}$。$10^{16}$ 的数量级使得其 ULP 大于 $1.0$。具体来说，$\\text{ulp}(10^{16}) \\approx 10^{16} \\cdot 2^{-52} \\approx 2.22$。加法中的 $1.0$ 因舍入而丢失。\n因此，$fl(a+b) = fl(1.0+10^{16}) = 10^{16}$。\n然后，$x_{\\mathrm{L}} = fl(10^{16} + (-10^{16})) = 0.0$。\n$x_{\\mathrm{R}} = a+(b+c)$。括号中的和是 $b+c = 10^{16} + (-10^{16}) = 0.0$。这个相消是精确的。\n然后，$x_{\\mathrm{R}} = fl(1.0 + 0.0) = 1.0$。\nULP 距离是 $\\Delta_{\\mathrm{ulp}}(0.0, 1.0) = \\lvert r(0.0) - r(1.0) \\rvert$。\n$r(0.0) = 0$。$1.0$ 的 binary64 表示是 $u = \\text{0x3FF0000000000000}$。\n$r(1.0) = \\text{0x3FF0000000000000} = 4607182418800017408$。\n$\\Delta_{\\mathrm{ulp},1} = \\lvert 0 - 4607182418800017408 \\rvert = 4607182418800017408$。\n\n情况 2：$(a,b,c) = (2^{-1074}, 1, -1)$\n设 $a=2^{-1074}$，$b=1.0$，$c=-1.0$。值 $a$ 是最小的正非规格化数。\n$x_{\\mathrm{L}} = (a+b)+c$。第一个和是 $2^{-1074} + 1.0$。$a$ 的数量级远小于 $1.0$ 的 ULP ($\\text{ulp}(1.0) = 2^{-52}$)。加法中的 $a$ 因舍入而丢失。\n因此，$fl(a+b) = fl(2^{-1074}+1.0) = 1.0$。\n然后，$x_{\\mathrm{L}} = fl(1.0 + (-1.0)) = 0.0$。\n$x_{\\mathrm{R}} = a+(b+c)$。括号中的和是 $b+c = 1.0 + (-1.0) = 0.0$。\n然后，$x_{\\mathrm{R}} = fl(2^{-1074} + 0.0) = 2^{-1074}$。\nULP 距离是 $\\Delta_{\\mathrm{ulp}}(0.0, 2^{-1074}) = \\lvert r(0.0) - r(2^{-1074}) \\rvert$。\n$r(0.0) = 0$。值 $2^{-1074}$ 是最小的正非规格化数，其表示为 $u=\\text{0x0000000000000001}$。\n$r(2^{-1074}) = 1$。\n$\\Delta_{\\mathrm{ulp},2} = \\lvert 0 - 1 \\rvert = 1$。这是预期的，因为它们在全序中是相邻的。\n\n情况 3：$(a,b,c) = (10^{-308}, 10^{308}, -10^{308})$\n设 $a=10^{-308}$，$b=10^{308}$，$c=-10^{308}$。\n$x_{\\mathrm{L}} = (a+b)+c$。第一个和是 $10^{-308} + 10^{308}$。与 $b$ 的 ULP 相比，$a$ 的值微不足道。加法因吸收而丢失。\n因此，$fl(a+b) = fl(10^{-308} + 10^{308}) = 10^{308}$。\n然后，$x_{\\mathrm{L}} = fl(10^{308} + (-10^{308})) = 0.0$。\n$x_{\\mathrm{R}} = a+(b+c)$。括号中的和是 $b+c = 10^{308} + (-10^{308}) = 0.0$。\n然后，$x_{\\mathrm{R}} = fl(10^{-308} + 0.0) = 10^{-308}$。\nULP 距离是 $\\Delta_{\\mathrm{ulp}}(0.0, 10^{-308}) = \\lvert r(0.0) - r(10^{-308}) \\rvert$。\n$r(0.0) = 0$。值 $10^{-308}$ 是一个非规格化数，因为它小于最小的规格化数 ($2^{-1022} \\approx 2.225 \\times 10^{-308}$)。它的值是 $k \\cdot 2^{-1074}$，其中 $k$ 是某个整数。这个整数 $k$ 就是它的位表示 $u$。\n$k$ 的值通过将 $10^{-308} / 2^{-1074}$ 舍入到最近的整数得到。\n$k = \\text{round}(10^{-308} / (4.94...\\times 10^{-324})) \\approx \\text{round}(2.0240225...\\times 10^{18}) = 2024022533832795894$。\n表示为 $u = 2024022533832795894$。因为该数为正，其序级就是 $u$。\n$r(10^{-308}) = 2024022533832795894$。\n$\\Delta_{\\mathrm{ulp},3} = \\lvert 0 - 2024022533832795894 \\rvert = 2024022533832795894$。\n\n最终结果是通过实现此逻辑计算出的三种情况的 ULP 距离。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport struct\n\ndef get_rank(f: np.float64) - int:\n    \"\"\"\n    Computes a monotonic integer rank for a binary64 floating-point number.\n    This rank corresponds to the position of the number in the total ordering\n    of finite binary64 values, from -infinity to +infinity.\n    \"\"\"\n    if not isinstance(f, np.float64):\n        f = np.float64(f)\n    \n    # Pack the float into 8 bytes (64 bits) and then unpack it as an\n    # unsigned 64-bit integer. This gives the bit-level representation.\n    # 'd' is for double-precision float, 'Q' is for unsigned long long.\n    try:\n        u = struct.unpack('Q', struct.pack('d', f))[0]\n    except (struct.error, OverflowError):\n        # Handle cases where f might be Inf or NaN, though not in test cases\n        # This is for robustness; problem statement guarantees finite values.\n        if np.isinf(f):\n            return (1  63) - 1 if f > 0 else -((1  63) - 1)\n        # For NaN, rank is undefined, but for completeness:\n        return 0\n\n    # The most significant bit (bit 63) is the sign bit.\n    sign_bit_mask = 1  63\n    \n    if (u  sign_bit_mask) == 0:\n        # For positive numbers (including +0.0), the integer representation `u`\n        # is already ordered monotonically with the float value.\n        # r(+0.0) = 0, r(smallest_positive_subnormal) = 1, etc.\n        return int(u)\n    else:\n        # For negative numbers (including -0.0), the integer representation's\n        # order is inverse to the float value's order. To create a single\n        # monotonic sequence across all floats, we map them to negative integers.\n        # The rank of -0.0 (u = 0x800...0) should be -1, just below +0.0 (rank=0).\n        # The rank of -min_subnormal (u = 0x800...1) should be -2, and so on.\n        # This mapping is achieved by r(u) = -( (u - 2^63) + 1 ).\n        return -int((u - sign_bit_mask) + 1)\n\ndef compute_ulp_distance(x: np.float64, y: np.float64) - int:\n    \"\"\"\n    Computes the exact ULP distance between two binary64 floats.\n    The distance is defined as the absolute difference of their integer ranks.\n    \"\"\"\n    rank_x = get_rank(x)\n    rank_y = get_rank(y)\n    return abs(rank_x - rank_y)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Large cancellation\n        (1.0, 1.0e16, -1.0e16),\n        # Case 2: Subnormal sensitivity\n        (2.0**(-1074), 1.0, -1.0),\n        # Case 3: Extreme magnitudes\n        (1.0e-308, 1.0e308, -1.0e308),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Explicitly cast to numpy's float64 to ensure IEEE 754 binary64 arithmetic.\n        a, b, c = (np.float64(v) for v in case)\n        \n        # Compute x_L = (a+b)+c using binary64 arithmetic.\n        x_L = (a + b) + c\n        \n        # Compute x_R = a+(b+c) using binary64 arithmetic.\n        x_R = a + (b + c)\n        \n        # Compute the exact ULP distance between the two results.\n        delta = compute_ulp_distance(x_L, x_R)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3511001"}]}