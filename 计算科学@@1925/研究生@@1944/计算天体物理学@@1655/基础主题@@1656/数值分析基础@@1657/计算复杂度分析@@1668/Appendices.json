{"hands_on_practices": [{"introduction": "N体仿真是天体物理学的基石，而理解其计算成本是设计高效算法的第一步。直接计算浮点运算（FLOPs）数量是复杂度分析最基本的形式。本练习旨在建立一项基本技能：将代码结构（如嵌套循环和条件分支）转化为其计算成本的数学表达式，从而揭示成本如何随问题规模扩展 [@problem_id:3503805]。这种从第一性原理出发的分析，对于识别算法瓶颈和评估优化策略至关重要。", "problem": "考虑 $N$ 个质量为 $\\{m_i\\}_{i=1}^{N}$ 的质点，它们均匀且独立地分布在一个边长为 $L$ 的立方体盒子中（因此体积为 $V = L^{3}$）。相距 $r_{ij}$ 的粒子 $i$ 和 $j$ 之间的成对牛顿引力势能为 $-G m_i m_j / r_{ij}$，其中 $G$ 是引力常数。你实现了一个朴素的显式嵌套循环算法（无邻近列表，无空间索引）来计算总势能，并使用球形截断半径 $r_c$，使得只有满足 $r_{ij} \\le r_c$ 的粒子对才会计入贡献。对于每个满足 $i  j$ 的不同粒子对 $(i,j)$，该算法采用以下步骤：\n\n- 计算坐标差 $\\Delta x = x_j - x_i$，$\\Delta y = y_j - y_i$，$\\Delta z = z_j - z_i$。\n- 构造 $r_{ij}^{2} = \\Delta x^{2} + \\Delta y^{2} + \\Delta z^{2}$。\n- 如果 $r_{ij}^{2} \\le r_c^{2}$，则计算 $r_{ij} = \\sqrt{r_{ij}^{2}}$，计算 $1/r_{ij}$，并将贡献 $-G m_i m_j / r_{ij}$ 累加到总能量的运行总和中。\n\n假设浮点运算（FLOPs）的计数模型如下：每次减法、加法、乘法、除法和平方根运算计为一次 FLOP；比较、分支和内存访问不计数。在循环外预计算 $r_c^{2}$ 不计入其中。假设 $r_c \\ll L$，因此可以忽略边界效应，并假设所有位置都是独立且均匀分布的。\n\n设数密度为 $\\eta = N/V$，并假设当 $N$ 变化时 $\\eta$ 保持不变（即 $L = (N/\\eta)^{1/3}$）。\n\n从这个循环结构和上述基本定义出发，推导出一个关于 $N$、$r_c$ 和 $\\eta$ 的预期总 FLOP 计数的闭式表达式，然后在 $\\eta$ 固定的假设下，将其简化为关于 $N$ 和 $r_c$ 的主导阶渐近形式。将你的最终答案表示为 $N$、$r_c$ 和 $\\eta$ 的单个解析表达式。不需要进行数值计算。", "solution": "问题要求计算使用带有截断半径 $r_c$ 的朴素嵌套循环算法来计算一个 $N$ 粒子系统的总引力势能所需的预期总浮点运算（FLOPs）次数。分析过程遵循一系列逻辑步骤。\n\n首先，我们确定算法的结构。它遍历所有满足 $ij$ 的不同粒子对 $(i,j)$。此类粒子对的总数由二项式系数 $\\binom{N}{2}$ 给出，其值为 $\\frac{N(N-1)}{2}$。\n\n其次，我们确定为每对粒子执行的 FLOP 次数。这些运算分为两部分：对每对粒子都执行的无条件部分，以及仅对满足距离准则 $r_{ij} \\le r_c$ 的粒子对执行的条件部分。\n\n无条件 FLOPs，$F_{\\text{uncond}}$，用于计算距离的平方 $r_{ij}^2$：\n1.  计算坐标差：$\\Delta x = x_j - x_i$，$\\Delta y = y_j - y_i$，$\\Delta z = z_j - z_i$。这需要 3 次减法。\n2.  计算坐标差的平方：$\\Delta x^2$，$\\Delta y^2$，$\\Delta z^2$。这需要 3 次乘法。\n3.  对平方求和：$r_{ij}^2 = \\Delta x^2 + \\Delta y^2 + \\Delta z^2$。这需要 2 次加法。\n每对粒子的总无条件 FLOP 计数为 $F_{\\text{uncond}} = 3 + 3 + 2 = 8$。\n\n条件 FLOPs，$F_{\\text{cond}}$，仅在 $r_{ij}^2 \\le r_c^2$ 时执行：\n1.  计算距离：$r_{ij} = \\sqrt{r_{ij}^2}$。这是 1 次 FLOP（平方根）。\n2.  计算距离的倒数：$1/r_{ij}$。这是 1 次 FLOP（除法）。\n3.  计算能量项 $-G m_i m_j / r_{ij}$。这可以计算为 $(-G \\cdot m_i \\cdot m_j) \\cdot (1/r_{ij})$。这涉及 3 次乘法（假设取负运算是自由操作，或者可以并入乘法中）。\n4.  将能量累加到运行总和中。这是 1 次 FLOP（加法）。\n每个符合条件的粒子对的总条件 FLOP 计数为 $F_{\\text{cond}} = 1 + 1 + 3 + 1 = 6$。\n\n第三，我们确定满足条件 $r_{ij} \\le r_c$ 的粒子对的期望数量。设 $P(r_{ij} \\le r_c)$ 为随机选择的两个粒子 $i$ 和 $j$ 之间的距离小于或等于 $r_c$ 的概率。\n粒子在体积为 $V=L^3$ 的立方体盒子中均匀且独立地分布。假设 $r_c \\ll L$ 使我们能够忽略边界效应。因此，对于任意给定的粒子 $i$，另一个粒子 $j$ 位于以粒子 $i$ 为中心、半径为 $r_c$ 的球体内的概率是该球体体积与盒子总体积之比。该球体的体积为 $V_{\\text{sphere}} = \\frac{4}{3}\\pi r_c^3$。\n因此，概率为：\n$$ P(r_{ij} \\le r_c) = \\frac{V_{\\text{sphere}}}{V} = \\frac{\\frac{4}{3}\\pi r_c^3}{V} $$\n根据期望的线性性质，满足条件的粒子对的期望数量 $\\mathbb{E}[N_{\\text{pairs}, r_c}]$ 是总粒子对数乘以这个概率：\n$$ \\mathbb{E}[N_{\\text{pairs}, r_c}] = \\binom{N}{2} P(r_{ij} \\le r_c) = \\frac{N(N-1)}{2} \\frac{4\\pi r_c^3}{3V} $$\n\n第四，我们构建预期总 FLOP 计数 $\\mathbb{E}[F_{\\text{total}}]$ 的表达式。它是总无条件 FLOPs 和预期总条件 FLOPs 的和。\n$$ \\mathbb{E}[F_{\\text{total}}] = \\binom{N}{2} F_{\\text{uncond}} + \\mathbb{E}[N_{\\text{pairs}, r_c}] F_{\\text{cond}} $$\n代入上面推导出的表达式：\n$$ \\mathbb{E}[F_{\\text{total}}] = \\frac{N(N-1)}{2} \\cdot 8 + \\left( \\frac{N(N-1)}{2} \\frac{4\\pi r_c^3}{3V} \\right) \\cdot 6 $$\n$$ \\mathbb{E}[F_{\\text{total}}] = 4N(N-1) + \\frac{N(N-1)}{2} \\frac{24\\pi r_c^3}{3V} $$\n$$ \\mathbb{E}[F_{\\text{total}}] = 4N(N-1) + N(N-1) \\frac{4\\pi r_c^3}{V} $$\n\n第五，我们使用给定的约束条件，即数密度 $\\eta = N/V$ 保持不变。这意味着 $V = N/\\eta$。将此代入 $\\mathbb{E}[F_{\\text{total}}]$ 的表达式中：\n$$ \\mathbb{E}[F_{\\text{total}}] = 4N(N-1) + N(N-1) \\frac{4\\pi r_c^3}{N/\\eta} $$\n$$ \\mathbb{E}[F_{\\text{total}}] = 4N(N-1) + (N-1) 4\\pi r_c^3 \\eta $$\n这就是预期总 FLOP 计数的精确闭式表达式。\n\n最后，我们将此表达式简化为对于大 $N$ 的主导阶渐近形式。对于大的 $N$，我们可以进行近似 $N-1 \\approx N$ 和 $N(N-1) = N^2 - N \\approx N^2$。该表达式有两个主要部分：粒子对搜索成本和相互作用计算成本。我们分别找出每个部分的主导阶项。\n无条件部分变为：\n$$ 4N(N-1) \\approx 4N^2 $$\n条件部分变为：\n$$ (N-1) 4\\pi r_c^3 \\eta \\approx N \\cdot 4\\pi r_c^3 \\eta $$\n将这些组合起来，就得到了总预期 FLOP 计数的主导阶渐近形式。该形式保留了对所有指定参数（$N$、$r_c$、$\\eta$）的依赖性，并正确地捕捉了算法两个组成部分的标度行为。\n$$ \\mathbb{E}[F_{\\text{total}}]_{\\text{asymptotic}} = 4N^2 + 4\\pi \\eta r_c^3 N $$\n这个表达式清楚地表明，总成本由搜索所有粒子对的 $\\mathcal{O}(N^2)$ 项主导，而在截断半径内计算相互作用的成本则按 $\\mathcal{O}(N)$ 标度。", "answer": "$$\\boxed{4N^{2} + 4\\pi\\eta r_{c}^{3}N}$$", "id": "3503805"}, {"introduction": "现代天体物理学模拟依赖于大规模并行计算，以处理巨大的数据集和复杂的物理过程。然而，简单地增加处理器数量并不总能带来线性的性能提升。Amdahl定律和Gustafson定律为预测并行加速比提供了两种基础但截然不同的理论模型。通过将这两种模型应用于一个典型的并行计算场景，本练习将帮助您理解它们的核心假设，并学会评估在不同问题规模假设下并行化的效率和潜在瓶颈 [@problem_id:3503847]。", "problem": "一个在均匀粒子分布上进行的 Barnes–Hut $N$体问题时间步长分析如下：一个可并行的树遍历占总单节点运行时间的 $f_{p} = 0.95$，而串行的时间积分和开销占 $s = 0.05$。考虑一个由 $p = 64$ 个相同节点组成的并行系统，其树遍历部分具有理想的负载均衡。使用加速比和效率的核心定义，即 $S_{p} = T_{1}/T_{p}$ 和 $E_{p} = S_{p}/p$，而不调用任何预先给定的扩展公式。从这些定义和每个模型对应的假设出发，在两种解释下推导模型预测的强扩展效率：\n- 固定总工作量（Amdahl 的固定规模观点）。\n- 在固定墙上时钟预算下扩展总工作量（Gustafson–Barsis 的扩展加速比观点）。\n计算当 $s = 0.05$ 和 $p = 64$ 时两种效率的值。将两个值都四舍五入到四位有效数字，并以小数形式表示。以 $(\\text{Amdahl}, \\text{Gustafson})$ 的顺序，将最终的数值对报告为行矩阵形式。用一两句话解释，为什么在相同的 $s$ 和 $p$ 值下，两种预测会产生差异。", "solution": "该问题被确认为自洽的，科学上基于并行计算原理，并且是适定的。所有必要的信息和定义都已提供。\n\n设 $T_{1}$ 为单处理器上执行 $N$ 体问题时间步长的总时间。问题陈述，这部分时间中，比例为 $s$ 的部分是纯串行的，比例为 $f_{p}$ 的部分是完全可并行的。给定 $s = 0.05$ 和 $f_{p} = 0.95$。注意 $s + f_{p} = 0.05 + 0.95 = 1$。串行部分花费的时间是 $s \\cdot T_{1}$，可并行部分花费的时间是 $f_{p} \\cdot T_{1}$。处理器数量为 $p=64$。加速比和效率的定义为 $S_{p} = T_{1}/T_{p}$ 和 $E_{p} = S_{p}/p$，其中 $T_{p}$ 是在 $p$ 个处理器上的执行时间。\n\n我们在两个不同的模型下推导效率：Amdahl 的固定规模模型和 Gustafson-Barsis 的可扩展规模模型。\n\n**1. Amdahl 定律（固定总工作量）**\n\n该模型假设要完成的总工作量是固定的，与使用的处理器数量无关。工作的串行部分不能并行化，而可并行部分在假设理想负载均衡的情况下，被平均分配给 $p$ 个处理器。\n\n在 $p$ 个处理器上执行程序的时间 $T_{p}$ 是串行部分的时间与并行化部分的时间之和。\n$$ T_{p} = (\\text{串行时间}) + (\\text{在 } p \\text{ 个处理器上的并行时间}) $$\n$$ T_{p} = s \\cdot T_{1} + \\frac{f_{p} \\cdot T_{1}}{p} $$\n将 $T_{1}$ 因子提出，我们得到：\n$$ T_{p} = T_{1} \\left( s + \\frac{f_{p}}{p} \\right) $$\n现在，我们使用加速比的定义 $S_{p} = T_{1}/T_{p}$：\n$$ S_{p} = \\frac{T_{1}}{T_{1} \\left( s + \\frac{f_{p}}{p} \\right)} = \\frac{1}{s + \\frac{f_{p}}{p}} $$\n使用 $f_{p} = 1 - s$，这就是经典的 Amdahl 定律：\n$$ S_{p} = \\frac{1}{s + \\frac{1-s}{p}} $$\n效率 $E_{p}$ 定义为 $S_{p}/p$：\n$$ E_{p, \\text{Amdahl}} = \\frac{S_{p}}{p} = \\frac{1}{p \\left( s + \\frac{1-s}{p} \\right)} = \\frac{1}{p \\cdot s + (1-s)} $$\n代入给定值 $s = 0.05$ 和 $p = 64$：\n$$ E_{p, \\text{Amdahl}} = \\frac{1}{64 \\cdot 0.05 + (1-0.05)} = \\frac{1}{3.2 + 0.95} = \\frac{1}{4.15} $$\n$$ E_{p, \\text{Amdahl}} \\approx 0.240963855... $$\n四舍五入到四位有效数字，我们得到 $0.2410$。\n\n**2. Gustafson–Barsis 定律（扩展总工作量）**\n\n该模型假设要完成的总工作量随处理器数量扩展，以使墙上时钟时间保持不变。具体来说，工作负载的可并行部分按因子 $p$ 进行扩展。\n\n设在具有 $p$ 个处理器的并行系统上的运行时间归一化为 1 个时间单位。这个时间由串行部分 $s$ 和并行部分 $f_p$ 组成：\n$$ T_{p} = s + f_{p} = 1 $$\n在这个模型中，总工作负载是可扩展的。串行工作量保持为 $s$，但并行工作量增加了因子 $p$。如果这个扩展后的问题在单个处理器上运行，其总工作量将需要时间 $T_{1}'$。\n$$ T_{1}' = (\\text{串行工作量}) + (\\text{扩展后的并行工作量}) = s + p \\cdot f_{p} $$\n根据 Gustafson-Barsis 的观点，扩展加速比是扩展后问题在单处理器上的时间 $T_{1}'$ 与该问题在多处理器上的时间 $T_{p}$ 之比。\n$$ S_{p, \\text{Gustafson}} = \\frac{T_{1}'}{T_{p}} = \\frac{s + p \\cdot f_{p}}{s + f_{p}} = \\frac{s + p \\cdot f_{p}}{1} = s + p \\cdot f_{p} $$\n使用 $f_{p} = 1 - s$，我们也可以将其写为 $s + p(1-s) = p - s(p-1)$。\n效率同样为 $E_{p} = S_{p}/p$：\n$$ E_{p, \\text{Gustafson}} = \\frac{S_{p, \\text{Gustafson}}}{p} = \\frac{s + p \\cdot f_{p}}{p} = \\frac{s}{p} + f_{p} $$\n代入给定值 $s = 0.05$，$f_{p} = 0.95$ 和 $p = 64$：\n$$ E_{p, \\text{Gustafson}} = \\frac{0.05}{64} + 0.95 $$\n$$ E_{p, \\text{Gustafson}} = 0.00078125 + 0.95 = 0.95078125 $$\n四舍五入到四位有效数字，我们得到 $0.9508$。\n\n**解释与协调**\n\n两种预测之所以不同，是因为 Amdahl 定律模拟的是一个固定规模的问题，其中固定时间的串行部分随着处理器数量的增加而成为越来越占主导地位的瓶颈。相反，Gustafson 定律模拟的是一个可扩展规模的问题，其中并行工作负载随之增长，从而减小了固定时间串行部分的相对影响，因此保持了高效率。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.2410  0.9508\n\\end{pmatrix}\n}\n$$", "id": "3503847"}, {"introduction": "一个算法的理论计算复杂度（如 $\\mathcal{O}(N)$ 或 $\\mathcal{O}(N \\log N)$）并不能完全决定其在真实硬件上的运行速度。内存访问速度往往成为现代处理器性能的主要瓶颈。屋顶线（Roofline）模型是一个直观而强大的工具，它将算法的“算术强度”（即每次内存访问所执行的计算量）与硬件的峰值计算性能和内存带宽联系起来。通过这个练习，您将学会如何计算一个算法的算术强度，并利用屋顶线模型来判断其性能是受计算能力限制还是受内存带宽限制，进而指导代码优化方向 [@problem_id:3503871]。", "problem": "一个大小为 $n^{3}$ 的三维均匀笛卡尔网格被用于一个计算天体物理学代码中，以更新一个代表引力势代理的标量场 $\\phi$。由于每个主方向上的非均匀有效耦合，数值更新使用了一个具有不同方向权重的各向异性七点有限差分模板。对于每个内部网格点 $(i,j,k)$，更新以非原地方式计算如下：\n$$\n\\phi_{\\text{new}}(i,j,k) = w_{0}\\,\\phi(i,j,k) + w_{x^{+}}\\,\\phi(i+1,j,k) + w_{x^{-}}\\,\\phi(i-1,j,k) + w_{y^{+}}\\,\\phi(i,j+1,k) + w_{y^{-}}\\,\\phi(i,j-1,k) + w_{z^{+}}\\,\\phi(i,j,k+1) + w_{z^{-}}\\,\\phi(i,j,k-1).\n$$\n所有权重 $w_{\\alpha}$ 在整个网格上是常数，但可以各不相同。算术运算以双精度进行。\n\n考虑单次扫描（对每个内部点进行一次更新）的两种实现：\n\n- 朴素实现：一个直接的三重嵌套循环，具有较差的空间和时间局部性。对于每次内部更新，假设代码为七个输入值从动态随机存取存储器（DRAM）发出七次加载指令，并为输出值发出一次存储指令。存储操作使用写分配策略，因此在写入前会从DRAM分配缓存行，这会产生一次对目标地址的双精度读取，随后是一次双精度写入。\n\n- 分块实现：一个缓存分块版本，将网格切分成大小为 $t^{3}$ 的立方体块，这些块可以装入末级缓存。在一个块内，输入值从缓存中重用，因此每个输入元素为了其自身更新的贡献仅从DRAM中获取一次。输出使用非临时（流式）存储进行写入，从而避免了写分配。通过假设 $n \\gg t$ 来忽略块之间的晕轮交换的贡献，并专注于每个块的内部点。\n\n假设单个图形处理器（GPU）上双精度运算的机器特性如下：峰值浮点性能 $P_{\\text{peak}} = 150 \\times 10^{9}$ 次浮点运算/秒，持续主存带宽 $B_{\\text{w}} = 250 \\times 10^{9}$ 字节/秒。\n\n从操作计数和内存流量的第一性原理出发，确定：\n\n1. 在朴素实现和分块实现中，单次内部更新的运算强度 $I_{\\text{naive}}$ 和 $I_{\\text{blocked}}$（单位为：每字节浮点运算次数）。\n\n2. 在屋顶线模型下，每种情况的可达性能（以每秒十亿次浮点运算表示），以及通过比较运算强度与比率 $P_{\\text{peak}}/B_{\\text{w}}$ 所揭示的相应性能区间（内存受限与计算受限）。\n\n按顺序提供 $I_{\\text{naive}}$、$I_{\\text{blocked}}$、朴素实现的可达性能和分块实现的可达性能的最终数值。将您的答案四舍五入到四位有效数字。以每秒十亿次浮点运算（GFLOP/s）为单位表示可达性能值。", "solution": "该问题陈述已经过验证，被认为是具有科学依据、良构且完整的。它描述了一个标准的计算科学场景，涉及有限差分法和使用屋顶线模型的性能分析，这些都是高性能计算中的既定概念。所有必要的参数和假设都已提供。我现在将进行正式求解。\n\n这个问题的核心在于应用屋顶线模型，该模型为计算核心的可达性能提供了一个上界。性能 $P$（以每秒浮点运算次数FLOP/s衡量）同时受到硬件的峰值浮点性能 $P_{\\text{peak}}$ 和持续主存带宽 $B_{\\text{w}}$ 的限制。其关系由下式给出：\n$$\nP_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\times B_{\\text{w}})\n$$\n其中 $I$ 是算法的运算强度，定义为执行的浮点运算次数与主存和处理器缓存之间移动的数据总字节数之比。\n$$\nI = \\frac{\\text{浮点运算次数 (FLOPs)}}{\\text{内存流量 (字节)}}\n$$\n一个双精度类型的数据值占用 $8$ 字节。\n\n机器特性给出如下：\n- 峰值性能，$P_{\\text{peak}} = 150 \\times 10^{9}$ FLOP/s。\n- 内存带宽，$B_{\\text{w}} = 250 \\times 10^{9}$ 字节/秒。\n\n根据这些值，我们可以计算机器平衡点，或称临界强度 $I_{\\text{critical}}$，这是区分内存受限和计算受限区间的阈值：\n$$\nI_{\\text{critical}} = \\frac{P_{\\text{peak}}}{B_{\\text{w}}} = \\frac{150 \\times 10^{9} \\, \\text{FLOP/s}}{250 \\times 10^{9} \\, \\text{bytes/s}} = \\frac{150}{250} \\frac{\\text{FLOP}}{\\text{byte}} = 0.6 \\, \\text{FLOP/byte}\n$$\n如果一个算法的运算强度 $I  I_{\\text{critical}}$，其性能受内存带宽限制 ($P = I \\times B_{\\text{w}}$)。如果 $I > I_{\\text{critical}}$，其性能受峰值计算速率限制 ($P = P_{\\text{peak}}$)。\n\n我们现在将为单次内部点更新分析每种实现。\n\n**1. 朴素实现的分析**\n\n首先，我们确定一次更新所需的浮点运算次数（FLOPs）。更新规则如下：\n$$\n\\phi_{\\text{new}}(i,j,k) = w_{0}\\,\\phi(i,j,k) + w_{x^{+}}\\,\\phi(i+1,j,k) + w_{x^{-}}\\,\\phi(i-1,j,k) + w_{y^{+}}\\,\\phi(i,j+1,k) + w_{y^{-}}\\,\\phi(i,j-1,k) + w_{z^{+}}\\,\\phi(i,j,k+1) + w_{z^{-}}\\,\\phi(i,j,k-1)\n$$\n该计算涉及 $7$ 次乘法和 $6$ 次加法。因此，每次更新的总FLOPs为 $7 + 6 = 13$ FLOPs。\n\n接下来，我们确定内存流量。对于每次内部点更新：\n- 为输入值 $\\phi$ 有 $7$ 次从DRAM的加载。由于每个值都是双精度值，加载流量为 $7 \\times 8 = 56$ 字节。\n- 为输出值 $\\phi_{\\text{new}}$ 有 $1$ 次存储。存储使用写分配策略，这意味着目标地址的缓存行在被修改和写入之前首先从DRAM读取。这导致 $1$ 次双精度值的读取和 $1$ 次双精度值的写入。因此，存储流量为 $(1+1) \\times 8 = 16$ 字节。\n- 总内存流量 $M_{\\text{naive}}$ 是加载和存储流量之和：$M_{\\text{naive}} = 56 + 16 = 72$ 字节。\n\n朴素实现的运算强度 $I_{\\text{naive}}$ 为：\n$$\nI_{\\text{naive}} = \\frac{13 \\, \\text{FLOPs}}{72 \\, \\text{bytes}} \\approx 0.180556 \\, \\text{FLOP/byte}\n$$\n将此与临界强度比较，我们发现 $I_{\\text{naive}} \\approx 0.1806  I_{\\text{critical}} = 0.6$。因此，朴素实现是**内存受限**的。\n\n可达性能 $P_{\\text{naive}}$ 受内存带宽限制：\n$$\nP_{\\text{naive}} = I_{\\text{naive}} \\times B_{\\text{w}} = \\frac{13}{72} \\times (250 \\times 10^{9}) \\, \\text{FLOP/s} = \\frac{3250}{72} \\times 10^{9} \\, \\text{FLOP/s} \\approx 45.1389 \\times 10^{9} \\, \\text{FLOP/s}\n$$\n以 GFLOP/s 表示并四舍五入到四位有效数字，结果为 $45.14$ GFLOP/s。\n\n**2. 分块实现的分析**\n\n每次更新的FLOPs数量仍为 $13$。\n\n对于分块实现，我们在一个驻留在缓存中的块内实现完美数据重用的假设下分析内存流量。这是对一个大块中所有点的摊销分析，如 $n \\gg t$ 所述。\n- 每个输入元素 $\\phi(i,j,k)$ 从DRAM中加载一次。它为其自身位置及其 $6$ 个邻居的更新做出贡献。在块内所有相关更新中使用完毕后，就不再需要它。摊销到每次更新，这对应于从DRAM进行 $1$ 次读取。\n- 输出值 $\\phi_{\\text{new}}(i,j,k)$ 使用非临时（流式）存储一次性写入DRAM，这种方式绕过缓存，避免了写分配的写时读取开销。摊销到每次更新，这对应于向DRAM进行 $1$ 次写入。\n- 总内存流量 $M_{\\text{blocked}}$ 是 $1$ 次摊销读取和 $1$ 次摊销写入的总和。每次都是一个双精度值。\n- 总内存流量：$M_{\\text{blocked}} = (1 \\times 8) + (1 \\times 8) = 16$ 字节。\n\n分块实现的运算强度 $I_{\\text{blocked}}$ 为：\n$$\nI_{\\text{blocked}} = \\frac{13 \\, \\text{FLOPs}}{16 \\, \\text{bytes}} = 0.8125 \\, \\text{FLOP/byte}\n$$\n将此与临界强度比较，我们发现 $I_{\\text{blocked}} = 0.8125 > I_{\\text{critical}} = 0.6$。因此，分块实现是**计算受限**的。\n\n可达性能 $P_{\\text{blocked}}$ 受硬件的峰值浮点性能限制：\n$$\nP_{\\text{blocked}} = P_{\\text{peak}} = 150 \\times 10^{9} \\, \\text{FLOP/s} = 150 \\, \\text{GFLOP/s}\n$$\n\n**结果总结**\n\n- $I_{\\text{naive}} = \\frac{13}{72} \\approx 0.1806$ FLOP/字节。\n- $I_{\\text{blocked}} = \\frac{13}{16} = 0.8125$ FLOP/字节。\n- $P_{\\text{naive}} \\approx 45.14$ GFLOP/s (内存受限)。\n- $P_{\\text{blocked}} = 150.0$ GFLOP/s (计算受限，写作四位有效数字)。\n\n最终数值答案要求按以下顺序给出：$I_{\\text{naive}}$、$I_{\\text{blocked}}$、$P_{\\text{naive}}$（以GFLOP/s为单位）和 $P_{\\text{blocked}}$（以GFLOP/s为单位），数值均四舍五入到四位有效数字。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.1806  0.8125  45.14  150.0 \\end{pmatrix}}\n$$", "id": "3503871"}]}