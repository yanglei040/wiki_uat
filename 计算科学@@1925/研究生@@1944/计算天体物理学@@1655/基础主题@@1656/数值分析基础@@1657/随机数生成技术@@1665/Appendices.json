{"hands_on_practices": [{"introduction": "在天体物理学的蒙特卡洛模拟中，我们经常需要从离散概率分布中抽样，例如决定恒星反馈的类型。爱丽丝方法 (Alias Method) 是一种优雅且高效的算法，它允许在一次性设置后，以 $O(1)$ 的恒定时间复杂度进行抽样，极大地优于朴素方法。通过 [@problem_id:3531161] 的练习，你将亲手推导并构建一个爱丽丝表，这是编写高性能模拟代码的一项基本技能。", "problem": "在一个计算天体物理学代码的大规模蒙特卡洛（MC）辐射输运模块中，每个恒星粒子在每个时间步都必须根据预先计算的发生率，概率性地触发 $5$ 个离散反馈通道中的一个。设通道由索引 $i \\in \\{1,2,3,4,5\\}$ 枚举，分类概率向量为\n$$\n\\mathbf{p} = \\left(p_{1},p_{2},p_{3},p_{4},p_{5}\\right) = \\left(\\frac{3}{20}, \\frac{4}{20}, \\frac{1}{20}, \\frac{8}{20}, \\frac{4}{20}\\right),\n$$\n该向量例如模拟了 Ia 型超新星、核心坍缩超新星、恒星风爆发、中子星诞生反冲和辐射加热等反馈事件的联合分布。为了避免与时间步相关的偏差，您必须以每次采样 $O(1)$ 的操作复杂度和精确的概率从此离散分布中进行采样。\n\n从离散概率分布的基本定义、全概率定律以及通过均匀分布随机数变换构造随机变量出发，推导并解释用于从具有 $N$ 个类别的离散分布中进行采样的别名方法（也称为 Walker 别名方法），该方法每次采样的时间复杂度为 $O(1)$。然后，对于给定的向量 $\\mathbf{p}$ 和 $N=5$，构建完整的别名表，包括阈值数组 $\\mathbf{q}=\\left(q_{1},\\dots,q_{5}\\right)$ 和别名索引数组 $\\mathbf{a}=\\left(a_{1},\\dots,a_{5}\\right)$。一次采样通过从 $\\{1,2,3,4,5\\}$ 中均匀抽取一个整数列索引 $J$ 和一个均匀分布随机数 $U \\in [0,1)$ 来获得，如果 $U  q_{J}$ 则返回 $J$，否则返回 $a_{J}$。\n\n假设在一次具体的实现中，随机整数为 $J=3$，均匀分布随机数为 $U=\\frac{7}{10}$，请根据您构建的别名表计算别名采样器将返回的单个整数。最终答案仅提供整数通道索引。无需四舍五入，不涉及物理单位。将最终答案表示为一个纯数字。", "solution": "问题陈述经过严格验证，确认有效。该问题具有科学依据，提法明确，客观且自成体系，是计算统计学中一个与指定计算天体物理学领域相关的标准问题。所有必要的数据和定义均已提供且内部一致。各概率之和为 $1$，符合要求。因此，我们可以着手求解。\n\n该问题要求推导和解释用于从离散分类分布中采样的别名方法，为给定的概率向量 $\\mathbf{p}$ 构建具体的别名表，并将得到的采样器应用于给定的随机数实现。\n\n**1. 别名方法的推导与解释**\n\n基本目标是从一个有 $N$ 个类别的离散概率分布中抽取随机样本，其中抽到类别 $i$ 的概率为 $p_i$，且 $\\sum_{i=1}^{N} p_i = 1$。一个简单的方法，如搜索累积分布，每次采样需要 $O(\\log N)$ 或 $O(N)$ 的时间。别名方法在经过一次 $O(N)$ 的初始设置后，能以 $O(1)$ 的时间复杂度完成此任务。\n\n别名方法的核心原理是将原始的非均匀分布转化为 $N$ 个简单的两点分布的均匀混合。我们可以通过想象 $N$ 个宽度为 $1$、高度为 $1$ 的箱子来将其可视化。这些箱子的总面积为 $N$。我们希望在这个结构中表示总概率 $\\sum p_i = 1$。\n\n首先，我们将概率乘以 $N$ 进行缩放：令 $P_i = N p_i$。这些缩放后概率的总和为 $\\sum_{i=1}^{N} P_i = N \\sum_{i=1}^{N} p_i = N$。$P_i$ 的平均值为 $1$。这意味着某些类别的 $P_i  1$（我们可称之为“欠满”），某些类别的 $P_i > 1$（“超满”），还有一些可能 $P_i=1$（“满”）。\n\n别名方法将超满类别的“多余”概率质量重新分配，以填补欠满类别的“不足”空间。经过这次重新分配后，$N$ 个箱子中的每一个都将恰好填满（即包含总概率质量为 $1$），并且每个箱子 $j$ 将最多包含来自两个原始类别的部分：主类别 $j$ 和一个“别名”类别 $a_j$。\n\n如问题中所定义，采样过程如下：\n1.  从 $\\{1, 2, \\ldots, N\\}$ 中均匀抽取一个整数索引 $J$。这以 $1/N$ 的概率选择一个箱子。\n2.  抽取一个均匀分布的随机数 $U \\in [0,1)$。\n3.  如果 $U  q_J$，则结果为 $J$。值 $q_J$ 是阈值概率，代表箱子 $J$ 中被类别 $J$ 占据的部分。\n4.  如果 $U \\ge q_J$，则结果为别名索引 $a_J$。箱子中剩余的部分 $1-q_J$ 被类别 $a_J$ 占据。\n\n采样类别 $k$ 的总概率是所有 $N$ 个箱子中得到 $k$ 的概率之和：\n$$\np_k = \\sum_{j=1}^{N} P(\\text{结果}=k | \\text{选中箱子 } j) \\times P(\\text{选中箱子 } j)\n$$\n由于箱子是均匀选择的，$P(\\text{选中箱子 } j) = 1/N$。条件概率由采样规则给出：\n$$\nP(\\text{结果}=k | \\text{选中箱子 } j) = q_j \\cdot \\mathbb{I}(j=k) + (1-q_j) \\cdot \\mathbb{I}(a_j=k)\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。将此代入前一个方程，得到别名表必须满足的基本关系：\n$$\np_k = \\frac{1}{N} \\sum_{j=1}^{N} \\left[ q_j \\mathbb{I}(j=k) + (1-q_j) \\mathbb{I}(a_j=k) \\right]\n$$\n乘以 $N$，我们得到关于缩放概率的条件：\n$$\nP_k = N p_k = q_k \\mathbb{I}(k \\text{ 在任何箱子中都是主类别}) + \\sum_{j: a_j=k} (1-q_j)\n$$\n\n一个构造阈值数组 $\\mathbf{q}$ 和别名数组 $\\mathbf{a}$ 的高效 $O(N)$ 算法（例如，Vose 算法）按以下步骤进行：\n1.  为索引 $i$ 创建两个工作列表 `Small` 和 `Large`，分别对应 $P_i  1$ 和 $P_i > 1$ 的情况。（$P_i=1$ 的类别可以暂时搁置）。\n2.  当 `Small` 不为空时，从 `Small` 中任意取出一个索引 $l$，并从 `Large` 中任意取出一个索引 $g$。\n3.  填充箱子 $l$：设置阈值 $q_l = P_l$。剩余的空间 $1-P_l$ 由超满类别 $g$ 填充，因此设置别名 $a_l = g$。\n4.  更新类别 $g$ 的概率质量：它已让出 $1-P_l$ 的质量。新的缩放概率为 $P_g' = P_g - (1-P_l) = P_g + P_l - 1$。\n5.  重新分类 $g$：如果 $P_g'  1$，将其移至 `Small` 列表。如果 $P_g' > 1$，它仍留在 `Large` 列表中。如果 $P_g' = 1$，则可以将其从工作列表中移除。\n6.  重复此过程，直到工作列表为空。任何从未在 `Small` 列表中的类别 $k$（即初始 $P_k \\ge 1$）将使其箱子 $k$ 完全由其自身概率填充。对于这些类别，我们设置 $q_k=1$（而 $a_k$ 变得无关紧要，通常设为 $k$）。\n\n这种构造方法确保了欠满的类别永远不会被用作别名，并且概率被精确地守恒。\n\n**2. 别名表的构建**\n\n给定概率向量 $\\mathbf{p} = \\left(\\frac{3}{20}, \\frac{4}{20}, \\frac{1}{20}, \\frac{8}{20}, \\frac{4}{20}\\right)$ 和 $N=5$。\n平均概率为 $1/N = 1/5 = 4/20$。\n\n首先，我们计算缩放后的概率 $P_i = N p_i = 5 p_i$：\n$P_1 = 5 \\times \\frac{3}{20} = \\frac{15}{20} = \\frac{3}{4}$\n$P_2 = 5 \\times \\frac{4}{20} = \\frac{20}{20} = 1$\n$P_3 = 5 \\times \\frac{1}{20} = \\frac{5}{20} = \\frac{1}{4}$\n$P_4 = 5 \\times \\frac{8}{20} = \\frac{40}{20} = 2$\n$P_5 = 5 \\times \\frac{4}{20} = \\frac{20}{20} = 1$\n因此，$\\mathbf{P} = \\left(\\frac{3}{4}, 1, \\frac{1}{4}, 2, 1\\right)$。\n\n我们初始化工作列表：\n- `Small` (其中 $P_i  1$): `{1, 3}` 对应值 $\\{3/4, 1/4\\}$。\n- `Large` (其中 $P_i > 1$): `{4}` 对应值 {$2$}。\n- $P_i=1$ 的类别是 `{2, 5}`。对于这些类别，我们可以立即设置 $q_2=1$ 和 $q_5=1$。它们的别名是无关紧要的；我们设置 $a_2=2$ 和 $a_5=5$。\n\n现在我们执行主循环：\n\n**迭代 1:**\n- 从 `Small` 中取出一个索引：我们选择 $l=3$ ($P_3=1/4$)。\n- 从 `Large` 中取出一个索引：我们必须选择 $g=4$ ($P_4=2$)。\n- 设置箱子 $3$ 的表：$q_3 = P_3 = 1/4$，别名为 $a_3=4$。\n- 更新类别 $4$ 的缩放概率：$P_4' = P_4 - (1-P_3) = 2 - (1 - 1/4) = 2 - 3/4 = 5/4$。\n- 由于 $P_4' = 5/4 > 1$，类别 $4$ 仍留在 `Large` 工作列表中。`Small` 列表现在只包含 `{1}`。\n\n**迭代 2:**\n- 从 `Small` 中取出最后一个索引：$l=1$ ($P_1=3/4$)。\n- 从 `Large` 中取出：我们必须再次选择 $g=4$ (其更新后的概率为 $P_4'=5/4$)。\n- 设置箱子 $1$ 的表：$q_1 = P_1 = 3/4$，别名为 $a_1=4$。\n- 更新类别 $4$ 的缩放概率：$P_4'' = P_4' - (1-P_1) = 5/4 - (1 - 3/4) = 5/4 - 1/4 = 1$。\n- `Small` 列表现在为空，因此循环终止。\n\n**最终确定:**\n剩下的类别 $4$ 现在有一个为 $1$ 的缩放概率。对于这个箱子，我们设置 $q_4=1$ (并且 $a_4=4$)。\n将所有部分结合起来，完整的别名表为：\n- 阈值数组: $\\mathbf{q} = \\left(q_1, q_2, q_3, q_4, q_5 \\right) = \\left(\\frac{3}{4}, 1, \\frac{1}{4}, 1, 1\\right)$\n- 别名数组: $\\mathbf{a} = \\left(a_1, a_2, a_3, a_4, a_5 \\right) = \\left(4, 2, 4, 4, 5\\right)$\n\n**3. 计算采样结果**\n\n问题提供了一次随机抽取的具体实现：\n- 整数列索引: $J=3$。\n- 均匀分布随机数: $U=\\frac{7}{10}$。\n\n我们对选定的箱子 $J=3$ 应用采样规则：\n1. 检索箱子 $3$ 的阈值和别名：$q_3 = 1/4$ 和 $a_3=4$。\n2. 将均匀分布随机数 $U$ 与阈值 $q_3$ 进行比较：\n   $U  q_3$ 是否成立？\n   $\\frac{7}{10}  \\frac{1}{4}$ 是否成立？\n   为了比较，我们可以使用公分母 $20$：$\\frac{14}{20}  \\frac{5}{20}$。此为假。\n3. 由于条件 $U  q_J$ 为假，采样器返回别名索引 $a_J$。\n   对于 $J=3$，别名为 $a_3=4$。\n\n因此，采样器返回的整数通道索引是 $4$。", "answer": "$$\\boxed{4}$$", "id": "3531161"}, {"introduction": "伪随机数生成器是确定性的，其输出的序列可能隐藏着会影响模拟精度的微妙相关性。谱测试 (Spectral Test) 是一种经典的几何方法，用于量化线性同余生成器 (LCG) 在高维空间中的晶格结构。通过 [@problem_id:3531220] 的实践，你将学习如何构建谱测试，并将抽象的几何结果与多维抽样任务中潜在的系统偏差直接联系起来，这对于评估生成器在天体物理模拟中的适用性至关重要。", "problem": "您的任务是构建、实现和分析一个用于宇宙射线传播的蒙特卡洛环境中的线性同余生成器（LCG）的三维谱检验。您的解决方案必须从LCG的核心定义及其输出在连续维度中作为格的几何解释开始，然后推导出一个在维度$d=3$下可计算实现的谱检验形式，并将检验结果与一个和计算天体物理学中采样任务相关的定量偏差代理联系起来。\n\n起点和定义：\n- 一个LCG由$X_{n+1} \\equiv a X_n + c \\pmod m$定义，其中$X_0 \\in \\{0,1,\\dots,m-1\\}$，参数$a, c, m \\in \\mathbb{Z}$，$m \\ge 2$。归一化输出为$U_n = X_n / m \\in [0,1)$。\n- 考虑由连续输出组成的$d$元组序列，这里$d=3$，即$Y_n = (U_n, U_{n+1}, U_{n+2}) \\in [0,1)^3$。\n- 一个经过充分检验的事实是，集合$\\{Y_n\\}$位于$\\mathbb{R}^3$中的有限数量的平行平面上。维度$d=3$的谱检验测量这些相邻平面之间的距离，该距离由对偶格的最短非零向量决定。\n\n待完成的任务：\n1) 从LCG定义和$Y_n$的结构出发，推导刻画所有垂直于包含$\\{Y_n\\}$的平面族的整数向量$w = (w_0,w_1,w_2) \\in \\mathbb{Z}^3$的同余方程，证明它们满足\n$$\nw_0 + a w_1 + a^2 w_2 \\equiv 0 \\pmod m.\n$$\n解释为什么在考虑元组的差分并因此研究谱检验所依赖的格结构时，对于$d \\ge 2$的情况，增量$c$不影响此条件。\n2) 证明同余方程（第1项中）的所有整数解$w$的集合在$\\mathbb{Z}^3$中构成一个满秩格，并仅使用$m$和$a$为其构造一个显式的整数基。一个方便的选择是\n$$\nb_1 = (m,0,0), \\quad b_2 = (-a,1,0), \\quad b_3 = (-a^2,0,1),\n$$\n其中$a^2$可以对$m$取模而不失一般性，因为$b_1$考虑了第一坐标中$m$的倍数。证明任何解$w$都可以写成$w = \\lambda_1 b_1 + \\lambda_2 b_2 + \\lambda_3 b_3$的形式，其中$\\lambda_i \\in \\mathbb{Z}$。\n3) 证明包含点集$\\{Y_n\\}$且正交于一个非零整数向量$w$的相邻平行平面之间的距离是$\\Delta = \\lVert w \\rVert_2^{-1}$，其中$\\lVert \\cdot \\rVert_2$是欧几里得范数。因此，三维谱检验简化为寻找解格中的最短非零向量$w^\\star$，而谱间距为$\\Delta^\\star = \\lVert w^\\star \\rVert_2^{-1}$。\n4) 定义归一化的三维谱品质因数\n$$\nQ = \\frac{\\lVert w^\\star \\rVert_2}{m^{1/3}},\n$$\n它将每单位厚度的实际平面数与三维空间中$m$个点的理想缩放情况进行比较。论证为什么$Q$为1的量级表示可接受的结构，而显著小于1的$Q$表示不良结构（平面间的间隙相对于理想的$m^{-1/3}$尺度过大）。\n5) 为了将检验结果与计算天体物理学中的采样偏差联系起来，考虑线性可观测量$f(y) = \\hat{n} \\cdot y$，其中$\\hat{n} \\in \\mathbb{R}^3$且$\\lVert \\hat{n} \\rVert_2 = 1$，作为对采样任务中各向异性敏感度的代理。证明由于点被限制在间距为$\\Delta^\\star$的平行平面上，这样一个1-利普希茨可观测量的均值的最坏情况绝对偏差由以下公式界定\n$$\nB = \\frac{\\Delta^\\star}{2} = \\frac{1}{2 \\lVert w^\\star \\rVert_2}.\n$$\n解释为什么当连续坐标用于参数化物理量时，这个界是各向异性或相关性引起的偏差的一个有原则的代理，这种偏差会影响蒙特卡洛传播。\n\n算法要求：\n- 构建第2项中的格基，使用标准的格基规约方法（例如，Lenstra–Lenstra–Lovász基规约算法）将其规约为一个近乎正交的基，该方法保持整数格不变，然后在一个有界范围内枚举短的整数组合以恢复精确的最短非零向量$w^\\star$。\n- 为下面的每个测试用例计算$\\lVert w^\\star \\rVert_2$、$Q$和$B$。使用足够精度的浮点算术来可靠地区分这些情况。\n\n测试套件和要求输出：\n- 在所有情况下均使用$d=3$。评估以下三组参数，每组均以$(m,a,c)$的形式给出：\n  - 用例 A（中等模数，乘法）：$(m,a,c) = (65537,3,0)$。\n  - 用例 B（具有已知短关系的小模数）：$(m,a,c) = (13,3,0)$。\n  - 用例 C（与用例 A 相同但为混合型）：$(m,a,c) = (65537,3,12345)$。\n- 对于每个用例，计算并报告浮点数三元组$(\\lVert w^\\star \\rVert_2, Q, B)$，并额外报告用例 A 和用例 C 之间$Q$的绝对差\n$$\n\\Delta Q = \\left| Q_{\\mathrm{A}} - Q_{\\mathrm{C}} \\right|,\n$$\n以经验性地确认谱检验对于$d \\ge 2$时与增量$c$的无关性。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序完全如下且四舍五入到六位小数：\n$[\\lVert w^\\star \\rVert_{2,\\mathrm{A}}, Q_{\\mathrm{A}}, B_{\\mathrm{A}}, \\lVert w^\\star \\rVert_{2,\\mathrm{B}}, Q_{\\mathrm{B}}, B_{\\mathrm{B}}, \\lVert w^\\star \\rVert_{2,\\mathrm{C}}, Q_{\\mathrm{C}}, B_{\\mathrm{C}}, \\Delta Q]$。\n不应打印任何其他文本。所有量都是无量纲的；输出中不要包含任何单位。在概念上讨论角度时，单位是弧度。", "solution": "该问题要求构建、实现和分析线性同余生成器（LCG）的三维谱检验。我们将首先推导该检验的理论基础，然后开发一个算法来计算给定测试用例所需的度量指标。\n\nLCG由递推关系$X_{n+1} \\equiv a X_n + c \\pmod m$定义，产生一个整数序列。通过模数$m$对这些整数进行归一化，得到一个伪随机数序列$U_n = X_n / m \\in [0,1)$。谱检验通过检查连续数字的$d$元组$Y_n = (U_n, U_{n+1}, \\dots, U_{n+d-1})$的几何结构来评估此生成器的质量。对于这个问题，我们关注维度$d=3$。\n\n**1. 格条件的推导**\n\n由LCG生成的点集$\\{Y_n\\}_{n \\ge 0}$并非真正的随机；它表现出规则的格结构。这些点位于有限数量的平行超平面上。在维度$d=3$中，这些是平面。一个平行平面族由一个法向量$w = (w_0, w_1, w_2) \\in \\mathbb{Z}^3$来表征。位于这些平面中任意一个上的点$y \\in \\mathbb{R}^3$都满足$w \\cdot y = \\text{常数}$。为了使集合$\\{Y_n\\}$位于这样的平面上，表达式$w \\cdot Y_n$必须取自一个离散集合。\n\n让我们分析点积$w \\cdot Y_n$：\n$$\nw \\cdot Y_n = w_0 U_n + w_1 U_{n+1} + w_2 U_{n+2} = \\frac{1}{m}(w_0 X_n + w_1 X_{n+1} + w_2 X_{n+2})\n$$\n我们可以使用LCG递推关系将$X_{n+1}$和$X_{n+2}$表示为$X_n$的函数。对于某些整数$k_{n,1}$和$k_{n,2}$，我们有：\n$X_{n+1} = a X_n + c - k_{n,1} m$\n$X_{n+2} = a X_{n+1} + c - k_{n,2} m = a(a X_n + c - k_{n,1} m) + c - k_{n,2} m = a^2 X_n + c(a+1) - (a k_{n,1} + k_{n,2})m$\n\n将这些代入点积（在括号内）得到：\n$$\nw_0 X_n + w_1 X_{n+1} + w_2 X_{n+2} = w_0 X_n + w_1(aX_n+c) + w_2(a^2X_n+c(a+1)) \\pmod m\n$$\n$$\n= (w_0 + a w_1 + a^2 w_2)X_n + c(w_1 + (a+1)w_2) \\pmod m\n$$\n点积的完整表达式为：\n$$\nw \\cdot Y_n = \\frac{1}{m}\\left((w_0 + a w_1 + a^2 w_2)X_n + c(w_1 + (a+1)w_2)\\right) - K_n\n$$\n其中$K_n$是某个整数，捕获了来自模运算的$m$的各种倍数。\n为了使点$\\{Y_n\\}$被限制在少数几个平面上，变化的项$X_n$的系数必须有效地消失。如果该系数是$m$的倍数，就可以实现这一点，这确保了如果LCG具有完整周期，则$(w_0 + a w_1 + a^2 w_2)X_n / m$对所有$X_n$都是整数，或者至少限制了其贡献。基本条件是向量$w$属于生成器格的对偶格，该对偶格由以下同余方程定义：\n$$\nw_0 + a w_1 + a^2 w_2 \\equiv 0 \\pmod m\n$$\n当此同余方程成立时，$w_0 + a w_1 + a^2 w_2 = k_w m$对于某个整数$k_w$成立，点积变为：\n$$\nw \\cdot Y_n = \\frac{1}{m}(k_w m X_n + c(w_1 + (a+1)w_2)) - K_n = k_w X_n - K_n + \\frac{c(w_1 + (a+1)w_2)}{m}\n$$\n由于$k_w, X_n, K_n$是整数， $w \\cdot Y_n$的值被限制在一个形如$\\{ I + \\delta_c \\}$的集合中，其中$I \\in \\mathbb{Z}$，$\\delta_c$是一个依赖于$c$的常数偏移。这证实了平面结构。\n\n加法常数$c$不影响格结构本身，只影响其在空间中的位置（一个仿射平移）。格是由差分向量集合$\\{Y_{n'} - Y_n\\}$来表征的。对于$d \\ge 2$，连续整数向量$(X_{n+1}, \\dots, X_{n+d}) - (X_n, \\dots, X_{n+d-1})$之间的差由一个与$c$无关的递推关系控制。具体来说，$X_{k+1}-X_k \\equiv a(X_k-X_{k-1}) \\pmod m$。谱检验探测的是这个基础向量格的几何形状，这就是为什么对于$d \\ge 2$，$c$的值是无关紧要的。\n\n**2. 解的格及其基**\n\n满足同余方程$w_0 + a w_1 + a^2 w_2 \\equiv 0 \\pmod m$的所有整数向量$w = (w_0, w_1, w_2) \\in \\mathbb{Z}^3$的集合构成一个格。为了证明给定的向量$b_1 = (m,0,0)$、$b_2 = (-a,1,0)$和$b_3 = (-a^2,0,1)$构成该格的一个整数基，我们必须证明两件事：（i）每个基向量都满足同余方程，以及（ii）任何解$w$都可以唯一地表示为它们的整数组合。\n\n(i) 检查基向量：\n对于$b_1$：$m + a(0) + a^2(0) = m \\equiv 0 \\pmod m$。\n对于$b_2$：$-a + a(1) + a^2(0) = 0 \\equiv 0 \\pmod m$。\n对于$b_3$：$-a^2 + a(0) + a^2(1) = 0 \\equiv 0 \\pmod m$。\n所有三个向量都属于解集。\n\n(ii) 证明它们能生成所有解。令$w = (w_0, w_1, w_2)$为满足同余方程的任意整数向量。我们寻找整数$\\lambda_1, \\lambda_2, \\lambda_3$使得$w = \\lambda_1 b_1 + \\lambda_2 b_2 + \\lambda_3 b_3$。\n$$\n(w_0, w_1, w_2) = \\lambda_1(m,0,0) + \\lambda_2(-a,1,0) + \\lambda_3(-a^2,0,1) = (\\lambda_1 m - \\lambda_2 a - \\lambda_3 a^2, \\lambda_2, \\lambda_3)\n$$\n通过比较分量，我们立即发现$\\lambda_2 = w_1$和$\\lambda_3 = w_2$。将这些代入第一个分量方程：\n$w_0 = \\lambda_1 m - w_1 a - w_2 a^2 \\implies \\lambda_1 m = w_0 + w_1 a + w_2 a^2$。\n由于$w$是同余方程的一个解，我们知道$w_0 + w_1 a + w_2 a^2$是$m$的一个整数倍。因此，$\\lambda_1 = (w_0 + w_1 a + w_2 a^2)/m$是一个整数。因此，任何解$w$都可以表示为$\\{b_1, b_2, b_3\\}$的整数组合。基矩阵的行列式为$m$，因此这些向量线性无关，使得该格为满秩格。在$b_3$中使用$a^2 \\pmod m$是有效的，因为第一分量中$m$的任何倍数都可以被$\\lambda_1$的整数变化所吸收。\n\n**3. 平面间的距离**\n\n对于来自解格的给定非零整数法向量$w$，点集$\\{Y_n\\}$被限制在形如$w \\cdot y = C_k$的平面上，其中值$C_k$形成一个等差数列。可以证明，$w \\cdot Y_n$的值的形式为$k + \\delta$，其中$k$为整数，$\\delta$为某个固定偏移量。这意味着这些点位于平面$w \\cdot y = k+\\delta$上。两个相邻平面$w \\cdot y = k+\\delta$和$w \\cdot y = k+1+\\delta$之间的距离是它们之间的最短距离。这个距离是沿着法线方向$\\hat{w} = w/\\lVert w \\rVert_2$的。这些平面上任意两点之间的分离向量在法线方向上的投影是恒定的。距离$\\Delta$由平面方程常数项的差除以向量$w$的范数给出，即$\\Delta = ((k+1+\\delta)-(k+\\delta)) / \\lVert w \\rVert_2 = 1 / \\lVert w \\rVert_2$。\n\n为了找到采样空间中最大的空区域，我们必须找到相邻平面之间可能的最大距离。这对应于选择间距最大的平面族，这反过来意味着找到解格中具有最小可能欧几里得范数$\\lVert w \\rVert_2$的非零向量$w$。这个向量被称为最短非零向量，记为$w^\\star$。相应的最大平面间距是三维谱值$\\Delta^\\star = \\lVert w^\\star \\rVert_2^{-1}$。\n\n**4. 品质因数 $Q$**\n\n品质因数$Q = \\lVert w^\\star \\rVert_2 / m^{1/3}$提供了一个生成器质量的归一化度量。如果$m$个点真正均匀随机地分布在$[0,1)^3$中，相邻点之间的典型距离将按$(1/m)^{1/3} = m^{-1/3}$的比例缩放。谱检验揭示了最大的保证空区域是一个厚度为$\\Delta^\\star = 1/\\lVert w^\\star \\rVert_2$的平板。一个好的生成器应该使这个最大间隙与典型的随机间距处于同一量级，即$\\Delta^\\star \\approx m^{-1/3}$，这意味着$\\lVert w^\\star \\rVert_2 \\approx m^{1/3}$。在这种情况下，$Q \\approx 1$。\n- 如果$Q \\ll 1$，则$\\lVert w^\\star \\rVert_2 \\ll m^{1/3}$，意味着$\\Delta^\\star \\gg m^{-1/3}$。平面相距很远，表明存在一个粗糙的、高度相关的格结构。这对于蒙特卡洛模拟是非常不希望的。\n- 如果$Q \\ge 1$，则格结构是细粒度的，平面间距与理想的随机间距相当或更小。这是一个高质量生成器的特征。\n\n**5. 偏差代理 $B$**\n\n在计算天体物理学中，蒙特卡洛方法用于模拟诸如宇宙射线传播之类的过程。使用来自劣质LCG的相关坐标来表示物理量（例如，动量分量）可能会引入系统误差，即偏差。一个线性可观测量$f(y) = \\hat{n} \\cdot y$，其中$\\lVert \\hat{n} \\rVert_2 = 1$，是物理量对采样各向异性敏感的一个简单代理。这样的函数是1-利普希茨连续的，因为$|f(y_1)-f(y_2)|=|\\hat{n}\\cdot(y_1-y_2)| \\le \\lVert\\hat{n}\\rVert_2 \\lVert y_1-y_2\\rVert_2 = \\lVert y_1-y_2\\rVert_2$。\n\n当其梯度$\\nabla f = \\hat{n}$与最稀疏采样的方向（即法向量$w^\\star$）对齐时，这种可观测量出现最坏情况偏差。LCG的点位于相距$\\Delta^\\star = 1/\\lVert w^\\star \\rVert_2$的平面上。采样最差的区域是两个这样的平面之间的空平板。位于此平板中心的点距离最近的采样平面为$\\Delta^\\star/2$。一个1-利普希茨函数在该点的值与在最近平面上的值之间的误差最多是这个距离。这个未采样区域的“半径”，$B = \\Delta^\\star/2 = 1/(2\\lVert w^\\star \\rVert_2)$，作为局部估计误差的一个有原则的界。虽然对均值偏差的全面分析涉及在整个域上积分，但$B$量化了最坏情况局部偏差的尺度，因此为生成器的格结构所引入的潜在系统偏差提供了一个强大而直观的代理。\n\n**算法实现**\n\n为了计算谱检验度量，我们必须在由基$\\{b_1, b_2, b_3\\}$张成的格中找到最短非零向量$w^\\star$。这是最短向量问题（SVP），在一般情况下是困难的，但在像$d=3$这样的低维空间中是可行的。策略是首先使用格基规约算法，如Lenstra–Lenstra–Lovász（LLL）算法，将高度倾斜的初始基转换为由短的、近乎正交的向量构成的新基。格中的最短向量很可能是这些新基向量之一或它们的非常短的整数组合。我们实现了$d=3$的LLL算法，然后在一个小的整数系数框内进行搜索，以找到精确的$w^\\star$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy  # Imported to adhere to problem spec, although not directly used.\n\ndef lll_3d(basis, delta=0.75):\n    \"\"\"\n    Performs LLL lattice basis reduction for a 3D basis.\n    \n    Args:\n        basis (list of lists or np.ndarray): The initial basis vectors (as rows).\n        delta (float): The LLL reduction parameter, typically in (0.25, 1).\n    \n    Returns:\n        np.ndarray: The LLL-reduced basis.\n    \"\"\"\n    B = np.array(basis, dtype=np.int64)\n    \n    while True:\n        # Gram-Schmidt Orthogonalization\n        B_star = np.zeros_like(B, dtype=np.float64)\n        mu = np.zeros((3, 3), dtype=np.float64)\n        \n        B_star[0] = B[0]\n        for i in range(1, 3):\n            B_star[i] = B[i].astype(np.float64)\n            for j in range(i):\n                # Ensure dot products are computed with high precision floats\n                dot_bi_bstarj = np.dot(B[i].astype(np.float64), B_star[j])\n                dot_bstarj_bstarj = np.dot(B_star[j], B_star[j])\n                if dot_bstarj_bstarj == 0:\n                    mu[i, j] = 0\n                else:\n                    mu[i, j] = dot_bi_bstarj / dot_bstarj_bstarj\n\n                B_star[i] -= mu[i, j] * B_star[j]\n\n        # Size Reduction step\n        reduced_in_pass = False\n        for i in range(1, 3):\n            for j in range(i - 1, -1, -1):\n                if abs(mu[i, j]) > 0.5:\n                    B[i] -= np.round(mu[i, j]).astype(np.int64) * B[j]\n                    reduced_in_pass = True\n        \n        if reduced_in_pass:\n            continue\n\n        # Lovasz Condition and Swapping step\n        swapped = False\n        for i in range(1, 3):\n            norm_b_star_i_sq = np.dot(B_star[i], B_star[i])\n            norm_b_star_prev_sq = np.dot(B_star[i-1], B_star[i-1])\n\n            if norm_b_star_i_sq  (delta - mu[i, i-1]**2) * norm_b_star_prev_sq:\n                B[[i, i-1]] = B[[i-1, i]]\n                swapped = True\n                break # Restart LLL\n        \n        if not swapped:\n            break # LLL terminated\n            \n    return B\n\ndef find_shortest_vector(basis, search_range=5):\n    \"\"\"Finds the shortest non-zero vector in a lattice given a basis.\"\"\"\n    \n    # Use LLL to get a basis of shorter vectors\n    reduced_basis = lll_3d(basis)\n    \n    # The shortest vector is often one of the reduced basis vectors\n    min_sq_norm = float('inf')\n    shortest_vec = None\n    \n    for vec in reduced_basis:\n        sq_norm = np.dot(vec, vec)\n        if 0  sq_norm  min_sq_norm:\n            min_sq_norm = sq_norm\n            shortest_vec = vec\n\n    # Enumerate short integer combinations of the reduced basis vectors\n    b1, b2, b3 = reduced_basis\n    for c1 in range(-search_range, search_range + 1):\n        for c2 in range(-search_range, search_range + 1):\n            for c3 in range(-search_range, search_range + 1):\n                if c1 == 0 and c2 == 0 and c3 == 0:\n                    continue\n                \n                vec = c1 * b1 + c2 * b2 + c3 * b3\n                sq_norm = np.dot(vec, vec)\n                \n                if 0  sq_norm  min_sq_norm:\n                    min_sq_norm = sq_norm\n                    shortest_vec = vec\n                    \n    return shortest_vec\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, a, c)\n        (65537, 3, 0),        # Case A\n        (13, 3, 0),          # Case B\n        (65537, 3, 12345),    # Case C\n    ]\n\n    results = []\n    q_values = []\n\n    for m, a, c in test_cases:\n        # Construct the lattice basis for vectors w = (w0, w1, w2) satisfying\n        # w0 + a*w1 + a^2*w2 === 0 (mod m)\n        # We use a^2 % m to keep initial numbers smaller, which is valid.\n        a2_mod_m = (a * a) % m\n        basis = [\n            [m, 0, 0],\n            [-a, 1, 0],\n            [-a2_mod_m, 0, 1]\n        ]\n        \n        # Find the shortest non-zero vector in this lattice\n        w_star = find_shortest_vector(np.array(basis, dtype=np.int64))\n        \n        # Calculate the required metrics\n        norm_w_star = np.linalg.norm(w_star)\n        q_metric = norm_w_star / (m**(1/3.0))\n        b_metric = 1.0 / (2.0 * norm_w_star)\n        \n        results.extend([norm_w_star, q_metric, b_metric])\n        q_values.append(q_metric)\n\n    # Calculate the difference in Q between Case A and Case C\n    delta_q = abs(q_values[0] - q_values[2])\n    results.append(delta_q)\n    \n    # Format the final output string with results rounded to six decimal places.\n    output_str = f\"[{','.join(['{:.6f}'.format(x) for x in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3531220"}, {"introduction": "理论测试固然重要，但检验随机数生成器质量的最终标准是其在具体科学问题中的表现。本练习 [@problem_id:3531195] 采用了一种与应用紧密结合的方法：通过模拟宇宙学中常见的各向同性高斯随机场，并测量其功率谱。你将看到，一个有缺陷的生成器如何直接导致功率谱的统计偏差，从而产生非物理性的结果，这直观地展示了在实际研究中验证随机数质量的必要性。", "problem": "要求您在计算天体物理学的背景下，为随机数生成器实现一个谱均匀性测试。目标是使用均匀分布的随机数在 $k$ 空间中对各向同性高斯随机场的复傅里叶模式进行采样，并通过壳层平均功率谱值的偏差来量化均匀性。程序必须是一个完整的、可运行的程序，无需用户输入即可产生所要求的输出。\n\n基本原理：\n- 均匀、各向同性的高斯随机场模型在计算天体物理学中被广泛使用。傅里叶空间中的场由功率谱 $P(k)$ 来表征，该谱仅依赖于波数向量的模 $k = \\lVert \\mathbf{k} \\rVert$。\n- 对于高斯随机场，每个独立的复傅里叶模式 $a_{\\mathbf{k}}$ 的实部和虚部是独立的、均值为零、方差为 $P(k)/2$ 的高斯随机变量。因此，其振幅的平方 $X_{\\mathbf{k}} = \\lvert a_{\\mathbf{k}} \\rvert^2$ 服从指数分布，其均值为 $P(k)$，方差为 $P(k)^2$。\n- 区间 $(0,1)$ 上的均匀分布随机数通过 Box–Muller 方法转换为高斯分布随机数。Box–Muller 变换中使用的角度必须是弧度。\n\n定义与目标计算：\n1. 设离散的二维傅里叶网格由 $(i,j)$ 索引，大小为 $N_x$ 和 $N_y$。使用离散傅里叶频率定义波数，使得 $k_x \\in \\{-\\lfloor N_x/2 \\rfloor, \\ldots, \\lfloor N_x/2 \\rfloor - 1\\}$，对 $k_y$ 也类似。定义 $k = \\sqrt{k_x^2 + k_y^2}$。\n2. 通过对 $k$ 进行整数分箱来定义径向壳层：$s = \\lfloor k + 0.5 \\rfloor$。排除 $s = 0$ 壳层（零频模式）。\n3. 对于每个壳层 $s$，令 $\\mathcal{K}_s$ 为波数大小落入壳层 $s$ 的索引 $(i,j)$ 的集合，并令 $K_s = \\lvert \\mathcal{K}_s \\rvert$ 为壳层 $s$ 中的模式数量。\n4. 对每个测试用例，通过 Box–Muller 方法从均匀分布随机数生成 $M$ 个独立的复傅里叶系数 $a_{\\mathbf{k}}$ 系综，其中 $\\operatorname{Re}(a_{\\mathbf{k}})$ 和 $\\operatorname{Im}(a_{\\mathbf{k}})$ 从 $\\mathcal{N}(0, P(k)/2)$ 中采样。\n5. 对每个壳层 $s$，计算该壳层中所有系综和模式的振幅平方的聚合样本均值：\n   $$\\widehat{P}_s = \\frac{1}{M K_s} \\sum_{m=1}^{M} \\sum_{(i,j) \\in \\mathcal{K}_s} X_{\\mathbf{k},m}, \\quad \\text{其中 } X_{\\mathbf{k},m} = \\lvert a_{\\mathbf{k},m} \\rvert^2.$$\n6. 壳层均值的期望为\n   $$\\mathbb{E}[\\widehat{P}_s] = \\frac{1}{K_s} \\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j}).$$\n   由于 $X_{\\mathbf{k}}$ 服从指数分布，方差为 $P(k)^2$，且样本是独立的，因此 $\\widehat{P}_s$ 的方差为\n   $$\\operatorname{Var}(\\widehat{P}_s) = \\frac{\\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j})^2}{M K_s^2},$$\n   相应的标准差为\n   $$\\sigma_s = \\sqrt{\\frac{\\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j})^2}{M K_s^2}}.$$\n7. 定义壳层归一化偏差（$z$-score）：\n   $$z_s = \\frac{\\lvert \\widehat{P}_s - \\mathbb{E}[\\widehat{P}_s] \\rvert}{\\sigma_s}.$$\n8. 定义一个测试阈值 $T$，如果最大壳层偏差满足 $\\max_s z_s \\le T$，则宣布该测试用例通过，否则为失败。\n\n实现要求：\n- 仅使用均匀分布随机数通过 Box–Muller 变换生成高斯分布随机数。角度使用弧度。\n- 实现多种均匀随机数生成器：\n  - 一个基于 64 位置换同余生成器（Permuted Congruential Generator 64-bit, PCG64）的高质量生成器。\n  - 一个特意设计的病态生成器，它在 $(0,1)$ 区间的两个值之间交替，从而违反了均匀性。\n- 以无量纲形式实现功率谱 $P(k)$。您必须至少处理以下情况：\n  - 白谱：$P(k) = P_0$，对于 $k > 0$。\n  - 幂律谱：$P(k) = P_0 \\left( \\frac{k}{k_0} \\right)^{n}$，对于 $k > 0$，具有指定的指数 $n$ 和尺度 $k_0$。\n\n单位：\n- 所有量均为无量纲。任何三角运算中的角度都必须是弧度。\n\n测试套件：\n您必须实现以下测试用例。每个用例指定了 $(\\text{rng\\_type}, N_x, N_y, M, P_0, n, k_0, T)$，其中 $\\text{rng\\_type} \\in \\{\\text{\"pcg\"}, \\text{\"alt\"}\\}$ 用于选择随机数生成器。\n\n- 用例1（正常路径）：$(\\text{\"pcg\"}, 64, 64, 60, 1.0, 0, 1.0, 3.5)$，白谱。\n- 用例2（覆盖幂律谱）：$(\\text{\"pcg\"}, 32, 32, 20, 1.0, -2.0, 6.0, 3.5)$，幂律谱 $P(k) = P_0 (k/k_0)^n$，对于 $k > 0$。\n- 用例3（病态RNG）：$(\\text{\"alt\"}, 64, 64, 60, 1.0, 0, 1.0, 3.5)$，白谱。\n- 用例4（边界：小样本量）：$(\\text{\"pcg\"}, 16, 16, 8, 1.0, 0, 1.0, 4.0)$，白谱。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果都是一个布尔值，指示相应的测试用例是通过（True）还是失败（False）。", "solution": "该问题陈述经评估有效。它在科学上基于统计场论和计算天体物理学的原理，特别是关于高斯随机场及其傅里叶空间表示的性质。该问题是适定的，所有必要的定义、常数和计算步骤都得到了充分的说明。它是客观、完整且计算上可行的。\n\n解决方案涉及实现一个统计测试，以验证随机数生成器（RNG）的质量。该测试利用了模拟的二维均匀各向同性高斯随机场的统计特性。核心原理是，如果来自RNG的底层均匀分布随机数是真正均匀的，那么从模拟中导出的物理量将在一定的统计容差内符合其理论期望。RNG中均匀性的偏差将传播到模拟场中的系统性偏差，而本测试正是为了检测这种偏差而设计的。\n\n对于提供的每个测试用例，解决方案按以下步骤进行：\n\n1.  **参数初始化**：对每个测试用例，我们定义网格维度（$N_x$，$N_y$）、系综数量（$M$）、功率谱参数（$P_0$，$n$，$k_0$）、测试阈值（$T$）以及随机数生成器的类型（`rng_type`）。\n\n2.  **波数网格生成**：构建一个二维离散傅里叶网格。根据离散傅里叶变换的约定，定义以零为中心的波数分量 $k_x$ 和 $k_y$。具体来说，对于大小为 $N$ 的网格，波数是范围 $\\{-\\lfloor N/2 \\rfloor, \\ldots, \\lfloor N/2 \\rfloor - 1\\}$ 内的整数。根据这些分量，计算网格上每个点的波矢量模 $k = \\sqrt{k_x^2 + k_y^2}$。\n\n3.  **功率谱模型**：实现一个函数来计算理论功率谱 $P(k)$。该函数支持白谱（$k > 0$ 时 $P(k) = P_0$）和幂律谱（$k > 0$ 时 $P(k) = P_0 (k/k_0)^n$）。对于 $k=0$ 模式，功率定义为 $P(0) = 0$，这与标准的宇宙学假设以及问题明确关注 $k > 0$ 的情况相符。\n\n4.  **壳层分箱与理论统计**：根据波数模的整数值 $s = \\lfloor k + 0.5 \\rfloor$ 将 k 空间划分为径向壳层。对应于直流分量的 $s=0$ 壳层被排除在分析之外。对于其余的每个壳层 $s$：\n    *   统计离散傅里叶模式的数量 $K_s$。\n    *   计算壳层平均功率的期望值 $\\mathbb{E}[\\widehat{P}_s]$，即该壳层内所有模式的 $P(k)$ 的平均值：\n        $$ \\mathbb{E}[\\widehat{P}_s] = \\frac{1}{K_s} \\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j}) $$\n    *   计算估计量的理论标准差 $\\sigma_s$。这依赖于一个事实：模式的振幅平方 $X_{\\mathbf{k}} = |a_{\\mathbf{k}}|^2$ 是一个指数分布的随机变量，其方差为 $P(k)^2$。因此，壳层平均功率估计量 $\\widehat{P}_s$ 的方差为：\n        $$ \\operatorname{Var}(\\widehat{P}_s) = \\frac{\\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j})^2}{M K_s^2} $$\n        标准差为 $\\sigma_s = \\sqrt{\\operatorname{Var}(\\widehat{P}_s)}$。没有模式的壳层（$K_s=0$）被排除在后续计算之外。\n\n5.  **随机场模拟**：\n    *   根据 `rng_type` 参数初始化一个合适的 RNG。对于 `\"pcg\"`，使用一个带种子的 `numpy.random.PCG64` 生成器以保证可复现性。对于 `\"alt\"`，实现一个自定义生成器，以产生一个病态的交替值序列（例如，$0.25$ 和 $0.75$）。\n    *   对 $M$ 个系综中的每一个，生成一个复傅里叶空间场 $a_{\\mathbf{k}}$。这通过首先在区间 $(0,1)$ 上生成均匀分布随机数网格 $u_1$ 和 $u_2$ 来完成。为避免 $\\log(0)$ 的数值问题，任何生成的恰好为 $0$ 的 $u_1$ 值都会被替换为一个小的正数。\n    *   将 Box-Muller 变换应用于 $(u_1, u_2)$ 以产生两个独立的标准正态分布随机数网格 $g_1$ 和 $g_2$。\n        $$ g_1 = \\sqrt{-2 \\ln u_1} \\cos(2 \\pi u_2) $$\n        $$ g_2 = \\sqrt{-2 \\ln u_1} \\sin(2 \\pi u_2) $$\n    *   然后，通过缩放这些标准正态随机数，使其具有所需的方差 $P(k)/2$，来构建复傅里叶振幅 $a_{\\mathbf{k}}$ 的实部和虚部：\n        $$ \\operatorname{Re}(a_{\\mathbf{k}}) = g_1 \\sqrt{P(k)/2} $$\n        $$ \\operatorname{Im}(a_{\\mathbf{k}}) = g_2 \\sqrt{P(k)/2} $$\n    *   对当前系综 $m$，计算每个模式的振幅平方 $X_{\\mathbf{k},m} = |a_{\\mathbf{k},m}|^2 = (\\operatorname{Re}(a_{\\mathbf{k},m}))^2 + (\\operatorname{Im}(a_{\\mathbf{k},m}))^2$。\n\n6.  **统计分析与判定**：\n    *   聚合模拟的振幅平方 $X_{\\mathbf{k},m}$。具体来说，将它们在所有 $M$ 个系综上求和，并分箱到用于理论值的相同径向壳层 $s$ 中。\n    *   计算模拟的壳层平均功率 $\\widehat{P}_s$：\n        $$ \\widehat{P}_s = \\frac{1}{M K_s} \\sum_{m=1}^{M} \\sum_{(i,j) \\in \\mathcal{K}_s} X_{\\mathbf{k},m} $$\n    *   对每个壳层，计算归一化偏差（z-score）：\n        $$ z_s = \\frac{|\\widehat{P}_s - \\mathbb{E}[\\widehat{P}_s]|}{\\sigma_s} $$\n    *   找出所有壳层中的最大偏差 $\\max_s z_s$。\n    *   如果此最大偏差小于或等于指定的阈值 $T$（即 $\\max_s z_s \\leq T$），则宣布该测试用例通过。否则，失败。\n\n对问题陈述中指定的四个测试用例中的每一个都执行此完整过程。实现过程使用 `numpy` 进行了完全向量化以提高效率，在可能的情况下避免了对网格点或系综的显式循环。最终输出是一个布尔值列表，指示每个用例的通过/失败结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted as per the instructions.\n\ndef solve():\n    \"\"\"\n    Main function to run the spectral uniformity tests and print the results.\n    \"\"\"\n\n    class AlternatingRNG:\n        \"\"\"\n        A pathological RNG that alternates between two fixed values.\n        This class mimics the interface of a numpy.random.Generator.\n        \"\"\"\n        def __init__(self, val1=0.25, val2=0.75):\n            self._vals = np.array([val1, val2])\n            self._state = 0\n\n        def random(self, size=None):\n            if size is None:\n                val = self._vals[self._state]\n                self._state = (self._state + 1) % 2\n                return val\n\n            n_elements = int(np.prod(size))\n            start_index = self._state\n            indices = (np.arange(n_elements) + start_index) % 2\n            output = self._vals[indices]\n            self._state = (start_index + n_elements) % 2\n            return output.reshape(size)\n\n    def power_spectrum(k, P0, n, k0):\n        \"\"\"\n        Calculates the power spectrum P(k).\n        \"\"\"\n        pk = np.zeros_like(k, dtype=float)\n        # The k=0 mode has P(0)=0. The problem states the formula is for k>0.\n        non_zero_k_mask = k > 0\n        k_pos = k[non_zero_k_mask]\n        \n        # White spectrum is a special case of power-law with n=0\n        if n == 0.0:\n            pk[non_zero_k_mask] = P0\n        else: # Power-law spectrum\n            pk[non_zero_k_mask] = P0 * (k_pos / k0)**n\n            \n        return pk\n\n    def run_test_case(rng_type, Nx, Ny, M, P0, n, k0, T):\n        \"\"\"\n        Executes a single test case for the spectral uniformity test.\n        \"\"\"\n        # 1. RNG Setup\n        if rng_type == \"pcg\":\n            # Use a fixed seed for reproducibility.\n            rng = np.random.Generator(np.random.PCG64(seed=12345))\n        elif rng_type == \"alt\":\n            rng = AlternatingRNG(val1=0.25, val2=0.75)\n        else:\n            raise ValueError(\"Unknown rng_type\")\n\n        # 2. Grid and k-space Setup\n        kx_int = np.fft.fftshift(np.fft.fftfreq(Nx) * Nx)\n        ky_int = np.fft.fftshift(np.fft.fftfreq(Ny) * Ny)\n        kx_grid, ky_grid = np.meshgrid(kx_int, ky_int)\n        \n        # In meshgrid with 'ij' indexing, first index is row (y), second is col (x)\n        # So we swap them to match physical (x, y) coordinates\n        k_grid = np.sqrt(ky_grid**2 + kx_grid**2)\n\n        # 3. Power Spectrum Model\n        pk_grid = power_spectrum(k_grid, P0, n, k0)\n\n        # 4. Shell Binning and Theoretical Statistics\n        s_grid = np.floor(k_grid + 0.5).astype(int)\n        max_s_val = np.max(s_grid)\n        \n        # Use bincount for efficient aggregation into shells\n        # We need counts up to max_s_val, so length must be max_s_val + 1\n        s_ravel = s_grid.ravel()\n        Ks_all = np.bincount(s_ravel, minlength=max_s_val + 1)\n        \n        sum_pk_s = np.bincount(s_ravel, weights=pk_grid.ravel(), minlength=max_s_val + 1)\n        sum_pk_sq_s = np.bincount(s_ravel, weights=(pk_grid**2).ravel(), minlength=max_s_val + 1)\n        \n        # Exclude shell s=0 and any shells with no modes\n        valid_shells_mask = (np.arange(max_s_val + 1) > 0)  (Ks_all > 0)\n        \n        Ks = Ks_all[valid_shells_mask]\n        \n        # Theoretical expectations\n        E_Phat_s = sum_pk_s[valid_shells_mask] / Ks\n        Var_Phat_s = sum_pk_sq_s[valid_shells_mask] / (M * Ks**2)\n        sigma_s = np.sqrt(Var_Phat_s)\n\n        # 5. Random Field Simulation (fully vectorized over ensembles)\n        sim_size = (M, Ny, Nx)\n        \n        # Generate uniform deviates for Box-Muller\n        u1 = rng.random(size=sim_size)\n        \n        # Handle u1=0 to avoid log(0) = -inf\n        u1[u1 == 0.0] = np.finfo(float).eps\n        \n        u2 = rng.random(size=sim_size)\n        \n        # Box-Muller transform\n        mag = np.sqrt(-2.0 * np.log(u1))\n        g1 = mag * np.cos(2.0 * np.pi * u2)\n        g2 = mag * np.sin(2.0 * np.pi * u2)\n        \n        # Scale to get Re(a_k) and Im(a_k)\n        # pk_grid must be broadcast to the simulation shape\n        sqrt_pk_half = np.sqrt(pk_grid / 2.0)\n        \n        re_ak = g1 * sqrt_pk_half\n        im_ak = g2 * sqrt_pk_half\n        \n        # Calculate squared amplitude X_k = |a_k|^2\n        Xk_m = re_ak**2 + im_ak**2\n        \n        # 6. Statistical Analysis and Verdict\n        # Sum over ensembles\n        Xk_total_ensembles = np.sum(Xk_m, axis=0) # Shape (Ny, Nx)\n        \n        # Bin into shells\n        total_Xk_s = np.bincount(s_ravel, weights=Xk_total_ensembles.ravel(), minlength=max_s_val + 1)\n        \n        # Calculate simulated shell-averaged power\n        Phat_s = total_Xk_s[valid_shells_mask] / (M * Ks)\n        \n        # Calculate z-scores\n        z_s = np.abs(Phat_s - E_Phat_s) / sigma_s\n        \n        # Some shells might have sigma_s = 0 if P(k)=0 for all k in that shell.\n        # This can happen if P(k)=0 for k>k_max for example.\n        # In that case, P_hat_s should also be 0, resulting in 0/0.\n        # We define 0/0 as 0 for the z-score.\n        z_s[sigma_s == 0.0] = 0.0\n        \n        max_z = np.max(z_s)\n        \n        return max_z = T\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (rng_type, Nx, Ny, M, P0, n, k0, T)\n        (\"pcg\", 64, 64, 60, 1.0, 0.0, 1.0, 3.5),\n        (\"pcg\", 32, 32, 20, 1.0, -2.0, 6.0, 3.5),\n        (\"alt\", 64, 64, 60, 1.0, 0.0, 1.0, 3.5),\n        (\"pcg\", 16, 16, 8, 1.0, 0.0, 1.0, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3531195"}]}