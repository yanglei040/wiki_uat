{"hands_on_practices": [{"introduction": "为了打下坚实的基础，我们从一个经典问题开始：分析一维离散拉普拉斯算子的本征模。这个练习将帮助你深入理解空间离散化如何引出一个矩阵本征值问题，其解近似于连续系统众所周知（且解析可知）的正弦模。通过解析推导本征值和本征向量，你将对物理模态及其数值表示之间的联系建立起基本的认识 [@problem_id:3526049]。", "problem": "一个厚度为 $L$ 的平行平面、光学厚的天体物理平板，沿笛卡尔坐标 $x \\in [0,L]$ 存在热扩散。由于与周围介质的高效辐射耦合，其边界温度保持固定。\n\n为了分析显式时间积分格式中的数值稳定性和模态成分，我们考虑一个空间算子，其基础为具有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(L)=0$ 的一维二阶导数 $d^{2}/dx^{2}$。\n\n使用 $N$ 个内网格点将该区间离散化，各点位置为 $x_{j} = j h$，$j \\in \\{1,2,\\dots,N\\}$，且 $h = L/(N+1)$。使用标准的二阶中心有限差分来近似二阶导数，该近似是基于导数作为差商极限的定义构建的。通过将常规的有限差分矩阵乘以 $h^{2}$ 来定义无量纲离散拉普拉斯矩阵 $\\tilde{\\mathcal{L}} \\in \\mathbb{R}^{N \\times N}$，其矩阵元素为\n$$\n\\tilde{\\mathcal{L}}_{j,j} = -2, \\quad \\tilde{\\mathcal{L}}_{j,j+1} = 1, \\quad \\tilde{\\mathcal{L}}_{j,j-1} = 1,\n$$\n所有其他元素均为 $0$，并且隐式地满足狄利克雷条件 $u_{0}=0$ 和 $u_{N+1}=0$。\n\n从这些定义和边界条件出发，推导 $\\tilde{\\mathcal{L}}$ 的特征对 $\\big(\\lambda_{k}, v^{(k)}\\big)$，并证明每个特征向量 $v^{(k)}$ 的分量是关于网格索引的正弦函数形式，与狄利克雷边界相符。你的推导应从特征值方程所蕴含的有限差分递推关系开始，并应论证满足边界条件的容许离散波数。\n\n最后，给出 $\\tilde{\\mathcal{L}}$ 的第 $k$ 个特征值 $\\lambda_{k}$ 作为整数 $N \\ge 2$ 和 $k \\in \\{1,2,\\dots,N\\}$ 的函数的解析表达式。将最终答案表示为单个闭式符号表达式。无需四舍五入，无量纲矩阵 $\\tilde{\\mathcal{L}}$ 也不需要物理单位。", "solution": "问题陈述已经过验证，被认为是数值分析领域一个有效、适定的问题，具体涉及带齐次狄利克雷边界条件的一维离散拉普拉斯算子的特征值问题。该问题自洽、有科学依据且客观，是计算数学中的一个标准练习题。\n\n任务是求无量纲离散拉普拉斯矩阵 $\\tilde{\\mathcal{L}} \\in \\mathbb{R}^{N \\times N}$ 的特征值和特征向量，其元素定义为 $\\tilde{\\mathcal{L}}_{j,j} = -2$、$\\tilde{\\mathcal{L}}_{j,j+1} = 1$ 和 $\\tilde{\\mathcal{L}}_{j,j-1} = 1$。特征值方程为\n$$\n\\tilde{\\mathcal{L}} v = \\lambda v\n$$\n其中 $\\lambda$ 是一个特征值，$v$ 是对应的特征向量，其分量为 $v_j$，$j \\in \\{1, 2, \\dots, N\\}$。\n\n将该矩阵方程写成其第 $j$ 个分量的形式，我们得到一个线性递推关系：\n$$\n\\tilde{\\mathcal{L}}_{j,j-1} v_{j-1} + \\tilde{\\mathcal{L}}_{j,j} v_j + \\tilde{\\mathcal{L}}_{j,j+1} v_{j+1} = \\lambda v_j\n$$\n代入矩阵元素可得：\n$$\nv_{j-1} - 2v_j + v_{j+1} = \\lambda v_j\n$$\n该关系对 $j = 1, 2, \\dots, N$ 成立。问题指定了齐次狄利克雷边界条件，在这种离散设置下，即为 $v_0 = 0$ 和 $v_{N+1} = 0$。\n\n我们可以将递推关系重排为：\n$$\nv_{j+1} + v_{j-1} = (2 + \\lambda) v_j\n$$\n这是一个二阶常系数齐次线性差分方程。我们寻找形如 $v_j = z^j$ 的解，其中 $z$ 是某个复数。将此试探解代入递推关系，得到特征方程：\n$$\nz^{j+1} + z^{j-1} = (2 + \\lambda) z^j\n$$\n两边同除以 $z^{j-1}$（对于非平凡解，必须有 $z \\neq 0$），我们得到：\n$$\nz^2 + 1 = (2 + \\lambda) z\n$$\n$$\nz^2 - (2 + \\lambda)z + 1 = 0\n$$\n矩阵 $\\tilde{\\mathcal{L}}$ 是实对称的，因此其特征值 $\\lambda$ 是实数。此外，作为带狄利克雷条件的二阶导数的离散表示，其特征值是负的。具体来说，可以证明 $-4  \\lambda  0$。对于此范围的 $\\lambda$，项 $2+\\lambda$ 位于区间 $(-2, 2)$ 内，且二次方程的判别式 $\\Delta = (2+\\lambda)^2 - 4$ 为负。因此，$z$ 的根是一对共轭复数。\n\n我们定义一个角度 $\\theta$ 使得 $2 + \\lambda = 2 \\cos(\\theta)$。特征方程变为：\n$$\nz^2 - 2\\cos(\\theta) z + 1 = 0\n$$\n根由二次方程求根公式给出：\n$$\nz = \\frac{2\\cos(\\theta) \\pm \\sqrt{4\\cos^2(\\theta) - 4}}{2} = \\frac{2\\cos(\\theta) \\pm 2i\\sin(\\theta)}{2} = \\cos(\\theta) \\pm i\\sin(\\theta) = e^{\\pm i\\theta}\n$$\n$v_j$ 的通解是与这些根对应的两个独立解的线性组合：\n$$\nv_j = A e^{ij\\theta} + B e^{-ij\\theta}\n$$\n使用欧拉公式，这可以表示为正弦函数和余弦函数的形式：\n$$\nv_j = C \\sin(j\\theta) + D \\cos(j\\theta)\n$$\n其中 $C$ 和 $D$ 是某些常数。\n\n现在我们应用边界条件。第一个条件是 $v_0 = 0$：\n$$\nv_0 = C \\sin(0 \\cdot \\theta) + D \\cos(0 \\cdot \\theta) = C \\cdot 0 + D \\cdot 1 = D = 0\n$$\n这迫使系数 $D$ 为零，因此解必须具有 $v_j = C \\sin(j\\theta)$ 的形式。这证明了特征向量的分量是关于网格索引 $j$ 的正弦函数形式，与要求相符。\n\n第二个边界条件是 $v_{N+1} = 0$：\n$$\nv_{N+1} = C \\sin((N+1)\\theta) = 0\n$$\n对于非平凡特征向量，我们必须有 $C \\neq 0$。因此，正弦函数的自变量必须是 $\\pi$ 的整数倍：\n$$\n(N+1)\\theta = k\\pi, \\quad k \\in \\mathbb{Z}\n$$\n这就将 $\\theta$ 的容许值量子化了：\n$$\n\\theta_k = \\frac{k\\pi}{N+1}\n$$\n因此，第 $k$ 个特征向量的分量由下式给出：\n$$\nv_j^{(k)} = C \\sin\\left(\\frac{jk\\pi}{N+1}\\right)\n$$\n我们必须确定整数模态索引 $k$ 的范围，以产生一组完备的线性无关特征向量。\n- 如果 $k=0$，那么 $\\theta_0=0$，并且对所有 $j$ 都有 $v_j^{(0)} = C\\sin(0) = 0$。这是平凡向量，不是特征向量。\n- 索引 $j$ 的取值范围是从 $1$ 到 $N$。如果 $k = N+1$，那么对所有整数 $j$ 都有 $v_j^{(N+1)} = C\\sin(j\\pi) = 0$。这也是平凡向量。\n- 对于 $k \\in \\{1, 2, \\dots, N\\}$，我们得到 $N$ 个非平凡的、线性无关的向量。\n- 对于 $k$ 的其他整数值，得到的向量不是新的。例如，当 $k' = -k$ 时，$v_j^{(-k)} = C \\sin(-jk\\pi/(N+1)) = -v_j^{(k)}$，这只是第 $k$ 个特征向量的一个标量倍。类似地，由于 $\\sin(x+2\\pi) = \\sin(x)$，$k' = k+2(N+1)$ 会产生相同的特征向量。\n\n因此，通过取 $k \\in \\{1, 2, \\dots, N\\}$，可以得到一组完备且唯一的 $N$ 个特征向量。\n\n最后，我们推导特征值 $\\lambda_k$ 的表达式。我们已经建立了关系式 $2 + \\lambda = 2 \\cos(\\theta)$。代入量子化的值 $\\theta_k$ 可得：\n$$\n2 + \\lambda_k = 2\\cos\\left(\\frac{k\\pi}{N+1}\\right)\n$$\n$$\n\\lambda_k = 2\\cos\\left(\\frac{k\\pi}{N+1}\\right) - 2\n$$\n使用三角恒等式 $\\cos(2\\alpha) = 1 - 2\\sin^2(\\alpha)$，或等价地 $\\cos(x)-1 = -2\\sin^2(x/2)$，我们可以重写 $\\lambda_k$ 的表达式：\n$$\n\\lambda_k = -2 \\left(1 - \\cos\\left(\\frac{k\\pi}{N+1}\\right)\\right) = -2 \\left(2\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)\\right)\n$$\n这就给出了特征值的最终闭式表达式：\n$$\n\\lambda_k = -4\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)\n$$\n这就是所要求的 $\\tilde{\\mathcal{L}}$ 的第 $k$ 个特征值 $\\lambda_k$ 作为 $N$ 和 $k$ 的函数的解析表达式，其中 $k \\in \\{1, 2, \\dots, N\\}$。", "answer": "$$\\boxed{-4\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)}$$", "id": "3526049"}, {"introduction": "从理论转向实际的天体物理应用，这个实践将挑战你使用有限元法（Finite Element Method, FEM）来模拟恒星振荡。你将把描述恒星脉动模式的 Sturm–Liouville 问题离散化为一个广义矩阵本征值问题 $Kx = \\lambda Bx$。这项编程任务不仅需要你组装刚度矩阵（$K$）和质量矩阵（$B$），还要求你对计算出的本征模之间关键的 $B$-正交性进行数值验证 [@problem_id:3526022]。", "problem": "考虑一个广义自伴随Sturm–Liouville特征值问题，该问题模拟了一维空间中恒星的球对称振荡模式，定义在区间 $\\left[0,R\\right]$ 上，\n$$\n-\\frac{d}{dr}\\left(p(r)\\frac{d\\xi}{dr}\\right) + q(r)\\,\\xi(r) \\;=\\; \\lambda\\, w(r)\\,\\xi(r),\n$$\n其中 $r$ 是径向坐标，$\\xi(r)$ 是位移本征函数，$\\lambda$ 是特征值，$p(r)$ 是正刚度分布，$q(r)$ 是非负恢复分布，$w(r)$ 是与密度分布成正比的正权重。施加齐次Dirichlet边界条件 $\\xi(0)=0$ 和 $\\xi(R)=0$。假设存在以下天体物理上合理的分布：\n$$\np(r) = r^2,\\quad q(r) = \\alpha\\, r^2,\\quad w(r) = r^2\\,\\rho(r),\\quad \\rho(r) = \\rho_c\\left(1 - \\left(\\frac{r}{R}\\right)^2\\right),\n$$\n其中 $\\alpha  0$ 且 $\\rho_c  0$。在 $H_0^1(0,R)$ 上的弱形式为：寻找 $\\lambda \\in \\mathbb{R}$ 和 $\\xi \\neq 0$，使得对于所有检验函数 $\\eta$，\n$$\n\\int_0^R p(r)\\,\\frac{d\\xi}{dr}\\,\\frac{d\\eta}{dr}\\,dr \\;+\\; \\int_0^R q(r)\\,\\xi(r)\\,\\eta(r)\\,dr \\;=\\; \\lambda \\int_0^R w(r)\\,\\xi(r)\\,\\eta(r)\\,dr.\n$$\n使用有限元(FE)法，在区间 $\\left[0,R\\right]$ 上包含 $N$ 个单元的均匀网格上，通过连续分段线性基函数对该弱形式进行离散化，并通过消除 $r=0$ 和 $r=R$ 处的边界自由度来施加Dirichlet边界条件。组装对称刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$ 和对称正定质量矩阵 $B \\in \\mathbb{R}^{n \\times n}$，其中 $n = N-1$ 是内部节点的数量。在每个单元上使用3点Gauss–Legendre求积来计算所有需要的积分。求解广义对称特征值问题\n$$\nK\\,x = \\lambda\\,B\\,x,\n$$\n并将前 $m$ 个本征模收集到模态矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 中，其列是对应于 $m$ 个最小特征值的特征向量。\n\n对计算出的本征模相对于 $B$ 进行归一化，使得 $X$ 的每一列 $x$ 都满足 $x^\\top B\\,x = 1$。然后通过计算以下公式来数值验证B-正交性\n$$\nM \\;=\\; X^\\top B\\,X,\n$$\n并通过两种方式量化与精确正交归一性的偏差：\n- 最大绝对非对角元素量值，$s = \\max_{i \\neq j} \\left|M_{ij}\\right|$。\n- 最大绝对对角线偏差（与1的偏差），$t = \\max_{i} \\left|M_{ii} - 1\\right|$。\n\n您的程序必须实现此过程，并为以下测试集生成结果，每个测试集由 $(N, R, \\rho_c, \\alpha, m)$ 指定：\n- 情况A：$(N, R, \\rho_c, \\alpha, m) = (32, 1, 1, 0.05, 6)$。\n- 情况B：$(N, R, \\rho_c, \\alpha, m) = (64, 1, 1, 0.0001, 6)$。\n- 情况C：$(N, R, \\rho_c, \\alpha, m) = (16, 1, 1000, 0.2, 4)$。\n\n对于每种情况，输出实数对 $[s, t]$。您的程序应生成单行输出，其中包含这些结果对的逗号分隔列表，并用方括号括起来。例如，要求的最终输出格式为\n$$\n\\left[ [s_A, t_A], [s_B, t_B], [s_C, t_C] \\right],\n$$\n其中 $[s_A, t_A]$ 对应情况A，$[s_B, t_B]$ 对应情况B，$[s_C, t_C]$ 对应情况C。此问题中不需要物理单位，因为所有量都已无量纲化。", "solution": "计算恒星球对称振荡模式的问题，被表述为在区间 $\\left[0,R\\right]$ 上的一个广义自伴随Sturm–Liouville特征值问题。求解过程需要使用有限元(FE)法对该问题进行离散化，然后数值求解所得的矩阵特征值问题。步骤如下。\n\n首先，我们从问题的弱（或变分）形式开始，该形式已在问题描述中给出。寻找一个特征值 $\\lambda \\in \\mathbb{R}$ 和一个非平凡的本征函数 $\\xi \\in H_0^1(0,R)$，使得对于所有的检验函数 $\\eta \\in H_0^1(0,R)$：\n$$\na(\\xi, \\eta) = \\lambda\\, b(\\xi, \\eta)\n$$\n其中双线性形式 $a(\\cdot, \\cdot)$ 和 $b(\\cdot, \\cdot)$ 定义如下：\n$$\na(\\xi, \\eta) = \\int_0^R p(r)\\,\\frac{d\\xi}{dr}\\,\\frac{d\\eta}{dr}\\,dr \\;+\\; \\int_0^R q(r)\\,\\xi(r)\\,\\eta(r)\\,dr\n$$\n$$\nb(\\xi, \\eta) = \\int_0^R w(r)\\,\\xi(r)\\,\\eta(r)\\,dr\n$$\n空间 $H_0^1(0,R)$ 是Sobolev空间，其中包含一阶导数平方可积且在边界 $r=0$ 和 $r=R$ 处为零的函数。系数由 $p(r) = r^2$，$q(r) = \\alpha r^2$ 和 $w(r) = r^2\\rho_c(1-(r/R)^2)$ 给出。由于当 $r \\in (0,R]$ 时 $p(r)0$，且 $\\alpha0$ 和 $\\rho_c0$，双线性形式 $a(\\cdot,\\cdot)$ 是对称正定的，在 $H_0^1(0,R)$ 上定义了一个内积。同样地，由于当 $r \\in (0,R)$ 时 $w(r)0$，双线性形式 $b(\\cdot,\\cdot)$ 也是对称正定的，在 $L^2(0,R)$ 上定义了一个内积。\n\n其次，我们应用有限元法。将域 $[0,R]$ 离散化为包含 $N$ 个单元的均匀网格，每个单元的大小为 $h = R/N$。这会创建 $N+1$ 个节点，位于 $r_i = i h$ 处，其中 $i=0, 1, \\dots, N$。解 $\\xi(r)$ 通过函数 $\\xi_h(r)$ 来近似，$\\xi_h(r)$ 是连续分段线性基函数（帽函数）$\\phi_j(r)$ 的线性组合：\n$$\n\\xi(r) \\approx \\xi_h(r) = \\sum_{j=1}^{N-1} x_j \\phi_j(r)\n$$\n求和遍历 $n = N-1$ 个内部节点（$j=1, \\dots, N-1$），因为齐次Dirichlet边界条件 $\\xi(0)=0$ 和 $\\xi(R)=0$ 是通过排除与边界节点相关的基函数 $\\phi_0(r)$ 和 $\\phi_N(r)$ 来强制执行的。系数 $x_j$ 是近似解在内部节点 $\\xi_h(r_j)$ 处的未知值。\n\n第三，我们采用Galerkin法，其中检验函数 $\\eta$ 从与试探函数 $\\xi_h$ 相同的有限维空间中选取。对于每个内部基函数 $i = 1, \\dots, N-1$，我们设置 $\\eta = \\phi_i(r)$。将近似解 $\\xi_h$ 和检验函数 $\\phi_i$ 代入弱形式，得到一个包含 $n$ 个线性方程的方程组：\n$$\n\\sum_{j=1}^{N-1} a(\\phi_j, \\phi_i) x_j = \\lambda \\sum_{j=1}^{N-1} b(\\phi_j, \\phi_i) x_j \\quad \\text{for } i=1, \\dots, N-1\n$$\n这是一个广义矩阵特征值问题 $Kx = \\lambda Bx$，其中 $x = [x_1, \\dots, x_{N-1}]^\\top$ 是未知系数的向量，$K$ 和 $B$ 分别是全局刚度矩阵和质量矩阵。它们的元素由以下公式给出：\n$$\nK_{ij} = a(\\phi_j, \\phi_i) = \\int_0^R \\left( p(r) \\frac{d\\phi_j}{dr} \\frac{d\\phi_i}{dr} + q(r) \\phi_j(r) \\phi_i(r) \\right) dr\n$$\n$$\nB_{ij} = b(\\phi_j, \\phi_i) = \\int_0^R w(r) \\phi_j(r) \\phi_i(r) dr\n$$\n这些矩阵是对称的，并且由于双线性形式的性质，$K$ 是正定的，$B$ 也是正定的。\n\n第四，矩阵元素的积分通过在每个单元上使用3点Gauss-Legendre求积进行数值计算。基函数 $\\phi_i$ 仅在最多两个相邻的单元上非零，这使得矩阵 $K$ 和 $B$ 是稀疏的（具体来说，是三对角的）。对于每个单元 $[r_e, r_{e+1}]$，我们通过计算 $2 \\times 2$ 的局部矩阵来计算其对全局矩阵的贡献。单元上的积分被变换到参考区间 $[-1,1]$ 上，并近似为：\n$$\n\\int_{r_e}^{r_{e+1}} f(r) dr \\approx \\frac{h}{2} \\sum_{k=1}^{3} w_k^{\\text{Gauss}} f(r(z_k))\n$$\n其中 $z_k$ 和 $w_k^{\\text{Gauss}}$ 是求积点和权重，$r(z_k)$ 是物理单元中的对应点。\n\n第五，在组装完 $n \\times n$ 矩阵 $K$ 和 $B$ 之后，求解广义对称特征值问题 $Kx=\\lambda Bx$，以得到 $m$ 个最小的特征值及相应的特征向量。这可以通过使用专门的数值求解器来完成，例如 `scipy.linalg.eigh`，它专为这类问题设计，并返回按升序排列的特征值以及相对于矩阵 $B$ 正交归一化的特征向量。\n\n最后，计算出的特征向量构成了模态矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 的列，这些向量已经被归一化，使得 $x^\\top B x = 1$。为了验证B-正交性的数值精度，我们计算矩阵 $M = X^\\top B X$。在精确计算和完美的特征向量下，$M$ 将是单位矩阵。与理想情况的偏差通过两个度量来量化：最大绝对非对角元素量值 $s = \\max_{i \\neq j} |M_{ij}|$，以及对角元素与1的最大绝对偏差 $t = \\max_i |M_{ii} - 1|$。这些值提供了对计算出的本征模质量的度量。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef analyze_modes(N, R, rho_c, alpha, m):\n    \"\"\"\n    Solves the Sturm-Liouville problem using FEM and verifies mode orthogonality.\n\n    Args:\n        N (int): Number of elements.\n        R (float): Radius of the star (domain endpoint).\n        rho_c (float): Central density parameter.\n        alpha (float): Parameter for the q(r) profile.\n        m (int): Number of smallest eigenmodes to compute.\n\n    Returns:\n        tuple[float, float]: A pair [s, t] where s is the max absolute off-diagonal\n                             magnitude and t is the max absolute diagonal deviation.\n    \"\"\"\n    # Number of interior nodes\n    n = N - 1\n    # Element size\n    h = R / N\n\n    # 3-point Gauss-Legendre quadrature points and weights on [-1, 1]\n    z_gauss = np.array([-np.sqrt(3/5), 0, np.sqrt(3/5)])\n    w_gauss = np.array([5/9, 8/9, 5/9])\n\n    # Initialize global stiffness (K) and mass (B) matrices\n    K = np.zeros((n, n))\n    B = np.zeros((n, n))\n\n    # Define coefficient functions based on the problem statement\n    def p(r): return r**2\n    def q(r): return alpha * r**2\n    def w(r): return r**2 * rho_c * (1 - (r/R)**2) if R > 0 else 0\n\n    # Assemble matrices element by element\n    for e in range(N):\n        r_e = e * h\n        \n        # Local 2x2 matrices for the current element\n        K_loc = np.zeros((2, 2))\n        B_loc = np.zeros((2, 2))\n        \n        # Integrate over the element using Gauss quadrature\n        for k in range(len(z_gauss)):\n            s_k = z_gauss[k]\n            weight_k = w_gauss[k]\n\n            # Map from reference element [-1, 1] to physical element [r_e, r_{e+1}]\n            r_k = r_e + (1 + s_k) * h / 2\n            jac = h / 2\n            \n            p_val = p(r_k)\n            q_val = q(r_k)\n            w_val = w(r_k)\n            \n            # Hat basis functions and their derivatives on the reference element\n            psi = np.array([(1 - s_k) / 2, (1 + s_k) / 2])\n            dpsi_dr = np.array([-1 / h, 1 / h])\n\n            for i in range(2):\n                for j in range(2):\n                    # Integral for stiffness matrix K\n                    integ_K = p_val * dpsi_dr[i] * dpsi_dr[j] + q_val * psi[i] * psi[j]\n                    K_loc[i, j] += weight_k * integ_K * jac\n                    \n                    # Integral for mass matrix B\n                    integ_B = w_val * psi[i] * psi[j]\n                    B_loc[i, j] += weight_k * integ_B * jac\n    \n        # Assemble local matrices into global matrices, considering only interior nodes\n        # Global matrix indices go from 0 to n-1, corresponding to nodes 1 to N-1\n        \n        # Left node of element 'e' is node 'e'. It is interior if e > 0.\n        if e > 0:\n            g_idx = e - 1\n            K[g_idx, g_idx] += K_loc[0, 0]\n            B[g_idx, g_idx] += B_loc[0, 0]\n\n        # Right node of element 'e' is node 'e+1'. It is interior if e+1  N.\n        if e  N - 1:\n            g_idx = e  # Corresponds to node e+1, so matrix index is (e+1)-1\n            K[g_idx, g_idx] += K_loc[1, 1]\n            B[g_idx, g_idx] += B_loc[1, 1]\n\n        # Off-diagonal terms if both nodes of the element are interior\n        if e > 0 and e  N - 1:\n            g_idx_i = e - 1\n            g_idx_j = e\n            K[g_idx_i, g_idx_j] += K_loc[0, 1]\n            K[g_idx_j, g_idx_i] += K_loc[1, 0]\n            B[g_idx_i, g_idx_j] += B_loc[0, 1]\n            B[g_idx_j, g_idx_i] += B_loc[1, 0]\n\n    # Solve the generalized symmetric eigenvalue problem K*x = lambda*B*x\n    # eigh returns eigenvalues in ascending order and B-orthonormalized eigenvectors\n    eigvals, eigvecs = eigh(K, B)\n    \n    # Collect the first m eigenmodes (eigenvectors)\n    X = eigvecs[:, :m]\n    \n    # Numerically verify B-orthogonality by computing M = X^T * B * X\n    M = X.T @ B @ X\n    \n    # Quantify the deviation from orthonormality\n    # s: maximum absolute off-diagonal magnitude\n    M_off_diag = M.copy()\n    np.fill_diagonal(M_off_diag, 0)\n    s = np.max(np.abs(M_off_diag))\n    \n    # t: maximum absolute diagonal deviation from unity\n    t = np.max(np.abs(np.diag(M) - 1))\n    \n    return s, t\n\ndef solve():\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (N, R, rho_c, alpha, m)\n        (32, 1, 1, 0.05, 6),      # Case A\n        (64, 1, 1, 0.0001, 6),    # Case B\n        (16, 1, 1000, 0.2, 4),    # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        s, t = analyze_modes(*case)\n        results.append([s, t])\n\n    # Format the final output string as specified\n    formatted_results = [f\"[{s},{t}]\" for s, t in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3526022"}, {"introduction": "在学习了如何构建和求解本征值问题之后，我们现在来解决大规模计算中的一个关键问题：效率。本练习将展示一个基于物理洞察的缩放变换如何显著加速迭代求解器（如反迭代法）的收敛速度。通过对比求解器在原始恒星振荡问题和缩放后问题上的性能，你将对预处理技术获得实践性的理解，这是解决现代计算天体物理学中海量本征值问题的核心技巧 [@problem_id:3526012]。", "problem": "考虑在 Cowling 近似下的小振幅、球对称恒星振荡，其中微扰不改变引力势。在分离变量并忽略角度依赖后，拉格朗日位移振幅的线性化径向方程可以转化为一个 Sturm-Liouville 型广义特征值问题，形式为 $A x = \\lambda B x$，其中 $A$ 是一个对称正定（SPD）刚度矩阵，$B$ 是一个对称正定（SPD）质量矩阵，$x$ 是离散特征函数，$\\lambda = \\omega^2$ 是角频率的平方。矩阵 $A$ 和 $B$ 源于算符 $L[y] = -\\frac{d}{dr}\\left(c^2(r) \\frac{d y}{dr}\\right) + V(r) y$ 的空间离散化，其权重为 $W(r) = \\rho(r)$，其中 $c(r)$ 是绝热声速，$\\rho(r)$ 是质量密度，$V(r)$ 是一个正势能项，用于模拟受引力影响的稳定分层。径向坐标 $r$ 的范围是从 $r = 0$ 到 $r = R$，边界条件是中心正则性（$y'(0) = 0$）和表面位移为零（$y(R) = 0$）。\n\n您将使用以下物理上一致的定义，在均匀的径向网格上构造 $A$ 和 $B$：\n- 设恒星半径为 $R$（单位：$\\mathrm{m}$），中心密度为 $\\rho_c$（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$），引力常数为 $G$（单位：$\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$），绝热指数为 $\\Gamma_1$（无量纲）。\n- 使用多方压力关系 $P(r) = K \\rho(r)^{\\Gamma_1}$，其中 $K$ 的选择使得中心声速 $c(0) = c_0$（单位：$\\mathrm{m}\\,\\mathrm{s}^{-1}$），即 $K = \\frac{c_0^2}{\\Gamma_1 \\rho_c^{\\Gamma_1 - 1}}$。因此 $c^2(r) = \\Gamma_1 K \\rho(r)^{\\Gamma_1 - 1}$。\n- 用 $\\rho(r) = \\rho_c \\max\\left(1 - a \\left(\\frac{r}{R}\\right)^2, \\epsilon_\\rho\\right)$ 来模拟密度分布，其中 $a  0$（无量纲），$\\epsilon_\\rho$ 是一个小的下限值（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$），以保持数值稳健性。\n- 定义包围质量 $M(r)$ 为 $M(r) = 4 \\pi \\int_0^r \\rho(s) s^2 \\, ds$，稳定势 $V(r) = \\beta \\frac{G M(r)}{(r + \\epsilon_r)^3}$，其中 $\\beta  0$（无量纲），$\\epsilon_r$ 是一个小的正则化长度（单位：$\\mathrm{m}$）。\n\n在 $N$ 个长度为 $h = \\frac{R}{N}$ 的均匀区间上使用二阶中心有限差分，未知数位于内部节点 $r_i = i h$（$i = 1, 2, \\dots, N - 1$），维度为 $N - 1$。使用中点传导率 $c^2\\left(r_{i \\pm \\frac{1}{2}}\\right)$ 从扩散项构造 $A$，并加上对角势能 $V(r_i)$。通过在 $r = 0$ 处对 $i=1$ 应用反射（Neumann）条件，并在 $r=R$ 处对 $i = N - 1$ 应用 Dirichlet 条件来施加边界条件。将 $B$ 构造为对角矩阵，其元素为 $B_{ii} = \\rho(r_i)$。\n\n您将实现并比较两种反迭代方案，以近似求解与一个基于物理动机的偏移量最接近的模式所对应的特征对：\n- 针对 $A x = \\lambda B x$ 的带偏移量 $\\mu$ 的广义反迭代法：在第 $k$ 次迭代时，求解 $(A - \\mu B) u_{k+1} = B x_k$，然后设置 $x_{k+1} = \\frac{u_{k+1}}{\\|u_{k+1}\\|_B}$，其中 $\\|u\\|_B = \\sqrt{u^\\top B u}$，并更新瑞利商 $\\lambda_{k+1} = \\frac{x_{k+1}^\\top A x_{k+1}}{x_{k+1}^\\top B x_{k+1}}$。\n- 在质量归一化坐标中使用对角缩放 $S = B^{-1/2}$ 的缩放反迭代法，使得 $C = S A S$ 定义了一个标准特征问题 $C z = \\lambda z$：在第 $k$ 次迭代时，求解 $(C - \\mu I) z_{k+1} = z_k$，然后归一化 $z_{k+1} = \\frac{z_{k+1}}{\\|z_{k+1}\\|_2}$，计算 $\\lambda_{k+1} = \\frac{z_{k+1}^\\top C z_{k+1}}{z_{k+1}^\\top z_{k+1}}$，并构建物理空间迭代量 $x_{k+1} = S z_{k+1}$ 以评估原始变量中的残差。\n\n两种方案必须使用相同的偏移量 $\\mu$，该偏移量由基于平均声速 $\\bar{c}$ 和全局长度尺度 $R$ 的频率尺度估计定义：$\\mu = \\kappa \\left(\\frac{\\pi \\bar{c}}{R}\\right)^2$，其中 $\\kappa$ 是一个严格介于 $0$ 和 $1$ 之间的无量纲因子。通过 $x_0(i) = \\sin\\left(\\pi \\frac{r_i}{R}\\right)$ 确定性地初始化 $x_0$，并设置 $z_0 = \\frac{S^{-1} x_0}{\\|S^{-1} x_0\\|_2}$。使用基于相对残差 $\\frac{\\|A x - \\lambda B x\\|_2}{\\|A\\|_2}$ 小于容差 $\\varepsilon$ 的停止准则，并设置 $K_{\\max}$ 次迭代的硬上限。请注意，对于两种方法，此残差都是在原始未缩放变量中评估的，且 $\\|A\\|_2$ 表示谱范数。\n\n其目的是证明基于物理动机的重缩放和质量归一化可以聚集算符的有效尺度，并改善偏移后线性求解的条件数，从而加速反迭代法的收敛。您将通过未缩放方法和缩放方法收敛所需迭代次数的差异来衡量改进效果。\n\n实现一个完整的程序，该程序：\n- 根据上述离散化和物理定义构建 $A$ 和 $B$。\n- 使用相同的偏移量 $\\mu$、容差 $\\varepsilon$ 和迭代上限 $K_{\\max}$ 运行两种反迭代变体。\n- 针对每个测试用例，报告整数差值 $\\Delta k = k_{\\text{unscaled}} - k_{\\text{scaled}}$，其中 $k_{\\text{unscaled}}$ 和 $k_{\\text{scaled}}$ 是满足停止准则所需的迭代次数。\n\n使用以下物理常数和参数，在适用的情况下以国际单位制（SI）表示：\n- $R = 6.96 \\times 10^8$（单位：$\\mathrm{m}$）。\n- $\\rho_c = 1.50 \\times 10^5$（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$）。\n- $G = 6.67430 \\times 10^{-11}$（单位：$\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$）。\n- $\\Gamma_1 = \\frac{5}{3}$（无量纲）。\n- $c_0 = 5.00 \\times 10^5$（单位：$\\mathrm{m}\\,\\mathrm{s}^{-1}$）。\n- $\\epsilon_\\rho = 1.00$（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$）。\n- $\\epsilon_r = 1.00 \\times 10^3$（单位：$\\mathrm{m}$）。\n- $\\kappa = 0.90$（无量纲）。\n- $\\varepsilon = 1.00 \\times 10^{-8}$（无量纲）。\n- $K_{\\max} = 100$（无量纲）。\n\n提供一个包含以下参数三元组 $(N, a, \\beta)$ 的测试套件：\n- 案例 1：$(128, 1.00, 0.02)$ 是一般性的“理想路径”情况。\n- 案例 2：$(64, 1.00, 0.02)$ 是一个粗分辨率边界情况。\n- 案例 3：$(256, 1.50, 0.02)$ 是一个考验条件数的高对比度边缘情况。\n- 案例 4：$(128, 0.20, 0.00)$ 是一个没有稳定势的近均匀密度情况。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为各案例的结果，顺序与上述案例完全一致，例如 `\"[d_1,d_2,d_3,d_4]\"`，其中每个 $d_i$ 是案例 $i$ 的整数 $\\Delta k$。", "solution": "用户提供了一个有效的问题陈述。它在科学上基于恒星振荡理论，特别是在数值星震学的背景下。该问题是适定的，描述了一个广义特征值问题，并寻求使用标准迭代方法（反迭代法）求解。问题陈述是客观、完整且可形式化的。所有常数、参数和算法定义均已提供，从而可以得到确定性且可验证的解。\n\n问题的核心是构造并求解广义特征值问题 $A x = \\lambda B x$，该问题模拟球对称恒星振荡。我们将首先基于均匀径向网格上控制微分算符的有限差分方法来构造矩阵 $A$ 和 $B$。随后，我们将实现并比较反迭代算法的两种变体，以找到最接近指定频移 $\\mu$ 的本征模。\n\n### 步骤 1：离散化与矩阵构造\n\n问题定义在一个具有 $N$ 个大小为 $h = R/N$ 的均匀区间的径向网格上。未知数是内部节点 $r_i = i h$（$i = 1, 2, \\dots, N - 1$）处的位移振幅 $y_i$。系统维度为 $d = N - 1$。在实现中，我们将对数组使用从零开始的索引，因此大小为 $d$ 的未知向量 $x$ 对应于 $y_1, \\dots, y_{N-1}$。\n\n**物理剖面：**\n首先，我们将物理量定义为径向坐标 $r$ 的函数：\n1.  **多方常数 $K$**：中心声速 $c(0) = c_0$ 用于设定多方压力-密度关系 $P = K \\rho^{\\Gamma_1}$ 中的常数 $K$。声速的平方为 $c^2 = \\frac{\\Gamma_1 P}{\\rho} = \\Gamma_1 K \\rho^{\\Gamma_1-1}$。在中心处，$c_0^2 = \\Gamma_1 K \\rho_c^{\\Gamma_1-1}$，得出 $K = \\frac{c_0^2}{\\Gamma_1 \\rho_c^{\\Gamma_1-1}}$。\n2.  **密度 $\\rho(r)$**：密度剖面由 $\\rho(r) = \\max(\\rho_c (1 - a(r/R)^2), \\epsilon_\\rho)$ 给出。\n3.  **声速 $c^2(r)$**：$c^2(r) = \\Gamma_1 K \\rho(r)^{\\Gamma_1 - 1}$。\n4.  **包围质量 $M(r)$**：这需要对密度剖面进行积分：$M(r) = 4\\pi \\int_0^r \\rho(s) s^2 ds$。设 $r_t$ 为过渡半径，在该处 $\\rho_c (1 - a(r_t/R)^2) = \\epsilon_\\rho$。如果平方根的参数为正，则过渡发生在 $r_t = R \\sqrt{(1 - \\epsilon_\\rho/\\rho_c)/a}$；否则，过渡不会在恒星内部发生。该积分是分段计算的。\n    对于 $r \\le r_t$：$M(r) = 4\\pi \\rho_c (r^3/3 - a r^5/(5R^2))$。\n    对于 $r  r_t$：$M(r) = M(r_t) + 4\\pi \\epsilon_\\rho (r^3 - r_t^3)/3$。\n5.  **势能 $V(r)$**：该项由 $V(r) = \\beta \\frac{G M(r)}{(r + \\epsilon_r)^3}$ 给出。\n\n**质量矩阵 $B$：**\n质量矩阵 $B$ 是一个维度为 $d \\times d$ 的对角矩阵，其元素为 $B_{ii} = \\rho(r_{i+1})$，$i=0, \\dots, d-1$。这表示微分方程中 $\\lambda \\rho(r) y$ 项的集中质量近似。\n\n**刚度矩阵 $A$：**\n刚度矩阵 $A$ 源于算符 $L[y] = -\\frac{d}{dr}(c^2(r) \\frac{dy}{dr}) + V(r)y$ 的二阶中心有限差分离散化。\n一个通用内部节点 $r_i$（$1  i  N-1$）给出以下模板：\n$$ (L[y])_i \\approx \\frac{1}{h^2} \\left[ -c^2(r_{i-1/2}) y_{i-1} + (c^2(r_{i-1/2}) + c^2(r_{i+1/2})) y_i - c^2(r_{i+1/2}) y_{i+1} \\right] + V(r_i) y_i $$\n这定义了 $A$ 的三对角线元素。由于算符 $L$ 的自伴性质，该矩阵必须是对称的。\n边界条件是 $y'(0)=0$（中心正则性）和 $y(R)=0$（表面位移为零）。\n-   **$r=R$ 处的 Dirichlet 条件**：对于最后一个未知数 $y_{N-1}$，模板涉及 $y_N$。设置 $y_N=0$ 可以正确地截断矩阵。对应于 $y_{N-1}$ 的行为：$\\dots -c^2(r_{N-3/2})y_{N-2} + (c^2(r_{N-3/2}) + c^2(r_{N-1/2}))y_{N-1}$。\n-   **$r=0$ 处的 Neumann 条件**：问题陈述要求对节点 $i=1$ 应用反射条件。为确保所得矩阵 $A$ 是对称且正定的，我们必须使用一致的离散化方法。一种保持这些性质的常用（尽管可能不是最精确的）方法是用一阶向前差分 $\\frac{y_1-y_0}{h}=0$ 来近似导数条件 $y'(0)=0$，这意味着 $y_0 = y_1$。将 $y_0=y_1$ 代入 $y_1$ 的模板中：\n$$ (L[y])_1 \\approx \\frac{1}{h^2} \\left[ -c^2(r_{1/2}) y_0 + (c^2(r_{1/2}) + c^2(r_{3/2})) y_1 - c^2(r_{3/2}) y_2 \\right] + V(r_1) y_1 $$\n$$ \\approx \\frac{1}{h^2} \\left[ (-c^2(r_{1/2}) + c^2(r_{1/2}) + c^2(r_{3/2})) y_1 - c^2(r_{3/2}) y_2 \\right] + V(r_1) y_1 $$\n$$ = \\frac{1}{h^2} \\left[ c^2(r_{3/2}) y_1 - c^2(r_{3/2}) y_2 \\right] + V(r_1) y_1 $$\n这种离散化方法虽然简单，但能产生一个对称正定矩阵，与问题的设定一致。得到的矩阵 $A$ 构造如下（使用从 0 开始的索引 $j=0, \\dots, d-1$）：\n-   非对角线元素：$A_{j, j+1} = A_{j+1, j} = -c^2(r_{j+3/2}) / h^2$。\n-   对角线元素：对于 $j > 0$，$A_{j,j} = (c^2(r_{j+1/2}) + c^2(r_{j+3/2}))/h^2 + V(r_{j+1})$。\n-   第一个对角线元素：$A_{0,0} = c^2(r_{3/2})/h^2 + V(r_1)$。\n-   最后一个对角线元素：$A_{d-1,d-1} = (c^2(r_{d-1/2}) + c^2(r_{d+1/2}))/h^2 + V(r_d)$。\n\n### 步骤 2：反迭代算法\n\n我们实现两种反迭代方案来寻找特征对 $(\\lambda, x)$，其中 $\\lambda$ 最接近给定的偏移量 $\\mu$。偏移量为 $\\mu = \\kappa (\\pi \\bar{c}/R)^2$，其中 $\\bar{c}$ 是内部网格节点上声速的均方根平均值。特征向量的初始猜测为 $x_0(i) = \\sin(\\pi r_i/R)$。当相对残差 $\\frac{\\|A x - \\lambda B x\\|_2}{\\|A\\|_2}$ 小于 $\\varepsilon=10^{-8}$ 或达到 $K_{\\max}=100$ 次迭代后，迭代停止。\n\n**方法 1：广义反迭代法（未缩放）**\n迭代过程如下：\n1.  初始化 $x_0 \\leftarrow x_0 / \\sqrt{x_0^\\top B x_0}$。\n2.  对于 $k=0, 1, 2, \\dots$：\n    a. 求解 $(A - \\mu B) u_{k+1} = B x_k$ 得到 $u_{k+1}$。\n    b. 归一化：$x_{k+1} = u_{k+1} / \\sqrt{u_{k+1}^\\top B u_{k+1}}$。\n    c. 计算瑞利商：$\\lambda_{k+1} = x_{k+1}^\\top A x_{k+1}$。\n    d. 检查收敛性。\n\n**方法 2：缩放反迭代法**\n此方法将广义问题转换为标准问题。设 $S=B^{-1/2}$，这是一个对角矩阵，其元素为 $1/\\sqrt{\\rho(r_i)}$。转换后的问题是 $C z = \\lambda z$，其中 $C = S A S$，$z = S^{-1} x$。\n迭代过程如下：\n1.  初始化 $z_0 = S^{-1} x_0$，然后 $z_0 \\leftarrow z_0 / \\|z_0\\|_2$。\n2.  对于 $k=0, 1, 2, \\dots$：\n    a. 求解 $(C - \\mu I) u_{k+1} = z_k$ 得到 $u_{k+1}$。\n    b. 归一化：$z_{k+1} = u_{k+1} / \\|u_{k+1}\\|_2$。\n    c. 计算瑞利商：$\\lambda_{k+1} = z_{k+1}^\\top C z_{k+1}$。\n    d. 转换回物理空间特征函数：$x_{k+1} = S z_{k+1}$。\n    e. 使用原始变量中的残差检查收敛性。\n\n将问题转换为标准特征问题有望改善每步求解的线性系统的条件数，特别是在密度剖面具有高对比度的情况下，从而导致更快的收敛。最终输出是迭代次数的差异 $\\Delta k = k_{\\text{unscaled}} - k_{\\text{scaled}}$。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    # Physical constants in SI units\n    R = 6.96e8  # m\n    RHO_C = 1.50e5  # kg*m^-3\n    G = 6.67430e-11  # m^3*kg^-1*s^-2\n    GAMMA_1 = 5.0 / 3.0\n    C0 = 5.00e5  # m*s^-1\n    EPSILON_RHO = 1.00  # kg*m^-3\n    EPSILON_R = 1.00e3  # m\n    KAPPA = 0.90\n    TOLERANCE = 1.00e-8\n    K_MAX = 100\n\n    # Polytropic constant K\n    K_CONST = C0**2 / (GAMMA_1 * RHO_C**(GAMMA_1 - 1))\n\n    # Test cases (N, a, beta)\n    test_cases = [\n        (128, 1.00, 0.02),\n        (64, 1.00, 0.02),\n        (256, 1.50, 0.02),\n        (128, 0.20, 0.00),\n    ]\n\n    results = []\n    for N, a, beta in test_cases:\n        # --- 1. Setup Grid and Physical Profiles ---\n        h = R / N\n        # Interior nodes r_1, ..., r_{N-1}\n        # Corresponds to python index 0, ..., N-2\n        r_nodes = h * np.arange(1, N) \n        # Midpoint nodes r_1/2, ..., r_{N-1/2}\n        # Corresponds to python index 0, ..., N-1\n        r_midpoints = h * (np.arange(0, N) + 0.5)\n\n        def rho(r_vec):\n            return np.maximum(RHO_C * (1 - a * (r_vec / R)**2), EPSILON_RHO)\n\n        def c2(r_vec):\n            # Avoid divide by zero if rho is zero, though epsilon_rho should prevent this.\n            return GAMMA_1 * K_CONST * rho(r_vec)**(GAMMA_1 - 1)\n\n        def M(r_vec):\n            # The vectorized calculation of enclosed mass.\n            m_vals = np.zeros_like(r_vec, dtype=float)\n            \n            # Find transition radius r_t\n            if a > (1 - EPSILON_RHO / RHO_C):\n                r_t = R * np.sqrt((1 - EPSILON_RHO/RHO_C) / a)\n            else: # Transition does not occur within [0, R)\n                r_t = R + 1.0 \n\n            # Part 1: r = r_t\n            mask1 = r_vec = r_t\n            r1 = r_vec[mask1]\n            m_vals[mask1] = 4 * np.pi * RHO_C * (r1**3 / 3 - a * r1**5 / (5 * R**2))\n\n            # Part 2: r > r_t\n            mask2 = r_vec > r_t\n            if np.any(mask2):\n                r2 = r_vec[mask2]\n                m_rt = 4 * np.pi * RHO_C * (r_t**3 / 3 - a * r_t**5 / (5 * R**2))\n                m_vals[mask2] = m_rt + 4 * np.pi * EPSILON_RHO * (r2**3 - r_t**3) / 3\n            \n            return m_vals\n\n        def V(r_vec):\n            if beta == 0.0:\n                return np.zeros_like(r_vec)\n            return beta * G * M(r_vec) / (r_vec + EPSILON_R)**3\n\n        # --- 2. Build Matrices A and B ---\n        dim = N - 1\n        A = np.zeros((dim, dim))\n        B = np.zeros((dim, dim))\n\n        rho_nodes = rho(r_nodes)\n        c2_mid = c2(r_midpoints)\n        V_nodes = V(r_nodes)\n\n        # Mass matrix B\n        np.fill_diagonal(B, rho_nodes)\n\n        # Stiffness matrix A\n        h2 = h**2\n        \n        # Fill tridiagonal entries for rows 1 to N-2 (0-based index)\n        # This covers i=1..dim-2, i.e. r_2 to r_{N-2}\n        for i in range(1, dim - 1):\n            A[i, i-1] = -c2_mid[i] / h2\n            A[i, i]   = (c2_mid[i] + c2_mid[i+1]) / h2 + V_nodes[i]\n            A[i, i+1] = -c2_mid[i+1] / h2\n\n        # First row (i=0, for r_1) with Neumann BC y'(0)=0\n        if dim > 1:\n            A[0, 0] = c2_mid[1] / h2 + V_nodes[0]\n            A[0, 1] = -c2_mid[1] / h2\n            A[1, 0] = -c2_mid[1] / h2 # Symmetry\n\n        # Last row (i=dim-1, for r_{N-1}) with Dirichlet BC y(R)=0\n        if dim > 0:\n            A[dim-1, dim-1] = (c2_mid[dim-1] + c2_mid[dim]) / h2 + V_nodes[dim-1]\n        if dim > 1:\n            A[dim-1, dim-2] = -c2_mid[dim-1] / h2\n            \n        # Case for dim=1 (N=2)\n        if dim == 1:\n            A[0,0] = (c2_mid[0] + c2_mid[1])/h2 + V_nodes[0]\n\n\n        # --- 3. Iterative Solvers ---\n        c_nodes_sq = c2(r_nodes)\n        c_mean_sq = np.mean(c_nodes_sq)\n        mu = KAPPA * (np.pi * np.sqrt(c_mean_sq) / R)**2\n        \n        x0 = np.sin(np.pi * r_nodes / R)\n        A_norm = scipy.linalg.norm(A, 2)\n\n        # Method 1: Unscaled\n        k_unscaled = K_MAX\n        try:\n            x = x0 / np.sqrt(x0.T @ B @ x0)\n            shift_matrix = A - mu * B\n            for k in range(1, K_MAX + 1):\n                b_vec = B @ x\n                u = np.linalg.solve(shift_matrix, b_vec)\n                norm_u_B = np.sqrt(u.T @ B @ u)\n                if norm_u_B == 0: break\n                x = u / norm_u_B\n                lambda_ = x.T @ A @ x\n                residual = np.linalg.norm(A @ x - lambda_ * B @ x, 2) / A_norm\n                if residual  TOLERANCE:\n                    k_unscaled = k\n                    break\n        except np.linalg.LinAlgError:\n            k_unscaled = K_MAX\n\n        # Method 2: Scaled\n        k_scaled = K_MAX\n        try:\n            B_diag = np.diag(B)\n            S_diag = 1.0 / np.sqrt(B_diag)\n            S_inv_diag = np.sqrt(B_diag)\n            S = np.diag(S_diag)\n            S_inv = np.diag(S_inv_diag)\n            \n            C = S @ A @ S\n            \n            z0 = S_inv @ x0\n            z = z0 / np.linalg.norm(z0, 2)\n            \n            shift_C_matrix = C - mu * np.identity(dim)\n\n            for k in range(1, K_MAX + 1):\n                z_next = np.linalg.solve(shift_C_matrix, z)\n                norm_z_next = np.linalg.norm(z_next, 2)\n                if norm_z_next == 0: break\n                z = z_next / norm_z_next\n                lambda_ = z.T @ C @ z\n                x = S @ z\n                residual = np.linalg.norm(A @ x - lambda_ * B @ x, 2) / A_norm\n                if residual  TOLERANCE:\n                    k_scaled = k\n                    break\n        except np.linalg.LinAlgError:\n            k_scaled = K_MAX\n            \n        results.append(k_unscaled - k_scaled)\n\n    # --- 4. Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3526012"}]}