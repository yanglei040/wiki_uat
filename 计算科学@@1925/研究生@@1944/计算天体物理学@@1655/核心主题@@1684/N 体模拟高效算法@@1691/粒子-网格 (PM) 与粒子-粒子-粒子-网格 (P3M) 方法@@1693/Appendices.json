{"hands_on_practices": [{"introduction": "任何粒子-网格 (PM) 方法的核心操作都是将离散粒子的属性（如质量）分配到规则的网格上。这个过程是将粒子描述转换为场描述的关键第一步，从而能够利用快速傅里叶变换 (FFT) 等高效算法来求解引力势。这个练习 [@problem_id:3529293] 提供了一个对“单元内云” (Cloud-In-Cell, CIC) 方案进行动手计算的机会，这是一种在精度和计算效率之间取得良好平衡的常用分配方法。通过亲手计算单个粒子的质量如何分布到其周围的网格节点，您可以对这一基本过程建立起具体而深入的理解。", "problem": "考虑在粒子-网格（PM）方法中使用的均匀笛卡尔网格，其网格节点位于位置 $(i h, j h, k h)$，其中 $i$、$j$ 和 $k$ 为整数，$h$ 是均匀的网格间距。在云中单元（CIC）质量分配方案中，粒子质量通过一个可分离的分段线性形函数分配到网格节点上，该函数质量守恒，并由包含该粒子的单元的 $8$ 个角节点支持。\n\n一个单位质量的单个粒子位于位置 $\\boldsymbol{x}_{p} = (0.3 h, 0.7 h, 0.1 h)$，该位置处于由平面 $x=0$、$x=h$、$y=0$、$y=h$、$z=0$ 和 $z=h$ 界定的基本单元内部。使用云中单元（CIC）分配规则，按以下固定顺序计算沉积到包围单元的 $8$ 个相邻角节点的质量分数：\n$(0,0,0)$、$(h,0,0)$、$(0,h,0)$、$(h,h,0)$、$(0,0,h)$、$(h,0,h)$、$(0,h,h)$、$(h,h,h)$。\n\n将每个分数表示为精确有理数，并以单个行向量的形式呈现最终答案。无需四舍五入。这些分数是无量纲的。", "solution": "用户希望解决一个粒子-网格问题。首先验证该问题。\n\n### 第一步：提取已知条件\n-   **网格类型**：均匀笛卡尔网格，网格节点位于位置 $(i h, j h, k h)$，其中 $i$、$j$ 和 $k$ 为整数。\n-   **网格间距**：$h$ 是均匀的网格间距。\n-   **分配方案**：云中单元（CIC），被描述为一个可分离、分段线性的形函数，该函数质量守恒，并由 8 个角节点支持。\n-   **粒子属性**：单个单位质量的粒子，$m_p = 1$。\n-   **粒子位置**：$\\boldsymbol{x}_{p} = (0.3 h, 0.7 h, 0.1 h)$。\n-   **包围单元**：该单元由平面 $x=0$、$x=h$、$y=0$、$y=h$、$z=0$ 和 $z=h$ 界定。其八个角节点位于 $(ih, jh, kh)$，其中 $i,j,k \\in \\{0,1\\}$。\n-   **任务**：计算沉积到 8 个相邻角节点的质量分数。\n-   **输出顺序**：分数必须按以下固定顺序对应节点：$(0,0,0)$、$(h,0,0)$、$(0,h,0)$、$(h,h,0)$、$(0,0,h)$、$(h,0,h)$、$(0,h,h)$、$(h,h,h)$。\n-   **输出格式**：每个分数必须是精确有理数，并以单个行向量的形式呈现。\n\n### 第二步：使用提取的已知条件进行验证\n-   **科学性**：该问题描述了云中单元（CIC）方案，这是计算天体物理学中用于 N 体模拟的一种标准且正确的方法。其原理是可靠的。\n-   **适定性**：该问题是适定的。粒子的位置在一个特定单元内被明确定义，并且 CIC 方法提供了一个唯一且稳定的算法来分配质量。\n-   **目标**：语言精确无歧义。\n-   **完整性**：所有必要信息（粒子位置、质量、单元定义、分配方案）均已提供。\n-   **一致性**：没有内部矛盾。\n\n### 第三步：结论与行动\n问题有效。将提供解答。\n\n***\n\n云中单元（CIC）质量分配方案将粒子的质量分配到包含它的网格单元的 $8$ 个顶点上。这种分配等效于三线性插值。分配给每个顶点的质量分数与该顶点对角方向的子长方体的体积成正比，该子长方体由穿过粒子位置且平行于单元面的平面构成。\n\n一个单位质量的粒子 $m_p=1$ 位于位置 $\\boldsymbol{x}_{p} = (x_p, y_p, z_p) = (0.3h, 0.7h, 0.1h)$。包含该粒子的基本单元由 $8$ 个角节点定义，其位置为 $\\boldsymbol{x}_{ijk} = (ih, jh, kh)$，其中 $h$ 是网格间距，$i, j, k \\in \\{0, 1\\}$。\n\n首先，我们定义粒子在该单元内相对于原点 $(0,0,0)$ 处节点的归一化无量纲坐标：\n$$ t_x = \\frac{x_p - 0}{h} = \\frac{0.3h}{h} = 0.3 $$\n$$ t_y = \\frac{y_p - 0}{h} = \\frac{0.7h}{h} = 0.7 $$\n$$ t_z = \\frac{z_p - 0}{h} = \\frac{0.1h}{h} = 0.1 $$\n粒子位于由归一化坐标定义的单位立方体内的归一化位置 $(t_x, t_y, t_z) = (0.3, 0.7, 0.1)$。\n\nCIC 方案使用可分离的分配函数，这意味着一个节点的总权重是一维线性插值权重的乘积。对于给定的维度（例如 $x$ 维度），分配给边界节点 $i=0$ 和 $i=1$ 的权重为：\n$$ w_x(0) = 1 - t_x $$\n$$ w_x(1) = t_x $$\n$y$ 和 $z$ 维度的权重类似：\n$$ w_y(0) = 1 - t_y, \\quad w_y(1) = t_y $$\n$$ w_z(0) = 1 - t_z, \\quad w_z(1) = t_z $$\n分配给节点 $(ih, jh, kh)$ 的质量分数 $f_{ijk}$ 由这些一维权重的乘积给出：\n$$ f_{ijk} = w_x(i) \\cdot w_y(j) \\cdot w_z(k) $$\n由于粒子质量为 $m_p=1$，这些分数就是沉积在网格节点上的绝对质量。\n\n使用粒子的归一化位置，我们计算一维权重：\n$$ w_x(0) = 1 - 0.3 = 0.7 = \\frac{7}{10} \\quad \\text{和} \\quad w_x(1) = 0.3 = \\frac{3}{10} $$\n$$ w_y(0) = 1 - 0.7 = 0.3 = \\frac{3}{10} \\quad \\text{和} \\quad w_y(1) = 0.7 = \\frac{7}{10} $$\n$$ w_z(0) = 1 - 0.1 = 0.9 = \\frac{9}{10} \\quad \\text{和} \\quad w_z(1) = 0.1 = \\frac{1}{10} $$\n\n现在，我们按指定顺序计算 $8$ 个节点中每个节点的质量分数。\n\n1.  节点位于 $(0,0,0)$，对应于 $(i,j,k)=(0,0,0)$:\n    $f_{000} = w_x(0) \\cdot w_y(0) \\cdot w_z(0) = \\frac{7}{10} \\times \\frac{3}{10} \\times \\frac{9}{10} = \\frac{189}{1000}$\n\n2.  节点位于 $(h,0,0)$，对应于 $(i,j,k)=(1,0,0)$:\n    $f_{100} = w_x(1) \\cdot w_y(0) \\cdot w_z(0) = \\frac{3}{10} \\times \\frac{3}{10} \\times \\frac{9}{10} = \\frac{81}{1000}$\n\n3.  节点位于 $(0,h,0)$，对应于 $(i,j,k)=(0,1,0)$:\n    $f_{010} = w_x(0) \\cdot w_y(1) \\cdot w_z(0) = \\frac{7}{10} \\times \\frac{7}{10} \\times \\frac{9}{10} = \\frac{441}{1000}$\n\n4.  节点位于 $(h,h,0)$，对应于 $(i,j,k)=(1,1,0)$:\n    $f_{110} = w_x(1) \\cdot w_y(1) \\cdot w_z(0) = \\frac{3}{10} \\times \\frac{7}{10} \\times \\frac{9}{10} = \\frac{189}{1000}$\n\n5.  节点位于 $(0,0,h)$，对应于 $(i,j,k)=(0,0,1)$:\n    $f_{001} = w_x(0) \\cdot w_y(0) \\cdot w_z(1) = \\frac{7}{10} \\times \\frac{3}{10} \\times \\frac{1}{10} = \\frac{21}{1000}$\n\n6.  节点位于 $(h,0,h)$，对应于 $(i,j,k)=(1,0,1)$:\n    $f_{101} = w_x(1) \\cdot w_y(0) \\cdot w_z(1) = \\frac{3}{10} \\times \\frac{3}{10} \\times \\frac{1}{10} = \\frac{9}{1000}$\n\n7.  节点位于 $(0,h,h)$，对应于 $(i,j,k)=(0,1,1)$:\n    $f_{011} = w_x(0) \\cdot w_y(1) \\cdot w_z(1) = \\frac{7}{10} \\times \\frac{7}{10} \\times \\frac{1}{10} = \\frac{49}{1000}$\n\n8.  节点位于 $(h,h,h)$，对应于 $(i,j,k)=(1,1,1)$:\n    $f_{111} = w_x(1) \\cdot w_y(1) \\cdot w_z(1) = \\frac{3}{10} \\times \\frac{7}{10} \\times \\frac{1}{10} = \\frac{21}{1000}$\n\n作为一致性检查，我们验证质量分数的总和是否等于 $1$，这是 CIC 方案的一个必要属性（质量守恒）。\n$$ \\sum_{i,j,k \\in \\{0,1\\}} f_{ijk} = \\frac{1}{1000} (189 + 81 + 441 + 189 + 21 + 9 + 49 + 21) = \\frac{1000}{1000} = 1 $$\n总和证实了计算的正确性。最终答案是这些分数的有序列表。\n得到的质量分数行向量为：\n$$ \\begin{pmatrix} \\frac{189}{1000}  \\frac{81}{1000}  \\frac{441}{1000}  \\frac{189}{1000}  \\frac{21}{1000}  \\frac{9}{1000}  \\frac{49}{1000}  \\frac{21}{1000} \\end{pmatrix} $$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{189}{1000}  \\frac{81}{1000}  \\frac{441}{1000}  \\frac{189}{1000}  \\frac{21}{1000}  \\frac{9}{1000}  \\frac{49}{1000}  \\frac{21}{1000}\n\\end{pmatrix}\n}\n$$", "id": "3529293"}, {"introduction": "掌握了质量分配之后，下一步就是利用网格计算的力来推动粒子运动。这个练习 [@problem_id:3529327] 将引导您在一个简化的静态引力势背景下，完成一个完整的PM模拟周期。您将构建一个代表Plummer球体引力势的网格，使用三线性插值从网格上获取作用在粒子上的力，并采用辛积分方法（蛙跳法）来更新粒子的轨道。通过检验能量守恒，您将实践一种验证N体模拟代码准确性的标准方法，从而将PM方法的各个组成部分融会贯通。", "problem": "考虑一个单个测试粒子在一个固定的、与Plummer球体模型相对应的球对称引力势中运动。在一个立方体区域内的均匀笛卡尔网格上，使用粒子-网格 (PM) 方法对该势进行离散化，并使用时间对称的蛙跳格式对粒子的运动进行积分，积分时间恰好为一个圆形轨道的轨道周期。估算长期能量误差作为时间步长 $\\Delta t$ 的函数。所有物理量均以无量纲的代码单位表示，其中引力常数 $G$ 等于 $1$。\n\nPlummer球体模型的引力势由经过充分检验的公式定义：\n$$\n\\Phi(r) = -\\frac{G M}{\\sqrt{r^2 + a^2}},\n$$\n其中 $r$ 是距原点的径向距离，$M$ 是总质量，$a$ 是软化长度。引力加速度由Newton第二定律和势的梯度给出：\n$$\n\\mathbf{a}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x}).\n$$\n\n您必须通过在均匀网格上对 $\\Phi(\\mathbf{x})$ 进行采样，并使用有限差分法在网格上计算 $\\nabla \\Phi(\\mathbf{x})$，来构建静态势的PM表示。使用三线性插值来计算粒子位置处的势及其梯度。然后，使用一个遵守Newton第二定律的蛙跳时间积分器 (kick-drift-kick) 来积分粒子的轨道。\n\n假设在无量纲代码单位下使用以下固定参数：\n- $G = 1$, $M = 1$, $a = 0.1$。\n- 立方体区域为 $[-L/2, L/2]^3$，其中 $L = 4$。\n- 使用均匀网格，每个维度上有 $N = 64$ 个节点。\n- 将粒子初始化于 $\\mathbf{x}_0 = (r_0, 0, 0)$，其中 $r_0 = 1$。选择初始速度为 $\\mathbf{v}_0 = (0, v_{\\mathrm{circ}}, 0)$，其中圆周速度 $v_{\\mathrm{circ}}$ 通过使向心加速度与Plummer势中的引力加速度相等来计算：\n$$\n\\frac{v_{\\mathrm{circ}}^2}{r_0} = \\frac{G M r_0}{(r_0^2 + a^2)^{3/2}}.\n$$\n\n使用圆形轨道周期\n$$\nT = \\frac{2\\pi r_0}{v_{\\mathrm{circ}}},\n$$\n其中角度以弧度为单位。\n\n将位置为 $\\mathbf{x}$、速度为 $\\mathbf{v}$ 时的总机械能定义为\n$$\nE = \\frac{1}{2}\\|\\mathbf{v}\\|^2 + \\Phi(\\mathbf{x}),\n$$\n其中 $\\Phi(\\mathbf{x})$ 是通过对网格上的PM势进行三线性插值获得的，$\\|\\mathbf{v}\\|$ 是欧几里得范数。积分一个轨道周期后的长期能量误差是绝对分数差\n$$\n\\epsilon = \\left|\\frac{E(T) - E(0)}{E(0)}\\right|.\n$$\n以十进制数（无量纲）的形式报告 $\\epsilon$。\n\n实现以下步骤：\n1. 在网格上构建PM势 $\\Phi$，并使用内部中心差分和边界单边差分在网格节点上计算其梯度 $\\nabla \\Phi$。\n2. 对于给定的 $\\Delta t$，使用蛙跳法和三线性插值计算中间位置的加速度，积分恰好一个周期 $T$。\n3. 使用PM插值势计算 $E(0)$ 和 $E(T)$，并计算返回长期能量误差 $\\epsilon$。\n\n测试组：\n对于上述相同的设置，评估以下时间步长的长期能量误差 $\\epsilon$，每个步长都被选择为可以整除周期：\n- $\\Delta t = T/200$,\n- $\\Delta t = T/100$,\n- $\\Delta t = T/50$,\n- $\\Delta t = T/20$,\n- $\\Delta t = T/8$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”）。每个结果是对应于上述顺序中 $\\Delta t$ 的 $\\epsilon$ 值。所有输出均为无量纲小数。", "solution": "用户提供了一个来自计算天体物理学的问题，要求模拟一个粒子的轨道，并评估粒子-网格 (PM) 格式的能量守恒性。这个问题是有效的，因为它有科学依据、是良定的和客观的。它为标准的计算实验提供了一套完整且一致的参数、初始条件和数值方法。\n\n解决方案如下：\n\n1.  **系统定义和初始条件：**\n    问题描述了一个测试粒子在一个由Plummer球体产生的静态引力势的影响下运动，其势为 $\\Phi(r) = -G M / \\sqrt{r^2 + a^2}$。参数以无量纲代码单位给出，$G=1$，$M=1$，软化长度 $a=0.1$。粒子在 $x-y$ 平面内以半径 $r_0=1$ 的圆形轨道上被初始化。圆周速度 $v_{\\mathrm{circ}}$ 通过平衡引力与向心力来确定：\n    $$\n    \\frac{v_{\\mathrm{circ}}^2}{r_0} = |\\mathbf{a}(r_0)| = \\left|-\\frac{d\\Phi}{dr}\\right|_{r=r_0} = \\frac{G M r_0}{(r_0^2 + a^2)^{3/2}}\n    $$\n    这给出了初始位置 $\\mathbf{x}_0 = (r_0, 0, 0)$ 和初始速度 $\\mathbf{v}_0 = (0, v_{\\mathrm{circ}}, 0)$。轨道周期，即总积分时间，为 $T = 2\\pi r_0 / v_{\\mathrm{circ}}$。\n\n2.  **粒子-网格 (PM) 离散化：**\n    PM方法的核心是在一个离散网格上表示连续的引力场。模拟在一个以原点为中心、边长为 $L=4$ 的立方体区域内进行。\n    -   **网格生成**：构建一个每个维度有 $N=64$ 个节点的均匀笛卡尔网格。网格间距为 $h = L / (N-1)$。\n    -   **势的采样**：在 $N \\times N \\times N$ 个网格节点中的每一个坐标处计算解析Plummer势 $\\Phi(\\mathbf{x})$，并将其存储在一个三维数组 $\\Phi_{\\text{grid}}$ 中。\n    -   **力场计算**：通过对势网格 $\\Phi_{\\text{grid}}$ 求数值梯度，在网格上计算引力加速度场 $\\mathbf{a}(\\mathbf{x}) = -\\nabla\\Phi(\\mathbf{x})$。按规定，梯度计算对内部节点使用二阶中心差分，对边界节点使用一阶单边差分。这会产生三个三维数组 $\\mathbf{a}_{x, \\text{grid}}$、$\\mathbf{a}_{y, \\text{grid}}$ 和 $\\mathbf{a}_{z, \\text{grid}}$，分别表示每个网格节点上加速度场的分量。\n\n3.  **粒子积分：**\n    为了积分粒子的运动方程 $\\ddot{\\mathbf{x}} = \\mathbf{a}(\\mathbf{x})$，我们需要粒子位置处的加速度，而该位置通常不与网格节点重合。\n    -   **场插值**：使用三线性插值来计算任意粒子位置 $\\mathbf{x}$ 处的势 $\\Phi$ 和加速度分量 $\\mathbf{a}$。这是通过找到包含粒子的网格单元，并对该单元8个角点上的值进行加权平均来实现的。权重由粒子在单元内的分数位置确定。\n    -   **蛙跳积分 (Kick-Drift-Kick)**：使用时间对称的蛙跳积分器来推进粒子的状态 $(\\mathbf{x}(t), \\mathbf{v}(t))$。使用的具体变体是“速度Verlet”算法，它等价于Kick-Drift-Kick (KDK) 格式。对于单个时间步 $\\Delta t$，从状态 $(\\mathbf{x}_n, \\mathbf{v}_n)$ 更新到 $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$ 的过程是：\n        1.  **Kick:** $\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{x}_n) \\frac{\\Delta t}{2}$\n        2.  **Drift:** $\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1/2} \\Delta t$\n        3.  **Kick:** $\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\mathbf{a}(\\mathbf{x}_{n+1}) \\frac{\\Delta t}{2}$\n    该格式对于 $\\Delta t$ 是二阶精度的，并且是辛的，这导致了其优异的长期能量守恒特性（即没有长期能量漂移）。\n\n4.  **能量误差计算：**\n    粒子的总能量是使用PM插值势而不是解析势来定义的，以便一致地评估数值方法本身的误差。在给定状态 $(\\mathbf{x}, \\mathbf{v})$ 下的能量是：\n    $$\n    E = \\frac{1}{2}\\|\\mathbf{v}\\|^2 + \\Phi_{\\text{interp}}(\\mathbf{x})\n    $$\n    初始能量 $E(0)$ 是使用初始状态 $(\\mathbf{x}_0, \\mathbf{v}_0)$ 计算的。最终能量 $E(T)$ 是在积分完一个完整周期 $T$ 后计算的。长期能量误差 $\\epsilon$ 是绝对分数差：\n    $$\n    \\epsilon = \\left|\\frac{E(T) - E(0)}{E(0)}\\right|\n    $$\n    对几个不同的时间步长 $\\Delta t$ 重复此计算，这些步长被选为周期 $T$ 的整数分之一。由于蛙跳积分器的局部截断误差为 $\\mathcal{O}(\\Delta t^3)$ 阶，因此在固定时间间隔内的全局能量误差预期会按 $\\epsilon \\propto \\Delta t^2$ 的比例变化。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the particle-mesh orbit integration problem.\n    \"\"\"\n    # 1. System Parameters and Initial Conditions\n    G = 1.0\n    M = 1.0\n    a = 0.1\n    L = 4.0\n    N = 64\n    r0 = 1.0\n\n    # Test cases: time step as a fraction of the period T\n    T_divisors = [200, 100, 50, 20, 8]\n\n    # Derived constants and initial conditions\n    h = L / (N - 1)\n    grid_coords = np.linspace(-L / 2, L / 2, N)\n\n    # Circular velocity for a Plummer potential\n    v_circ_sq = (G * M * r0**2) / (r0**2 + a**2)**1.5\n    v_circ = np.sqrt(v_circ_sq)\n    \n    # Orbital period\n    T = 2 * np.pi * r0 / v_circ\n\n    # Initial state vectors\n    x0 = np.array([r0, 0.0, 0.0])\n    v0 = np.array([0.0, v_circ, 0.0])\n\n    # 2. PM Grid Construction\n    # Create grid coordinate arrays\n    X, Y, Z = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n\n    # Compute potential on the grid\n    R_sq = X**2 + Y**2 + Z**2\n    Phi_grid = -G * M / np.sqrt(R_sq + a**2)\n\n    # Compute acceleration field using numerical gradient of the potential field\n    # np.gradient uses 2nd-order central differences for the interior\n    # and 1st-order one-sided differences at boundaries, as required.\n    # The gradient is returned as a list of arrays [d/dx, d/dy, d/dz]\n    # because meshgrid's indexing was 'ij'.\n    grad_Phi = np.gradient(Phi_grid, h)\n    Acc_x_grid = -grad_Phi[0]\n    Acc_y_grid = -grad_Phi[1]\n    Acc_z_grid = -grad_Phi[2]\n\n    # 3. Create Interpolators\n    # Stack all fields for efficient multi-value interpolation\n    values_to_interpolate = np.stack(\n        [Phi_grid, Acc_x_grid, Acc_y_grid, Acc_z_grid], axis=-1\n    )\n    \n    # The interpolator function will be used to get potential and acceleration\n    # at any off-grid particle position. 'linear' corresponds to trilinear.\n    interpolator = RegularGridInterpolator(\n        (grid_coords, grid_coords, grid_coords),\n        values_to_interpolate,\n        method='linear',\n        bounds_error=True  # Ensure particle stays within the simulation box\n    )\n\n    def get_potential_and_accel(pos):\n        # The interpolator expects a (n_points, n_dims) array.\n        # For a single point, we reshape and then squeeze the output.\n        interp_values = interpolator(pos.reshape(1, -1))\n        return interp_values[0] # Returns [phi, ax, ay, az]\n\n    # Calculate initial energy E(0) using the interpolated potential\n    phi0, _, _, _ = get_potential_and_accel(x0)\n    E0 = 0.5 * np.dot(v0, v0) + phi0\n\n    results = []\n    \n    # 4. Integration and Error Calculation Loop\n    for divisor in T_divisors:\n        dt = T / divisor\n        N_steps = int(divisor)\n\n        # Reset particle state for each test run\n        x = np.copy(x0)\n        v = np.copy(v0)\n\n        # KDK Leapfrog / Velocity Verlet Integrator\n        # Get initial acceleration\n        _, ax, ay, az = get_potential_and_accel(x)\n        a_current = np.array([ax, ay, az])\n\n        for _ in range(N_steps):\n            # Kick (half step)\n            v_half_step = v + a_current * dt / 2.0\n            # Drift (full step)\n            x = x + v_half_step * dt\n            # Update acceleration at the new position\n            _, ax_new, ay_new, az_new = get_potential_and_accel(x)\n            a_new = np.array([ax_new, ay_new, az_new])\n            # Kick (second half step)\n            v = v_half_step + a_new * dt / 2.0\n            # Store the new acceleration for the next iteration\n            a_current = a_new\n        \n        # At this point, x and v are the final state at time T\n        x_final = x\n        v_final = v\n\n        # Calculate final energy E(T)\n        phi_final, _, _, _ = get_potential_and_accel(x_final)\n        E_final = 0.5 * np.dot(v_final, v_final) + phi_final\n\n        # Calculate and store the secular energy error\n        error = np.abs((E_final - E0) / E0)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3529327"}, {"introduction": "对于计算天体物理学的研究生来说，理解并量化数值方法的内在局限性至关重要。PM方法虽然高效，但在将连续密度场离散化的过程中会引入诸如混叠 (aliasing) 之类的数值效应，这在进行功率谱等傅里叶空间分析时尤其明显。这个高级练习 [@problem_id:3529375] 模拟了一个受控的计算实验，您将在此实验中为不同的质量分配方案（如NGP、CIC和TSC）所产生的混叠效应建模，并设计一个反卷积方案来修正这些效应。这项实践旨在培养您在研究层面处理和校正模拟数据，以恢复真实物理信号的关键技能。", "problem": "您需要实现一个计算实验，该实验基于粒子-网格 (PM) 和 粒子-粒子 粒子-网格 (P³M) 方法，用以分析并校正因质量分配而在快速傅里叶变换 (FFT) 功率谱估计中产生的混叠效应。考虑一个边长为 $L$ 的三维周期性盒子，它被离散化为一个均匀网格，每维有 $N$ 个单元格，网格间距为 $d x$。该实验必须使用一个具有已知输入功率谱 $P(k)$ 的受控各向同性密度场，并模拟质量分配对从离散化场中估计 $P(k)$ 的影响。然后，您必须设计一种反卷积方法，将功率谱恢复到目标分数误差以内。\n\n起点是各向同性输入功率谱 $P(k)$ 的定义，由 $P(k) = A \\, k^n \\, \\exp\\!\\left[-\\left( \\frac{k}{k_0} \\right)^2 \\right]$ 给出，其中 $A$、$n$ 和 $k_0$ 是常数，$k \\equiv |\\boldsymbol{k}|$ 是波矢量的模。网格间距为 $d x$，基波数为 $k_f = \\frac{2 \\pi}{L}$，采样波数为 $k_s = \\frac{2 \\pi}{d x}$，奈奎斯特波数为 $k_N = \\frac{\\pi}{d x}$。为确保具体性和计算可复现性，设 $d x = 1$ (无量纲单位)，因此 $L = N$，$k_f = \\frac{2 \\pi}{N}$，$k_s = 2 \\pi$，$k_N = \\pi$。使用 $A=1$ 和 $n=1$，并设置 $k_0 = \\alpha \\, k_N$，其中 $\\alpha = 0.9$。所有物理量均为无量纲量，角度以弧度为单位。\n\n当使用质量分配到网格上估计功率谱时，您必须模拟 PM 和 P³M 代码中常用的分配核的影响：\n- 最近邻网格点 (NGP)，\n- 云中单元 (CIC)，\n- 三角形云 (TSC)。\n\n将这些视为 $p$ 阶均匀 B 样条质量分配核，其中 NGP 为 $p=1$，CIC 为 $p=2$，TSC 为 $p=3$。傅里叶空间中分配窗口的模在笛卡尔分量上是可分离的，由 $W(\\boldsymbol{k}) = \\prod_{i \\in \\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left( \\frac{k_i d x}{2} \\right) \\right]^p$ 给出，其中 $\\mathrm{sinc}(x) \\equiv \\frac{\\sin x}{x}$，$k_i$ 是 $\\boldsymbol{k}$ 的笛卡尔分量。在主傅里叶域上，观测到的、离散采样的、质量分配后的功率谱估计 $P_{\\mathrm{meas}}(\\boldsymbol{k})$ 受到采样混叠的影响。它可以被建模为由采样引起的整数混叠像的求和：在 $\\boldsymbol{k} + \\boldsymbol{g}$ 处的贡献，其中 $\\boldsymbol{g}$ 的分量为 $g_i = m_i \\, k_s$，且 $m_i \\in \\mathbb{Z}$。您必须使用一个有限模板 $m_i \\in \\{-1, 0, +1\\}$ 来近似混叠和，这对于足够平滑的 $P(k)$ 能够捕捉到主要的混叠像。\n\n您的任务是：\n1. 在网格的主傅里叶域上构建各向同性输入 $P(k)$。\n2. 对于每种分配核，通过对所有 $\\boldsymbol{g}$（其中 $m_i \\in \\{-1,0,+1\\}$）求和 $P\\!\\left(|\\boldsymbol{k}+\\boldsymbol{g}|\\right) \\, \\left| W\\!\\left(\\boldsymbol{k}+\\boldsymbol{g}\\right) \\right|^2$，计算出预期的混叠、质量分配后的功率 $P_{\\mathrm{meas}}(\\boldsymbol{k})$。\n3. 设计一个反卷积估计器 $P_{\\mathrm{corr}}(\\boldsymbol{k})$，它移除分配窗口并减去对应于 $\\boldsymbol{g} \\neq \\boldsymbol{0}$ 的混叠贡献，仅使用上述指定的量，将 $P(k)$ 恢复到指定的目标分数误差范围内。通过在 $k = |\\boldsymbol{k}|$ 从 $k_{\\min} = k_f$ 到 $k_{\\max} = \\beta \\, k_N$（其中 $\\beta = 0.7$）的径向壳层中分箱来评估分数误差 $\\Delta P / P$，排除零模式。对于每个径向分箱，计算 $P_{\\mathrm{corr}}$ 的均值和 $P_{\\mathrm{true}}$ 的均值，然后计算该分箱中的分数误差为 $\\left| P_{\\mathrm{corr}} - P_{\\mathrm{true}} \\right| / P_{\\mathrm{true}}$。报告最大分箱分数误差作为该测试用例的性能指标。\n\n您的程序必须精确实现上述逻辑，并评估以下测试套件。对于每个测试用例，输出必须是一个布尔值，指示最大分箱分数误差是否小于或等于指定的目标阈值。对所有测试使用功率谱参数 $A=1$，$n=1$ 和 $k_0 = 0.9 \\, k_N$，以及 $d x = 1$（因此 $L=N$）：\n- 测试用例 1：$N=64$，分配核 $=$ CIC，$\\Delta P / P$ 的目标阈值 $=$ $0.02$。\n- 测试用例 2：$N=64$，分配核 $=$ NGP，$\\Delta P / P$ 的目标阈值 $=$ $0.05$。\n- 测试用例 3：$N=48$，分配核 $=$ TSC，$\\Delta P / P$ 的目标阈值 $=$ $0.01$。\n- 测试用例 4：$N=32$，分配核 $=$ NGP，$\\Delta P / P$ 的目标阈值 $=$ $0.02$。\n\n所有量均为无量纲。您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔列表的结果（例如，“[$\\mathrm{result}_1$,$\\mathrm{result}_2$,$\\mathrm{result}_3$,$\\mathrm{result}_4$]”），其中每个 $\\mathrm{result}_i$ 是测试用例 $i$ 的布尔值通过/失败结果。", "solution": "问题陈述已经过验证，被认为是科学上可靠、适定且内部一致的。它在计算天体物理学领域内提出了一个清晰、可形式化的计算实验，具体涉及粒子-网格 (PM) 和 粒子-粒子 粒子-网格 (P³M) 方法中的数值伪影。所有必要的参数和定义均已提供。因此，我们可以着手解决。\n\n这个问题的核心是模拟质量分配和采样对宇宙学功率谱估计的影响，然后设计并验证一个校正方案。该过程包括几个不同的步骤：定义真实的底层功率谱，模拟受数值伪影影响的“测量”谱，应用校正程序，以及量化校正结果的误差。\n\n首先，我们定义理论量。真实的、底层的各向同性功率谱由下式给出\n$$\nP(k) = A \\, k^n \\, \\exp\\!\\left[-\\left( \\frac{k}{k_0} \\right)^2 \\right]\n$$\n其中 $k = |\\boldsymbol{k}|$ 是波矢量 $\\boldsymbol{k}$ 的模。问题指定了无量纲参数 $A=1$、$n=1$ 和 $dx=1$。最后一个条件意味着盒子尺寸为 $L=N$，波数为 $k_f = \\frac{2\\pi}{N}$ (基波)，$k_s = 2\\pi$ (采样)，以及 $k_N = \\pi$ (奈奎斯特)。参数 $k_0$ 设置为 $k_0 = 0.9 \\, k_N = 0.9\\pi$。\n\n质量分配过程将粒子数据存放到网格上，在实空间中相当于一次卷积，这等同于在傅里叶空间中乘以一个窗口函数 $W(\\boldsymbol{k})$。对于指定的 $p$ 阶 B 样条核 (其中 NGP 为 $p=1$，CIC 为 $p=2$，TSC 为 $p=3$)，窗口函数为\n$$\nW(\\boldsymbol{k}) = \\prod_{i \\in \\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left( \\frac{k_i d x}{2} \\right) \\right]^p\n$$\n其中 $\\mathrm{sinc}(x) \\equiv \\frac{\\sin x}{x}$。当 $dx=1$ 时，这简化为 $W(\\boldsymbol{k}) = \\prod_{i \\in \\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left( \\frac{k_i}{2} \\right) \\right]^p$。\n\n在离散网格上进行采样的过程会引入混叠。在主傅里叶域 ($k_i \\in [-\\pi, \\pi)$) 中给定波矢量 $\\boldsymbol{k}$ 处的功率会受到来自更高频率模式在 $\\boldsymbol{k}+\\boldsymbol{g}$ 处的功率污染，其中 $\\boldsymbol{g}$ 是指向倒易格点的矢量，其分量为 $g_i = m_i k_s = 2\\pi m_i$，其中 $m_i$ 为整数。问题要求我们通过用一个 $3 \\times 3 \\times 3$ 模板（其中 $m_i \\in \\{-1, 0, +1\\}$）上的有限和来近似所有混叠的无限和，从而模拟测量的功率谱 $P_{\\mathrm{meas}}(\\boldsymbol{k})$。因此，测量谱的模型是：\n$$\nP_{\\mathrm{meas}}(\\boldsymbol{k}) = \\sum_{m_x, m_y, m_z \\in \\{-1, 0, 1\\}} P\\big(|\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}|\\big) \\, \\left| W(\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}) \\right|^2\n$$\n其中 $\\boldsymbol{g}_{\\boldsymbol{m}} = (2\\pi m_x, 2\\pi m_y, 2\\pi m_z)$。这个和明确包括了在 $\\boldsymbol{k}$ 处的真实功率（$\\boldsymbol{m}=(0,0,0)$ 项）以及来自其 26 个最近的混叠像的贡献。\n\n下一个任务是设计一个反卷积估计器 $P_{\\mathrm{corr}}(\\boldsymbol{k})$，它“移除分配窗口并减去混叠贡献”。根据我们对 $P_{\\mathrm{meas}}(\\boldsymbol{k})$ 的模型，我们可以将期望项与混叠项分开：\n$$\nP_{\\mathrm{meas}}(\\boldsymbol{k}) = P(|\\boldsymbol{k}|) |W(\\boldsymbol{k})|^2 + \\sum_{\\boldsymbol{m} \\in \\{-1,0,1\\}^3, \\boldsymbol{m} \\neq \\boldsymbol{0}} P\\big(|\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}|\\big) \\, \\left| W(\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}) \\right|^2\n$$\n右侧的第二项代表混叠贡献，我们将其表示为 $C(\\boldsymbol{k})$。反卷积过程必须首先减去这个估计的混叠功率，然后除以窗口函数的影响。\n$$\nP_{\\mathrm{corr}}(\\boldsymbol{k}) = \\frac{P_{\\mathrm{meas}}(\\boldsymbol{k}) - C(\\boldsymbol{k})}{|W(\\boldsymbol{k})|^2}\n$$\n由于该问题是一个受控的数值实验，我们能够访问 $P(k)$ 和 $W(\\boldsymbol{k})$ 的解析形式，因此混叠校正项 $C(\\boldsymbol{k})$ 可以根据模型精确计算：\n$$\nC(\\boldsymbol{k}) = \\sum_{\\boldsymbol{m} \\in \\{-1,0,1\\}^3, \\boldsymbol{m} \\neq \\boldsymbol{0}} P\\big(|\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}|\\big) \\, \\left| W(\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}) \\right|^2\n$$\n将 $P_{\\mathrm{meas}}(\\boldsymbol{k})$ 和 $C(\\boldsymbol{k})$ 的表达式代入 $P_{\\mathrm{corr}}(\\boldsymbol{k})$ 的方程中，得到：\n$$\nP_{\\mathrm{corr}}(\\boldsymbol{k}) = \\frac{\\left( P(|\\boldsymbol{k}|) |W(\\boldsymbol{k})|^2 + C(\\boldsymbol{k}) \\right) - C(\\boldsymbol{k})}{|W(\\boldsymbol{k})|^2} = \\frac{P(|\\boldsymbol{k}|) |W(\\boldsymbol{k})|^2}{|W(\\boldsymbol{k})|^2} = P(|\\boldsymbol{k}|)\n$$\n这表明，根据构造，在每个网格点上校正后的功率谱 $P_{\\mathrm{corr}}(\\boldsymbol{k})$ 精确等于真实的功率谱 $P(|\\boldsymbol{k}|)$，前提是计算使用足够的数值精度进行。\n\n最后，我们通过计算分数误差来评估性能。评估在 $k = |\\boldsymbol{k}|$ 从 $k_{\\min} = k_f$ 到 $k_{\\max} = 0.7 k_N$ 的径向分箱中进行。对于每个分箱，我们计算校正功率的均值 $\\langle P_{\\mathrm{corr}} \\rangle$ 和真实功率的均值 $\\langle P_{\\mathrm{true}} \\rangle$，其中 $P_{\\mathrm{true}}(\\boldsymbol{k}) = P(|\\boldsymbol{k}|)$。由于在每个点 $\\boldsymbol{k}$ 上 $P_{\\mathrm{corr}}(\\boldsymbol{k}) = P_{\\mathrm{true}}(\\boldsymbol{k})$，它们在任何分箱上的均值也必须相同。因此，分数误差 $\\left| \\langle P_{\\mathrm{corr}} \\rangle - \\langle P_{\\mathrm{true}} \\rangle \\right| / \\langle P_{\\mathrm{true}} \\rangle$ 将为零，直到浮点运算误差为止。由于指定的误差阈值是非零的（从 $0.01$ 到 $0.05$），逻辑上的结论是所有测试用例都应该通过，因为标准双精度算术中的数值精度误差将小很多个数量级。\n\n因此，实现将是对这些步骤的仔细执行：\n1. 对于每个测试用例，建立 $N \\times N \\times N$ 的傅里叶空间波矢量网格 $\\boldsymbol{k}$。\n2. 通过对每个网格点求和 27 个混叠项，计算“测量”的功率谱 $P_{\\mathrm{meas}}(\\boldsymbol{k})$。\n3. 通过求和 26 个非中心的混叠项，计算校正项 $C(\\boldsymbol{k})$。\n4. 计算校正谱 $P_{\\mathrm{corr}}(\\boldsymbol{k}) = (P_{\\mathrm{meas}}(\\boldsymbol{k}) - C(\\boldsymbol{k})) / |W(\\boldsymbol{k})|^2$。\n5. 对 $P_{\\mathrm{corr}}(\\boldsymbol{k})$ 和真实功率 $P(|\\boldsymbol{k}|)$ 进行径向分箱，并计算它们分箱均值之间的最大分数误差。\n6. 将最大误差与给定的阈值进行比较，以确定布尔结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    # Global parameters from the problem statement\n    A_PARAM = 1.0\n    N_POWER_PARAM = 1.0\n    ALPHA_PARAM = 0.9\n    BETA_PARAM = 0.7\n    DX_PARAM = 1.0\n\n    # Mapping of kernel names to their B-spline order p\n    KERNEL_P_MAP = {\n        'NGP': 1,\n        'CIC': 2,\n        'TSC': 3,\n    }\n\n    def my_sinc(x):\n        \"\"\"\n        Implements sinc(x) = sin(x)/x, using the numerically stable numpy.sinc.\n        numpy.sinc(y) = sin(pi*y)/(pi*y), so with y = x/pi, we get sin(x)/x.\n        \"\"\"\n        return np.sinc(x / np.pi)\n\n    def true_power_spectrum(k, A, n, k0):\n        \"\"\"\n        Calculates the true isotropic power spectrum P(k) = A * k^n * exp(-(k/k0)^2).\n        \"\"\"\n        # The form is safe for k=0 when n>0. Add a small epsilon for robustness.\n        k_safe = np.maximum(k, 1e-30)\n        return A * np.power(k_safe, n) * np.exp(-(k / k0)**2)\n\n    def window_function_sq(kx, ky, kz, p, dx):\n        \"\"\"\n        Calculates the squared magnitude of the mass assignment window function |W(k)|^2.\n        \"\"\"\n        sinc_kx_arg = kx * dx / 2.0\n        sinc_ky_arg = ky * dx / 2.0\n        sinc_kz_arg = kz * dx / 2.0\n        \n        W_val = (my_sinc(sinc_kx_arg) * my_sinc(sinc_ky_arg) * my_sinc(sinc_kz_arg))**p\n        return W_val**2\n\n    def run_simulation(N, kernel, threshold):\n        \"\"\"\n        Performs the full simulation and validation for a single test case.\n        \"\"\"\n        p = KERNEL_P_MAP[kernel]\n        L = N * DX_PARAM\n\n        # Wavenumber setup\n        k_s = 2.0 * np.pi / DX_PARAM\n        k_N = np.pi / DX_PARAM\n        k_f = 2.0 * np.pi / L\n        k0 = ALPHA_PARAM * k_N\n\n        # Generate 3D k-space grid\n        k_coords_1d = 2 * np.pi * np.fft.fftfreq(N, d=DX_PARAM)\n        kx, ky, kz = np.meshgrid(k_coords_1d, k_coords_1d, k_coords_1d, indexing='ij')\n\n        # Model P_meas(k) by summing over the 3x3x3 alias stencil\n        P_meas = np.zeros((N, N, N), dtype=np.float64)\n        C_alias = np.zeros((N, N, N), dtype=np.float64)\n        alias_stencil_m = [-1, 0, 1]\n\n        for mx in alias_stencil_m:\n            for my in alias_stencil_m:\n                for mz in alias_stencil_m:\n                    g_vec = np.array([mx * k_s, my * k_s, mz * k_s])\n                    \n                    k_prime_x, k_prime_y, k_prime_z = kx + g_vec[0], ky + g_vec[1], kz + g_vec[2]\n                    k_prime_mag = np.sqrt(k_prime_x**2 + k_prime_y**2 + k_prime_z**2)\n                    \n                    p_true_aliased = true_power_spectrum(k_prime_mag, A_PARAM, N_POWER_PARAM, k0)\n                    w_sq_aliased = window_function_sq(k_prime_x, k_prime_y, k_prime_z, p, DX_PARAM)\n                    \n                    alias_term = p_true_aliased * w_sq_aliased\n                    P_meas += alias_term\n                    \n                    if not (mx == 0 and my == 0 and mz == 0):\n                        C_alias += alias_term\n        \n        # Compute the corrected power spectrum P_corr(k)\n        W_sq_k = window_function_sq(kx, ky, kz, p, DX_PARAM)\n        P_corr = (P_meas - C_alias) / (W_sq_k + 1e-40) # Epsilon for safety\n\n        # Evaluate fractional error in radial bins\n        k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n        P_grid_true = true_power_spectrum(k_mag, A_PARAM, N_POWER_PARAM, k0)\n\n        k_min_bin = k_f\n        k_max_bin = BETA_PARAM * k_N\n        \n        num_bins = 50 # A reasonable number of bins\n        bins = np.linspace(k_min_bin, k_max_bin, num_bins + 1)\n        \n        # Flatten arrays and exclude k=0 mode\n        k_mag_flat = k_mag.flatten()\n        nonzero_mask = k_mag_flat > 1e-9\n        \n        P_corr_flat = P_corr.flatten()[nonzero_mask]\n        P_grid_true_flat = P_grid_true.flatten()[nonzero_mask]\n        k_mag_flat_nonzero = k_mag_flat[nonzero_mask]\n\n        bin_indices = np.digitize(k_mag_flat_nonzero, bins)\n        \n        max_frac_error = 0.0\n        for i in range(1, len(bins)):\n            in_bin_mask = (bin_indices == i)\n            if not np.any(in_bin_mask):\n                continue\n                \n            mean_P_corr = np.mean(P_corr_flat[in_bin_mask])\n            mean_P_true = np.mean(P_grid_true_flat[in_bin_mask])\n            \n            if mean_P_true > 1e-30:\n                frac_error = np.abs(mean_P_corr - mean_P_true) / mean_P_true\n                if frac_error > max_frac_error:\n                    max_frac_error = frac_error\n                    \n        return max_frac_error = threshold\n\n    test_cases = [\n        (64, 'CIC', 0.02),\n        (64, 'NGP', 0.05),\n        (48, 'TSC', 0.01),\n        (32, 'NGP', 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, kernel, threshold = case\n        result = run_simulation(N, kernel, threshold)\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3529375"}]}