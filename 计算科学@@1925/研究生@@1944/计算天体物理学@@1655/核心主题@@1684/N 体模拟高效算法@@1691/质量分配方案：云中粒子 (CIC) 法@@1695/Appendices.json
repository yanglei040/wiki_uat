{"hands_on_practices": [{"introduction": "理解任何数值方案都始于其基本力学。第一个练习要求您在周期性的一维域中应用云中单元（CIC）插值规则，这是宇宙学模拟中的核心场景。通过计算边界附近一个粒子的权重，您将巩固对 CIC 在处理周期性空间的“环绕”特性时如何保持质量守恒的理解。", "problem": "考虑一个长度为 $L$ 的周期性一维域，该域被 $N$ 个均匀间隔的网格节点离散化，节点位置为 $x_i = i\\,\\Delta$，$i \\in \\{0,1,\\dots,N-1\\}$，网格间距为 $\\Delta \\equiv L/N$。在采用云中单元（Cloud-in-Cell, CIC）质量分配的粒子-网格方法中，一个位于位置 $x_p$、质量为 $m_p$ 的粒子通过将其狄拉克δ函数（Dirac delta）与一个一维的、紧支集、分段线性、支撑集宽度为 $2\\Delta$ 且单位归一化的 CIC 核函数进行卷积，从而对网格密度做出贡献。该域是严格周期性的，因此距离是使用周长为 $L$ 的圆上的最小间隔来测量的。\n\n一个粒子位于 $x_p = L - \\epsilon$，其中 $0  \\epsilon  \\Delta$。仅使用上述定义和圆上周期性距离的第一性原理，推导分配给网格节点 $i=N-1$ 和 $i=0$ 的归一化 CIC 权重 $w_i$，并明确证明对于该粒子，这些是仅有的非零贡献。同时证明总分配权重是守恒的。\n\n请以行矩阵 $\\begin{pmatrix} w_{N-1}  w_{0} \\end{pmatrix}$ 的形式给出最终答案，该答案应为关于 $\\epsilon$ 和 $\\Delta$ 的闭合形式函数。不需要进行数值计算，也不需要单位。最终答案必须是单一的解析表达式。", "solution": "一维的云中单元（CIC）质量分配方案是一种线性插值方法。对于一个位于网格单元中节点 $x_i$ 和 $x_{i+1}$ 之间的粒子，其位置为 $x_p$，它的质量被分配给这两个节点。权重与粒子到相对节点的距离成线性比例。\n\n网格节点的位置为 $x_i = i\\Delta$，$i \\in \\{0, 1, \\dots, N-1\\}$。网格间距为 $\\Delta = L/N$。域是周期性的，因此位置 $x=L$ 处的节点与位置 $x=0$ 处的节点相同。\n粒子位于 $x_p = L - \\epsilon$，其中 $0  \\epsilon  \\Delta$。\n\n我们必须首先确定粒子所在的网格单元。网格节点位于 $\\Delta$ 的整数倍位置上。节点 $i=N-1$ 位于 $x_{N-1} = (N-1)\\Delta = N\\Delta - \\Delta = L - \\Delta$。序列中的下一个节点将是 $i=N$，位于位置 $x_N = N\\Delta = L$。由于周期性，这个位置等同于位于 $x_0 = 0$ 的节点 $i=0$。\n\n粒子的位置是 $x_p = L - \\epsilon$。鉴于 $0  \\epsilon  \\Delta$，可以得出 $L - \\Delta  L - \\epsilon  L$。这意味着 $x_{N-1}  x_p  x_N$，其中 $x_N$ 是 $x_0$ 的周期性等效位置。因此，粒子位于连接节点 $i=N-1$ 和 $i=0$ 的网格单元中。在 CIC 方案下，这两个是仅有的会接收到非零权重的节点。\n\n让我们将该单元的“左”节点表示为 $x_{N-1}$，其“右”节点表示为 $x_0 \\equiv L$。该单元的宽度是 $\\Delta$。粒子在该单元内的位置，从左节点 $x_{N-1}$ 测量，是：\n$$d = x_p - x_{N-1} = (L - \\epsilon) - (L - \\Delta) = \\Delta - \\epsilon$$\n粒子距离左节点的分数距离是 $\\delta_{frac} = d / \\Delta$。\n$$\\delta_{frac} = \\frac{\\Delta - \\epsilon}{\\Delta} = 1 - \\frac{\\epsilon}{\\Delta}$$\n根据 CIC 算法，分配给右节点（$i=0$）的权重等于此分数距离，而分配给左节点（$i=N-1$）的权重是 $1$ 减去此分数距离。\n\n节点 $i=0$ 上的权重：\n$$w_0 = \\delta_{frac} = \\frac{\\Delta - \\epsilon}{\\Delta}$$\n\n节点 $i=N-1$ 上的权重：\n$$w_{N-1} = 1 - \\delta_{frac} = 1 - \\left(\\frac{\\Delta - \\epsilon}{\\Delta}\\right) = \\frac{\\Delta - (\\Delta - \\epsilon)}{\\Delta} = \\frac{\\epsilon}{\\Delta}$$\n\n为了证明这些是仅有的非零贡献，我们考虑相邻的节点。CIC 核函数 $W(x_p - x_i)$ 仅在 $|x_p - x_i|  \\Delta$ 时非零（使用周期性距离）。\n考虑节点 $i=N-2$：$x_{N-2} = (N-2)\\Delta = L - 2\\Delta$。周期性距离是：\n$$d(x_p, x_{N-2}) = |(L-\\epsilon) - (L-2\\Delta)| = |2\\Delta - \\epsilon|$$\n由于 $0  \\epsilon  \\Delta$，我们有 $\\Delta  2\\Delta - \\epsilon  2\\Delta$。这个距离大于 $\\Delta$，所以 $w_{N-2} = 0$。\n\n考虑节点 $i=1$：$x_1 = \\Delta$。周期性距离必须考虑域的环绕性质。直接距离是 $|x_p - x_1| = |(L-\\epsilon) - \\Delta| = L - \\Delta - \\epsilon$。跨越周期性边界的距离是 $\\epsilon + \\Delta$。最小间隔是：\n$$d(x_p, x_1) = \\min(L - \\Delta - \\epsilon, \\Delta + \\epsilon) = \\Delta + \\epsilon$$\n由于 $\\epsilon > 0$，这个距离大于 $\\Delta$，所以 $w_1 = 0$。\n所有其他节点都更远，所以它们的权重也为零。\n\n最后，我们证明总权重是守恒的（即权重之和为 $1$）。\n$$\\sum_i w_i = w_{N-1} + w_0 = \\frac{\\epsilon}{\\Delta} + \\frac{\\Delta-\\epsilon}{\\Delta} = \\frac{\\epsilon + \\Delta - \\epsilon}{\\Delta} = \\frac{\\Delta}{\\Delta} = 1$$\n总分配权重是守恒的，从而验证了推导出的表达式是归一化权重。\n\n最终结果是节点 $i=N-1$ 和 $i=0$ 的权重集。\n$w_{N-1} = \\frac{\\epsilon}{\\Delta}$\n$w_0 = \\frac{\\Delta - \\epsilon}{\\Delta}$", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{\\epsilon}{\\Delta}  \\frac{\\Delta - \\epsilon}{\\Delta} \\end{pmatrix}}$$", "id": "3516929"}, {"introduction": "将粒子分配到网格上不可避免地会改变密度场，这种效应最好通过傅里叶空间中的窗函数来量化。这个动手编程实践将引导您完成计算天体物理学中一个标准的验证测试：测量一个人造粒子晶体的功率谱，以精确验证 CIC 窗函数的理论模型及相关的混叠效应。成功完成此任务将增强您对用于分析大尺度结构的数值工具的信心。", "problem": "给定一个边长为 $L$ 的周期性立方体盒子，其中包含一个由点粒子构成的合成三维立方晶体。该晶体沿每个轴的晶格间距为 $a$，并对所有粒子施加一个全局偏移矢量 $\\boldsymbol{r}_0$（以避免与分析网格发生意外对齐）。目标是通过测量网格化功率谱，并将其与一个同时包含窗函数抑制和采样引起的混叠效应的理论预测进行比较，来验证云内插值（Cloud-in-Cell, CIC）质量分配窗函数模型。\n\n从以下基础概念出发：\n- 对于一组质量为 $m$、位置为 $\\boldsymbol{x}_j$ 的点粒子，其质量密度场 $\\rho(\\boldsymbol{x})$ 定义为 $\\rho(\\boldsymbol{x}) = \\sum_j m \\, \\delta_{\\mathrm{D}}(\\boldsymbol{x} - \\boldsymbol{x}_j)$，其中 $\\delta_{\\mathrm{D}}$ 表示狄拉克δ分布。\n- 在边长为 $L$ 的周期性盒子中，场 $f(\\boldsymbol{x})$ 的傅里叶级数系数与离散波矢量 $\\boldsymbol{k} = \\frac{2\\pi}{L} \\boldsymbol{\\ell}$ 相关联，其中 $\\boldsymbol{\\ell} \\in \\mathbb{Z}^3$。\n- 云内插值（Cloud-in-Cell）质量分配方案在实空间中沿每个轴用一个可分离的三角核来替代每个点粒子。此核函数沿一个轴的傅里叶变换是一个平方的未归一化sinc函数，而三维窗函数是一维因子的乘积。\n- 在间距为 $\\Delta x = L/N$ 的离散网格上对连续场进行采样，会根据采样定理在傅里叶空间中引起混叠；测得的基本傅里叶模式会接收到真实场在每个维度上被采样频率的整数倍平移后的波矢量处的贡献。\n\n您的任务：\n1. 在盒子内构建一个点粒子立方晶体，其晶格间距为 $a = L/M$，其中 $M$ 为整数。在每个晶格位置 $\\boldsymbol{x}_{i,j,k} = (\\boldsymbol{r}_0 + a(i,j,k)) \\bmod L$（对于 $i,j,k \\in \\{0,1,\\ldots,M-1\\}$）显式地放置一个粒子。使用粒子质量 $m=1$。\n2. 使用云内插值（CIC）质量分配方案，将所有粒子质量沉积到同一个盒子中的一个均匀的 $N \\times N \\times N$ 分析网格上。对粒子分布和质量分配都强制执行周期性边界条件。沉积后，在网格上构建密度对比度为 $\\delta_{\\mathrm{g}}(\\boldsymbol{n}) = \\rho_{\\mathrm{g}}(\\boldsymbol{n}) - \\bar{\\rho}$，其中 $\\bar{\\rho}$ 是网格上的平均质量密度，$\\boldsymbol{n} = (n_x,n_y,n_z)$ 是网格单元的索引。不要用平均值进行归一化；使用此对比度定义，以便移除零模式，并且相对于原始质量场，非零模式的振幅保持不变。\n3. 计算 $\\delta_{\\mathrm{g}}$ 的三维离散傅里叶变换，以获得在标准离散变换约定下，具有基频 $\\boldsymbol{k} = \\frac{2\\pi}{L} \\boldsymbol{\\ell}$ 的离散网格波数指数 $\\boldsymbol{\\ell} = (\\ell_x,\\ell_y,\\ell_z)$ 处的 $\\tilde{\\delta}_{\\mathrm{g}}[\\boldsymbol{\\ell}]$。\n4. 在傅里叶空间中推导出一维的云内插值窗函数为 $W_1(\\ell) = \\left[\\frac{\\sin\\left(\\pi \\ell / N\\right)}{\\pi \\ell / N}\\right]^2$，极限值为 $W_1(0) = 1$，以及三维窗函数 $W(\\boldsymbol{\\ell}) = W_1(\\ell_x) W_1(\\ell_y) W_1(\\ell_z)$。\n5. 从粒子分布的离散傅里叶变换的定义出发，推导网格化傅里叶系数的振幅级混叠模型，证明在指数 $\\boldsymbol{\\ell}$ 处测得的模式可以表示为底层粒子场系数的混叠项之和，并由CIC窗函数加权。特别是，对于形式为 $\\boldsymbol{\\ell} = (\\ell_x,0,0)$ 的模式，证明主要混叠仅沿 $x$ 方向出现，并且预测的复振幅可以近似为\n   $$\\tilde{\\delta}_{\\mathrm{model}}[\\ell_x,0,0] \\approx \\sum_{q=-Q}^{Q} W_1(\\ell_x + q N) \\sum_j \\exp\\left(- i \\, \\frac{2\\pi}{L} (\\ell_x + q N) \\, x_{j}\\right),$$\n   其中 $x_j$ 是粒子 $j$ 的 $x$ 坐标，$Q$ 是一个选择用来截断混叠和的小整数，因为窗函数会抑制高阶混叠。由此，定义模型功率为 $P_{\\mathrm{model}}(\\ell_x) = \\left|\\tilde{\\delta}_{\\mathrm{model}}[\\ell_x,0,0]\\right|^2$。\n6. 从网格傅里叶变换中测量所选模式的功率 $P_{\\mathrm{CIC}}(\\ell_x) = \\left|\\tilde{\\delta}_{\\mathrm{g}}[\\ell_x,0,0]\\right|^2$。对于每种情况，报告在所选模式中测量值与窗函数加混叠模型的最大相对偏差：\n   $$\\varepsilon = \\max_{\\ell_x \\in \\mathcal{L}} \\frac{\\left|P_{\\mathrm{CIC}}(\\ell_x) - P_{\\mathrm{model}}(\\ell_x)\\right|}{P_{\\mathrm{model}}(\\ell_x)}.$$\n\n测试套件和参数：\n- 在无量纲单位中使用 $L = 1$。使用固定的偏移矢量 $\\boldsymbol{r}_0 = (0.123,\\,0.311,\\,0.271)$，单位与 $L$ 相同。\n- 在所有测试中，使用分析网格大小 $N = 64$，且 $\\Delta x = L/N$。\n- 在理论预测中使用混叠截断参数 $Q = 3$。\n- 构建并分析以下三种情况：\n  - 情况A（理想情况，中度混叠）：$M = 8$，因此 $a = L/8$，评估集合为 $\\mathcal{L} = \\{8, 16, 24\\}$。\n  - 情况B（更强的基波和谐波）：$M = 16$，因此 $a = L/16$，评估集合为 $\\mathcal{L} = \\{16, 32\\}$。\n  - 情况C（接近奈奎斯特线）：$M = 32$，因此 $a = L/32$，评估集合为 $\\mathcal{L} = \\{32\\}$。\n- 对于每种情况，按上述方法计算 $\\varepsilon$。\n\n最终输出规范：\n- 您的程序应生成一行输出，其中包含情况A、B和C的三个 $\\varepsilon$ 值，形式为用方括号括起来的逗号分隔列表（例如，“[0.0001,0.0002,0.0003]”）。这些值必须是十进制浮点数。不涉及物理单位；所有量都是无量纲的。", "solution": "该问题要求验证在计算天体物理学中使用的云内插值（Cloud-in-Cell, CIC）质量分配方案。这是通过将从数值网格化的粒子分布计算出的功率谱与一个精确的、考虑了分配窗函数和网格采样导致的混叠效应的理论模型进行比较来实现的。粒子分布是一个合成的立方晶体，它具有简单且已知的底层功率谱，因此是一个理想的测试案例。\n\n解决方案分几个步骤进行：\n1.  生成代表立方晶格的粒子分布。\n2.  使用CIC方案将粒子质量沉积到均匀网格上。\n3.  从网格化的质量密度计算功率谱。\n4.  推导并计算包含混叠效应的理论功率谱。\n5.  比较数值和理论结果，以量化模型的准确性。\n\n### 1. 粒子分布\n考虑一个边长为 $L$ 的周期性立方体盒子。生成一个点粒子立方晶体，其晶格间距为 $a = L/M$，其中 $M$ 为整数。对所有粒子位置施加一个全局偏移矢量 $\\boldsymbol{r}_0$，以防止它们与分析网格对齐，这种情况可能会掩盖混叠效应。由 $(i,j,k)$（其中 $i,j,k \\in \\{0, 1, \\ldots, M-1\\}$）索引的粒子位置由下式给出：\n$$\n\\boldsymbol{x}_{i,j,k} = (\\boldsymbol{r}_0 + a(i,j,k)) \\bmod L\n$$\n每个粒子被赋予质量 $m=1$。在连续表示中，质量密度场是狄拉克δ分布的总和：\n$$\n\\rho(\\boldsymbol{x}) = \\sum_{p} m \\, \\delta_{\\mathrm{D}}(\\boldsymbol{x} - \\boldsymbol{x}_p)\n$$\n其中求和遍及所有 $M^3$ 个粒子。\n\n### 2. 云内插值（CIC）质量分配\nCIC方案是一种在离散网格上表示粒子分布的方法。它不将每个粒子视为一个点，而是视为一个电荷/质量均匀分布的方块（二维中）或立方体（三维中），其边长等于网格间距 $\\Delta x = L/N$。这个“云”的总质量随后被分配到它所覆盖的网格节点上。这等效于使用一维线性（三角形）插值核的张量积。\n\n对于位于位置 $\\boldsymbol{x}_p = (x_p, y_p, z_p)$ 的粒子，我们首先确定它最接近的“左下”网格节点。该节点的索引为 $\\boldsymbol{n}_0 = (i_0, j_0, k_0)$，其中 $i_0 = \\lfloor x_p/\\Delta x \\rfloor$， $j_0 = \\lfloor y_p/\\Delta x \\rfloor$， $k_0 = \\lfloor z_p/\\Delta x \\rfloor$。粒子在此单元内的归一化位置由矢量 $\\boldsymbol{t} = (t_x, t_y, t_z)$ 给出，其分量为：\n$$\nt_x = \\frac{x_p}{\\Delta x} - i_0, \\quad t_y = \\frac{y_p}{\\Delta x} - j_0, \\quad t_z = \\frac{z_p}{\\Delta x} - k_0\n$$\n粒子的质量被分配到周围的8个网格节点上。分配到与 $\\boldsymbol{n}_0$ 相距 $(\\delta i, \\delta j, \\delta k)$ 偏移量（其中 $\\delta i, \\delta j, \\delta k \\in \\{0,1\\}$）的节点的质量分数是线性插值权重的乘积：\n$$\nw(\\delta i, \\delta j, \\delta k) = w_x(\\delta i) w_y(\\delta j) w_z(\\delta k)\n$$\n其中 $w_x(0) = 1-t_x$, $w_x(1)=t_x$，对于 $y$ 和 $z$ 也类似。例如，沉积在节点 $\\boldsymbol{n}_0 = (i_0, j_0, k_0)$ 的质量是 $m(1-t_x)(1-t_y)(1-t_z)$，而在节点 $(i_0+1, j_0, k_0)$ 的质量是 $m \\, t_x(1-t_y)(1-t_z)$。所有索引都通过周期性边界条件处理，例如，索引 $N$ 变为 $0$。\n\n在所有粒子都沉积完毕后，我们得到网格化的质量密度 $\\rho_{\\mathrm{g}}(\\boldsymbol{n})$。平均密度为 $\\bar{\\rho} = \\frac{\\sum m}{N^3} = \\frac{M^3}{N^3}$。我们计算密度对比度网格 $\\delta_{\\mathrm{g}}(\\boldsymbol{n}) = \\rho_{\\mathrm{g}}(\\boldsymbol{n}) - \\bar{\\rho}$，这有效地移除了场的直流分量（$\\boldsymbol{k}=0$ 模式）。\n\n### 3. 数值功率谱测量\n功率谱由网格化密度对比度的傅里叶变换计算得出。我们计算 $\\delta_{\\mathrm{g}}(\\boldsymbol{n})$ 的三维离散傅里叶变换（DFT）：\n$$\n\\tilde{\\delta}_{\\mathrm{g}}[\\boldsymbol{\\ell}] = \\sum_{n_x=0}^{N-1} \\sum_{n_y=0}^{N-1} \\sum_{n_z=0}^{N-1} \\delta_{\\mathrm{g}}(n_x,n_y,n_z) \\exp\\left(-i \\frac{2\\pi}{N}(\\ell_x n_x + \\ell_y n_y + \\ell_z n_z)\\right)\n$$\n其中 $\\boldsymbol{\\ell}=(\\ell_x, \\ell_y, \\ell_z)$ 是整数模式索引的矢量。沿 $\\ell_x$ 轴的模式的测量功率则定义为：\n$$\nP_{\\mathrm{CIC}}(\\ell_x) = \\left|\\tilde{\\delta}_{\\mathrm{g}}[\\ell_x,0,0]\\right|^2\n$$\n\n### 4. 包含窗函数和混叠效应的理论模型\n网格化和采样的过程通过两种方式修改了底层连续场的傅里叶表示：\n1.  **窗函数**：分配方案将真实密度场与一个插值核进行卷积。在傅里叶空间中，这对应于将傅里叶系数乘以该核的傅里叶变换，即所谓的窗函数 $W(\\boldsymbol{k})$。对于CIC，在大小为 $N$ 的网格上，模式索引为 $\\ell$ 的一维窗函数为：\n    $$\n    W_1(\\ell) = \\left[\\frac{\\sin\\left(\\pi \\ell / N\\right)}{\\pi \\ell / N}\\right]^2 = \\mathrm{sinc}^2(\\ell/N)\n    $$\n    极限值为 $W_1(0)=1$。三维窗函数是一维窗函数的乘积：$W(\\boldsymbol{\\ell}) = W_1(\\ell_x)W_1(\\ell_y)W_1(\\ell_z)$。\n\n2.  **混叠**：在间距为 $\\Delta x$ 的离散网格上对场进行采样，意味着频率高于奈奎斯特频率（$k_{Ny} = \\pi/\\Delta x$，对应于模式 $\\ell=N/2$）的结构会被“折叠”回基频范围。在模式 $\\boldsymbol{\\ell}$ 处测得的傅里叶系数是真实场在所有波矢量 $\\boldsymbol{k}_{\\boldsymbol{\\ell} + \\boldsymbol{q}N} = \\frac{2\\pi}{L}(\\boldsymbol{\\ell} + \\boldsymbol{q}N)$（对于所有整数矢量 $\\boldsymbol{q} = (q_x,q_y,q_z)$）处的系数之和。\n\n结合这些效应，网格化场 $\\tilde{\\rho}_{\\mathrm{g}}[\\boldsymbol{\\ell}]$ 的DFT与原始粒子分布的傅里叶系数 $\\tilde{\\rho}_{\\text{part}} \\propto \\sum_p m_p e^{-i \\boldsymbol{k} \\cdot \\boldsymbol{x}_p}$ 相关，关系如下：\n$$\n\\tilde{\\rho}_{\\mathrm{g}}[\\boldsymbol{\\ell}] \\propto \\sum_{\\boldsymbol{q} \\in \\mathbb{Z}^3} W(\\boldsymbol{\\ell} + \\boldsymbol{q}N) \\sum_p m_p \\exp\\left(-i \\frac{2\\pi}{L}(\\boldsymbol{\\ell} + \\boldsymbol{q}N) \\cdot \\boldsymbol{x}_p\\right)\n$$\n问题要求我们针对模式 $\\boldsymbol{\\ell} = (\\ell_x, 0, 0)$ 对此进行评估。在这种情况下，三维窗函数的乘积得以简化。项 $W_1(\\ell_y+q_yN) = W_1(q_yN) = \\mathrm{sinc}^2(q_y)$ 和 $W_1(\\ell_z+q_zN) = W_1(q_zN) = \\mathrm{sinc}^2(q_z)$ 分别仅在 $q_y=0$ 和 $q_z=0$ 时非零。因此，对 $\\boldsymbol{q}$ 的求和简化为仅对 $q_x$ 的求和。这给出了复振幅的模型表达式：\n$$\n\\tilde{\\delta}_{\\mathrm{model}}[\\ell_x,0,0] = C \\sum_{q_x=-Q}^{Q} W_1(\\ell_x + q_x N) \\sum_p \\exp\\left(-i \\frac{2\\pi}{L} (\\ell_x + q_x N) x_p\\right)\n$$\n其中对 $q_x$ 的求和在一个小整数 $Q$ 处截断，因为窗函数会强烈抑制高阶混叠。比例常数 $C$ 是一个与DFT定义相关的归一化因子。通过使用相同的约定（例如 `numpy.fft` 中的约定）来实现DFT和模型求和，这个常数实际上为1。对粒子 $p$ 的求和是粒子分布的结构因子。\n\n理论模型功率则为 $P_{\\mathrm{model}}(\\ell_x) = \\left|\\tilde{\\delta}_{\\mathrm{model}}[\\ell_x,0,0]\\right|^2$。\n\n### 5. 比较\n最后一步是计算在一组指定的模式 $\\mathcal{L}$ 上，测量功率与模型预测之间的最大相对偏差：\n$$\n\\varepsilon = \\max_{\\ell_x \\in \\mathcal{L}} \\frac{\\left|P_{\\mathrm{CIC}}(\\ell_x) - P_{\\mathrm{model}}(\\ell_x)\\right|}{P_{\\mathrm{model}}(\\ell_x)}\n$$\n一个小的 $\\varepsilon$ 值表示对CIC窗函数和混叠模型的成功验证。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates the Cloud-in-Cell (CIC) mass assignment window model by comparing\n    the gridded power spectrum of a synthetic crystal with a theoretical model\n    that includes aliasing.\n    \"\"\"\n    \n    # Global parameters from the problem statement\n    L = 1.0\n    r0 = np.array([0.123, 0.311, 0.271])\n    N = 64\n    Q = 3\n    \n    test_cases = [\n        # Case A: M=8, L_modes={8, 16, 24}\n        (8, [8, 16, 24]),\n        # Case B: M=16, L_modes={16, 32}\n        (16, [16, 32]),\n        # Case C: M=32, L_modes={32}\n        (32, [32]),\n    ]\n    \n    results = []\n    \n    for M, L_modes in test_cases:\n        # --- 1. Construct particle crystal ---\n        a = L / M\n        num_particles = M**3\n        \n        # Create a mesh of integer indices for the lattice\n        i, j, k = np.mgrid[0:M, 0:M, 0:M]\n        indices = np.stack([i.ravel(), j.ravel(), k.ravel()], axis=-1)\n        \n        # Calculate particle positions\n        positions = r0 + a * indices\n        positions %= L  # Apply periodic boundary conditions\n        \n        # --- 2. CIC mass assignment ---\n        dx = L / N\n        grid = np.zeros((N, N, N), dtype=np.float64)\n        \n        for p in range(num_particles):\n            pos = positions[p]\n            \n            # Find the \"lower-left\" corner node index for the particle's cell\n            i0 = np.floor(pos / dx).astype(int)\n            \n            # Find the normalized position within the cell (trilinear weights)\n            t = (pos / dx) - i0\n            \n            # Distribute mass m=1 to 8 neighboring grid nodes\n            for i_off in range(2):\n                for j_off in range(2):\n                    for k_off in range(2):\n                        # Calculate the index of the node to update\n                        cell_idx = (\n                            (i0[0] + i_off) % N,\n                            (i0[1] + j_off) % N,\n                            (i0[2] + k_off) % N,\n                        )\n                        \n                        # Calculate trilinear interpolation weight\n                        w_x = (1 - t[0]) if i_off == 0 else t[0]\n                        w_y = (1 - t[1]) if j_off == 0 else t[1]\n                        w_z = (1 - t[2]) if k_off == 0 else t[2]\n                        weight = w_x * w_y * w_z\n                        \n                        grid[cell_idx] += weight\n\n        # --- 3. Compute measured power spectrum ---\n        rho_bar = num_particles / (N**3)\n        delta_g = grid - rho_bar\n        \n        # Compute the 3D Fast Fourier Transform\n        delta_g_k = np.fft.fftn(delta_g)\n        \n        case_errors = []\n        \n        # --- 4-6. Compute theoretical model and compare ---\n        for ell_x in L_modes:\n            # Measured power from the gridded data FFT\n            measured_power = np.abs(delta_g_k[ell_x, 0, 0])**2\n            \n            # Theoretical model including aliasing\n            model_k_val = 0.0j\n            x_coords = positions[:, 0]\n            \n            q_range = np.arange(-Q, Q + 1)\n            for q in q_range:\n                lk = ell_x + q * N\n                \n                # CIC window function W_1(l) = sinc^2(l/N)\n                # np.sinc(x) is defined as sin(pi*x)/(pi*x)\n                window = np.sinc(lk / N)**2\n                \n                # Structure factor from particle positions\n                k_val = (2 * np.pi / L) * lk\n                structure_factor = np.sum(np.exp(-1j * k_val * x_coords))\n                \n                model_k_val += window * structure_factor\n            \n            model_power = np.abs(model_k_val)**2\n            \n            # Calculate the relative deviation\n            if model_power  0:\n                relative_error = np.abs(measured_power - model_power) / model_power\n                case_errors.append(relative_error)\n        \n        if case_errors:\n            max_error = np.max(case_errors)\n            results.append(max_error)\n        else: # Should not happen given the problem setup\n            results.append(0.0)\n\n    # Final output format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3516937"}, {"introduction": "拥有 CIC 窗函数的模型固然强大，但其真正的效用在于用它来校正测量数据。本实践旨在解决反卷积这一关键任务——通过除以窗函数效应来恢复真实的功率谱——并揭示了经典的偏差-方差权衡。您将实现并比较一个朴素反卷积和一个更稳健的正则化估计器，从而深入了解如何从网格化数据中获得高保真结果。", "problem": "给定一个间距为 $\\Delta$ 的三维均匀笛卡尔网格和云中网格 (CIC) 质量分配方法。目标是推导傅里叶空间窗口函数 $W_{\\mathrm{CIC}}(\\mathbf{k})$，计算其与功率谱相关的平方模 $|W_{\\mathrm{CIC}}(\\mathbf{k})|^2$，并实现对测量功率谱的数值稳定反卷积，该反卷积要考虑到在窗口函数值较小的波矢附近，正则化引入的偏差与方差之间的权衡。\n\n从以下基本定义出发：\n- 宽度为 $\\Delta$ 的实空间一维顶帽盒函数 $T(x)$ 定义为：当 $|x| \\le \\Delta/2$ 时，$T(x) = \\frac{1}{\\Delta}$，否则 $T(x) = 0$。因此 $\\int_{-\\infty}^{\\infty} T(x) \\, dx = 1$。\n- 一维云中网格 (CIC) 分配核是顶帽函数自身的卷积，$w_{\\mathrm{CIC}}(x) = (T * T)(x)$。它是一个支撑集在 $[-\\Delta, \\Delta]$ 上且积分为 1 的三角函数。\n- 函数 $f(\\mathbf{x})$ 的傅里叶变换定义为 $F(\\mathbf{k}) = \\int_{\\mathbb{R}^3} f(\\mathbf{x}) \\, e^{-i \\mathbf{k} \\cdot \\mathbf{x}} \\, d^3 \\mathbf{x}$。\n- 实空间中的卷积对应于傅里叶空间中的乘积：如果 $h = f * g$，那么 $\\widehat{h}(\\mathbf{k}) = \\widehat{f}(\\mathbf{k}) \\, \\widehat{g}(\\mathbf{k})$。\n\n任务：\n1. 从定义 $w_{\\mathrm{CIC}}(x) = (T * T)(x)$ 出发，并使用上述傅里叶变换定义，推导一维云中网格核 $w_{\\mathrm{CIC}}(x)$ 的一维傅里叶变换 $\\widehat{w}_{\\mathrm{CIC}}(k)$。利用在笛卡尔网格上的可分离性，推导三维傅里叶空间窗口函数 $W_{\\mathrm{CIC}}(\\mathbf{k})$，其中 $\\mathbf{k} = (k_x, k_y, k_z)$。\n2. 对于一个测量的功率谱模型 $P_{\\mathrm{meas}}(\\mathbf{k}) = |W_{\\mathrm{CIC}}(\\mathbf{k})|^2 \\, P_{\\mathrm{true}}(k) + \\eta(\\mathbf{k})$，其中 $k = \\|\\mathbf{k}\\|$，测量噪声 $\\eta(\\mathbf{k})$ 的均值为零、方差为 $\\sigma^2(\\mathbf{k})$，设计真实功率谱的两种估计量：\n   - 朴素反卷积估计量 $P_{\\mathrm{naive}}(\\mathbf{k}) = P_{\\mathrm{meas}}(\\mathbf{k}) / |W_{\\mathrm{CIC}}(\\mathbf{k})|^2$，\n   - 一个岭正则化估计量，它通过最小化带有 Tikhonov (岭) 惩罚项的平方误差目标函数得到，为每个 $\\mathbf{k}$ 产生一个形式为 $P_{\\mathrm{ridge}}(\\mathbf{k}) = \\alpha(\\mathbf{k}) \\, P_{\\mathrm{meas}}(\\mathbf{k})$ 的标量逆，其中标量 $\\alpha(\\mathbf{k})$ 取决于 $|W_{\\mathrm{CIC}}(\\mathbf{k})|^2$ 和一个正则化参数 $\\lambda > 0$。\n3. 对每种估计量，推导其偏差 $\\mathrm{bias}(\\mathbf{k}) = \\mathbb{E}[P_{\\mathrm{est}}(\\mathbf{k})] - P_{\\mathrm{true}}(k)$、方差 $\\mathrm{var}(\\mathbf{k}) = \\mathrm{Var}[P_{\\mathrm{est}}(\\mathbf{k})]$ 和均方误差 $\\mathrm{mse}(\\mathbf{k}) = \\mathrm{bias}(\\mathbf{k})^2 + \\mathrm{var}(\\mathbf{k})$。用 $|W_{\\mathrm{CIC}}(\\mathbf{k})|^2$、$P_{\\mathrm{true}}(k)$、$\\sigma^2(\\mathbf{k})$ 和 $\\lambda$ 来表示这些量。\n4. 实现一个程序，用于计算 $W_{\\mathrm{CIC}}(\\mathbf{k})$，并针对以下测试套件评估朴素估计量和岭正则化估计量的偏差、方差和均方误差。\n\n数值评估的假设和定义：\n- 在无量纲代码单位中使用网格间距 $\\Delta = 1$。\n- 使用以弧度每单位长度表示的波数 $\\mathbf{k}$。这是此处使用的傅里叶变换定义所要求的。\n- 采用无量纲的真实各向同性功率谱 $P_{\\mathrm{true}}(k) = A \\exp\\!\\big(- (k/k_c)^2 \\big)$，其中在代码单位中 $A = 10$ 且 $k_c = 1$。\n- 使用白噪声模型 $\\sigma^2(\\mathbf{k}) = \\sigma_0^2$，其值由每个测试案例指定。\n\n测试套件：\n- 案例1（零波数边界，低噪声）：$\\mathbf{k} = (0, 0, 0)$，$\\lambda = 10^{-6}$，$\\sigma_0^2 = 10^{-4}$。\n- 案例2（理想情况，中等波数）：$\\mathbf{k} = (\\pi/4, \\pi/4, \\pi/4)$，$\\lambda = 10^{-6}$，$\\sigma_0^2 = 10^{-3}$。\n- 案例3（各向异性高波数，一个分量在奈奎斯特频率）：$\\mathbf{k} = (\\pi, 0, 0)$，$\\lambda = 10^{-2}$，$\\sigma_0^2 = 10^{-2}$。\n- 案例4（所有方向均在奈奎斯特频率的极端高波数）：$\\mathbf{k} = (\\pi, \\pi, \\pi)$，$\\lambda = 10^{-1}$，$\\sigma_0^2 = 10^{-2}$。\n- 案例5（高低分量混合）：$\\mathbf{k} = (0.9\\pi, 0.9\\pi, 0.1\\pi)$，$\\lambda = 5 \\times 10^{-3}$，$\\sigma_0^2 = 5 \\times 10^{-3}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 每个元素对应一个测试案例，并且本身必须是包含六个浮点数的列表，顺序完全如下：$[\\,|W_{\\mathrm{CIC}}(\\mathbf{k})|^2,\\; P_{\\mathrm{true}}(k),\\; \\mathrm{bias}_{\\mathrm{ridge}}(\\mathbf{k}),\\; \\mathrm{var}_{\\mathrm{ridge}}(\\mathbf{k}),\\; \\mathrm{mse}_{\\mathrm{ridge}}(\\mathbf{k}),\\; \\mathrm{mse}_{\\mathrm{naive}}(\\mathbf{k})\\,]$。\n- 在所采用的代码单位中，所有量都是无量纲的。", "solution": "解题过程按要求分为四个阶段：\n1. 推导傅里叶空间中的三维云中网格 (CIC) 窗口函数。\n2. 构建真实功率谱的朴素估计量和岭正则化估计量。\n3. 推导两种估计量的偏差、方差和均方误差 (MSE)。\n4. 针对所提供的测试案例进行数值实现和评估。\n\n**1. CIC 窗口函数 $W_{\\mathrm{CIC}}(\\mathbf{k})$ 的推导**\n\n推导始于一维顶帽函数 $T(x)$，它是一个将粒子质量投影到一个长度为 $\\Delta$ 的线段上的盒函数。\n$T(x) = \\frac{1}{\\Delta}$ 当 $|x| \\le \\frac{\\Delta}{2}$，否则 $T(x) = 0$。它被归一化，使得 $\\int_{-\\infty}^{\\infty} T(x) dx = 1$。\n\n其傅里叶变换 $\\widehat{T}(k)$ 计算如下：\n$$\n\\widehat{T}(k) = \\int_{-\\infty}^{\\infty} T(x) e^{-ikx} dx = \\frac{1}{\\Delta} \\int_{-\\Delta/2}^{\\Delta/2} e^{-ikx} dx\n$$\n$$\n\\widehat{T}(k) = \\frac{1}{\\Delta} \\left[ \\frac{e^{-ikx}}{-ik} \\right]_{-\\Delta/2}^{\\Delta/2} = \\frac{1}{-ik\\Delta} \\left( e^{-ik\\Delta/2} - e^{ik\\Delta/2} \\right)\n$$\n使用欧拉恒等式 $e^{i\\theta} - e^{-i\\theta} = 2i\\sin(\\theta)$，我们得到：\n$$\n\\widehat{T}(k) = \\frac{1}{-ik\\Delta} \\left( -2i\\sin\\left(\\frac{k\\Delta}{2}\\right) \\right) = \\frac{2\\sin(k\\Delta/2)}{k\\Delta} = \\frac{\\sin(k\\Delta/2)}{k\\Delta/2}\n$$\n这是未归一化的 sinc 函数，我们记作 $\\mathrm{sinc}(x) = \\sin(x)/x$。因此，$\\widehat{T}(k) = \\mathrm{sinc}(k\\Delta/2)$。\n\n一维 CIC 分配核 $w_{\\mathrm{CIC}}(x)$ 是顶帽函数自身的卷积：$w_{\\mathrm{CIC}}(x) = (T * T)(x)$。根据卷积定理，其傅里叶变换 $\\widehat{w}_{\\mathrm{CIC}}(k)$ 是各个傅里叶变换的乘积：\n$$\n\\widehat{w}_{\\mathrm{CIC}}(k) = \\widehat{T}(k) \\cdot \\widehat{T}(k) = \\left( \\mathrm{sinc}\\left(\\frac{k\\Delta}{2}\\right) \\right)^2\n$$\n\n三维 CIC 核在笛卡尔网格上是可分离的，意味着它是三个一维核的乘积：$W_{\\mathrm{CIC}}^{real}(\\mathbf{x}) = w_{\\mathrm{CIC}}(x)w_{\\mathrm{CIC}}(y)w_{\\mathrm{CIC}}(z)$。因此，其三维傅里叶变换 $W_{\\mathrm{CIC}}(\\mathbf{k})$ 是每个波矢分量 $k_x, k_y, k_z$ 对应的一维傅里叶变换的乘积：\n$$\nW_{\\mathrm{CIC}}(\\mathbf{k}) = \\widehat{w}_{\\mathrm{CIC}}(k_x) \\widehat{w}_{\\mathrm{CIC}}(k_y) \\widehat{w}_{\\mathrm{CIC}}(k_z) = \\mathrm{sinc}^2\\left(\\frac{k_x\\Delta}{2}\\right) \\mathrm{sinc}^2\\left(\\frac{k_y\\Delta}{2}\\right) \\mathrm{sinc}^2\\left(\\frac{k_z\\Delta}{2}\\right) = \\prod_{i=x,y,z} \\mathrm{sinc}^2\\left(\\frac{k_i\\Delta}{2}\\right)\n$$\n\n**2. 功率谱估计量的构建**\n\n网格化过程对底层的连续密度场起着线性滤波器的作用。在傅里叶空间中，网格化场的变换是连续场变换与窗口函数的乘积。功率谱与场的傅里叶变换的平方模成正比，因此受到 $|W_{\\mathrm{CIC}}(\\mathbf{k})|^2$ 的调制。\n测量的功率谱模型如下：\n$$\nP_{\\mathrm{meas}}(\\mathbf{k}) = |W_{\\mathrm{CIC}}(\\mathbf{k})|^2 P_{\\mathrm{true}}(k) + \\eta(\\mathbf{k})\n$$\n其中 $\\eta(\\mathbf{k})$ 是一个噪声项，满足 $\\mathbb{E}[\\eta(\\mathbf{k})] = 0$ 和 $\\mathrm{Var}[\\eta(\\mathbf{k})] = \\sigma^2(\\mathbf{k})$。我们定义传递函数 $G(\\mathbf{k}) = |W_{\\mathrm{CIC}}(\\mathbf{k})|^2$。\n$$\nG(\\mathbf{k}) = \\left| \\prod_{i=x,y,z} \\mathrm{sinc}^2\\left(\\frac{k_i\\Delta}{2}\\right) \\right|^2 = \\prod_{i=x,y,z} \\mathrm{sinc}^4\\left(\\frac{k_i\\Delta}{2}\\right)\n$$\n模型变为 $P_{\\mathrm{meas}}(\\mathbf{k}) = G(\\mathbf{k}) P_{\\mathrm{true}}(k) + \\eta(\\mathbf{k})$。\n\n**朴素反卷积估计量：**\n该估计量直接对传递函数求逆：\n$$\nP_{\\mathrm{naive}}(\\mathbf{k}) = \\frac{P_{\\mathrm{meas}}(\\mathbf{k})}{G(\\mathbf{k})}\n$$\n\n**岭正则化估计量：**\n该估计量是通过最小化一个 Tikhonov 正则化的最小二乘目标函数推导出来的。对于每个 $\\mathbf{k}$，我们寻求一个估计值 $\\hat{P}_{\\mathrm{true}}$ 来最小化：\n$$\nJ(\\hat{P}_{\\mathrm{true}}) = (P_{\\mathrm{meas}}(\\mathbf{k}) - G(\\mathbf{k})\\hat{P}_{\\mathrm{true}})^2 + \\lambda \\hat{P}_{\\mathrm{true}}^2\n$$\n对 $\\hat{P}_{\\mathrm{true}}$ 求导并令其为零以找到最小值：\n$$\n\\frac{\\partial J}{\\partial \\hat{P}_{\\mathrm{true}}} = -2G(\\mathbf{k})(P_{\\mathrm{meas}}(\\mathbf{k}) - G(\\mathbf{k})\\hat{P}_{\\mathrm{true}}) + 2\\lambda \\hat{P}_{\\mathrm{true}} = 0\n$$\n$$\n-G(\\mathbf{k})P_{\\mathrm{meas}}(\\mathbf{k}) + G(\\mathbf{k})^2\\hat{P}_{\\mathrm{true}} + \\lambda \\hat{P}_{\\mathrm{true}} = 0\n$$\n求解 $\\hat{P}_{\\mathrm{true}}$，即我们的岭估计量 $P_{\\mathrm{ridge}}(\\mathbf{k})$：\n$$\nP_{\\mathrm{ridge}}(\\mathbf{k}) = \\frac{G(\\mathbf{k})}{G(\\mathbf{k})^2 + \\lambda} P_{\\mathrm{meas}}(\\mathbf{k})\n$$\n\n**3. 偏差、方差和均方误差**\n\n我们现在分析每种估计量的统计特性。\n\n**朴素估计量 ($P_{\\mathrm{naive}}$)：**\n$$\nP_{\\mathrm{naive}} = \\frac{G P_{\\mathrm{true}} + \\eta}{G} = P_{\\mathrm{true}} + \\frac{\\eta}{G}\n$$\n- **期望与偏差：** 期望值为 $\\mathbb{E}[P_{\\mathrm{naive}}] = \\mathbb{E}[P_{\\mathrm{true}} + \\eta/G] = P_{\\mathrm{true}} + \\mathbb{E}[\\eta]/G = P_{\\mathrm{true}}$。因此偏差为零。\n  $$\n  \\mathrm{bias}_{\\mathrm{naive}}(\\mathbf{k}) = \\mathbb{E}[P_{\\mathrm{naive}}] - P_{\\mathrm{true}} = 0\n  $$\n- **方差：** 方差完全由噪声项决定。\n  $$\n  \\mathrm{var}_{\\mathrm{naive}}(\\mathbf{k}) = \\mathrm{Var}\\left[P_{\\mathrm{true}} + \\frac{\\eta}{G}\\right] = \\mathrm{Var}\\left[\\frac{\\eta}{G}\\right] = \\frac{1}{G(\\mathbf{k})^2} \\mathrm{Var}[\\eta] = \\frac{\\sigma^2(\\mathbf{k})}{G(\\mathbf{k})^2}\n  $$\n- **均方误差：** $\\mathrm{mse} = \\mathrm{bias}^2 + \\mathrm{var}$。\n  $$\n  \\mathrm{mse}_{\\mathrm{naive}}(\\mathbf{k}) = 0^2 + \\frac{\\sigma^2(\\mathbf{k})}{G(\\mathbf{k})^2} = \\frac{\\sigma^2(\\mathbf{k})}{G(\\mathbf{k})^2} = \\frac{\\sigma^2(\\mathbf{k})}{|W_{\\mathrm{CIC}}(\\mathbf{k})|^4}\n  $$\n\n**岭估计量 ($P_{\\mathrm{ridge}}$)：**\n$$\nP_{\\mathrm{ridge}} = \\frac{G}{G^2 + \\lambda} (G P_{\\mathrm{true}} + \\eta)\n$$\n- **期望与偏差：**\n  $$\n  \\mathbb{E}[P_{\\mathrm{ridge}}] = \\mathbb{E}\\left[\\frac{G}{G^2 + \\lambda} (G P_{\\mathrm{true}} + \\eta)\\right] = \\frac{G^2}{G^2 + \\lambda} P_{\\mathrm{true}}\n  $$\n  该估计量是有偏的。偏差为：\n  $$\n  \\mathrm{bias}_{\\mathrm{ridge}}(\\mathbf{k}) = \\mathbb{E}[P_{\\mathrm{ridge}}] - P_{\\mathrm{true}} = \\left(\\frac{G(\\mathbf{k})^2}{G(\\mathbf{k})^2 + \\lambda} - 1\\right)P_{\\mathrm{true}}(k) = \\frac{-\\lambda}{G(\\mathbf{k})^2 + \\lambda} P_{\\mathrm{true}}(k)\n  $$\n- **方差：**\n  $$\n  \\mathrm{var}_{\\mathrm{ridge}}(\\mathbf{k}) = \\mathrm{Var}\\left[\\frac{G}{G^2 + \\lambda} (G P_{\\mathrm{true}} + \\eta)\\right] = \\mathrm{Var}\\left[\\frac{G}{G^2 + \\lambda} \\eta\\right] = \\left(\\frac{G}{G^2 + \\lambda}\\right)^2 \\mathrm{Var}[\\eta] = \\frac{G(\\mathbf{k})^2 \\sigma^2(\\mathbf{k})}{(G(\\mathbf{k})^2 + \\lambda)^2}\n  $$\n- **均方误差：**\n  $$\n  \\mathrm{mse}_{\\mathrm{ridge}}(\\mathbf{k}) = \\mathrm{bias}_{\\mathrm{ridge}}(\\mathbf{k})^2 + \\mathrm{var}_{\\mathrm{ridge}}(\\mathbf{k})\n  $$\n  $$\n  \\mathrm{mse}_{\\mathrm{ridge}}(\\mathbf{k}) = \\left(\\frac{-\\lambda P_{\\mathrm{true}}(k)}{G(\\mathbf{k})^2 + \\lambda}\\right)^2 + \\frac{G(\\mathbf{k})^2 \\sigma^2(\\mathbf{k})}{(G(\\mathbf{k})^2 + \\lambda)^2} = \\frac{\\lambda^2 P_{\\mathrm{true}}(k)^2 + G(\\mathbf{k})^2 \\sigma^2(\\mathbf{k})}{(G(\\mathbf{k})^2 + \\lambda)^2}\n  $$\n\n**4. 数值实现**\n\n将推导出的公式用于指定的测试案例进行实现。网格间距为 $\\Delta = 1$。真实功率谱为 $P_{\\mathrm{true}}(k) = 10 \\exp(-k^2)$，其中 $k = \\|\\mathbf{k}\\|$。噪声方差为常数 $\\sigma^2(\\mathbf{k}) = \\sigma_0^2$。\n\n需要为每个测试案例计算的量包括：\n- $G(\\mathbf{k}) = |W_{\\mathrm{CIC}}(\\mathbf{k})|^2 = \\prod_{i=x,y,z} \\mathrm{sinc}^4(k_i/2)$\n- $P_{\\mathrm{true}}(k)$\n- $\\mathrm{bias}_{\\mathrm{ridge}}(\\mathbf{k})$\n- $\\mathrm{var}_{\\mathrm{ridge}}(\\mathbf{k})$\n- $\\mathrm{mse}_{\\mathrm{ridge}}(\\mathbf{k})$\n- $\\mathrm{mse}_{\\mathrm{naive}}(\\mathbf{k})$\n\n这些表达式在提供的 Python 代码中进行数值计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the CIC window function and evaluates bias, variance, and MSE\n    for naive and ridge-regularized power spectrum estimators.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is (k_vector, lambda, sigma_squared).\n    test_cases = [\n        # Case 1: k at origin, low noise\n        (np.array([0.0, 0.0, 0.0]), 1e-6, 1e-4),\n        # Case 2: Moderate wavenumbers, low noise\n        (np.array([np.pi/4, np.pi/4, np.pi/4]), 1e-6, 1e-3),\n        # Case 3: Anisotropic, one component at Nyquist\n        (np.array([np.pi, 0.0, 0.0]), 1e-2, 1e-2),\n        # Case 4: Isotropic at Nyquist\n        (np.array([np.pi, np.pi, np.pi]), 1e-1, 1e-2),\n        # Case 5: Mixed high and low wavenumbers\n        (np.array([0.9*np.pi, 0.9*np.pi, 0.1*np.pi]), 5e-3, 5e-3),\n    ]\n\n    # Parameters for the true power spectrum.\n    A = 10.0\n    k_c = 1.0\n    delta = 1.0  # Grid spacing\n\n    results = []\n\n    def sinc(x):\n        \"\"\"\n        Numerically stable sinc function, sinc(x) = sin(x)/x.\n        \"\"\"\n        return np.where(x == 0.0, 1.0, np.sin(x) / x)\n\n    for case in test_cases:\n        k_vec, lambda_val, sigma_sq_val = case\n\n        # 1. Calculate the true power spectrum P_true(k)\n        k_mag = np.linalg.norm(k_vec)\n        p_true = A * np.exp(-(k_mag / k_c)**2)\n\n        # 2. Calculate the power spectrum transfer function G(k) = |W_CIC(k)|^2\n        # W_CIC(k) = Product_i sinc^2(k_i * delta / 2)\n        # G(k) = |W_CIC(k)|^2 = Product_i sinc^4(k_i * delta / 2)\n        sinc_args = k_vec * delta / 2.0\n        sinc_vals = sinc(sinc_args)\n        G_k = np.prod(sinc_vals**4)\n\n        # 3. Calculate bias, variance, and MSE for both estimators\n        \n        # Guard against division by zero for the naive estimator, though not\n        # expected for these test cases.\n        G_k_sq = G_k**2\n        if G_k_sq == 0.0:\n            mse_naive = np.inf\n        else:\n            mse_naive = sigma_sq_val / G_k_sq\n\n        # Ridge estimator calculations\n        denom_ridge = G_k_sq + lambda_val\n        \n        bias_ridge = (-lambda_val / denom_ridge) * p_true\n        var_ridge = (G_k_sq / (denom_ridge**2)) * sigma_sq_val\n        mse_ridge = bias_ridge**2 + var_ridge\n\n        # Store the results for this case in the specified order\n        # [|W_CIC(k)|^2, P_true(k), bias_ridge, var_ridge, mse_ridge, mse_naive]\n        case_results = [\n            G_k,\n            p_true,\n            bias_ridge,\n            var_ridge,\n            mse_ridge,\n            mse_naive\n        ]\n        results.append(case_results)\n\n    # Format the final output string as specified: [[...],[...],...]\n    # Each inner list is a string representation of the list of floats.\n    list_strs = []\n    for row in results:\n        list_strs.append(f\"[{','.join(f'{x:.8e}' for x in row)}]\")\n    final_output = f\"[{','.join(list_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "3516941"}]}