{"hands_on_practices": [{"introduction": "在模拟复杂的N体系统之前，我们必须牢固掌握最简单的情况：二体问题。这项练习将指导你从牛顿定律出发，推导出开普勒第三定律。通过这个过程，你将加深对质心参考系和约化质量等概念的理解，这些都是所有N体代码的基础，也是建立物理直觉的关键。[@problem_id:3540212]", "problem": "在牛顿引力背景下，考虑一个由两个质点组成的孤立子系统，其质量分别为 $m_{1}$ 和 $m_{2}$，它们之间仅通过相互的引力相互作用。设该系统为束缚系统，其相对轨道形成一个半长轴为 $a$ 的椭圆。仅从牛顿第二定律、引力平方反比定律以及质心和角动量的定义出发，将此二体问题简化为质心参考系中的等效单体问题，并推导出束缚相对运动的轨道周期 $T$ 作为 $a$、引力常数 $G$ 和总质量 $M = m_{1} + m_{2}$ 的函数。你的推导必须证明为什么对质量的依赖性仅通过总质量 $M$ 体现，而不是分别通过 $m_{1}$ 和 $m_{2}$。不要引用或假设任何已有的周期-半长轴关系；相反，应从第一性原理出发进行推理，必要时包括守恒定律和圆锥曲线的几何性质。\n\n请用 $a$、$G$、$M$ 和 $\\pi$ 写出最终答案的单一解析表达式。不需要进行数值计算，最终表达式中不应包含单位。", "solution": "该问题被验证为科学上可靠、提法恰当、客观且自洽。推导过程按要求从第一性原理出发。\n\n设两个质点 $m_{1}$ 和 $m_{2}$ 的位置矢量分别为 $\\vec{r}_{1}$ 和 $\\vec{r}_{2}$。该系统是孤立的，因此作用力只有它们之间的相互引力。根据牛顿第二定律和万有引力定律，这两个质量的运动方程为：\n$$m_{1}\\ddot{\\vec{r}}_{1} = \\vec{F}_{12} = G\\frac{m_{1}m_{2}}{|\\vec{r}_{2} - \\vec{r}_{1}|^{3}}(\\vec{r}_{2} - \\vec{r}_{1})$$\n$$m_{2}\\ddot{\\vec{r}}_{2} = \\vec{F}_{21} = G\\frac{m_{1}m_{2}}{|\\vec{r}_{1} - \\vec{r}_{2}|^{3}}(\\vec{r}_{1} - \\vec{r}_{2})$$\n注意 $\\vec{F}_{12} = -\\vec{F}_{21}$，这与牛顿第三定律一致。\n\n为了简化这个二体问题，我们引入两个新的坐标：质心位置矢量 $\\vec{R}_{CM}$ 和相对位置矢量 $\\vec{r}$。\n质心定义为：\n$$\\vec{R}_{CM} = \\frac{m_{1}\\vec{r}_{1} + m_{2}\\vec{r}_{2}}{m_{1} + m_{2}}$$\n系统的总质量为 $M = m_{1} + m_{2}$。将 $\\vec{R}_{CM}$ 对时间求二阶导数，得到其加速度：\n$$\\ddot{\\vec{R}}_{CM} = \\frac{m_{1}\\ddot{\\vec{r}}_{1} + m_{2}\\ddot{\\vec{r}}_{2}}{M} = \\frac{\\vec{F}_{12} + \\vec{F}_{21}}{M} = \\frac{\\vec{0}}{M} = \\vec{0}$$\n这表明质心以恒定速度运动，意味着质心参考系是一个惯性参考系。\n\n相对位置矢量定义为 $\\vec{r} = \\vec{r}_{1} - \\vec{r}_{2}$。其二阶时间导数为：\n$$\\ddot{\\vec{r}} = \\ddot{\\vec{r}}_{1} - \\ddot{\\vec{r}}_{2} = \\frac{\\vec{F}_{12}}{m_{1}} - \\frac{\\vec{F}_{21}}{m_{2}}$$\n代入力学的表达式，并注意到 $\\vec{F}_{21} = -\\vec{F}_{12}$ 和 $\\vec{r}_{2} - \\vec{r}_{1} = -\\vec{r}$：\n$$\\ddot{\\vec{r}} = \\frac{1}{m_{1}}\\left(-G\\frac{m_{1}m_{2}}{r^{3}}\\vec{r}\\right) - \\frac{1}{m_{2}}\\left(G\\frac{m_{1}m_{2}}{r^{3}}\\vec{r}\\right)$$\n$$\\ddot{\\vec{r}} = -G\\frac{m_{2}}{r^{3}}\\vec{r} - G\\frac{m_{1}}{r^{3}}\\vec{r} = -G\\frac{(m_{1} + m_{2})}{r^{3}}\\vec{r}$$\n代入 $M = m_{1} + m_{2}$，我们得到相对坐标的运动方程：\n$$\\ddot{\\vec{r}} = -\\frac{GM}{r^{3}}\\vec{r}$$\n该方程描述了一个假想粒子的运动，其位置由相对矢量 $\\vec{r}$ 给出，该粒子受到一个源于固定点的中心力的影响，其中决定加速度的有效质量是总质量 $M = m_{1} + m_{2}$。这一步明确地证明了为什么动力学依赖于质量之和 $M$，而不是单个的 $m_{1}$ 或 $m_{2}$。因此，二体问题被简化为了一个等效的单体问题。\n\n力是纯粹的中心力（沿 $\\vec{r}$ 方向），这意味着比角动量 $\\vec{h} = \\vec{r} \\times \\dot{\\vec{r}}$ 是一个守恒量。\n$$\\dot{\\vec{h}} = \\frac{d}{dt}(\\vec{r} \\times \\dot{\\vec{r}}) = \\dot{\\vec{r}} \\times \\dot{\\vec{r}} + \\vec{r} \\times \\ddot{\\vec{r}} = \\vec{0} + \\vec{r} \\times \\left(-\\frac{GM}{r^{3}}\\vec{r}\\right) = \\vec{0}$$\n$\\vec{h}$ 的守恒意味着运动被限制在与恒定矢量 $\\vec{h}$ 垂直的平面内。比角动量的大小为 $h = |\\vec{h}|$。在此平面内，相对位置矢量扫过面积的速率由掠面速度给出：\n$$\\frac{dA}{dt} = \\frac{1}{2}|\\vec{r} \\times \\dot{\\vec{r}}| = \\frac{h}{2}$$\n由于 $h$ 是常数，掠面速度是恒定的（开普勒第二定律）。轨道周期 $T$ 是扫过整个椭圆面积 $A$ 所需的总时间。因此，\n$$T = \\frac{A}{dA/dt} = \\frac{A}{h/2}$$\n半长轴为 $a$、半短轴为 $b$ 的椭圆面积为 $A = \\pi a b$。因此，周期为：\n$$T = \\frac{2\\pi a b}{h}$$\n\n为了求出周期，我们必须将 $h$ 和 $b$ 与给定的参数 $a$ 和 $M$ 联系起来。这需要求解轨道的运动方程。在平方反比力作用下，路径 $\\vec{r}(t)$ 的通解是一个圆锥曲线。对于束缚轨道，它是一个椭圆，其一个焦点位于原点（等效单体系统的质心）。该椭圆在极坐标 $(r, \\theta)$ 中的方程是：\n$$r = \\frac{p}{1 + e\\cos\\theta}$$\n其中 $e$ 是离心率（对于椭圆，$0 \\le e  1$），$p$ 是半通径。求解运动微分方程 $\\ddot{\\vec{r}} = -GM\\vec{r}/r^{3}$ 的一个标准结果是比角动量和半通径之间的关系：\n$$h^{2} = GMp$$\n对于椭圆，半通径 $p$ 和半短轴 $b$ 与半长轴 $a$ 和离心率 $e$ 的关系为：\n$$p = a(1 - e^{2})$$\n$$b = a\\sqrt{1 - e^{2}}$$\n将 $p$ 的表达式代入 $h^2$ 的方程中：\n$$h^{2} = GMa(1 - e^{2})$$\n现在我们可以用 $a$、$G$ 和 $M$ 来表示周期 $T$。我们从周期的表达式开始，并将其平方：\n$$T^{2} = \\left(\\frac{2\\pi a b}{h}\\right)^{2} = \\frac{4\\pi^{2}a^{2}b^{2}}{h^{2}}$$\n代入 $b^{2} = a^{2}(1-e^{2})$ 和 $h^{2} = GMa(1-e^{2})$：\n$$T^{2} = \\frac{4\\pi^{2}a^{2}\\left(a^{2}(1-e^{2})\\right)}{GMa(1-e^{2})}$$\n分子和分母中的 $(1-e^{2})$ 项相互抵消，表明周期依赖于半长轴，而不依赖于离心率。\n$$T^{2} = \\frac{4\\pi^{2}a^{4}}{GMa} = \\frac{4\\pi^{2}a^{3}}{GM}$$\n对两边取平方根，得到轨道周期的最终表达式：\n$$T = 2\\pi\\sqrt{\\frac{a^{3}}{GM}}$$\n这就是开普勒第三定律的推广形式，完全按要求从第一性原理推导得出。", "answer": "$$ \\boxed{2\\pi\\sqrt{\\frac{a^{3}}{GM}}} $$", "id": "3540212"}, {"introduction": "N体代码通常在无量纲的“代码单位”下运行，以保持数值稳定性。这项实践将带你解决一个关键步骤：如何将一个真实的物理系统（如球状星团）映射到这些代码单位。通过选择合适的单位，使得系统的特征物理量在代码中接近1，你将学会如何最大限度地减少数值误差，确保模拟结果的稳定性和准确性。[@problem_id:3540198]", "problem": "您正在准备一个真实球状星团的直接引力多体（N体）模拟，该模拟在代码单位下进行，其中$G=1$，$M=1$，$L=1$。$G$是引力常数，$M$是质量单位，$L$是长度单位。物理目标系统的总质量为 $M_{\\mathrm{phys}} \\approx 10^{5}\\,\\mathrm{M}_{\\odot}$，半质量半径为 $R_{\\mathrm{h}} \\approx 3\\,\\mathrm{pc}$，在 $R_{\\mathrm{h}}$ 处的一维速度弥散约为 $10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$。您将使用机器精度 $\\epsilon_{\\mathrm{mach}} \\approx 2.22\\times 10^{-16}$ 的双精度浮点（DPFP）算法运行此模拟，并且希望在整个积分和诊断（位置、速度、加速度、能量和时间步长）过程中，最大限度地减少舍入、上溢或下溢的风险。假设没有外部潮汐力且所有粒子质量相等。\n\n从 Newton 的引力定律和量纲分析出发，确定以下哪种物理单位标度 $(M_{\\mathrm{unit}},L_{\\mathrm{unit}})$ 的选择，对于代码单位 $(G=1, M=1, L=1)$ 而言，能最好地将球状星团映射到代码空间，使得 $R_{\\mathrm{h}}$ 附近的典型无量纲位置、速度弥散和穿越时间都为1的数量级。如果需要，可使用广为接受的天体物理学值 $G_{\\mathrm{phys}} \\approx 4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2}$ 以及换算关系 $1\\,\\mathrm{pc}/(\\mathrm{km}/\\mathrm{s}) \\approx 0.9778\\,\\mathrm{Myr}$。您的选择必须通过第一性原理推导来证明其合理性，该推导需将标度与特征动力学尺度联系起来，并解释为什么它能在DPFP中最大限度地降低数值风险。\n\n哪个选项最合适？\n\n- A. $M_{\\mathrm{unit}} = 10^{6}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 1\\,\\mathrm{pc}$.\n\n- B. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$.\n\n- C. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 0.1\\,\\mathrm{pc}$.\n\n- D. $M_{\\mathrm{unit}} = 5\\times 10^{4}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 10\\,\\mathrm{pc}$.\n\n通过选择唯一的最佳选项来回答，并从第一性原理出发进行论证，解释对于每个选项，代码单位的速度和时间标度在物理单位中是多少，以及为什么您的选择能为目标球状星团模型降低DPFP运算中的舍入、上溢或下溢风险。", "solution": "用户希望我确定一个球状星团N体模拟最合适的物理单位选择。目标是缩放问题，使得特征物理量映射到1的数量级的无量纲代码单位值，从而最小化数值误差。\n\n### 步骤1：提取已知条件\n- **代码单位系统：** 引力常数 $G_{\\mathrm{code}}=1$，质量单位 $M_{\\mathrm{code}}=1$，长度单位 $L_{\\mathrm{code}}=1$。\n- **物理系统（球状星团）：**\n    - 总质量，$M_{\\mathrm{phys}} \\approx 10^{5}\\,\\mathrm{M}_{\\odot}$。\n    - 半质量半径，$R_{\\mathrm{h}} \\approx 3\\,\\mathrm{pc}$。\n    - 在 $R_{\\mathrm{h}}$ 处的一维速度弥散，$\\sigma_{\\mathrm{phys}} \\approx 10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$。\n- **数值细节：** 双精度浮点（DPFP）运算，机器精度 $\\epsilon_{\\mathrm{mach}} \\approx 2.22\\times 10^{-16}$。\n- **天体物理常数：**\n    - 引力常数，$G_{\\mathrm{phys}} \\approx 4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2}$。\n    - 时间换算，$1\\,\\mathrm{pc}/(\\mathrm{km}/\\mathrm{s}) \\approx 0.9778\\,\\mathrm{Myr}$。\n- **目标：** 选择物理单位标度 $(M_{\\mathrm{unit}},L_{\\mathrm{unit}})$，将星团的特征位置、速度和时间尺度映射到代码空间中1的数量级，以最小化数值风险。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题描述了计算天体物理学中的一个标准流程：为N体模拟设置单位标度。为球状星团提供的物理参数（$M_{\\mathrm{phys}}$, $R_{\\mathrm{h}}$, $\\sigma_{\\mathrm{phys}}$）是此标度的基础。尽管存在轻微的物理不一致性（对于给定质量和半径的维里化系统，给定的速度弥散略高），但这并不影响问题的有效性。任务不是要验证物理模型的真实性，而是在给定一组特征参数的情况下正确执行单位标度程序。这个问题在科学上基于 Newton 的引力和量纲分析，问题设定良好，目标明确，并提供了所有必要的数据。因此，问题陈述是有效的。\n\n### 基于原理的推导\n\n在N体模拟中，标准做法是使用一个引力常数 $G$ 等于 $1$ 的单位系统。设质量、长度和时间的物理单位分别用 $M_{\\mathrm{unit}}$、$L_{\\mathrm{unit}}$ 和 $T_{\\mathrm{unit}}$ 表示。一个物理量 $Q_{\\mathrm{phys}}$ 通过除以这些单位标度的适当组合，转换为其无量纲的代码单位对应量 $Q_{\\mathrm{code}}$。\n\n物理引力常数 $G_{\\mathrm{phys}}$ 和代码单位引力常数 $G_{\\mathrm{code}}$ 之间的关系由量纲分析给出：\n$$ G_{\\mathrm{code}} = G_{\\mathrm{phys}} \\frac{M_{\\mathrm{unit}} T_{\\mathrm{unit}}^2}{L_{\\mathrm{unit}}^3} $$\n令 $G_{\\mathrm{code}}=1$ 对单位标度施加了一个约束：\n$$ 1 = G_{\\mathrm{phys}} \\frac{M_{\\mathrm{unit}} T_{\\mathrm{unit}}^2}{L_{\\mathrm{unit}}^3} \\implies T_{\\mathrm{unit}}^2 = \\frac{L_{\\mathrm{unit}}^3}{G_{\\mathrm{phys}} M_{\\mathrm{unit}}} $$\n由此，我们导出时间单位：\n$$ T_{\\mathrm{unit}} = \\sqrt{\\frac{L_{\\mathrm{unit}}^3}{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}} $$\n相应的速度单位 $V_{\\mathrm{unit}}$ 则为：\n$$ V_{\\mathrm{unit}} = \\frac{L_{\\mathrm{unit}}}{T_{\\mathrm{unit}}} = \\frac{L_{\\mathrm{unit}}}{\\sqrt{L_{\\mathrm{unit}}^3 / (G_{\\mathrm{phys}} M_{\\mathrm{unit}})}} = \\sqrt{\\frac{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}{L_{\\mathrm{unit}}}} $$\n目标是选择 $M_{\\mathrm{unit}}$ 和 $L_{\\mathrm{unit}}$，使得系统的特征量在代码单位中为1的数量级（$O(1)$）。这通过使典型值远离上溢/下溢极限并减少算术运算中的有效位数损失，来最小化DPFP中的数值误差。球状星团的特征尺度是其总质量 $M_{\\mathrm{phys}}$ 和其半质量半径 $R_{\\mathrm{h}}$。因此，单位标度最自然的选择是令 $M_{\\mathrm{unit}}$ 等于系统的总质量，令 $L_{\\mathrm{unit}}$ 等于其特征半径。\n\n让我们采用这种“自然”标度：\n1.  将质量单位设为系统的总质量：$M_{\\mathrm{unit}} = M_{\\mathrm{phys}} = 10^5 \\, \\mathrm{M}_{\\odot}$。这确保了代码单位中的总质量为 $M_{\\mathrm{code}} = M_{\\mathrm{phys}}/M_{\\mathrm{unit}} = 1$。\n2.  将长度单位设为系统的特征半径：$L_{\\mathrm{unit}} = R_{\\mathrm{h}} = 3 \\, \\mathrm{pc}$。这确保了半质量半径附近的粒子在代码单位中的半径为 $r_{\\mathrm{code}} = R_{\\mathrm{h}}/L_{\\mathrm{unit}} = 1$。\n\n做出此选择后，我们现在可以检查由此产生的速度标度是否也合适。物理速度弥散 $\\sigma_{\\mathrm{phys}}$ 应映射到1的数量级的代码单位速度 $\\sigma_{\\mathrm{code}}$。我们首先计算导出的速度单位 $V_{\\mathrm{unit}}$：\n$$ V_{\\mathrm{unit}} = \\sqrt{\\frac{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}{L_{\\mathrm{unit}}}} = \\sqrt{\\frac{(4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2})(10^5\\,\\mathrm{M}_{\\odot})}{3\\,\\mathrm{pc}}} $$\n$$ V_{\\mathrm{unit}} = \\sqrt{\\frac{430.2}{3} \\, (\\mathrm{km/s})^2} = \\sqrt{143.4} \\, \\mathrm{km/s} \\approx 11.975 \\, \\mathrm{km/s} $$\n给定的物理速度弥散为 $\\sigma_{\\mathrm{phys}} \\approx 10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$。相应的代码单位速度弥散为：\n$$ \\sigma_{\\mathrm{code}} = \\frac{\\sigma_{\\mathrm{phys}}}{V_{\\mathrm{unit}}} \\approx \\frac{10\\,\\mathrm{km}\\,\\mathrm{s}^{-1}}{11.975\\,\\mathrm{km}\\,\\mathrm{s}^{-1}} \\text{ 到 } \\frac{15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}}{11.975\\,\\mathrm{km}\\,\\mathrm{s}^{-1}} $$\n$$ \\sigma_{\\mathrm{code}} \\approx 0.835 \\text{ 到 } 1.253 $$\n这个范围理想地以 $1$ 为中心。最后，特征动力学时间，即穿越时间，是 $T_{\\mathrm{cross}} \\sim R_{\\mathrm{h}}/\\sigma_{\\mathrm{phys}}$。在代码单位中，这变为 $t_{\\mathrm{cross, code}} \\sim r_{\\mathrm{h, code}}/\\sigma_{\\mathrm{code}} \\approx 1/1 = 1$。\n因此，选择 $M_{\\mathrm{unit}} = 10^5\\,\\mathrm{M}_{\\odot}$ 和 $L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$ 可以使特征质量、长度、速度和时间的代码单位值都达到1的数量级。这是保持数值精度的理想情况。\n\n### 逐项分析\n\n现在我们根据这个理想标度来评估每个选项。\n\n**A. $M_{\\mathrm{unit}} = 10^{6}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 1\\,\\mathrm{pc}$.**\n- 代码单位中的总质量：$M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{10^6\\,\\mathrm{M}_{\\odot}} = 0.1$。这不等于1的数量级。\n- 代码单位中的半质量半径：$r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{1\\,\\mathrm{pc}} = 3$。这可以说是在1的数量级，但偏高。\n- 速度单位：$V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^6)}{1}} \\approx 65.6\\,\\mathrm{km/s}$。\n- 代码单位中的速度弥散：$\\sigma_{\\mathrm{code}} = \\frac{10-15}{65.6} \\approx 0.15-0.23$。这不等于1的数量级。\n这个选择导致特征质量和速度值远小于 $1$，并非最优。\n**结论：错误。**\n\n**B. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$.**\n- 代码单位中的总质量：$M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{10^5\\,\\mathrm{M}_{\\odot}} = 1$。理想。\n- 代码单位中的半质量半径：$r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{3\\,\\mathrm{pc}} = 1$。理想。\n- 速度单位：$V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^5)}{3}} \\approx 11.975\\,\\mathrm{km/s}$。\n- 代码单位中的速度弥散：$\\sigma_{\\mathrm{code}} = \\frac{10-15}{11.975} \\approx 0.835-1.253$。理想。\n这个选择完美地将系统的特征物理尺度映射到代码单位值 $1$，为最小化数值误差提供了最佳条件。时间单位是 $T_{\\mathrm{unit}} = L_{\\mathrm{unit}}/V_{\\mathrm{unit}} = 3\\,\\mathrm{pc} / (11.975\\,\\mathrm{km/s}) \\approx 0.2505\\,\\mathrm{pc}/(\\mathrm{km/s}) \\approx 0.245\\,\\mathrm{Myr}$。代码单位中的穿越时间约为 $\\sim 1$。\n**结论：正确。**\n\n**C. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 0.1\\,\\mathrm{pc}$.**\n- 代码单位中的总质量：$M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{10^5\\,\\mathrm{M}_{\\odot}} = 1$。理想。\n- 代码单位中的半质量半径：$r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{0.1\\,\\mathrm{pc}} = 30$。这不等于1的数量级。典型的粒子位置值会很大，增加了舍入风险。\n- 速度单位：$V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^5)}{0.1}} \\approx 65.6\\,\\mathrm{km/s}$。\n- 代码单位中的速度弥散：$\\sigma_{\\mathrm{code}} = \\frac{10-15}{65.6} \\approx 0.15-0.23$。这不等于1的数量级。\n这个选择很差，因为它导致代码单位中的位置值过大而速度值过小。\n**结论：错误。**\n\n**D. $M_{\\mathrm{unit}} = 5\\times 10^{4}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 10\\,\\mathrm{pc}$.**\n- 代码单位中的总质量：$M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{5\\times 10^4\\,\\mathrm{M}_{\\odot}} = 2$。这是1的数量级。\n- 代码单位中的半质量半径：$r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{10\\,\\mathrm{pc}} = 0.3$。这处于临界状态，偏小。\n- 速度单位：$V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(5\\times 10^4)}{10}} = \\sqrt{21.51} \\approx 4.64\\,\\mathrm{km/s}$。\n- 代码单位中的速度弥散：$\\sigma_{\\mathrm{code}} = \\frac{10-15}{4.64} \\approx 2.16-3.23$。这些值变得有些大。\n虽然这些值比选项A和C中的值更接近 $1$，但它们始终偏离了2到3倍。选项B实现了更好的映射，所有主要特征量都映射到非常接近 $1$ 的值。\n**结论：错误。**\n\n总之，选项B无疑是最合适的选择，因为它完美地将代码单位与物理系统的内在质量、长度和速度尺度对齐，从而为模拟提供了最数值稳定的设置。", "answer": "$$\\boxed{B}$$", "id": "3540198"}, {"introduction": "N体模拟的长期精度在很大程度上取决于积分器的选择。这项编程练习通过一个时间反演对称性测试，直观地对比了辛积分器（速度Verlet）与非辛积分器（四阶龙格-库塔）的性能差异。你将通过亲手实践，深刻体会到“影子哈密顿量”等概念的实际意义，并理解为何几何积分器是引力动力学模拟的标准选择。[@problem_id:3540226]", "problem": "你的任务是设计并实现一个数值实验，用以评估引力 $N$ 体问题中的时间不可逆性，检验时间反演后的失配如何依赖于积分器的类别及其参数，并根据影子哈密顿量的概念解释观察到的行为。实验应在无量纲 $N$ 体单位下进行，其中引力常数 $G=1$，粒子质量相等（按规定），位置使用相同的长度单位，速度使用相同的长度/时间单位，时间使用相同的时间单位。所有输出都必须使用这些无量纲单位。\n\n从应用于 $N$ 个质点的牛顿第二定律和软化的成对牛顿引力出发，加速度由软化势的负梯度确定。该系统遵循总能量的哈密顿流，其中动能和软化势能构成了哈密顿量。时间可逆性可以通过以下程序进行探究：向前积分至最终时间 $T$，将所有速度取反，然后使用相同的持续时间和参数再次向前积分，并量化相对于初始状态的位置失配。\n\n你的任务是：\n\n- 实现两种积分器：\n  1. 一种辛、时间可逆的方法，具体为速度 Verlet（也称为蛙跳法）方案。\n  2. 一种非辛方法，具体为经典四阶龙格-库塔 (RK4) 方法。\n\n- 在物体之间使用软化的引力。物体 $i$ 和 $j$ 之间的软化势由分离矢量 $\\mathbf{r}_{ij}$ 给出：$$\\Phi_{ij} = -\\frac{G m_i m_j}{\\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}},$$ 其对应的物体 $j$ 对物体 $i$ 的作用力为：$$\\mathbf{F}_{ij} = - \\nabla \\Phi_{ij} = - G m_i m_j \\frac{\\mathbf{r}_{ij}}{\\left(\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2\\right)^{3/2}}.$$\n\n- 对每个测试用例，执行以下实验：\n  1. 使用选定的积分器，以时间步长 $dt$ 将系统从时间 $t=0$ 向前积分到 $t=T$。\n  2. 在 $t=T$ 时，反转每个速度矢量，即 $\\mathbf{v}_i \\leftarrow -\\mathbf{v}_i$。\n  3. 使用相同的积分器，再次向前积分相同的步数（持续时间 $T$ 和时间步长 $dt$）。\n  4. 计算均方根 (Root Mean Square (RMS)) 位置失配：$$\\delta x = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\left\\lVert \\mathbf{x}_i^{\\text{back}} - \\mathbf{x}_i^{\\text{init}} \\right\\rVert^2}.$$ 以与位置相同的长度单位报告 $\\delta x$。\n\n- 软化引力常数设为 $G=1$。在所有测试中，软化长度固定为 $\\epsilon=10^{-2}$。物体数量 $N$、它们的质量 $m_i$、初始位置 $\\mathbf{x}_i(0)$ 和初始速度 $\\mathbf{v}_i(0)$ 将在下面为每个测试指定。\n\n- 在前向积分开始时实现总能量计算：$$E(0) = K(0) + U(0), \\quad K = \\sum_{i=1}^N \\frac{1}{2} m_i \\lVert \\mathbf{v}_i \\rVert^2, \\quad U = \\sum_{1 \\le i  j \\le N} - \\frac{G m_i m_j}{\\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}},$$ 尽管你不需要输出能量；这仅用于内部一致性检查。\n\n- 设计程序以计算以下测试套件的上述 $\\delta x$ 值。每个测试用例以一个参数元组的形式给出，指定了积分器、$N$、质量、位置、速度、$dt$ 和 $T$：\n\n  1. 用例 A（理想情况，近可积二体，辛方法，小时间步长）：\n     - 积分器：速度 Verlet\n     - $N=2$, $m_1=m_2=1/2$\n     - $\\mathbf{x}_1(0)=(-1/2,0,0)$, $\\mathbf{x}_2(0)=(1/2,0,0)$\n     - 为相距 $r_0=1$ 的等质量物体选择圆周轨道速度；对于每个半径为 $a=r_0/2$ 的物体，速度为 $v=\\sqrt{G m_{\\text{other}}/(2 r_0)}$，其中 $G=1$ 且 $m_{\\text{other}}=1/2$，因此 $v=1/2$。设置 $\\mathbf{v}_1(0)=(0,v,0)$ 和 $\\mathbf{v}_2(0)=(0,-v,0)$。\n     - $dt=10^{-3}$, $T=2$。\n\n  2. 用例 B（近可积二体，非辛方法，较大时间步长）：\n     - 积分器：经典四阶龙格-库塔 (RK4)\n     - 与用例 A 相同的 $N$、质量、位置\n     - 与用例 A 相同的圆周轨道速度\n     - $dt=10^{-2}$, $T=2$。\n\n  3. 用例 C（三体类混沌构型，辛方法，小时间步长）：\n     - 积分器：速度 Verlet\n     - $N=3$, $m_i=1/3$ for $i=1,2,3$\n     - $\\mathbf{x}_1(0)=(-1,0,0)$, $\\mathbf{x}_2(0)=(1,0.2,0)$, $\\mathbf{x}_3(0)=(0,-0.8,0)$\n     - $\\mathbf{v}_1(0)=(0.3,0.2,0)$, $\\mathbf{v}_2(0)=(-0.2,0.5,0)$, $\\mathbf{v}_3(0)=(-0.1,-0.3,0)$\n     - $dt=2\\times 10^{-3}$, $T=5$。\n\n  4. 用例 D（三体类混沌构型，非辛方法，中等时间步长）：\n     - 积分器：经典四阶龙格-库塔 (RK4)\n     - 与用例 C 相同的 $N$、质量、位置、速度\n     - $dt=5\\times 10^{-3}$, $T=5$。\n\n  5. 用例 E（三体类混沌构型，辛方法，大时间步长）：\n     - 积分器：速度 Verlet\n     - 与用例 C 相同的 $N$、质量、位置、速度\n     - $dt=5\\times 10^{-2}$, $T=5$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），其中每个 $result_k$ 是用例 $k$ 的 $\\delta x$ 值，顺序为 A、B、C、D、E。每个 $\\delta x$ 必须是浮点数，单位与位置的长度单位相同。程序必须是自包含的，且不得读取任何输入。", "solution": "所述问题是有效的。它提出了一个定义明确的数值实验，该实验基于经典力学和计算动力学的原理。所有必要的参数、初始条件和物理定律都已提供，构成一个自包含且科学上合理的任务。\n\n目标是研究引力 $N$ 体问题数值解的时间可逆性。由牛顿运动定律支配的真实动力学是时间可逆的。如果在任何时刻，所有粒子的速度都被反向，系统将在相空间中追溯其路径，返回到其初始状态。本实验测试了两种不同的数值积分方案——速度 Verlet 和经典四阶龙格-库塔 (RK4)——在多大程度上保持了这一基本对称性。在一次前向-后向积分序列之后，与完美反演的偏差由均方根 (RMS) 位置失配 $\\delta x$ 来量化。\n\n系统的动力学由软化引力势决定，对于一对粒子 $i$ 和 $j$，其表达式为 $\\Phi_{ij} = -G m_i m_j / \\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}$，其中 $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$ 是分离矢量，$m_i$ 是质量，$G$ 是引力常数，$\\epsilon$ 是软化长度。粒子 $j$ 对粒子 $i$ 的力是该势的负梯度，$\\mathbf{F}_{ij} = - \\nabla_i \\Phi_{ij} = -G m_i m_j \\mathbf{r}_{ij} / (\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2)^{3/2}$。粒子 $i$ 的总加速度为 $\\mathbf{a}_i = (1/m_i) \\sum_{j \\neq i} \\mathbf{F}_{ij}$。此设置定义了一个哈密顿系统，其在相空间 $(\\mathbf{x}, \\mathbf{v})$ 中的轨迹正是我们旨在进行数值近似的对象。\n\n分析的核心在于两种积分器的对比特性。\n\n速度 Verlet 积分器是几何积分器家族的一员，具体来说，它是辛和时间可逆的。其算法按“踢-漂-踢”（kick-drift-kick）序列进行：\n$1$. 将速度更新半步：$\\mathbf{v}(t + dt/2) = \\mathbf{v}(t) + \\mathbf{a}(t) \\cdot dt/2$。\n$2$. 使用半步速度将位置更新一整步：$\\mathbf{x}(t + dt) = \\mathbf{x}(t) + \\mathbf{v}(t + dt/2) \\cdot dt$。\n$3$. 在新位置计算新的加速度 $\\mathbf{a}(t+dt)$。\n$4$. 完成速度更新：$\\mathbf{v}(t + dt) = \\mathbf{v}(t + dt/2) + \\mathbf{a}(t+dt) \\cdot dt/2$。\n该方案是显式时间可逆的。如果执行一个大小为 $dt$ 的步长，将最终速度取反，再执行一个大小为 $dt$ 的步长，系统将精确返回其初始状态，不计浮点舍入误差。此外，作为辛方法，意味着在许多步长之后，积分器不会精确地守恒真实的哈密顿量 $H$，而是守恒一个与之接近的“影子哈密顿量” $H' = H + O(dt^2)$，并且能以非常高的精度保持其守恒。此特性带来了出色的长期能量守恒（无长期漂移）和稳定性。因此，对于时间反演测试，Verlet 方法的失配 $\\delta x$ 应主要由机器精度舍入误差的累积所主导。\n\n相反，经典四阶龙格-库塔 (RK4) 方法是一种通用的、高精度的常微分方程求解器。对于系统 $\\dot{\\mathbf{y}} = f(\\mathbf{y}, t)$，单步计算如下：\n$\\mathbf{k}_1 = f(\\mathbf{y}_n, t_n)$\n$\\mathbf{k}_2 = f(\\mathbf{y}_n + \\frac{dt}{2}\\mathbf{k}_1, t_n + \\frac{dt}{2})$\n$\\mathbf{k}_3 = f(\\mathbf{y}_n + \\frac{dt}{2}\\mathbf{k}_2, t_n + \\frac{dt}{2})$\n$\\mathbf{k}_4 = f(\\mathbf{y}_n + dt\\mathbf{k}_3, t_n + dt)$\n$\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{dt}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$\n尽管 RK4 具有 $O(dt^5)$ 阶的微小局部截断误差，但它不是辛方法。它不保留哈密顿动力学的几何结构，也不守恒影子哈密顿量。它的误差虽然小，却是耗散性的，并破坏了底层物理的时间反演对称性。因此，前向-后向积分测试将产生一个远大于机器精度的失配 $\\delta x$，这主要是由该方法的累积截断误差引起的。\n\n数值实现将包含一个主程序，为每个测试用例组织实验。该程序将调用一个加速度函数，根据所有粒子当前的位置计算引力加速度。为提高效率，使用了向量化的 `NumPy` 操作。两个独立的步进函数 `verlet_step` 和 `rk4_step` 将实现各自积分器的逻辑。\n\n预期结果将凸显这些理论差异。\n对于稳定的二体系统（用例 A, B），Verlet (A) 应表现出接近机器精度的 $\\delta x$，证明其固有的可逆性。RK4 (B) 将显示出显著更大的 $\\delta x$，反映其非辛性质。\n对于混沌的三体系统（用例 C, D, E），由于小误差的指数级放大（李雅普诺夫不稳定性），情况更为复杂。即使对于 Verlet (C)，舍入误差也会被放大，导致 $\\delta x$ 大于稳定情况。然而，RK4 (D) 的表现会更差，因为其更大的系统性截断误差和舍入误差都会被放大。用例 E 使用大时间步长的 Verlet，将证明辛性并非精度的保证；大的 $dt$ 意味着影子哈密顿量与真实哈密顿量相去甚远，由此产生的巨大单步误差被混沌动力学严重放大，导致可逆性得分很差。", "answer": "```python\nimport numpy as np\n\ndef get_accelerations(pos, mass, G, epsilon):\n    \"\"\"\n    Calculate the acceleration of each body due to gravitational interaction.\n    The force on particle i from j is F_ij = -G m_i m_j * (r_i - r_j) / (|r_i - r_j|^2 + e^2)^(3/2).\n    Acceleration a_i = F_i / m_i = sum_j(F_ij) / m_i.\n    \n    Args:\n        pos (np.ndarray): Positions of N bodies, shape (N, 3).\n        mass (np.ndarray): Masses of N bodies, shape (N, 1).\n        G (float): Gravitational constant.\n        epsilon (float): Softening length.\n\n    Returns:\n        np.ndarray: Accelerations of N bodies, shape (N, 3).\n    \"\"\"\n    N = pos.shape[0]\n    # rij is a (N, N, 3) array where rij[i, j, :] = pos[i, :] - pos[j, :]\n    rij = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n\n    # dist_sq is a (N, N) array of squared separations\n    dist_sq = np.sum(rij**2, axis=-1)\n\n    # Add epsilon^2 to the denominator and compute inv_r3 = (dist^2 + e^2)^(-3/2)\n    # The diagonal (i=j) will have dist_sq=0, but epsilon avoids division by zero.\n    inv_r3 = (dist_sq + epsilon**2)**(-1.5)\n    \n    # Calculate forces. F_ij's magnitude is G * m_i * m_j / (dist^2+eps^2).\n    # Force vector is this magnitude * -(r_i-r_j)/dist. We rewrite this.\n    # a_i = sum_j!=i -G m_j (r_i - r_j) * inv_r3_ij\n    \n    # We can write `a_i = G * sum_j m_j * (r_j - r_i) * inv_r3_ij`.\n    # Let's use the vectorized force calculation for clarity.\n    \n    # Mass matrix M[i, j] = m_i * m_j\n    mass_matrix = mass @ mass.T\n    \n    # Force magnitude component, excluding the vector part and signs.\n    # Note: F_ij = -G m_i m_j * rij / denom^(3/2)\n    # The term G * m_i * m_j * inv_r3 corresponds to the scalar part of the force.\n    scalar_force = G * mass_matrix * inv_r3\n\n    # Multiply by the displacement vectors. Diagonal rij[i,i] is zero, so F_ii is zero.\n    # F_vectors[i,j,:] is the force on i from j.\n    F_vectors = -rij * scalar_force[..., np.newaxis]\n\n    # Sum forces on each particle\n    F_total = np.sum(F_vectors, axis=1)\n\n    # a = F/m\n    accel = F_total / mass\n    \n    return accel\n\ndef verlet_step(pos, vel, acc, mass, G, epsilon, dt):\n    \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n    vel_half = vel + acc * 0.5 * dt\n    pos_new = pos + vel_half * dt\n    acc_new = get_accelerations(pos_new, mass, G, epsilon)\n    vel_new = vel_half + acc_new * 0.5 * dt\n    return pos_new, vel_new, acc_new\n\ndef rk4_step(pos, vel, mass, G, epsilon, dt):\n    \"\"\"A single step of the classic 4th-order Runge-Kutta integrator.\"\"\"\n    # k1\n    k1_x = vel\n    k1_v = get_accelerations(pos, mass, G, epsilon)\n    \n    # k2\n    k2_x = vel + k1_v * dt * 0.5\n    k2_v = get_accelerations(pos + k1_x * dt * 0.5, mass, G, epsilon)\n\n    # k3\n    k3_x = vel + k2_v * dt * 0.5\n    k3_v = get_accelerations(pos + k2_x * dt * 0.5, mass, G, epsilon)\n\n    # k4\n    k4_x = vel + k3_v * dt\n    k4_v = get_accelerations(pos + k3_x * dt, mass, G, epsilon)\n\n    # Update\n    pos_new = pos + (dt / 6.0) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n    vel_new = vel + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n    \n    return pos_new, vel_new\n\ndef run_experiment(integrator_name, N, masses, pos_init, vel_init, dt, T, G, epsilon):\n    \"\"\"Performs the forward-backward integration and returns the mismatch.\"\"\"\n    pos = pos_init.copy()\n    vel = vel_init.copy()\n    \n    num_steps = int(round(T / dt))\n\n    # Forward integration\n    if integrator_name == 'verlet':\n        acc = get_accelerations(pos, masses, G, epsilon)\n        for _ in range(num_steps):\n            pos, vel, acc = verlet_step(pos, vel, acc, masses, G, epsilon, dt)\n    elif integrator_name == 'rk4':\n        for _ in range(num_steps):\n            pos, vel = rk4_step(pos, vel, masses, G, epsilon, dt)\n    \n    # Reverse velocities\n    vel = -vel\n\n    # Backward integration\n    if integrator_name == 'verlet':\n        # acc at time T is needed to start Verlet again\n        acc = get_accelerations(pos, masses, G, epsilon)\n        for _ in range(num_steps):\n            pos, vel, acc = verlet_step(pos, vel, acc, masses, G, epsilon, dt)\n    elif integrator_name == 'rk4':\n        for _ in range(num_steps):\n            pos, vel = rk4_step(pos, vel, masses, G, epsilon, dt)\n            \n    # Compute RMS position mismatch\n    diffs = pos - pos_init\n    rms_mismatch = np.sqrt(np.sum(diffs**2) / N)\n    \n    return rms_mismatch\n\ndef solve():\n    G_const = 1.0\n    epsilon_const = 1e-2\n\n    test_cases = [\n        {\n            \"id\": \"A\", \"integrator\": \"verlet\", \"N\": 2,\n            \"masses\": np.array([[0.5], [0.5]]),\n            \"pos\": np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"vel\": np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]]),\n            \"dt\": 1e-3, \"T\": 2.0\n        },\n        {\n            \"id\": \"B\", \"integrator\": \"rk4\", \"N\": 2,\n            \"masses\": np.array([[0.5], [0.5]]),\n            \"pos\": np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"vel\": np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]]),\n            \"dt\": 1e-2, \"T\": 2.0\n        },\n        {\n            \"id\": \"C\", \"integrator\": \"verlet\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 2e-3, \"T\": 5.0\n        },\n        {\n            \"id\": \"D\", \"integrator\": \"rk4\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 5e-3, \"T\": 5.0\n        },\n        {\n            \"id\": \"E\", \"integrator\": \"verlet\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 5e-2, \"T\": 5.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_x = run_experiment(\n            integrator_name=case[\"integrator\"],\n            N=case[\"N\"],\n            masses=case[\"masses\"],\n            pos_init=case[\"pos\"],\n            vel_init=case[\"vel\"],\n            dt=case[\"dt\"],\n            T=case[\"T\"],\n            G=G_const,\n            epsilon=epsilon_const\n        )\n        results.append(delta_x)\n\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3540226"}]}