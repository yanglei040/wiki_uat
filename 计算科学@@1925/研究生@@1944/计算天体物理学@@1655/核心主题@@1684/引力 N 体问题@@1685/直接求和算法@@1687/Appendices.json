{"hands_on_practices": [{"introduction": "任何可靠模拟的基础都是对其核心物理原理的可验证实现。本练习将指导您完成$N$体代码最基本的健全性检查之一：测试质心运动的守恒性。通过实施该测试 ([@problem_id:3508414])，您将获得实践经验，以验证您的力求和计算是否正确遵守了牛顿第三定律，这是经典力学的基石。", "problem": "您的任务是设计并实现一个直接求和引力 $N$ 体积分器，该积分器可以定量地测试系统质心运动的守恒性，作为力求和正确性的健全性检查。从牛顿运动定律和质心的定义出发，并仅使用内部引力相互作用。以此为基础，推导出仅受内力作用的封闭系统的质心遵循惯性运动这一事实，并利用该理论结果为数值模拟定义一个可测量的偏差。您的程序必须直接实现逐对力计算（无树代码或多极展开）、一个时间积分器和一个诊断工具，该诊断工具用于将模拟的质心轨迹与预期的惯性轨迹进行比较。\n\n物理模型是带有 Plummer 软化的牛顿引力，粒子 $i$ 因粒子 $j$ 而受到的总引力加速度由软化的牛顿逐对定律构建，并对所有 $j\\neq i$ 进行求和。在国际单位制（SI）中使用引力常数 $G$，所有距离以米表示，质量以千克表示，时间以秒表示。\n\n您的算法必须实现两种力累积模式：\n- 正确的对称逐对累积，为每个相互作用的粒子对强制执行大小相等、方向相反的成对贡献，这与牛顿第三定律一致。\n- 一个扰动模式，通过一个微小的无量纲参数 $\\eta$ 故意违反作用力-反作用力对称性，以模拟错误的力求和。在此模式下，对于每个无序对 $\\{i,j\\}$，将其对粒子 $i$ 加速度的贡献乘以 $(1+\\eta)$，对粒子 $j$ 加速度的贡献乘以 $(1-\\eta)$。\n\n时间积分必须使用辛蛙跳格式。从时间 $t=0$ 的给定位置和速度开始初始化，并以均匀的时间步长 $\\Delta t$ 前进 $n_{\\mathrm{steps}}$ 步。在每一步，计算系统的质心位置 $\\mathbf{R}_{\\mathrm{cm}}(t)$，并将其与根据初始质心位置 $\\mathbf{R}_{\\mathrm{cm}}(0)$ 和初始质心速度 $\\mathbf{V}_{\\mathrm{cm}}(0)$ 预测的惯性参考轨迹进行比较。将时间 $t$ 的偏差定义为模拟的质心位置与惯性参考质心位置之间矢量差的欧几里得范数。您的程序必须为每个测试用例报告整个模拟时间内的最大偏差。\n\n所有输出必须以国际单位制（SI）报告。最大偏差必须以米表示。对于任何矢量运算，隐式使用弧度；不直接需要角度。您的程序必须将每个报告值格式化为具有 $6$ 位有效数字的科学记数法十进制浮点数。\n\n测试套件。实现以下四个测试用例；对于每个用例，计算系统质心与其预期惯性轨迹的最大偏差。对于所有用例，使用引力常数 $G=6.67430\\times 10^{-11}\\ \\mathrm{m^{3}\\ kg^{-1}\\ s^{-2}}$ 和每个用例提供的 Plummer 软化长度 $\\epsilon$。\n\n- 情况 1（理想情况，正确对称性）：\n  - $N=3$\n  - 质量 $\\mathbf{m}=[5\\times 10^{24},\\ 6\\times 10^{24},\\ 7\\times 10^{24}]\\ \\mathrm{kg}$\n  - 初始位置 $\\mathbf{r}(0)$（单位：米）：\n    - $\\mathbf{r}_1=[0,\\ 0,\\ 0]$\n    - $\\mathbf{r}_2=[2\\times 10^{9},\\ 0,\\ 0]$\n    - $\\mathbf{r}_3=[-1\\times 10^{9},\\ 1.5\\times 10^{9},\\ 0]$\n  - 初始速度 $\\mathbf{v}(0)$（单位：米/秒）：\n    - $\\mathbf{v}_1=[0,\\ 300,\\ 0]$\n    - $\\mathbf{v}_2=[0,\\ -100,\\ 0]$\n    - $\\mathbf{v}_3=[50,\\ 0,\\ 0]$\n  - 时间步长 $\\Delta t=2000\\ \\mathrm{s}$，步数 $n_{\\mathrm{steps}}=1000$\n  - 软化 $\\epsilon=10^{6}\\ \\mathrm{m}$\n  - 对称性扰动参数 $\\eta=0$\n\n- 情况 2（违反作用力-反作用力，检测漂移）：\n  - 除使用 $\\eta=1\\times 10^{-5}$ 外，与情况 1 相同\n\n- 情况 3（边界条件 $N=1$）：\n  - $N=1$\n  - 质量 $\\mathbf{m}=[1\\times 10^{26}]\\ \\mathrm{kg}$\n  - 初始位置 $\\mathbf{r}(0)$（单位：米）：\n    - $\\mathbf{r}_1=[1\\times 10^{8},\\ -2\\times 10^{8},\\ 0]$\n  - 初始速度 $\\mathbf{v}(0)$（单位：米/秒）：\n    - $\\mathbf{v}_1=[1200,\\ -500,\\ 0]$\n  - 时间步长 $\\Delta t=1000\\ \\mathrm{s}$，步数 $n_{\\mathrm{steps}}=2000$\n  - 软化 $\\epsilon=10^{6}\\ \\mathrm{m}$\n  - 对称性扰动参数 $\\eta=0$\n\n- 情况 4（总动量为零，预期质心静止）：\n  - $N=4$\n  - 质量 $\\mathbf{m}=[2\\times 10^{25},\\ 3\\times 10^{25},\\ 4\\times 10^{25},\\ 5\\times 10^{25}]\\ \\mathrm{kg}$\n  - 初始位置 $\\mathbf{r}(0)$（单位：米）：\n    - $\\mathbf{r}_1=[1\\times 10^{9},\\ 0,\\ 0]$\n    - $\\mathbf{r}_2=[-1\\times 10^{9},\\ 1\\times 10^{9},\\ 0]$\n    - $\\mathbf{r}_3=[0,\\ -1\\times 10^{9},\\ 0]$\n    - $\\mathbf{r}_4=[2\\times 10^{9},\\ 2\\times 10^{9},\\ 0]$\n  - 初始速度 $\\mathbf{v}(0)$（单位：米/秒）：\n    - $\\mathbf{v}_1=[200,\\ 0,\\ 0]$\n    - $\\mathbf{v}_2=[-100,\\ 100,\\ 0]$\n    - $\\mathbf{v}_3=[0,\\ -50,\\ 0]$\n    - $\\mathbf{v}_4=[-20,\\ -20,\\ 0]$\n  - 时间步长 $\\Delta t=1500\\ \\mathrm{s}$，步数 $n_{\\mathrm{steps}}=1200$\n  - 软化 $\\epsilon=5\\times 10^{5}\\ \\mathrm{m}$\n  - 对称性扰动参数 $\\eta=0$\n\n所需的最终输出格式。您的程序应生成单行输出，其中包含四个最大偏差（单位：米），每个都格式化为具有 $6$ 位有效数字的科学记数法，作为一个用方括号括起来的逗号分隔列表。例如，输出必须具有 \"[x,y,z,w]\" 的形式，其中 x、y、z 和 w 均为用科学记数法书写、具有 $6$ 位有效数字且不带单位的浮点数。不应打印任何其他文本。", "solution": "该问题提法明确，具有科学依据，并包含了获得唯一解所需的所有必要信息。它要求设计并实现一个 $N$ 体积分器，以测试质心运动的守恒性，这是牛顿第三定律的直接推论，为力求和算法提供了基本的健全性检查。我们将进行完整的求解。\n\n### 理论基础：封闭系统中的质心运动\n\n这个问题的基础在于牛顿力学。我们首先定义一个由 $N$ 个粒子组成的系统的质心（CM），其中粒子 $i$ 的质量为 $m_i$，位置矢量为 $\\mathbf{r}_i$。\n\n系统的总质量为 $M_{\\mathrm{tot}} = \\sum_{i=1}^{N} m_i$。\n质心位置 $\\mathbf{R}_{\\mathrm{cm}}$ 是粒子位置的质量加权平均值：\n$$\n\\mathbf{R}_{\\mathrm{cm}}(t) = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\mathbf{r}_i(t)\n$$\n\n对时间 $t$ 求导，得到质心速度 $\\mathbf{V}_{\\mathrm{cm}}$：\n$$\n\\mathbf{V}_{\\mathrm{cm}}(t) = \\frac{d\\mathbf{R}_{\\mathrm{cm}}}{dt} = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\frac{d\\mathbf{r}_i}{dt} = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\mathbf{v}_i(t)\n$$\n量 $\\sum m_i \\mathbf{v}_i$ 是系统的总动量 $\\mathbf{P}_{\\mathrm{tot}}$，所以 $\\mathbf{P}_{\\mathrm{tot}} = M_{\\mathrm{tot}} \\mathbf{V}_{\\mathrm{cm}}$。\n\n再求导一次，得到质心加速度 $\\mathbf{A}_{\\mathrm{cm}}$：\n$$\n\\mathbf{A}_{\\mathrm{cm}}(t) = \\frac{d\\mathbf{V}_{\\mathrm{cm}}}{dt} = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\frac{d\\mathbf{v}_i}{dt} = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\mathbf{a}_i(t)\n$$\n\n根据牛顿第二定律，项 $m_i \\mathbf{a}_i$ 等于作用在粒子 $i$ 上的总力 $\\mathbf{F}_i^{\\mathrm{tot}}$。对于一个只受内力作用的封闭系统，这个力是来自系统中所有其他粒子 $j$ 的力的矢量和：\n$$\nm_i \\mathbf{a}_i = \\mathbf{F}_i^{\\mathrm{tot}} = \\sum_{j=1, j\\neq i}^{N} \\mathbf{F}_{ij}\n$$\n其中 $\\mathbf{F}_{ij}$ 是粒子 $j$ 施加在粒子 $i$ 上的力。将此代入 $\\mathbf{A}_{\\mathrm{cm}}$ 的方程中，得到：\n$$\nM_{\\mathrm{tot}} \\mathbf{A}_{\\mathrm{cm}} = \\sum_{i=1}^{N} \\mathbf{F}_i^{\\mathrm{tot}} = \\sum_{i=1}^{N} \\sum_{j=1, j\\neq i}^{N} \\mathbf{F}_{ij}\n$$\n\n关键步骤是应用牛顿第三定律（作用力与反作用力定律），该定律指出任意两个粒子之间的力大小相等、方向相反：$\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$。右侧的双重求和可以看作是对所有相互作用的粒子对 $\\{i,j\\}$ 的求和。对于每一对，求和中都包含 $\\mathbf{F}_{ij}$ 和 $\\mathbf{F}_{ji}$。\n$$\n\\sum_{i=1}^{N} \\sum_{j=1, j\\neq i}^{N} \\mathbf{F}_{ij} = \\sum_{i  j} (\\mathbf{F}_{ij} + \\mathbf{F}_{ji})\n$$\n根据牛顿第三定律，每一项 $(\\mathbf{F}_{ij} + \\mathbf{F}_{ji})$ 都恒等于零。因此，系统上的总内力为零：\n$$\n\\sum_{i=1}^{N} \\mathbf{F}_i^{\\mathrm{tot}} = \\mathbf{0}\n$$\n这意味着 $M_{\\mathrm{tot}} \\mathbf{A}_{\\mathrm{cm}} = \\mathbf{0}$，因此 $\\mathbf{A}_{\\mathrm{cm}} = \\mathbf{0}$。质心的加速度为零。这就是动量守恒定律。\n\n如果 $\\mathbf{A}_{\\mathrm{cm}} = \\mathbf{0}$，那么速度 $\\mathbf{V}_{\\mathrm{cm}}$ 是一个常数，等于其初始值 $\\mathbf{V}_{\\mathrm{cm}}(0)$。再次积分，我们发现质心必须遵循一条惯性轨迹（以恒定速度沿直线运动）：\n$$\n\\mathbf{R}_{\\mathrm{cm}}(t) = \\mathbf{R}_{\\mathrm{cm}}(0) + \\mathbf{V}_{\\mathrm{cm}}(0) t\n$$\n这个方程定义了用于检验数值模拟的参考轨迹。\n\n### 算法设计与数值实现\n\n现在的任务是将这个物理原理转化为数值算法。\n\n#### 1. 使用 Plummer 软化的力计算\n\n粒子 $i$ 因粒子 $j$ 而受到的引力由牛顿引力定律给出，并使用 Plummer 软化进行修正，以避免粒子间距离非常近时出现数值奇异点。力矢量为：\n$$\n\\mathbf{F}_{ij} = G m_i m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\left( \\|\\mathbf{r}_j - \\mathbf{r}_i\\|^2 + \\epsilon^2 \\right)^{3/2}}\n$$\n其中 $G$ 是引力常数，$\\epsilon$ 是软化长度。粒子 $i$ 的加速度为 $\\mathbf{a}_i = \\frac{1}{m_i} \\sum_{j \\neq i} \\mathbf{F}_{ij}$。\n\n#### 2. 违反作用力-反作用力对称性\n\n诊断测试的核心涉及两种力累积模式：\n- **对称模式 ($\\eta = 0$)：** 在一个对唯一粒子对 $(i, j)$（其中 $i  j$）进行直接求和的循环中，我们计算 $\\mathbf{F}_{ij}$ 并将其加到粒子 $i$ 的总受力上，同时将 $\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$ 加到粒子 $j$ 的总受力上。这正确地实现了牛顿第三定律。在数值误差范围内，系统总动量是守恒的。\n- **扰动模式 ($\\eta \\neq 0$)：** 问题指定了一种对对称性的故意违反。对于每个粒子对 $\\{i,j\\}$（我们使用 $i  j$），我们计算加速度贡献 $\\mathbf{a}_{i \\leftarrow j}$ 和 $\\mathbf{a}_{j \\leftarrow i}$。然后，我们通过将对粒子 $i$ 加速度的贡献乘以 $(1+\\eta)$，对粒子 $j$ 加速度的贡献乘以 $(1-\\eta)$ 来累加这些贡献。这引入了一个净的非零内力，会导致质心加速，从而偏离其惯性轨迹。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to execute all test cases and print the final result.\n    \"\"\"\n    G = 6.67430e-11  # SI units: m^3 kg^-1 s^-2\n\n    test_cases = [\n        # Case 1 (happy path, correct symmetry)\n        {\n            \"N\": 3,\n            \"masses\": np.array([5e24, 6e24, 7e24]),\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0],\n                [2e9, 0.0, 0.0],\n                [-1e9, 1.5e9, 0.0]\n            ]),\n            \"velocities\": np.array([\n                [0.0, 300.0, 0.0],\n                [0.0, -100.0, 0.0],\n                [50.0, 0.0, 0.0]\n            ]),\n            \"dt\": 2000.0,\n            \"n_steps\": 1000,\n            \"epsilon\": 1e6,\n            \"eta\": 0.0,\n        },\n        # Case 2 (action–reaction violation, detect drift)\n        {\n            \"N\": 3,\n            \"masses\": np.array([5e24, 6e24, 7e24]),\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0],\n                [2e9, 0.0, 0.0],\n                [-1e9, 1.5e9, 0.0]\n            ]),\n            \"velocities\": np.array([\n                [0.0, 300.0, 0.0],\n                [0.0, -100.0, 0.0],\n                [50.0, 0.0, 0.0]\n            ]),\n            \"dt\": 2000.0,\n            \"n_steps\": 1000,\n            \"epsilon\": 1e6,\n            \"eta\": 1e-5,\n        },\n        # Case 3 (boundary condition N=1)\n        {\n            \"N\": 1,\n            \"masses\": np.array([1e26]),\n            \"positions\": np.array([\n                [1e8, -2e8, 0.0]\n            ]),\n            \"velocities\": np.array([\n                [1200.0, -500.0, 0.0]\n            ]),\n            \"dt\": 1000.0,\n            \"n_steps\": 2000,\n            \"epsilon\": 1e6,\n            \"eta\": 0.0,\n        },\n        # Case 4 (zero total momentum)\n        {\n            \"N\": 4,\n            \"masses\": np.array([2e25, 3e25, 4e25, 5e25]),\n            \"positions\": np.array([\n                [1e9, 0.0, 0.0],\n                [-1e9, 1e9, 0.0],\n                [0.0, -1e9, 0.0],\n                [2e9, 2e9, 0.0]\n            ]),\n            \"velocities\": np.array([\n                [200.0, 0.0, 0.0],\n                [-100.0, 100.0, 0.0],\n                [0.0, -50.0, 0.0],\n                [-20.0, -20.0, 0.0]\n            ]),\n            \"dt\": 1500.0,\n            \"n_steps\": 1200,\n            \"epsilon\": 5e5,\n            \"eta\": 0.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        max_deviation = run_simulation(\n            masses=case[\"masses\"],\n            positions=case[\"positions\"],\n            velocities=case[\"velocities\"],\n            G=G,\n            dt=case[\"dt\"],\n            n_steps=case[\"n_steps\"],\n            epsilon=case[\"epsilon\"],\n            eta=case[\"eta\"]\n        )\n        results.append(f\"{max_deviation:.6e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_accelerations(positions, masses, G, epsilon, eta):\n    \"\"\"\n    Calculates gravitational accelerations using direct summation.\n    \n    This function implements both symmetric force accumulation (eta=0) and a\n    perturbed mode that violates Newton's third law (eta != 0).\n    \"\"\"\n    n_particles = positions.shape[0]\n    accelerations = np.zeros((n_particles, 3))\n    \n    # Iterate over unique pairs of particles (i, j) where i  j\n    for i in range(n_particles):\n        for j in range(i + 1, n_particles):\n            # Vector from particle i to particle j\n            r_ij = positions[j] - positions[i]\n            \n            # Squared distance with softening\n            dist_sq = np.sum(r_ij**2)\n            \n            # Softened inverse cube law factor\n            inv_dist_cubed = (dist_sq + epsilon**2)**(-1.5)\n            \n            # Calculate acceleration contribution for each particle due to the other\n            acc_i_due_to_j = G * masses[j] * inv_dist_cubed * r_ij\n            acc_j_due_to_i = G * masses[i] * inv_dist_cubed * (-r_ij)\n            \n            # Apply symmetric or asymmetric force accumulation\n            # For a pair {i,j}, the contribution to i's acceleration is scaled by (1+eta)\n            # and to j's acceleration by (1-eta).\n            accelerations[i] += (1.0 + eta) * acc_i_due_to_j\n            accelerations[j] += (1.0 - eta) * acc_j_due_to_i\n            \n    return accelerations\n\ndef run_simulation(masses, positions, velocities, G, dt, n_steps, epsilon, eta):\n    \"\"\"\n    Runs a single N-body simulation and returns the max CM deviation.\n    \"\"\"\n    # Defensive copies to avoid modifying the original test case data\n    pos = np.copy(positions)\n    vel = np.copy(velocities)\n    masses_reshaped = masses.reshape(-1, 1)\n    \n    total_mass = np.sum(masses)\n    \n    # Calculate initial center-of-mass position and velocity\n    if total_mass > 0:\n        R_cm_0 = np.sum(masses_reshaped * pos, axis=0) / total_mass\n        V_cm_0 = np.sum(masses_reshaped * vel, axis=0) / total_mass\n    else: # Handle case of zero total mass if needed, though not in tests\n        R_cm_0 = np.zeros(3)\n        V_cm_0 = np.zeros(3)\n\n    max_deviation = 0.0\n\n    # Leapfrog Integrator (KDK - Kick-Drift-Kick)\n    \n    # Initial Kick (half-step)\n    acc = calculate_accelerations(pos, masses, G, epsilon, eta)\n    vel += acc * (dt / 2.0)\n    \n    for step in range(n_steps):\n        # Drift (full step)\n        pos += vel * dt\n        \n        # Kick (full step)\n        acc = calculate_accelerations(pos, masses, G, epsilon, eta)\n        vel += acc * dt\n        \n        # --- Diagnostic Calculation ---\n        current_time = (step + 1) * dt\n        \n        # Calculate simulated center-of-mass position\n        R_cm_sim = np.sum(masses_reshaped * pos, axis=0) / total_mass\n        \n        # Calculate theoretical inertial reference position\n        R_cm_ref = R_cm_0 + V_cm_0 * current_time\n        \n        # Calculate deviation and update maximum\n        deviation = np.linalg.norm(R_cm_sim - R_cm_ref)\n        if deviation > max_deviation:\n            max_deviation = deviation\n            \n    return max_deviation\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3508414"}, {"introduction": "除了理论上的正确性，直接求和算法的实际精度还受到浮点运算有限精度的限制。本练习通过比较使用单精度和双精度累加器进行的力计算，深入探讨了数值误差这一关键主题。通过这个探索 ([@problem_id:3508472])，您将清楚地了解舍入误差是如何累积并影响结果保真度的，这是所有科学计算中的一个关键考量。", "problem": "考虑一个在牛顿引力作用下的自引力 $N$ 体系统，该系统在无量纲 $N$ 体单位下建模，其中 $G = 1$。设位置 $\\mathbf{x}_i \\in \\mathbb{R}^3$ 和速度 $\\mathbf{v}_i \\in \\mathbb{R}^3$ 以双精度（binary $64$）存储。粒子 $i$ 因所有其他粒子而受到的引力加速度定义为\n$$\n\\mathbf{a}_i = \\sum_{j \\ne i} m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\left(\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^2 + \\epsilon^2\\right)^{3/2}},\n$$\n其中 $m_j$ 是粒子 $j$ 的质量，$\\epsilon > 0$ 是一个 Plummer 软化长度，用于防止在零间距时出现奇异力。在直接求和算法中，累加 $\\mathbf{a}_i$ 对 $j$ 的部分和可以用单精度（binary $32$）或双精度（binary $64$）计算。在这两种情况下，位置 $\\mathbf{x}_i$ 和速度 $\\mathbf{v}_i$ 仍然以双精度存储。\n\n你需要量化在使用单精度与双精度累加加速度矢量时引入的数值误差，而所有输入（位置、速度、质量、软化长度）均以双精度表示。对于下述每个测试用例，计算以下误差度量：\n$$\nE_{\\max} = \\max_{i \\in \\{1,\\dots,N\\}} \\left( \\frac{\\lVert \\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})} \\rVert_2}{\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2} \\right),\n$$\n对于接近零的分母，采用以下约定：如果 $\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2 \\le \\tau$，则用绝对误差 $\\lVert \\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})} \\rVert_2$ 代替该比率。使用阈值 $\\tau = 10^{-300}$。加速度 $\\mathbf{a}_i^{(\\text{single})}$ 和 $\\mathbf{a}_i^{(\\text{double})}$ 都必须使用上述相同的贡献公式，唯一的区别在于对 $j$ 的求和累加：前者使用单精度累加器，后者使用双精度累加器。在双精度下计算贡献项，对于单精度累加，在相加前将每个贡献项转换为单精度。\n\n使用以下测试套件。所有随机值必须使用提供的种子确定性地生成，并且所有量在 $N$ 体单位下都是无量纲的：\n\n- 测试用例 $1$（一般配置，中等 $N$）：$N = 32$。位置 $\\mathbf{x}_i$ 从 $[-1,1]^3$ 上的均匀分布中独立抽取，种子为 $12345$。质量 $m_i$ 从 $[0.5,1.5]$ 上的均匀分布中独立抽取，使用相同的种子。速度 $\\mathbf{v}_i$ 从 $[-0.1,0.1]^3$ 上的均匀分布中独立抽取，使用相同的种子。使用软化长度 $\\epsilon = 10^{-3}$。\n\n- 测试用例 $2$（成对对称与抵消）：$N = 20$。从 $[-0.5,0.5]^3$ 上均匀生成 $10$ 个基向量 $\\mathbf{b}_k$，种子为 $777$，并通过配对 $\\mathbf{x}_{2k-1} = \\mathbf{b}_k$ 和 $\\mathbf{x}_{2k} = -\\mathbf{b}_k$（其中 $k = 1,\\dots,10$）来形成位置。将所有质量设置为 $m_i = 1$。速度 $\\mathbf{v}_i$ 从 $[-0.1,0.1]^3$ 上的均匀分布中独立抽取，使用相同的种子。使用软化长度 $\\epsilon = 10^{-3}$。\n\n- 测试用例 $3$（更大的 $N$ 以突显累加效应）：$N = 256$。位置 $\\mathbf{x}_i$ 从 $[-2,2]^3$ 上的均匀分布中独立抽取，种子为 $2021$。将所有质量设置为 $m_i = 1$。速度 $\\mathbf{v}_i$ 从 $[-0.01,0.01]^3$ 上的均匀分布中独立抽取，使用相同的种子。使用软化长度 $\\epsilon = 10^{-4}$。\n\n- 测试用例 $4$（贡献项的动态范围）：$N = 64$。将一个质量为 $m_1 = 10^6$ 的粒子置于原点。其余 $63$ 个位置从 $[0.1,1]^3$ 上的均匀分布中独立抽取，种子为 $42$。对于 $i \\ge 2$，其余质量 $m_i$ 从 $[0.5,1.5]$ 上的均匀分布中独立抽取，使用相同的种子。速度 $\\mathbf{v}_i$ 从 $[-0.01,0.01]^3$ 上的均匀分布中独立抽取，使用相同的种子。使用软化长度 $\\epsilon = 10^{-2}$。\n\n您的程序必须为两种累加精度实现加速度的直接求和，并为每个测试用例计算 $E_{\\max}$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，结果采用科学记数法，小数点后恰好有六位数字（例如 $[1.234567\\text{e-}08,9.876543\\text{e-}07,\\dots]$）。输出为 $N$ 体单位下的无量纲数。不允许外部输入；所有数据必须按规定在程序内生成。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于牛顿力学和数值分析的原理，问题定义良好，所有必要的参数和条件都已明确，并且其表述是客观的。任务是量化在一个 $N$ 体系统中，与双精度基准相比，使用单精度浮点运算累加引力加速度时所引入的数值误差。\n\n问题的核心在于对粒子 $i$ 上的引力加速度 $\\mathbf{a}_i$ 进行直接求和计算：\n$$\n\\mathbf{a}_i = \\sum_{j \\ne i} m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\left(\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^2 + \\epsilon^2\\right)^{3/2}}\n$$\n其中 $\\mathbf{x}_i$ 是位置，$m_j$ 是质量，$\\epsilon$ 是 Plummer 软化长度。问题要求比较两种计算变体：$\\mathbf{a}_i^{(\\text{double})}$，其中求和以双精度（`binary64`）累加；以及 $\\mathbf{a}_i^{(\\text{single})}$，其中求和以单精度（`binary32`）累加。所有输入量（$\\mathbf{x}_i, m_j, \\epsilon$）都以双精度提供。\n\n所研究的基本原理是浮点数求和中的舍入误差累积。在对一串数字求和时，表示的有限精度可能导致准确性损失。当一个小数加到一个大数上（吸收）或对许多符号交替的项求和（灾难性抵消）时，这种情况尤其明显。单精度算术的尾数（通常为 $23$ 位）比双精度（$52$ 位）小，因此更容易受到这些效应的影响。\n\n解决此问题的算法方法如下：\n\n1.  **系统初始化**：对于每个测试用例，使用指定的参数和随机种子确定性地生成粒子位置 $\\mathbf{x}_i$ 和质量 $m_i$。这确保了可复现性。使用 NumPy 的 `default_rng` 提供了一个现代且可靠的伪随机数源。\n\n2.  **力贡献的矢量化计算**：直接求和算法的计算复杂度为 $O(N^2)$，因为它涉及计算所有唯一粒子对之间的相互作用。为了高效地实现这一点，采用了矢量化方法。\n    -   首先，使用 NumPy 的广播功能，为所有粒子对 $(i, j)$ 计算一个 $N \\times N \\times 3$ 的位移矢量数组 $\\Delta\\mathbf{x}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$。\n    -   由此，计算出一个 $N \\times N$ 的距离平方矩阵 $\\lVert \\Delta\\mathbf{x}_{ij} \\rVert^2$。\n    -   然后，对所有粒子对逐元素计算软化反立方定律项 $(\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^2 + \\epsilon^2)^{-3/2}$，得到一个 $N \\times N$ 矩阵。将对应于 $i=j$ 的对角线元素设置为零，以强制执行 $j \\ne i$ 的条件。\n    -   最后，所有单独的成对加速度贡献项 $\\mathbf{f}_{ij} = m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{(\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^2 + \\epsilon^2)^{3/2}}$ 都在双精度（`float64`）下计算，并存储在一个 $N \\times N \\times 3$ 的数组中。该数组表示要为每个粒子 $i$ 求和的所有项。\n\n3.  **特定精度的加速度累加**：\n    -   **双精度加速度 $\\mathbf{a}_i^{(\\text{double})}$**：通过沿适当的轴（$j$）对预先计算的 `float64` 贡献项求和，来计算所有粒子的加速度矢量。当 `numpy.sum` 函数应用于 `float64` 数组时，默认使用 `float64` 累加器，从而正确地模拟了双精度求和。\n    -   **单精度加速度 $\\mathbf{a}_i^{(\\text{single})}$**：为按规定模拟单精度累加，每个双精度贡献项在添加到累加器*之前*必须转换为单精度（`float32`）。这通过首先创建整个 $N \\times N \\times 3$ 贡献项数组的 `float32` 副本实现。然后，对这个 `float32` 数组使用 `numpy.sum`。求和过程自然地使用 `float32` 累加器进行，从而忠实地复制了指定的数值过程。\n\n4.  **误差度量计算**：分析的核心是计算最大相对误差 $E_{\\max}$。\n    $$\n    E_{\\max} = \\max_{i \\in \\{1,\\dots,N\\}} \\left( \\frac{\\lVert \\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})} \\rVert_2}{\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2} \\right)\n    $$\n    -   为每个粒子计算差分矢量 $\\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})}$。注意，`float32` 结果 $\\mathbf{a}_i^{(\\text{single})}$ 必须转换回 `float64` 以进行此减法，从而保留误差信息。\n    -   为所有粒子计算差分矢量和双精度加速度矢量的 L2 范数（欧几里得范数）。\n    -   为了处理 $\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2$ 接近于零的情况（例如，由于对称性，如测试用例 2 中所示），使用了一个阈值 $\\tau = 10^{-300}$。如果 $\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2 \\le \\tau$，则使用绝对误差 $\\lVert \\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})} \\rVert_2$ 代替比率。这可以防止除以零，并正确处理相对误差可能产生误导性的大值或无穷大的情况。\n    -   最终误差 $E_{\\max}$ 是在所有粒子的单个误差度量中找到的最大值。\n\n此方法应用于四个指定的测试用例中的每一个，并将得到的 $E_{\\max}$ 值按要求收集和格式化。", "answer": "```python\nimport numpy as np\n\ndef generate_test_case_data(case_num):\n    \"\"\"\n    Generates initial conditions for a specified test case.\n    \"\"\"\n    if case_num == 1:\n        N = 32\n        epsilon = 1e-3\n        seed = 12345\n        rng = np.random.default_rng(seed)\n        positions = rng.uniform(-1.0, 1.0, size=(N, 3))\n        masses = rng.uniform(0.5, 1.5, size=N)\n        # Velocities are not needed for acceleration calculation\n    elif case_num == 2:\n        N = 20\n        epsilon = 1e-3\n        seed = 777\n        rng = np.random.default_rng(seed)\n        base_vectors = rng.uniform(-0.5, 0.5, size=(N // 2, 3))\n        positions = np.zeros((N, 3), dtype=np.float64)\n        positions[0::2] = base_vectors\n        positions[1::2] = -base_vectors\n        masses = np.ones(N, dtype=np.float64)\n    elif case_num == 3:\n        N = 256\n        epsilon = 1e-4\n        seed = 2021\n        rng = np.random.default_rng(seed)\n        positions = rng.uniform(-2.0, 2.0, size=(N, 3))\n        masses = np.ones(N, dtype=np.float64)\n    elif case_num == 4:\n        N = 64\n        epsilon = 1e-2\n        seed = 42\n        rng = np.random.default_rng(seed)\n        positions = np.zeros((N, 3), dtype=np.float64)\n        masses = np.zeros(N, dtype=np.float64)\n        \n        # Central massive particle\n        positions[0] = [0.0, 0.0, 0.0]\n        masses[0] = 1e6\n        \n        # Other particles\n        positions[1:] = rng.uniform(0.1, 1.0, size=(N - 1, 3))\n        masses[1:] = rng.uniform(0.5, 1.5, size=N - 1)\n    else:\n        raise ValueError(\"Invalid case number\")\n        \n    return N, positions, masses, epsilon\n\ndef compute_E_max(N, positions, masses, epsilon):\n    \"\"\"\n    Computes accelerations with single and double precision accumulators\n    and returns the maximum relative error E_max.\n    \"\"\"\n    tau = 1e-300\n    \n    # Use broadcasting to compute all pairwise displacement vectors\n    # dx[i, j, :] = positions[j] - positions[i]\n    dx = positions[None, :, :] - positions[:, None, :]\n    \n    # Compute squared distances\n    r_sq = np.sum(dx**2, axis=2)\n    \n    # Compute the softened inverse cube law term\n    # Add a small value to r_sq to avoid division by zero if epsilon is 0, though not required here.\n    inv_r3_soft = (r_sq + epsilon**2)**(-1.5)\n    \n    # Set diagonal elements to 0 to exclude self-interaction (j != i)\n    # This is an efficient way to handle the j != i condition.\n    np.fill_diagonal(inv_r3_soft, 0.0)\n    \n    # Compute all pairwise acceleration contributions in double precision\n    # terms[i, j, :] is the acceleration on particle i due to particle j\n    # Broadcasting masses (1, N) * inv_r3_soft (N, N) -> (N, N)\n    # Then expand dims to (N, N, 1) and multiply by dx (N, N, 3)\n    terms = (masses[None, :] * inv_r3_soft)[:, :, None] * dx\n\n    # 1. Double-precision accumulation\n    # np.sum on a float64 array uses a float64 accumulator\n    a_double = np.sum(terms, axis=1, dtype=np.float64)\n\n    # 2. Single-precision accumulation\n    # Per the problem, cast each term to float32 BEFORE summing.\n    # This is achieved by creating a float32 copy of the terms array.\n    # np.sum on a float32 array will use a float32 accumulator.\n    terms_single = terms.astype(np.float32)\n    a_single = np.sum(terms_single, axis=1)\n\n    # Calculate the error metric E_max\n    # Cast a_single back to float64 for a high-precision difference\n    diff_a = a_single.astype(np.float64) - a_double\n    \n    norm_diff_a = np.linalg.norm(diff_a, axis=1)\n    norm_a_double = np.linalg.norm(a_double, axis=1)\n    \n    # Apply the threshold condition to avoid division by zero/small numbers\n    # Use absolute error where norm_a_double is small\n    errors = np.where(\n        norm_a_double > tau,\n        norm_diff_a / norm_a_double,\n        norm_diff_a\n    )\n    \n    E_max = np.max(errors)\n    \n    return E_max\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [1, 2, 3, 4]\n    results = []\n\n    for case_num in test_cases:\n        N, positions, masses, epsilon = generate_test_case_data(case_num)\n        E_max = compute_E_max(N, positions, masses, epsilon)\n        results.append(E_max)\n\n    # Format output as a list of strings in scientific notation\n    formatted_results = [f\"{res:.6e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3508472"}, {"introduction": "正确的力计算只是第一步；在时间上动态演化系统需要一个数值积分器，而积分器的选择会极大地影响模拟的长期行为。这个实践问题使用“前进-后退”积分实验来揭示时间可逆（辛）积分器和不可逆积分器之间的深刻差异。通过量化截断误差和舍入误差 ([@problem_id:3508413])，您将对不同误差源如何影响$N$体模拟的整体保真度有更深入的理解。", "problem": "考虑一个在牛顿引力作用下演化的小型 $N$ 体系统。计算任务是设计并执行一个正向-反向积分实验，该实验使用直接求和算法计算引力加速度，并量化由截断误差和舍入误差引起的可逆性误差。实验必须在无量纲单位下进行，引力常数 $G=1$。该问题的基本定律和定义是牛顿第二定律和牛顿万有引力定律：质量为 $m_i$ 的粒子 $i$ 的加速度由下式给出：\n$$\n\\frac{d^2 \\boldsymbol{r}_i}{dt^2} = \\boldsymbol{a}_i(\\boldsymbol{r}) = \\sum_{j \\ne i} G m_j \\frac{\\boldsymbol{r}_j - \\boldsymbol{r}_i}{\\left(\\lVert \\boldsymbol{r}_j - \\boldsymbol{r}_i \\rVert^2 + \\epsilon^2 \\right)^{3/2}},\n$$\n其中 $\\boldsymbol{r}_i \\in \\mathbb{R}^3$ 是粒子 $i$ 的位置，$\\boldsymbol{a}_i(\\boldsymbol{r})$ 是由所有其他粒子引起的加速度，$G$ 是引力常数，$\\epsilon$ 是用于正则化近距离接触的 Plummer 软化长度。\n\n你的程序必须：\n- 实现一个直接求和程序，使用上述公式（$G=1$）计算所有粒子的加速度 $\\boldsymbol{a}_i(\\boldsymbol{r})$。\n- 实现两种时间积分方案：\n  - 速度 Verlet (VV) 积分器，这是一种时间对称的二阶方法。在每个大小为 $\\Delta t$ 的步长中，使用“半步踢-整步漂移-半步踢”（half-kick, full drift, and half-kick）序列来定义该方案。\n  - 经典的四阶 Runge–Kutta (RK4) 方法。通过 $d\\boldsymbol{r}/dt=\\boldsymbol{v}$ 和 $d\\boldsymbol{v}/dt=\\boldsymbol{a}(\\boldsymbol{r})$ 为状态 $(\\boldsymbol{r},\\boldsymbol{v})$ 定义常微分方程组，然后应用步长为 $\\Delta t$ 的 RK4 更新。\n\n- 执行正向-反向实验：给定初始状态 $(\\boldsymbol{r}(0),\\boldsymbol{v}(0))$，使用步长 $\\Delta t$ 进行 $n=\\lfloor T/\\Delta t \\rfloor$ 步的正向积分，总时间为 $T$；然后使用相同的积分器和相同的操作序列，以步长 $-\\Delta t$ 进行相同步数的反向积分。设反向积分后的最终状态为 $(\\boldsymbol{r}_{\\mathrm{fb}},\\boldsymbol{v}_{\\mathrm{fb}})$。\n- 通过完整状态向量差值的欧几里得范数量化可逆性误差：\n$$\nE = \\left\\lVert \\mathrm{vec}(\\boldsymbol{r}_{\\mathrm{fb}},\\boldsymbol{v}_{\\mathrm{fb}}) - \\mathrm{vec}(\\boldsymbol{r}(0),\\boldsymbol{v}(0)) \\right\\rVert_2,\n$$\n其中 $\\mathrm{vec}(\\boldsymbol{r},\\boldsymbol{v})$ 表示将所有粒子的所有位置和速度分量连接成 $\\mathbb{R}^{6N}$ 中单个向量而形成的向量。\n\n- 通过执行受控数值实验来归因截断误差和舍入误差的贡献：\n  - 为突出舍入误差，重复实验，在每次更新后将所有状态变量和中间更新量化为单精度（即使用 $32$ 位浮点数），并与双精度（即使用 $64$ 位浮点数）进行比较。\n  - 为突出截断误差，在使用非时间可逆的 RK4 方法时，保持双精度并改变步长 $\\Delta t$，比较两个不同 $\\Delta t$ 值下的可逆性误差。\n\n所有量均为无量纲。不使用物理单位。不明确要求角度。最终输出必须是浮点数。\n\n测试套件：\n- 使用以下系统和参数。在所有情况下，引力常数均为 $G=1$，总积分时间为每个测试指定的 $T$。软化长度 $\\epsilon$ 也由每个测试指定。\n\n- 为 $N=3$ 的测试定义初始三体系统：\n  - 质量：$[1.0,1.0,1.0]$。\n  - 位置：$\\boldsymbol{r}(0) = \\left[(-1.0,0.0,0.0),(1.0,0.0,0.0),(0.0,0.0,0.5)\\right]$。\n  - 速度：$\\boldsymbol{v}(0) = \\left[(0.0,0.5,0.0),(0.0,-0.5,0.0),(0.0,0.0,-0.5)\\right]$。\n\n- 为 $N=2$ 的测试定义初始双体圆形轨道：\n  - 质量：$[1.0,1.0]$。\n  - 位置：$\\boldsymbol{r}(0) = \\left[(-0.5,0.0,0.0),(0.5,0.0,0.0)\\right]$。\n  - 速度：选择 $y$ 方向上的圆形轨道速度，大小为 $v=\\sqrt{0.5}$，即 $\\boldsymbol{v}(0) = \\left[(0.0,\\sqrt{0.5},0.0),(0.0,-\\sqrt{0.5},0.0)\\right]$。\n\n- 定义平凡的 $N=1$ 系统（边界条件）：\n  - 质量：$[1.0]$。\n  - 位置：$\\boldsymbol{r}(0) = \\left[(0.0,0.0,0.0)\\right]$。\n  - 速度：$\\boldsymbol{v}(0) = \\left[(1.0,0.0,0.0)\\right]$。\n\n需要运行并报告的实验：\n- 测试 $1$（舍入误差主导，可逆方法）：$N=3$，积分器 VV，$\\Delta t=0.01$，$T=1.0$，$\\epsilon=10^{-3}$，双精度（$64$位），每次更新后量化为 $64$ 位。\n- 测试 $2$（增强的舍入误差）：与测试 $1$ 相同，但每次更新后量化为单精度（$32$位）。\n- 测试 $3$（存在不可逆截断误差）：$N=3$，积分器 RK4，$\\Delta t=0.01$，$T=1.0$，$\\epsilon=10^{-3}$，双精度，每次更新后量化。\n- 测试 $4$（截断误差缩放）：与测试 $3$ 相同，但 $\\Delta t=0.005$。\n- 测试 $5$（使用可逆方法的双体系统）：$N=2$，积分器 VV，$\\Delta t=0.05$，$T=1.0$，$\\epsilon=0.0$，双精度，每次更新后量化。\n- 测试 $6$（边界情况 $N=1$，零加速度）：$N=1$，积分器 RK4，$\\Delta t=0.02$，$T=1.0$，$\\epsilon=0.0$，双精度，每次更新后量化。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的浮点数列表，并用方括号括起来，顺序为 $[E_1,E_2,E_3,E_4,E_5,E_6]$，其中 $E_k$ 是测试 $k$ 的可逆性误差。例如，程序必须精确打印一行，格式如 $[E_1,E_2,E_3,E_4,E_5,E_6]$。", "solution": "用户提供的问题是有效且适定的。它基于应用于计算天体物理学的经典力学和数值分析的基本原理。该问题要求设计并实现一个数值实验，以研究引力 $N$ 体问题中两种标准积分方案——速度 Verlet (VV) 和四阶 Runge-Kutta (RK4)——的可逆性属性和误差特性。所有提供的参数、初始条件和评估指标在科学上都是合理的、完整的且无歧义的。\n\n解决方案的步骤是：首先建立数学和物理框架，然后详细说明所需数值算法的实现，最后解释正向-反向实验的设计及其结果的解释。\n\n### 1. 运动控制方程\n\n该系统由 $N$ 个通过牛顿引力相互作用的质点组成。每个质量为 $m_i$、位置为 $\\boldsymbol{r}_i \\in \\mathbb{R}^3$ 的粒子 $i$ 的运动遵循牛顿第二定律 $\\boldsymbol{F}_i = m_i \\boldsymbol{a}_i$，其中 $\\boldsymbol{a}_i = d^2\\boldsymbol{r}_i/dt^2$ 是加速度。粒子 $i$ 上受到的力 $\\boldsymbol{F}_i$ 是来自所有其他粒子 $j \\neq i$ 的引力的矢量和。根据牛顿万有引力定律，并按规定取引力常数 $G=1$，粒子 $i$ 的加速度为：\n$$\n\\boldsymbol{a}_i(\\boldsymbol{r}) = \\sum_{j \\ne i} m_j \\frac{\\boldsymbol{r}_j - \\boldsymbol{r}_i}{\\lVert \\boldsymbol{r}_j - \\boldsymbol{r}_i \\rVert^3}\n$$\n为了防止两个粒子相互靠近（即 $\\lVert \\boldsymbol{r}_j - \\boldsymbol{r}_i \\rVert \\to 0$）时出现数值发散，引入了 Plummer 软化长度 $\\epsilon$。修正后的正则化加速度为：\n$$\n\\boldsymbol{a}_i(\\boldsymbol{r}) = \\sum_{j \\ne i} m_j \\frac{\\boldsymbol{r}_j - \\boldsymbol{r}_i}{\\left(\\lVert \\boldsymbol{r}_j - \\boldsymbol{r}_i \\rVert^2 + \\epsilon^2 \\right)^{3/2}}\n$$\n通过定义一个 $6N$ 维的状态向量 $Y(t) = (\\boldsymbol{r}_1, \\dots, \\boldsymbol{r}_N, \\boldsymbol{v}_1, \\dots, \\boldsymbol{v}_N)$，其中 $\\boldsymbol{v}_i = d\\boldsymbol{r}_i/dt$ 是速度，这组 $N$ 个耦合的二阶常微分方程（ODEs）可以转化为一个包含 $2N$ 个一阶常微分方程的系统。系统的随时间演化可由下式给出：\n$$\n\\frac{dY}{dt} = f(Y) = \\left( \\boldsymbol{v}_1, \\dots, \\boldsymbol{v}_N, \\boldsymbol{a}_1(\\boldsymbol{r}), \\dots, \\boldsymbol{a}_N(\\boldsymbol{r}) \\right)\n$$\n这个一阶系统适合用标准的数值积分器求解。\n\n### 2. 用于计算加速度的直接求和算法\n\n直接求和算法通过遍历所有其他粒子并将其贡献相加来计算每个粒子上的加速度。对于一个包含 $N$ 个粒子的系统，这涉及到计算 $N(N-1)$ 次成对相互作用，导致计算复杂度为 $O(N^2)$。对于本问题中的小 $N$ 值，这种方法是完全足够的。为了提高效率，实现中以向量化的方式计算这些成对的力。\n\n### 3. 数值积分方案\n\n该问题要求实现两种不同的积分器来使系统随时间演化。\n\n**速度 Verlet (VV) 积分器：**\n速度 Verlet 算法是一种二阶、辛（symplectic）且时间可逆的积分器。其时间可逆性使其成为像 $N$ 体问题这样的哈密顿系统长期模拟的绝佳选择，因为它能在长时间内保持能量守恒（伴有有界振荡）。从时间 $t$ 到 $t+\\Delta t$ 的单步积分是按“踢-漂移-踢”（kick-drift-kick）序列执行的：\n1.  **半步踢（Half Kick）：** 将速度更新半步：$\\boldsymbol{v}(t + \\Delta t/2) = \\boldsymbol{v}(t) + \\frac{1}{2}\\Delta t \\cdot \\boldsymbol{a}(\\boldsymbol{r}(t))$。\n2.  **整步漂移（Full Drift）：** 使用新的半步速度更新位置：$\\boldsymbol{r}(t + \\Delta t) = \\boldsymbol{r}(t) + \\Delta t \\cdot \\boldsymbol{v}(t + \\Delta t/2)$。\n3.  **计算新加速度：** 在新位置上计算 $\\boldsymbol{a}(\\boldsymbol{r}(t + \\Delta t))$。\n4.  **半步踢（Half Kick）：** 完成速度更新：$\\boldsymbol{v}(t + \\Delta t) = \\boldsymbol{v}(t + \\Delta t/2) + \\frac{1}{2}\\Delta t \\cdot \\boldsymbol{a}(\\boldsymbol{r}(t + \\Delta t))$。\n关键在于，这些操作通过将 $\\Delta t$ 取反是完全可逆的。在没有舍入误差的情况下，正向积分然后再反向积分相同的量将完美地恢复初始状态。\n\n**四阶 Runge-Kutta (RK4) 积分器：**\n经典的 RK4 方法是一种广泛使用的通用积分器，以其高精度而著称。它是一种四阶方法，意味着其全局误差的缩放级别为 $\\mathcal{O}((\\Delta t)^4)$。对于系统 $dY/dt = f(Y)$，其更新规则为：\n$$\nY_{n+1} = Y_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n其中中间斜率为：\n-   $k_1 = f(Y_n)$\n-   $k_2 = f(Y_n + \\frac{\\Delta t}{2} k_1)$\n-   $k_3 = f(Y_n + \\frac{\\Delta t}{2} k_2)$\n-   $k_4 = f(Y_n + \\Delta t k_3)$\n在我们的问题中，$Y_n = (\\boldsymbol{r}_n, \\boldsymbol{v}_n)$，并且 $f(Y_n)$ 涉及计算加速度。尽管对于给定的 $\\Delta t$，RK4 方法精度很高，但它既不是辛的，也不是时间可逆的。这意味着误差，特别是截断误差，在时间反演时不会相互抵消。\n\n### 4. 正向-反向可逆性实验\n\n该实验旨在通过测试积分器逆转已计算轨迹的能力来量化数值误差。\n1.  系统从初始状态 $(\\boldsymbol{r}(0), \\boldsymbol{v}(0))$ 开始正向积分，总时间为 $T$。\n2.  从最终状态 $(\\boldsymbol{r}(T), \\boldsymbol{v}(T))$ 开始，系统反向积分相同的时间 $T$（使用步长 $-\\Delta t$）。\n3.  将此反向积分的最终状态 $(\\boldsymbol{r}_{\\mathrm{fb}}, \\boldsymbol{v}_{\\mathrm{fb}})$ 与原始初始状态进行比较。\n可逆性误差 $E = \\left\\lVert \\mathrm{vec}(\\boldsymbol{r}_{\\mathrm{fb}},\\boldsymbol{v}_{\\mathrm{fb}}) - \\mathrm{vec}(\\boldsymbol{r}(0),\\boldsymbol{v}(0)) \\right\\rVert_2$ 衡量了总偏差。此误差来自两个主要来源：\n-   **截断误差：** 使用离散步长算法近似连续微分方程所产生的内在误差。对于像 VV 这样的时间可逆积分器，截断误差以一种结构化的方式累积，在反向积分时大部分会相互抵消。而对于像 RK4 这样的非可逆积分器，它们不会抵消，从而导致显著的可逆性误差。此误差随步长 $\\Delta t$ 缩放。\n-   **舍入误差：** 由于计算机中数字的有限精度表示而产生的误差。这些误差以伪随机的方式累积。通过在单精度（$32$位）和双精度（$64$位）下进行实验，我们可以分离出舍入误差的贡献。舍入误差的影响是通过在每个完整的积分步骤后，将状态向量 $(\\boldsymbol{r}, \\boldsymbol{v})$ 量化到目标精度来模拟的。\n\n### 5. 测试用例分析\n所提供的测试用例旨在系统地探究这些误差来源：\n-   **测试 1 和 2 (VV, $N=3$)：** 对时间可逆的 VV 积分器比较双精度与单精度，可以分离出舍入误差的影响。测试 1（$64$位）中的误差应该非常小，而测试 2（$32$位）中的误差将大得多，这表明了降低精度的代价。\n-   **测试 3 (RK4, $N=3$)：** 使用非可逆的 RK4 方法，误差将由不可抵消的截断误差主导，预计会远大于测试 1 中 VV 积分器的由舍入误差主导的误差，尽管 RK4 是一种更高阶的方法。\n-   **测试 4 (RK4, $N=3$, 更小的 $\\Delta t$)：** 与测试 3 相比，将 $\\Delta t$ 减半将测试 RK4 截断误差的 $\\mathcal{O}((\\Delta t)^4)$ 缩放特性。误差 $E_4$ 应显著小于 $E_3$，理想情况下，其比例因子接近 $(0.01/0.005)^4 = 16$。\n-   **测试 5 (VV, $N=2$)：** 此测试将稳健的 VV 方法应用于稳定的双体开普勒轨道。在`double`精度和 $\\epsilon=0$ 的情况下，误差应该非常小，主要由理想物理系统中的舍入误差引起。\n-   **测试 6 (RK4, $N=1$)：** 一个不受任何力作用的粒子沿直线运动。其精确解是平凡的。任何计算出的误差 $E_6$ 都完全来自于位置和速度更新中浮点舍入误差的累积，为该计算环境下的机器精度限制提供了一个基线。", "answer": "```python\nimport numpy as np\n\ndef calculate_accelerations(pos, masses, eps, dtype):\n    \"\"\"\n    Calculates gravitational accelerations using a vectorized direct summation.\n    G is assumed to be 1.\n    \"\"\"\n    n_particles = pos.shape[0]\n    if n_particles == 1:\n        return np.zeros_like(pos, dtype=dtype)\n\n    # Vectorized calculation of pairwise differences and distances\n    # pos_i shape: (n, 1, 3); pos_j shape: (1, n, 3)\n    # This allows broadcasting to get all pairs of vectors.\n    pos_i = pos[:, np.newaxis, :]\n    pos_j = pos[np.newaxis, :, :]\n    \n    #_r_ij is vector from i to j, has shape (n, n, 3)\n    r_ij = pos_j - pos_i \n    \n    # dist_sq has shape (n, n)\n    dist_sq = np.sum(r_ij**2, axis=-1)\n    \n    # Softened inverse cube distance\n    inv_r3 = (dist_sq + eps**2)**(-1.5)\n    \n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r3, 0.0)\n    \n    # masses_j shape: (1, n, 1) to broadcast correctly with r_ij\n    masses_j = masses[np.newaxis, :, np.newaxis]\n    \n    # Sum over j axis; inv_r3 needs an extra dimension for broadcasting\n    # accel shape: (n, 3)\n    accel = np.sum(masses_j * r_ij * inv_r3[..., np.newaxis], axis=1)\n    \n    return accel.astype(dtype)\n\ndef step_vv(pos, vel, masses, dt, eps, dtype):\n    \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n    a_t = calculate_accelerations(pos, masses, eps, dtype)\n    v_half = vel + 0.5 * dt * a_t\n    pos_new = pos + dt * v_half\n    a_t_plus_dt = calculate_accelerations(pos_new, masses, eps, dtype)\n    vel_new = v_half + 0.5 * dt * a_t_plus_dt\n    return pos_new, vel_new\n\ndef step_rk4(pos, vel, masses, dt, eps, dtype):\n    \"\"\"A single step of the classic 4th-order Runge-Kutta integrator.\"\"\"\n    # k1\n    k1_r = dt * vel\n    k1_v = dt * calculate_accelerations(pos, masses, eps, dtype)\n    \n    # k2\n    k2_r = dt * (vel + 0.5 * k1_v)\n    k2_v = dt * calculate_accelerations(pos + 0.5 * k1_r, masses, eps, dtype)\n    \n    # k3\n    k3_r = dt * (vel + 0.5 * k2_v)\n    k3_v = dt * calculate_accelerations(pos + 0.5 * k2_r, masses, eps, dtype)\n    \n    # k4\n    k4_r = dt * (vel + k3_v)\n    k4_v = dt * calculate_accelerations(pos + k3_r, masses, eps, dtype)\n    \n    # Update state\n    pos_new = pos + (k1_r + 2*k2_r + 2*k3_r + k4_r) / 6.0\n    vel_new = vel + (k1_v + 2*k2_v + 2*k3_v + k4_v) / 6.0\n    \n    return pos_new, vel_new\n\ndef run_experiment(initial_r, initial_v, masses, integrator_name, dt, T, eps, precision_str):\n    \"\"\"\n    Performs a forward-backward integration experiment and returns the reversibility error.\n    \"\"\"\n    dtype = np.float64 if precision_str == 'double' else np.float32\n\n    # Set initial state and precision\n    r0 = initial_r.copy().astype(dtype)\n    v0 = initial_v.copy().astype(dtype)\n    m = masses.copy().astype(dtype)\n    \n    r, v = r0.copy(), v0.copy()\n\n    stepper = step_vv if integrator_name == 'VV' else step_rk4\n    n_steps = int(round(T / abs(dt)))\n\n    # Forward integration\n    for _ in range(n_steps):\n        r_new, v_new = stepper(r, v, m, dt, eps, dtype)\n        r = r_new.astype(dtype)\n        v = v_new.astype(dtype)\n        \n    # Backward integration\n    for _ in range(n_steps):\n        r_new, v_new = stepper(r, v, m, -dt, eps, dtype)\n        r = r_new.astype(dtype)\n        v = v_new.astype(dtype)\n        \n    r_fb, v_fb = r, v\n    \n    # Calculate final error\n    initial_state_vec = np.concatenate((r0.flatten(), v0.flatten()))\n    final_state_vec = np.concatenate((r_fb.flatten(), v_fb.flatten()))\n    \n    error = np.linalg.norm(final_state_vec - initial_state_vec)\n    return float(error)\n\ndef solve():\n    # Initial conditions\n    ic_n3 = {\n        'masses': np.array([1.0, 1.0, 1.0]),\n        'pos': np.array([[-1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.5]]),\n        'vel': np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0], [0.0, 0.0, -0.5]])\n    }\n    \n    v_circ = np.sqrt(0.5)\n    ic_n2 = {\n        'masses': np.array([1.0, 1.0]),\n        'pos': np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n        'vel': np.array([[0.0, v_circ, 0.0], [0.0, -v_circ, 0.0]])\n    }\n    \n    ic_n1 = {\n        'masses': np.array([1.0]),\n        'pos': np.array([[0.0, 0.0, 0.0]]),\n        'vel': np.array([[1.0, 0.0, 0.0]])\n    }\n\n    test_cases = [\n        # Test 1: VV, double, N=3\n        {'ic': ic_n3, 'integrator': 'VV', 'dt': 0.01, 'T': 1.0, 'eps': 1e-3, 'precision': 'double'},\n        # Test 2: VV, single, N=3\n        {'ic': ic_n3, 'integrator': 'VV', 'dt': 0.01, 'T': 1.0, 'eps': 1e-3, 'precision': 'single'},\n        # Test 3: RK4, double, dt=0.01, N=3\n        {'ic': ic_n3, 'integrator': 'RK4', 'dt': 0.01, 'T': 1.0, 'eps': 1e-3, 'precision': 'double'},\n        # Test 4: RK4, double, dt=0.005, N=3\n        {'ic': ic_n3, 'integrator': 'RK4', 'dt': 0.005, 'T': 1.0, 'eps': 1e-3, 'precision': 'double'},\n        # Test 5: VV, double, N=2\n        {'ic': ic_n2, 'integrator': 'VV', 'dt': 0.05, 'T': 1.0, 'eps': 0.0, 'precision': 'double'},\n        # Test 6: RK4, double, N=1\n        {'ic': ic_n1, 'integrator': 'RK4', 'dt': 0.02, 'T': 1.0, 'eps': 0.0, 'precision': 'double'},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_experiment(\n            initial_r=case['ic']['pos'],\n            initial_v=case['ic']['vel'],\n            masses=case['ic']['masses'],\n            integrator_name=case['integrator'],\n            dt=case['dt'],\n            T=case['T'],\n            eps=case['eps'],\n            precision_str=case['precision']\n        )\n        results.append(error)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3508413"}]}