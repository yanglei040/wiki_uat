{"hands_on_practices": [{"introduction": "蛙跳格式的一个特点是其动量和位置在时间上是交错的。但在实际应用中，我们通常从同一时刻的位置 $q_0$ 和动量 $p_0$ 开始。因此，一个关键的实践问题是如何正确地启动积分过程。本练习 [@problem_id:3538304] 将引导你推导“踢-漂-踢”（KDK）蛙跳格式的初始半步动量，通过确保第一步积分就达到二阶精度来保证整个算法的正确性和时间对称性，这是正确实现该算法的基石。", "problem": "考虑一个代表无碰撞引力 $N$ 体模型的可分离哈密顿系统，其哈密顿量为 $H(q,p)=T(p)+V(q)$，其中 $q \\in \\mathbb{R}^{d}$ 是位置，$p \\in \\mathbb{R}^{d}$ 是正则动量，$T$ 是仅依赖于 $p$ 的动能，$V$ 是仅依赖于 $q$ 的势能。设运动方程由哈密顿方程给出，即 $\\dot{q}=\\nabla_{p}T(p)$ 和 $\\dot{p}=-\\nabla_{q}V(q)$，并假设所有函数都足够光滑以使泰勒展开有效。\n\n您希望使用时间步长为 $\\Delta t0$ 的时间对称辛蛙跳算法（踢-漂-踢，KDK）形式来对该系统进行积分。KDK 方案从时刻 $t=0$ 的状态 $(q_{0},p_{0})$ 开始，首先执行一个半步长的动量更新（踢），然后是一个完整步长的位置更新（漂），最后再执行一个半步长的动量更新（踢）。由于蛙跳算法使用交错动量，您必须仅使用 $(q_{0},p_{0})$ 和 $\\Delta t$ 来初始化一个半步动量 $p_{1/2}$，以使得：\n- 第一个漂移步产生的 $q_{1}$ 与精确解 $q(\\Delta t)$ 的匹配达到并包括 $\\Delta t^{2}$ 阶项（局部截断误差为 $\\mathcal{O}(\\Delta t^{3})$），并且\n- 整个方法在变换 $(q,p,\\Delta t)\\mapsto(q,-p,-\\Delta t)$ 下是时间可逆的。\n\n假设 $T$ 关于 $p$ 是二次连续可微且严格凸的，因此 $\\nabla_{p}T$ 可逆，且其关于 $p$ 的雅可比矩阵等于海森矩阵 $D^{2}_{pp}T(p)$。设第一个漂移步通过 $q_{1}=q_{0}+\\Delta t\\,\\nabla_{p}T(p_{1/2})$ 使用初始化的 $p_{1/2}$。将初始化参数化为 $p_{1/2}=p_{0}-c\\,\\Delta t\\,\\nabla_{q}V(q_{0})+\\mathcal{O}(\\Delta t^{2})$，其中 $c \\in \\mathbb{R}$ 是一个待定常数。\n\n从哈密顿方程和关于 $t=0$ 的泰勒展开出发，推导满足上述两个条件所需的 $c$ 值，并由此获得以 $q_{0}$、$p_{0}$、$\\Delta t$ 和 $\\nabla_{q}V(q_{0})$ 表示的 $p_{1/2}$ 的唯一初始化公式，该公式确保 KDK 方法从第一步起就具有二阶精度和时间可逆性。将您的最终答案表示为 $p_{1/2}$ 的单个闭式解析表达式。不需要进行数值计算。", "solution": "首先验证问题陈述，以确保其具有科学依据、良定性及客观性。\n\n### 第一步：提取已知条件\n- **系统**：一个由 $H(q,p)=T(p)+V(q)$ 描述的可分离哈密顿系统。\n- **变量**：$q \\in \\mathbb{R}^{d}$ (位置)，$p \\in \\mathbb{R}^{d}$ (正则动量)。\n- **能量项**：$T(p)$ 是动能，$V(q)$ 是势能。假设所有函数都足够光滑。\n- **运动方程**：哈密顿方程为 $\\dot{q}=\\nabla_{p}T(p)$ 和 $\\dot{p}=-\\nabla_{q}V(q)$。\n- **积分方案**：时间步长为 $\\Delta t  0$ 的时间对称辛蛙跳算法（踢-漂-踢，KDK）形式。\n- **初始条件**：系统在时刻 $t=0$ 处于状态 $(q_{0},p_{0})$。\n- **任务**：仅使用 $(q_{0},p_{0})$ 和 $\\Delta t$ 确定半步动量 $p_{1/2}$ 的初始化公式。\n- **条件 1 (精度)**：由 $q_{1}=q_{0}+\\Delta t\\,\\nabla_{p}T(p_{1/2})$ 给出的第一个漂移步必须产生一个位置 $q_{1}$，该位置与精确解 $q(\\Delta t)$ 的匹配具有 $\\mathcal{O}(\\Delta t^{3})$ 的局部截断误差。即 $q_{1} - q(\\Delta t) = \\mathcal{O}(\\Delta t^{3})$。\n- **条件 2 (时间可逆性)**：整个积分方法必须在变换 $(q,p,\\Delta t)\\mapsto(q,-p,-\\Delta t)$ 下是时间可逆的。\n- **关于 $T(p)$ 的假设**：动能 $T$ 关于 $p$ 是二次连续可微且严格凸的，确保其海森矩阵 $D^{2}_{pp}T(p)$ 是一个良定、可逆的矩阵。\n- **参数化**：$p_{1/2}$ 的初始化被参数化为 $p_{1/2}=p_{0}-c\\,\\Delta t\\,\\nabla_{q}V(q_{0})+\\mathcal{O}(\\Delta t^{2})$，其中 $c \\in \\mathbb{R}$ 是一个待定常数。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据**：该问题植根于经典力学（哈密顿形式体系）和数值分析（辛积分），这些是计算物理学和天体物理学中的标准和基础课题。\n- **良定性**：问题陈述清晰，包含了所有必要信息。它要求求解一个特定的常数 $c$ 及相应的公式，以满足明确定义的数学条件（精度和时间可逆性）。\n- **客观性**：问题以精确的数学语言表述，没有任何主观性或歧义。\n\n该问题不违反任何无效性标准。它是几何数值积分领域中的一个标准的、非平凡的推导。\n\n### 第三步：结论与行动\n问题有效。下面是完整的、有理有据的解答。\n\n### 解答推导\n\n主要任务是找到满足给定精度要求的常数 $c$ 的值。这个值将定义 $p_{1/2}$ 的初始化公式。\n\n首先，我们确定精确位置 $q(\\Delta t)$ 在 $t=0$ 附近直到 $(\\Delta t)^2$ 阶项的泰勒级数展开。精确解根据哈密顿方程从初始状态 $(q_0, p_0)$ 演化而来。\n\n泰勒展开式为：\n$$q(\\Delta t) = q(0) + \\Delta t \\, \\dot{q}(0) + \\frac{(\\Delta t)^2}{2} \\ddot{q}(0) + \\mathcal{O}(\\Delta t^3)$$\n在 $t=0$ 时，我们有 $q(0) = q_0$ 和 $p(0) = p_0$。位置的一阶导数由哈密顿方程给出：\n$$\\dot{q}(t) = \\nabla_p T(p(t))$$\n在 $t=0$ 时求值：\n$$\\dot{q}(0) = \\nabla_p T(p_0)$$\n为了求二阶导数 $\\ddot{q}(0)$，我们使用链式法则对 $\\dot{q}(t)$ 关于时间求导：\n$$\\ddot{q}(t) = \\frac{d}{dt} \\left( \\nabla_p T(p(t)) \\right) = D^2_{pp}T(p(t)) \\, \\dot{p}(t)$$\n其中 $D^2_{pp}T(p(t))$ 是 $T$ 关于 $p$ 的海森矩阵。动量的导数 $\\dot{p}(t)$ 也由哈密顿方程给出：\n$$\\dot{p}(t) = -\\nabla_q V(q(t))$$\n在 $t=0$ 时求值：\n$$\\dot{p}(0) = -\\nabla_q V(q_0)$$\n将此代入 $\\ddot{q}(0)$ 的表达式中：\n$$\\ddot{q}(0) = D^2_{pp}T(p_0) (-\\nabla_q V(q_0)) = -D^2_{pp}T(p_0) \\nabla_q V(q_0)$$\n现在，我们将导数代回到 $q(\\Delta t)$ 的泰勒展开式中：\n$$q(\\Delta t) = q_0 + \\Delta t \\, \\nabla_p T(p_0) - \\frac{(\\Delta t)^2}{2} D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$$\n\n接下来，我们分析从数值方案第一步得到的位置 $q_1$。该方案使用基于初始化动量 $p_{1/2}$ 的漂移步：\n$$q_1 = q_0 + \\Delta t \\, \\nabla_p T(p_{1/2})$$\n动量 $p_{1/2}$ 由参数化给出：\n$$p_{1/2} = p_0 - c \\, \\Delta t \\, \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2)$$\n为了找到一个可与 $q(\\Delta t)$ 的展开式相比较的 $q_1$ 表达式，我们将 $\\nabla_p T(p_{1/2})$ 在 $p_0$ 附近进行泰勒级数展开。令 $\\delta p = p_{1/2} - p_0 = -c \\, \\Delta t \\, \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2)$。注意 $\\delta p$ 是 $\\mathcal{O}(\\Delta t)$ 阶的。\n$$\\nabla_p T(p_{1/2}) = \\nabla_p T(p_0 + \\delta p) = \\nabla_p T(p_0) + D^2_{pp}T(p_0) \\, \\delta p + \\mathcal{O}(||\\delta p||^2)$$\n将 $\\delta p$ 的表达式代入：\n$$\\nabla_p T(p_{1/2}) = \\nabla_p T(p_0) + D^2_{pp}T(p_0) \\left( -c \\, \\Delta t \\, \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2) \\right) + \\mathcal{O}(\\Delta t^2)$$\n$$\\nabla_p T(p_{1/2}) = \\nabla_p T(p_0) - c \\, \\Delta t \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2)$$\n现在，将此展开式代回到 $q_1$ 的表达式中：\n$$q_1 = q_0 + \\Delta t \\left( \\nabla_p T(p_0) - c \\, \\Delta t \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2) \\right)$$\n$$q_1 = q_0 + \\Delta t \\, \\nabla_p T(p_0) - c \\, (\\Delta t)^2 \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$$\n\n精度条件要求 $q_1 = q(\\Delta t) + \\mathcal{O}(\\Delta t^3)$。我们比较推导出的两个展开式：\n精确解：$q(\\Delta t) = q_0 + \\Delta t \\, \\nabla_p T(p_0) - \\frac{1}{2} (\\Delta t)^2 D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$\n数值解：$q_1 = q_0 + \\Delta t \\, \\nabla_p T(p_0) - c \\, (\\Delta t)^2 \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$\n$\\mathcal{O}(1)$ 和 $\\mathcal{O}(\\Delta t)$ 阶的项已经匹配。为了使展开式在 $(\\Delta t)^2$ 阶上一致，$(\\Delta t)^2$ 项的系数必须相等：\n$$-c \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) = -\\frac{1}{2} D^2_{pp}T(p_0) \\nabla_q V(q_0)$$\n由于 $T(p)$ 是严格凸的，其海森矩阵 $D^2_{pp}T(p_0)$ 是可逆的。假设势能非平凡，即 $\\nabla_q V(q_0) \\neq 0$，我们可以得出结论：\n$$c = \\frac{1}{2}$$\n\n$c$ 的这个值满足了精度条件。现在我们考虑时间可逆性条件。标准的 KDK 积分器是对应于势能 $V$（踢）和动能 $T$（漂）下的流的算子的对称组合：$\\Phi_{\\Delta t} = \\phi_V^{\\Delta t/2} \\circ \\phi_T^{\\Delta t} \\circ \\phi_V^{\\Delta t/2}$。这种对称结构确保了该方法是时间可逆的，即对于变换 $S(q,p)=(q,-p)$，有 $\\Phi_{\\Delta t}^{-1} = S \\circ \\Phi_{\\Delta t} \\circ S$，前提是动能 $T(p)$ 是 $p$ 的偶函数。初始化步骤 $p_{1/2} = p_0 - c \\Delta t \\nabla_q V(q_0)$ 对应于第一个算子——半步踢 $\\phi_V^{c \\Delta t}$ 的作用。为使整个方案成为对称的 KDK 积分器，这第一个踢必须是半步踢 $\\phi_V^{\\Delta t/2}$。这意味着 $c \\Delta t = \\Delta t / 2$，从而得到 $c = 1/2$。因此，精度和时间可逆性两个条件独立地导出了相同的 $c$ 值。\n\n当 $c=1/2$ 时，参数化 $p_{1/2}=p_{0}-c\\,\\Delta t\\,\\nabla_{q}V(q_{0})+\\mathcal{O}(\\Delta t^{2})$ 成为初始半步动量更新的确定公式。对于标准的 KDK 方案，高阶项为零，因此在该算法的定义范围内，这个唯一公式是精确的。\n\n$p_{1/2}$ 的唯一初始化公式为：\n$$p_{1/2} = p_0 - \\frac{1}{2} \\Delta t \\nabla_q V(q_0)$$", "answer": "$$\\boxed{p_{1/2} = p_0 - \\frac{1}{2} \\Delta t \\nabla_q V(q_0)}$$", "id": "3538304"}, {"introduction": "构建了积分器之后，下一步是理解其性能。辛积分器的一个标志性特征是它们能极好地保持系统的长期能量稳定性，但会引入微小的相位误差。本练习 [@problem_id:3538279] 通过分析简谐振子这一基本模型，让你定量地探究这种相位误差。通过推导数值积分产生的“修正频率” $\\tilde{\\omega}$，你将亲身体会到辛积分器是如何用一个可预测的、缓慢累积的相位漂移来换取能量的有界误差，这是其在长期模拟中表现出色的关键。", "problem": "考虑一维谐振子，其哈密顿量为 $H(x,p) = \\frac{p^{2}}{2 m} + \\frac{1}{2} m \\omega^{2} x^{2}$，其中 $m$ 是质量，$\\omega$ 是精确角频率。其精确运动是周期性的，周期为 $T = \\frac{2 \\pi}{\\omega}$。使用蛙跳法的“踢-漂-踢”（KDK）形式（一种辛积分器）来演化该系统，固定时间步长为 $h$，且满足稳定性条件 $\\omega h  2$。假设初始条件是通用的（非平凡振幅和相位），并且 $N T / h$ 是一个整数，以便在 $t = N T$ 时刻精确采样数值轨迹。\n\n从哈密顿方程 $\\dot{x} = \\frac{p}{m}$ 和 $\\dot{p} = - m \\omega^{2} x$ 以及“踢-漂-踢”方案的定义（无外力）出发，推导仅针对位置 $x^{(n)}$ 的离散更新方程，推断与蛙跳法动力学相关的修正角频率 $\\tilde{\\omega}$，然后量化经过 $N$ 个精确周期后的累积相位误差。该误差定义为在 $t = N T$ 时刻计算的数值相位与精确相位之差。计算到 $h$ 的主非平凡阶，并用 $N$、$h^{2}$ 和 $\\omega$ 明确表示你的最终答案。\n\n最终的相位误差以弧度表示。不需要进行数值四舍五入；提供一个精确到 $h^{2}$ 主导阶的闭式解析表达式。", "solution": "该问题要求分析用于一维谐振子的蛙跳法“踢-漂-踢”（KDK）形式。目标是推导位置的数值更新规则，推断修正后的数值频率，并计算在指定时间后的累积相位误差。\n\n谐振子的哈密顿量由下式给出：\n$$H(x,p) = \\frac{p^{2}}{2 m} + \\frac{1}{2} m \\omega^{2} x^{2}$$\n该哈密顿量可以分解为动能部分 $T(p) = \\frac{p^{2}}{2m}$ 和势能部分 $V(x) = \\frac{1}{2} m \\omega^{2} x^{2}$。哈密顿方程为 $\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}$ 和 $\\dot{p} = -\\frac{\\partial H}{\\partial x} = -m \\omega^{2} x$。力为 $F(x) = -m\\omega^2 x$。\n\n对于大小为 $h$ 的单个时间步，“踢-漂-踢”（KDK）方案将系统从时间 $t_n$ 的 $(x^{(n)}, p^{(n)})$ 演化到时间 $t_{n+1} = t_n + h$ 的 $(x^{(n+1)}, p^{(n+1)})$，过程如下：\n1.  **第一次踢（半步）**：动量在半个时间步长 $h/2$ 内更新。\n    $$p^{(n+1/2)} = p^{(n)} - \\frac{h}{2} \\frac{dV}{dx}(x^{(n)}) = p^{(n)} - \\frac{h}{2} m \\omega^{2} x^{(n)}$$\n2.  **漂移（全步）**：位置使用新的动量在整个时间步长 $h$ 内更新。\n    $$x^{(n+1)} = x^{(n)} + h \\frac{dT}{dp}(p^{(n+1/2)}) = x^{(n)} + \\frac{h}{m} p^{(n+1/2)}$$\n3.  **第二次踢（半步）**：动量使用新位置上的力在另一个半个时间步长 $h/2$ 内再次更新。\n    $$p^{(n+1)} = p^{(n+1/2)} - \\frac{h}{2} \\frac{dV}{dx}(x^{(n+1)}) = p^{(n+1/2)} - \\frac{h}{2} m \\omega^{2} x^{(n+1)}$$\n\n首先，我们推导 $x$ 和 $p$ 的离散更新方程。将第一次踢的表达式代入漂移方程：\n$$x^{(n+1)} = x^{(n)} + \\frac{h}{m} \\left( p^{(n)} - \\frac{h}{2} m \\omega^{2} x^{(n)} \\right) = \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) x^{(n)} + \\frac{h}{m} p^{(n)}$$\n现在，我们通过代入第一次踢得到的 $p^{(n+1/2)}$ 表达式和我们刚才推导出的 $x^{(n+1)}$ 表达式来找到 $p^{(n+1)}$ 的更新方程：\n$$p^{(n+1)} = \\left(p^{(n)} - \\frac{h}{2} m \\omega^{2} x^{(n)}\\right) - \\frac{h}{2} m \\omega^{2} x^{(n+1)}$$\n$$p^{(n+1)} = p^{(n)} - \\frac{h}{2} m \\omega^{2} x^{(n)} - \\frac{h}{2} m \\omega^{2} \\left[ \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) x^{(n)} + \\frac{h}{m} p^{(n)} \\right]$$\n$$p^{(n+1)} = \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) p^{(n)} - \\left( \\frac{h}{2} m \\omega^{2} + \\frac{h}{2} m \\omega^{2} \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) \\right)x^{(n)}$$\n$$p^{(n+1)} = \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) p^{(n)} - m \\omega^{2} h \\left(1 - \\frac{\\omega^2 h^2}{4}\\right) x^{(n)}$$\n\n为了仅推导位置 $x^{(n)}$ 的离散更新方程，我们构建一个二阶递推关系。对于该系统，KDK方案等价于Störmer-Verlet方法，它给出了著名的有限差分方程：\n$$x^{(n+1)} - 2x^{(n)} + x^{(n-1)} = h^2 \\frac{F(x^{(n)})}{m} = h^2 (-\\omega^2 x^{(n)})$$\n整理后得到位置的更新规则：\n$$x^{(n+1)} = (2 - \\omega^2 h^2) x^{(n)} - x^{(n-1)}$$\n这就是仅针对位置的离散更新方程。\n\n接下来，我们推断修正角频率 $\\tilde{\\omega}$。我们寻找形如 $x^{(n)} = A z^n$ 的递推关系解。将其代入方程得到特征方程：\n$$z^2 - (2 - \\omega^2 h^2) z + 1 = 0$$\n方程的根是复共轭 $z = e^{\\pm i \\phi}$，其中 $\\phi$ 是每个时间步的数值相位推进。对于振荡解，根的模必须为1。根的和为 $z + z^{-1} = 2 \\cos(\\phi)$。根据特征方程，根的和为 $2 - \\omega^2 h^2$。因此：\n$$2 \\cos(\\phi) = 2 - \\omega^2 h^2 \\implies \\cos(\\phi) = 1 - \\frac{\\omega^2 h^2}{2}$$\n稳定性条件 $\\omega h  2$ 确保了 $|1 - \\frac{\\omega^2 h^2}{2}|  1$，因此 $\\phi$ 是实数。使用半角恒等式 $\\cos(\\phi) = 1 - 2\\sin^2(\\phi/2)$，我们得到：\n$$1 - 2\\sin^2(\\frac{\\phi}{2}) = 1 - \\frac{\\omega^2 h^2}{2} \\implies \\sin^2(\\frac{\\phi}{2}) = \\frac{\\omega^2 h^2}{4}$$\n对于小的 $h$，我们期望一个小的正相位推进 $\\phi$，所以我们取正根：\n$$\\sin(\\frac{\\phi}{2}) = \\frac{\\omega h}{2}$$\n数值频率 $\\tilde{\\omega}$ 通过 $\\phi = \\tilde{\\omega} h$ 与每步的相位推进相关联。为了找到它与 $\\omega$ 的主导阶偏差，我们对小的 $\\phi$ 展开 $\\sin(\\frac{\\phi}{2})$：\n$$\\sin(u) = u - \\frac{u^3}{6} + O(u^5)$$\n令 $u = \\phi/2$：\n$$\\frac{\\phi}{2} - \\frac{1}{6}\\left(\\frac{\\phi}{2}\\right)^3 + O(\\phi^5) = \\frac{\\omega h}{2}$$\n在主导阶上，$\\phi \\approx \\omega h$。我们将此代入三次项以获得展开式的下一项：\n$$\\frac{\\phi}{2} - \\frac{(\\omega h)^3}{48} + O(h^5) \\approx \\frac{\\omega h}{2}$$\n$$\\frac{\\phi}{2} \\approx \\frac{\\omega h}{2} + \\frac{\\omega^3 h^3}{48}$$\n$$\\phi \\approx \\omega h + \\frac{\\omega^3 h^3}{24}$$\n修正角频率 $\\tilde{\\omega}$ 为 $\\phi/h$：\n$$\\tilde{\\omega} = \\frac{\\phi}{h} \\approx \\omega + \\frac{\\omega^3 h^2}{24}$$\n主导阶的频率误差为 $\\tilde{\\omega} - \\omega = \\frac{\\omega^3 h^2}{24}$。\n\n最后，我们量化经过 $N$ 个精确周期后的累积相位误差。精确周期为 $T = 2\\pi/\\omega$。总时间为 $t = NT = N \\frac{2\\pi}{\\omega}$。\n在时间 $t$ 的精确相位是 $\\Phi_{exact}(t) = \\omega t + \\delta_0$，其中 $\\delta_0$ 是初始相位。\n在时间 $t$ 的数值相位是 $\\Phi_{num}(t) = \\tilde{\\omega} t + \\delta_0$。\n累积相位误差 $\\Delta \\Phi$ 是数值相位和精确相位之差：\n$$\\Delta \\Phi(t) = \\Phi_{num}(t) - \\Phi_{exact}(t) = (\\tilde{\\omega} - \\omega)t$$\n我们在 $t = NT$ 处计算此值：\n$$\\Delta \\Phi(NT) = (\\tilde{\\omega} - \\omega) NT$$\n代入频率误差的主导阶表达式和 $T$ 的表达式：\n$$\\Delta \\Phi(NT) \\approx \\left(\\frac{\\omega^3 h^2}{24}\\right) \\left(N \\frac{2\\pi}{\\omega}\\right)$$\n$$\\Delta \\Phi(NT) \\approx \\frac{2\\pi N \\omega^2 h^2}{24} = \\frac{\\pi N \\omega^2 h^2}{12}$$\n这是经过 $N$ 个精确周期后的累积相位误差，表示为 $h^2$ 的主非平凡阶，并用 $N$ 和 $\\omega$ 表示。", "answer": "$$\n\\boxed{\\frac{\\pi N \\omega^{2} h^{2}}{12}}\n$$", "id": "3538279"}, {"introduction": "理论上的辛性质只有在精确算术下才能得到保证，而计算机的浮点运算会引入误差，代码中的疏忽也可能破坏这一性质。本章的最后一个实践 [@problem_id:3538342] 将理论与实践联系起来，要求你设计一个数值诊断工具，以检验一个给定的积分器实现是否真正保持了相空间的辛结构。对于任何计算物理学家来说，这都是一项至关重要的技能，它能确保我们选择的数值方法的理论优势不会因为实现中的错误而丧失。", "problem": "要求你设计并实现一个数值诊断程序，用于在随机相空间点上估计 Leapfrog (踢-漂-踢) 映射的量 $J^{\\top}\\Omega J - \\Omega$，并指定用于检测因实现错误导致的辛性丧失的容差。其背景是一个可分离哈密顿系统，具有正则坐标 $(q,p)$ 和哈密顿量 $H(q,p) = T(p) + V(q)$，其中 $T(p)$ 仅依赖于 $p$，$V(q)$ 仅依赖于 $q$。正则辛形式是常数 $2\\times 2$ 矩阵\n$$\n\\Omega \\equiv \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}.\n$$\nLeapfrog (踢-漂-踢) 格式通过三个连续的子步骤将 $(q,p)$推进一个时间步长 $h$：半步动量更新（“踢”）、全步位置更新（“漂移”）和半步动量更新（“踢”）。该诊断程序必须：\n- 在随机选择的相空间点上，使用有限差分法数值近似单步映射 $(q,p)\\mapsto (q',p')$ 的雅可比矩阵 $J$。\n- 通过 $S \\equiv J^{\\top}\\Omega J - \\Omega$ 评估辛性偏差，并聚合一个误差度量（例如，$S$ 的最大绝对值元素）。\n- 基于一组随机相空间样本的聚合误差度量，判断该映射是否在预设容差内是辛的。\n\n设计约束和基础：\n- 使用哈密顿方程 $dq/dt = \\partial H/\\partial p$ 和 $dp/dt = -\\partial H/\\partial q$，以及 $H$ 的可分离性来证明 Leapfrog (踢-漂-踢) 子步骤的合理性。\n- 为进行具体且可复现的测试，使用简谐振子，其无量纲参数为 $m=1$ 和 $k=1$，即 $T(p)=\\tfrac{1}{2}p^2$ 和 $V(q)=\\tfrac{1}{2}q^2$。所有量均为无量纲；无需物理单位。\n- 在点 $(q,p)$ 处，使用中心有限差分法和用户指定的各坐标微扰大小 $\\delta$ 来近似雅可比矩阵 $J$。对第 $i$ 个坐标，使用中心差分公式 $J_{:,i} \\approx \\big(F(x+\\delta e_i)-F(x-\\delta e_i)\\big)/(2\\delta)$，其中 $F$ 是单步映射，$e_i$ 是第 $i$ 个标准基向量。\n- 将一个点上的辛性误差定义为 $\\|S\\|_{\\infty}$，其中 $\\|\\cdot\\|_{\\infty}$ 表示最大绝对值范数。\n- 通过取样本中的最大误差来对多个随机样本进行聚合。\n\n容差规范：\n- 有限差分雅可比矩阵估计引入了两个主要的误差来源：截断误差 $O(\\delta^2)$ 和浮点舍入误差放大 $O(\\epsilon_{\\text{mach}}/\\delta)$，其中 $\\epsilon_{\\text{mach}}$ 是机器精度。对于此诊断，一个在典型双精度场景下稳健的实用检测阈值为\n$$\n\\tau(\\delta) \\equiv 10\\,\\delta^2 + 10^{-8}.\n$$\n- 如果样本集上的聚合误差 $\\max\\|S\\|_{\\infty}$ 小于或等于 $\\tau(\\delta)$，则诊断程序应将该实现分类为辛的。\n\n随机抽样：\n- 为了可复现性，使用固定的随机种子，从区间 $[-1,1]$ 中独立且均匀地抽取 $(q,p)$。\n\n待检测的实现错误：\n- 至少包含一个有缺陷的 Leapfrog 变体，它在漂移子步骤中使用了踢前的动量 $p$ 而不是半踢后的动量 $p_{1/2}$；这种不一致性破坏了辛性，应能被诊断程序检测出来。\n\n测试套件：\n- 实现四个测试用例，每个用例由一个元组 $(\\text{scheme}, h, \\delta, N)$ 指定：\n    1. $(\\text{KDK}, 0.1, 10^{-6}, 256)$: 正确的 Kick-Drift-Kick 格式，中等时间步长和有限差分尺度。\n    2. $(\\text{KDK}, 1.0, 10^{-6}, 128)$: 正确的 Kick-Drift-Kick 格式，时间步长较大。\n    3. $(\\text{BUG1}, 0.1, 10^{-6}, 256)$: 有缺陷的格式，其中漂移步骤使用了 $p$ 而不是 $p_{1/2}$。\n    4. $(\\text{KDK}, 0.1, 10^{-12}, 64)$: 正确的格式，但有限差分尺度非常小，以说明由于舍入误差放大导致的失效。\n\n要求的最终输出格式：\n- 你的程序应生成一行输出，其中包含对每个测试用例的诊断决策。决策是一个用方括号括起来的逗号分隔列表，每个条目都是一个布尔值，如果聚合误差 $\\le \\tau(\\delta)$ 则为 $\\text{True}$，否则为 $\\text{False}$。例如：$[\\text{True},\\text{True},\\text{False},\\text{False}]$。", "solution": "任务是设计一个数值诊断程序，以验证用于可分离哈密顿系统的数值积分器的辛性。一个推进相空间坐标 $x = (q,p)$ 的映射 $\\Phi$ 被定义为辛映射，如果其雅可比矩阵 $J = \\partial \\Phi / \\partial x$ 保持正则辛形式 $\\Omega$ 不变。这由关系式 $J^{\\top}\\Omega J = \\Omega$ 表达。我们的诊断程序将数值估计偏差矩阵 $S \\equiv J^{\\top}\\Omega J - \\Omega$，并检查其大小是否在与数值精度和近似误差相符的容差范围内。\n\n所考虑的物理系统是简谐振子，由可分离的哈密顿量 $H(q,p) = T(p) + V(q)$ 描述，其中动能为 $T(p) = \\frac{1}{2}p^2$，势能为 $V(q) = \\frac{1}{2}q^2$。对于这个问题，我们使用无量纲参数，使得质量 $m=1$ 和弹簧常数 $k=1$。动力学由哈密顿方程控制：\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -q\n$$\n\n待测试的积分器是二阶 Leapfrog 格式，采用其 Kick-Drift-Kick (KDK) 表述。该方法是几何积分器的一个例子，旨在保持底层物理系统的几何特性，包括辛性。$H$ 的可分离性允许进行算子分裂，其中一个时间步长 $h$ 内的完整演化通过一个仅涉及 $T(p)$ 或 $V(q)$ 的对称操作序列来近似。从 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的单步映射由三个子步骤给出：\n\n1.  **踢 (动量更新, 半步 $\\Delta t = h/2$)**: 系统在势能 $V(q)$ 下演化。动量使用力 $F(q) = -\\partial V/\\partial q = -q$ 进行更新。\n    $$p_{n+1/2} = p_n + \\frac{h}{2} F(q_n) = p_n - \\frac{h}{2} q_n$$\n2.  **漂移 (位置更新, 全步 $\\Delta t = h$)**: 系统在动能 $T(p)$ 下演化。位置使用速度 $v(p) = \\partial T/\\partial p = p$ 进行更新。此步骤必须使用经过半步更新的动量 $p_{n+1/2}$。\n    $$q_{n+1} = q_n + h \\cdot v(p_{n+1/2}) = q_n + h \\cdot p_{n+1/2}$$\n3.  **踢 (动量更新, 半步 $\\Delta t = h/2$)**: 执行第二次动量更新，使用在新位置 $q_{n+1}$ 处计算的力。\n    $$p_{n+1} = p_{n+1/2} + \\frac{h}{2} F(q_{n+1}) = p_{n+1/2} - \\frac{h}{2} q_{n+1}$$\n\n这种对称构造确保了最终的映射是精确辛的。我们还考虑一个有缺陷的变体 (BUG1)，其中漂移步骤错误地使用了初始动量 $p_n$ 而不是 $p_{n+1/2}$：$q_{n+1} = q_n + h \\cdot p_n$。这个看似微小的错误破坏了积分器的对称性，并导致一个非辛映射。\n\n我们诊断程序的核心是对单步映射（记为 $F(x)$）的雅可比矩阵 $J$ 进行数值近似。由于对于复杂系统，通常无法获得 $J$ 的解析表达式，我们采用二阶中心有限差分公式。对于雅可比矩阵的每一列 $i$，对应于相空间向量 $x=(q,p)$ 的第 $i$ 个坐标的微扰，我们有：\n$$\nJ_{:,i} \\approx \\frac{F(x + \\delta e_i) - F(x - \\delta e_i)}{2\\delta}\n$$\n其中 $e_i$ 是第 $i$ 个标准基向量，$\\delta$ 是一个小的微扰。这种近似引入了 $O(\\delta^2)$ 阶的截断误差。\n\n利用数值估计的雅可比矩阵 $\\tilde{J}$，我们计算偏差矩阵 $\\tilde{S} = \\tilde{J}^{\\top}\\Omega \\tilde{J} - \\Omega$。对于正确的 KDK 格式，真实的映射是辛的，因此 $\\tilde{S}$ 中唯一的误差来源应该是来自雅可比矩阵近似的截断误差，即 $\\|\\tilde{S}\\|_{\\infty} = O(\\delta^2)$。然而，对于有缺陷的 BUG1 格式，映射本身不是辛的，这导致 $S$ 中存在一个内在误差，该误差在 $\\delta \\to 0$ 时不会消失。我们会发现这个内在误差的阶数为 $O(h^2)$。第二个数值误差来源是浮点舍入误差，当 $\\delta$ 非常小时，它变得非常显著。有限差分分子中两个几乎相等的数相减，再除以一个非常小的 $\\delta$，会放大舍入误差，贡献一个阶数为 $O(\\epsilon_{\\text{mach}}/\\delta)$ 的项，其中 $\\epsilon_{\\text{mach}}$ 是机器精度（对于双精度，约为 $10^{-16}$）。\n\n该诊断程序将这些考虑因素组合成一个单一的决策规则。我们在相空间中的一组 $N$ 个随机点上计算偏差矩阵的最大绝对值元素 $\\|S\\|_{\\infty}$，并取其找到的最大值。如果这个聚合误差小于或等于指定的容差 $\\tau(\\delta) = 10\\delta^2 + 10^{-8}$，则该实现被分类为正确的辛实现。这个公式为预期的截断误差提供了一个上限（$10\\delta^2$），并为容纳舍入误差提供了一个下限（$10^{-8}$），特别是在 $\\delta$ 值约为 $10^{-8}$ 时，这两个误差源是可比的。\n\n测试套件将检查四种场景：\n1.  **正确的 KDK，较小的 $h$**：诊断应通过，因为测得的误差 $O(\\delta^2) = O((10^{-6})^2) = O(10^{-12})$ 将远低于容差 $\\tau \\approx 10^{-8}$。\n2.  **正确的 KDK，较大的 $h$**：结果应该相同。无论步长 $h$ 如何，映射都是精确辛的，因此诊断误差仅取决于 $\\delta$。\n3.  **有缺陷的 BUG1**：诊断应失败。内在的非辛性引入了一个量级为 $h^2/2 = (0.1)^2/2 = 0.005$ 的误差，这远大于 $\\tau \\approx 10^{-8}$。\n4.  **正确的 KDK，非常小的 $\\delta$**：诊断应失败。舍入误差放大，$O(\\epsilon_{\\text{mach}}/\\delta) \\approx 10^{-16}/10^{-12} = 10^{-4}$，将占主导地位并超过容差 $\\tau \\approx 10^{-8}$。这表明当 $\\delta$ 选择不当时，数值诊断本身存在局限性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the symplecticity diagnostic on a set of test cases.\n    \"\"\"\n    # Define the canonical symplectic form matrix Omega\n    OMEGA = np.array([[0, 1], [-1, 0]], dtype=np.float64)\n\n    # --- Integrator Maps ---\n\n    def kdk_step(x: np.ndarray, h: float) - np.ndarray:\n        \"\"\"\n        Performs one step of the Kick-Drift-Kick (KDK) Leapfrog integrator\n        for the simple harmonic oscillator H = 0.5*p^2 + 0.5*q^2.\n\n        Args:\n            x: Phase-space vector [q, p].\n            h: Time step.\n\n        Returns:\n            New phase-space vector [q_new, p_new].\n        \"\"\"\n        q, p = x\n        # Force F(q) = -dV/dq = -q\n        \n        # Kick 1 (half step)\n        p_half = p - (h / 2.0) * q\n        \n        # Drift (full step) using updated momentum\n        q_new = q + h * p_half\n        \n        # Kick 2 (half step) using new position\n        p_new = p_half - (h / 2.0) * q_new\n        \n        return np.array([q_new, p_new], dtype=np.float64)\n\n    def buggy_step(x: np.ndarray, h: float) - np.ndarray:\n        \"\"\"\n        Performs one step of a flawed Leapfrog integrator where the drift\n        step incorrectly uses the initial momentum.\n\n        Args:\n            x: Phase-space vector [q, p].\n            h: Time step.\n\n        Returns:\n            New phase-space vector [q_new, p_new].\n        \"\"\"\n        q, p = x\n        \n        # Kick 1 (half step)\n        p_half = p - (h / 2.0) * q\n        \n        # Drift (full step) - THE BUG: uses initial momentum p instead of p_half\n        q_new = q + h * p\n        \n        # Kick 2 (half step)\n        p_new = p_half - (h / 2.0) * q_new\n        \n        return np.array([q_new, p_new], dtype=np.float64)\n\n    # --- Diagnostic Tools ---\n\n    def compute_jacobian(map_func, x: np.ndarray, h: float, delta: float) - np.ndarray:\n        \"\"\"\n        Computes the Jacobian of a map function using central finite differences.\n\n        Args:\n            map_func: The one-step map function, e.g., kdk_step.\n            x: The phase-space point [q, p] at which to evaluate the Jacobian.\n            h: The time step for the map function.\n            delta: The perturbation size for the finite difference.\n\n        Returns:\n            The 2x2 Jacobian matrix.\n        \"\"\"\n        dim = len(x)\n        J = np.zeros((dim, dim), dtype=np.float64)\n        \n        for i in range(dim):\n            # Create perturbation vector e_i * delta\n            perturbation = np.zeros(dim, dtype=np.float64)\n            perturbation[i] = delta\n            \n            x_plus = x + perturbation\n            x_minus = x - perturbation\n            \n            f_plus = map_func(x_plus, h)\n            f_minus = map_func(x_minus, h)\n            \n            # Central difference formula for the i-th column of the Jacobian\n            J[:, i] = (f_plus - f_minus) / (2.0 * delta)\n            \n        return J\n\n    def check_symplecticity(scheme_name: str, h: float, delta: float, N: int) - bool:\n        \"\"\"\n        Runs the full diagnostic for a given scheme and parameters.\n\n        Args:\n            scheme_name: Identifier for the scheme ('KDK' or 'BUG1').\n            h: Time step for the integrator.\n            delta: Perturbation for finite-difference Jacobian.\n            N: Number of random samples to test.\n\n        Returns:\n            True if the scheme is classified as symplectic, False otherwise.\n        \"\"\"\n        if scheme_name == 'KDK':\n            map_func = kdk_step\n        elif scheme_name == 'BUG1':\n            map_func = buggy_step\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme_name}\")\n\n        # Fixed seed for reproducibility\n        rng = np.random.default_rng(42)\n        \n        # Generate N random phase-space points (q, p) in [-1, 1] x [-1, 1]\n        samples = rng.uniform(low=-1.0, high=1.0, size=(N, 2))\n        \n        max_S_norm = 0.0\n        \n        for x_point in samples:\n            # 1. Compute numerical Jacobian J\n            J = compute_jacobian(map_func, x_point, h, delta)\n            \n            # 2. Compute the deviation matrix S = J^T Omega J - Omega\n            S = J.T @ OMEGA @ J - OMEGA\n            \n            # 3. Compute the point-wise error ||S||_inf (max absolute entry)\n            s_norm_inf = np.max(np.abs(S))\n            \n            # 4. Aggregate by taking the maximum error found so far\n            if s_norm_inf > max_S_norm:\n                max_S_norm = s_norm_inf\n        \n        # 5. Calculate the tolerance tau(delta)\n        tolerance = 10.0 * delta**2 + 1e-8\n        \n        # 6. Classify based on the tolerance\n        return max_S_norm = tolerance\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('KDK', 0.1, 1e-6, 256),\n        ('KDK', 1.0, 1e-6, 128),\n        ('BUG1', 0.1, 1e-6, 256),\n        ('KDK', 0.1, 1e-12, 64)\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme, h, delta, N = case\n        is_symplectic = check_symplecticity(scheme, h, delta, N)\n        results.append(str(is_symplectic))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3538342"}]}