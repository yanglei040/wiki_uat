{"hands_on_practices": [{"introduction": "在实现复杂的正则化积分器之前，理解其工作原理至关重要。核心思想是通过变换自变量（时间）来使运动方程在引力奇点附近变得更加平滑。本练习将探讨 Sundman 时间变换 $ds/dt = r^{\\alpha}$，并要求您推导一个简单积分器的局部截断误差如何随距离 $r$ 和不同的 $\\alpha$ 值而变化。通过分析这种标度关系 ([@problem_id:3532374])，您将从第一性原理层面理解正则化如何抑制引力奇点，以及哪种变换最为有效。", "problem": "考虑牛顿二体问题，其中一个质点在参数为 $\\mu$ (引力参数) 的固定中心引力势下运动。专注于沿直线的纯径向运动（零角动量），使得物理时间 $t$ 下的物理运动方程简化为常微分方程 (ODE) $dr/dt = v$ 和 $dv/dt = -\\mu/r^{2}$，其中 $r > 0$ 是径向距离，$v$ 是径向速度。为实现算法正则化，引入一个 Sundman 型时间变换，定义为 $ds/dt = r^{\\alpha}$，其中 $\\alpha \\in \\{-1, 0, 1, 2\\}$。考虑在虚拟时间 $s$ 下的变换后系统。\n\n您的任务是从第一性原理出发，通过推导来研究：在不同的 $\\alpha$ 选择下，当接近近距离接触极限 $r \\to 0$ 时，$s$ 时间上的一阶前向欧拉步的主阶局部截断误差如何随 $r$ 缩放。您的推理必须基于基本的牛顿常微分方程、Sundman 变换的定义，以及将局部截断误差定义为应用于 $s$ 时间系统的一步前向欧拉法的泰勒余项中的首个非零项。\n\n要求与约束：\n- 从基本的牛顿常微分方程和定义 $ds/dt = r^{\\alpha}$ 出发。仅使用链式法则和代数推导 $s$ 时间下关于 $r(s)$ 和 $v(s)$ 的变换后常微分方程，除径向运动和牛顿引力外不引入任何额外假设。\n- 将位置更新 $r \\mapsto r + h_s \\, dr/ds$（在 $s$ 时间上经过一个大小为 $h_s$ 的单步前向欧拉积分后）的主阶局部截断误差大小定义为在初始状态 $(r, v)$ 处求值的、$h_s$ 的泰勒余项中首个非零项的绝对值。\n- 通过采用抛物线自由落体运动学作为渐近初始条件族，来专门研究近距离碰撞情景，即取 $v(r) = -\\sqrt{2 \\mu / r}$，这是零比能自由落体的径向速度。这个选择捕捉了普适的 $r \\to 0$ 缩放行为。\n- 为了数值估计缩放指数，您必须对一组给定的半径计算主阶局部截断误差的大小作为 $r$ 的函数，然后在对数空间中进行最小二乘拟合，以提取指数 $\\beta$，使得当 $r \\to 0$ 时误差按 $r^{\\beta}$ 缩放。不要使用任何预先制表或外部提供的特例公式；请从上述基础出发推导您所需要的一切。\n\n数值规格：\n- 使用归一化单位，令 $\\mu = 1$。\n- 使用虚拟时间步长 $h_s = 1$ (无量纲)；由于您要提取的是关于 $r$ 的缩放指数， $h_s$ 的具体正值仅贡献一个常数前置因子，不影响指数。\n- 使用以下半径集合进行拟合：$r \\in \\{10^{-6}, 3 \\cdot 10^{-6}, 10^{-5}, 3 \\cdot 10^{-5}, 10^{-4}, 3 \\cdot 10^{-4}, 10^{-3}\\}$。\n- 对每个 $\\alpha \\in \\{-1, 0, 1, 2\\}$ 分别评估指数 $\\beta$。\n\n测试套件与输出：\n- 测试套件是将四个 $\\alpha$ 值 $\\{-1, 0, 1, 2\\}$ 应用于上述 $r$ 网格。\n- 对于 $\\alpha = -1, 0, 1, 2$ 序列中的每个 $\\alpha$，通过对 $\\log_{10}(\\text{误差})$ 与 $\\log_{10}(r)$ 进行最小二乘拟合来估计缩放指数 $\\beta$。\n- 同时，确定给定集合中的“最优” $\\alpha$ 选择，即最大化估计的 $\\beta$ 的那一个，也就是主阶局部截断误差随 $r$ 减小而衰减最快（或者在没有衰减的情况下发散最慢）的那个。\n- 最终程序输出必须是包含 5 个数字列表的单行：按 $\\alpha = -1, 0, 1, 2$ 顺序排列的四个估计指数，后跟相应的最优 $\\alpha$ 值。所有四个指数必须四舍五入到三位小数，最优 $\\alpha$ 必须是整数。例如，输出可能看起来像 $[\\beta_{-1},\\beta_{0},\\beta_{1},\\beta_{2},\\alpha_{\\text{opt}}]$。\n\n在此径向设置中，角度单位不适用。指数是无量纲的，无需报告其物理单位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[1.000,-2.000,-4.000,-6.000,-1]$）。", "solution": "目标是确定在二体问题近距离接触期间，径向坐标的主阶局部截断误差相对于径向距离 $r$ 的缩放行为。此分析将在 Sundman 时间变换 $ds/dt = r^{\\alpha}$ 下针对不同的整数 $\\alpha$ 值进行。缩放指数可以洞察该变换的正则化能力。\n\n首先，我们推导虚拟时间 $s$ 中的运动方程。纯径向运动的基本牛顿方程如下：\n$$\n\\frac{dr}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = -\\frac{\\mu}{r^2}\n$$\nSundman 变换通过 $ds/dt = r^{\\alpha}$ 将物理时间 $t$ 与虚拟时间 $s$ 关联起来。由此可得 $dt = r^{-\\alpha} ds$。我们使用链式法则将对 $t$ 的导数转换为对 $s$ 的导数：\n$$\n\\frac{dr}{ds} = \\frac{dr}{dt} \\frac{dt}{ds} = v \\cdot \\frac{1}{r^{\\alpha}} = v r^{-\\alpha}\n$$\n$$\n\\frac{dv}{ds} = \\frac{dv}{dt} \\frac{dt}{ds} = \\left(-\\frac{\\mu}{r^2}\\right) \\cdot \\frac{1}{r^{\\alpha}} = -\\mu r^{-2-\\alpha}\n$$\n这些就是状态变量 $(r, v)$ 作为 $s$ 的函数的变换后常微分方程 (ODE)。\n\n接下来，我们分析应用于 $s$ 时间中位置更新的一阶前向欧拉法的局部截断误差 (LTE)。对于大小为 $h_s$ 的单步，$r$ 的前向欧拉更新为：\n$$\nr_{n+1} = r_n + h_s \\left.\\frac{dr}{ds}\\right|_n\n$$\n$r(s_n + h_s)$ 的精确解可以通过在 $s_n$ 处的泰勒级数展开来表示：\n$$\nr(s_n + h_s) = r(s_n) + h_s \\left.\\frac{dr}{ds}\\right|_n + \\frac{h_s^2}{2} \\left.\\frac{d^2r}{ds^2}\\right|_n + O(h_s^3)\n$$\n主阶局部截断误差 $E_r$ 是精确解与数值近似解之差中的首个非零项。对于一阶欧拉法，这是与 $h_s^2$ 成正比的项：\n$$\nE_r \\approx \\frac{h_s^2}{2} \\frac{d^2r}{ds^2}\n$$\n我们要分析的就是这个误差的大小：$|E_r| \\approx \\frac{h_s^2}{2} \\left|\\frac{d^2r}{ds^2}\\right|$。为了找到它随 $r$ 的缩放关系，我们必须计算二阶导数 $\\frac{d^2r}{ds^2}$。我们使用乘法法则和链式法则对 $\\frac{dr}{ds} = v r^{-\\alpha}$ 关于 $s$ 求导：\n$$\n\\frac{d^2r}{ds^2} = \\frac{d}{ds} (v r^{-\\alpha}) = \\frac{dv}{ds} r^{-\\alpha} + v \\frac{d}{ds}(r^{-\\alpha})\n$$\n对第二项应用链式法则：$\\frac{d}{ds}(r^{-\\alpha}) = \\frac{d}{dr}(r^{-\\alpha}) \\frac{dr}{ds} = (-\\alpha r^{-\\alpha-1}) \\frac{dr}{ds}$。\n代入 $\\frac{dr}{ds}$ 和 $\\frac{dv}{ds}$ 的表达式：\n$$\n\\frac{d^2r}{ds^2} = (-\\mu r^{-2-\\alpha}) r^{-\\alpha} + v (-\\alpha r^{-\\alpha-1}) (v r^{-\\alpha})\n$$\n$$\n\\frac{d^2r}{ds^2} = -\\mu r^{-2-2\\alpha} - \\alpha v^2 r^{-2\\alpha-1}\n$$\n这个表达式同时依赖于 $r$ 和 $v$。问题指定使用抛物线自由落体运动学来模拟近距离碰撞情景，此时比轨道能为零。这对应于条件 $v(r) = -\\sqrt{2\\mu/r}$，或 $v^2 = 2\\mu/r$。将此代入二阶导数的表达式中：\n$$\n\\frac{d^2r}{ds^2} = -\\mu r^{-2-2\\alpha} - \\alpha \\left(\\frac{2\\mu}{r}\\right) r^{-2\\alpha-1}\n$$\n$$\n\\frac{d^2r}{ds^2} = -\\mu r^{-2-2\\alpha} - 2\\alpha\\mu r^{-1} r^{-2\\alpha-1}\n$$\n$$\n\\frac{d^2r}{ds^2} = -\\mu r^{-2-2\\alpha} - 2\\alpha\\mu r^{-2-2\\alpha}\n$$\n$$\n\\frac{d^2r}{ds^2} = -\\mu (1 + 2\\alpha) r^{-2(1+\\alpha)}\n$$\n这是在指定条件下二阶导数的最终表达式。请注意，当 $\\alpha = -1/2$ 时，该导数为零，表明精度更高；但是，这个值不在我们所考虑的集合中。\n\n因此，主阶局部截断误差的大小为：\n$$\n|E_r| \\approx \\frac{h_s^2}{2} \\left|-\\mu (1 + 2\\alpha) r^{-2(1+\\alpha)}\\right| = \\frac{h_s^2\\mu}{2} |1 + 2\\alpha| r^{-2(1+\\alpha)}\n$$\n误差随 $r$ 的缩放关系为 $r^{\\beta}$，其中缩放指数 $\\beta$ 由下式给出：\n$$\n\\beta = -2(1+\\alpha)\n$$\n现在我们可以为每个 $\\alpha \\in \\{-1, 0, 1, 2\\}$ 值计算该指数：\n- 对于 $\\alpha = -1$：$\\beta = -2(1 - 1) = 0$。当 $r \\to 0$ 时，误差是常数。\n- 对于 $\\alpha = 0$：$\\beta = -2(1 + 0) = -2$。误差按 $r^{-2}$ 发散。这对应于在物理时间 $dt=ds$ 内进行积分。\n- 对于 $\\alpha = 1$：$\\beta = -2(1 + 1) = -4$。误差按 $r^{-4}$ 发散。这与开普勒时间元 $r dt$ 相关。\n- 对于 $\\alpha = 2$：$\\beta = -2(1 + 2) = -6$。误差按 $r^{-6}$ 发散。\n\n数值任务是通过将计算误差的对数与 $r$ 的对数进行线性拟合来验证这些缩放指数。模型为 $\\log(|E_r|) = \\log(\\text{const}) + \\beta \\log(r)$，因此 $\\beta$ 是对数-对数图的斜率。\n\n在集合 $\\{-1, 0, 1, 2\\}$ 中，$\\alpha$ 的“最优”选择是使指数 $\\beta$ 最大化的那个。更大的 $\\beta$ 意味着当 $r \\to 0$ 时，误差衰减得更快或发散得最慢。计算出的指数为 $\\{0, -2, -4, -6\\}$。最大值为 $\\beta=0$，对应于 $\\alpha = -1$。这个变换 $ds = dt/r$ 被称为类偏近点角时间元，在所有选项中，它对自由落体奇点的正则化程度最低，使得在此特定分析中主阶误差与 $r$ 无关。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the scaling exponent of the local truncation error for different\n    Sundman time transformations in the radial two-body problem.\n    \"\"\"\n    \n    # Numerical specifications from the problem statement\n    mu = 1.0\n    hs = 1.0\n    r_values = np.array([1e-6, 3e-6, 1e-5, 3e-5, 1e-4, 3e-4, 1e-3])\n    alpha_values = [-1, 0, 1, 2]\n\n    # Pre-calculate the logarithm of the radii for fitting\n    log10_r = np.log10(r_values)\n\n    beta_estimates = []\n\n    for alpha in alpha_values:\n        # Analytically derived expression for the second derivative d^2r/ds^2\n        # d^2r/ds^2 = -mu * (1 + 2*alpha) * r**(-2 * (1 + alpha))\n        # The constant part of the expression\n        # For alpha = -0.5, the expression is zero, which would require\n        # a different error analysis (higher-order terms). This case is not\n        # in the test suite.\n        const_factor = -mu * (1.0 + 2.0 * alpha)\n        \n        # Power of r in the expression\n        r_exponent = -2.0 * (1.0 + alpha)\n        \n        # Second derivative values\n        d2r_ds2_values = const_factor * (r_values ** r_exponent)\n        \n        # Leading-order local truncation error magnitude\n        # E(r) = (hs^2 / 2) * |d^2r/ds^2|\n        error_magnitudes = (hs**2 / 2.0) * np.abs(d2r_ds2_values)\n        \n        # Take the logarithm for linear fitting\n        log10_error = np.log10(error_magnitudes)\n        \n        # Perform a linear least-squares fit in log-log space.\n        # The model is log10(error) = beta * log10(r) + log10(C).\n        # np.polyfit returns [slope, intercept], so we need the first element.\n        beta, _ = np.polyfit(log10_r, log10_error, 1)\n        \n        beta_estimates.append(beta)\n\n    # Find the optimal alpha, which maximizes the scaling exponent beta\n    max_beta = -np.inf\n    optimal_alpha = None\n    for i, beta in enumerate(beta_estimates):\n        if beta > max_beta:\n            max_beta = beta\n            optimal_alpha = alpha_values[i]\n            \n    # Format the results as required by the problem statement\n    # Exponents rounded to three decimal places\n    formatted_betas = [f\"{b:.3f}\" for b in beta_estimates]\n    \n    # Final list of results\n    final_results = formatted_betas + [str(optimal_alpha)]\n    \n    # Print the final output in the specified single-line format\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "3532374"}, {"introduction": "理论误差分析表明正则化是有益的，但这如何转化为计算性能的提升呢？一个关键优势是能够在新的时间坐标下使用更大、更均匀的步长。本练习要求您估算通过一个高偏心率轨道的近心点通道所需的总积分步数，并比较正则化（$\\alpha=1$）与非正则化（$\\alpha=0$）积分器之间的差异。通过实现这个步数估算模型 ([@problem_id:3532368])，您将在实际的天体物理场景中，特别是在近抛物线相遇的情况下，量化正则化所带来的显著效率提升。", "problem": "考虑一个双体牛顿引力系统，其引力参数为 $\\mu$，开普勒圆锥轨道由偏心率 $e$ 和近心点距离 $r_p$ 表征。令 $f$ 表示真近点角，$r(f)$ 表示真近点角为 $f$ 时的径向距离。该系统在一个由 Sundman 变换 $ds = dt / r^{\\alpha}$ 定义的重参数化自变量 $s$ 中进行积分，其中 $\\alpha$ 是一个常数指数，用于控制近距离接触中的正则化强度。\n\n根据双体动力学，真近点角的瞬时变化率满足 $df/dt = h/r^2$，其中 $h$ 是比角动量，$r(f)$ 由开普勒圆锥公式 $r(f) = p/(1 + e \\cos f)$ 给出，半通径为 $p = r_p (1 + e)$。比角动量为 $h = \\sqrt{\\mu p}$。Sundman 重参数化意味着 $df/ds = (df/dt)(dt/ds) = h r^{\\alpha - 2}$。\n\n将近心点通过区域定义为真近点角中的对称区间 $f \\in [-f_0, f_0]$，使得 $r(f_0) = R r_p$，其中 $R > 1$ 是一个固定的径向比，用于选择通过区域的边界。此条件通过关系式 $r(f_0)/r_p = (1+e)/(1 + e \\cos f_0) = R$ 确定 $f_0$，因此 $\\cos f_0 = \\left(\\frac{1+e}{R} - 1\\right)/e$。角度必须以弧度处理。\n\n你的任务是为常数 $s$ 步长积分器推导、实现并使用一个步长估计，以确保真近点角上的相位误差满足目标界限。假设一个保守的局部步长准则，要求每一步真近点角的变化量受目标相位容差 $\\varepsilon_f$（以弧度为单位）的限制。在此准则下，$s$ 中允许的最大步长为 $\\Delta s_{\\max} = \\varepsilon_f / \\max_{f \\in [-f_0, f_0]}(df/ds)$。由于 $r(f)$ 在近心点 $f = 0$ 处达到最小值 $r(0) = r_p$，可以得出 $\\max(df/ds) = h r_p^{\\alpha - 2}$，因此 $\\Delta s_{\\max} = \\varepsilon_f / (h r_p^{\\alpha - 2})$。\n\n令 $S(\\alpha)$ 表示一次近心点通过所跨越的总 Sundman 时间，\n$$\nS(\\alpha) = \\int_{-f_0}^{f_0} ds = \\int_{-f_0}^{f_0} \\frac{dt}{r^{\\alpha}} = \\int_{-f_0}^{f_0} \\frac{r^{2-\\alpha}}{h} \\, df = \\frac{1}{h}\\int_{-f_0}^{f_0} \\left( \\frac{p}{1 + e \\cos f} \\right)^{2 - \\alpha} \\, df.\n$$\n使用上述保守步长准则，估计遍历近心点通过区域所需的常数 $s$ 步数 $N(\\alpha)$ 为\n$$\nN(\\alpha) = \\left\\lceil \\frac{S(\\alpha)}{\\Delta s_{\\max}} \\right\\rceil = \\left\\lceil \\frac{S(\\alpha) \\, h \\, r_p^{\\alpha - 2}}{\\varepsilon_f} \\right\\rceil.\n$$\n\n你的任务是：\n- 实现一个程序，对于每个提供的测试用例，根据上述定义计算 $\\alpha = 0$ 时的所需步数 $N(0)$ 和 $\\alpha = 1$ 时的所需步数 $N(1)$。\n- 使用正则单位，其中 $\\mu = 1$，距离和时间使用一致的无量纲单位，并以弧度报告角度。目标相位容差 $\\varepsilon_f$ 以弧度为单位提供。\n- 使用上述关于 $\\cos f_0$ 的关系式计算 $f_0$。验证 $\\arccos$ 的参数位于 $[-1,1]$ 内；否则，此测试用例无效。\n- 通过对被积函数 $(p/(1 + e \\cos f))^{2 - \\alpha}/h$进行数值积分，将 $S(\\alpha)$ 作为在 $f \\in [-f_0, f_0]$ 上的定积分进行评估。\n\n测试套件：\n对于每个测试用例，使用下面给出的参数 $(\\mu, e, r_p, R, \\varepsilon_f)$。所有评估必须以弧度进行，最终输出必须是无单位的整数。\n\n1. 情况 A (近抛物线，中等通过宽度):\n   - $\\mu = 1$, $e = 0.999$, $r_p = 1$, $R = 5$, $\\varepsilon_f = 10^{-3}$。\n\n2. 情况 B (精确抛物线边界情况):\n   - $\\mu = 1$, $e = 1.0$, $r_p = 1$, $R = 5$, $\\varepsilon_f = 10^{-3}$。\n\n3. 情况 C (更极端的近抛物线，具有更小的近心点和更宽的通过区域):\n   - $\\mu = 1$, $e = 0.9999$, $r_p = 0.1$, $R = 10$, $\\varepsilon_f = 5 \\times 10^{-4}$。\n\n4. 情况 D (较不极端的偏心率，较大的近心点):\n   - $\\mu = 1$, $e = 0.99$, $r_p = 10$, $R = 5$, $\\varepsilon_f = 2 \\times 10^{-3}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个双元素列表 $[N(0), N(1)]$。例如，输出应如下所示\n$[[N(0)_A, N(1)_A], [N(0)_B, N(1)_B], [N(0)_C, N(1)_C], [N(0)_D, N(1)_D]]$。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于牛顿力学和天体动力学的原理，特别是关于二体问题和用于数值积分的时间正则化技术。该问题定义良好，提供了所有必要的参数和定义，并且不包含内部矛盾或歧义。计算任务是可行的，并且与计算天体物理学领域相关。\n\n目标是计算在两种不同的 Sundman 变换（由 $\\alpha=0$ 和 $\\alpha=1$ 表征）下，积分一个双体系统通过近心点区域所需的估计常数 $s$ 步数 $N(\\alpha)$。步数由以下公式给出：\n$$\nN(\\alpha) = \\left\\lceil \\frac{S(\\alpha)}{\\Delta s_{\\max}} \\right\\rceil\n$$\n其中 $S(\\alpha)$ 是通过区域的总 Sundman 时间，$\\Delta s_{\\max}$ 是正则化时间 $s$ 中允许的最大步长。\n\n根据提供的定义，我们可以写出 $N(\\alpha)$ 的更直接的表达式。总 Sundman 时间为\n$$\nS(\\alpha) = \\frac{1}{h}\\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df\n$$\n最大步长基于真近点角的最快变化，这发生在近心点（$f=0$, $r=r_p$）：\n$$\n\\Delta s_{\\max} = \\frac{\\varepsilon_f}{\\max(df/ds)} = \\frac{\\varepsilon_f}{h\\,r_p^{\\alpha - 2}}\n$$\n将这些结合起来，得到步数的最终表达式：\n$$\nN(\\alpha) = \\left\\lceil \\frac{\\left( \\frac{1}{h}\\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df \\right) h \\, r_p^{\\alpha - 2}}{\\varepsilon_f} \\right\\rceil = \\left\\lceil \\frac{r_p^{\\alpha - 2}}{\\varepsilon_f} \\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df \\right\\rceil\n$$\n其中 $r(f)$ 是真近点角为 $f$ 时的轨道半径。\n\n每个测试用例 $(\\mu, e, r_p, R, \\varepsilon_f)$ 的计算过程如下：\n\n1.  **计算轨道和通过参数**：首先，我们确定开普勒轨道和近心点通过区域的基本属性。\n    - 半通径 $p$ 计算为 $p = r_p (1 + e)$。\n    - 轨道半径由圆锥曲线的极坐标方程给出：$r(f) = \\frac{p}{1 + e \\cos f}$。\n    - 近心点通过区域的边界由真近点角 $\\pm f_0$ 定义，其中径向距离为 $r(f_0) = R r_p$。这导出 $\\cos f_0$ 的方程：\n      $$\n      \\cos f_0 = \\frac{\\frac{1+e}{R} - 1}{e}\n      $$\n      对于抛物线轨道（$e=1$）的特殊情况，这简化为 $\\cos f_0 = \\frac{2}{R} - 1$。一个关键的验证步骤，如问题所述，是确保反余弦函数的参数在有效范围 $[-1, 1]$ 内。然后我们求得 $f_0 = \\arccos(\\cos f_0)$，其中 $f_0 \\in [0, \\pi]$。\n\n2.  **评估积分**：积分项 $\\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df$ 通常没有简单的解析解。因此，必须使用数值求积法进行评估。被积函数 $r(f)^{2-\\alpha}$ 是 $f$ 的偶函数，因为 $\\cos(f) = \\cos(-f)$。这种对称性使得计算更高效：\n    $$\n    \\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df = 2 \\int_{0}^{f_0} \\left( \\frac{p}{1 + e \\cos f} \\right)^{2 - \\alpha} \\, df\n    $$\n    对于每个所需的 $\\alpha$ 值（$\\alpha=0$ 和 $\\alpha=1$），此定积分均采用数值计算。\n\n3.  **计算步数 $N(\\alpha)$**：利用积分值，我们使用推导出的公式计算 $N(\\alpha)$：\n    $$\n    N(\\alpha) = \\left\\lceil \\frac{2 \\cdot r_p^{\\alpha - 2}}{\\varepsilon_f} \\int_{0}^{f_0} \\left( \\frac{p}{1 + e \\cos f} \\right)^{2 - \\alpha} \\, df \\right\\rceil\n    $$\n    应用向上取整函数 $\\lceil \\cdot \\rceil$ 以确保步数为足以覆盖整个区间的整数。此计算针对 $\\alpha=0$（无时间正则化，$ds=dt$）和 $\\alpha=1$（通过 $ds=dt/r$ 进行正则化）进行。\n\n此过程提供了导航近距离接触所需的计算工作的定量估计。$N(0)$ 和 $N(1)$ 之间的比较说明了正则化的有效性。对于在近心点附近速度急剧变化的高偏心率轨道，标准时间步进器（$\\alpha=0$）需要非常大量的步数来保持精度。$\\alpha=1$ 正则化变换自变量，以在轨道最快的部分减慢数值积分，从而在 $s$ 域中产生更均匀的步长，因此，与 $N(0)$ 相比，总步数 $N(1)$ 更小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the number of steps N(0) and N(1) for each case\n    and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case A (near-parabolic, moderate passage width):\n        # (mu, e, r_p, R, eps_f)\n        (1.0, 0.999, 1.0, 5.0, 1e-3),\n\n        # Case B (exact parabolic boundary case):\n        (1.0, 1.0, 1.0, 5.0, 1e-3),\n\n        # Case C (more extreme near-parabolic with smaller pericenter and wider passage):\n        (1.0, 0.9999, 0.1, 10.0, 5e-4),\n\n        # Case D (less extreme eccentricity, larger pericenter):\n        (1.0, 0.99, 10.0, 5.0, 2e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        mu, e, r_p, R, eps_f = case\n        \n        # Calculate N for alpha = 0 and alpha = 1\n        n0 = _calculate_n_alpha(0, e, r_p, R, eps_f)\n        n1 = _calculate_n_alpha(1, e, r_p, R, eps_f)\n        \n        results.append(f\"[{n0},{n1}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef _calculate_n_alpha(alpha, e, r_p, R, eps_f):\n    \"\"\"\n    Calculates the number of steps N(alpha) for a given set of parameters.\n\n    Args:\n        alpha (float): The exponent of the Sundman transformation.\n        e (float): Eccentricity.\n        r_p (float): Pericenter distance.\n        R (float): Radial ratio defining the passage boundary.\n        eps_f (float): Target phase tolerance in radians.\n\n    Returns:\n        int: The calculated number of steps N(alpha).\n    \"\"\"\n    # Calculate the semilatus rectum p\n    p = r_p * (1.0 + e)\n\n    # Calculate the cosine of the boundary true anomaly f0\n    # Special handling for the parabolic case e = 1 to avoid division by zero in theory,\n    # though the formula simplifies correctly.\n    if np.isclose(e, 1.0):\n        cos_f0 = 2.0 / R - 1.0\n    else:\n        cos_f0 = ((1.0 + e) / R - 1.0) / e\n\n    # Validate that the argument for arccos is within [-1, 1]\n    if not -1.0 = cos_f0 = 1.0:\n        # This case should be considered invalid as per the problem description.\n        # This check is included for robustness.\n        raise ValueError(\n            f\"Invalid arccos argument for f0 calculation: {cos_f0:.6f}\"\n        )\n    \n    f0 = np.arccos(cos_f0)\n\n    # Define the integrand for the Sundman time S(alpha) calculation\n    # Integrand is r(f)^(2-alpha)\n    def integrand(f):\n        return (p / (1.0 + e * np.cos(f)))**(2.0 - alpha)\n        \n    # Numerically integrate from 0 to f0. The full integral is 2x this value.\n    # The quad function from SciPy returns the result and an error estimate.\n    integral_val, _ = quad(integrand, 0, f0)\n    \n    # Calculate N(alpha) using the derived formula\n    # N(alpha) = ceil( (r_p^(alpha-2) / eps_f) * integral over [-f0, f0] )\n    # integral over [-f0, f0] is 2 * integral over [0, f0]\n    term = (r_p**(alpha - 2.0) / eps_f) * (2.0 * integral_val)\n    \n    # The number of steps must be an integer, so we take the ceiling.\n    num_steps = np.ceil(term)\n    \n    return int(num_steps)\n\nsolve()\n```", "id": "3532368"}, {"introduction": "尽管局部精度和步数很重要，但轨道动力学数值积分器的最终考验在于其长期保真度。能量和角动量等守恒量的误差会在多个轨道周期内累积，导致非物理性的长期漂移。在此实践中，您将为正则化运动方程实现一个完整的四阶龙格-库塔积分器，并测量在数万个轨道周期内角动量的长期漂移。这个模拟 ([@problem_id:3532333]) 提供了一种常见且关键的验证测试的直接经验，揭示了正则化参数和步长的选择如何影响 N 体代码的长期稳定性和科学可靠性。", "problem": "考虑一个平面内的牛顿引力下的束缚双体问题，引力参数为 $\\mu  0$。在相对坐标中，设位置为 $\\mathbf{x}(t) \\in \\mathbb{R}^2$，速度为 $\\mathbf{v}(t) = d\\mathbf{x}/dt$。运动方程由下式给出：$$\\frac{d^2 \\mathbf{x}}{dt^2} = - \\mu \\frac{\\mathbf{x}}{r^3},$$ 其中 $r = \\|\\mathbf{x}\\|$。角动量矢量为 $\\mathbf{L} = \\mathbf{x} \\times \\mathbf{v}$，它在连续动力学中是精确守恒的，并且在二维情况下，其大小简化为标量 $L_z = x v_y - y v_x$。\n\n为正则化近距离接近，引入一个带有参数 $\\alpha \\ge 0$ 的 Sundman 时间变换，定义为 $$dt = r^{\\alpha} \\, d\\tau.$$ 用撇号表示对 $\\tau$ 的导数。根据链式法则，变换后的二阶系统变为 $$\\mathbf{x}'' = - \\mu \\, \\mathbf{x} \\, r^{2\\alpha - 3} + \\alpha \\, r^{-2} \\, \\mathbf{x}' \\, (\\mathbf{x} \\cdot \\mathbf{x}'),$$ 以及时间演化方程 $$t' = r^{\\alpha}.$$ 计算角动量所需的物理速度可通过下式恢复 $$\\mathbf{v} = \\frac{\\mathbf{x}'}{r^{\\alpha}}.$$\n\n你需要使用固定步长的四阶龙格-库塔方法，在 Sundman 变量 $\\tau$ 下为该变换后的系统实现一个数值积分器。初始条件对应于一个半长轴 $a = 1$、离心率 $e = 0.9$（无量纲单位）的开普勒椭圆，其中 $\\mu = 1$。在近心点进行初始化：$$\\mathbf{x}(0) = (r_p, 0), \\quad r_p = a (1 - e),$$ $$\\mathbf{v}(0) = \\left(0, \\sqrt{\\mu \\left(\\frac{2}{r_p} - \\frac{1}{a}\\right)}\\right),$$ 以及 $$\\mathbf{x}'(0) = \\mathbf{v}(0)\\, r_p^{\\alpha}, \\quad t(0) = 0.$$ 轨道周期为 $$P = 2\\pi \\frac{a^{3/2}}{\\sqrt{\\mu}},$$ 在此单位下计算为 $P = 2\\pi$。\n\n对于给定的轨道数 $N_{\\text{orb}} = 10^5$，进行积分，直到物理时间 $t$ 满足 $t \\ge T_{\\text{final}}$，其中 $$T_{\\text{final}} = N_{\\text{orb}} \\, P.$$ 在积分结束时，使用最终的 $\\mathbf{x}$ 和 $\\mathbf{v}$ 通过下式计算标量角动量 $L_z$：$$L_z = x v_y - y v_x = \\frac{x x'_y - y x'_x}{r^{\\alpha}}.$$ 将数值方案中角动量的长期漂移量化为无量纲标量 $$\\Delta = \\frac{L_z(T_{\\text{final}}) - L_z(0)}{L_z(0)}.$$\n\n设计你的程序，以评估以下正则化参数和 Sundman 步长 $(\\alpha, h)$ 测试套件的 $\\Delta$ 值：\n- 测试用例 $0$：$(\\alpha, h) = (1.0, 1.2)$。\n- 测试用例 $1$：$(\\alpha, h) = (2.0, 1.2)$。\n- 测试用例 $2$：$(\\alpha, h) = (0.5, 1.2)$。\n- 测试用例 $3$：$(\\alpha, h) = (1.0, 2.4)$。\n\n所有量均为无量纲；无需物理单位。角度（如果使用任何中间角度）必须以弧度为单位，但数值算法必须纯粹使用矢量状态进行计算，而不显式使用角度。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须包含五个条目：前四个条目是测试用例 0 到 3 的漂移量 $\\Delta$（按此顺序，为浮点数），第五个条目是使绝对漂移最小化的测试用例的整数索引 $i^\\ast \\in \\{0,1,2,3\\}$，即 $$i^\\ast = \\underset{i \\in \\{0,1,2,3\\}}{\\operatorname{argmin}} \\, |\\Delta_i|.$$\n\n通过遵循定义的模型和初始条件，确保科学真实性和数值稳定性。你的实现必须是自包含的，不得读取输入，也不得访问任何外部资源。最终答案必须严格按照指定格式打印，不得包含任何额外文本。", "solution": "用户提供的问题已经过分析和验证。这是一个在计算天体物理学中定义明确且科学合理的问题，要求对开普勒问题的正则化进行数值实验。所有必需的参数、方程和条件均已提供，不存在不一致或模糊之处。\n\n核心任务是积分一个引力作用下双体系统的运动方程，这些方程已通过 Sundman 时间变换 $dt = r^{\\alpha} \\, d\\tau$ 进行了转换。该变换通过在近距离接近（小 $r$）期间减慢虚拟时间 $\\tau$ 的积分速度，从而对 $r=0$ 处的奇点进行正则化。目标是针对不同的正则化参数 $\\alpha$ 和数值步长 $h$ 值，测量角动量守恒的长期数值误差。\n\n算法解决方案的结构如下：\n\n1.  **一阶常微分方程组**：该问题被表述为一个关于 Sundman 时间变量 $\\tau$ 的包含五个一阶常微分方程（ODE）的方程组。系统状态由向量 $Y(\\tau) = [x(\\tau), y(\\tau), x'_x(\\tau), x'_y(\\tau), t(\\tau)]^T$ 描述，其中 $\\mathbf{x}=(x,y)$ 是位置，$\\mathbf{x}'=d\\mathbf{x}/d\\tau$ 是变换后的速度，$t$ 是物理时间。状态向量的导数 $Y'(\\tau) = dY/d\\tau$ 是一个从问题陈述中提供的方程推导出的函数 $F(Y, \\alpha)$。\n\n2.  **导数函数 $F(Y, \\alpha)$**：导数向量 $Y' = [x'_x, x'_y, x'', y'', t']^T$ 的分量按如下方式确定：\n    -   位置的导数 $(x', y')$ 直接作为状态向量 $Y$ 的第三和第四个分量。\n    -   物理时间的导数 $t'$ 由变换规则给出：$t' = r^{\\alpha}$，其中 $r = \\sqrt{x^2+y^2}$。\n    -   变换后的加速度 $\\mathbf{x}'' = (x'', y'')^T$ 由变换后的运动方程给出：\n        $$ \\mathbf{x}'' = - \\mu \\, \\mathbf{x} \\, r^{2\\alpha - 3} + \\alpha \\, r^{-2} \\, (\\mathbf{x} \\cdot \\mathbf{x}') \\, \\mathbf{x}' $$\n    这个函数 $F(Y, \\alpha)$ 定义了系统在 $\\tau$ 域中的完整动力学。\n\n3.  **初始条件**：积分始于一个半长轴 $a=1$、离心率 $e=0.9$ 的开普勒椭圆的近心点。\n    -   近心点距离为 $r_p = a(1-e) = 1(1-0.9) = 0.1$。\n    -   初始位置为 $\\mathbf{x}(0) = (r_p, 0) = (0.1, 0)$。\n    -   近心点的速度纯粹在 $y$ 方向，其大小为 $v_p = \\sqrt{\\mu(2/r_p - 1/a)} = \\sqrt{1(2/0.1 - 1/1)} = \\sqrt{19}$。因此，$\\mathbf{v}(0) = (0, \\sqrt{19})$。\n    -   初始变换速度为 $\\mathbf{x}'(0) = \\mathbf{v}(0) r_p^{\\alpha} = (0, \\sqrt{19} \\cdot 0.1^\\alpha)$。这取决于测试用例的参数 $\\alpha$。\n    -   初始物理时间为 $t(0) = 0$。\n    -   将这些结合起来，得到初始状态向量 $Y(0) = [0.1, 0, 0, \\sqrt{19} \\cdot 0.1^\\alpha, 0]^T$。\n\n4.  **数值积分**：采用标准的四阶龙格-库塔（RK4）方案，以固定步长 $h$（在 $\\tau$ 中）将状态向量从 $Y_n$推进到 $Y_{n+1}$：\n    $$ Y_{n+1} = Y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4) $$\n    其中 $k_1 = F(Y_n, \\alpha)$，$k_2 = F(Y_n+\\frac{h}{2}k_1, \\alpha)$，$k_3 = F(Y_n+\\frac{h}{2}k_2, \\alpha)$，以及 $k_4 = F(Y_n + h k_3, \\alpha)$。积分从 $Y(0)$ 开始迭代进行，直到物理时间分量 $Y_4 = t$ 达到或超过目标最终时间 $T_{\\text{final}} = N_{\\text{orb}} P = 10^5 \\times 2\\pi$。\n\n5.  **误差量化**：积分完成后，计算角动量的数值漂移。\n    -   初始角动量为 $L_z(0) = x(0)v_y(0) - y(0)v_x(0) = r_p v_p = 0.1\\sqrt{19}$。\n    -   最终角动量 $L_z(T_{\\text{final}})$ 是根据最终状态向量 $Y_f = [x_f, y_f, x'_{xf}, x'_{yf}, t_f]^T$ 使用以下公式计算的：\n        $$ L_z(T_{\\text{final}}) = \\frac{x_f x'_{yf} - y_f x'_{xf}}{r_f^{\\alpha}} $$\n        其中 $r_f = \\sqrt{x_f^2+y_f^2}$。\n    -   然后，相对漂移评估为 $\\Delta = \\frac{L_z(T_{\\text{final}}) - L_z(0)}{L_z(0)}$。\n\n6.  **执行与输出**：对四个测试用例 $(\\alpha, h)$ 中的每一个都执行上述过程。收集得到的四个 $\\Delta$ 值。确定对应于最小绝对漂移 $|\\Delta_i|$ 的索引 $i^\\ast \\in \\{0,1,2,3\\}$。最终输出为单行，包含四个漂移值和最优索引 $i^\\ast$，格式为方括号内的逗号分隔列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the regularized two-body problem for the specified test cases\n    and determines the optimal regularization parameter set.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, h)\n        (1.0, 1.2),  # Case 0\n        (2.0, 1.2),  # Case 1\n        (0.5, 1.2),  # Case 2\n        (1.0, 2.4),  # Case 3\n    ]\n\n    # Physical and orbital parameters\n    MU = 1.0\n    A = 1.0\n    E = 0.9\n    N_ORB = 100000\n\n    # Calculated constants\n    P = 2.0 * np.pi * A**(1.5) / np.sqrt(MU)\n    T_FINAL = N_ORB * P\n\n    def F(Y, alpha):\n        \"\"\"\n        Computes the derivative dY/d(tau) for the regularized system.\n        Y = [x, y, x_prime, y_prime, t]\n        \"\"\"\n        x, y, vx_p, vy_p, _ = Y\n        \n        r_sq = x*x + y*y\n        r = np.sqrt(r_sq)\n\n        if r == 0.0:\n            return np.zeros_like(Y)\n            \n        # Time derivative: t' = r^alpha\n        t_prime = r**alpha\n\n        # Acceleration in tau-time: x''\n        x_vec = np.array([x, y])\n        xp_vec = np.array([vx_p, vy_p])\n        \n        # x'' = - mu * x * r^(2*alpha - 3) + alpha * r^(-2) * x' * (x . x')\n        r_pow_term = r**(2.0 * alpha - 3.0)\n        x_dot_xp = x * vx_p + y * vy_p\n        \n        x_dd_vec = -MU * r_pow_term * x_vec + alpha * r**(-2.0) * x_dot_xp * xp_vec\n        \n        return np.array([vx_p, vy_p, x_dd_vec[0], x_dd_vec[1], t_prime])\n\n    def run_simulation(alpha, h):\n        \"\"\"\n        Performs a full RK4 integration for a given (alpha, h) pair.\n        \"\"\"\n        # Initial conditions at pericenter\n        r_p = A * (1.0 - E)\n        v_p = np.sqrt(MU * (2.0/r_p - 1.0/A))\n        \n        x0_vec = np.array([r_p, 0.0])\n        v0_vec = np.array([0.0, v_p])\n        xp0_vec = v0_vec * (r_p**alpha)\n        \n        # State vector Y = [x, y, x_prime, y_prime, t]\n        Y = np.array([x0_vec[0], x0_vec[1], xp0_vec[0], xp0_vec[1], 0.0])\n\n        # Initial angular momentum Lz(0)\n        Lz0 = x0_vec[0] * v0_vec[1] - x0_vec[1] * v0_vec[0]\n\n        # RK4 integration loop\n        while Y[4]  T_FINAL:\n            k1 = F(Y, alpha)\n            k2 = F(Y + 0.5 * h * k1, alpha)\n            k3 = F(Y + 0.5 * h * k2, alpha)\n            k4 = F(Y + h * k3, alpha)\n            Y += (h / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n            \n        # Final state analysis\n        xf, yf, vxf_p, vyf_p, _ = Y\n        rf = np.sqrt(xf**2 + yf**2)\n        \n        if rf == 0.0:\n            Lz_final = 0.0\n        else:\n            # Lz_final = (x_f * x'_yf - y_f * x'_xf) / r_f^alpha\n            Lz_final = (xf * vyf_p - yf * vxf_p) / (rf**alpha)\n        \n        # Calculate relative drift\n        delta = (Lz_final - Lz0) / Lz0\n        return delta\n\n    # Execute for all test cases\n    results_delta = []\n    for case in test_cases:\n        alpha, h = case\n        delta = run_simulation(alpha, h)\n        results_delta.append(delta)\n\n    # Find the index of the test case with minimum absolute drift\n    min_abs_drift_index = np.argmin(np.abs(np.array(results_delta)))\n\n    # Combine results and print in the specified format\n    final_output = results_delta + [min_abs_drift_index]\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```", "id": "3532333"}]}