{"hands_on_practices": [{"introduction": "在修正数值磁散度之前，我们必须首先能够探测并量化它。这项练习将引导你完成构建诊断工具的实际步骤，以衡量对 $\\nabla \\cdot \\mathbf{B} = 0$ 约束的局部违反程度，并为修正操作（如散度清理或网格加密）创建自动化触发器[@problem_id:3506882]。这是任何稳健的磁流体动力学（MHD）模拟中的第一步，它确保了我们只在需要时和必要的地方采取修正措施，从而在保持物理准确性的同时优化计算资源。", "problem": "要求您为理想磁流体动力学（MHD，Magnetohydrodynamics）中由伪散度引起的加速度构建并测试一种计算诊断工具。该诊断工具必须基于第一性原理，并在均匀笛卡尔网格上实现。目标是定义一个代理加速度，用以量化对磁场高斯定律的数值违反，并设计阈值标准以触发局部散度清理或网格加密。\n\n从磁场高斯定律出发，该定律指出磁场在连续介质中必须满足 $\\nabla \\cdot \\mathbf{B} = 0$。您将基于此在均匀二维网格上推导并实现离散诊断工具。请仅使用以下基本且经过充分检验的事实作为出发点：\n\n- 麦克斯韦方程组（磁场高斯定律）：$\\nabla \\cdot \\mathbf{B} = 0$。\n- 间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀笛卡尔网格。\n- 光滑场允许进行泰勒展开；中心有限差分可以在内部区域以二阶精度逼近一阶导数；单边差分提供一阶边界闭合方案。\n- 磁场大小为 $|\\mathbf{B}| = \\sqrt{B_x^2 + B_y^2}$。\n- 当 $\\nabla \\cdot \\mathbf{B} \\neq 0$ 时，离散动量方程中会出现类似磁单极子的伪力；由此产生的加速度的一个常用代理，在相差一个常数的情况下，与 $-(\\nabla \\cdot \\mathbf{B}) \\mathbf{B}$ 成正比。\n\n您的任务是：\n\n- 在均匀网格的内部区域，使用中心差分格式推导并实现 $\\nabla \\cdot \\mathbf{B}$ 的二阶精度有限差分近似；在边界上，使用一致的单边近似。\n- 基于此离散散度，定义并实现一个无量纲归一化散度指标$\\varepsilon$，其随分辨率的变化关系为$\\varepsilon \\sim h |\\nabla \\cdot \\mathbf{B}| / (|\\mathbf{B}| + B_{\\mathrm{floor}})$，其中$h$是特征网格尺寸，$B_{\\mathrm{floor}}$是一个小的正则化常数，用于防止除以零。选择$h = \\min(\\Delta x, \\Delta y)$，并将$B_{\\mathrm{floor}}$视为给定参数。\n- 定义并计算代理伪加速度矢量$\\mathbf{f}_{\\mathrm{div}} \\propto -(\\nabla \\cdot \\mathbf{B}) \\mathbf{B}$。\n- 根据局部诊断量设计用于清理和加密的布尔触发器：\n  - 如果$\\varepsilon > \\theta_{\\mathrm{clean}}$，则清理触发器$T_{\\mathrm{clean}}$设置为真。\n  - 如果$\\varepsilon > \\theta_{\\mathrm{ref}}$或$|\\nabla \\cdot \\mathbf{B}| > \\phi_{\\mathrm{abs}}$，则加密触发器$T_{\\mathrm{ref}}$设置为真。\n  使用给定的阈值$\\theta_{\\mathrm{clean}}$、$\\theta_{\\mathrm{ref}}$和$\\phi_{\\mathrm{abs}}$。\n\n您必须实现一个程序，对下面的每个测试用例，计算：\n- 网格上$\\varepsilon$的最大值，记为$\\varepsilon_{\\max}$（无单位）。\n- $T_{\\mathrm{clean}}$为真的网格单元总数（整数计数）。\n- $T_{\\mathrm{ref}}$为真的网格单元总数（整数计数）。\n\n报告$\\varepsilon_{\\max}$，四舍五入到六位小数。本问题中的所有量均视为无单位（无量纲）。若涉及角度，必须以弧度为单位解释。\n\n离散算子和边界条件：\n- 使用大小为 $N_x \\times N_y$、间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀二维网格。\n- 在内部网格单元上，使用二阶中心有限差分来近似 $\\partial B_x/\\partial x$ 和 $\\partial B_y/\\partial y$。\n- 在区域边界上，使用一致的一阶单边有限差分。\n\n阈值和正则化：\n- 使用$\\theta_{\\mathrm{clean}} = 0.2$、$\\theta_{\\mathrm{ref}} = 0.6$、$\\phi_{\\mathrm{abs}} = 0.8$和$B_{\\mathrm{floor}} = 10^{-6}$。\n\n测试套件：\n为以下四个测试用例提供结果。在所有情况下，网格均为网格中心类型，且 $\\mathbf{B}$ 在网格中心给出。\n\n- 测试用例 A（通过构造得到的光滑、近似无散场）：$N_x = 33$, $N_y = 33$，区域 $x \\in [0, 2\\pi]$，$y \\in [0, 2\\pi]$，因此 $\\Delta x = 2\\pi/(N_x - 1)$ 且 $\\Delta y = 2\\pi/(N_y - 1)$。定义流函数 $\\psi(x,y) = \\sin(k_x x) \\sin(k_y y)$，其中 $k_x = 2$，$k_y = 3$。通过 $B_x = \\partial \\psi/\\partial y$ 和 $B_y = -\\partial \\psi/\\partial x$ 在网格中心解析地求值来构造 $\\mathbf{B}$。\n- 测试用例 B（类似磁单极子的界面）：$N_x = 9$, $N_y = 9$, $\\Delta x = 1$, $\\Delta y = 1$。对于所有满足 $i \\ge \\lceil N_x/2 \\rceil$ 的索引，定义 $B_x(i,j) = 1$，否则 $B_x(i,j) = 0$；对所有网格单元，设置 $B_y(i,j) = 0$。这里的 $i$ 和 $j$ 是代码中从零开始的索引，但您的推导必须独立于索引约定。\n- 测试用例 C（近真空噪声）：$N_x = 7$, $N_y = 7$, $\\Delta x = 1$, $\\Delta y = 1$。将 $B_x$ 和 $B_y$ 定义为独立的、具有小振幅的场，其值由固定的伪随机种子生成，在 $[-10^{-12}, 10^{-12}]$ 区间内均匀分布的确定性伪随机值。同上，使用 $B_{\\mathrm{floor}} = 10^{-6}$。\n- 测试用例 D（带有局域微扰的强均匀场）：$N_x = 17$, $N_y = 17$, $\\Delta x = 1$, $\\Delta y = 1$。对所有网格单元，定义 $B_x(i,j) = 5$。初始时对所有网格单元定义 $B_y(i,j) = 0$，然后在 y 方向上增加一个阶跃：对于所有满足 $j \\ge \\lfloor N_y/2 \\rfloor$ 的网格单元，设置 $B_y(i,j) \\leftarrow B_y(i,j) + 1$，其余网格单元保持不变。\n\n对每个测试用例，计算并返回一个包含三个元素的列表 $[\\varepsilon_{\\max}, n_{\\mathrm{clean}}, n_{\\mathrm{ref}}]$，其中 $n_{\\mathrm{clean}}$ 是 $T_{\\mathrm{clean}}$ 为真的网格单元数，$n_{\\mathrm{ref}}$ 是 $T_{\\mathrm{ref}}$ 为真的网格单元数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个列表。例如，您应该打印形如 “[[eA,ncA,nrA],[eB,ncB,nrB],[eC,ncC,nrC],[eD,ncD,nrD]]” 的一行，不含空格，其中 $eX$ 是四舍五入到六位小数的浮点数，$ncX$、$nrX$ 是整数。", "solution": "目标是为数值磁流体动力学（MHD）中的伪磁场散度构建并测试一个计算诊断工具。这涉及在均匀笛卡尔网格上推导并实现离散算子，以量化对磁场高斯定律 $\\nabla \\cdot \\mathbf{B} = 0$ 的违反，并为散度清理或网格加密等修正措施建立标准。\n\n### 步骤 1：散度算子的离散化\n\n二维磁场 $\\mathbf{B} = (B_x, B_y)$ 的散度由以下连续介质表达式给出：\n$$ \\nabla \\cdot \\mathbf{B} = \\frac{\\partial B_x}{\\partial x} + \\frac{\\partial B_y}{\\partial y} $$\n我们的任务是在一个均匀的、以网格为中心的笛卡尔网格上离散化该算子。该网格由点 $(x_i, y_j) = (i\\Delta x, j\\Delta y)$ 定义，其中整数索引 $i \\in [0, N_x-1]$，$j \\in [0, N_y-1]$。场分量 $B_x(i, j)$ 和 $B_y(i, j)$ 在这些网格中心上是已知的。\n\n对于内部网格单元，其中 $0  i  N_x-1$ 且 $0  j  N_y-1$，我们采用二阶精度的中心有限差分格式。偏导数近似为：\n$$ \\left(\\frac{\\partial B_x}{\\partial x}\\right)_{i,j} \\approx \\frac{B_x(i+1, j) - B_x(i-1, j)}{2 \\Delta x} $$\n$$ \\left(\\frac{\\partial B_y}{\\partial y}\\right)_{i,j} \\approx \\frac{B_y(i, j+1) - B_y(i, j-1)}{2 \\Delta y} $$\n因此，内部单元 $(i,j)$ 处的离散散度为：\n$$ (\\nabla \\cdot \\mathbf{B})_{i,j} \\approx \\frac{B_x(i+1, j) - B_x(i-1, j)}{2 \\Delta x} + \\frac{B_y(i, j+1) - B_y(i, j-1)}{2 \\Delta y} $$\n\n对于区域边界上的单元，垂直于该边界的导数需要采用一阶精度的单边差分，而切向导数仍然可以使用中心差分格式。例如，在左边界上（$i=0$）但非角点（$0  j  N_y-1$）的单元，近似变为：\n$$ (\\nabla \\cdot \\mathbf{B})_{0,j} \\approx \\underbrace{\\frac{B_x(1, j) - B_x(0, j)}{\\Delta x}}_{\\text{一阶向前}} + \\underbrace{\\frac{B_y(0, j+1) - B_y(0, j-1)}{2 \\Delta y}}_{\\text{二阶中心}} $$\n在角点处，例如左下角（$i=0, j=0$），两个导数都必须用一阶向前差分来近似：\n$$ (\\nabla \\cdot \\mathbf{B})_{0,0} \\approx \\frac{B_x(1, 0) - B_x(0, 0)}{\\Delta x} + \\frac{B_y(0, 1) - B_y(0, 0)}{\\Delta y} $$\n类似地，对于上边界和右边界，使用向后差分格式。这种混合精度格式是在有界网格上离散化导数的标准方法。\n\n### 步骤 2：诊断指标和触发器\n\n根据计算出的离散散度 $(\\nabla \\cdot \\mathbf{B})_{i,j}$，我们定义几个诊断量。\n\n主要诊断量是无量纲归一化散度指标 $\\varepsilon$，定义为：\n$$ \\varepsilon_{i,j} = \\frac{h |(\\nabla \\cdot \\mathbf{B})_{i,j}|}{|\\mathbf{B}|_{i,j} + B_{\\mathrm{floor}}} $$\n这里，$h = \\min(\\Delta x, \\Delta y)$ 是一个特征网格尺寸，它使得 $\\varepsilon$ 成为一个相对于网格尺度的散度误差度量。$|\\mathbf{B}|_{i,j} = \\sqrt{B_x(i,j)^2 + B_y(i,j)^2}$ 是局部磁场的大小。通过 $|\\mathbf{B}|$ 进行归一化，使 $\\varepsilon$ 成为一个相对误差度量，这通常比绝对散度更有意义。常数 $B_{\\mathrm{floor}}$ 是一个小的正数（在本问题中为 $10^{-6}$），它对表达式进行正则化，防止在磁场极弱（近真空）的区域出现除以零或虚假的 $\\varepsilon$ 大值。\n\n基于 $\\varepsilon$ 和 $|\\nabla \\cdot \\mathbf{B}|$ 的值，我们为数值控制定义两个布尔触发器：\n\n1.  **清理触发器 ($T_{\\mathrm{clean}}$):** 该触发器表示需要进行局部散度清理操作（例如，使用双曲或椭圆清理格式）。当归一化散度超过一个中等阈值时，它被激活：\n    $$ T_{\\mathrm{clean}} \\text{ is true if } \\varepsilon > \\theta_{\\mathrm{clean}} $$\n    对于本问题，$\\theta_{\\mathrm{clean}} = 0.2$。\n\n2.  **加密触发器 ($T_{\\mathrm{ref}}$):** 该触发器标志着一个更严重的问题，表明局部网格分辨率可能不足以解析场结构，需要进行自适应网格加密（AMR）。当归一化散度非常大或绝对散度很大时，它被激活：\n    $$ T_{\\mathrm{ref}} \\text{ is true if } (\\varepsilon > \\theta_{\\mathrm{ref}}) \\lor (|\\nabla \\cdot \\mathbf{B}| > \\phi_{\\mathrm{abs}}) $$\n    对于本问题，$\\theta_{\\mathrm{ref}} = 0.6$ 且 $\\phi_{\\mathrm{abs}} = 0.8$。\n\n### 步骤 3：计算流程\n\n对于每个测试用例，总体算法流程如下：\n1.  **网格和场设置：** 定义一个大小为 $N_x \\times N_y$、间距为 $\\Delta x$ 和 $\\Delta y$ 的网格。根据具体测试用例的定义，在此网格上填充磁场分量 $B_x$ 和 $B_y$。\n2.  **散度计算：** 使用上述混合差分格式的有限差分方案，为所有网格单元计算离散散度 $(\\nabla \\cdot \\mathbf{B})_{i,j}$。\n3.  **诊断量计算：** 为所有网格单元计算场的大小 $|\\mathbf{B}|_{i,j}$ 和归一化散度 $\\varepsilon_{i,j}$。\n4.  **触发器评估：** 在每个网格单元评估 $T_{\\mathrm{clean}}$ 和 $T_{\\mathrm{ref}}$ 的布尔条件，得到两个布尔数组。\n5.  **结果聚合：** 从全网格的诊断数组中计算最终输出：\n    - 归一化散度的最大值，$\\varepsilon_{\\max} = \\max_{i,j}(\\varepsilon_{i,j})$。\n    - 需要清理的网格单元总数，$n_{\\mathrm{clean}} = \\sum_{i,j} T_{\\mathrm{clean}}(i,j)$。\n    - 需要加密的网格单元总数，$n_{\\mathrm{ref}} = \\sum_{i,j} T_{\\mathrm{ref}}(i,j)$。\n\n此流程应用于四个指定的测试用例，这些测试用例旨在探究该诊断工具对不同场构型的响应：一个光滑、解析无散的场；一个模拟磁单极子的尖锐不连续性；一个带有随机噪声的近真空区域；以及一个叠加在强均匀背景场上的场分量中的阶跃函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for MHD divergence diagnostics.\n    \"\"\"\n\n    def compute_diagnostics(Nx, Ny, Bx, By, dx, dy):\n        \"\"\"\n        Computes divergence diagnostics for a given magnetic field on a Cartesian grid.\n\n        Args:\n            Nx (int): Number of grid points in x.\n            Ny (int): Number of grid points in y.\n            Bx (np.ndarray): 2D array of the x-component of the magnetic field.\n            By (np.ndarray): 2D array of the y-component of the magnetic field.\n            dx (float): Grid spacing in x.\n            dy (float): Grid spacing in y.\n\n        Returns:\n            list: A list containing [eps_max, n_clean, n_ref].\n        \"\"\"\n        # Define given thresholds and regularization constant\n        theta_clean = 0.2\n        theta_ref = 0.6\n        phi_abs = 0.8\n        B_floor = 1e-6\n        \n        # Characteristic cell size\n        h = min(dx, dy)\n\n        # Compute partial derivatives using a second-order central difference\n        # for the interior and a first-order one-sided difference at the boundaries.\n        # numpy.gradient implements this exact scheme.\n        # We use 'ij' indexing (matrix-style), so for an array of shape (Nx, Ny),\n        # axis=0 corresponds to the first index (x) and axis=1 to the second index (y).\n        d_Bx_dx = np.gradient(Bx, dx, axis=0)\n        d_By_dy = np.gradient(By, dy, axis=1)\n\n        # Compute divergence of B\n        div_B = d_Bx_dx + d_By_dy\n\n        # Compute magnetic field magnitude\n        B_mag = np.sqrt(Bx**2 + By**2)\n\n        # Compute dimensionless normalized divergence indicator epsilon\n        epsilon = h * np.abs(div_B) / (B_mag + B_floor)\n        \n        # Calculate maximum epsilon over the grid\n        eps_max = np.max(epsilon)\n\n        # Evaluate cleaning and refinement triggers\n        T_clean = epsilon > theta_clean\n        T_ref = (epsilon > theta_ref) | (np.abs(div_B) > phi_abs)\n\n        # Count the number of cells where triggers are true\n        n_clean = np.sum(T_clean)\n        n_ref = np.sum(T_ref)\n\n        return [round(eps_max, 6), int(n_clean), int(n_ref)]\n\n    results = []\n\n    # Test Case A: Smooth, nearly divergence-free field\n    Nx_A, Ny_A = 33, 33\n    x_A = np.linspace(0, 2 * np.pi, Nx_A)\n    y_A = np.linspace(0, 2 * np.pi, Ny_A)\n    dx_A, dy_A = x_A[1] - x_A[0], y_A[1] - y_A[0]\n    xx_A, yy_A = np.meshgrid(x_A, y_A, indexing='ij')\n    kx, ky = 2, 3\n    # Bx = d(psi)/dy\n    Bx_A = ky * np.sin(kx * xx_A) * np.cos(ky * yy_A)\n    # By = -d(psi)/dx\n    By_A = -kx * np.cos(kx * xx_A) * np.sin(ky * yy_A)\n    results.append(compute_diagnostics(Nx_A, Ny_A, Bx_A, By_A, dx_A, dy_A))\n\n    # Test Case B: Monopole-like interface\n    Nx_B, Ny_B = 9, 9\n    dx_B, dy_B = 1.0, 1.0\n    Bx_B = np.zeros((Nx_B, Ny_B))\n    i_step_B = int(np.ceil(Nx_B / 2.0)) # For Nx=9, ceil(4.5)=5. 0-indexed: 5,6,7,8\n    Bx_B[i_step_B:, :] = 1.0\n    By_B = np.zeros((Nx_B, Ny_B))\n    results.append(compute_diagnostics(Nx_B, Ny_B, Bx_B, By_B, dx_B, dy_B))\n\n    # Test Case C: Near-vacuum noise\n    Nx_C, Ny_C = 7, 7\n    dx_C, dy_C = 1.0, 1.0\n    rng = np.random.default_rng(seed=0)\n    Bx_C = rng.uniform(-1e-12, 1e-12, size=(Nx_C, Ny_C))\n    By_C = rng.uniform(-1e-12, 1e-12, size=(Nx_C, Ny_C))\n    results.append(compute_diagnostics(Nx_C, Ny_C, Bx_C, By_C, dx_C, dy_C))\n\n    # Test Case D: Strong uniform field with localized perturbation\n    Nx_D, Ny_D = 17, 17\n    dx_D, dy_D = 1.0, 1.0\n    Bx_D = np.full((Nx_D, Ny_D), 5.0)\n    By_D = np.zeros((Nx_D, Ny_D))\n    j_step_D = int(np.floor(Ny_D / 2.0)) # For Ny=17, floor(8.5)=8. 0-indexed: 8,...,16\n    By_D[:, j_step_D:] += 1.0\n    results.append(compute_diagnostics(Nx_D, Ny_D, Bx_D, By_D, dx_D, dy_D))\n    \n    # Format the final output string\n    # e.g., [[1.0,2,3],[4.0,5,6]]\n    output_str = f\"[{','.join(str(r).replace(' ', '') for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3506882"}, {"introduction": "一旦识别出散度误差，就必须选择如何清理它们。本练习将直接比较两种最主要的技术：通过求解泊松方程来精确执行约束的投影方法，以及将误差视为一种需要被阻尼和传输的波的广义拉格朗日乘子（GLM）方法[@problem_id:3506842]。通过亲手实现和基准测试这两种方法，你将深入了解它们在精度、计算成本和实现复杂性之间的关键权衡，这对于为特定的科学问题选择最合适的数值方案至关重要。", "problem": "您需要实现并比较两种用于磁流体力学（MHD）中磁场散度清理的策略：一种是谱投影方法，另一种是广义拉格朗日乘子（GLM）清理方法。比较必须依据清理后的离散散度范数所衡量的精度，以及通过简单操作计数建模的计算成本来进行。所有量均为无量纲。\n\n本问题的基本依据是磁流体力学中来自 Maxwell 方程组的无散度约束，即磁场满足 $\\nabla \\cdot \\mathbf{B} = 0$。在实践中，激波主导流动的数值格式可能会违反此约束，导致非零的离散散度，必须对其进行清理。两种广泛使用的策略是：\n\n- 一种投影方法，通过求解一个势 $\\phi$ 的泊松方程并通过 $\\mathbf{B} \\leftarrow \\mathbf{B} - \\nabla \\phi$ 投影 $\\mathbf{B}$ 来强制执行该约束。\n- 一种广义拉格朗日乘子（GLM）方法，它引入一个辅助标量场 $\\psi$，并将其与 $\\nabla \\cdot \\mathbf{B}$ 进行双曲和抛物耦合，以衰减和对流散度。\n\n您必须在周期性的二维方形域 $[0,1) \\times [0,1)$ 上实现这两种方法，该域使用 $N_x \\times N_y$ 单元的均匀网格进行离散化，其中 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。比较应在一组指定的测试用例上执行。\n\n激波主导的清理前状态的场构建：\n- 通过组合一个光滑的螺线管（无散度）分量和一个受控的非螺线管分量，构建一个合成的清理前磁场 $\\mathbf{B}^*$，以模拟激波主导的情况：\n  - 设$\\psi(x,y) = A \\sin(2\\pi x)\\sin(2\\pi y)$，其中$A = 0.1$。\n  - 设$\\phi_{\\text{shock}}(x,y) = s \\tanh\\left(\\frac{x - 1/2}{w}\\right)$，其中$s$控制激波严重程度，$w$控制激波厚度。\n  - 定义\n    $$\n    B_x^*(x,y) = \\frac{\\partial \\psi}{\\partial y}(x,y) + \\frac{\\partial \\phi_{\\text{shock}}}{\\partial x}(x,y), \\quad\n    B_y^*(x,y) = -\\frac{\\partial \\psi}{\\partial x}(x,y),\n    $$\n    使得 $\\nabla \\cdot \\mathbf{B}^* = \\nabla^2 \\phi_{\\text{shock}}$ 非零且集中在激波处。在构建 $\\mathbf{B}^*$ 时出现的导数必须通过解析计算得出：\n    $$\n    \\frac{\\partial \\psi}{\\partial y} = A \\sin(2\\pi x)\\, 2\\pi \\cos(2\\pi y), \\quad\n    \\frac{\\partial \\psi}{\\partial x} = A\\, 2\\pi \\cos(2\\pi x)\\, \\sin(2\\pi y),\n    $$\n    $$\n    \\frac{\\partial \\phi_{\\text{shock}}}{\\partial x} = \\frac{s}{w} \\operatorname{sech}^2\\!\\left(\\frac{x - 1/2}{w}\\right), \\quad \\frac{\\partial \\phi_{\\text{shock}}}{\\partial y} = 0.\n    $$\n\n离散诊断：\n- 使用带有周期性环绕的二阶中心差分来定义网格场 $\\mathbf{B}$ 的离散散度：\n  $$\n  (\\nabla \\cdot \\mathbf{B})_{i,j} = \\frac{B_{x,i+1,j} - B_{x,i-1,j}}{2\\Delta x} + \\frac{B_{y,i,j+1} - B_{y,i,j-1}}{2\\Delta y}.\n  $$\n- 将离散$L^2$散度范数定义为\n  $$\n  E(\\mathbf{B}) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i,j} \\left[(\\nabla \\cdot \\mathbf{B})_{i,j}\\right]^2 }.\n  $$\n\n方法1：谱投影（泊松求解）：\n- 通过求解\n  $$\n  \\nabla^2 \\phi = \\nabla \\cdot \\mathbf{B}^*\n  $$\n  在周期性网格上计算一个标量势 $\\phi$，并对 $\\phi$ 施加零均值条件（即，将零波数处的傅里叶模式设置为零）。使用快速傅里叶变换（FFT）以谱方法实现此求解：在傅里叶空间中，对于波数 $k_x = 2\\pi n_x$ 和 $k_y = 2\\pi n_y$，求解\n  $$\n  \\widehat{\\phi}(\\mathbf{k}) = -\\frac{\\widehat{\\nabla \\cdot \\mathbf{B}^*}(\\mathbf{k})}{k_x^2 + k_y^2} \\quad \\text{for} \\quad \\mathbf{k} \\neq \\mathbf{0}, \\quad \\widehat{\\phi}(\\mathbf{0}) = 0,\n  $$\n  并通过乘以 $\\mathrm{i}\\mathbf{k}$ 和进行逆 FFT 来以谱方法获得 $\\nabla \\phi$。清理后的场是\n  $$\n  \\mathbf{B}^{\\mathrm{proj}} = \\mathbf{B}^* - \\nabla \\phi.\n  $$\n- 投影方法的成本模型：使用 FFT 操作计数。假设计算投影需要 $n_{\\mathrm{FFT}} = 4$ 次二维 FFT。每次二维 FFT 的成本建模为\n  $$\n  C_{\\mathrm{FFT}} = \\gamma \\, N_x N_y \\, \\log_2(N_x N_y),\n  $$\n  其中 $\\gamma$ 是一个正常数。因此总成本为\n  $$\n  \\text{Cost}_{\\mathrm{proj}} = n_{\\mathrm{FFT}} \\, C_{\\mathrm{FFT}}.\n  $$\n\n方法2：GLM 清理（广义拉格朗日乘子）：\n- 初始化 $\\psi = 0$。对于 $m$ 个子步，执行显式更新\n  $$\n  \\psi^{n+1} = \\psi^n - \\Delta t \\, c_h^2 \\, (\\nabla \\cdot \\mathbf{B}^n) - \\Delta t \\, \\frac{c_h^2}{c_p^2} \\, \\psi^n,\n  $$\n  $$\n  \\mathbf{B}^{n+1} = \\mathbf{B}^n - \\Delta t \\, \\nabla \\psi^{n+1},\n  $$\n  其中 $c_h$ 是双曲清理速度，$c_p$ 是抛物线阻尼参数，$\\nabla$ 通过带有周期性环绕的二阶中心差分进行离散化（与上面的散度算子一致）。将子步数设置为$m = \\lceil c_h \\rceil$，并选择子步大小\n  $$\n  \\Delta t = \\mathrm{CFL} \\cdot \\frac{\\min(\\Delta x,\\Delta y)}{\\max(c_h, 10^{-8})},\n  $$\n  其中 $\\mathrm{CFL} = 0.8$。经过 $m$ 个子步后清理的场记为 $\\mathbf{B}^{\\mathrm{glm}}$。\n- GLM 方法的成本模型：计算局部模板操作。假设每个子步的成本为\n  $$\n  C_{\\mathrm{local}} = \\beta \\, N_x N_y\n  $$\n  次操作，因此总成本为\n  $$\n  \\text{Cost}_{\\mathrm{glm}} = m \\, C_{\\mathrm{local}}.\n  $$\n\n比较指标和决策规则：\n- 定义一个绝对精度容差$\\tau = 10^{-3}$。\n- 对于每种方法，使用下面指定的 $\\gamma$ 和 $\\beta$ 和上述模型计算清理后的散度范数 $E(\\mathbf{B}^{\\mathrm{proj}})$ 和 $E(\\mathbf{B}^{\\mathrm{glm}})$，以及成本 $\\text{Cost}_{\\mathrm{proj}}$ 和 $\\text{Cost}_{\\mathrm{glm}}$。\n- 根据以下规则确定哪种方法占优：\n  - 如果恰好有一种方法达到 $E \\le \\tau$，则选择该方法。\n  - 如果两种方法都达到 $E \\le \\tau$，则选择成本较低者。\n  - 如果两种方法都未达到 $E \\le \\tau$，则选择 $E$ 较小者；如果 $E$ 在 $10^{-6}$ 的相对容差内相等，则选择成本较低者。\n- 将每个测试用例的选择编码为一个整数：\n  - 如果选择投影方法，输出 $1$。\n  - 如果选择 GLM 方法，输出 $-1$。\n  - 如果因平局导致没有严格偏好（仅适用于两种方法在相对容差内的 $E$ 相等且在成本模型下成本也相等的情况），输出 $0$。\n\n成本模型的常数：\n- 使用$\\gamma = 5.0$和$\\beta = 20.0$。\n\n测试套件：\n实现程序以精确执行以下五个测试用例，其中每个元组为 $(N_x, N_y, s, w, c_h, c_p)$：\n- 情况 1：$(128, 128, 1.0, 0.02, 1.0, 1.0)$\n- 情况 2：$(128, 128, 3.0, 0.01, 1.0, 1.0)$\n- 情况 3：$(256, 256, 1.0, 0.02, 1.0, 1.0)$\n- 情况 4：$(128, 128, 1.0, 0.02, 5.0, 1.0)$\n- 情况 5：$(64, 64, 0.5, 0.05, 0.5, 1.0)$\n\n要求的最终输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的整数列表，其顺序与测试用例相同，例如，“[$r_1, r_2, r_3, r_4, r_5$]”。不允许有其他输出。", "solution": "该问题要求在二维周期性域上，为磁流体动力学（MHD）中强制执行无散度约束 $\\nabla \\cdot \\mathbf{B} = 0$ 的两种不同数值方法进行实现和比较。待比较的方法是一种谱投影方法和一种广义拉格朗日乘子（GLM）清理方案。比较基于清理后的精度（通过离散散度范数衡量）和计算成本（通过简化的操作模型估算）。\n\n首先，我们建立计算域和初始状态。该域是一个周期性的方形域 $[0,1) \\times [0,1)$，通过一个均匀的 $N_x \\times N_y$ 单元网格进行离散化，网格间距为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。单元中心位于 $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$，其中 $i \\in \\{0, \\dots, N_x-1\\}$ 且 $j \\in \\{0, \\dots, N_y-1\\}$。\n\n初始的、清理前的磁场，记为 $\\mathbf{B}^*$，被解析地定义为同时包含一个螺线管（无散度）部分和一个非螺线管部分，以模拟来自激波的数值误差。它由一个矢量势 $\\psi(x,y) = A \\sin(2\\pi x)\\sin(2\\pi y)$ 和一个标量势 $\\phi_{\\text{shock}}(x,y) = s \\tanh\\left(\\frac{x - 1/2}{w}\\right)$ 构建，其中 $A=0.1$。其分量为：\n$$\nB_x^*(x,y) = \\frac{\\partial \\psi}{\\partial y}(x,y) + \\frac{\\partial \\phi_{\\text{shock}}}{\\partial x}(x,y) = 2\\pi A \\sin(2\\pi x) \\cos(2\\pi y) + \\frac{s}{w} \\operatorname{sech}^2\\!\\left(\\frac{x - 1/2}{w}\\right)\n$$\n$$\nB_y^*(x,y) = -\\frac{\\partial \\psi}{\\partial x}(x,y) = -2\\pi A \\cos(2\\pi x) \\sin(2\\pi y)\n$$\n该场的散度解析地为 $\\nabla \\cdot \\mathbf{B}^* = \\nabla^2\\phi_{\\text{shock}}$，这是非零的。\n\n每种清理方法的精度由清理后场的散度的离散 $L^2$ 范数来量化，定义为：\n$$\nE(\\mathbf{B}) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i,j} \\left[(\\nabla \\cdot \\mathbf{B})_{i,j}\\right]^2 }\n$$\n离散散度算子 $(\\nabla \\cdot \\mathbf{B})_{i,j}$ 使用带有周期性边界条件的二阶中心差分来近似：\n$$\n(\\nabla \\cdot \\mathbf{B})_{i,j} = \\frac{B_{x,i+1,j} - B_{x,i-1,j}}{2\\Delta x} + \\frac{B_{y,i,j+1} - B_{y,i,j-1}}{2\\Delta y}\n$$\n\n**方法1：谱投影**\n\n投影方法的原理是将初始场 $\\mathbf{B}^*$ 分解为一个无散度部分和一个标量势的梯度，即 $\\mathbf{B}^* = \\mathbf{B}^{\\mathrm{proj}} + \\nabla \\phi$。为了使清理后的场 $\\mathbf{B}^{\\mathrm{proj}}$ 无散度（即 $\\nabla \\cdot \\mathbf{B}^{\\mathrm{proj}} = 0$），势 $\\phi$ 必须满足泊松方程：\n$$\n\\nabla^2 \\phi = \\nabla \\cdot \\mathbf{B}^*\n$$\n在周期性域上，这个方程可以在傅里叶空间中高效求解。进行傅里叶变换可得：\n$$\n-(k_x^2 + k_y^2) \\widehat{\\phi}(\\mathbf{k}) = \\widehat{\\nabla \\cdot \\mathbf{B}^*}(\\mathbf{k})\n$$\n其中 $\\mathbf{k}=(k_x, k_y)$ 是波数矢量，其分量为 $k_x = 2\\pi n_x$ 和 $k_y = 2\\pi n_y$，对于整数模式数 $n_x, n_y$。势的傅里叶系数的解是：\n$$\n\\widehat{\\phi}(\\mathbf{k}) = -\\frac{\\widehat{\\nabla \\cdot \\mathbf{B}^*}(\\mathbf{k})}{k_x^2 + k_y^2} \\quad \\text{for} \\quad \\mathbf{k} \\neq \\mathbf{0}\n$$\n对于 $\\mathbf{k} = \\mathbf{0}$，分母为零。通过施加零均值条件 $\\widehat{\\phi}(\\mathbf{0}) = 0$，可以获得 $\\phi$ 的唯一解。\n\n该实现对所有导数都一致地使用谱方法。首先，计算 $B_x^*$ 和 $B_y^*$ 的傅里叶变换。然后，在傅里叶空间中通过 $\\widehat{\\nabla \\cdot \\mathbf{B}^*} = i k_x \\widehat{B_x^*} + i k_y \\widehat{B_y^*}$ 计算散度。在求解出 $\\widehat{\\phi}$ 后，梯度 $\\nabla \\phi$ 也以谱方法找到：$\\widehat{\\nabla\\phi} = i\\mathbf{k}\\widehat{\\phi}$。然后通过傅里叶逆变换恢复 $\\nabla\\phi$ 的分量。清理后的场是 $\\mathbf{B}^{\\mathrm{proj}} = \\mathbf{B}^* - \\nabla\\phi$。整个过程需要对 $\\mathbf{B}^*$ 进行两次正向快速傅里叶变换（FFT），对 $\\nabla\\phi$ 进行两次逆向 FFT，这证实了给定参数 $n_{\\mathrm{FFT}} = 4$。计算成本建模为：\n$$\n\\text{Cost}_{\\mathrm{proj}} = n_{\\mathrm{FFT}} \\, \\gamma \\, N_x N_y \\, \\log_2(N_x N_y)\n$$\n其中 $\\gamma = 5.0$。\n\n**方法2：广义拉格朗日乘子（GLM）**\n\nGLM 方法引入一个辅助标量场 $\\psi$，它与磁场耦合。该方程组旨在以速度 $c_h$ 将散度误差输运出计算域，并同时在一个与参数 $c_p$ 相关的时间尺度上对其进行衰减。单次清理扫描的迭代更新方案由下式给出：\n$$\n\\psi^{n+1} = \\psi^n - \\Delta t \\, c_h^2 \\, (\\nabla \\cdot \\mathbf{B}^n) - \\Delta t \\, \\frac{c_h^2}{c_p^2} \\, \\psi^n\n$$\n$$\n\\mathbf{B}^{n+1} = \\mathbf{B}^n - \\Delta t \\, \\nabla \\psi^{n+1}\n$$\n从 $\\psi^0 = 0$ 和 $\\mathbf{B}^0 = \\mathbf{B}^*$ 开始，该方案总共应用 $m = \\lceil c_h \\rceil$ 个子步。时间步长 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 条件确定：\n$$\n\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\min(\\Delta x,\\Delta y)}{\\max(c_h, 10^{-8})}\n$$\n其中 $\\mathrm{CFL} = 0.8$。离散梯度 $\\nabla$ 和散度 $\\nabla \\cdot$ 算子使用二阶中心差分实现，与诊断计算一致。基于局部模板操作的成本建模为：\n$$\n\\text{Cost}_{\\mathrm{glm}} = m \\, \\beta \\, N_x N_y\n$$\n其中 $\\beta = 20.0$。\n\n**比较和决策**\n\n对于每个测试用例，执行两种方法以获得清理后的场 $\\mathbf{B}^{\\mathrm{proj}}$ 和 $\\mathbf{B}^{\\mathrm{glm}}$、它们各自的散度范数 $E(\\mathbf{B}^{\\mathrm{proj}})$ 和 $E(\\mathbf{B}^{\\mathrm{glm}})$，以及它们的成本 $\\text{Cost}_{\\mathrm{proj}}$ 和 $\\text{Cost}_{\\mathrm{glm}}$。根据一个预定义的规则集做出决策，该规则集涉及一个精度容差 $\\tau = 10^{-3}$：\n1.  如果一种方法是精确的（$E \\le \\tau$）而另一种不是，则选择精确的方法。\n2.  如果两种方法都精确，则选择成本较低的方法。\n3.  如果两种方法都不精确，则选择散度范数 $E$ 较低的方法。如果 $E$ 相等（在 $10^{-6}$ 的相对容差内），则通过选择成本较低的方法来打破平局。\n\n最终的选择被编码为：投影方法为 $1$，GLM 方法为 $-1$，如果在精度（在容差范围内）和成本上完全打平则为 $0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares spectral projection and GLM divergence cleaning methods for MHD.\n    \"\"\"\n\n    # --- Problem Constants ---\n    A = 0.1\n    GAMMA = 5.0\n    BETA = 20.0\n    CFL = 0.8\n    TAU = 1e-3\n    REL_TOL_E = 1e-6\n\n    # --- Test Suite ---\n    test_cases = [\n        # (Nx, Ny, s, w, ch, cp)\n        (128, 128, 1.0, 0.02, 1.0, 1.0),\n        (128, 128, 3.0, 0.01, 1.0, 1.0),\n        (256, 256, 1.0, 0.02, 1.0, 1.0),\n        (128, 128, 1.0, 0.02, 5.0, 1.0),\n        (64, 64, 0.5, 0.05, 0.5, 1.0),\n    ]\n\n    def calculate_divergence(Bx, By, dx, dy):\n        \"\"\"Computes discrete divergence using 2nd-order central differences.\"\"\"\n        d_Bx_dx = (np.roll(Bx, -1, axis=1) - np.roll(Bx, 1, axis=1)) / (2 * dx)\n        d_By_dy = (np.roll(By, -1, axis=0) - np.roll(By, 1, axis=0)) / (2 * dy)\n        return d_Bx_dx + d_By_dy\n\n    def calculate_gradient(phi, dx, dy):\n        \"\"\"Computes discrete gradient using 2nd-order central differences.\"\"\"\n        d_phi_dx = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * dx)\n        d_phi_dy = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * dy)\n        return d_phi_dx, d_phi_dy\n\n    def run_projection_method(B_star_x, B_star_y, Nx, Ny, dx, dy):\n        \"\"\"Implements the spectral projection method.\"\"\"\n        # Wavenumbers (for a grid from 0 to L=1)\n        kx_grid = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n        ky_grid = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n        kx_grid, ky_grid = np.meshgrid(kx_grid, ky_grid)\n        k_squared = kx_grid**2 + ky_grid**2\n\n        # FFT of initial field\n        B_hat_x = np.fft.fft2(B_star_x)\n        B_hat_y = np.fft.fft2(B_star_y)\n\n        # Spectral divergence\n        div_B_hat = 1j * kx_grid * B_hat_x + 1j * ky_grid * B_hat_y\n\n        # Solve for phi in Fourier space\n        phi_hat = np.zeros_like(div_B_hat)\n        non_zero_k = k_squared != 0\n        phi_hat[non_zero_k] = -div_B_hat[non_zero_k] / k_squared[non_zero_k]\n\n        # Spectral gradient of phi\n        grad_phi_x_hat = 1j * kx_grid * phi_hat\n        grad_phi_y_hat = 1j * ky_grid * phi_hat\n\n        # Inverse FFT to get gradient in real space\n        grad_phi_x = np.fft.ifft2(grad_phi_x_hat).real\n        grad_phi_y = np.fft.ifft2(grad_phi_y_hat).real\n\n        # Cleaned field\n        B_proj_x = B_star_x - grad_phi_x\n        B_proj_y = B_star_y - grad_phi_y\n\n        # Diagnostics\n        div_proj = calculate_divergence(B_proj_x, B_proj_y, dx, dy)\n        E_proj = np.sqrt(np.mean(div_proj**2))\n        cost_proj = 4 * GAMMA * Nx * Ny * np.log2(Nx * Ny)\n        \n        return E_proj, cost_proj\n\n    def run_glm_method(B_star_x, B_star_y, Nx, Ny, dx, dy, ch, cp):\n        \"\"\"Implements the GLM cleaning method.\"\"\"\n        # Parameters\n        m = int(np.ceil(ch))\n        dt = CFL * min(dx, dy) / max(ch, 1e-8)\n\n        # Initialization\n        psi = np.zeros((Ny, Nx))\n        Bx = B_star_x.copy()\n        By = B_star_y.copy()\n\n        # Iterative cleaning\n        for _ in range(m):\n            div_B = calculate_divergence(Bx, By, dx, dy)\n            psi_new = psi - dt * ch**2 * div_B - dt * (ch**2 / cp**2) * psi\n            grad_psi_x, grad_psi_y = calculate_gradient(psi_new, dx, dy)\n            Bx_new = Bx - dt * grad_psi_x\n            By_new = By - dt * grad_psi_y\n            \n            psi, Bx, By = psi_new, Bx_new, By_new\n        \n        # Diagnostics\n        B_glm_x, B_glm_y = Bx, By\n        div_glm = calculate_divergence(B_glm_x, B_glm_y, dx, dy)\n        E_glm = np.sqrt(np.mean(div_glm**2))\n        cost_glm = m * BETA * Nx * Ny\n\n        return E_glm, cost_glm\n        \n    results = []\n    for case in test_cases:\n        Nx, Ny, s, w, ch, cp = case\n        \n        # Grid setup\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        x = (np.arange(Nx) + 0.5) * dx\n        y = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(x, y, indexing='ij')\n        \n        xx_T, yy_T = xx.T, yy.T # Transpose for correct broadcasting with shape (Ny, Nx)\n\n        # Initial field construction\n        B_star_x = (A * 2 * np.pi * np.sin(2 * np.pi * xx_T) * np.cos(2 * np.pi * yy_T) + \n                    (s / w) / (np.cosh((xx_T - 0.5) / w)**2))\n        B_star_y = -A * 2 * np.pi * np.cos(2 * np.pi * xx_T) * np.sin(2 * np.pi * yy_T)\n        \n        # Run methods\n        E_proj, cost_proj = run_projection_method(B_star_x, B_star_y, Nx, Ny, dx, dy)\n        E_glm, cost_glm = run_glm_method(B_star_x, B_star_y, Nx, Ny, dx, dy, ch, cp)\n\n        # Comparison logic\n        proj_ok = E_proj = TAU\n        glm_ok = E_glm = TAU\n        \n        result = 0\n        if proj_ok and not glm_ok:\n            result = 1\n        elif not proj_ok and glm_ok:\n            result = -1\n        elif proj_ok and glm_ok:\n            if cost_proj  cost_glm:\n                result = 1\n            elif cost_glm  cost_proj:\n                result = -1\n            else:\n                result = 0\n        else: # Neither is OK\n            if np.isclose(E_proj, E_glm, rtol=REL_TOL_E):\n                if cost_proj  cost_glm:\n                    result = 1\n                elif cost_glm  cost_proj:\n                    result = -1\n                else: \n                    result = 0\n            elif E_proj  E_glm:\n                result = 1\n            else:\n                result = -1\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3506842"}, {"introduction": "在真实的天体物理学模拟中，为了高效地解析特定结构（如激波或薄盘），计算网格通常是拉伸的或“各向异性”的。这项练习探讨了一个更高级的主题：标准的GLM清理方案的性能在此类网格上可能如何下降，以及如何设计一种更智能的、能适应局部网格几何形状的各向异性阻尼模型[@problem_id:3506840]。这项实践将带领你从方法的标准应用走向数值方案的优化，这是进行前沿计算研究的一项关键技能。", "problem": "考虑用于磁流体动力学 (MHD) 的广义拉格朗日乘子 (GLM) 散度清理，该方法通过一个辅助标量场来增强感应方程，以输运和耗散散度误差。假设在二维空间中采用常系数的双曲-抛物线清理形式，由以下线性化方程组给出：\n$$\n\\frac{\\partial \\mathbf{B}}{\\partial t} + \\nabla \\times \\mathbf{E} + \\nabla \\psi = \\mathbf{0}, \\quad\n\\frac{\\partial \\psi}{\\partial t} + c_h^2 \\nabla \\cdot \\mathbf{B} = - c_p \\, \\psi,\n$$\n其中 $\\mathbf{B}$ 是磁场，$\\psi$ 是清理场，$c_h$ 是清理波速，$c_p$ 是一个耗散率。所有量均为无量纲。角度必须以弧度表示。\n\n仅从上述方程和在具有间距 $\\Delta x$ 和 $\\Delta y$ 的均匀但各向异性的网格上进行二阶中心差分的标准离散傅里叶分析出发，完成以下任务：\n\n1) 推导离散散度$D = \\nabla \\cdot \\mathbf{B}$的傅里叶模式振幅的演化方程，其形式为针对单个波矢 $\\mathbf{k} = (k_x, k_y)$ 的阻尼线性振子，其中半离散的离散拉普拉斯算子通过有效波数引入：\n$$\nk_{x,\\mathrm{eff}} = \\frac{2}{\\Delta x} \\sin\\!\\left(\\frac{k_x \\Delta x}{2}\\right), \\quad\nk_{y,\\mathrm{eff}} = \\frac{2}{\\Delta y} \\sin\\!\\left(\\frac{k_y \\Delta y}{2}\\right).\n$$\n证明$D$的模式振幅$A(t)$在常系数下满足一个常微分方程，形式为$A''(t) + c_p \\, A'(t) + \\omega_0^2 \\, A(t) = 0$，其中$\\omega_0^2 = c_h^2 \\left(k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2\\right)$，并采用初始条件$A(0) = 1$和$A'(0) = 0$。\n\n2) 提出了一个依赖于局部磁场方向和网格各向异性的各向异性耗散模型。设$\\theta$为磁场与$x$轴之间的夹角，并设$r = \\Delta x / \\Delta y$为网格各向异性比。将各向异性耗散率 $c_p(\\theta)$ 定义为\n$$\nc_p(\\theta) = c_{p0} \\, \\frac{\\sqrt{(\\Delta x \\cos\\theta)^2 + (\\Delta y \\sin\\theta)^2}}{\\sqrt{\\Delta x \\, \\Delta y}} = c_{p0} \\sqrt{ r \\cos^2\\theta + \\frac{1}{r} \\sin^2\\theta },\n$$\n其中 $c_{p0}$ 是一个基准各向同性耗散率。请根据由拉伸网格所感生的方向度量以及希望沿有效间距较大方向加强耗散的愿望，来证明此选择的合理性。\n\n3) 对于与磁场对齐、大小为 $k_0$ 的单个傅里叶模式，即$k_x = k_0 \\cos\\theta$和$k_y = k_0 \\sin\\theta$，使用第 1 部分中的常微分方程，计算在时间 $t = T$ 时的精确闭式解振幅 $A(t)$，分别针对各向同性情况（$c_p = c_{p0}$）和各向异性情况（$c_p = c_p(\\theta)$）。\n\n4) 将散度控制的性能指标定义为比率\n$$\nR = \\frac{A_{\\mathrm{aniso}}(T)}{A_{\\mathrm{iso}}(T)},\n$$\n其中$A_{\\mathrm{aniso}}(T)$和$A_{\\mathrm{iso}}(T)$分别为各向异性和各向同性耗散选择下在时间 $T$ 时的振幅。$R  1$的值表示在所选参数下，各向异性模型改善了控制效果。\n\n您的任务是编写一个完整的程序，对于下述测试套件中的每个测试用例，使用在初始条件$A(0) = 1$和$A'(0) = 0$下的$A(t)$的精确闭式解来计算 $R$，并适当考虑由$c_p^2 - 4 \\omega_0^2$的符号决定的阻尼振子的三种状态（欠阻尼、临界阻尼、过阻尼）。\n\n使用以下测试套件，其中每个测试用例是一个元组 $(\\Delta x, \\Delta y, \\theta, k_0, c_h, c_{p0}, T)$:\n\n- 用例 $1$（理想情况，各向同性网格，所以 $R=1$）：$(\\Delta x, \\Delta y, \\theta, k_0, c_h, c_{p0}, T) = (1.0, 1.0, 0.7, 1.2, 1.0, 1.0, 1.0)$。\n- 用例 $2$（在 $x$ 方向拉伸，场与拉伸方向对齐）：$(4.0, 1.0, 0.0, 1.0, 1.0, 0.5, 2.0)$。\n- 用例 $3$（在 $x$ 方向拉伸，场与拉伸方向垂直）：$(4.0, 1.0, \\pi/2, 1.0, 1.0, 0.5, 2.0)$。\n- 用例 $4$（强拉伸，小角度）：$(10.0, 1.0, 0.1, 2.2, 1.0, 0.7, 3.0)$。\n- 用例 $5$（零波数边界情况，平均模式不衰减）：$(2.0, 1.0, 0.3, 0.0, 1.0, 0.9, 1.5)$。\n- 用例 $6$（各向同性选择接近临界阻尼）：$(1.0, 0.5, 0.0, 2.6, 1.0, 3.8, 0.7)$。\n\n您的程序必须：\n\n- 在每种状态下，使用初始条件$A(0) = 1$和$A'(0) = 0$实现$A(T)$的精确闭式解。\n- 使用如上所述的离散有效波数 $k_{x,\\mathrm{eff}}$ 和 $k_{y,\\mathrm{eff}}$。\n- 计算并输出一个单行，其中包含一个列表，按给定顺序包含所有测试用例的 $R$ 值，四舍五入到六位小数，格式为逗号分隔的列表并用方括号括起来（例如，$[0.123456,0.234567,\\dots]$）。\n\n所有量均为无量纲，角度以弧度为单位。不应读取外部输入；测试套件如上所述固定并嵌入在您的程序中。输出必须严格为所描述的单行内容，不含任何额外文本。", "solution": "此问题是有效的。这是一个计算天体物理学中的适定问题，其基础是偏微分方程（特别是磁流体动力学(MHD)）数值方法的标准数学框架。所有必要的方程、参数和初始条件都已提供，并且没有内部矛盾、科学谬误或含糊之处。\n\n下文中，我们推导所要求的结果并构建计算算法。\n\n### 第 1 部分：散度的阻尼振子方程推导\n\n给定线性的、二维的、常系数的广义拉格朗日乘子 (GLM) 方程：\n$$ \\frac{\\partial \\mathbf{B}}{\\partial t} + \\nabla \\times \\mathbf{E} + \\nabla \\psi = \\mathbf{0} \\quad (1) $$\n$$ \\frac{\\partial \\psi}{\\partial t} + c_h^2 \\nabla \\cdot \\mathbf{B} = - c_p \\, \\psi \\quad (2) $$\n\n我们的目标是推导磁场散度 $D = \\nabla \\cdot \\mathbf{B}$ 的演化方程。我们首先对方程 $(1)$ 取散度：\n$$ \\nabla \\cdot \\left( \\frac{\\partial \\mathbf{B}}{\\partial t} \\right) + \\nabla \\cdot (\\nabla \\times \\mathbf{E}) + \\nabla \\cdot (\\nabla \\psi) = 0 $$\n假设有足够的光滑性，我们可以交换空间和时间导数，$\\nabla \\cdot (\\frac{\\partial \\mathbf{B}}{\\partial t}) = \\frac{\\partial}{\\partial t}(\\nabla \\cdot \\mathbf{B})$。旋度的散度恒为零，$\\nabla \\cdot (\\nabla \\times \\mathbf{E}) \\equiv 0$。梯度的散度是拉普拉斯算子，$\\nabla \\cdot (\\nabla \\psi) = \\nabla^2 \\psi$。因此，方程简化为：\n$$ \\frac{\\partial D}{\\partial t} + \\nabla^2 \\psi = 0 \\quad (3) $$\n该方程表明，清理场 $\\psi$ 的非零散度是磁场散度变化的源。\n\n为了得到 $D$ 的二阶方程，我们对等式 $(3)$ 对时间求导：\n$$ \\frac{\\partial^2 D}{\\partial t^2} + \\frac{\\partial}{\\partial t}(\\nabla^2 \\psi) = 0 $$\n再次假设光滑性，我们交换导数：\n$$ \\frac{\\partial^2 D}{\\partial t^2} + \\nabla^2 \\left(\\frac{\\partial \\psi}{\\partial t}\\right) = 0 \\quad (4) $$\n现在，我们将方程 $(2)$ 中 $\\frac{\\partial \\psi}{\\partial t}$ 的表达式代入方程 $(4)$：\n$$ \\frac{\\partial^2 D}{\\partial t^2} + \\nabla^2 (-c_h^2 \\nabla \\cdot \\mathbf{B} - c_p \\psi) = 0 $$\n代入 $D = \\nabla \\cdot \\mathbf{B}$ 并分配拉普拉斯算子（因为 $c_h$ 和 $c_p$ 是常数）：\n$$ \\frac{\\partial^2 D}{\\partial t^2} - c_h^2 \\nabla^2 D - c_p \\nabla^2 \\psi = 0 \\quad (5) $$\n最后，我们使用方程 $(3)$ 将 $\\nabla^2 \\psi$ 替换为 $-\\frac{\\partial D}{\\partial t}$。将此代入方程 $(5)$ 得到：\n$$ \\frac{\\partial^2 D}{\\partial t^2} - c_h^2 \\nabla^2 D - c_p \\left(-\\frac{\\partial D}{\\partial t}\\right) = 0 $$\n整理后得到散度 $D$ 的阻尼波动方程：\n$$ \\frac{\\partial^2 D}{\\partial t^2} + c_p \\frac{\\partial D}{\\partial t} - c_h^2 \\nabla^2 D = 0 $$\n\n为了找到单个傅里叶模式的方程，我们考虑形式为 $D(\\mathbf{x}, t) = A(t) e^{i \\mathbf{k} \\cdot \\mathbf{x}}$ 的解，其中 $\\mathbf{k} = (k_x, k_y)$ 是波矢，$A(t)$ 是模式随时间变化的振幅。对于连续系统，拉普拉斯算子 $\\nabla^2$ 作用于此模式相当于乘以 $-k^2 = -(k_x^2 + k_y^2)$。\n\n对于使用二阶中心差分在间距为 $(\\Delta x, \\Delta y)$ 的网格上的半离散系统，拉普拉斯算子对模式 $e^{i(k_x x + k_y y)}$ 的作用被修正。二阶偏导数 $\\frac{\\partial^2}{\\partial x^2}$ 由中心差分算子 $\\delta_x^2 f(x) = \\frac{f(x+\\Delta x) - 2f(x) + f(x-\\Delta x)}{(\\Delta x)^2}$ 近似。其作用于 $e^{i k_x x}$ 产生一个乘法因子：\n$$ \\frac{e^{i k_x(x+\\Delta x)} - 2e^{i k_x x} + e^{i k_x(x-\\Delta x)}}{(\\Delta x)^2} = \\frac{e^{i k_x x}(e^{i k_x \\Delta x} - 2 + e^{-i k_x \\Delta x})}{(\\Delta x)^2} = \\frac{e^{i k_x x}(2\\cos(k_x \\Delta x) - 2)}{(\\Delta x)^2} $$\n使用半角恒等式 $1 - \\cos(\\alpha) = 2\\sin^2(\\alpha/2)$，这变为：\n$$ \\frac{e^{i k_x x}(-4\\sin^2(k_x \\Delta x/2))}{(\\Delta x)^2} = - \\left( \\frac{2}{\\Delta x} \\sin\\left(\\frac{k_x \\Delta x}{2}\\right) \\right)^2 e^{i k_x x} = -k_{x,\\mathrm{eff}}^2 e^{i k_x x} $$\n因此，离散拉普拉斯算子 $\\nabla_d^2 = \\delta_x^2 + \\delta_y^2$ 作用于模式 $A(t) e^{i \\mathbf{k} \\cdot \\mathbf{x}}$ 时，会将其乘以 $-(k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2)$。\n\n将此代入 $D$ 的波动方程，得到振幅 $A(t)$ 的常微分方程：\n$$ A''(t) + c_p A'(t) + c_h^2 (k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2) A(t) = 0 $$\n这正是所要求的形式 $A''(t) + c_p A'(t) + \\omega_0^2 A(t) = 0$，其固有频率的平方由 $\\omega_0^2 = c_h^2 (k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2)$ 给出。\n\n### 第 2 部分：各向异性耗散模型的合理性证明\n\n所提出的各向异性耗散率为：\n$$ c_p(\\theta) = c_{p0} \\sqrt{ r \\cos^2\\theta + \\frac{1}{r} \\sin^2\\theta } $$\n其中 $r = \\Delta x / \\Delta y$ 是网格各向异性比，$\\theta$ 是磁场相对于 $x$ 轴的角度。\n\n该模型的原理是使耗散强度适应于沿磁场方向（以及因此的散度波传播方向）的局部网格分辨率。平方根下的项 $M(\\theta, r) = r \\cos^2\\theta + \\frac{1}{r} \\sin^2\\theta$ 可以重写为：\n$$ M(\\theta, r) = \\frac{\\Delta x}{\\Delta y} \\cos^2\\theta + \\frac{\\Delta y}{\\Delta x} \\sin^2\\theta = \\frac{(\\Delta x \\cos\\theta)^2 + (\\Delta y \\sin\\theta)^2}{\\Delta x \\Delta y} $$\n分子代表了一个经单元尺寸缩放的、指向 $\\theta$ 方向的矢量的长度平方。这个量可以作为该方向有效网格间距的度量。耗散率 $c_p(\\theta)$ 与该有效间距度量的平方根成正比。\n\n考虑在坐标轴上的行为：\n- 沿 $x$ 轴 ($\\theta = 0$): $c_p(0) = c_{p0} \\sqrt{r} = c_{p0} \\sqrt{\\Delta x / \\Delta y}$。\n- 沿 $y$ 轴 ($\\theta = \\pi/2$): $c_p(\\pi/2) = c_{p0} \\sqrt{1/r} = c_{p0} \\sqrt{\\Delta y / \\Delta x}$。\n如果网格在 $x$ 方向被拉伸（$\\Delta x > \\Delta y$，因此 $r > 1$），那么 $c_p(0) > c_{p0}$ 且 $c_p(\\pi/2)  c_{p0}$。这意味着在分辨率较粗的方向（$\\Delta x$）上耗散得到加强，而在分辨率较细的方向（$\\Delta y$）上耗散被减弱。这种启发式方法是合理的：数值误差在单元尺寸较大的方向上通常更显著或传播方式不同，因此在这些方向上增加耗散可以提高散度清理方案的稳定性和准确性。\n\n对于各向同性网格（$r=1$），$c_p(\\theta) = c_{p0} \\sqrt{\\cos^2\\theta+\\sin^2\\theta} = c_{p0}$，恢复到各向同性情况，符合要求。\n\n### 第 3 部分：振幅 $A(t)$ 的闭式解\n\n我们必须求解常微分方程 $A''(t) + c_p A'(t) + \\omega_0^2 A(t) = 0$，其初始条件为 $A(0)=1$ 和 $A'(0)=0$。特征方程是 $\\lambda^2 + c_p\\lambda + \\omega_0^2 = 0$，其根为 $\\lambda_{1,2} = \\frac{-c_p \\pm \\sqrt{c_p^2 - 4\\omega_0^2}}{2}$。解的形式取决于判别式 $\\Delta = c_p^2 - 4\\omega_0^2$ 的符号。\n\n1.  **过阻尼情况 ($\\Delta > 0$):**\n    通解为 $A(t) = e^{-c_p t/2} (C_1 e^{\\Omega_d t} + C_2 e^{-\\Omega_d t})$，其中 $\\Omega_d = \\frac{\\sqrt{\\Delta}}{2}$。应用初始条件 $A(0)=1$ 和 $A'(0)=0$ 可得系数，从而得到特解：\n    $$ A(t) = e^{-c_p t/2} \\left[ \\cosh(\\Omega_d t) + \\frac{c_p}{2\\Omega_d} \\sinh(\\Omega_d t) \\right] $$\n\n2.  **临界阻尼情况 ($\\Delta = 0$):**\n    特征方程有一个重根 $\\lambda = -c_p/2$。通解为 $A(t) = (C_1 + C_2 t)e^{-c_p t/2}$。应用初始条件得到：\n    $$ A(t) = \\left(1 + \\frac{c_p}{2} t\\right) e^{-c_p t/2} $$\n\n3.  **欠阻尼情况 ($\\Delta  0$):**\n    根是复共轭的，$\\lambda_{1,2} = -c_p/2 \\pm i\\omega_d$，其中 $\\omega_d = \\frac{\\sqrt{-\\Delta}}{2}$。通解为 $A(t) = e^{-c_p t/2} (C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t))$。应用初始条件得到：\n    $$ A(t) = e^{-c_p t/2} \\left[ \\cos(\\omega_d t) + \\frac{c_p}{2\\omega_d} \\sin(\\omega_d t) \\right] $$\n\n一个重要的边界情况是 $k_0 = 0$，这意味着 $k_{x,\\mathrm{eff}} = k_{y,\\mathrm{eff}} = 0$，因此 $\\omega_0^2 = 0$。常微分方程变为 $A''(t) + c_p A'(t) = 0$。给定 $A'(0)=0$，解为 $A'(t)=0$ 对所有 $t$ 成立，这意味着 $A(t)$ 是常数。由于 $A(0)=1$，我们有 $A(t)=1$。我们推导的公式能正确处理这种情况：如果 $\\omega_0^2=0$，则 $\\Delta = c_p^2 \\ge 0$。对于 $c_p>0$，这是过阻尼情况，$\\Omega_d = c_p/2$，公式简化为 $A(t)=1$。对于 $c_p=0$，这是临界阻尼情况，同样得到 $A(t)=1$。\n\n### 第 4 部分：算法实现\n\n任务简化为实现这些闭式解并为每个测试用例计算比率 $R = A_{\\mathrm{aniso}}(T) / A_{\\mathrm{iso}}(T)$。\n\n算法如下：\n对于每个测试用例元组 $(\\Delta x, \\Delta y, \\theta, k_0, c_h, c_{p0}, T)$:\n1.  计算辅助参数：网格比 $r = \\Delta x / \\Delta y$，以及波矢分量 $k_x = k_0 \\cos\\theta$ 和 $k_y = k_0 \\sin\\theta$。\n2.  计算有效波数：\n    $$ k_{x,\\mathrm{eff}} = \\frac{2}{\\Delta x} \\sin\\left(\\frac{k_x \\Delta x}{2}\\right), \\quad k_{y,\\mathrm{eff}} = \\frac{2}{\\Delta y} \\sin\\left(\\frac{k_y \\Delta y}{2}\\right) $$\n3.  计算两种场景共有的固有频率平方：$\\omega_0^2 = c_h^2(k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2)$。\n4.  定义一个函数 `compute_amplitude(T, c_p, omega_0_sq)`，它接受时间 $T$、耗散率 $c_p$ 和频率平方 $\\omega_0^2$，并返回 $A(T)$。该函数将：\n    a. 计算判别式 $\\Delta = c_p^2 - 4\\omega_0^2$。\n    b. 使用一个小容差来检查 $\\Delta$ 是正、负还是零。\n    c. 应用适当的公式（过阻尼、临界阻尼或欠阻尼）计算 $A(T)$。\n5.  **各向同性情况**：\n    a. 设置 $c_p = c_{p0}$。\n    b. 调用 `compute_amplitude` 得到 $A_{\\mathrm{iso}}(T)$。\n6.  **各向异性情况**：\n    a. 计算 $c_p(\\theta) = c_{p0} \\sqrt{r \\cos^2\\theta + (1/r) \\sin^2\\theta}$。\n    b. 调用 `compute_amplitude` 得到 $A_{\\mathrm{aniso}}(T)$。\n7.  计算性能比 $R = A_{\\mathrm{aniso}}(T) / A_{\\mathrm{iso}}(T)$。如果 $A_{\\mathrm{iso}}(T)$ 碰巧为零，则该比率按标准浮点除法规则处理。\n8.  存储 $R$ 的四舍五入值。\n处理完所有用例后，按指定格式打印结果。\n\n此过程构成了所提供 Python 程序的基础。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the divergence control performance metric R for a set of test cases\n    based on the GLM-MHD divergence cleaning equations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (dx, dy, theta, k0, ch, cp0, T)\n    test_cases = [\n        (1.0, 1.0, 0.7, 1.2, 1.0, 1.0, 1.0),\n        (4.0, 1.0, 0.0, 1.0, 1.0, 0.5, 2.0),\n        (4.0, 1.0, np.pi/2, 1.0, 1.0, 0.5, 2.0),\n        (10.0, 1.0, 0.1, 2.2, 1.0, 0.7, 3.0),\n        (2.0, 1.0, 0.3, 0.0, 1.0, 0.9, 1.5),\n        (1.0, 0.5, 0.0, 2.6, 1.0, 3.8, 0.7),\n    ]\n\n    results = []\n    \n    # A small tolerance for floating point comparisons to handle the\n    # critically damped case robustly.\n    TOLERANCE = 1e-12\n\n    def calculate_A(T, c_p, omega_0_sq):\n        \"\"\"\n        Calculates the amplitude A(T) of the divergence mode for a given time T,\n        damping coefficient c_p, and natural frequency squared omega_0_sq.\n        \n        The function handles the three regimes of a damped linear oscillator:\n        underdamped, critically damped, and overdamped.\n        \n        Args:\n            T (float): The time at which to evaluate the amplitude.\n            c_p (float): The damping coefficient.\n            omega_0_sq (float): The square of the natural frequency.\n            \n        Returns:\n            float: The amplitude A at time T.\n        \"\"\"\n        # If omega_0_sq is basically zero (k=0 mode), the amplitude does not decay.\n        if abs(omega_0_sq)  TOLERANCE:\n            return 1.0\n            \n        discriminant = c_p**2 - 4 * omega_0_sq\n\n        if discriminant > TOLERANCE:  # Overdamped case\n            Omega_d = 0.5 * np.sqrt(discriminant)\n            term1 = np.cosh(Omega_d * T)\n            term2 = (0.5 * c_p / Omega_d) * np.sinh(Omega_d * T)\n            amplitude = np.exp(-0.5 * c_p * T) * (term1 + term2)\n        elif discriminant  -TOLERANCE:  # Underdamped case\n            omega_d = 0.5 * np.sqrt(-discriminant)\n            term1 = np.cos(omega_d * T)\n            term2 = (0.5 * c_p / omega_d) * np.sin(omega_d * T)\n            amplitude = np.exp(-0.5 * c_p * T) * (term1 + term2)\n        else:  # Critically damped case\n            amplitude = (1 + 0.5 * c_p * T) * np.exp(-0.5 * c_p * T)\n            \n        return amplitude\n\n    for case in test_cases:\n        dx, dy, theta, k0, ch, cp0, T = case\n\n        # Calculate grid ratio and wavevector components\n        r = dx / dy\n        kx = k0 * np.cos(theta)\n        ky = k0 * np.sin(theta)\n\n        # Calculate effective wavenumbers, handling k=0 case to avoid sin(0)/0\n        k_x_eff = (2.0 / dx) * np.sin(kx * dx / 2.0)\n        k_y_eff = (2.0 / dy) * np.sin(ky * dy / 2.0)\n        \n        if k0 == 0.0:\n            k_x_eff = 0.0\n            k_y_eff = 0.0\n        \n        # Calculate natural frequency squared\n        omega_0_sq = ch**2 * (k_x_eff**2 + k_y_eff**2)\n        \n        # --- Isotropic case ---\n        c_p_iso = cp0\n        A_iso = calculate_A(T, c_p_iso, omega_0_sq)\n\n        # --- Anisotropic case ---\n        c_p_aniso = cp0 * np.sqrt(r * np.cos(theta)**2 + (1.0/r) * np.sin(theta)**2)\n        A_aniso = calculate_A(T, c_p_aniso, omega_0_sq)\n        \n        # --- Performance Metric R ---\n        if abs(A_iso)  TOLERANCE:\n            if abs(A_aniso)  TOLERANCE:\n                R = 1.0\n            else:\n                R = np.inf\n        else:\n            R = A_aniso / A_iso\n        \n        results.append(R)\n\n    # Format output as specified, rounding to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3506840"}]}