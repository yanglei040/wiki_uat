{"hands_on_practices": [{"introduction": "在宇宙学中，宇宙膨胀对粒子运动最基本的影响是“哈勃拖拽”效应，它会导致粒子的奇特动量随时间衰减。本练习将通过数值方法来模拟这一动量衰减过程。通过将简单的数值积分方案（如欧拉法）与更复杂的方案（如四阶龙格-库塔法）以及精确解析解进行比较，您将对宇宙学背景下数值计算的精度和稳定性建立起基本认识 [@problem_id:3506150]。", "problem": "实现一个完整、可运行的程序，用于对在共形时间下演化的粒子，在其共动坐标系中的自由流本动量进行积分。从以下基本原理出发：在一个膨胀的、空间平坦的 Friedmann–Robertson–Walker 背景中，自由流本动量满足一阶常微分方程 (ODE) $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$，其中 $\\tau$ 是共形时间，$u(\\tau)$ 是共动本动量，$\\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau)$ 是共形哈勃参数，$a(\\tau)$ 是标度因子。您必须推导由该 ODE 的解析解所蕴含的一个精确离散时间积分器，并将其与直接对 ODE $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$ 进行时间步进的显式数值方案进行基准测试比较。\n\n您的程序必须：\n- 全程使用无量纲量；不要求也不允许使用物理单位。\n- 将以下宇宙学背景实现为共形时间 $\\tau$ 的函数：\n  - 辐射主导：$a(\\tau) = \\tau$，得出 $\\mathcal{H}(\\tau) = 1/\\tau$（对于 $\\tau > 0$）。\n  - 物质主导：$a(\\tau) = \\tau^2$，得出 $\\mathcal{H}(\\tau) = 2/\\tau$（对于 $\\tau > 0$）。\n  - 宇宙学常数主导（共形时间下的德西特时空）：$a(\\tau) = -1/\\tau$，得出 $\\mathcal{H}(\\tau) = -1/\\tau$（对于 $\\tau  0$）。\n- 实现四种积分方案，用 $N$ 个大小为 $\\Delta \\tau = (\\tau_1 - \\tau_0)/N$ 的均匀步长，将 $u(\\tau)$ 从初始时间 $\\tau_0$ 推进到最终时间 $\\tau_1$：\n  - 由 ODE 解析解蕴含的精确离散积分器，在每个区间上逐步应用。\n  - 应用于 ODE $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$ 的前向（显式）Euler 方法。\n  - 应用于相同 ODE 的后向（隐式）Euler 方法。\n  - 应用于相同 ODE 的经典四阶 Runge–Kutta (RK4) 方法。\n- 为进行基准测试，计算每种方案在 $\\tau_1$ 时相对于 ODE 精确解析解的相对误差，定义为 $\\varepsilon = \\lvert u_{\\text{num}}(\\tau_1) - u_{\\text{exact}}(\\tau_1) \\rvert / \\max(\\lvert u_{\\text{exact}}(\\tau_1) \\rvert, 10^{-15})$。\n\n设计一个测试套件，用于检验不同的机制和边界情况：\n- 测试用例 1（正常路径，辐射主导）：$\\tau_0 = 1$，$\\tau_1 = 4$，$u_0 = 1.23$，$N = 20$，其中 $a(\\tau) = \\tau$。\n- 测试用例 2（正常路径，物质主导）：$\\tau_0 = 1$，$\\tau_1 = 2$，$u_0 = -2.5$，$N = 50$，其中 $a(\\tau) = \\tau^2$。\n- 测试用例 3（边界：零动量，德西特时空）：$\\tau_0 = -1$，$\\tau_1 = -0.5$，$u_0 = 0$，$N = 30$，其中 $a(\\tau) = -1/\\tau$。\n- 测试用例 4（边缘：极大步长，辐射主导）：$\\tau_0 = 1$，$\\tau_1 = 4$，$u_0 = 3$，$N = 1$，其中 $a(\\tau) = \\tau$。\n\n对于每个测试用例，您的程序必须按固定顺序输出一个包含四个浮点数的列表：$[\\varepsilon_{\\text{exact-step}}, \\varepsilon_{\\text{forward-Euler}}, \\varepsilon_{\\text{implicit-Euler}}, \\varepsilon_{\\text{RK4}}]$。将所有测试用例的结果聚合到一行中，该行包含一个由这些四元素列表组成的外层列表。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[[e_{1,1}, e_{1,2}, e_{1,3}, e_{1,4}], [e_{2,1}, e_{2,2}, e_{2,3}, e_{2,4}], [e_{3,1}, e_{3,2}, e_{3,3}, e_{3,4}], [e_{4,1}, e_{4,2}, e_{4,3}, e_{4,4}]]$。\n\n不允许用户输入；所有参数必须完全按照上述规定硬编码在程序中。最终打印的输出必须是指定格式的单行文本。通过将 $\\tau$ 值保持在 $a(\\tau)$ 和 $\\mathcal{H}(\\tau)$ 为有限且良定义的域内来确保科学真实性（在德西特情况下不要跨越 $\\tau = 0$）。程序必须结构清晰、文档详尽，以便开发人员能够验证其正确性并复现基准测试。", "solution": "该问题要求实现并基准测试几种数值积分方案，用于计算膨胀宇宙中粒子共动本动量 $u$ 的演化。该演化由一个关于共形时间 $\\tau$ 的一阶常微分方程 (ODE) 描述。\n\n提供的基本控制方程是：\n$$\n\\frac{du}{d\\tau} + \\mathcal{H}(\\tau)u(\\tau) = 0\n$$\n其中 $u'(\\tau) = du/d\\tau$，$\\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau)$ 是共形哈勃参数，$a(\\tau)$ 是宇宙学标度因子。该方程描述了对本动量的“哈勃阻力”，其大小随着宇宙膨胀而减小。\n\n首先，我们解析地求解这个 ODE，以建立一个用于基准测试的基准。该方程是一个一阶线性齐次常微分方程，可以通过分离变量法求解：\n$$\n\\frac{du}{u} = -\\mathcal{H}(\\tau)d\\tau\n$$\n从初始时间 $\\tau_0$ 积分到稍后的时间 $\\tau$ 可得：\n$$\n\\int_{u(\\tau_0)}^{u(\\tau)} \\frac{d\\tilde{u}}{\\tilde{u}} = -\\int_{\\tau_0}^{\\tau} \\mathcal{H}(\\tilde{\\tau})d\\tilde{\\tau}\n$$\n$$\n\\ln\\left(\\frac{u(\\tau)}{u(\\tau_0)}\\right) = -\\int_{\\tau_0}^{\\tau} \\frac{a'(\\tilde{\\tau})}{a(\\tilde{\\tau})}d\\tilde{\\tau} = -\\left[\\ln(a(\\tilde{\\tau}))\\right]_{\\tau_0}^{\\tau} = -(\\ln(a(\\tau)) - \\ln(a(\\tau_0))) = \\ln\\left(\\frac{a(\\tau_0)}{a(\\tau)}\\right)\n$$\n对两边取指数，得到精确的解析解：\n$$\nu(\\tau) = u(\\tau_0) \\frac{a(\\tau_0)}{a(\\tau)}\n$$\n这个结果表明，共动本动量会发生红移，其大小与标度因子成反比而减小，即 $u \\propto 1/a$。\n\n程序将实现并比较四种积分方案，用 $N$ 个大小为 $\\Delta\\tau = (\\tau_1 - \\tau_0)/N$ 的均匀步长，来求解从初始时间 $\\tau_0$ 到最终时间 $\\tau_1$ 的 ODE。令 $u_i = u(\\tau_i)$，其中 $\\tau_i = \\tau_0 + i\\Delta\\tau$。\n\n1. **精确步进积分器**：该方案在从 $\\tau_i$ 到 $\\tau_{i+1}$ 的每个离散时间步上应用精确解析解。其更新规则直接从解析解推导而来：\n$$\nu_{i+1} = u_i \\frac{a(\\tau_i)}{a(\\tau_{i+1})}\n$$\n根据其构造，该方法将在 $\\tau_1$ 处得出在浮点精度范围内的精确结果，因此其相对误差应接近于零。\n\n2. **前向（显式）Euler 方法**：这是最简单的数值方案。它使用区间起点 $\\tau_i$ 处的导数进行近似。ODE 可写作 $u' = -\\mathcal{H}(\\tau)u(\\tau)$。其更新规则是：\n$$\nu_{i+1} = u_i + \\Delta\\tau \\cdot u'(\\tau_i) = u_i - \\Delta\\tau \\mathcal{H}(\\tau_i) u_i = u_i (1 - \\Delta\\tau \\mathcal{H}(\\tau_i))\n$$\n\n3. **后向（隐式）Euler 方法**：该方案在区间终点 $\\tau_{i+1}$ 处评估导数，这使其对于刚性问题更为稳定。其更新规则是：\n$$\nu_{i+1} = u_i + \\Delta\\tau \\cdot u'(\\tau_{i+1}) = u_i - \\Delta\\tau \\mathcal{H}(\\tau_{i+1}) u_{i+1}\n$$\n解出 $u_{i+1}$ 得到显式更新规则：\n$$\nu_{i+1}(1 + \\Delta\\tau \\mathcal{H}(\\tau_{i+1})) = u_i \\implies u_{i+1} = \\frac{u_i}{1 + \\Delta\\tau \\mathcal{H}(\\tau_{i+1})}\n$$\n\n4. **经典四阶 Runge-Kutta (RK4) 方法**：这是一种高阶方法，通过在步长内的多个点上评估导数来提供更高的精度。对于一个 ODE $u' = f(\\tau, u)$，其更新规则是：\n$$\nu_{i+1} = u_i + \\frac{\\Delta\\tau}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n其中，对于我们的特定问题 $f(\\tau, u) = -\\mathcal{H}(\\tau)u(\\tau)$：\n- $k_1 = f(\\tau_i, u_i) = -\\mathcal{H}(\\tau_i)u_i$\n- $k_2 = f(\\tau_i + \\frac{\\Delta\\tau}{2}, u_i + \\frac{\\Delta\\tau}{2}k_1) = -\\mathcal{H}(\\tau_i + \\frac{\\Delta\\tau}{2})(u_i + \\frac{\\Delta\\tau}{2}k_1)$\n- $k_3 = f(\\tau_i + \\frac{\\Delta\\tau}{2}, u_i + \\frac{\\Delta\\tau}{2}k_2) = -\\mathcal{H}(\\tau_i + \\frac{\\Delta\\tau}{2})(u_i + \\frac{\\Delta\\tau}{2}k_2)$\n- $k_4 = f(\\tau_i + \\Delta\\tau, u_i + \\Delta\\tau k_3) = -\\mathcal{H}(\\tau_i + \\Delta\\tau)(u_i + \\Delta\\tau k_3)$\n\n指定的宇宙学模型是：\n- 辐射主导：$a(\\tau) = \\tau$，$\\mathcal{H}(\\tau) = 1/\\tau$，对于 $\\tau  0$。\n- 物质主导：$a(\\tau) = \\tau^2$，$\\mathcal{H}(\\tau) = 2/\\tau$，对于 $\\tau  0$。\n- 德西特时空：$a(\\tau) = -1/\\tau$，$\\mathcal{H}(\\tau) = -1/\\tau$，对于 $\\tau  0$。\n对于所有这些模型，ODE 的形式为 $u' = -c \\cdot u/\\tau$，其中 $c$ 是某个常数。一个已知的性质是，RK4 方法对于这种形式的 ODE 能提供精确解。因此，我们预期在所有测试用例中，RK4 的误差都将接近于零。\n\n基准测试过程如下：\n- 对每个测试用例，定义参数 $(\\tau_0, \\tau_1, u_0, N)$ 和宇宙学模型。\n- 计算精确的最终动量 $u_{\\text{exact}}(\\tau_1) = u_0 a(\\tau_0)/a(\\tau_1)$。\n- 对于四种数值方案中的每一种，通过从 $\\tau_0$ 开始迭代 $N$ 次来计算最终动量 $u_{\\text{num}}(\\tau_1)$。\n- 使用提供的公式为每种方案计算相对误差 $\\varepsilon$：\n$$\n\\varepsilon = \\frac{\\lvert u_{\\text{num}}(\\tau_1) - u_{\\text{exact}}(\\tau_1) \\rvert}{\\max(\\lvert u_{\\text{exact}}(\\tau_1) \\rvert, 10^{-15})}\n$$\n程序整理每个测试用例的这些误差，并以指定的列表的列表格式呈现它们。", "answer": "```python\n#\n# Meticulous and Exacting STEM Professor\n# Solution for Comoving Momentum Integration\n#\n\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main entry point for the program. Defines test cases, runs benchmarks,\n    and prints the final results in the specified format.\n    \"\"\"\n\n    # Dictionary mapping cosmology names to their scale factor and Hubble parameter functions.\n    cosmology_models = {\n        'radiation': {\n            'a': lambda tau: tau,\n            'H': lambda tau: 1.0 / tau\n        },\n        'matter': {\n            'a': lambda tau: tau**2,\n            'H': lambda tau: 2.0 / tau\n        },\n        'de_sitter': {\n            'a': lambda tau: -1.0 / tau,\n            'H': lambda tau: -1.0 / tau\n        }\n    }\n\n    # Define the test suite as specified in the problem statement.\n    test_cases = [\n        {'cosmology': 'radiation', 'tau0': 1.0, 'tau1': 4.0, 'u0': 1.23, 'N': 20},\n        {'cosmology': 'matter',    'tau0': 1.0, 'tau1': 2.0, 'u0': -2.5, 'N': 50},\n        {'cosmology': 'de_sitter', 'tau0': -1.0, 'tau1': -0.5, 'u0': 0.0, 'N': 30},\n        {'cosmology': 'radiation', 'tau0': 1.0, 'tau1': 4.0, 'u0': 3.0, 'N': 1},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        errors = run_benchmark(case, cosmology_models)\n        all_results.append(errors)\n\n    # Format the final output string as a list of lists.\n    # The default string representation of floats is used as no specific format was required.\n    inner_lists_str = []\n    for res_list in all_results:\n        inner_lists_str.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    print(final_output)\n\n\ndef run_benchmark(case, cosmology_models):\n    \"\"\"\n    Runs all integration schemes for a single test case and returns their relative errors.\n\n    Args:\n        case (dict): A dictionary containing parameters for the test case\n                     (cosmology, tau0, tau1, u0, N).\n        cosmology_models (dict): A dictionary of cosmological model functions.\n\n    Returns:\n        list: A list of four floats representing the relative errors for each scheme.\n    \"\"\"\n    cosmology = case['cosmology']\n    tau0, tau1, u0, N = case['tau0'], case['tau1'], case['u0'], case['N']\n\n    a_func = cosmology_models[cosmology]['a']\n    H_func = cosmology_models[cosmology]['H']\n\n    # Generate time steps. np.linspace correctly handles N=1 (2 points).\n    tau_steps = np.linspace(tau0, tau1, N + 1)\n    delta_tau = (tau1 - tau0) / N\n\n    # Calculate the exact analytical solution at the final time for reference.\n    u_exact_final = u0 * a_func(tau0) / a_func(tau1)\n\n    # Run each of the four integration schemes.\n    u_exact_step_final = integrate_exact_step(u0, tau_steps, a_func)\n    u_forward_euler_final = integrate_forward_euler(u0, tau_steps, delta_tau, H_func)\n    u_implicit_euler_final = integrate_implicit_euler(u0, tau_steps, delta_tau, H_func)\n    u_rk4_final = integrate_rk4(u0, tau_steps, delta_tau, H_func)\n\n    # Collect the numerical results.\n    numerical_solutions = [\n        u_exact_step_final,\n        u_forward_euler_final,\n        u_implicit_euler_final,\n        u_rk4_final\n    ]\n    \n    # Calculate the relative error for each scheme.\n    errors = [calculate_relative_error(u_num, u_exact_final) for u_num in numerical_solutions]\n    \n    return errors\n\n\ndef calculate_relative_error(u_num, u_exact):\n    \"\"\"\n    Calculates the relative error according to the specified formula.\n    \"\"\"\n    numerator = np.abs(u_num - u_exact)\n    denominator = np.maximum(np.abs(u_exact), 1e-15)\n    return numerator / denominator\n\n\ndef integrate_exact_step(u0, tau_steps, a_func):\n    \"\"\"Integrator based on the exact solution applied stepwise.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        u = u * a_func(tau_steps[i]) / a_func(tau_steps[i+1])\n    return u\n\n\ndef integrate_forward_euler(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Forward (explicit) Euler integrator.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i = tau_steps[i]\n        u = u * (1.0 - delta_tau * H_func(tau_i))\n    return u\n\n\ndef integrate_implicit_euler(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Implicit Euler integrator.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i_plus_1 = tau_steps[i+1]\n        u = u / (1.0 + delta_tau * H_func(tau_i_plus_1))\n    return u\n\n\ndef integrate_rk4(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Classical fourth-order Runge-Kutta (RK4) integrator.\"\"\"\n    # Define the function f(tau, u) = u' for the ODE u' = -H(tau) * u\n    f = lambda tau, u: -H_func(tau) * u\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i = tau_steps[i]\n        \n        k1 = f(tau_i, u)\n        k2 = f(tau_i + 0.5 * delta_tau, u + 0.5 * delta_tau * k1)\n        k3 = f(tau_i + 0.5 * delta_tau, u + 0.5 * delta_tau * k2)\n        k4 = f(tau_i + delta_tau, u + delta_tau * k3)\n        \n        u = u + (delta_tau / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n    return u\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3506150"}, {"introduction": "在理解了动量如何演化之后，下一步是积分出粒子的完整运动轨迹。任何宇宙学模拟代码都必须通过一项关键测试：它需要能够精确地维持那些在共动坐标系中静止的粒子的状态。本练习要求您实现几种标准的积分器，并量化它们的“伪漂移”，这是衡量数值保真度的关键指标 [@problem_id:3506173]。", "problem": "考虑一个在牛顿极限下建模的空间均匀、无压、物质主导的宇宙，其标度因子为 $a(t)$，哈勃参数为 $H(t)$。在一个平坦的爱因斯坦-德西特宇宙中，弗里德曼方程意味着 $H^2(t) = \\frac{8 \\pi G}{3} \\rho_b(t)$ 且 $a(t) \\propto t^{2/3}$，其中 $t$ 是宇宙时间，$G$ 是引力常数，$\\rho_b(t)$ 是均匀背景密度。在此背景下，一个自由测试粒子的物理位置 $r(t)$ 满足二阶常微分方程（ODE）$ \\frac{d^2 r}{dt^2} = - \\frac{4 \\pi G}{3} \\rho_b(t) \\, r(t)$，这是均匀密度分布内的引力场。\n\n定义共动坐标 $x(t) = r(t)/a(t)$。对于一个初始与哈勃流共动的粒子（即 $r(t_0) = a(t_0) x_0$ 且 $\\frac{dr}{dt}(t_0) = H(t_0) r(t_0)$，其中 $x_0$ 为常数），我们期望对于所有的 $t$ 都精确地有 $x(t) = x_0$，因为该粒子在共动坐标系中保持静止。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 使用无量纲代码单位在指定的均匀背景中实现该动力学系统，所选单位应使关系精确且数值条件良好。\n- 对多种积分器选择和时间步长，数值积分粒子的运动。\n- 验证一个初始在共动坐标系中静止的粒子保持静止，并量化其伪漂移 $|x(t) - x_0|$ 作为积分器选择和时间步长的函数。\n\n使用以下无量纲归一化：\n- 设置 $G = 1$ 并选择 $t_0 = 1$，从而精确得到 $a(t) = t^{2/3}$ 和 $H(t) = \\frac{2}{3 t}$。\n- 选择 $\\rho_0 = \\rho_b(t_0)$ 使得 $H_0^2 = \\frac{8 \\pi G}{3} \\rho_0$，其中 $H_0 = \\frac{2}{3}$，这意味着 $\\rho_0 = \\frac{1}{6 \\pi}$。\n- 通过此选择，常微分方程简化为 $\\frac{d^2 r}{dt^2} = - \\frac{2}{9} \\frac{r}{t^2}$。\n- 在 $t = t_0 = 1$ 处初始化，$x_0 = 1$，$r(t_0) = a(t_0) x_0 = 1$，以及 $\\frac{dr}{dt}(t_0) = \\frac{2}{3}$。\n\n您必须实现并比较以下应用于 $(r, v)$ 一阶系统的时间积分方案，其中 $v = \\frac{dr}{dt}$：\n- 显式欧拉法：使用在当前步计算的加速度 $a_r(t, r) = - \\frac{2}{9} \\frac{r}{t^2}$ 更新 $v$ 和 $r$。\n- 速度 Verlet（踢-漂移-踢）方法：一种时间中心格式，它执行 $v$ 的半步更新、$r$ 的全步更新，然后是 $v$ 的另一次半步更新，其中显式的时间依赖性在每一步的开始和结束时处理。\n- 经典四阶龙格-库塔（RK4）方法：对系统 $\\frac{dr}{dt} = v$、$\\frac{dv}{dt} = - \\frac{2}{9} \\frac{r}{t^2}$ 使用标准的四阶段过程计算更新，注意将适当的时间传递给每个阶段。\n\n对于每个积分器和时间步长，从 $t = t_0 = 1$ 积分到 $t_f = 10$。在每一步，计算共动坐标 $x(t) = \\frac{r(t)}{a(t)} = \\frac{r(t)}{t^{2/3}}$，并跟踪整个积分区间内的最大绝对漂移 $\\max_t |x(t) - x_0|$。所有报告的漂移必须表示为无量纲浮点数。\n\n测试套件：\n- 情况 1：显式欧拉法，$\\Delta t = 0.5$。\n- 情况 2：显式欧拉法，$\\Delta t = 0.05$。\n- 情况 3：速度 Verlet 法，$\\Delta t = 0.1$。\n- 情况 4：经典龙格-库塔 4 阶法，$\\Delta t = 0.5$。\n- 情况 5：经典龙格-库塔 4 阶法，$\\Delta t = 0.01$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 是相应测试用例的最大绝对漂移 $\\max_t |x(t) - x_0|$，以无量纲共动坐标单位的浮点数形式报告。", "solution": "用户提供的问题已经过评估，并被确定为**有效**。该问题在科学上基于标准宇宙学模型，在数学上作为一个常微分方程的初值问题是适定的，并且以客观、明确的语言和数据呈现。\n\n该问题要求在一个物质主导、膨胀宇宙的简化模型（爱因斯坦-德西特模型）内，对一个测试粒子的运动方程进行数值积分。其目标是量化由不同积分方案引入的数值误差或“漂移”，对于一个解析上应保持在恒定共动位置的粒子而言。\n\n控制物理模型以无量纲形式给出。粒子的物理位置 $r(t)$ 根据二阶常微分方程（ODE）演化：\n$$\n\\frac{d^2 r}{dt^2} = - \\frac{2}{9} \\frac{r}{t^2}\n$$\n该方程描述了在此模型中，一个粒子在均匀、膨胀介质中所受到的引力加速度。积分将在时间区间 $t \\in [1, 10]$ 上执行。\n\n初始条件设置在 $t_0 = 1$。粒子初始位于共动位置 $x_0 = 1$。因此，物理位置为 $r(t_0) = a(t_0) x_0$，其中标度因子 $a(t) = t^{2/3}$。这得出 $r(1) = 1^{2/3} \\cdot 1 = 1$。粒子初始也与哈勃流共动，意味着其初始物理速度与其所在位置的膨胀速度相匹配：$\\frac{dr}{dt}(t_0) = H(t_0) r(t_0)$。由于哈勃参数为 $H(t) = \\frac{2}{3t}$，初始速度为 $\\frac{dr}{dt}(1) = H(1) r(1) = (\\frac{2}{3 \\cdot 1}) \\cdot 1 = \\frac{2}{3}$。\n\n为了数值求解此问题，我们首先将二阶 ODE 转换为一个由两个耦合的一阶 ODE 组成的系统。设 $v(t) = \\frac{dr}{dt}$。该系统为：\n$$\n\\frac{dr}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = a_r(t, r) = - \\frac{2}{9} \\frac{r}{t^2}\n$$\n初始条件为在 $t_0 = 1$ 时，$(r_0, v_0) = (1, 2/3)$。\n\n我们的任务是实现三种数值积分方案，以离散时间步长 $\\Delta t$ 从 $t_0=1$ 到 $t_f=10$ 求解该系统。在积分的每个时间点 $t_n$，我们计算共动坐标 $x(t_n) = \\frac{r(t_n)}{a(t_n)} = \\frac{r(t_n)}{t_n^{2/3}}$。评估的主要指标是与解析解的最大绝对漂移 $\\max_t |x(t) - x_0|$，其中初始共动位置为 $x_0=1$。\n\n三种积分方案的实现如下：\n\n1.  **显式欧拉法：** 这是一种一阶方法。给定在时间 $t_n$ 的状态 $(r_n, v_n)$，在 $t_{n+1} = t_n + \\Delta t$ 的状态是使用在区间开始处评估的导数计算的：\n    $$\n    v_{n+1} = v_n + \\Delta t \\cdot a_r(t_n, r_n)\n    $$\n    $$\n    r_{n+1} = r_n + \\Delta t \\cdot v_n\n    $$\n    这种方法很简单，但众所周知其精度不高，并且对于振荡系统可能会出现不稳定性。\n\n2.  **速度 Verlet（踢-漂移-踢）方法：** 这是一种二阶辛积分器，由于其在长时积分中良好的能量守恒特性，被广泛用于分子动力学和 N 体模拟中。对于一个依赖于位置和时间的力，其步骤如下：\n    *   **踢（半步）：** 使用步长开始时的加速度更新速度。\n        $$v_{n+1/2} = v_n + \\frac{\\Delta t}{2} a_r(t_n, r_n)$$\n    *   **漂移（全步）：** 使用新的半步速度更新位置。\n        $$r_{n+1} = r_n + \\Delta t \\cdot v_{n+1/2}$$\n    *   **踢（半步）：** 计算步长结束时的新加速度 $a_r(t_{n+1}, r_{n+1})$，并将速度更新至其最终值。\n        $$v_{n+1} = v_{n+1/2} + \\frac{\\Delta t}{2} a_r(t_{n+1}, r_{n+1})$$\n\n3.  **经典四阶龙格-库塔（RK4）方法：** 这是一种四阶方法，与低阶方法相比，对于给定的步长能提供更高的精度。设状态向量为 $\\mathbf{y} = [r, v]^T$，导数函数为 $\\mathbf{f}(t, \\mathbf{y}) = [v, a_r(t,r)]^T$。更新规则为：\n    $$\n    \\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_1}{2})\n    $$\n    $$\n    \\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_2}{2})\n    $$\n    $$\n    \\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\mathbf{k}_3)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    $$\n    这需要在每步中于 $(t, r, v)$ 相空间中的四个不同点评估加速度，以实现其高精度。\n\n程序在不同的函数中实现了这三种方法。一个主循环遍历指定的测试用例。对于每个用例，它将状态初始化为 $(t, r, v) = (1, 1, 2/3)$，计算总步数，并进入一个一次推进模拟一步的循环。在此循环内，在每步开始时计算共动坐标 $x(t)$，并跟踪与 $x_0=1$ 的最大漂移。在 $t=t_f=10$ 时进行最终检查。然后存储累积的最大漂移。最后，收集并打印所有测试用例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef accel(t: float, r: float) - float:\n    \"\"\"Calculates the acceleration of the particle.\"\"\"\n    # The time t=0 is avoided by the problem's integration range [1, 10].\n    return -2.0/9.0 * r / t**2\n\ndef euler_integrate(dt: float) - float:\n    \"\"\"\n    Integrates the particle's motion using the Explicit Euler method.\n    Returns the maximum absolute comoving drift.\n    \"\"\"\n    t0, tf = 1.0, 10.0\n    r, v = 1.0, 2.0 / 3.0\n    x0 = 1.0\n\n    n_steps = int(round((tf - t0) / dt))\n    max_drift = 0.0\n\n    for i in range(n_steps):\n        t = t0 + i * dt\n        \n        # Calculate drift at the start of the step\n        current_x = r / t**(2.0/3.0)\n        max_drift = max(max_drift, abs(current_x - x0))\n\n        # Update step\n        a = accel(t, r)\n        r_new = r + v * dt\n        v_new = v + a * dt\n        r, v = r_new, v_new\n    \n    # Final drift check at t_f\n    final_x = r / tf**(2.0/3.0)\n    max_drift = max(max_drift, abs(final_x - x0))\n    \n    return max_drift\n\ndef verlet_integrate(dt: float) - float:\n    \"\"\"\n    Integrates the particle's motion using the Velocity Verlet (KDK) method.\n    Returns the maximum absolute comoving drift.\n    \"\"\"\n    t0, tf = 1.0, 10.0\n    r, v = 1.0, 2.0 / 3.0\n    x0 = 1.0\n\n    n_steps = int(round((tf - t0) / dt))\n    max_drift = 0.0\n\n    for i in range(n_steps):\n        t = t0 + i * dt\n        \n        # Calculate drift at the start of the step\n        current_x = r / t**(2.0/3.0)\n        max_drift = max(max_drift, abs(current_x - x0))\n\n        # Kick-Drift-Kick update\n        a_current = accel(t, r)\n        v_half = v + 0.5 * dt * a_current\n        r_next = r + dt * v_half\n        t_next = t + dt\n        a_next = accel(t_next, r_next)\n        v_next = v_half + 0.5 * dt * a_next\n        r, v = r_next, v_next\n\n    # Final drift check at t_f\n    final_x = r / tf**(2.0/3.0)\n    max_drift = max(max_drift, abs(final_x - x0))\n    \n    return max_drift\n\ndef rk4_integrate(dt: float) - float:\n    \"\"\"\n    Integrates the particle's motion using the Classical RK4 method.\n    Returns the maximum absolute comoving drift.\n    \"\"\"\n    t0, tf = 1.0, 10.0\n    r, v = 1.0, 2.0 / 3.0\n    x0 = 1.0\n\n    n_steps = int(round((tf - t0) / dt))\n    max_drift = 0.0\n\n    for i in range(n_steps):\n        t = t0 + i * dt\n        \n        # Calculate drift at the start of the step\n        current_x = r / t**(2.0/3.0)\n        max_drift = max(max_drift, abs(current_x - x0))\n\n        # RK4 stages\n        k1_r = dt * v\n        k1_v = dt * accel(t, r)\n\n        k2_r = dt * (v + k1_v / 2.0)\n        k2_v = dt * accel(t + dt / 2.0, r + k1_r / 2.0)\n\n        k3_r = dt * (v + k2_v / 2.0)\n        k3_v = dt * accel(t + dt / 2.0, r + k2_r / 2.0)\n\n        k4_r = dt * (v + k3_v)\n        k4_v = dt * accel(t + dt, r + k3_r)\n        \n        # Update step\n        r += (k1_r + 2.0 * k2_r + 2.0 * k3_r + k4_r) / 6.0\n        v += (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v) / 6.0\n\n    # Final drift check at t_f\n    final_x = r / tf**(2.0/3.0)\n    max_drift = max(max_drift, abs(final_x - x0))\n    \n    return max_drift\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        ('Euler', 0.5),\n        ('Euler', 0.05),\n        ('Verlet', 0.1),\n        ('RK4', 0.5),\n        ('RK4', 0.01),\n    ]\n\n    integrators = {\n        'Euler': euler_integrate,\n        'Verlet': verlet_integrate,\n        'RK4': rk4_integrate\n    }\n\n    results = []\n    for integrator_name, dt in test_cases:\n        func = integrators[integrator_name]\n        drift = func(dt)\n        results.append(drift)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3506173"}, {"introduction": "共动坐标不仅是简化动力学计算的工具，更是解读宇宙学观测数据的基石。本练习将我们的关注点从粒子动力学转移到计算宇宙学中的一个基本可观测量：给定红移处天体的共动距离。您将学习处理列表形式的宇宙学数据，并掌握插值和数值积分等技术来计算这一基本量，同时分析其中产生的数值误差 [@problem_id:3506157]。", "problem": "给定一个作为红移函数列表的哈勃膨胀率，记为 $H(z)$，你需要计算指定目标红移下的视线方向上的共动坐标距离 $\\chi(z)$。你必须设计并实现一个用于计算 $\\chi(z)$ 的高精度数值积分方法，并估计由插值和积分方案的选择所引入的误差。你的推导必须从适用于 Friedmann–Lemaître–Robertson–Walker (FLRW) 度规的第一性原理开始，并且你的计算必须产生以百万秒差距（单位为 $\\mathrm{Mpc}$）表示的共动距离。所有量都必须以科学真实且自洽的方式处理。\n\n从 Friedmann–Lemaître–Robertson–Walker (FLRW) 线元和光子的零测地线条件出发，推导在空间平坦背景下视线方向上的共动坐标距离 $\\chi(z)$ 的积分表达式，该表达式应以哈勃膨胀率 $H(z)$ 和光速 $c$ 表示。明确说明单位约定，使得当 $H(z)$ 以 $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ 为单位、 $c$ 以 $\\mathrm{km\\,s^{-1}}$ 为单位时，计算出的 $\\chi(z)$ 以 $\\mathrm{Mpc}$ 为单位。\n\n然后，你必须实现以下算法组件：\n- 为列表形式的 $H(z)$ 构建两种插值算子：分段线性插值和具有自然边界条件的三次样条插值。\n- 实现两种对红移进行积分的数值积分方案：复合 Simpson 法则和自适应 Gauss–Kronrod 法则。自适应 Gauss–Kronrod 法则必须配置为高精度，其绝对和相对容差均设为 $10^{-12}$。\n- 对于每个目标红移 $z$，使用两种插值方案和两种积分方案计算 $\\chi(z)$。\n- 对于每个测试用例，计算三种误差度量：\n  1. 插值选择误差估计 $E_{\\mathrm{interp}}$：在使用相同的复合 Simpson 积分法时，由三次样条插值和分段线性插值计算出的 $\\chi(z)$ 之间绝对差在所有目标 $z$ 上的最大值。\n  2. 积分选择误差估计 $E_{\\mathrm{int}}$：在使用三次样条插值时，由复合 Simpson 积分法和自适应 Gauss–Kronrod 积分法计算出的 $\\chi(z)$ 之间绝对差在所有目标 $z$ 上的最大值。\n  3. 相对解析高分辨率参考的总误差 $E_{\\mathrm{total}}$：由三次样条插值和自适应 Gauss–Kronrod 积分法计算出的 $\\chi(z)$ 与参考值 $\\chi_{\\mathrm{ref}}(z)$ 之间绝对差在所有目标 $z$ 上的最大值。参考值 $\\chi_{\\mathrm{ref}}(z)$ 是通过使用相同容差的自适应 Gauss–Kronrod 积分法对精确的解析 $H(z)$ 进行积分得到的。该参考值应根据一个经过充分检验的公式计算，此公式源自包含物质、辐射和宇宙学常数的空间平坦宇宙中的 Friedmann 方程。\n\n你的推导和实现应基于以下基本背景：\n- 空间平坦宇宙的 Friedmann–Lemaître–Robertson–Walker (FLRW) 度规和光子测地线的零条件。\n- 红移 $z$ 的定义及其与标度因子 $a(t)$ 和哈勃膨胀率 $H(z)$ 的关系。\n- 光速 $c=299792.458\\,\\mathrm{km\\,s^{-1}}$。\n- 空间平坦的 $\\Lambda$ 冷暗物质（$\\Lambda\\mathrm{CDM}$）模型中包含物质、辐射和宇宙学常数组分的哈勃膨胀率，由以下经过充分检验的公式给出：\n$$\nH(z)=H_0\\sqrt{\\Omega_{\\mathrm{r}}(1+z)^4+\\Omega_{\\mathrm{m}}(1+z)^3+\\Omega_{\\Lambda}},\n$$\n其中 $H_0$ 是哈勃常数，$\\Omega_{\\mathrm{r}}$ 是辐射密度参数，$\\Omega_{\\mathrm{m}}$ 是物质密度参数，$\\Omega_{\\Lambda}$ 是宇宙学常数密度参数，且满足 $\\Omega_{\\mathrm{r}}+\\Omega_{\\mathrm{m}}+\\Omega_{\\Lambda}=1$。\n\n物理单位要求：\n- 所有共动距离以 $\\mathrm{Mpc}$ 表示。\n- 使用的 $H(z)$ 单位为 $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$，$c$ 的单位为 $\\mathrm{km\\,s^{-1}}$。\n\n测试套件：\n- 测试用例 1（正常路径，粗略制表，中等红移范围）：$H_0=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$，$\\Omega_{\\mathrm{m}}=0.3$，$\\Omega_{\\Lambda}=0.7$，$\\Omega_{\\mathrm{r}}=0$，红移网格 $z\\in[0,2]$ 上有 $11$ 个均匀间隔的点，目标红移为 $z\\in\\{0.0,0.5,1.0,2.0\\}$。\n- 测试用例 2（正常路径，精细制表，相同宇宙学模型）：$H_0=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$，$\\Omega_{\\mathrm{m}}=0.3$，$\\Omega_{\\Lambda}=0.7$，$\\Omega_{\\mathrm{r}}=0$，红移网格 $z\\in[0,2]$ 上有 $101$ 个均匀间隔的点，目标红移为 $z\\in\\{0.2,0.9,1.7\\}$。\n- 测试用令 3（边界情况，包含辐射的高红移）：$H_0=67.74\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$，$\\Omega_{\\mathrm{m}}=0.3$，$\\Omega_{\\mathrm{r}}=9.2\\times 10^{-5}$，$\\Omega_{\\Lambda}=1-\\Omega_{\\mathrm{m}}-\\Omega_{\\mathrm{r}}$，红移网格 $z\\in[0,10]$ 上有 $21$ 个均匀间隔的点，目标红移为 $z\\in\\{0.0,2.0,6.0,10.0\\}$。\n\n你的程序必须：\n- 通过在指定的红移网格上评估解析 $H(z)$ 模型，为每个测试用例构建列表形式的 $H(z)$ 值。\n- 对于每个测试用例，计算如上定义的三种误差度量 $E_{\\mathrm{interp}}$、$E_{\\mathrm{int}}$ 和 $E_{\\mathrm{total}}$，所有单位均为 $\\mathrm{Mpc}$。\n- 生成单行输出，其中包含所有测试用例的误差度量，按顺序连接成一个用方括号括起来的逗号分隔列表。具体来说，输出必须是 $\\bigl[E_{\\mathrm{interp,1}},E_{\\mathrm{int,1}},E_{\\mathrm{total,1}},E_{\\mathrm{interp,2}},E_{\\mathrm{int,2}},E_{\\mathrm{total,2}},E_{\\mathrm{interp,3}},E_{\\mathrm{int,3}},E_{\\mathrm{total,3}}\\bigr]$，其中下标表示测试用例的索引。所有值都必须是单位为 $\\mathrm{Mpc}$ 的浮点数。", "solution": "该问题要求在宇宙学背景下推导并数值计算视线方向上的共动距离，然后对所使用的数值方法进行误差分析。该问题定义严谨，科学上合理，且内部一致。\n\n### 1. 共动距离 $\\chi(z)$ 的推导\n\n均匀且各向同性的宇宙的几何结构由 Friedmann–Lemaître–Robertson–Walker (FLRW) 度规描述。对于空间平坦的宇宙（$k=0$），在球面共动坐标 $(\\chi, \\theta, \\phi)$ 中，线元 $ds$ 由下式给出：\n$$\nds^2 = c^2 dt^2 - a(t)^2 [d\\chi^2 + \\chi^2(d\\theta^2 + \\sin^2\\theta d\\phi^2)]\n$$\n其中 $c$ 是光速，$t$ 是宇宙时，$a(t)$ 是无量纲的标度因子（在当前时间 $t_0$ 归一化为 $a(t_0)=1$），$\\chi$ 是径向共动坐标距离。\n\n我们考虑一个从遥远源传播到位于原点（$\\chi=0$）的观测者的光子。该光子沿零测地线传播，即 $ds^2=0$。假设光子沿径向路径传播（$d\\theta=0$，$d\\phi=0$），则条件变为：\n$$\nc^2 dt^2 = a(t)^2 d\\chi^2\n$$\n取平方根并重新整理，得到在时间间隔 $dt$ 内传播的共动距离增量：\n$$\nd\\chi = \\pm \\frac{c \\, dt}{a(t)}\n$$\n由于 $\\chi$ 是一个距离，我们取正根。光子朝向原点传播，因此其坐标 $\\chi$ 随着时间 $t$ 的增加而减小。设光子在时间 $t_e$ 从共动距离 $\\chi(z)$ 处发出，并在当前时间 $t_0$ 于原点（$\\chi=0$）被接收。对该表达式进行积分得到：\n$$\n\\int_{\\chi(z)}^0 d\\chi' = \\int_{t_e}^{t_0} -\\frac{c \\, dt'}{a(t')}\n$$\n$$\n-\\chi(z) = -c \\int_{t_e}^{t_0} \\frac{dt'}{a(t')} \\implies \\chi(z) = c \\int_{t_e}^{t_0} \\frac{dt'}{a(t')}\n$$\n为了用红移 $z$ 表示这个积分，我们使用红移的定义 $1+z = a(t_0)/a(t) = 1/a(t)$，以及哈勃参数的定义 $H(t) = \\dot{a}/a = (1/a)(da/dt)$。我们可以写出 $dt = da/(aH)$。\n微分量 $dz$ 通过对 $a=(1+z)^{-1}$ 求导与 $da$ 相关联：\n$$\nda = -(1+z)^{-2} dz\n$$\n将此代入 $dt$ 的表达式中：\n$$\ndt = \\frac{-(1+z)^{-2} dz}{(1+z)^{-1} H(z)} = -\\frac{dz}{(1+z)H(z)}\n$$\n现在，我们将积分变量从 $t'$ 更改为 $z'$。积分限变为 $t_e \\to z$ 和 $t_0 \\to 0$。\n$$\n\\chi(z) = c \\int_{z}^{0} \\frac{1}{a(t(z'))} \\left( -\\frac{dz'}{(1+z')H(z')} \\right)\n$$\n使用 $a(t(z')) = (1+z')^{-1}$，我们得到：\n$$\n\\chi(z) = c \\int_{z}^{0} (1+z') \\left( -\\frac{dz'}{(1+z')H(z')} \\right) = -c \\int_{z}^{0} \\frac{dz'}{H(z')}\n$$\n翻转积分限以吸收负号，得到视线方向上的共动距离的最终表达式：\n$$\n\\chi(z) = c \\int_0^z \\frac{dz'}{H(z')}\n$$\n\n### 2. 单位一致性\n\n问题指定了输入量的单位：$c$ 的单位是 $\\mathrm{km\\,s^{-1}}$，$H(z)$ 的单位是 $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$。积分变量 $z'$ 是无量纲的。被积函数 $\\frac{c}{H(z')}$ 的单位是：\n$$\n\\text{Units}\\left[\\frac{c}{H(z')}\\right] = \\frac{\\mathrm{km\\,s^{-1}}}{\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}} = \\mathrm{Mpc}\n$$\n因此，积分的结果 $\\chi(z)$ 将自然地以百万秒差距（$\\mathrm{Mpc}$）为单位，符合要求。\n\n### 3. 数值实现策略\n\n问题的核心是使用 $H(z)$ 的数值列表数据计算 $\\chi(z)$ 的积分，并量化此过程中产生的误差。\n\n**A. $H(z)$ 的插值**\n列表数据 $(z_i, H(z_i))$ 必须转换为一个连续函数 $H_{\\text{interp}}(z)$，以便在积分中使用。我们需要使用两种方法：\n1.  **分段线性插值**：此方法用直线连接相邻的数据点。它简单且鲁棒，但精度较低，因为其导数在数据点处不连续。\n2.  **三次样条插值**：此方法在数据点之间拟合分段三次多项式，确保所得函数及其前两阶导数是连续的。我们将使用自然边界条件，即将样条函数在端点的二阶导数设置为零。这是一种高阶方法，通常能提供对底层函数更平滑、更准确的表示。\n\n**B. 数值积分**\n我们需要为不同的目标红移 $z$ 计算积分 $\\int_0^z (c/H_{\\text{interp}}(z')) dz'$。需要使用两种方法：\n1.  **复合 Simpson 法则**：这是一个经典的 Newton-Cotes 公式，它在子区间上用二次函数近似被积函数。为实现高精度并确保积分误差相对于插值误差是次要的，我们将使用一个包含 $10001$ 个点的细网格进行积分。\n2.  **自适应 Gauss-Kronrod 积分**：这是一种更复杂的方法，它会自动调整子区间的密度以满足预设的精度目标。它使用一对嵌套的 Gaussian 积分法则（Gauss 法则和更高阶的 Kronrod 法则）来估计积分及其误差。我们将使用严格的绝对和相对容差 $10^{-12}$ 来配置它。\n\n**C. 误差估计**\n问题定义了三种误差度量来评估数值方案：\n1.  $E_{\\mathrm{interp}} = \\max_z |\\chi_{\\text{spline, Simp}}(z) - \\chi_{\\text{lin, Simp}}(z)|$：通过保持积分方法（Simpson 法则）不变，该度量分离出由插值方案选择（线性 vs. 样条）引起的误差。\n2.  $E_{\\mathrm{int}} = \\max_z |\\chi_{\\text{spline, Simp}}(z) - \\chi_{\\text{spline, adapt}}(z)|$：通过保持插值方法（三次样条）不变，该度量分离出由积分方案选择（Simpson vs. 自适应）引起的误差。\n3.  $E_{\\mathrm{total}} = \\max_z |\\chi_{\\text{spline, adapt}}(z) - \\chi_{\\mathrm{ref}}(z)|$：该度量衡量我们最佳数值方案（样条插值与自适应积分）相对于高保真参考值 $\\chi_{\\text{ref}}$ 的总误差。该参考值是通过使用相同的高精度自适应积分法对 $H(z)$ 的精确解析公式进行积分计算得出的，从而代表了给定宇宙学模型的“真实值”。\n\n每个测试用例的计算流程如下：\n1.  从解析的 $\\Lambda$CDM 公式生成 $(z_i, H(z_i))$ 值的离散表。\n2.  为 $H(z)$ 构建分段线性和三次样条插值函数。\n3.  对于每个目标红移 $z_j$：\n    - 使用插值和积分方案的四种组合计算 $\\chi(z_j)$。\n    - 计算参考值 $\\chi_{\\mathrm{ref}}(z_j)$。\n4.  计算在所有 $z_j$ 上的最大绝对差，以求得 $E_{\\mathrm{interp}}$、$E_{\\mathrm{int}}$ 和 $E_{\\mathrm{total}}$。\n5.  收集所有测试用例的结果，并按指定格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import interp1d, CubicSpline\nfrom scipy.integrate import simpson, quad\n\ndef solve():\n    \"\"\"\n    Computes comoving distances and evaluates numerical errors based on\n    tabulated Hubble expansion rate data.\n    \"\"\"\n    # Speed of light in km/s\n    c = 299792.458\n\n    # Test cases: (H0, Om_m, Om_r, (z_min, z_max, n_points), target_z_list)\n    test_cases = [\n        (70.0, 0.3, 0.0, (0.0, 2.0, 11), [0.0, 0.5, 1.0, 2.0]),\n        (70.0, 0.3, 0.0, (0.0, 2.0, 101), [0.2, 0.9, 1.7]),\n        (67.74, 0.3, 9.2e-5, (0.0, 10.0, 21), [0.0, 2.0, 6.0, 10.0])\n    ]\n\n    # Parameters for numerical methods\n    SIMPSON_N_POINTS = 10001\n    ADAPTIVE_TOL = 1e-12\n\n    results = []\n    for case_params in test_cases:\n        H0, Om_m, Om_r, z_grid_params, target_z = case_params\n        Om_L = 1.0 - Om_m - Om_r\n\n        # --- 1. Define H(z) functions ---\n\n        def H_analytic(z, H0_loc=H0, Om_m_loc=Om_m, Om_r_loc=Om_r, Om_L_loc=Om_L):\n            \"\"\"Analytic Hubble expansion rate for flat LambdaCDM+radiation.\"\"\"\n            return H0_loc * np.sqrt(Om_r_loc * (1 + z)**4 + Om_m_loc * (1 + z)**3 + Om_L_loc)\n\n        # --- 2. Generate tabulated data and interpolators ---\n        \n        z_tab = np.linspace(z_grid_params[0], z_grid_params[1], z_grid_params[2])\n        H_tab = H_analytic(z_tab)\n\n        # Piecewise linear interpolation\n        H_linear_interp = interp1d(z_tab, H_tab, kind='linear', bounds_error=False, fill_value=\"extrapolate\")\n        \n        # Cubic spline interpolation with natural boundary conditions\n        H_spline_interp = CubicSpline(z_tab, H_tab, bc_type='natural')\n\n        # --- 3. Define integrands for comoving distance ---\n        \n        integrand_linear = lambda z: c / H_linear_interp(z)\n        integrand_spline = lambda z: c / H_spline_interp(z)\n        integrand_analytic = lambda z: c / H_analytic(z)\n\n        # --- 4. Compute chi(z) for all methods and target redshifts ---\n        \n        chi_lin_simp_vals = []\n        chi_spline_simp_vals = []\n        chi_spline_adapt_vals = []\n        chi_ref_vals = []\n\n        for z_t in target_z:\n            if z_t == 0.0:\n                chi_lin_simp_vals.append(0.0)\n                chi_spline_simp_vals.append(0.0)\n                chi_spline_adapt_vals.append(0.0)\n                chi_ref_vals.append(0.0)\n                continue\n\n            # a) Composite Simpson's rule integration\n            z_fine_grid = np.linspace(0, z_t, SIMPSON_N_POINTS)\n            \n            y_linear = integrand_linear(z_fine_grid)\n            chi_lin_simp = simpson(y_linear, z_fine_grid)\n            chi_lin_simp_vals.append(chi_lin_simp)\n\n            y_spline = integrand_spline(z_fine_grid)\n            chi_spline_simp = simpson(y_spline, z_fine_grid)\n            chi_spline_simp_vals.append(chi_spline_simp)\n            \n            # b) Adaptive Gauss-Kronrod integration\n            chi_spline_adapt, _ = quad(integrand_spline, 0, z_t, epsabs=ADAPTIVE_TOL, epsrel=ADAPTIVE_TOL)\n            chi_spline_adapt_vals.append(chi_spline_adapt)\n\n            # c) Reference high-accuracy calculation\n            chi_ref, _ = quad(integrand_analytic, 0, z_t, epsabs=ADAPTIVE_TOL, epsrel=ADAPTIVE_TOL)\n            chi_ref_vals.append(chi_ref)\n        \n        chi_lin_simp_arr = np.array(chi_lin_simp_vals)\n        chi_spline_simp_arr = np.array(chi_spline_simp_vals)\n        chi_spline_adapt_arr = np.array(chi_spline_adapt_vals)\n        chi_ref_arr = np.array(chi_ref_vals)\n\n        # --- 5. Compute error metrics ---\n\n        # E_interp: Error from interpolation choice (linear vs. spline)\n        E_interp = np.max(np.abs(chi_spline_simp_arr - chi_lin_simp_arr))\n\n        # E_int: Error from integration choice (Simpson vs. adaptive)\n        E_int = np.max(np.abs(chi_spline_simp_arr - chi_spline_adapt_arr))\n\n        # E_total: Total error of best scheme vs. analytic reference\n        E_total = np.max(np.abs(chi_spline_adapt_arr - chi_ref_arr))\n\n        results.extend([E_interp, E_int, E_total])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3506157"}]}