{"hands_on_practices": [{"introduction": "在应用物理方程之前，我们必须首先掌握离散快速傅里叶变换（FFT）数组索引与其所代表的连续物理波矢量 $\\mathbf{k}$ 之间的关系。这项基础练习旨在正确建立此映射，并强制执行物理空间中实值场所需的厄米共轭对称性 [@problem_id:3512441]。正确处理这些细节对于避免在任何基于傅里葉变换的计算中出现细微但重大的错误至关重要。", "problem": "您正在一个边长为 $L_x$、$L_y$ 和 $L_z$ 的三维周期性立方体域中生成高斯随机场的宇宙学初始条件，该域在尺寸为 $N_x$、$N_y$ 和 $N_z$、间距为 $\\Delta_x = L_x/N_x$、$\\Delta_y = L_y/N_y$ 和 $\\Delta_z = L_z/N_z$ 的规则网格上进行离散化。您将通过在傅里叶空间中求解泊松型方程来计算一阶和二阶拉格朗日微扰理论 (2LPT) 的位移，因此您必须将快速傅里叶变换 (FFT) 数组的索引准确地映射到物理波矢分量，并确保实空间场为实数。\n\n从在网格上采样的实标量场 $\\delta(\\mathbf{x})$ 的离散傅里叶变换的定义开始，该定义与整数 $m_a \\in \\mathbb{Z}$（其中 $a \\in \\{x,y,z\\}$）上的三维周期性傅里叶级数表示一致：\n$$\n\\delta(\\mathbf{x}_{\\mathbf{n}}) = \\sum_{\\mathbf{m}} \\tilde{\\delta}(\\mathbf{k}_{\\mathbf{m}}) \\exp\\!\\left(i \\mathbf{k}_{\\mathbf{m}} \\cdot \\mathbf{x}_{\\mathbf{n}}\\right), \\quad \\mathbf{x}_{\\mathbf{n}} = \\left(n_x \\Delta_x, n_y \\Delta_y, n_z \\Delta_z\\right), \\quad \\mathbf{k}_{\\mathbf{m}} = \\left(\\tfrac{2\\pi m_x}{L_x}, \\tfrac{2\\pi m_y}{L_y}, \\tfrac{2\\pi m_z}{L_z}\\right),\n$$\n其中 $n_a \\in \\{0,1,\\dots,N_a-1\\}$。对于实场 $\\delta(\\mathbf{x})$，其傅里叶系数服从厄米对称性 $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$。\n\n在实践中，FFT 库以不同的索引顺序呈现离散谱。两种常见的约定是：\n- 原始的、“未移位”的 FFT 输出排序，每个轴 $a$ 的索引为 $i_a \\in \\{0,1,\\dots,N_a-1\\}$。\n- 重新索引的“移位”排序（例如，通过一个将零频率移动到中心的函数），索引为 $s_a \\in \\{0,1,\\dots,N_a-1\\}$，对应于从负到正递增的有符号频率。\n\n为了确保生成的高斯随机场以及所有导出的一阶和二阶拉格朗日微扰理论位移场在实空间中严格为实数，必须在每种约定下使用从 FFT 数组索引到物理 $\\mathbf{k}$ 值的正确整数频率映射，并对自共轭的零频模式和奈奎斯特模式应用正确的处理方法。\n\n哪个选项正确地规定了：\n(i) 在三维空间中（涵盖偶数和奇数 $N_a$ 的情况），对于未移位和移位两种约定，从 FFT 数组索引到整数三元组 $(m_x, m_y, m_z)$，并由此到物理 $\\mathbf{k}$ 的映射，以及\n(ii) 为满足 $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$ 以使 $\\delta(\\mathbf{x})$ 为实数，所需的对零频和奈奎斯特模式的正确处理方法？\n\n选择最佳选项。\n\nA. 未移位映射：对于每个尺寸为 $N_a$、原始索引为 $i_a \\in \\{0,\\dots,N_a-1\\}$ 的轴 $a$，定义整数频率\n$$\nm_a(i_a) = \\begin{cases}\ni_a,  \\text{若 } 0 \\le i_a \\le \\frac{N_a}{2} \\quad (\\text{偶数 } N_a) \\\\\ni_a - N_a,  \\text{若 } \\frac{N_a}{2}  i_a \\le N_a - 1 \\quad (\\text{偶数 } N_a) \\\\\ni_a,  \\text{若 } 0 \\le i_a \\le \\frac{N_a - 1}{2} \\quad (\\text{奇数 } N_a) \\\\\ni_a - N_a,  \\text{若 } \\frac{N_a + 1}{2} \\le i_a \\le N_a - 1 \\quad (\\text{奇数 } N_a)\n\\end{cases}\n$$\n移位映射：对于每个移位索引为 $s_a \\in \\{0,\\dots,N_a - 1\\}$ 的轴 $a$，定义\n$$\nm_a(s_a) = s_a - \\left\\lfloor \\tfrac{N_a}{2} \\right\\rfloor,\n$$\n使得有符号整数从 $- \\left\\lfloor \\tfrac{N_a}{2} \\right\\rfloor$ 递增到 $+\\left\\lceil \\tfrac{N_a}{2} \\right\\rceil - 1$。物理波矢为\n$$\nk_a = \\frac{2\\pi m_a}{L_a}, \\quad \\mathbf{k} = (k_x, k_y, k_z).\n$$\n零频和奈奎斯特模式处理：通过配对不同的模式来强制执行 $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$；对于在离散对称性 $2 m_a \\equiv 0 \\pmod{N_a}$ 对所有 $a$ 成立的情况下为其自身负值的任何模式（即当 $N_a$ 为偶数时，每个分量 $m_a \\in \\{0, N_a/2\\}$），将 $\\tilde{\\delta}(\\mathbf{k})$ 设置为纯实数。特别地，零频模式 $(m_x,m_y,m_z)=(0,0,0)$ 和所有 $m_a \\in \\{0, N_a/2\\}$（如果适用）的“角落”奈奎斯特组合都是实数。所有其他模式都通过厄米配对来处理。\n\nB. 未移位映射：$k_a = \\dfrac{2\\pi i_a}{L_a}$ 对于 $i_a \\in \\{0,\\dots,N_a-1\\}$，无环绕；移位映射：$k_a = \\dfrac{2\\pi s_a}{L_a}$。零频和奈奎斯特模式处理：只有零频模式必须是实数；奈奎斯特模式可以是具有独立实部和虚部的复数，因为它们的负值在别处表示。\n\nC. 未移位映射：当 $i_a  \\tfrac{N_a}{2}$ 时为 $m_a(i_a) = i_a$，当 $i_a \\ge \\tfrac{N_a}{2}$ 时为 $m_a(i_a) = \\tfrac{N_a}{2} - i_a$；移位映射：对所有 $s_a$ 为 $m_a(s_a) = s_a$。物理波数是 $k_a = \\dfrac{m_a}{\\Delta_a}$，不带因子 $2\\pi$。零频和奈奎斯特模式处理：仅当恰好一个轴处于奈奎斯特值时才将虚部设置为零；零频模式无需约束，因为厄米对称性将在逆 FFT 后强制实现实数性质。\n\nD. 未移位映射：对所有 $i_a$ 为 $m_a(i_a) = i_a - N_a$；移位映射：$m_a(s_a) = s_a - N_a$ 以使负索引占据前半部分，但零频率在索引 $s_a = N_a$ 处。物理波数是 $k_a = \\dfrac{\\pi m_a}{L_a}$，限制在范围 $\\lvert k_a \\rvert \\le \\dfrac{\\pi}{\\Delta_a}$ 内。零频和奈奎斯特模式处理：将所有模式（包括零频和奈奎斯特模式）视为独立的复数自由度，并依赖数值舍入来抵消实空间中的虚部。", "solution": "我们从有限三维域上的周期性傅里叶级数开始。对于每个轴 $a \\in \\{x,y,z\\}$，长度为 $L_a$ 的周期域上场的连续表示允许具有物理波数的离散傅里叶模式\n$$\nk_a = \\frac{2\\pi m_a}{L_a}, \\quad m_a \\in \\mathbb{Z}.\n$$\n在均匀网格 $\\{n_a \\in \\{0,\\dots,N_a-1\\}\\}$ 上的采样选择这些整数 $m_a$ 的一个有限集合，及其相关的离散傅里叶变换系数 $\\tilde{\\delta}(\\mathbf{k}_{\\mathbf{m}})$，逆变换通过以下方式重构场：\n$$\n\\delta(\\mathbf{x}_{\\mathbf{n}}) = \\sum_{m_x} \\sum_{m_y} \\sum_{m_z} \\tilde{\\delta}(\\mathbf{k}_{\\mathbf{m}}) \\exp\\!\\left(i \\left(\\frac{2\\pi m_x}{L_x} n_x \\Delta_x + \\frac{2\\pi m_y}{L_y} n_y \\Delta_y + \\frac{2\\pi m_z}{L_z} n_z \\Delta_z\\right)\\right),\n$$\n其中 $\\Delta_a = L_a/N_a$ 且 $\\mathbf{x}_{\\mathbf{n}} = (n_x \\Delta_x, n_y \\Delta_y, n_z \\Delta_z)$。离散傅里叶变换以由 FFT 约定决定的特定索引顺序实现这些求和。\n\n关键在于从 FFT 数组索引到整数频率 $\\mathbf{m} = (m_x, m_y, m_z)$ 的映射，然后通过 $k_a = 2\\pi m_a / L_a$ 映射到物理 $\\mathbf{k}$。两种常见的约定是原始的“未移位”排序和“fftshifted”排序。\n\n未移位排序。对于每个轴 $a$，FFT 输出数组的索引为 $i_a \\in \\{0,1,\\dots,N_a-1\\}$。频率的排序方式是，非负整数在前，负整数在后。对于偶数 $N_a$，标准的未移位整数序列是\n$$\n0,\\;1,\\;2,\\;\\dots,\\;\\frac{N_a}{2},\\;-\\frac{N_a}{2}+1,\\;-\\frac{N_a}{2}+2,\\;\\dots,\\;-1,\n$$\n这对应于映射\n$$\nm_a(i_a) = \\begin{cases}\ni_a,  0 \\le i_a \\le \\frac{N_a}{2}\\\\\ni_a - N_a,  \\frac{N_a}{2}  i_a \\le N_a - 1\n\\end{cases}\n$$\n对于奇数 $N_a$，没有奈奎斯特整数；序列是\n$$\n0,\\;1,\\;2,\\;\\dots,\\;\\frac{N_a-1}{2},\\;-\\frac{N_a-1}{2},\\;-\\frac{N_a-1}{2}+1,\\;\\dots,\\;-1,\n$$\n映射变为\n$$\nm_a(i_a) = \\begin{cases}\ni_a,  0 \\le i_a \\le \\frac{N_a - 1}{2}\\\\\ni_a - N_a,  \\frac{N_a + 1}{2} \\le i_a \\le N_a - 1\n\\end{cases}\n$$\n这些表达式编码了负频率环绕（模 $N_a$）到索引范围的上半部分。\n\n移位排序。通过将零频率移动到数组中间的“移位”（例如“fftshift”）重新索引后，每个轴 $a$ 的整数序列是从负到正递增的。对于偶数 $N_a$，它是\n$$\n-\\frac{N_a}{2},\\;-\\frac{N_a}{2}+1,\\;\\dots,\\;-1,\\;0,\\;1,\\;\\dots,\\;\\frac{N_a}{2}-1,\n$$\n对于奇数 $N_a$，它是\n$$\n-\\frac{N_a - 1}{2},\\;-\\frac{N_a - 1}{2}+1,\\;\\dots,\\;-1,\\;0,\\;1,\\;\\dots,\\;\\frac{N_a - 1}{2}.\n$$\n一个涵盖两种情况的紧凑映射是\n$$\nm_a(s_a) = s_a - \\left\\lfloor \\frac{N_a}{2} \\right\\rfloor, \\quad s_a \\in \\{0,\\dots,N_a - 1\\},\n$$\n这会产生所需的有序整数序列。在所有情况下，物理波矢分量都由 $k_a = 2\\pi m_a/L_a$ 得到。\n\n实数性质与厄米对称性。对于实场 $\\delta(\\mathbf{x})$，离散傅里叶系数必须满足厄米对称性，\n$$\n\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast,\n$$\n以便逆变换是实数。对于 $-\\mathbf{k}$ 与 $\\mathbf{k}$ 处于不同数组索引的模式，这是通过在 $\\mathbf{k}$ 处生成一个复系数，并将其在 $-\\mathbf{k}$ 处的系数设置为其复共轭来实现的。然而，每当一个模式在离散对称性下是其自身的负值时，厄米条件就简化为 $\\tilde{\\delta}(\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$，这意味着系数是纯实数。在离散设置中，一个模式是自共轭的当且仅当，对于每个轴 $a$，整数 $m_a$ 满足\n$$\n2 m_a \\equiv 0 \\pmod{N_a},\n$$\n这意味着当 $N_a$ 为偶数时 $m_a \\in \\{0, N_a/2\\}$，当 $N_a$ 为奇数时 $m_a = 0$。因此：\n- 零频模式 $(m_x,m_y,m_z) = (0,0,0)$ 总是纯实数。\n- 对于偶数 $N_a$，任何每个分量 $m_a \\in \\{0, N_a/2\\}$ 的“角落”组合都是自共轭的，并且必须是纯实数。在 $d$ 维空间中，最多有 $2^d$ 个这样的点（对于 $d=3$，最多有 8 个点），这取决于哪些轴具有偶数尺寸。\n- 所有其他模式都以 $\\pm \\mathbf{k}$ 对的形式出现，并且必须设置为复共轭对。\n\n这在宇宙学初始条件生成中至关重要：对零频和奈奎斯特模式的不当处理会违反 $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$，并在实空间场中产生复数污染，从而破坏一阶位移（Zel’dovich 近似）和二阶拉格朗日微扰理论校正。\n\n我们现在评估这些选项。\n\n选项 A。此选项为偶数和奇数 $N_a$ 提供了正确的未移位映射，正确地捕捉了负整数到索引范围上半部分的环绕。它提供了紧凑的移位映射 $m_a = s_a - \\lfloor N_a/2 \\rfloor$。物理 $k_a$ 正确地由 $k_a = 2\\pi m_a/L_a$ 给出。对于实数性质处理，它正确地陈述了对不同 $\\pm \\mathbf{k}$ 的厄米配对，以及任何为其自身负值的模式（所有分量满足 $2 m_a \\equiv 0 \\pmod{N_a}$）必须是纯实数，明确包括零频模式和所有奈奎斯特角落组合。这是正确和完整的规定。\n\n结论：正确。\n\n选项 B。此选项将 $k_a$ 线性映射到原始索引 $i_a$ 而没有环绕。它没有考虑负频率，因此无法恢复有符号整数谱；它也错误地将移位索引 $s_a$ 直接映射到正的 $k_a$ 值。在处理零频和奈奎斯特模式时，它错误地声称奈奎斯特模式可以是具有独立实部和虚部的复数。这违反了当 $m_a = N_a/2$（偶数时）时模式的自共轭条件，使得逆变换不为实数。\n\n结论：不正确。\n\n选项 C。此选项提出当 $i_a  N_a/2$ 时 $m_a(i_a) = i_a$，否则 $m_a(i_a) = N_a/2 - i_a$，这不是标准的未移位映射，并且产生不正确的负频率索引（例如，它以不匹配模 $N_a$ 算术的方式翻转符号和大小）。移位映射 $m_a(s_a) = s_a$ 也是错误的，因为它未能将零点居中并包含负整数。物理波数 $k_a = m_a/\\Delta_a$ 缺少必要的因子 $2\\pi$ 并使用错误的缩放。零频和奈奎斯特处理不正确：自共轭性取决于所有轴，而不仅仅是恰好一个轴在奈奎斯特值，并且零频模式必须明确约束为实数。\n\n结论：不正确。\n\n选项 D。此选项对所有 $i_a$ 设置 $m_a(i_a) = i_a - N_a$，这会错误地移动整个频谱并将零频率放在一个负整数处，不匹配任何常见的 FFT 排序。移位映射 $m_a(s_a) = s_a - N_a$ 同样将零点错误地放在索引 $N_a$ 处，这超出了有效范围。物理波数 $k_a = \\pi m_a/L_a$ 缺少了因子 $2$，并且所述的限制 $\\lvert k_a \\rvert \\le \\pi/\\Delta_a$ 是一个采样理论的陈述，而不是一个映射规则；此外，映射本身是错误的。将零频和奈奎斯特模式视为独立的复数自由度的处理方法是错误的，并且不能确保实数逆场。\n\n结论：不正确。\n\n因此，唯一正确提供了常见 FFT 约定的索引到 $\\mathbf{k}$ 映射以及保持实场一致性所需的零频/奈奎斯特处理的选项是 A。", "answer": "$$\\boxed{A}$$", "id": "3512441"}, {"introduction": "二阶拉格朗日微扰理论（2LPT）的方程包含非线性项，这使得其数值实现可能非常棘手。验证复杂数值代码的一个强大技术是，将其与一个“人造解”——即一个具有已知解析答案的简化问题——进行对比 [@problem_id:3512423]。本练习将指导您创建一个这样的测试框架，利用一个简单的、基于余弦函数的势场来验证您计算的 2LPT 位移场是否与精确的理论结果相符。", "problem": "设计并实现一个独立的程序，构建一个周期性的三维拉格朗日微扰理论测试框架，用于验证由初始势中已知的潮汐四极矩引起的二阶拉格朗日微扰理论 (2LPT) 各向异性位移。在边长为 $L$ 的周期性立方体上完全使用无量纲量进行计算，并使用离散傅里叶变换求解泊松型方程。程序必须生成单行输出，包含一个浮点值列表，每个值对应于指定测试用例下，2LPT 位移的数值计算与解析的均方根 (RMS) 分量之间的最大相对误差。\n\n从以下基础开始：\n- 拉格朗日位移展开为 $\\boldsymbol{\\Psi} = \\sum_{n \\ge 1} \\boldsymbol{\\Psi}^{(n)}$，其中 $\\boldsymbol{\\Psi}^{(n)} = -\\boldsymbol{\\nabla} \\phi^{(n)}$，$n$ 阶标量势为 $\\phi^{(n)}$。\n- 在二阶拉格朗日微扰理论 (2LPT) 中，标量势的控制二阶方程为\n$$\n\\nabla^2 \\phi^{(2)}(\\boldsymbol{x}) \\;=\\; \\sum_{ij} \\left( \\phi^{(1)}_{,ii}(\\boldsymbol{x}) \\, \\phi^{(1)}_{,jj}(\\boldsymbol{x}) \\;-\\; \\left[\\phi^{(1)}_{,ij}(\\boldsymbol{x})\\right]^2 \\right),\n$$\n其中 $\\phi^{(1)}_{,ij} \\equiv \\partial_i \\partial_j \\phi^{(1)}$。\n\n通过规定以下形式，将一个已知的、空间周期性的潮汐四极矩注入初始（一阶）势中\n$$\n\\phi^{(1)}(\\boldsymbol{x}) \\;=\\; A \\sum_{i \\in \\{x,y,z\\}} a_i \\cos\\!\\left( K \\, x_i \\right),\n$$\n其中 $A$ 是一个无量纲振幅，$\\boldsymbol{a} = (a_x,a_y,a_z)$ 是一个编码四极各向异性的无量纲系数三元组，$K = 2\\pi m / L$ 是基准波数，整数模式指数为 $m$。使用 $m = 1$。在周期性立方体 $[0,L)^3$ 上的一个包含 $N^3$ 个点的规则网格上进行计算。\n\n需要实现的任务：\n1. 仅使用一阶二阶导数，构造 2LPT 标量势的实空间源项，\n$$\nS(\\boldsymbol{x}) \\;\\equiv\\; \\sum_{ij} \\left( \\phi^{(1)}_{,ii} \\phi^{(1)}_{,jj} - \\left[\\phi^{(1)}_{,ij}\\right]^2 \\right).\n$$\n对于上述可分离的余弦拟设，当 $i \\neq j$ 时 $\\phi^{(1)}_{,ij} = 0$，且 $\\phi^{(1)}_{,ii} = -A \\, a_i \\, K^2 \\cos(K x_i)$，因此\n$$\nS(\\boldsymbol{x}) \\;=\\; A^2 K^4 \\left( a_x a_y \\cos(K x) \\cos(K y) \\;+\\; a_x a_z \\cos(K x) \\cos(K z) \\;+\\; a_y a_z \\cos(K y) \\cos(K z) \\right).\n$$\n2. 在周期性立方体上使用谱方法求解二阶势的泊松方程，\n$$\n\\nabla^2 \\phi^{(2)}(\\boldsymbol{x}) \\;=\\; S(\\boldsymbol{x}),\n$$\n其中 $\\phi^{(2)}$ 满足周期性边界条件且均值为零。在傅里叶空间中，对于每个非零波矢量 $\\boldsymbol{k} = (k_x,k_y,k_z)$（其中 $k^2 = k_x^2 + k_y^2 + k_z^2$），解满足\n$$\n\\tilde{\\phi}^{(2)}(\\boldsymbol{k}) \\;=\\; - \\frac{\\tilde{S}(\\boldsymbol{k})}{k^2}, \\quad \\text{and} \\quad \\tilde{\\phi}^{(2)}(\\boldsymbol{0}) \\;=\\; 0,\n$$\n其中波浪号表示离散傅里叶变换。\n3. 通过谱微分计算二阶位移场，\n$$\n\\tilde{\\Psi}^{(2)}_i(\\boldsymbol{k}) \\;=\\; i k_i \\, \\tilde{\\phi}^{(2)}(\\boldsymbol{k}), \\quad \\text{and inverse transform to obtain } \\Psi^{(2)}_i(\\boldsymbol{x}).\n$$\n4. 在整个网格上计算每个分量的数值均方根 (RMS)，\n$$\n\\mathrm{RMS}^{\\mathrm{num}}_i \\;=\\; \\sqrt{\\langle \\left(\\Psi^{(2)}_i(\\boldsymbol{x})\\right)^2 \\rangle_{\\boldsymbol{x}} }.\n$$\n5. 对于所选的可分离余弦拟设，推导并评估解析均方根。利用均匀网格上各坐标因子之间的独立性以及 $\\langle \\sin^2(K x_i) \\rangle = 1/2$，$\\langle \\cos^2(K x_i) \\rangle = 1/2$，第 $i$ 个分量的均方根为\n$$\n\\mathrm{RMS}^{\\mathrm{ana}}_i \\;=\\; \\frac{A^2 K^3}{4} \\, \\sqrt{ a_i^2 \\left( \\sum_{j \\neq i} a_j^2 \\right) }.\n$$\n6. 对于每个指定的测试用例，报告各分量中的最大相对误差，\n$$\n\\epsilon_{\\max} \\;=\\; \\max_{i \\in \\{x,y,z\\}} \\begin{cases}\n\\left| \\dfrac{\\mathrm{RMS}^{\\mathrm{num}}_i - \\mathrm{RMS}^{\\mathrm{ana}}_i}{\\mathrm{RMS}^{\\mathrm{ana}}_i} \\right|,  \\mathrm{if}\\ \\mathrm{RMS}^{\\mathrm{ana}}_i \\neq 0, \\\\\n\\left| \\mathrm{RMS}^{\\mathrm{num}}_i \\right|,  \\mathrm{if}\\ \\mathrm{RMS}^{\\mathrm{ana}}_i = 0.\n\\end{cases}\n$$\n\n数值实现要求：\n- 所有测试均使用边长为 $L = 1$、网格大小为 $N = 64$ 的周期性立方体。\n- 使用 $m = 1$，因此 $K = 2\\pi$。\n- 使用离散傅里叶变换，其波数为 $k_i = 2\\pi \\, n_i / L$，其中 $n_i$ 是对应于大小为 $N$ 的网格上离散傅里叶变换的标准整频率。\n- 全程使用无量纲单位。\n\n测试套件：\n- 用例 1：$(A, a_x, a_y, a_z) = (0.05, 1, -1, 0)$。\n- 用例 2：$(A, a_x, a_y, a_z) = (0.1, 1, 1, -2)$。\n- 用例 3：$(A, a_x, a_y, a_z) = (0.2, 0, 0, 0)$。\n\n要求输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序列出结果，例如 $[\\epsilon_1,\\epsilon_2,\\epsilon_3]$。每个 $\\epsilon_i$ 都必须是浮点数。\n\n不出现物理单位；所有量都严格无量纲。当角度出现在三角函数内部时，根据离散傅里叶表示的构造，其单位为弧度。", "solution": "用户提供的问题经评估有效。该问题在科学上是合理的，提法恰当，客观，并包含唯一解所需的所有必要信息。核心任务是实现一个针对二阶拉格朗日微扰理论 (2LPT) 的数值测试，并与一个预设的解析解进行对比，这是计算宇宙学中的标准验证程序。该方法依赖于在周期域上求解微分方程的傅里叶分析的既定原则。\n\n以下是对所实现解决方案的原则性、分步描述。\n\n程序的目标是，针对特定的初始条件，计算数值计算出的二阶拉格朗日位移场 $\\boldsymbol{\\Psi}^{(2)}$ 与其已知解析对应物之间的最大相对误差。整个过程在一个三维周期性网格上进行。\n\n**1. 网格和常数初始化**\n模拟区域是一个边长为 $L=1$ 的周期性立方体，离散化为一个包含 $N^3$ 个点的规则网格，其中 $N=64$。初始势的基准波数为 $K = 2\\pi m / L$，其中模式指数为 $m=1$。由于 $L=1$，这简化为 $K=2\\pi$。我们构造三维坐标数组 $x, y, z$，代表网格点 $(x_i, y_j, z_k)$，其中 $i,j,k \\in \\{0, 1, \\dots, N-1\\}$。\n\n**2. 构造 2LPT 源项**\n问题从一个预设的一阶势 $\\phi^{(1)}$ 开始，这是一个可分离的余弦拟设：\n$$\n\\phi^{(1)}(\\boldsymbol{x}) \\;=\\; A \\sum_{i \\in \\{x,y,z\\}} a_i \\cos\\!\\left( K \\, x_i \\right)\n$$\n二阶势 $\\phi^{(2)}$ 的源项 $S(\\boldsymbol{x})$ 由 $\\phi^{(1)}$ 的导数定义：\n$$\nS(\\boldsymbol{x}) \\;\\equiv\\; \\sum_{ij} \\left( \\phi^{(1)}_{,ii} \\phi^{(1)}_{,jj} - \\left[\\phi^{(1)}_{,ij}\\right]^2 \\right)\n$$\n对于给定的 $\\phi^{(1)}$ 的可分离形式，当 $i \\neq j$ 时，交叉导数 $\\phi^{(1)}_{,ij}$ 为零。二阶导数为 $\\phi^{(1)}_{,ii} = -A \\, a_i \\, K^2 \\cos(K x_i)$。将这些代入 $S(\\boldsymbol{x})$ 的定义，得到代码中使用的解析表达式：\n$$\nS(\\boldsymbol{x}) \\;=\\; A^2 K^4 \\left( a_x a_y \\cos(K x) \\cos(K y) \\;+\\; a_x a_z \\cos(K x) \\cos(K z) \\;+\\; a_y a_z \\cos(K y) \\cos(K z) \\right)\n$$\n对于每个测试用例给定的参数 $A$ 和 $\\boldsymbol{a}=(a_x, a_y, a_z)$，在实空间网格上计算该源项。\n\n**3. 二阶势的谱方法求解**\n二阶势 $\\phi^{(2)}$ 受泊松方程 $\\nabla^2 \\phi^{(2)}(\\boldsymbol{x}) = S(\\boldsymbol{x})$ 控制。在周期域上，使用谱方法求解该方程最为高效。\n首先，使用三维快速傅里叶变换 (FFT) 将源项变换到傅里叶空间，$\\tilde{S}(\\boldsymbol{k}) = \\mathcal{F}[S(\\boldsymbol{x})]$，这是用 `scipy.fft.fftn` 实现的。\n在傅里叶空间中，拉普拉斯算子 $\\nabla^2$ 变为乘以 $-k^2$，其中 $k^2 = k_x^2 + k_y^2 + k_z^2$ 是波矢量 $\\boldsymbol{k}$ 的模的平方。与网格对应的离散波矢量 $k_i$ 使用 `scipy.fft.fftfreq` 生成。\n因此，泊松方程变换为势的傅里叶模式的代数方程：\n$$\n-k^2 \\tilde{\\phi}^{(2)}(\\boldsymbol{k}) = \\tilde{S}(\\boldsymbol{k}) \\quad \\implies \\quad \\tilde{\\phi}^{(2)}(\\boldsymbol{k}) = - \\frac{\\tilde{S}(\\boldsymbol{k})}{k^2}\n$$\n该解对所有 $\\boldsymbol{k} \\neq \\boldsymbol{0}$ 均有效。对于零频模式（$\\boldsymbol{k}=\\boldsymbol{0}$），除以 $k^2=0$ 是未定义的。势的均值为零的物理约束，$\\langle \\phi^{(2)} \\rangle=0$，将傅里叶空间的直流分量设为零，即 $\\tilde{\\phi}^{(2)}(\\boldsymbol{0})=0$。这在代码中得到了明确处理。\n\n**4. 2LPT 位移场的计算**\n2LPT 位移场是势的负梯度，$\\boldsymbol{\\Psi}^{(2)} = -\\boldsymbol{\\nabla}\\phi^{(2)}$。与拉普拉斯算子类似，梯度算子在傅里叶空间中有简单的表示：$\\mathcal{F}[\\boldsymbol{\\nabla} f(\\boldsymbol{x})] = i\\boldsymbol{k}\\tilde{f}(\\boldsymbol{k})$。\n因此，位移场分量的傅里叶模式通过以下方式计算：\n$$\n\\tilde{\\Psi}^{(2)}_i(\\boldsymbol{k}) = -i k_i \\tilde{\\phi}^{(2)}(\\boldsymbol{k})\n$$\n一旦计算出傅里叶空间位移分量 $\\tilde{\\Psi}^{(2)}_i(\\boldsymbol{k})$，就使用逆 FFT (`scipy.fft.ifftn`) 将它们变换回实空间。由于原始场是实数，所得的位移分量 $\\Psi^{(2)}_i(\\boldsymbol{x})$ 也必须是实数。我们明确地取逆 FFT 输出的实部，以舍弃由浮点不精确性引起的任何微小的、虚假的虚部。\n\n**5. 验证与误差计算**\n过程的最后一部分是验证数值结果。\n每个位移分量的数值均方根 (RMS) 通过对整个网格上场值的平方取均值后再开方来计算：\n$$\n\\mathrm{RMS}^{\\mathrm{num}}_i \\;=\\; \\sqrt{\\frac{1}{N^3} \\sum_{\\boldsymbol{x}} \\left(\\Psi^{(2)}_i(\\boldsymbol{x})\\right)^2 }\n$$\n这是使用 `numpy.sqrt` 和 `numpy.mean` 实现的。\n将这些数值结果与问题陈述中提供的解析推导的 RMS 值进行比较：\n$$\n\\mathrm{RMS}^{\\mathrm{ana}}_i \\;=\\; \\frac{A^2 K^3}{4} \\, \\sqrt{ a_i^2 \\left( \\sum_{j \\neq i} a_j^2 \\right) }\n$$\n对于每个分量 $i \\in \\{x,y,z\\}$，计算相对误差。需要进行条件检查以处理解析 RMS 为零的情况。如果 $\\mathrm{RMS}^{\\mathrm{ana}}_i = 0$，则误差定义为数值 RMS 的绝对值 $|\\mathrm{RMS}^{\\mathrm{num}}_i|$。否则，它是标准的相对误差 $|\\mathrm{RMS}^{\\mathrm{num}}_i - \\mathrm{RMS}^{\\mathrm{ana}}_i| / |\\mathrm{RMS}^{\\mathrm{ana}}_i|$。\n每个测试用例的最终输出是这三个分量误差中的最大值 $\\epsilon_{\\max}$。对所有指定的测试用例重复此整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef compute_2lpt_error(params):\n    \"\"\"\n    Computes the maximum relative error for 2LPT displacement for one test case.\n\n    This function implements the full chain:\n    1. Set up the grid and initial potential parameters.\n    2. Compute the real-space source term S(x).\n    3. Solve the Poisson equation for phi^(2) in Fourier space.\n    4. Compute the displacement field Psi^(2) via spectral differentiation.\n    5. Calculate numerical and analytical RMS values.\n    6. Return the maximum relative error across components.\n    \"\"\"\n    # Unpack test case parameters\n    A, ax, ay, az = params\n\n    # Numerical and physical constants\n    L = 1.0\n    N = 64\n    m = 1\n    K = 2.0 * np.pi * m / L\n\n    # 1. Construct the real-space grid\n    grid_1d = np.arange(N, dtype=float) * L / N\n    # Use 'ij' indexing for coordinate arrays to match the typical (x,y,z) loop order\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # 2. Construct the real-space source term for the 2LPT scalar potential\n    S = A**2 * K**4 * (\n        ax * ay * np.cos(K * x) * np.cos(K * y) +\n        ax * az * np.cos(K * x) * np.cos(K * z) +\n        ay * az * np.cos(K * y) * np.cos(K * z)\n    )\n\n    # 3. Solve the Poisson equation using spectral methods\n    # Fourier transform the source term\n    S_k = fft.fftn(S)\n\n    # Create the k-space grid of wavevectors\n    k_freq = fft.fftfreq(N, d=L / N) * 2.0 * np.pi\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    \n    # Calculate k-squared, handling the k=0 mode to avoid division by zero\n    k_squared = kx**2 + ky**2 + kz**2\n    # The [0,0,0] element is the DC mode (k=0).\n    # Temporarily set k_squared[0,0,0] to a non-zero value to avoid a warning.\n    k_squared[0, 0, 0] = 1.0\n\n    # Solve for phi_2_k = -S_k / k^2\n    phi2_k = -S_k / k_squared\n    # Enforce zero mean for phi^(2) by setting the k=0 mode to zero.\n    phi2_k[0, 0, 0] = 0.0\n\n    # 4. Compute the second-order displacement field by spectral differentiation\n    # Psi_i = -grad_i phi  =  Psi_i_k = -i * k_i * phi_k\n    Psi2x_k = -1j * kx * phi2_k\n    Psi2y_k = -1j * ky * phi2_k\n    Psi2z_k = -1j * kz * phi2_k\n\n    # Inverse transform to get real-space displacement fields\n    Psi2x = fft.ifftn(Psi2x_k).real\n    Psi2y = fft.ifftn(Psi2y_k).real\n    Psi2z = fft.ifftn(Psi2z_k).real\n\n    # 5. Compute the numerical RMS of each displacement component\n    rms_num_x = np.sqrt(np.mean(Psi2x**2))\n    rms_num_y = np.sqrt(np.mean(Psi2y**2))\n    rms_num_z = np.sqrt(np.mean(Psi2z**2))\n    rms_num = np.array([rms_num_x, rms_num_y, rms_num_z])\n\n    # 6. Derive and evaluate the analytic RMS\n    prefactor = (A**2 * K**3) / 4.0\n    a = np.array([ax, ay, az])\n    \n    rms_ana_x = prefactor * np.sqrt(a[0]**2 * (a[1]**2 + a[2]**2))\n    rms_ana_y = prefactor * np.sqrt(a[1]**2 * (a[0]**2 + a[2]**2))\n    rms_ana_z = prefactor * np.sqrt(a[2]**2 * (a[0]**2 + a[1]**2))\n    rms_ana = np.array([rms_ana_x, rms_ana_y, rms_ana_z])\n\n    # 7. Compute the maximum relative error across components\n    errors = np.zeros(3)\n    for i in range(3):\n        if rms_ana[i] != 0.0:\n            errors[i] = np.abs((rms_num[i] - rms_ana[i]) / rms_ana[i])\n        else:\n            errors[i] = np.abs(rms_num[i])\n            \n    return np.max(errors)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.05, 1.0, -1.0, 0.0),   # Case 1\n        (0.1, 1.0, 1.0, -2.0),    # Case 2\n        (0.2, 0.0, 0.0, 0.0),     # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        max_error = compute_2lpt_error(case)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3512423"}, {"introduction": "在建立了数值基础并验证了核心算法之后，我们现在可以着手构建一个完整的初始条件生成器。这项综合性练习要求您创建一个程序，该程序能从给定的功率谱和转移函数出发，生成一个随机的、包含多种组分（例如冷暗物质和重子）的宇宙初始条件 [@problem_id:3512400]。您将实现完整的 2LPT 流水线，并对输出场的统计特性进行必要的验证检查，以确保代码能产生物理上和统计上都正确的结果。", "problem": "您的任务是构建一个程序，使用高斯随机场和二阶拉格朗日微扰理论 (2LPT)，在周期性立方体区域上为两种无压强组分生成三维宇宙学初始条件。该程序必须计算特定组分的傅里叶空间超密度场，使用由总物质场源引起的一阶 Zel'dovich 近似和 2LPT 计算位移，并验证总物质功率谱等于基于组分分数和转移函数的理论预期加权和。\n\n使用一个边长为 $L$、包含 $N^3$ 个均匀间隔单元格并具有周期性边界条件的立方体网格。完全在无量纲系统中工作；不需要物理单位。如果傅里叶波数的定义中隐式出现任何角度量，请使用弧度。\n\n基本原理：\n- 区域是一个周期性立方体，傅里叶波数为 $k_x = \\frac{2\\pi}{L} n_x$, $k_y = \\frac{2\\pi}{L} n_y$, $k_z = \\frac{2\\pi}{L} n_z$，其中 $n_i \\in \\mathbb{Z}$ 是由快速傅里叶变换 (FFT) 定义的整数网格波指数。\n- 一个统计上均匀且各向同性的高斯随机场 $\\delta(\\mathbf{x})$ 在傅里叶空间中由 $\\delta(\\mathbf{k}) = \\sqrt{P(k)}\\,G(\\mathbf{k})$ 定义，其中 $P(k)$ 是各向同性功率谱，$G(\\mathbf{k})$ 是一个复高斯随机场，其均值为零，每个独立模式的方差为单位值，并具有确保 $\\delta(\\mathbf{x})$ 为实数的厄米共轭对称性。\n- 对于质量分数为 $f_1$ 和 $f_2$ (满足 $f_1 + f_2 = 1$) 的两种组分，绝热构造使用单个高斯随机场 $G(\\mathbf{k})$ 和组分转移函数 $T_1(k)$ 和 $T_2(k)$，使得 $\\delta_1(\\mathbf{k}) = T_1(k)\\sqrt{P_0(k)}\\,G(\\mathbf{k})$ 和 $\\delta_2(\\mathbf{k}) = T_2(k)\\sqrt{P_0(k)}\\,G(\\mathbf{k})$。总物质超密度为 $\\delta_m(\\mathbf{k}) = f_1\\delta_1(\\mathbf{k}) + f_2\\delta_2(\\mathbf{k})$。\n- 对于 $\\mathbf{k} \\neq \\mathbf{0}$，一阶拉格朗日位移 (Zel'dovich) 场满足 $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = i\\,\\frac{\\mathbf{k}}{k^2}\\,\\delta_m(\\mathbf{k})$，零模式设置为零。\n- 通过泊松关系 $\\nabla^2 \\phi^{(1)}(\\mathbf{x}) = \\delta_m(\\mathbf{x})$ 定义一阶势 $\\phi^{(1)}$，即对于 $\\mathbf{k} \\neq \\mathbf{0}$，$\\phi^{(1)}(\\mathbf{k}) = -\\delta_m(\\mathbf{k})/k^2$，且在 $\\mathbf{k}=\\mathbf{0}$ 处为零。标准 2LPT 源项在实空间中为\n$$\nS_2(\\mathbf{x}) = \\sum_{ij}\\Big(\\phi^{(1)}_{,ii}(\\mathbf{x})\\,\\phi^{(1)}_{,jj}(\\mathbf{x}) - \\left[\\phi^{(1)}_{,ij}(\\mathbf{x})\\right]^2\\Big),\n$$\n其中逗号表示空间导数。2LPT 势满足 $\\nabla^2 \\phi^{(2)}(\\mathbf{x}) = S_2(\\mathbf{x})$，因此对于 $\\mathbf{k} \\neq \\mathbf{0}$，$\\phi^{(2)}(\\mathbf{k}) = -S_2(\\mathbf{k})/k^2$，二阶位移为 $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{x}) = -\\nabla \\phi^{(2)}(\\mathbf{x})$。\n\n程序要求：\n1. 构造各向同性基础功率谱\n$$\nP_0(k) = A\\,k^{n}\\,\\exp\\left[-\\left(\\frac{k}{k_c}\\right)^8\\right],\n$$\n其中常数 $A$、$n$ 和 $k_c$ 在每个测试案例中提供。设总物质转移函数为 $T_m(k) \\equiv 1$。对于组分 1，使用形状\n$$\nT_1(k) = 1 + a\\,e^{-(k/k_0)^2} - \\tfrac{1}{2}a\\,e^{-(k/k_1)^2},\n$$\n其中参数 $a$、$k_0$ 和 $k_1$ 在每个测试案例中给出。通过定义\n$$\nT_2(k) = \\frac{T_m(k) - f_1 T_1(k)}{f_2},\n$$\n来强制执行绝热性（对于 $f_2 \\neq 0$）。在两种组分中使用相同的实现 $G(\\mathbf{k})$，使得\n$\n\\delta_s(\\mathbf{k}) = T_s(k)\\sqrt{P_0(k)}\\,G(\\mathbf{k})\n$\n对于 $s\\in\\{1,2\\}$ 成立，并且\n$\n\\delta_m(\\mathbf{k}) = \\left[f_1 T_1(k) + f_2 T_2(k)\\right]\\sqrt{P_0(k)}\\,G(\\mathbf{k})\n$\n成立。通过对实空间白噪声场进行 FFT 来生成 $G(\\mathbf{k})$ 以确保厄米共轭对称性，并在完整的三维网格上传输所有场。\n\n2. 根据 $\\delta_m(\\mathbf{k})$ 计算一阶 Zel'dovich 位移 $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k})$。通过在傅里叶空间中求解泊松方程计算 $\\phi^{(1)}$，通过谱方法微分构造二阶导数 $\\phi^{(1)}_{,ij}(\\mathbf{x})$，组装 $S_2(\\mathbf{x})$，求解 $\\phi^{(2)}(\\mathbf{k})$，并计算二阶位移 $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{x})$。\n\n3. 总物质场的验证：\n   - 通过将 $|\\delta_m(\\mathbf{k})|^2$ 分箱到 $k$ 空间中宽度为 $\\Delta k = 2\\pi/L$ 的球壳中，来估计球平均的总物质功率谱，排除零模式和任何贡献模式数少于最小数量的球壳（选择一个确保数值稳定性的阈值）。\n   - 对于每个球壳，通过将\n   $$\n   \\left|G(\\mathbf{k})\\right|^2\\,\\left[f_1 T_1(k) + f_2 T_2(k)\\right]^2 P_0(k)\n   $$\n   在同一球壳中的相同模式上进行分箱来计算预测功率。计算测量到的分箱功率与预测的分箱功率之比。报告在所有接受的球壳中的最大绝对分数偏差，限制在奈奎斯特波数的一个保守分数以下，以避免网格极限处的各向异性。\n   - 通过使用谱方法导数计算恒等式 $-\\nabla\\cdot\\boldsymbol{\\Psi}^{(1)}(\\mathbf{x}) = \\delta_m(\\mathbf{x})$ 的相对均方根误差，独立验证一阶运动学一致性。报告此相对误差。\n\n您的程序必须实现以上内容，并为每个测试案例生成一对浮点数：功率谱检查中的最大绝对分数偏差，以及一阶散度恒等式的相对均方根误差。将所有测试案例的结果聚合为单个输出行上的列表的列表。不要打印任何额外的文本。\n\n测试套件：\n为以下三个测试案例提供结果。所有符号如上定义，所有数字应解释为与所选单位一致的无量纲值：\n- 案例 A (一般情况)：$N=32$，$L=200$，$f_1=0.84$，$f_2=0.16$，$A=1$，$n=1$，$k_c=3$，$a=0.2$，$k_0=0.3$，$k_1=1.0$。\n- 案例 B (接近单组分极限)：$N=24$，$L=150$，$f_1=0.99$，$f_2=0.01$，$A=1$，$n=1$，$k_c=3$，$a=-0.3$，$k_0=0.4$，$k_1=1.2$。\n- 案例 C (具有更强尺度依赖性的均等分数)：$N=28$，$L=220$，$f_1=0.5$，$f_2=0.5$，$A=1$，$n=1$，$k_c=3$，$a=0.5$，$k_0=0.25$，$k_1=0.9$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，其中每个元素本身是每个测试案例的两个浮点数的双元素列表。例如，格式必须完全是\n$\n[[x_1,y_1],[x_2,y_2],[x_3,y_3]]\n$\n且行中没有任何空格。", "solution": "用户的问题被评估为有效。它在科学上基于标准的宇宙学微扰理论框架，问题阐述清晰，对于给定的随机种子，有一条明确的算法路径可以得到唯一解，并且所有必要的参数和方程都已提供。该任务是计算宇宙学中一个标准的、尽管是多步骤的过程。\n\n解决方案通过实现指定的算法来执行。核心步骤是：1) 在傅里叶空间中设置计算网格，2) 生成具有适当统计属性的高斯随机场，3) 构建物质密度场和 LPT 位移场，以及 4) 执行所需的验证检查。\n\n**1. 网格和波数表示**\n模拟在尺寸为 $N \\times N \\times N$ 的立方体网格上进行，该网格代表一个边长为 $L$ 的物理体积。我们在傅里叶空间中操作，这对于周期性区域是自然的。离散波矢量由 $\\mathbf{k} = (k_x, k_y, k_z)$ 给出，其中每个分量 $k_i$（对于 $i \\in \\{x, y, z\\}$）定义为 $k_i = \\frac{2\\pi}{L} n_i$。索引 $n_i$ 是整数，跨越适合快速傅里叶变换 (FFT) 的范围，通常从 $-N/2$ 到 $N/2-1$。这些波矢量分量很容易使用 `numpy.fft.fftfreq` 和 `numpy.meshgrid` 生成三维数组 $k_x, k_y, k_z$。从这些数组中，计算每个波矢量的模 $k = \\sqrt{k_x^2 + k_y^2 + k_z^2}$。必须小心处理 $\\mathbf{k}=\\mathbf{0}$ 的特殊情况（“直流模式”），以避免在后续步骤中出现除以零的情况。预先计算一个波数平方的倒数场 $1/k^2$，并将其在 $k=0$ 处的值显式设置为 0。\n\n**2. 高斯随机场的生成**\n一个统计上均匀且各向同性的高斯随机场在傅里叶空间中由其模式 $\\delta(\\mathbf{k})$ 来表征。这些模式的相位是随机的，它们的振幅从瑞利分布中抽取，使得 $\\langle |\\delta(\\mathbf{k})|^2 \\rangle = P(k)$，其中 $P(k)$ 是功率谱。为了保证该场在位形空间中是实数，傅里叶模式必须服从厄米共轭对称性条件 $\\delta(-\\mathbf{k}) = \\delta^*(\\mathbf{k})$。\n\n问题指定生成一个复高斯场 $G(\\mathbf{k})$，其均值为零，每个独立模式的方差为单位值，并具有厄米共轭对称性。满足这些属性的一个有效方法是首先生成一个实空间白噪声场 $w(\\mathbf{x})$，通过从标准正态分布中抽取 $N^3$ 个值。这个实数场的 FFT，$G(\\mathbf{k}) = \\mathcal{F}[w(\\mathbf{x})]$，自动满足厄米共轭属性。通过显式地将 $k=0$ 模式置零，$G(\\mathbf{k}=\\mathbf{0})=0$，来将场的均值设置为零。\n\n**3. 物质场和位移场的构建**\n在建立了基础随机场 $G(\\mathbf{k})$ 之后，我们构建所有其他场。\n*   **功率谱和转移函数**：对于网格上所有的 $k$ 值，计算基础功率谱 $P_0(k) = A k^n \\exp[-(k/k_c)^8]$ 和组分1的转移函数 $T_1(k) = 1 + a e^{-(k/k_0)^2} - \\frac{1}{2}a e^{-(k/k_1)^2}$。\n*   **总物质超密度**：问题指定了一个绝热设置，其中总物质转移函数 $T_m(k) \\equiv 1$。组分2的转移函数定义为 $T_2(k) = (T_m(k) - f_1 T_1(k))/f_2$。这强制使得质量加权的总转移函数 $f_1 T_1(k) + f_2 T_2(k)$ 恒等于 $T_m(k) = 1$。因此，傅里叶空间中的总物质超密度场简化为 $\\delta_m(\\mathbf{k}) = [f_1 T_1(k) + f_2 T_2(k)] \\sqrt{P_0(k)} G(\\mathbf{k}) = \\sqrt{P_0(k)} G(\\mathbf{k})$。\n\n*   **一阶 (Zel'dovich) 位移**：位移场 $\\boldsymbol{\\Psi}^{(1)}$ 与超密度通过 $\\nabla \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{x}) = -\\delta_m(\\mathbf{x})$ 相关。在傅里叶空间中，这变成 $i\\mathbf{k} \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = -\\delta_m(\\mathbf{k})$。这个初始位移的无旋性质允许我们将其写成一个势的梯度，$\\boldsymbol{\\Psi}^{(1)} = -\\nabla \\phi^{(1)}$，从而得到表达式 $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = i \\frac{\\mathbf{k}}{k^2} \\delta_m(\\mathbf{k})$。这个矢量场在傅里叶空间中按分量计算。\n\n*   **二阶 (2LPT) 位移**：2LPT 计算涉及几个步骤：\n    1.  通过求解泊松方程 $\\nabla^2 \\phi^{(1)} = \\delta_m$ 找到一阶势 $\\phi^{(1)}$。在傅里叶空间中，这是一个简单的代数关系：$\\phi^{(1)}(\\mathbf{k}) = -\\delta_m(\\mathbf{k})/k^2$。\n    2.  二阶源项 $S_2(\\mathbf{x}) = \\sum_{ij}(\\phi^{(1)}_{,ii}\\phi^{(1)}_{,jj} - [\\phi^{(1)}_{,ij}]^2)$ 在实空间中构建。这需要计算 $\\phi^{(1)}(\\mathbf{x})$ 的所有二阶空间导数。这些导数在傅里叶空间中可以高效计算，因为微分对应于与波矢量相乘：$\\phi^{(1)}_{,ij}(\\mathbf{x}) = \\mathcal{F}^{-1}[-k_i k_j \\phi^{(1)}(\\mathbf{k})]$。\n    3.  在计算了六个唯一的二阶导数（$\\phi^{(1)}_{,xx}$、$\\phi^{(1)}_{,yy}$、$\\phi^{(1)}_{,zz}$、$\\phi^{(1)}_{,xy}$、$\\phi^{(1)}_{,xz}$、$\\phi^{(1)}_{,yz}$）之后，根据 $S_2(\\mathbf{x})$ 的公式在每个网格点上将它们相乘。\n    4.  通过求解另一个泊松方程 $\\nabla^2 \\phi^{(2)} = S_2$ 找到二阶势 $\\phi^{(2)}$。同样，这也是在傅里叶空间中完成的：$\\phi^{(2)}(\\mathbf{k}) = -S_2(\\mathbf{k})/k^2$，其中 $S_2(\\mathbf{k}) = \\mathcal{F}[S_2(\\mathbf{x})]$。\n    5.  最后，二阶位移是该势的负梯度，$\\boldsymbol{\\Psi}^{(2)}(\\mathbf{x}) = -\\nabla \\phi^{(2)}(\\mathbf{x})$，在傅里叶空间中即为 $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{k}) = -i\\mathbf{k}\\,\\phi^{(2)}(\\mathbf{k})$。\n\n**4. 验证程序**\n执行两个数值检查以验证实现的正确性。\n*   **功率谱验证**：此检查将数值上实现的功率谱与理论预期进行比较。“测量”到的每个模式的功率是 $|\\delta_m(\\mathbf{k})|^2$。“预测”的功率是 $|G(\\mathbf{k})|^2 |f_1 T_1(k) + f_2 T_2(k)|^2 P_0(k)$。这两个量对于每个模式在解析上是相同的。该检查将这两个量分箱到 $k$ 空间中宽度为 $\\Delta k = 2\\pi/L$ 的球壳中。计算每个箱中总测量功率与总预测功率的比值。测试指标是最大绝对分数偏差 $\\max(|P_{\\text{meas}}/P_{\\text{pred}} - 1|)$，该偏差在所有包含足够多模式（例如，超过10个）并且位于奈奎斯特频率一半以下的箱中计算，以避免网格尺度上的各向异性。这个值应该在机器浮点精度的数量级上。\n\n*   **运动学一致性**：此检查验证一阶位移和物质超密度之间的基本关系 $-\\nabla \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{x}) = \\delta_m(\\mathbf{x})$。这个恒等式在傅里叶空间中最容易测试，它变成 $-i\\mathbf{k} \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = \\delta_m(\\mathbf{k})$（对于 $\\mathbf{k} \\neq \\mathbf{0}$）。左侧是从生成的 $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k})$ 计算的，右侧是生成的 $\\delta_m(\\mathbf{k})$。计算相对均方根误差 $\\sqrt{\\sum|\\text{LHS} - \\text{RHS}|^2 / \\sum|\\text{RHS}|^2}$，其中求和是对所有傅里叶模式进行的。这个值也应该接近机器精度，从而确认傅里叶空间算符的正确实现。\n\n该实现将这些步骤封装在一个函数中，为每个测试案例调用该函数，产生两个指定的验证指标。", "answer": "```python\nimport numpy as np\n\ndef compute_initial_conditions(N, L, f1, f2, A, n_spec, k_c, a, k0, k1):\n    \"\"\"\n    Generates cosmological initial conditions and performs verification checks.\n    \"\"\"\n    # 1. Setup Grid\n    k_vec = np.fft.fftfreq(N, d=L / N) * 2 * np.pi\n    kx, ky, kz = np.meshgrid(k_vec, k_vec, k_vec, indexing='ij')\n    k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n    \n    k_is_zero = (k_mag == 0)\n    k_mag_safe = np.where(k_is_zero, 1.0, k_mag)\n    k_sq_inv = 1.0 / k_mag_safe**2\n    k_sq_inv[k_is_zero] = 0.0\n\n    # 2. Generate Initial Random Field\n    white_noise = np.random.randn(N, N, N)\n    G_k = np.fft.fftn(white_noise)\n    G_k[0, 0, 0] = 0.0  # Enforce zero mean for the field\n\n    # Power spectrum and transfer functions\n    P0_k = A * k_mag_safe**n_spec * np.exp(-(k_mag_safe / k_c)**8)\n    P0_k[k_is_zero] = 0.0\n\n    T1_k = 1.0 + a * np.exp(-(k_mag / k0)**2) - 0.5 * a * np.exp(-(k_mag / k1)**2)\n    \n    # Total matter overdensity field (since f1*T1 + f2*T2 = 1)\n    delta_m_k = np.sqrt(P0_k) * G_k\n\n    # 3. Compute LPT Displacements\n    # First-order (Zel'dovich)\n    Psi1_kx = 1j * kx * k_sq_inv * delta_m_k\n    Psi1_ky = 1j * ky * k_sq_inv * delta_m_k\n    Psi1_kz = 1j * kz * k_sq_inv * delta_m_k\n    \n    # Second-order (2LPT)\n    phi1_k = -delta_m_k * k_sq_inv\n    \n    d2phi1_dx2_k = -kx**2 * phi1_k\n    d2phi1_dy2_k = -ky**2 * phi1_k\n    d2phi1_dz2_k = -kz**2 * phi1_k\n    d2phi1_dxdy_k = -kx * ky * phi1_k\n    d2phi1_dxdz_k = -kx * kz * phi1_k\n    d2phi1_dydz_k = -ky * kz * phi1_k\n\n    d2phi1_xx = np.fft.ifftn(d2phi1_dx2_k).real\n    d2phi1_yy = np.fft.ifftn(d2phi1_dy2_k).real\n    d2phi1_zz = np.fft.ifftn(d2phi1_dz2_k).real\n    d2phi1_xy = np.fft.ifftn(d2phi1_dxdy_k).real\n    d2phi1_xz = np.fft.ifftn(d2phi1_dxdz_k).real\n    d2phi1_yz = np.fft.ifftn(d2phi1_dydz_k).real\n    \n    S2_x = (d2phi1_xx * d2phi1_yy - d2phi1_xy**2) + \\\n           (d2phi1_xx * d2phi1_zz - d2phi1_xz**2) + \\\n           (d2phi1_yy * d2phi1_zz - d2phi1_yz**2)\n    \n    S2_k = np.fft.fftn(S2_x)\n    phi2_k = -S2_k * k_sq_inv\n\n    _ = -1j * kx * phi2_k  # Psi2_kx, not needed for verification but computed as required\n    _ = -1j * ky * phi2_k  # Psi2_ky\n    _ = -1j * kz * phi2_k  # Psi2_kz\n\n    # 4. Verification\n    \n    # 4a. Power Spectrum Check\n    P_meas_k = np.abs(delta_m_k)**2\n    \n    if f2 != 0:\n        T2_k = (1.0 - f1 * T1_k) / f2\n    else: # Should not happen based on test cases but good practice\n        T2_k = np.zeros_like(T1_k)\n    total_T_k_explicit = f1 * T1_k + f2 * T2_k\n    P_pred_k = np.abs(G_k)**2 * np.abs(total_T_k_explicit)**2 * P0_k\n\n    k_fundamental = 2 * np.pi / L\n    k_nyquist = np.pi * N / L\n    k_max_verify = k_nyquist / 2.0\n    \n    k_flat = k_mag.flatten()\n    valid_modes = ~k_is_zero.flatten()\n    k_flat_valid = k_flat[valid_modes]\n    \n    max_k_val = np.max(k_flat_valid) if k_flat_valid.size > 0 else 0\n    num_bins = int(np.ceil(max_k_val / k_fundamental)) + 1\n\n    bin_indices = np.floor(k_flat_valid / k_fundamental).astype(int)\n    \n    binned_P_meas = np.bincount(bin_indices, weights=P_meas_k.flatten()[valid_modes], minlength=num_bins)\n    binned_P_pred = np.bincount(bin_indices, weights=P_pred_k.flatten()[valid_modes], minlength=num_bins)\n    counts = np.bincount(bin_indices, minlength=num_bins)\n\n    ratios = []\n    min_modes_per_bin = 10\n    \n    for i in range(num_bins):\n        k_bin_center = (i + 0.5) * k_fundamental\n        if counts[i] >= min_modes_per_bin and binned_P_pred[i] > 1e-30 and k_bin_center  k_max_verify:\n             ratio = binned_P_meas[i] / binned_P_pred[i]\n             ratios.append(ratio)\n    \n    max_frac_dev = np.max(np.abs(np.array(ratios) - 1.0)) if ratios else 0.0\n\n    # 4b. Kinematic Consistency Check\n    LHS_k = -(1j * kx * Psi1_kx + 1j * ky * Psi1_ky + 1j * kz * Psi1_kz)\n    RHS_k = delta_m_k\n    err_k = LHS_k - RHS_k\n    \n    norm_err_sq = np.sum(np.abs(err_k)**2)\n    norm_rhs_sq = np.sum(np.abs(RHS_k)**2)\n    \n    rel_rms_err = np.sqrt(norm_err_sq / norm_rhs_sq) if norm_rhs_sq > 0 else 0.0\n\n    return [max_frac_dev, rel_rms_err]\n\ndef solve():\n    # Set a consistent seed for reproducibility of random numbers.\n    np.random.seed(42)\n\n    test_cases = [\n        # Case A\n        {'N': 32, 'L': 200, 'f1': 0.84, 'f2': 0.16, 'A': 1, 'n_spec': 1, 'k_c': 3, 'a': 0.2, 'k0': 0.3, 'k1': 1.0},\n        # Case B\n        {'N': 24, 'L': 150, 'f1': 0.99, 'f2': 0.01, 'A': 1, 'n_spec': 1, 'k_c': 3, 'a': -0.3, 'k0': 0.4, 'k1': 1.2},\n        # Case C\n        {'N': 28, 'L': 220, 'f1': 0.5, 'f2': 0.5, 'A': 1, 'n_spec': 1, 'k_c': 3, 'a': 0.5, 'k0': 0.25, 'k1': 0.9},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = compute_initial_conditions(**params)\n        results.append(result)\n\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3512400"}]}