{"hands_on_practices": [{"introduction": "宇宙学辐射流体力学的一个核心挑战是其控制方程的“刚性”问题，即不同的物理过程在迥异的时间尺度上发生。在电离化学中，复合时间尺度可能极短，这对显式时间积分方案的稳定性构成了严峻的制约。第一个实践练习 [@problem_id:3507618] 通过一个简化的单区模型，为此问题提供了基础性的理解。你将推导出一个显式求解器的稳定性条件，并实现显式和隐式两种方法，以直接比较它们在准确性、计算成本和稳定性方面的表现，从而为该领域最关键的数值挑战之一建立直观认识。", "problem": "考虑在宇宙再电离时期，一个代表星系际介质单元的单一、空间均匀控制体积中，氢电离分数 $x(t) \\in [0,1]$ 的演化。假设氢数密度 $n_{\\mathrm{H}}$ 为常数，并且由外部辐射场引起的每个氢原子的光致电离率 $\\Gamma$ 也为常数。忽略碰撞电离，并采用固定温度下的B情形复合，其复合系数为 $\\alpha_{\\mathrm{B}}$。控制该过程的常微分方程 (ODE) 为\n$$\n\\frac{dx}{dt} = (1 - x)\\,\\Gamma - \\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}\\,x^2,\n$$\n该方程源于光致电离与辐射复合之间的平衡。定义复合时标\n$$\nt_{\\mathrm{rec}} = \\frac{1}{\\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}},\n$$\n并令 $k \\equiv \\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}$。\n\n任务A (推导)：从该ODE出发，围绕稳定平衡点 $x_{\\infty}$（即 $k\\,x^2 + \\Gamma\\,x - \\Gamma = 0$ 的正根）对动力学进行线性化，并分析前向欧拉显式离散化方法。推导一个充分的时间步长条件，该条件可用一个选定的无量纲参数 $0  \\epsilon  1$ 和复合时标 $t_{\\mathrm{rec}}$ 来表示，以确保显式更新在趋近 $x_{\\infty}$ 时不产生振荡，从而防止电离分数出现步间超调。您的推导应仅使用在 $x_{\\infty}$ 处计算的右侧函数的雅可比矩阵，以及前向欧拉方法对于具有负特征值的线性测试方程的稳定性行为。从由复合主导的刚性角度解释该判据的物理意义。\n\n任务B (算法比较)：从业已给定的初值 $x(0) = x_0$ 出发，在有限时间范围 $T$ 内，为该ODE实现两种时间积分器：\n- 一种显式前向欧拉方法，\n$$\nx^{n+1} = x^n + \\Delta t\\left[(1 - x^n)\\,\\Gamma - k\\,(x^n)^2\\right].\n$$\n- 一种隐式后向欧拉方法，\n$$\nx^{n+1} = x^n + \\Delta t\\left[(1 - x^{n+1})\\,\\Gamma - k\\,(x^{n+1})^2\\right],\n$$\n该方法在每一步都归结为一个关于 $x^{n+1}$ 的二次方程；选择位于 $[0,1]$ 区间内物理上可接受的根。\n\n为获得参考精度，请使用具有常系数的Riccati方程的精确解。令 $x_1$ 和 $x_2$ 为 $k\\,x^2 + \\Gamma\\,x - \\Gamma = 0$ 的两个稳态根（其中 $x_1 > 0$ 且 $x_2  0$），并定义 $\\lambda = \\sqrt{\\Gamma^2 + 4\\,\\Gamma\\,k} = k\\,(x_1 - x_2)$。对于初始条件 $x(0) = x_0$，精确解为\n$$\nx(t) = \\frac{x_1 - C\\,e^{-\\lambda t}\\,x_2}{1 - C\\,e^{-\\lambda t}}, \\quad C = \\frac{x_0 - x_1}{x_0 - x_2}.\n$$\n\n成本模型：将显式方法的成本计为每步 $w_{\\mathrm{exp}} = 1$，隐式方法的成本计为每步 $w_{\\mathrm{imp}} = 4$，以反映额外的代数求解工作。总成本为步数乘以相应的权重。如果使用固定的 $\\Delta t$ 会导致最后一步超过总时间 $T$，则仅缩短最后一步的步长，以使总步长恰好等于 $T$。\n\n超调度量：对于显式方法，记录在积分过程中遇到的超过物理边界 $x \\le 1$ 的最大超调量，\n$$\n\\mathrm{overshoot}_{\\max} = \\max_{n}\\,\\max\\left(0, x^n - 1\\right).\n$$\n\n精度度量：报告两种积分器在最终时刻的绝对误差，\n$$\nE_{\\mathrm{exp}} = \\left|x_{\\mathrm{exp}}(T) - x_{\\mathrm{exact}}(T)\\right|,\\quad\nE_{\\mathrm{imp}} = \\left|x_{\\mathrm{imp}}(T) - x_{\\mathrm{exact}}(T)\\right|.\n$$\n\n单位：$n_{\\mathrm{H}}$ 的单位为 $\\mathrm{cm}^{-3}$，$\\alpha_{\\mathrm{B}}$ 的单位为 $\\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\Gamma$ 的单位为 $\\mathrm{s}^{-1}$，所有时间（包括 $t_{\\mathrm{rec}}$、$T$ 和 $\\Delta t$）的单位均为 $\\mathrm{s}$。初始分数 $x_0$ 和超调量是无量纲的。\n\n测试套件：您的程序必须评估以下五个科学上合理的参数集，每个参数集由一个元组 $(\\alpha_{\\mathrm{B}}, n_{\\mathrm{H}}, \\Gamma, x_0, \\epsilon, T_{\\mathrm{factor}}, \\Delta t_{\\mathrm{factor}})$ 表示，其中 $T = T_{\\mathrm{factor}}\\,t_{\\mathrm{rec}}$ 且 $\\Delta t = \\Delta t_{\\mathrm{factor}}\\,\\epsilon\\,t_{\\mathrm{rec}}$：\n- 案例1：$(2.6\\times10^{-13}, 1.0\\times10^{-2}, 1.0\\times10^{-15}, 0.0, 0.2, 2.0, 0.25)$，一个远在判据范围内的“理想”显式时间步长。\n- 案例2：$(2.6\\times10^{-13}, 1.0\\times10^{-2}, 1.0\\times10^{-15}, 0.0, 0.2, 2.0, 0.95)$，一个邻近边界、刚好低于安全裕度的显式时间步长。\n- 案例3：$(2.6\\times10^{-13}, 1.0\\times10^{-2}, 1.0\\times10^{-15}, 0.0, 0.2, 2.0, 1.2)$，一个旨在引发超调或振荡行为的超临界显式时间步长。\n- 案例4：$(2.6\\times10^{-13}, 1.0\\times10^{-1}, 2.0\\times10^{-14}, 0.0, 0.1, 1.0, 0.5)$，一个密度更高、刚性更强的情况，其显式时间步长被安全地约束。\n- 案例5：$(2.6\\times10^{-13}, 1.0\\times10^{-3}, 1.0\\times10^{-16}, 0.0, 0.3, 3.0, 1.1)$，一个低密度情况，其显式时间步长超出了判据要求。\n\n对于每个案例，还需计算编码为整数的布尔判据检查，\n$$\n\\mathrm{pass} = \\begin{cases}\n1  \\text{若 } \\Delta t \\le \\epsilon\\,t_{\\mathrm{rec}},\\\\\n0  \\text{其他情况。}\n\\end{cases}\n$$\n\n最终输出格式：您的程序应生成单行输出，其中包含汇总到列表的列表中的所有案例结果。对于每个案例，按顺序返回一个包含六个条目\n$$\n[\\mathrm{pass},\\ \\mathrm{overshoot}_{\\max},\\ E_{\\mathrm{exp}},\\ E_{\\mathrm{imp}},\\ \\mathrm{cost}_{\\mathrm{exp}},\\ \\mathrm{cost}_{\\mathrm{imp}}]\n$$\n的列表。最后一行必须是\n$$\n[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,].\n$$\n所有数值条目必须是布尔型、整型、浮点型或它们的列表。布尔值必须编码为 $0$ 或 $1$（整数）。", "solution": "该问题被评估为有效。它在科学上基于成熟的光致电离和复合理论，提出了一个具有已知解析解的适定常微分方程，并定义了一套清晰、客观的计算任务和度量标准。所提供的参数据称对于与宇宙再电离相关的环境是科学上合理的。\n\n### 任务A：时间步长条件的推导\n\n电离分数 $x(t)$ 的演化由以下常微分方程 (ODE) 控制：\n$$\n\\frac{dx}{dt} = f(x) = (1 - x)\\Gamma - kx^2\n$$\n其中 $\\Gamma$ 是光致电离率，$k = \\alpha_{\\mathrm{B}}n_{\\mathrm{H}}$ 是按氢数密度缩放的复合率系数。\n\n当 $\\frac{dx}{dt} = 0$ 时，系统达到平衡态 $x_{\\infty}$，这需要求解二次方程：\n$$\nk x_{\\infty}^2 + \\Gamma x_{\\infty} - \\Gamma = 0\n$$\n问题指明我们关心的是稳定平衡点，它对应于该方程唯一的正根，这可以通过分析系统动力学来验证。\n\n为了分析数值方法在该平衡点附近的行为，我们在 $x = x_{\\infty}$ 周围对ODE进行线性化。令 $x(t) = x_{\\infty} + \\delta x(t)$，其中 $\\delta x$ 是一个小微扰。微扰的动力学可近似为：\n$$\n\\frac{d(\\delta x)}{dt} \\approx J(x_{\\infty}) \\cdot \\delta x\n$$\n此处，$J(x)$ 是右端项 $f(x)$ 的雅可比矩阵。\n$$\nJ(x) = \\frac{df}{dx} = \\frac{d}{dx} \\left( \\Gamma - \\Gamma x - kx^2 \\right) = -\\Gamma - 2kx\n$$\n在平衡点 $x_{\\infty}$ 处计算雅可比矩阵，得到线性化系统的特征值 $\\lambda_{\\text{sys}}$：\n$$\n\\lambda_{\\text{sys}} = J(x_{\\infty}) = -\\Gamma - 2kx_{\\infty}\n$$\n由于 $\\Gamma  0$，$k  0$ 且 $x_{\\infty}  0$，该特征值恒为负，这证实了 $x_{\\infty}$ 是一个稳定不动点。\n\n应用于线性测试方程 $\\frac{dy}{dt} = \\lambda_{\\text{sys}} y$ 的前向欧拉方法由下式给出：\n$$\ny^{n+1} = y^n + \\Delta t (\\lambda_{\\text{sys}} y^n) = (1 + \\Delta t \\lambda_{\\text{sys}}) y^n\n$$\n为使数值解收敛到平衡点而不产生振荡，放大因子 $(1 + \\Delta t \\lambda_{\\text{sys}})$ 必须为非负。即：\n$$\n1 + \\Delta t \\lambda_{\\text{sys}} \\ge 0\n$$\n代入 $\\lambda_{\\text{sys}}$ 的表达式并求解时间步长 $\\Delta t$：\n$$\n1 + \\Delta t (-\\Gamma - 2kx_{\\infty}) \\ge 0 \\implies 1 \\ge \\Delta t (\\Gamma + 2kx_{\\infty}) \\implies \\Delta t \\le \\frac{1}{\\Gamma + 2kx_{\\infty}}\n$$\n这是为防止在平衡点 $x_{\\infty}$ 附近出现数值振荡而对时间步长 $\\Delta t$ 施加的严格条件。量 $\\tau_{\\text{relax}} = (\\Gamma + 2kx_{\\infty})^{-1}$ 是系统弛豫到平衡的特征时标。\n\n问题要求解释一个形式为 $\\Delta t \\le \\epsilon t_{\\mathrm{rec}}$ 的简化充分条件，其中 $t_{\\mathrm{rec}} = 1/k$。这种形式具有物理动机。项 $kx^2$ 代表复合过程，其特征时标约等于 $x / (kx^2) = 1/(kx)$。对于高度电离的介质 ($x \\approx 1$)，该时标就是 $1/k = t_{\\mathrm{rec}}$。在许多天体物理场景中，特别是在星系际介质的更稠密区域，复合可能是最快的过程，这使得方程组变得“刚性”。对于像前向欧拉这样的显式时间积分格式，当应用于刚性系统时，要保持稳定和精确，其时间步长必须受限于系统中最短的时标。因此，一个常见且稳健的做法是将时间步长约束为复合时间的一小部分：\n$$\n\\Delta t \\le C \\cdot t_{\\mathrm{rec}}\n$$\n其中 $C$ 是一个无量纲的安全因子，在此记为 $\\epsilon$ ($0  \\epsilon  1$)。尽管形式上推导出的条件依赖于具体状态 $x_{\\infty}$ 和 $\\Gamma$，但判据 $\\Delta t \\le \\epsilon t_{\\mathrm{rec}}$ 通过解析通常主导系统刚性的过程的时标，提供了一个实用的、保守的上限，从而确保了数值稳定性。\n\n### 任务B：算法设计\n\n该实现将前向欧拉（显式）和后向欧拉（隐式）方法与针对几个测试案例的精确解析解进行比较。\n\n**1. 预备工作：**\n对于每个测试案例，我们首先根据输入元组 $(\\alpha_{\\mathrm{B}}, n_{\\mathrm{H}}, \\Gamma, x_0, \\epsilon, T_{\\mathrm{factor}}, \\Delta t_{\\mathrm{factor}})$ 计算导出的物理参数。\n- 复合率常数：$k = \\alpha_{\\mathrm{B}} n_{\\mathrm{H}}$\n- 复合时标：$t_{\\mathrm{rec}} = 1/k$\n- 总积分时间：$T = T_{\\mathrm{factor}} t_{\\mathrm{rec}}$\n- 两种方法的时间步长：$\\Delta t = \\Delta t_{\\mathrm{factor}} \\epsilon t_{\\mathrm{rec}}$\n- 对时间步长判据进行检查：如果 $\\Delta t_{\\mathrm{factor}} \\le 1$ 则 $\\mathrm{pass} = 1$，否则为 $0$，因为这等价于 $\\Delta t \\le \\epsilon t_{\\mathrm{rec}}$。\n\n**2. 精确解：**\n计算最终时刻 $T$ 的精确解作为参考。这需要 $k x^2 + \\Gamma x - \\Gamma = 0$ 的根：\n$$\nx_{1,2} = \\frac{-\\Gamma \\pm \\sqrt{\\Gamma^2 + 4\\Gamma k}}{2k}\n$$\n我们确定正根 $x_1 = x_{\\infty}$ 和负根 $x_2$。我们还计算 $\\lambda = \\sqrt{\\Gamma^2 + 4\\Gamma k}$（其等于 $k(x_1-x_2)$）和积分常数 $C = (x_0 - x_1) / (x_0 - x_2)$。则在时刻 $T$ 的精确解为：\n$$\nx_{\\text{exact}}(T) = \\frac{x_1 - C e^{-\\lambda T} x_2}{1 - C e^{-\\lambda T}}\n$$\n\n**3. 时间积分循环：**\n对于两种数值方法，总步数是 $N = \\lceil T / \\Delta t \\rceil$。积分过程先进行 $N-1$ 个大小为 $\\Delta t$ 的步，然后是最后一个较小的步，大小为 $\\Delta t_{\\text{final}} = T - (N-1)\\Delta t$，以精确到达时刻 $T$。\n\n**4. 前向欧拉方法：**\n从 $x_{\\mathrm{exp}}^0 = x_0$ 开始，我们迭代：\n$$\nx_{\\mathrm{exp}}^{n+1} = x_{\\mathrm{exp}}^n + \\Delta t_n \\left[ (1 - x_{\\mathrm{exp}}^n)\\Gamma - k(x_{\\mathrm{exp}}^n)^2 \\right]\n$$\n其中 $\\Delta t_n$ 是当前步长。在此过程中，我们跟踪超过物理极限 $x=1$ 的最大超调量：$\\mathrm{overshoot}_{\\max} = \\max_{n} \\max(0, x_{\\mathrm{exp}}^n - 1)$。最终误差为 $E_{\\mathrm{exp}} = |x_{\\mathrm{exp}}(T) - x_{\\text{exact}}(T)|$，成本为 $\\mathrm{cost}_{\\mathrm{exp}} = N \\cdot w_{\\mathrm{exp}} = N$。\n\n**5. 后向欧拉方法：**\n从 $x_{\\mathrm{imp}}^0 = x_0$ 开始，每一步都需要从隐式方程求解 $x^{n+1}$：\n$$\nx^{n+1} = x^n + \\Delta t_n \\left[ (1 - x^{n+1})\\Gamma - k(x^{n+1})^2 \\right]\n$$\n对于 $y = x^{n+1}$，可将其重新排列为标准二次型 $ay^2 + by + c = 0$：\n$$\n(\\Delta t_n k) y^2 + (1 + \\Delta t_n \\Gamma) y - (x^n + \\Delta t_n \\Gamma) = 0\n$$\n系数为 $a = \\Delta t_n k$，$b = 1 + \\Delta t_n \\Gamma$ 和 $c = -(x^n + \\Delta t_n \\Gamma)$。由于 $ac  0$（对于物理输入），该二次方程有一个正实根和一个负实根。我们选择物理上可接受的正根：\n$$\nx_{\\mathrm{imp}}^{n+1} = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}\n$$\n最终误差为 $E_{\\mathrm{imp}} = |x_{\\mathrm{imp}}(T) - x_{\\text{exact}}(T)|$，成本为 $\\mathrm{cost}_{\\mathrm{imp}} = N \\cdot w_{\\mathrm{imp}} = 4N$。\n\n**6. 输出汇总：**\n对于每个测试案例，将六个所需的度量 $[\\mathrm{pass}, \\mathrm{overshoot}_{\\max}, E_{\\mathrm{exp}}, E_{\\mathrm{imp}}, \\mathrm{cost}_{\\mathrm{exp}}, \\mathrm{cost}_{\\mathrm{imp}}]$ 收集到一个列表中。最终输出是包含这五个结果列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ionization ODE problem for a suite of test cases, comparing\n    Forward Euler and Backward Euler methods against an exact solution.\n    \"\"\"\n    # Test suite: (alpha_B, n_H, Gamma, x0, epsilon, T_factor, dt_factor)\n    test_cases = [\n        # Case 1: \"happy path\" explicit timestep\n        (2.6e-13, 1.0e-2, 1.0e-15, 0.0, 0.2, 2.0, 0.25),\n        # Case 2: boundary-adjacent explicit timestep\n        (2.6e-13, 1.0e-2, 1.0e-15, 0.0, 0.2, 2.0, 0.95),\n        # Case 3: supercritical explicit timestep\n        (2.6e-13, 1.0e-2, 1.0e-15, 0.0, 0.2, 2.0, 1.2),\n        # Case 4: stiffer density, constrained timestep\n        (2.6e-13, 1.0e-1, 2.0e-14, 0.0, 0.1, 1.0, 0.5),\n        # Case 5: low density, supercritical timestep\n        (2.6e-13, 1.0e-3, 1.0e-16, 0.0, 0.3, 3.0, 1.1),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha_B, n_H, Gamma, x0, epsilon, T_factor, dt_factor = case\n\n        # 1. Calculate derived parameters\n        k = alpha_B * n_H\n        t_rec = 1.0 / k\n        T = T_factor * t_rec\n        dt = dt_factor * epsilon * t_rec\n\n        # 2. Perform boolean criterion check\n        # The condition dt = epsilon * t_rec is equivalent to dt_factor = 1\n        passes_criterion = 1 if dt_factor = 1.0 else 0\n\n        # 3. Compute exact solution at time T\n        # Roots of k*x^2 + Gamma*x - Gamma = 0\n        sqrt_discriminant = np.sqrt(Gamma**2 + 4 * Gamma * k)\n        x1 = (-Gamma + sqrt_discriminant) / (2 * k)  # Positive root x_inf\n        x2 = (-Gamma - sqrt_discriminant) / (2 * k)  # Negative root\n\n        # Integration constant C\n        # Denominator x0 - x2 is never zero since x0 = 0 and x2  0\n        C = (x0 - x1) / (x0 - x2)\n        \n        # Exact solution x(T)\n        # The term lambda in the problem is sqrt_discriminant\n        x_exact_T = (x1 - C * np.exp(-sqrt_discriminant * T) * x2) / \\\n                    (1 - C * np.exp(-sqrt_discriminant * T))\n\n        # 4. Perform numerical integrations\n        if T == 0:\n            N_steps = 0\n            timesteps = []\n        else:\n            N_steps = int(np.ceil(T / dt))\n            # The last step is adjusted to end exactly at T\n            timesteps = [dt] * (N_steps - 1)\n            last_step = T - (N_steps - 1) * dt\n            if last_step  1e-12 * T: # Avoid negligible last step\n                timesteps.append(last_step)\n            else: # If last step is tiny, adjust previous step and reduce N\n                if N_steps  1:\n                    timesteps[-1] += last_step\n                N_steps = len(timesteps)\n\n\n        # --- Forward Euler ---\n        x_exp = x0\n        max_overshoot = 0.0\n        if N_steps  0:\n            for step_dt in timesteps:\n                dxdt = (1.0 - x_exp) * Gamma - k * x_exp**2\n                x_exp_new = x_exp + step_dt * dxdt\n                # Track maximum overshoot above physical bound x=1\n                current_overshoot = x_exp_new - 1.0\n                if current_overshoot  max_overshoot:\n                    max_overshoot = current_overshoot\n                x_exp = x_exp_new\n        \n        # Ensure overshoot is non-negative as per definition\n        max_overshoot = max(0.0, max_overshoot)\n        E_exp = abs(x_exp - x_exact_T)\n        cost_exp = N_steps * 1\n\n        # --- Backward Euler ---\n        x_imp = x0\n        if N_steps  0:\n            for step_dt in timesteps:\n                # Solve quadratic equation for x_imp^{n+1}\n                # (dt*k) y^2 + (1+dt*Gamma) y - (x_imp^n + dt*Gamma) = 0\n                a = step_dt * k\n                b = 1.0 + step_dt * Gamma\n                c = -(x_imp + step_dt * Gamma)\n                # Choose the physically admissible (positive) root\n                x_imp = (-b + np.sqrt(b**2 - 4 * a * c)) / (2 * a)\n\n        E_imp = abs(x_imp - x_exact_T)\n        cost_imp = N_steps * 4\n\n        all_results.append([\n            passes_criterion, max_overshoot, E_exp, E_imp, cost_exp, cost_imp\n        ])\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3507618"}, {"introduction": "除了局域的化学演化，辐射流体力学的核心任务是模拟辐射在空间中的输运。模拟的准确性通常取决于其能否精确捕捉辐射场的角分布，即各向异性，尤其是在包含多个源和能产生阴影的不透明吸收体的复杂环境中。这个动手实践 [@problem_id:3507616] 聚焦于这一空间维度的挑战。你将实现并比较三种不同的辐射输运近似方法——“精确”的长特征线法、广泛使用的 M1 闭包以及光学薄变 Eddington 张量（OTVET）方法——在一个经典的阴影测试场景中量化它们的性能，从而揭示在辐射输运建模中计算成本与物理保真度之间的根本性权衡。", "problem": "您的任务是在一个与宇宙学再电离的辐射流体动力学相关的简化各向异性双源阴影测试中，实现并比较三种近似辐射转移闭包。目标是仅使用第一性原理和经过充分检验的公式来计算角各向异性度量，并量化不同方法之间的偏差。\n\n此任务的基础如下。\n\n- 考虑真空中稳态、各向同性的电离辐射点源。对于位于 $\\mathbf{x}_s$ 处、全波段光度为 $L$ 的单个点源，在没有吸收的情况下，根据球体上的能量守恒，半径 $r$ 处的能流通量大小为 $L/(4\\pi r^2)$。在自由传播条件下，辐射能量密度 $E$ 与通量 $\\mathbf{F}$ 的关系为 $\\mathbf{F} = c E \\hat{\\mathbf{n}}$，其中 $c$ 是光速，$\\hat{\\mathbf{n}}$ 是从源指向场点的单位向量。因此，对于一个位于 $\\mathbf{x}$ 处、满足 $r = \\|\\mathbf{x}-\\mathbf{x}_s\\|$ 的场点，有\n$$\nE_s(\\mathbf{x}) = \\frac{L}{4\\pi c\\, r^2}, \\quad \\mathbf{F}_s(\\mathbf{x}) = c\\,E_s(\\mathbf{x})\\,\\frac{\\mathbf{x}-\\mathbf{x}_s}{\\|\\mathbf{x}-\\mathbf{x}_s\\|}.\n$$\n- 对于真空中的多个独立源，叠加原理适用：$E(\\mathbf{x}) = \\sum_s E_s(\\mathbf{x})$ 且 $\\mathbf{F}(\\mathbf{x}) = \\sum_s \\mathbf{F}_s(\\mathbf{x})$，前提是从每个源到 $\\mathbf{x}$ 的视线上没有不透明的障碍物。\n- 引入一个半径为 $R$、中心位于 $\\mathbf{x}_c$ 的不透明圆形吸收体（一个高密度中性团块），它会完全阻挡任何从源到场点的直线段与该圆盘相交的射线。在这种情况下，相应源在该视线方向上的贡献被设为零。\n\n定义某一点的角各向异性度量（约化通量）为\n$$\nA(\\mathbf{x}) \\equiv \\frac{\\|\\mathbf{F}(\\mathbf{x})\\|}{c\\,E(\\mathbf{x})},\n$$\n根据其构造，该度量必须满足 $0 \\le A \\le 1$。注意，$E_s$ 中的任何全局常数都在此比率中被抵消。\n\n您必须比较三种估算 $A(\\mathbf{x})$ 的方法。\n\n1. 长特征线 (LC) 射线追踪：独立处理每个源，应用障碍物的精确直线遮挡，然后进行叠加。这得到\n$$\nE_{\\mathrm{LC}}(\\mathbf{x}) = \\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{4\\pi c\\, r_s^2}, \\quad \\mathbf{F}_{\\mathrm{LC}}(\\mathbf{x}) = \\sum_{s \\in \\mathcal{V}(\\mathbf{x})} c\\,\\frac{L_s}{4\\pi c\\, r_s^2}\\,\\hat{\\mathbf{n}}_s,\n$$\n其中 $\\mathcal{V}(\\mathbf{x})$ 是到 $\\mathbf{x}$ 的视线未被阻挡的源的集合，$r_s = \\|\\mathbf{x}-\\mathbf{x}_s\\|$ 且 $\\hat{\\mathbf{n}}_s = (\\mathbf{x}-\\mathbf{x}_s)/r_s$。然后\n$$\nA_{\\mathrm{LC}}(\\mathbf{x}) = \\frac{\\left\\|\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}\\,\\hat{\\mathbf{n}}_s\\right\\|}{\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}}.\n$$\n\n2. M1 矩闭包 (M1)：在稳态、自由传播区域，局部辐射矩满足 $\\mathbf{F}=cE\\,\\mathbf{f}$，其中约化通量 $\\mathbf{f}$ 等于归一化通量矢量。对于非相互作用光束的局部混合，M1 约化通量是方向贡献的归一化叠加。在当前不求解演化方程的静态测试中，对于相同的遮挡集合，这给出了与 LC 相同的代数约化通量：\n$$\nA_{\\mathrm{M1}}(\\mathbf{x}) = \\frac{\\left\\|\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}\\,\\hat{\\mathbf{n}}_s\\right\\|}{\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}}.\n$$\n\n3. 光学薄可变爱丁顿张量 (OTVET)：爱丁顿张量以及由此产生的角结构是根据忽略吸收和遮挡的光学薄场构建的。在此静态比较中，将 OTVET 预测的方向视为所有源方向的光学薄加权平均值，权重与 $E_s^{\\mathrm{thin}} \\propto L_s/r_s^2$ 成正比，并包含所有源。如果真实的局部能量密度是 $E_{\\mathrm{LC}}(\\mathbf{x})$，则与 OTVET 一致的各向异性估计为\n$$\nA_{\\mathrm{OTVET}}(\\mathbf{x}) = \\left\\|\\sum_{s} w_s(\\mathbf{x})\\,\\hat{\\mathbf{n}}_s\\right\\|,\\quad w_s(\\mathbf{x}) = \\frac{\\frac{L_s}{r_s^2}}{\\sum_{s'} \\frac{L_{s'}}{r_{s'}^2}},\n$$\n其中 $A_{\\mathrm{OTVET}}$ 中的求和遍历所有源，无论是否被遮挡。\n\n实现一个程序，对于一个固定的双源、单障碍物几何结构，在几个指定的场点上为每种方法计算 $A$ 的值，并报告与 LC 参考值的偏差。\n\n几何结构和参数：\n\n- 两个相同的源，光度 $L_1=L_2=1$，分别位于 $\\mathbf{x}_1 = (-2,0)$ 和 $\\mathbf{x}_2 = (2,0)$。\n- 一个不透明圆形障碍物，中心位于 $\\mathbf{x}_c=(0,0)$，半径为 $R=0.5$。\n- 四个场点：\n  - 测试案例 $1$：$\\mathbf{x}^{(1)} = (-1, 0.2)$。\n  - 测试案例 $2$：$\\mathbf{x}^{(2)} = (0, 1)$。\n  - 测试案例 $3$：$\\mathbf{x}^{(3)} = (0.6, 0)$。\n  - 测试案例 $4$：$\\mathbf{x}^{(4)} = (0, 0.6)$。\n\n对于每个测试案例 $i \\in \\{1,2,3,4\\}$，计算：\n- 使用精确的直线段与圆相交来判断遮挡，计算 $A_{\\mathrm{LC}}(\\mathbf{x}^{(i)})$，\n- 使用与 LC 相同的可见源集合，计算 $A_{\\mathrm{M1}}(\\mathbf{x}^{(i)})$，\n- 使用所有源，不论是否被遮挡，计算 $A_{\\mathrm{OTVET}}(\\mathbf{x}^{(i)})$，\n以及绝对偏差\n$$\n\\Delta_{\\mathrm{M1}}^{(i)} = \\left|A_{\\mathrm{M1}}(\\mathbf{x}^{(i)}) - A_{\\mathrm{LC}}(\\mathbf{x}^{(i)})\\right|,\\quad\n\\Delta_{\\mathrm{OTVET}}^{(i)} = \\left|A_{\\mathrm{OTVET}}(\\mathbf{x}^{(i)}) - A_{\\mathrm{LC}}(\\mathbf{x}^{(i)})\\right|.\n$$\n\n所有结果都是无量纲的；输出中不需要物理单位。在需要进行矢量归一化时，角度应在内部以弧度处理，但不需要打印任何角度值。\n\n输出规范：\n\n- 您的程序必须生成单一行，其中包含一个由四个子列表组成的列表，每个子列表对应一个测试案例 $i=1,2,3,4$。\n- 每个子列表必须按以下顺序包含五个十进制数，四舍五入到小数点后六位：$[A_{\\mathrm{LC}}, A_{\\mathrm{M1}}, A_{\\mathrm{OTVET}}, \\Delta_{\\mathrm{M1}}, \\Delta_{\\mathrm{OTVET}}]$。\n- 最终输出必须是严格符合以下格式的单一行\n$$\n\\left[\\,[a_{11},a_{12},a_{13},a_{14},a_{15}],\\,[a_{21},a_{22},a_{23},a_{24},a_{25}],\\,[a_{31},a_{32},a_{33},a_{34},a_{35}],\\,[a_{41},a_{42},a_{43},a_{44},a_{45}]\\,\\right],\n$$\n不带任何附加文本。\n\n测试套件覆盖范围：\n\n- 测试案例 1 是一个通用的离轴点，其中一个源被遮挡，另一个可见，用于探测强各向异性和 OTVET 偏差。\n- 测试案例 2 是一个理想路径点，其中两个源在障碍物远上方都可见，用于探测部分抵消和方法间的一致性。\n- 测试案例 3 是右侧的一个近轴点，其中左侧的源被遮挡，用于探测单向照明和 OTVET 偏差。\n- 测试案例 4 是一个近边界点，其中两个源都可见，但几何结构靠近障碍物，用于探测无遮挡情况下对各向异性的敏感度。\n\n您的实现必须是一个完整、可运行的程序，该程序精确地按照描述执行这些计算，并以确切指定的格式打印结果。不允许用户输入，也不应使用外部文件。", "solution": "该问题已被验证并被确定为是合理的。它在科学上基于辐射转移原理，是适定的，提供了所有必要的参数和定义，并且可以形式化为一个直接的计算任务。长特征线 (LC)、M1 和光学薄可变爱丁顿张量 (OTVET) 方法之间的比较，是计算天体物理学中一个标准的、有意义的问题，用于评估辐射转移近似的性能。\n\n任务是使用三种不同的方法，为一个特定的二维配置计算角各向异性度量 $A(\\mathbf{x}) \\equiv \\frac{\\|\\mathbf{F}(\\mathbf{x})\\|}{c\\,E(\\mathbf{x})}$。该设置包括两个各向同性点源、一个不透明圆形障碍物和四个指定的场点。\n\n每个场点 $\\mathbf{x}$ 的计算核心包括两个主要步骤：首先，确定哪些源被障碍物遮挡；其次，根据源的可见性，为每种方法（$A_{\\mathrm{LC}}$、$A_{\\mathrm{M1}}$、$A_{\\mathrm{OTVET}}$）应用不同的公式。\n\n几何和物理参数如下：\n- 源：$L_1=1$ 位于 $\\mathbf{x}_1 = (-2, 0)$，$L_2=1$ 位于 $\\mathbf{x}_2 = (2, 0)$。\n- 障碍物：圆心位于 $\\mathbf{x}_c=(0,0)$，半径 $R=0.5$ 的圆。\n- 场点：$\\mathbf{x}^{(1)} = (-1, 0.2)$，$\\mathbf{x}^{(2)} = (0, 1)$，$\\mathbf{x}^{(3)} = (0.6, 0)$，$\\mathbf{x}^{(4)} = (0, 0.6)$。\n\n计算过程如下：\n\n1.  **遮挡检测**：对于每个源 $\\mathbf{x}_s$ 和场点 $\\mathbf{x}_p$，我们必须确定连接它们的线段是否与由 $\\|\\mathbf{x}\\|^2 \\le R^2$ 定义的圆形障碍物相交。由于源和场点都不在障碍物内部，这等效于找到从圆心 ($\\mathbf{x}_c = \\mathbf{0}$) 到线段 $[\\mathbf{x}_s, \\mathbf{x}_p]$ 的最小距离，并检查该距离是否小于或等于 $R$。这个最小距离 $d_{\\mathrm{min}}$ 是通过将从线段端点（例如 $\\mathbf{x}_s$）到圆心的矢量投影到线段的方向矢量 $\\mathbf{d} = \\mathbf{x}_p - \\mathbf{x}_s$ 上找到的。投影参数为\n    $$ t = \\frac{(\\mathbf{x}_c - \\mathbf{x}_s) \\cdot \\mathbf{d}}{\\mathbf{d} \\cdot \\mathbf{d}} $$\n    如果 $t \\in [0, 1]$，则最近点位于线段内部，而 $d_{\\mathrm{min}}$ 是垂直距离。否则，最近点是端点之一，即 $\\mathbf{x}_s$ 或 $\\mathbf{x}_p$。如果从 $\\mathbf{x}_p$ 到源 $s$ 的视线未被遮挡，则该源是可见的。可见源的集合表示为 $\\mathcal{V}(\\mathbf{x}_p)$。\n\n2.  **各向异性度量的计算**：对于每个场点 $\\mathbf{x}$，我们计算以下量。请注意，由于光度 $L_s=1$ 是相同的，它们可以被约去。令 $I_s(\\mathbf{x}) = 1/\\|\\mathbf{x}-\\mathbf{x}_s\\|^2 = 1/r_s^2$ 为未归一化的能量密度贡献，$\\hat{\\mathbf{n}}_s = (\\mathbf{x}-\\mathbf{x}_s)/r_s$ 为方向矢量。\n\n    -   **长特征线 ($A_{\\mathrm{LC}}$)**：这是基准真相。计算仅涉及可见源。\n    $$\n    A_{\\mathrm{LC}}(\\mathbf{x}) = \\frac{\\left\\| \\sum_{s \\in \\mathcal{V}(\\mathbf{x})} I_s(\\mathbf{x}) \\hat{\\mathbf{n}}_s \\right\\|}{\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} I_s(\\mathbf{x})}\n    $$\n    如果只有一个源可见，则求和中只有一个项，得出 $A_{\\mathrm{LC}} = \\|\\hat{\\mathbf{n}}_s\\| = 1$。如果没有源可见，$A_{\\mathrm{LC}}$ 未定义，但这在测试案例中不会发生。\n\n    -   **M1 闭包 ($A_{\\mathrm{M1}}$)**：问题陈述中指出，对于此静态测试，M1 方法使用与 LC 方法相同的可见源集合，并产生相同的结果。\n    $$\n    A_{\\mathrm{M1}}(\\mathbf{x}) = A_{\\mathrm{LC}}(\\mathbf{x})\n    $$\n\n    -   **光学薄可变爱丁顿张量 ($A_{\\mathrm{OTVET}}$)**：此方法基于光学薄辐射场构建其各向异性，这意味着它考虑所有源，无论是否被遮挡。\n    $$\n    A_{\\mathrm{OTVET}}(\\mathbf{x}) = \\left\\| \\sum_s w_s(\\mathbf{x}) \\hat{\\mathbf{n}}_s \\right\\|, \\quad \\text{其中} \\quad w_s(\\mathbf{x}) = \\frac{I_s(\\mathbf{x})}{\\sum_{s'} I_{s'}(\\mathbf{x})}\n    $$\n    $w_s$ 和 $A_{\\mathrm{OTVET}}$ 的求和遍历所有源 $s$ 和 $s'$。\n\n3.  **偏差的计算**：与 LC 参考值的绝对差值计算如下：\n    $$\n    \\Delta_{\\mathrm{M1}} = |A_{\\mathrm{M1}} - A_{\\mathrm{LC}}| = 0 \\quad (\\text{根据此问题的定义})\n    $$\n    $$\n    \\Delta_{\\mathrm{OTVET}} = |A_{\\mathrm{OTVET}} - A_{\\mathrm{LC}}|\n    $$\n\n此过程应用于四个测试案例中的每一个。\n\n**案例 1：$\\mathbf{x} = (-1, 0.2)$**\n-   遮挡：源 $\\mathbf{x}_1=(-2,0)$ 可见。源 $\\mathbf{x}_2=(2,0)$ 被遮挡，因为视线穿过障碍物。\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}$：由于只有一个可见源，场是完全各向异性的。$A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = 1$。\n-   $A_{\\mathrm{OTVET}}$：使用两个源计算，由于对两个不同方向矢量的平均，得到一个小于 $1$ 的值。\n-   结果：$A_{\\mathrm{LC}} = 1.0$， $A_{\\mathrm{M1}} = 1.0$， $A_{\\mathrm{OTVET}} \\approx 0.797613$。偏差：$\\Delta_{\\mathrm{M1}} = 0.0$， $\\Delta_{\\mathrm{OTVET}} \\approx 0.202387$。\n\n**案例 2：$\\mathbf{x} = (0, 1)$**\n-   遮挡：根据对称性，该点离障碍物足够远，两个源都可见。\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}$：使用两个源计算。\n-   $A_{\\mathrm{OTVET}}$：由于所有源都可见，使用的源集合与 LC 相同。在这种情况下，$A_{\\mathrm{LC}}$ 和 $A_{\\mathrm{OTVET}}$ 的公式在数学上是等价的。\n-   结果：$A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = A_{\\mathrm{OTVET}} = 1/\\sqrt{5} \\approx 0.447214$。偏差：$\\Delta_{\\mathrm{M1}} = 0.0$， $\\Delta_{\\mathrm{OTVET}} = 0.0$。\n\n**案例 3：$\\mathbf{x} = (0.6, 0)$**\n-   遮挡：该点位于 x 轴上。到 $\\mathbf{x}_1=(-2,0)$ 的视线穿过原点，因此被遮挡。到 $\\mathbf{x}_2=(2,0)$ 的视线是清晰的。\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}$：由于只有一个可见源，场是完全各向异性的。$A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = 1$。\n-   $A_{\\mathrm{OTVET}}$：使用两个源计算。两个方向矢量是相反的（$\\hat{\\mathbf{n}}_1=(1,0), \\hat{\\mathbf{n}}_2=(-1,0)$），导致显著抵消和一个低的各向异性值。\n-   结果：$A_{\\mathrm{LC}} = 1.0$， $A_{\\mathrm{M1}} = 1.0$， $A_{\\mathrm{OTVET}} \\approx 0.550570$。偏差：$\\Delta_{\\mathrm{M1}} = 0.0$， $\\Delta_{\\mathrm{OTVET}} \\approx 0.449430$。\n\n**案例 4：$\\mathbf{x} = (0, 0.6)$**\n-   遮挡：该点位于 y 轴上，刚好在障碍物外面（$0.6 > R=0.5$）。两条视线都靠近但未与障碍物相交。两个源都可见。\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}, A_{\\mathrm{OTVET}}$：与案例 2 一样，所有源都可见，因此所有三种方法都产生相同的结果。\n-   结果：$A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = A_{\\mathrm{OTVET}} = 0.6/\\sqrt{2^2+0.6^2} \\approx 0.287348$。偏差：$\\Delta_{\\mathrm{M1}} = 0.0$， $\\Delta_{\\mathrm{OTVET}} = 0.0$。\n\n最终的代码精确地实现了这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares three approximate radiative transfer closures\n    in a simplified anisotropic two-source shadowing test.\n    \"\"\"\n\n    # Define geometry and parameters\n    sources = [\n        {'pos': np.array([-2.0, 0.0]), 'L': 1.0},\n        {'pos': np.array([2.0, 0.0]), 'L': 1.0}\n    ]\n    obstacle = {'center': np.array([0.0, 0.0]), 'radius': 0.5}\n    \n    # Define test cases (field points)\n    test_cases = [\n        np.array([-1.0, 0.2]),\n        np.array([0.0, 1.0]),\n        np.array([0.6, 0.0]),\n        np.array([0.0, 0.6])\n    ]\n\n    def is_occluded(source_pos, point_pos, obs_center, obs_radius):\n        \"\"\"\n        Checks if the line segment from source_pos to point_pos is occluded\n        by a circular obstacle.\n        \n        This is done by finding the point on the line segment closest to the\n        obstacle's center and checking if its distance is within the radius.\n        \"\"\"\n        # Vector from source to point\n        vec_sp = point_pos - source_pos\n        d_sq = np.dot(vec_sp, vec_sp)\n        if d_sq == 0:  # Point is at the source\n            return False\n\n        # Vector from source to obstacle center\n        vec_s_obs = obs_center - source_pos\n\n        # Project vec_s_obs onto vec_sp to find the closest point on the infinite line\n        # t = (obs_center - source_pos) . (point_pos - source_pos) / |point_pos - source_pos|^2\n        t = np.dot(vec_s_obs, vec_sp) / d_sq\n        \n        # Clamp t to [0, 1] to find the closest point on the line segment\n        t_clamped = np.clip(t, 0.0, 1.0)\n\n        # Calculate the closest point on the segment to the obstacle center\n        closest_point_on_segment = source_pos + t_clamped * vec_sp\n        \n        # Calculate distance from this point to the obstacle center\n        dist_sq = np.sum((closest_point_on_segment - obs_center)**2)\n        \n        return dist_sq = obs_radius**2\n\n    results = []\n    \n    for x_p in test_cases:\n        # Determine the set of visible sources\n        visible_sources_indices = []\n        for i, s in enumerate(sources):\n            if not is_occluded(s['pos'], x_p, obstacle['center'], obstacle['radius']):\n                visible_sources_indices.append(i)\n\n        # --- Calculate A_LC and A_M1 ---\n        # (Based on visible sources)\n        A_lc = 0.0\n        if visible_sources_indices:\n            sum_flux_vec_lc = np.zeros(2)\n            sum_energy_den_lc = 0.0\n            for i in visible_sources_indices:\n                s = sources[i]\n                r_vec = x_p - s['pos']\n                r_mag = np.linalg.norm(r_vec)\n                n_hat = r_vec / r_mag\n                intensity = s['L'] / r_mag**2\n                \n                sum_flux_vec_lc += intensity * n_hat\n                sum_energy_den_lc += intensity\n            \n            if sum_energy_den_lc  0:\n                A_lc = np.linalg.norm(sum_flux_vec_lc) / sum_energy_den_lc\n        \n        A_m1 = A_lc  # As per problem statement\n        delta_m1 = abs(A_m1 - A_lc)\n\n        # --- Calculate A_OTVET ---\n        # (Based on ALL sources)\n        sum_weighted_n_hat_otvet = np.zeros(2)\n        total_intensity_otvet = 0.0\n        \n        intensities = []\n        unit_vectors = []\n        for s in sources:\n            r_vec = x_p - s['pos']\n            r_mag = np.linalg.norm(r_vec)\n            if r_mag  0:\n                n_hat = r_vec / r_mag\n                intensity = s['L'] / r_mag**2\n                intensities.append(intensity)\n                unit_vectors.append(n_hat)\n                total_intensity_otvet += intensity\n            else: # field point is at a source location\n                intensities.append(0)\n                unit_vectors.append(np.zeros(2))\n        \n        if total_intensity_otvet  0:\n            for i in range(len(sources)):\n                weight = intensities[i] / total_intensity_otvet\n                sum_weighted_n_hat_otvet += weight * unit_vectors[i]\n\n        A_otvet = np.linalg.norm(sum_weighted_n_hat_otvet)\n        delta_otvet = abs(A_otvet - A_lc)\n\n        # Store the results for this test case\n        results.append([A_lc, A_m1, A_otvet, delta_m1, delta_otvet])\n\n    # Format the final output string as specified\n    sublist_strs = []\n    for sublist in results:\n        sublist_strs.append(f\"[{','.join([f'{val:.6f}' for val in sublist])}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3507616"}]}