{"hands_on_practices": [{"introduction": "在计算天体物理学中，一个模拟的有效性取决于其能否准确地捕捉到关键的物理尺度。在模拟涉及自引力的系统（如公共包层演化）时，一个核心挑战是避免“人工碎裂”——这是一种数值不稳定性，它会导致气体云在物理上不应发生坍缩的情况下发生虚假的成团。为了防止这种情况，必须确保模拟的分辨率足以解析局部的金斯长度（Jeans length）[@problem_id:3533014]。本练习将指导您应用著名的特鲁洛夫判据（Truelove criterion），计算在自适应网格加密（AMR）模拟中确保物理真实性所需的最低分辨率。", "problem": "一个关于共同包层（CE）演化过程中形成的盘的全局三维模拟，在笛卡尔网格上使用了自适应网格加密（AMR）技术。CE 诱导盘中的气体在内部区域可近似为等温气体，其温度为 $T = 4.0 \\times 10^{3}\\ \\text{K}$，平均分子量为 $\\mu = 1.3$。在整个模拟过程中，盘内任意位置测得的最大中平面密度为 $\\rho_{\\max} = 1.0 \\times 10^{-4}\\ \\text{g cm}^{-3}$。基础网格单元的尺寸为 $\\Delta x_{0} = 7.5 \\times 10^{12}\\ \\text{cm}$，每个 AMR 层级在每个维度上将空间分辨率提高 2 倍，因此在层级 $L$ 处，局部单元尺寸为 $\\Delta x_{L} = \\Delta x_{0} / 2^{L}$。该模拟旨在通过强制要求在 $\\rho = \\rho_{\\max}$ 的位置，局部金斯长度至少被 $N_{J} = 8$ 个单元解析，从而抑制人为碎裂。\n\n从基本定义（用 $T$ 和 $\\mu$ 表示的等温声速、引力常数 $G$ 以及经典金斯长度）出发，确定所需的 AMR 最小整数层级数 $L_{\\min}$，以确保在假设 $\\rho = \\rho_{\\max}$ 处等温近似成立的情况下，金斯长度在任何地方都至少被 $N_{J}$ 个单元解析。使用 $k_{B}$ 表示玻尔兹曼常数，$m_{p}$ 表示质子质量。请以整数形式报告 $L_{\\min}$。\n\n除了计算之外，请简要说明为什么满足此分辨率要求对于抑制 CE 诱导盘中的人为碎裂是相关的。您最终报告的答案必须仅为 $L_{\\min}$ 的值，不带单位或附加文本。", "solution": "该问题被认为是有效的，因为它具有科学依据、提法恰当，并基于计算天体物理学的标准原理。这是一个完整且一致的问题陈述。\n\n主要目标是确定在共同包层（CE）诱导盘的模拟中，为恰当解析金斯长度所需的自适应网格加密（AMR）的最小整数层级数 $L_{\\min}$。这个被称为 Truelove 判据的分辨率要求，对于防止人为的数值碎裂至关重要。该判据规定，局部金斯长度 $\\lambda_J$ 必须被至少 $N_J$ 个网格单元解析。\n\n首先，我们定义等温声速 $c_s$。对于平均分子量为 $\\mu$、温度恒为 $T$ 的气体，其声速由下式给出：\n$$c_s = \\sqrt{\\frac{k_B T}{\\mu m_p}}$$\n其中 $k_B$ 是玻尔兹曼常数，$m_p$ 是质子质量。\n\n接着，我们定义经典金斯长度 $\\lambda_J$。这是一个临界波长，当自引力、均匀、静态的气体云的尺度超过该波长时，它将变得不稳定并发生坍缩。其表达式为：\n$$\\lambda_J = c_s \\sqrt{\\frac{\\pi}{G \\rho}}$$\n其中 $G$ 是引力常数，$\\rho$ 是气体密度。\n\n为了防止人为碎裂，模拟必须能够解析引力坍缩。这要求单元尺寸 $\\Delta x$ 小于坍缩的特征尺度。由于 $\\lambda_J \\propto \\rho^{-1/2}$，最严苛的条件出现在密度最高的地方。因此，我们必须在最大密度 $\\rho_{\\max}$ 处评估该条件。\n\n金斯分辨率要求规定，在最大密度位置的单元尺寸必须满足：\n$$\\Delta x_L \\le \\frac{\\lambda_J(\\rho_{\\max})}{N_J}$$\n其中 $\\Delta x_L$ 是 AMR 层级 $L$ 处的单元尺寸，$N_J$ 是每个金斯长度所需解析的单元数。问题指定 $N_J = 8$。\n\n我们可以代入 $c_s$ 和 $\\lambda_J$ 的表达式，得到一个关于分辨率要求的综合公式。首先，让我们用基本参数来表示 $\\lambda_J$：\n$$\\lambda_J(\\rho_{\\max}) = \\sqrt{\\frac{k_B T}{\\mu m_p}} \\sqrt{\\frac{\\pi}{G \\rho_{\\max}}} = \\sqrt{\\frac{\\pi k_B T}{G \\mu m_p \\rho_{\\max}}}$$\n\nAMR 层级 $L$ 处的单元尺寸由 $\\Delta x_L = \\Delta x_0 / 2^L$ 给出，其中 $\\Delta x_0$ 是基础网格单元尺寸。将此代入不等式，可得：\n$$\\frac{\\Delta x_0}{2^L} \\le \\frac{1}{N_J} \\sqrt{\\frac{\\pi k_B T}{G \\mu m_p \\rho_{\\max}}}$$\n\n我们需要找到满足此条件的最小整数 $L$。我们可以重新整理不等式来求解 $L$：\n$$2^L \\ge N_J \\Delta x_0 \\sqrt{\\frac{G \\mu m_p \\rho_{\\max}}{\\pi k_B T}}$$\n对两边取以 2 为底的对数，得到：\n$$L \\ge \\log_2 \\left( N_J \\Delta x_0 \\sqrt{\\frac{G \\mu m_p \\rho_{\\max}}{\\pi k_B T}} \\right)$$\n所需的最小层级 $L_{\\min}$ 将是该表达式的向上取整值，因为 $L$ 必须是整数。\n\n现在，我们代入 CGS 单位制下的给定数值：\n- 温度 $T = 4.0 \\times 10^{3}\\ \\text{K}$\n- 平均分子量 $\\mu = 1.3$\n- 最大密度 $\\rho_{\\max} = 1.0 \\times 10^{-4}\\ \\text{g cm}^{-3}$\n- 基础网格单元尺寸 $\\Delta x_0 = 7.5 \\times 10^{12}\\ \\text{cm}$\n- 金斯分辨率数 $N_J = 8$\n- 引力常数 $G \\approx 6.674 \\times 10^{-8}\\ \\text{cm}^3\\ \\text{g}^{-1}\\ \\text{s}^{-2}$\n- 玻尔兹曼常数 $k_B \\approx 1.381 \\times 10^{-16}\\ \\text{erg K}^{-1}$\n- 质子质量 $m_p \\approx 1.673 \\times 10^{-24}\\ \\text{g}$\n\n首先，我们计算平方根内的表达式：\n$$\\frac{G \\mu m_p \\rho_{\\max}}{\\pi k_B T} \\approx \\frac{(6.674 \\times 10^{-8}) (1.3) (1.673 \\times 10^{-24}) (1.0 \\times 10^{-4})}{\\pi (1.381 \\times 10^{-16}) (4.0 \\times 10^{3})}$$\n分子：$(6.674 \\times 1.3 \\times 1.673) \\times 10^{-8-24-4} \\approx 14.52 \\times 10^{-36} \\approx 1.452 \\times 10^{-35}$\n分母：$\\pi (1.381 \\times 4.0) \\times 10^{-16+3} \\approx 3.14159 \\times 5.524 \\times 10^{-13} \\approx 1.735 \\times 10^{-12}$\n比值：$\\frac{1.452 \\times 10^{-35}}{1.735 \\times 10^{-12}} \\approx 8.369 \\times 10^{-24}\\ \\text{cm}^{-2}$\n\n现在，我们计算平方根：\n$$\\sqrt{8.369 \\times 10^{-24}\\ \\text{cm}^{-2}} \\approx 2.893 \\times 10^{-12}\\ \\text{cm}^{-1}$$\n\n接下来，我们计算对数内的表达式：\n$$N_J \\Delta x_0 \\sqrt{\\frac{G \\mu m_p \\rho_{\\max}}{\\pi k_B T}} \\approx (8) (7.5 \\times 10^{12}\\ \\text{cm}) (2.893 \\times 10^{-12}\\ \\text{cm}^{-1})$$\n$$(60 \\times 10^{12}) (2.893 \\times 10^{-12}) = 60 \\times 2.893 \\approx 173.58$$\n\n最后，我们求 $L$：\n$$L \\ge \\log_2(173.58)$$\n由于 $\\log_2(x) = \\frac{\\ln(x)}{\\ln(2)}$，我们有：\n$$L \\ge \\frac{\\ln(173.58)}{\\ln(2)} \\approx \\frac{5.1566}{0.6931} \\approx 7.439$$\n由于 AMR 层级数 $L$ 必须是整数，我们对这个值向上取整：\n$$L_{\\min} = \\lceil 7.439 \\rceil = 8$$\n\n因此，至少需要 8 个层级的自适应网格加密。\n\n关于分辨率要求的合理解释：\n满足金斯分辨率要求（通常称为 Truelove 判据）对于抑制涉及自引力的流体动力学模拟中的人为碎裂至关重要。在离散网格上，物理量及其梯度是使用有限差分法来近似的。如果金斯长度——即引力不稳定性发展的尺度——没有被足够数量的单元解析，那么力的数值计算可能会变得不准确。具体来说，提供抵抗坍缩支撑的离散化压力梯度，相对于离散化的引力，可能会被系统性地低估。这种数值不平衡可能导致一个物理上稳定的气体团块在模拟中表现为引力不稳定，从而引发虚假的坍缩和碎裂。通过强制要求金斯长度跨越至少 $N_J$ 个单元（其中 $N_J \\ge 4$ 是一个常见的选择，而 $N_J=8$ 则更为保守），模拟可以精确地捕捉压力和引力之间的相互作用，从而确保任何观察到的碎裂都是物理过程的结果，而不是数值伪影。", "answer": "$$\\boxed{8}$$", "id": "3533014"}, {"introduction": "求解用于计算自引力的泊松方程（Poisson equation）通常是公共包层演化模拟中计算成本最高的部分。因此，选择正确的求解器对于模拟的性能和准确性至关重要。不同的算法，如基于快速傅里叶变换（FFT）的求解器和多重网格（multigrid）方法，在处理边界条件、适应非均匀网格（如AMR）以及计算可扩展性方面具有根本不同的特性[@problem_id:3533020]。这项练习要求您从根本上评估这些方法的优缺点，并为真实的、具有挑战性的模拟场景选择最合适的算法。", "problem": "一个经历公共包层 (CE) 演化的双星系统在一个边长为 $L$ 的三维笛卡尔域中通过自适应网格加密 (AMR) 技术进行模拟。在每个流体动力学时间步，必须通过求解泊松方程来计算自引力势 $\\Phi(\\mathbf{x})$\n$$\n\\nabla^{2}\\Phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x}),\n$$\n其中 $G$ 是引力常数，$\\rho(\\mathbf{x})$ 是质量密度。该物理构型是孤立的：预期的边界条件是当 $\\lvert \\mathbf{x} \\rvert \\to \\infty$ 时 $\\Phi(\\mathbf{x}) \\to 0$。AMR 层级结构是块结构的，其可变分辨率集中在包层中的陡峭密度梯度和致密天体附近。\n\n正在考虑两类求解器：几何多重网格求解器和基于快速傅里叶变换 (FFT) 的求解器。计算约束包括：需要在孤立的、非周期性边界条件下保持精度；在未知量数量 $N$ 增长时保持效率和可扩展性；以及尊重 AMR 层级结构，而不是强制在最高分辨率下使用全局均匀网格。\n\n仅使用泊松算子和离散傅里叶变换的标准性质，以及“松弛法平滑高频误差，而粗网格校正低频误差”这一多重网格基本原理，对以下陈述进行推断：\n\n- 在一个边长为 $L$ 的盒子上的均匀网格中，对于周期性边界条件，离散拉普拉斯算子可被离散傅里叶基对角化。其本征模为 $e^{i \\mathbf{k} \\cdot \\mathbf{x}}$，其中波数 $\\mathbf{k}$ 与周期性一致，而一个基于 FFT 的求解器会产生一个对应于 $\\rho(\\mathbf{x})$ 周期性环绕的解。\n- 对于孤立边界条件，自由空间格林函数 $G(\\mathbf{r}) = -\\dfrac{1}{4\\pi \\lvert \\mathbf{r} \\rvert}$ 意味着一个卷积 $\\Phi(\\mathbf{x}) = G * (4\\pi G \\rho)$，该卷积可以在均匀网格上通过使用零填充来避免循环环绕而得到加速。这种方法预设了一个均匀网格来定义一个单一的全局卷积网格。\n- 在几何多重网格方法中，一个松弛格式（例如，加权 Jacobi 或 Gauss–Seidel）在给定网格上减少高频误差，而限制到更粗的网格加上粗网格校正可以减少低频误差。延拓将校正值返回到更细的网格。如果限制和延拓操作遵守加密界面，此过程可以自然地应用于块结构的 AMR，并且孤立边界条件可以通过适当的边界值（例如，通过在域边界上进行多极展开）来强制执行。\n\n哪个选项最好地描述了适用于带有 AMR 的非周期性、孤立 CE 模拟的求解器选择及其理由？\n\nA. 在最高 AMR 分辨率的均匀网格上使用一个全局的、基于 FFT 的求解器，并采用周期性边界条件；使计算盒子足够大，以致周期性镜像引入的误差可以忽略不计。这确保了 $O(N \\log N)$ 的复杂度，并避免了实现复杂的边界条件。\n\nB. 在最高分辨率的均匀网格上使用带零填充的、基于 FFT 的自由空间卷积来模拟孤立边界，然后降采样到 AMR 层级。这能精确地保持孤立边界条件，并维持 $O(N \\log N)$ 的标度性，且没有显著的内存开销。\n\nC. 在 AMR 层级结构上使用几何多重网格求解器，在每个层级上进行松弛，在层级之间进行限制和延拓，并通过在外部域上施加基于多极展开的狄利克雷边界来强制执行孤立边界条件。这维持了 $O(N)$ 的复杂度，尊重了 AMR 结构，并避免了周期性环绕。\n\nD. 在每个 AMR 补丁上使用局部 FFT 求解，并在补丁边界上施加周期性边界条件；通过在界面处匹配势来耦合各个补丁。这保持了局部性和每个补丁 $O(N \\log N)$ 的标度性，并且当补丁尺寸很小时，与孤立边界是一致的。", "solution": "用户要求对问题陈述进行批判性验证，然后给出详细的解法和对所提供选项的评估。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **物理系统：** 经历公共包层 (CE) 演化的双星系统。\n- **计算域：** 边长为 $L$ 的三维笛卡尔域。\n- **数值方法：** 自适应网格加密 (AMR)，具体为块结构层级。\n- **控制方程：** 用于自引力势 $\\Phi(\\mathbf{x})$ 的泊松方程，由 $\\nabla^{2}\\Phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x})$ 给出。\n- **符号：** $G$ 是引力常数，$\\rho(\\mathbf{x})$ 是质量密度。\n- **边界条件（物理）：** 系统是孤立的，意味着势在无穷远处消失：当 $\\lvert \\mathbf{x} \\rvert \\to \\infty$ 时 $\\Phi(\\mathbf{x}) \\to 0$。\n- **考虑的求解器：** 几何多重网格和基于快速傅里叶变换 (FFT) 的求解器。\n- **计算约束：**\n    1. 必须精确处理孤立的、非周期性边界条件。\n    2. 随着未知量数量 $N$ 的增长，必须保持高效和可扩展。\n    3. 必须尊重 AMR 层级结构，而无需在最高分辨率下使用全局均匀网格。\n- **支持性前提（作为事实提供的背景信息）：**\n    1. 在均匀周期性网格上，基于 FFT 的求解器通过本征模 $e^{i \\mathbf{k} \\cdot \\mathbf{x}}$ 对离散拉普拉斯算子进行对角化，适用于周期性问题。\n    2. 对于孤立边界，与格林函数 $G(\\mathbf{r}) = -\\dfrac{1}{4\\pi \\lvert \\mathbf{r} \\rvert}$ 的均匀网格卷积可以通过 FFT 和零填充来加速，以避免周期性环绕。\n    3. 几何多重网格使用松弛法（处理高频误差）和粗网格校正（处理低频误差），天然适用于 AMR，并能通过在域边界上设置适当的值（例如，通过多极展开）来强制执行孤立边界条件。\n\n**步骤2：使用提取的已知条件进行验证**\n根据所需标准评估问题陈述。\n- **科学上合理：** 该问题牢固地建立在计算天体物理学领域内。自引力的泊松方程、公共包层演化的概念、AMR 的使用，以及对 FFT 和多重网格求解器的考虑，都是该领域标准和基础的内容。所提供的关于这些求解器性质的前提是正确的。\n- **良态的：** 任务是根据一套清晰一致的物理和计算约束来评估不同数值方法的适用性。问题定义明确，可以得出一个关于选项中“最佳”方法的唯一、合理的结论。\n- **客观的：** 语言技术性强且精确。它描述了物理模型、数值算法及其性质，没有主观性或偏见。\n- **缺陷清单：**\n    1. **科学上不健全：** 无。所有陈述的物理和数值原理都是正确的。\n    2. **不可形式化：** 无。该问题明确地是关于形式化的数值方法。\n    3. **不完整/矛盾的设定：** 无。约束条件（AMR、孤立边界条件、效率）被明确指定，并构成了连贯的评估基础。例如，需要尊重 AMR 层级结构是对求解器选择的直接约束。\n    4. **不切实际/不可行：** 无。这是一个计算天体物理学家面临的典型问题。\n    5. **病态/模糊：** 无。所有技术术语都是该领域的标准术语。\n    6. **伪深刻/琐碎：** 无。在 AMR 背景下，这些求解器之间的权衡是复杂的，代表了科学计算中的一个真正挑战。\n    7. **超出科学可验证性范围：** 无。这些算法的性能和准确性是可以通过经验验证和理论分析的。\n\n**步骤3：结论和行动**\n问题陈述是**有效的**。这是一个关于计算天体物理学中数值方法应用的、表述良好的问题。我现在将进行解法推导和选项分析。\n\n### 解法推导\n\n问题要求在三个同步约束下，为泊松方程 $\\nabla^{2}\\Phi = 4\\pi G \\rho$ 选择最合适的求解器：\n1.  **孤立系统：** 边界条件必须表示孤立的质量分布，而非周期性的。\n2.  **AMR 网格：** 求解器必须在非均匀、块结构的自适应网格上高效运行。\n3.  **可扩展性：** 求解器的计算成本应随着网格单元数 $N$ 的增加而有利地扩展。\n\n让我们基于这些约束来分析这两类求解器。\n\n**1. 基于快速傅里叶变换 (FFT) 的求解器：**\nFFT 求解器的效率通常与总网格点数 $N$ 成 $O(N \\log N)$ 比例，非常有吸引力。然而，它们有其根本性的局限。\n- 标准的 FFT 求解器对拉普拉斯算子进行对角化，这内在地对应于在**周期性边界条件**下求解微分方程。这直接违反了约束 #1。\n- 为了处理孤立边界条件（约束 #1），可以使用卷积定理。其解由源项与自由空间格林函数的卷积给出：$\\Phi(\\mathbf{x}) = \\int \\frac{-G \\rho(\\mathbf{x}')}{\\lvert \\mathbf{x} - \\mathbf{x}' \\rvert} d^3\\mathbf{x}'$。在离散形式下，这个卷积可以使用 FFT 快速计算。然而，离散傅里叶变换（由 FFT 算法计算）假设了周期性。为了正确计算非周期性卷积，源数组 $\\rho$ 必须用零填充，使其在每个维度上的大小至少增加一倍，以防止源“环绕”并与其自身的周期性镜像相互作用。关键是，这种方法需要一个**单一的、全局的、均匀的网格**。\n- 对均匀网格的这一要求直接与约束 #2（AMR 网格结构）冲突。要使用基于 FFT 的卷积方法，就必须在 AMR 层级中存在的最高分辨率下创建一个临时的均匀网格。这将用细网格单元填充 AMR 网格的所有粗糙区域，从而抵消了 AMR 带来的内存和计算节省。这个均匀网格上的网格点数 $N_{\\text{fine}}$ 将远远大于 AMR 层级中的实际单元数 $N_{\\text{AMR}}$。计算成本将与 $N_{\\text{fine}} \\log N_{\\text{fine}}$ 成正比，这是极其昂贵的，并且不能与问题的真实复杂度相匹配。\n\n**2. 几何多重网格 (MG) 求解器：**\n- 多重网格方法是为椭圆型偏微分方程设计的迭代求解器。其核心原理是使用一系列网格来有效消除所有频率尺度的误差。高频误差通过在细网格上进行简单的松弛过程（如加权 Jacobi 或 Gauss-Seidel）来平滑，而低频误差则被转移到更粗的网格上（限制），在那里它们表现为更高频率的误差并可以被有效求解。然后，校正值被插值回细网格（延拓）。\n- 这种方法天然地适用于 AMR 层级结构（约束 #2）。现有的 AMR 层级可作为多重网格循环的网格。限制和延拓算子必须在加密层级之间的边界上仔细定义，但这在现代 AMR 的多重网格实现中是一个标准且已得到良好解决的问题。\n- 多重网格求解器是实空间方法，本身不与任何特定的边界条件绑定。边界条件在松弛步骤中直接强制执行。对于一个孤立系统（约束 #1），物理条件 $\\Phi \\to 0$ 当 $\\lvert \\mathbf{x} \\rvert \\to \\infty$ 时被施加在有限计算域的边界上。一个常用且准确的技术是计算质量分布 $\\rho$ 的多极展开，并用它来评估域最外层边界上的势 $\\Phi$。这为在内部运行的多重网格求解器提供了必要的狄利克雷边界条件。\n- 一个正确实现的用于泊松方程的几何多重网格求解器具有最优的计算复杂度 $O(N)$（约束 #3），其中 $N$ 是 AMR 层级中的真实单元数（$N = N_{\\text{AMR}}$）。这在渐近意义上比任何基于 FFT 的方法都要快，并直接与问题的有效大小成比例。\n\n**结论：** 对于此问题，几何多重网格是更优越的选择，因为它自然地与 AMR 结构集成，能正确处理孤立边界条件，并提供最优的 $O(N)$ 标度性。基于 FFT 的方法在效率上与 AMR 结构根本不兼容。\n\n### 逐项选项分析\n\n**A. 在最高 AMR 分辨率的均匀网格上使用一个全局的、基于 FFT 的求解器，并采用周期性边界条件；使计算盒子足够大，以致周期性镜像引入的误差可以忽略不计。这确保了 $O(N \\log N)$ 的复杂度，并避免了实现复杂的边界条件。**\n- 此选项明确违反了 AMR 的精神和目的，因为它要求一个“在最高 AMR 分辨率下的均匀网格”。这将导致灾难性的内存和计算成本。其标度性是 $O(N_{\\text{fine}} \\log N_{\\text{fine}})$，而不是基于实际单元数 $N_{\\text{AMR}}$。此外，它使用周期性边界条件，对于一个孤立的引力系统，即使在一个大盒子里，这也是一个拙劣且物理上不正确的近似。\n- **结论：不正确。**\n\n**B. 在最高分辨率的均匀网格上使用带零填充的、基于 FFT 的自由空间卷积来模拟孤立边界，然后降采样到 AMR 层级。这能精确地保持孤立边界条件，并维持 $O(N \\log N)$ 的标度性，且没有显著的内存开销。**\n- 这个选项也因要求“最高分辨率的均匀网格”而失败。声称这“没有显著的内存开销”是错误的；开销是这种方法未被使用的主要原因。在一个 AMR 流体模拟中，求解器必须在主要数据结构上操作，因此在细网格上求解然后“降采样”的工作流程是无意义的。与选项 A 中的原因相同，标度性论证具有误导性。\n- **结论：不正确。**\n\n**C. 在 AMR 层级结构上使用几何多重网格求解器，在每个层级上进行松弛，在层级之间进行限制和延拓，并通过在外部域上施加基于多极展开的狄利克雷边界来强制执行孤立边界条件。这维持了 $O(N)$ 的复杂度，尊重了 AMR 结构，并避免了周期性环绕。**\n- 这个选项准确地描述了最先进的方法。它正确地指出了多重网格天然适用于 AMR 层级结构。它指定了一种物理上合适且数值上标准的方法（多极展开）来处理孤立边界条件。它正确地陈述了最优的 $O(N)$ 复杂度。它正确地指出，作为一种实空间方法，它避免了 FFT 的周期性假象。这个选项与我们的推导完全一致。\n- **结论：正确。**\n\n**D. 在每个 AMR 补丁上使用局部 FFT 求解，并在补丁边界上施加周期性边界条件；通过在界面处匹配势来耦合各个补丁。这保持了局部性和每个补丁 $O(N \\log N)$ 的标度性，并且当补丁尺寸很小时，与孤立边界是一致的。**\n- 这描述了一种不适用于引力的域分解方法。引力的泊松方程是椭圆型的，意味着任何一点的势都依赖于各处的质量分布。在每个补丁上使用局部周期性求解并试图“耦合”它们是极其困难的，因为 $1/r$ 力的长程性质。一个补丁的边界条件依赖于所有其他补丁，而不仅仅是邻居。声称这“与孤立边界一致”是错误的；局部周期性求解从根本上与全局孤立场不一致。\n- **结论：不正确。**", "answer": "$$\\boxed{C}$$", "id": "3533020"}, {"introduction": "数值模拟本质上是物理过程的近似，因此，验证其数值精度和守恒性是不可或缺的一步。能量和角动量等基本物理量的守恒是衡量模拟可靠性的黄金标准。不守恒的模拟可能会产生完全不符合物理现实的结果，而一个精确的守恒审计（conservation audit）是诊断和量化数值误差来源的关键工具[@problem_id:3533079]。这个动手编程练习将引导您为一个简化的公共包层系统实现一个完整的守恒审计程序，处理诸如移动坐标系和开放边界等复杂情况，这是验证任何流体动力学代码的核心技能。", "problem": "您的任务是为一个与计算天体物理学中的公共包层演化（CEE）相关的简化模拟实现一个守恒审计。该审计必须计算和跟踪在单个离散时间步长内总能量和总角动量的全局变化，并明确修正由开放边界损失和网格运动引起的参考系变换所造成的影响。该实现必须在一个简化模型上运行，该模型由两个点质量（恒星核心）和一小组代表包层的气体单元组成，使用牛顿力学和标准热力学。\n\n程序必须计算更新前后的总能量和总角动量，然后形成修正后的变化量，该变化量需要加回那些已离开计算域的指定损失。请使用以下原理和定义作为您推导和实现的基础。\n\n1. 模型、参考系和更新：\n- 将两个恒星核心视为点质量，其质量分别为 $M_1$ 和 $M_2$，位置为 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$，速度为 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$。\n- 将包层视为一组由索引 $i$ 标识的气体单元，每个单元的质量为 $m_i$，位置为 $\\mathbf{r}_i$，速度为 $\\mathbf{v}_i$，温度为 $T_i$，体积为 $V_i$。\n- 计算网格可以是欧拉（固定）网格或移动网格；移动网格具有均匀的网格速度 $\\mathbf{v}_{\\rm grid}$。速度可以在实验室参考系或网格参考系中提供。如果在网格参考系中提供，则对每个对象（气体单元或核心）使用 $\\mathbf{v}_{\\rm lab}=\\mathbf{v}_{\\rm rel}+\\mathbf{v}_{\\rm grid}$ 转换为实验室参考系。\n- 使用实验室参考系中的速度，通过纯平流在一个持续时间为 $\\Delta t$ 的时间步长内更新位置：\n$$\n\\mathbf{r}^{\\rm final}=\\mathbf{r}^{\\rm initial}+\\mathbf{v}_{\\rm lab}\\,\\Delta t\n$$\n在此简化审计的更新过程中不施加加速度。\n\n2. 总能量 $E_{\\rm tot}$ 的组成部分：\n- 动能：\n$$\nE_{\\rm kin}=\\frac{1}{2}\\sum_i m_i \\|\\mathbf{v}_{\\rm lab,i}\\|^2+\\frac{1}{2}\\sum_{a=1}^{2} M_a \\|\\mathbf{v}_{\\rm lab,a}\\|^2\n$$\n- 理想气体的热（内）能，其绝热指数为 $\\gamma$，平均分子量为 $\\mu$：\n$$\nu_i=\\frac{k_B\\,T_i}{(\\gamma-1)\\,\\mu\\,m_p}=\\frac{3}{2}\\frac{k_B\\,T_i}{\\mu\\,m_p},\\quad E_{\\rm th}=\\sum_i m_i\\,u_i\n$$\n其中 $k_B$ 是玻尔兹曼常数，$m_p$ 是质子质量，并使用了单原子理想气体条件 $\\gamma=5/3$。\n- 辐射能，假设局部热力学平衡：\n$$\nE_{\\rm rad}=\\sum_i a_{\\rm rad}\\,T_i^4\\,V_i\n$$\n其中 $a_{\\rm rad}$ 是辐射常数。\n- 引力势能（牛顿），包括气体单元之间、气体单元与核心之间的两两相互作用，以及核心-核心相互作用：\n$$\nE_{\\rm grav}=-\\sum_{i}\\sum_{a=1}^{2}\\frac{G\\,m_i\\,M_a}{\\|\\mathbf{r}_i-\\mathbf{r}_a\\|}-\\frac{1}{2}\\sum_{i}\\sum_{j\\neq i}\\frac{G\\,m_i\\,m_j}{\\|\\mathbf{r}_i-\\mathbf{r}_j\\|}-\\frac{G\\,M_1\\,M_2}{\\|\\mathbf{r}_1-\\mathbf{r}_2\\|}\n$$\n\n3. 总角动量 $\\mathbf{J}_{\\rm tot}$：\n- 计算总角动量矢量，作为气体单元和核心贡献的总和：\n$$\n\\mathbf{J}_{\\rm tot}=\\sum_i m_i\\,\\mathbf{r}_i\\times \\mathbf{v}_{\\rm lab,i}+\\sum_{a=1}^{2} M_a\\,\\mathbf{r}_a\\times \\mathbf{v}_{\\rm lab,a}\n$$\n报告并使用国际单位制下的大小 $J_{\\rm tot}=\\|\\mathbf{J}_{\\rm tot}\\|$。\n\n4. 修正后的变化量和诊断量：\n- 设 $E_{\\rm out}$ 表示在更新期间离开计算体积的能量（辐射和对流能量损失之和），设 $J_{\\rm out}$ 表示离开该体积的角动量。将修正后的变化量定义为\n$$\n\\Delta E_{\\rm corr}=\\left(E_{\\rm tot}^{\\rm final}+E_{\\rm out}\\right)-E_{\\rm tot}^{\\rm initial},\\qquad\n\\Delta J_{\\rm corr}=\\left(J_{\\rm tot}^{\\rm final}+J_{\\rm out}\\right)-J_{\\rm tot}^{\\rm initial}\n$$\n- 定义分数诊断量\n$$\nf_E=\\frac{\\Delta E_{\\rm corr}}{|E_{\\rm tot}^{\\rm initial}|},\\qquad f_J=\\frac{\\Delta J_{\\rm corr}}{J_{\\rm tot}^{\\rm initial}}\n$$\n它们是无量纲小数。\n- 在所提供的测试套件中，计算 $f_E$ 与网格速率大小 $g=\\|\\mathbf{v}_{\\rm grid}\\|$ 之间以及 $f_E$ 与求解器阶数 $p$ 之间的 Pearson 线性相关系数。\n\n5. 物理常数和单位：\n- 始终使用国际单位制（SI）。\n- 引力常数：$G=6.67430\\times 10^{-11}\\,\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}$。\n- 玻尔兹曼常数：$k_B=1.380649\\times 10^{-23}\\,\\text{J}\\,\\text{K}^{-1}$。\n- 质子质量：$m_p=1.67262192369\\times 10^{-27}\\,\\text{kg}$。\n- 平均分子量：$\\mu=0.61$。\n- 辐射常数：$a_{\\rm rad}=7.5657\\times 10^{-16}\\,\\text{J}\\,\\text{m}^{-3}\\,\\text{K}^{-4}$。\n- 能量必须以 $\\text{J}$（焦耳）为单位计算和汇总，角动量以 $\\text{kg}\\,\\text{m}^2\\,\\text{s}^{-1}$ 为单位。\n\n6. 测试套件：\n实现您的程序来处理以下三种情况，每种情况都指定了初始状态、时间步长、网格运动、求解器阶数、参考系约定和损失。对于每种情况，位置通过 $\\mathbf{r}^{\\rm final}=\\mathbf{r}^{\\rm initial}+\\mathbf{v}_{\\rm lab}\\,\\Delta t$ 更新，而温度 $T_i$ 和体积 $V_i$ 在时间步长内保持不变。\n\n- 情况 1（正常路径，欧拉网格）：\n  - 核心：$M_1=2.386\\times 10^{30}\\,\\text{kg}$ 位于 $\\mathbf{r}_1^{\\rm init}=(-2.5\\times 10^{10},\\,0,\\,0)\\,\\text{m}$，速度为 $\\mathbf{v}_1=(0,\\,4.5\\times 10^{4},\\,0)\\,\\text{m s}^{-1}$；$M_2=1.192\\times 10^{30}\\,\\text{kg}$ 位于 $\\mathbf{r}_2^{\\rm init}=(2.5\\times 10^{10},\\,0,\\,0)\\,\\text{m}$，速度为 $\\mathbf{v}_2=(0,\\,-9.0\\times 10^{4},\\,0)\\,\\text{m s}^{-1}$。\n  - 气体单元 ($i=0,1,2,3$)：\n    - 质量：$[4.0\\times 10^{27},\\,5.0\\times 10^{27},\\,3.5\\times 10^{27},\\,4.5\\times 10^{27}]\\,\\text{kg}$。\n    - 位置：$[(-1.0\\times 10^{10},\\,2.0\\times 10^{10},\\,0),\\,(1.5\\times 10^{10},\\,-2.2\\times 10^{10},\\,0),\\,(-2.0\\times 10^{10},\\,-1.0\\times 10^{10},\\,0),\\,(2.2\\times 10^{10},\\,1.0\\times 10^{10},\\,0)]\\,\\text{m}$。\n    - 速度（实验室参考系）：$[(1.0\\times 10^{4},\\,-0.8\\times 10^{4},\\,0),\\,(-1.2\\times 10^{4},\\,0.5\\times 10^{4},\\,0),\\,(0.6\\times 10^{4},\\,1.8\\times 10^{4},\\,0),\\,(-0.7\\times 10^{4},\\,-1.5\\times 10^{4},\\,0)]\\,\\text{m s}^{-1}$。\n    - 温度：$[1.2\\times 10^{5},\\,1.1\\times 10^{5},\\,0.9\\times 10^{5},\\,1.3\\times 10^{5}]\\,\\text{K}$。\n    - 体积：$[1.0\\times 10^{27},\\,1.2\\times 10^{27},\\,0.9\\times 10^{27},\\,1.1\\times 10^{27}]\\,\\text{m}^3$。\n  - 网格运动：$\\mathbf{v}_{\\rm grid}=(0,\\,0,\\,0)\\,\\text{m s}^{-1}$，速度在实验室参考系中提供。\n  - 时间步长：$\\Delta t=1000\\,\\text{s}$。\n  - 损失：$E_{\\rm out}^{\\rm rad}=5.0\\times 10^{31}\\,\\text{J}$，$E_{\\rm out}^{\\rm adv}=2.0\\times 10^{32}\\,\\text{J}$，$J_{\\rm out}=1.0\\times 10^{41}\\,\\text{kg m}^2 \\text{s}^{-1}$。\n  - 求解器阶数：$p=2$。\n\n- 情况 2（移动网格，速度在网格参考系中提供）：\n  - 核心：$M_1=2.386\\times 10^{30}\\,\\text{kg}$ 位于 $\\mathbf{r}_1^{\\rm init}=(-2.4\\times 10^{10},\\,0,\\,0)\\,\\text{m}$，速度为 $\\mathbf{v}_1=(0,\\,4.6\\times 10^{4},\\,0)\\,\\text{m s}^{-1}$；$M_2=1.192\\times 10^{30}\\,\\text{kg}$ 位于 $\\mathbf{r}_2^{\\rm init}=(2.4\\times 10^{10},\\,0,\\,0)\\,\\text{m}$，速度为 $\\mathbf{v}_2=(0,\\,-9.2\\times 10^{4},\\,0)\\,\\text{m s}^{-1}$。\n  - 气体单元 ($i=0,1,2,3$)：\n    - 质量：$[5.5\\times 10^{27},\\,4.2\\times 10^{27},\\,3.8\\times 10^{27},\\,4.6\\times 10^{27}]\\,\\text{kg}$。\n    - 位置：$[(-1.2\\times 10^{10},\\,1.8\\times 10^{10},\\,0),\\,(1.8\\times 10^{10},\\,-1.9\\times 10^{10},\\,0),\\,(-1.5\\times 10^{10},\\,-1.2\\times 10^{10},\\,0),\\,(2.4\\times 10^{10},\\,0.8\\times 10^{10},\\,0)]\\,\\text{m}$。\n    - 速度（网格参考系）：$[(0.8\\times 10^{4},\\,-1.0\\times 10^{4},\\,0),\\,(-1.1\\times 10^{4},\\,0.6\\times 10^{4},\\,0),\\,(0.5\\times 10^{4},\\,1.6\\times 10^{4},\\,0),\\,(-0.9\\times 10^{4},\\,-1.2\\times 10^{4},\\,0)]\\,\\text{m s}^{-1}$。\n    - 温度：$[1.0\\times 10^{5},\\,1.2\\times 10^{5},\\,1.1\\times 10^{5},\\,0.95\\times 10^{5}]\\,\\text{K}$。\n    - 体积：$[1.1\\times 10^{27},\\,1.0\\times 10^{27},\\,1.0\\times 10^{27},\\,1.2\\times 10^{27}]\\,\\text{m}^3$。\n  - 网格运动：$\\mathbf{v}_{\\rm grid}=(2.0\\times 10^{4},\\,0,\\,0)\\,\\text{m s}^{-1}$，速度在网格参考系中提供，必须转换为实验室参考系。\n  - 时间步长：$\\Delta t=800\\,\\text{s}$。\n  - 损失：$E_{\\rm out}^{\\rm rad}=1.5\\times 10^{32}\\,\\text{J}$，$E_{\\rm out}^{\\rm adv}=5.0\\times 10^{31}\\,\\text{J}$，$J_{\\rm out}=2.0\\times 10^{41}\\,\\text{kg m}^2 \\text{s}^{-1}$。\n  - 求解器阶数：$p=3$。\n\n- 情况 3（边界情况，高网格速度）：\n  - 核心：$M_1=2.386\\times 10^{30}\\,\\text{kg}$ 位于 $\\mathbf{r}_1^{\\rm init}=(-2.6\\times 10^{10},\\,0,\\,0)\\,\\text{m}$，速度为 $\\mathbf{v}_1=(0,\\,4.4\\times 10^{4},\\,0)\\,\\text{m s}^{-1}$；$M_2=1.192\\times 10^{30}\\,\\text{kg}$ 位于 $\\mathbf{r}_2^{\\rm init}=(2.6\\times 10^{10},\\,0,\\,0)\\,\\text{m}$，速度为 $\\mathbf{v}_2=(0,\\,-8.8\\times 10^{4},\\,0)\\,\\text{m s}^{-1}$。\n  - 气体单元 ($i=0,1,2,3$)：\n    - 质量：$[4.8\\times 10^{27},\\,5.0\\times 10^{27},\\,4.0\\times 10^{27},\\,3.8\\times 10^{27}]\\,\\text{kg}$。\n    - 位置：$[(-1.0\\times 10^{10},\\,1.5\\times 10^{10},\\,0),\\,(1.9\\times 10^{10},\\,-1.5\\times 10^{10},\\,0),\\,(-1.7\\times 10^{10},\\,-1.3\\times 10^{10},\\,0),\\,(2.0\\times 10^{10},\\,0.5\\times 10^{10},\\,0)]\\,\\text{m}$。\n    - 速度（网格参考系）：$[(1.2\\times 10^{4},\\,-0.6\\times 10^{4},\\,0),\\,(-1.0\\times 10^{4},\\,0.8\\times 10^{4},\\,0),\\,(0.7\\times 10^{4},\\,1.4\\times 10^{4},\\,0),\\,(-1.1\\times 10^{4},\\,-1.3\\times 10^{4},\\,0)]\\,\\text{m s}^{-1}$。\n    - 温度：$[1.05\\times 10^{5},\\,1.15\\times 10^{5},\\,1.05\\times 10^{5},\\,1.00\\times 10^{5}]\\,\\text{K}$。\n    - 体积：$[1.15\\times 10^{27},\\,1.05\\times 10^{27},\\,1.00\\times 10^{27},\\,1.10\\times 10^{27}]\\,\\text{m}^3$。\n  - 网格运动：$\\mathbf{v}_{\\rm grid}=(6.0\\times 10^{4},\\,-1.0\\times 10^{4},\\,0)\\,\\text{m s}^{-1}$，速度在网格参考系中提供，必须转换。\n  - 时间步长：$\\Delta t=1200\\,\\text{s}$。\n  - 损失：$E_{\\rm out}^{\\rm rad}=3.0\\times 10^{32}\\,\\text{J}$，$E_{\\rm out}^{\\rm adv}=1.0\\times 10^{32}\\,\\text{J}$，$J_{\\rm out}=3.5\\times 10^{41}\\,\\text{kg m}^2 \\text{s}^{-1}$。\n  - 求解器阶数：$p=1$。\n\n7. 必需的最终输出：\n- 对于三种情况中的每一种，计算两个诊断量 $f_E$ 和 $f_J$。\n- 在这三种情况中，计算 $f_E$ 与网格速率大小 $g$ 之间以及 $f_E$ 与求解器阶数 $p$ 之间的 Pearson 相关系数。\n- 您的程序应生成单行输出，其中包含一个包含在方括号中的逗号分隔列表，其结构应完全如下：\n$$\n\\left[ [f_{E,1},f_{J,1}], [f_{E,2},f_{J,2}], [f_{E,3},f_{J,3}], \\rho_{f_E,g}, \\rho_{f_E,p} \\right],\n$$\n其中 $\\rho_{f_E,g}$ 是 $f_E$ 和 $g$ 之间的 Pearson 相关性，$\\rho_{f_E,p}$ 是 $f_E$ 和 $p$ 之间的 Pearson 相关性。不需要四舍五入，但值必须是可从输入计算出的有效实数。\n\n通过严格遵守给定的公式和规定的单位约定，确保您的实现具有科学真实性。所有数值结果必须采用国际单位制，能量单位为 $\\text{J}$，角动量单位为 $\\text{kg m}^2 \\text{s}^{-1}$，而 $f_E$、$f_J$ 和相关系数是无量纲小数。", "solution": "该审计必须通过明确地对更新前后的明确定义的能量和角动量贡献求和来跟踪守恒性，同时修正已知的损失并确保网格运动下参考系的一致性。\n\n基于原理的推导：\n\n1. 参考系和更新。对于在网格（移动网格）参考系中提供的任何速度，通过 $\\mathbf{v}_{\\rm lab}=\\mathbf{v}_{\\rm rel}+\\mathbf{v}_{\\rm grid}$ 获得实验室参考系中的速度。对于欧拉网格，$\\mathbf{v}_{\\rm grid}=\\mathbf{0}$ 且 $\\mathbf{v}_{\\rm lab}=\\mathbf{v}$。在时间步长 $\\Delta t$ 内的更新是纯平流的：\n$$\n\\mathbf{r}^{\\rm final}=\\mathbf{r}^{\\rm initial}+\\mathbf{v}_{\\rm lab}\\,\\Delta t,\n$$\n适用于所有气体单元和两个核心。这保证了位置与所选速度参考系的一致性。这种简化的更新将守恒审计与动力学分离开来，专注于诊断的一致性而非物理积分。\n\n2. 能量学。总能量是各项之和 $E_{\\rm tot}=E_{\\rm kin}+E_{\\rm th}+E_{\\rm rad}+E_{\\rm grav}$。\n- 动能由牛顿力学得出：\n$$\nE_{\\rm kin}=\\frac{1}{2}\\sum_i m_i \\|\\mathbf{v}_{\\rm lab,i}\\|^2+\\frac{1}{2}\\sum_{a=1}^2 M_a \\|\\mathbf{v}_{\\rm lab,a}\\|^2.\n$$\n- 理想气体的热能依赖于 $u=p/[(\\gamma-1)\\rho]$，以及对于平均分子量为 $\\mu$ 的完全电离的等离子体的 $p=\\rho k_B T/(\\mu m_p)$。结合起来得到\n$$\nu=\\frac{k_B T}{(\\gamma-1)\\mu m_p}=\\frac{3}{2}\\frac{k_B T}{\\mu m_p}\n$$\n对于 $\\gamma=5/3$。总热能为 $E_{\\rm th}=\\sum_i m_i u_i$。\n- 辐射能假设局部热力学平衡，并使用黑体辐射能量密度 $e_{\\rm rad}=a_{\\rm rad}T^4$，在单元体积 $V_i$ 上积分：\n$$\nE_{\\rm rad}=\\sum_i a_{\\rm rad} T_i^4 V_i.\n$$\n- 引力势能是所有两两相互作用的总和。为避免对点质量和气体单元重复计算，需要\n$$\nE_{\\rm grav}=-\\sum_{i}\\sum_{a=1}^{2}\\frac{G\\,m_i\\,M_a}{\\|\\mathbf{r}_i-\\mathbf{r}_a\\|}-\\frac{1}{2}\\sum_{i}\\sum_{j\\neq i}\\frac{G\\,m_i\\,m_j}{\\|\\mathbf{r}_i-\\mathbf{r}_j\\|}-\\frac{G\\,M_1\\,M_2}{\\|\\mathbf{r}_1-\\mathbf{r}_2\\|}.\n$$\n这使用了牛顿万有引力定律，是点质量系统的正确离散形式。\n\n3. 角动量。总角动量矢量是所有质量贡献的总和：\n$$\n\\mathbf{J}_{\\rm tot}=\\sum_i m_i\\,\\mathbf{r}_i\\times \\mathbf{v}_{\\rm lab,i}+\\sum_{a=1}^{2} M_a\\,\\mathbf{r}_a\\times \\mathbf{v}_{\\rm lab,a}.\n$$\n计算其大小 $J_{\\rm tot}=\\|\\mathbf{J}_{\\rm tot}\\|$。叉乘的定义是基础：$\\mathbf{r}\\times \\mathbf{v}$ 垂直于由位置和速度张成的平面。\n\n4. 修正后的变化量和归一化。由于计算域可能通过辐射和开放边界损失能量和角动量，我们必须加回这些损失来审计封闭系统的守恒性：\n$$\n\\Delta E_{\\rm corr}=\\left(E_{\\rm tot}^{\\rm final}+E_{\\rm out}\\right)-E_{\\rm tot}^{\\rm initial},\\quad E_{\\rm out}=E_{\\rm out}^{\\rm rad}+E_{\\rm out}^{\\rm adv},\n$$\n$$\n\\Delta J_{\\rm corr}=\\left(J_{\\rm tot}^{\\rm final}+J_{\\rm out}\\right)-J_{\\rm tot}^{\\rm initial}.\n$$\n分数诊断量使用绝对值归一化以避免符号问题：\n$$\nf_E=\\frac{\\Delta E_{\\rm corr}}{|E_{\\rm tot}^{\\rm initial}|},\\qquad f_J=\\frac{\\Delta J_{\\rm corr}}{J_{\\rm tot}^{\\rm initial}}.\n$$\n这些无量纲值量化了相对漂移，并且在不同尺度上具有鲁棒性。\n\n5. 与求解器阶数和网格运动的相关性。两个数组 $x$ 和 $y$ 之间的 Pearson 相关系数为\n$$\n\\rho_{x,y}=\\frac{{\\rm cov}(x,y)}{\\sigma_x\\,\\sigma_y},\n$$\n其中 ${\\rm cov}$ 表示协方差，$\\sigma$ 表示标准差。计算 $\\rho_{f_E,g}$（其中 $g=\\|\\mathbf{v}_{\\rm grid}\\|$ 是每个案例的网格速率）和 $\\rho_{f_E,p}$（其中 $p$ 是求解器阶数）。这量化了守恒误差如何随数值选择和网格运动学变化。\n\n算法设计：\n- 解析案例参数和常数。\n- 使用规定的规则将所有速度转换为实验室参考系。\n- 通过 $\\mathbf{r}^{\\rm final}=\\mathbf{r}^{\\rm initial}+\\mathbf{v}_{\\rm lab}\\,\\Delta t$ 更新气体单元和核心的位置。\n- 使用上述定义计算初始和最终状态的 $E_{\\rm kin}$、$E_{\\rm th}$、$E_{\\rm rad}$ 和 $E_{\\rm grav}$。\n- 计算初始和最终状态的 $\\mathbf{J}_{\\rm tot}$ 矢量及其大小。\n- 使用提供的损失形成 $\\Delta E_{\\rm corr}$ 和 $\\Delta J_{\\rm corr}$。\n- 为每个案例计算 $f_E$ 和 $f_J$。\n- 构建 $f_E$、网格速率大小 $g$ 和求解器阶数 $p$ 的数组，并通过标准 Pearson 相关性计算 $\\rho_{f_E,g}$ 和 $\\rho_{f_E,p}$。\n- 按指定格式输出单行结果：\n$$\n\\left[ [f_{E,1},f_{J,1}], [f_{E,2},f_{J,2}], [f_{E,3},f_{J,3}], \\rho_{f_E,g}, \\rho_{f_E,p} \\right].\n$$\n所有数值计算都严格遵守国际单位制以及从牛顿力学和理想气体热力学推导出的公式，从而为求解器和网格选择下的守恒诊断提供科学上合理的审计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants (SI units)\nG = 6.67430e-11            # m^3 kg^-1 s^-2\nk_B = 1.380649e-23         # J K^-1\nm_p = 1.67262192369e-27    # kg\nmu = 0.61                  # mean molecular weight\ngamma = 5.0 / 3.0          # monatomic ideal gas\na_rad = 7.5657e-16         # J m^-3 K^-4\n\ndef to_lab_velocity(v, v_grid, vel_frame):\n    \"\"\"Convert velocity to laboratory frame based on frame flag.\"\"\"\n    if vel_frame == 'grid':\n        return v + v_grid\n    else:\n        return v\n\ndef update_positions(r_init, v_lab, dt):\n    \"\"\"Advect positions over timestep dt with lab-frame velocities.\"\"\"\n    return r_init + v_lab * dt\n\ndef kinetic_energy(masses, velocities):\n    \"\"\"Compute kinetic energy: 0.5 * sum(m * |v|^2).\"\"\"\n    v2 = np.sum(velocities**2, axis=1)\n    return 0.5 * np.sum(masses * v2)\n\ndef internal_energy(masses, temperatures):\n    \"\"\"Compute thermal energy for ideal gas: sum(m * u), u = k_B T / ((gamma-1) mu m_p).\"\"\"\n    u = (k_B * temperatures) / ((gamma - 1.0) * mu * m_p)\n    return np.sum(masses * u)\n\ndef radiation_energy(temperatures, volumes):\n    \"\"\"Compute radiation energy: sum(a_rad * T^4 * V).\"\"\"\n    return np.sum(a_rad * (temperatures**4) * volumes)\n\ndef pairwise_grav_energy(m1, r1, m2, r2):\n    \"\"\"Compute pairwise gravitational energy -G m1 m2 / |r1 - r2|.\"\"\"\n    dr = r1 - r2\n    dist = np.linalg.norm(dr)\n    # Avoid division by zero (should not occur with provided test data)\n    return -G * m1 * m2 / dist\n\ndef gravitational_energy(gas_masses, gas_positions, core_masses, core_positions):\n    \"\"\"Compute total gravitational energy: gas-core + gas-gas + core-core.\"\"\"\n    # Gas-core interactions\n    E_gc = 0.0\n    for i in range(len(gas_masses)):\n        for a in range(len(core_masses)):\n            E_gc += pairwise_grav_energy(gas_masses[i], gas_positions[i], core_masses[a], core_positions[a])\n    # Gas-gas interactions (0.5 * sum over i!=j)\n    E_gg = 0.0\n    n = len(gas_masses)\n    for i in range(n):\n        for j in range(i + 1, n):\n            E_gg += pairwise_grav_energy(gas_masses[i], gas_positions[i], gas_masses[j], gas_positions[j])\n    E_gg *= 1.0  # already counted each pair once\n    # Core-core interaction\n    E_cc = pairwise_grav_energy(core_masses[0], core_positions[0], core_masses[1], core_positions[1])\n    return E_gc + E_gg + E_cc\n\ndef angular_momentum(masses, positions, velocities):\n    \"\"\"Compute total angular momentum vector: sum(m r x v).\"\"\"\n    J_vec = np.array([0.0, 0.0, 0.0])\n    for i in range(len(masses)):\n        J_vec += masses[i] * np.cross(positions[i], velocities[i])\n    return J_vec\n\ndef compute_totals(state):\n    \"\"\"\n    Compute initial and final total energies and angular momenta.\n    State dict contains:\n      - cores: list of dicts with keys M, r_init, v, vel_frame\n      - gas: list of dicts with keys m, r_init, v, T, V, vel_frame\n      - v_grid: np.array([vx, vy, vz])\n      - dt: float\n      - losses: dict with keys E_rad_out, E_adv_out, J_out\n      - solver_order: int\n    \"\"\"\n    v_grid = state['v_grid']\n    dt = state['dt']\n\n    # Prepare cores\n    core_masses = []\n    core_r_init = []\n    core_v_lab = []\n    for core in state['cores']:\n        core_masses.append(core['M'])\n        core_r_init.append(np.array(core['r_init'], dtype=float))\n        core_v_lab.append(to_lab_velocity(np.array(core['v'], dtype=float), v_grid, core['vel_frame']))\n    core_masses = np.array(core_masses, dtype=float)\n    core_r_init = np.array(core_r_init, dtype=float)\n    core_v_lab = np.array(core_v_lab, dtype=float)\n\n    # Prepare gas\n    gas_masses = []\n    gas_r_init = []\n    gas_v_lab = []\n    gas_T = []\n    gas_V = []\n    for cell in state['gas']:\n        gas_masses.append(cell['m'])\n        gas_r_init.append(np.array(cell['r_init'], dtype=float))\n        gas_v_lab.append(to_lab_velocity(np.array(cell['v'], dtype=float), v_grid, cell['vel_frame']))\n        gas_T.append(cell['T'])\n        gas_V.append(cell['V'])\n    gas_masses = np.array(gas_masses, dtype=float)\n    gas_r_init = np.array(gas_r_init, dtype=float)\n    gas_v_lab = np.array(gas_v_lab, dtype=float)\n    gas_T = np.array(gas_T, dtype=float)\n    gas_V = np.array(gas_V, dtype=float)\n\n    # Final positions after advection\n    core_r_final = update_positions(core_r_init, core_v_lab, dt)\n    gas_r_final = update_positions(gas_r_init, gas_v_lab, dt)\n    # Final velocities remain the same in this simplified audit (lab frame)\n    core_v_final = core_v_lab.copy()\n    gas_v_final = gas_v_lab.copy()\n\n    # Energies initial\n    E_kin_init = kinetic_energy(gas_masses, gas_v_lab) + kinetic_energy(core_masses, core_v_lab)\n    E_th_init = internal_energy(gas_masses, gas_T)\n    E_rad_init = radiation_energy(gas_T, gas_V)\n    E_grav_init = gravitational_energy(gas_masses, gas_r_init, core_masses, core_r_init)\n    E_tot_init = E_kin_init + E_th_init + E_rad_init + E_grav_init\n\n    # Energies final\n    E_kin_final = kinetic_energy(gas_masses, gas_v_final) + kinetic_energy(core_masses, core_v_final)\n    E_th_final = internal_energy(gas_masses, gas_T)  # unchanged T\n    E_rad_final = radiation_energy(gas_T, gas_V)     # unchanged T, V\n    E_grav_final = gravitational_energy(gas_masses, gas_r_final, core_masses, core_r_final)\n    E_tot_final = E_kin_final + E_th_final + E_rad_final + E_grav_final\n\n    # Angular momenta initial and final\n    J_gas_init = angular_momentum(gas_masses, gas_r_init, gas_v_lab)\n    J_core_init = angular_momentum(core_masses, core_r_init, core_v_lab)\n    J_tot_init_vec = J_gas_init + J_core_init\n    J_tot_init = np.linalg.norm(J_tot_init_vec)\n\n    J_gas_final = angular_momentum(gas_masses, gas_r_final, gas_v_final)\n    J_core_final = angular_momentum(core_masses, core_r_final, core_v_final)\n    J_tot_final_vec = J_gas_final + J_core_final\n    J_tot_final = np.linalg.norm(J_tot_final_vec)\n\n    # Loss corrections\n    E_out = state['losses']['E_rad_out'] + state['losses']['E_adv_out']\n    J_out = state['losses']['J_out']\n\n    # Corrected changes and fractional diagnostics\n    dE_corr = (E_tot_final + E_out) - E_tot_init\n    dJ_corr = (J_tot_final + J_out) - J_tot_init\n\n    fE = dE_corr / abs(E_tot_init) if E_tot_init != 0.0 else np.nan\n    fJ = dJ_corr / J_tot_init if J_tot_init != 0.0 else np.nan\n\n    return {\n        'fE': fE,\n        'fJ': fJ,\n        'grid_speed': np.linalg.norm(v_grid),\n        'solver_order': state['solver_order']\n    }\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    case1 = {\n        'cores': [\n            {'M': 2.386e30, 'r_init': [-2.5e10, 0.0, 0.0], 'v': [0.0, 4.5e4, 0.0], 'vel_frame': 'lab'},\n            {'M': 1.192e30, 'r_init': [ 2.5e10, 0.0, 0.0], 'v': [0.0,-9.0e4, 0.0], 'vel_frame': 'lab'},\n        ],\n        'gas': [\n            {'m': 4.0e27, 'r_init': [-1.0e10,  2.0e10, 0.0], 'v': [ 1.0e4, -0.8e4, 0.0], 'T': 1.2e5, 'V': 1.0e27, 'vel_frame': 'lab'},\n            {'m': 5.0e27, 'r_init': [ 1.5e10, -2.2e10, 0.0], 'v': [-1.2e4,  0.5e4, 0.0], 'T': 1.1e5, 'V': 1.2e27, 'vel_frame': 'lab'},\n            {'m': 3.5e27, 'r_init': [-2.0e10, -1.0e10, 0.0], 'v': [ 0.6e4,  1.8e4, 0.0], 'T': 0.9e5, 'V': 0.9e27, 'vel_frame': 'lab'},\n            {'m': 4.5e27, 'r_init': [ 2.2e10,  1.0e10, 0.0], 'v': [-0.7e4, -1.5e4, 0.0], 'T': 1.3e5, 'V': 1.1e27, 'vel_frame': 'lab'},\n        ],\n        'v_grid': np.array([0.0, 0.0, 0.0]),\n        'dt': 1000.0,\n        'losses': {'E_rad_out': 5.0e31, 'E_adv_out': 2.0e32, 'J_out': 1.0e41},\n        'solver_order': 2\n    }\n\n    case2 = {\n        'cores': [\n            {'M': 2.386e30, 'r_init': [-2.4e10, 0.0, 0.0], 'v': [0.0, 4.6e4, 0.0], 'vel_frame': 'grid'},\n            {'M': 1.192e30, 'r_init': [ 2.4e10, 0.0, 0.0], 'v': [0.0,-9.2e4, 0.0], 'vel_frame': 'grid'},\n        ],\n        'gas': [\n            {'m': 5.5e27, 'r_init': [-1.2e10,  1.8e10, 0.0], 'v': [ 0.8e4, -1.0e4, 0.0], 'T': 1.0e5,  'V': 1.1e27, 'vel_frame': 'grid'},\n            {'m': 4.2e27, 'r_init': [ 1.8e10, -1.9e10, 0.0], 'v': [-1.1e4,  0.6e4, 0.0], 'T': 1.2e5,  'V': 1.0e27, 'vel_frame': 'grid'},\n            {'m': 3.8e27, 'r_init': [-1.5e10, -1.2e10, 0.0], 'v': [ 0.5e4,  1.6e4, 0.0], 'T': 1.1e5,  'V': 1.0e27, 'vel_frame': 'grid'},\n            {'m': 4.6e27, 'r_init': [ 2.4e10,  0.8e10, 0.0], 'v': [-0.9e4, -1.2e4, 0.0], 'T': 0.95e5, 'V': 1.2e27, 'vel_frame': 'grid'},\n        ],\n        'v_grid': np.array([2.0e4, 0.0, 0.0]),\n        'dt': 800.0,\n        'losses': {'E_rad_out': 1.5e32, 'E_adv_out': 5.0e31, 'J_out': 2.0e41},\n        'solver_order': 3\n    }\n\n    case3 = {\n        'cores': [\n            {'M': 2.386e30, 'r_init': [-2.6e10, 0.0, 0.0], 'v': [0.0, 4.4e4, 0.0], 'vel_frame': 'grid'},\n            {'M': 1.192e30, 'r_init': [ 2.6e10, 0.0, 0.0], 'v': [0.0,-8.8e4, 0.0], 'vel_frame': 'grid'},\n        ],\n        'gas': [\n            {'m': 4.8e27, 'r_init': [-1.0e10,  1.5e10, 0.0], 'v': [ 1.2e4, -0.6e4, 0.0], 'T': 1.05e5, 'V': 1.15e27, 'vel_frame': 'grid'},\n            {'m': 5.0e27, 'r_init': [ 1.9e10, -1.5e10, 0.0], 'v': [-1.0e4,  0.8e4, 0.0], 'T': 1.15e5, 'V': 1.05e27, 'vel_frame': 'grid'},\n            {'m': 4.0e27, 'r_init': [-1.7e10, -1.3e10, 0.0], 'v': [ 0.7e4,  1.4e4, 0.0], 'T': 1.05e5, 'V': 1.00e27, 'vel_frame': 'grid'},\n            {'m': 3.8e27, 'r_init': [ 2.0e10,  0.5e10, 0.0], 'v': [-1.1e4, -1.3e4, 0.0], 'T': 1.00e5, 'V': 1.10e27, 'vel_frame': 'grid'},\n        ],\n        'v_grid': np.array([6.0e4, -1.0e4, 0.0]),\n        'dt': 1200.0,\n        'losses': {'E_rad_out': 3.0e32, 'E_adv_out': 1.0e32, 'J_out': 3.5e41},\n        'solver_order': 1\n    }\n\n    test_cases = [case1, case2, case3]\n\n    results = []\n    fE_list = []\n    grid_speeds = []\n    solver_orders = []\n\n    for state in test_cases:\n        res = compute_totals(state)\n        results.append([res['fE'], res['fJ']])\n        fE_list.append(res['fE'])\n        grid_speeds.append(res['grid_speed'])\n        solver_orders.append(res['solver_order'])\n\n    fE_arr = np.array(fE_list, dtype=float)\n    grid_arr = np.array(grid_speeds, dtype=float)\n    p_arr = np.array(solver_orders, dtype=float)\n\n    # Compute Pearson correlation coefficients\n    # Handle potential degenerate cases: if variance is zero, correlation is NaN.\n    def pearson_corr(x, y):\n        if np.allclose(np.std(x), 0.0) or np.allclose(np.std(y), 0.0):\n            return float('nan')\n        c = np.corrcoef(x, y)\n        return float(c[0, 1])\n\n    corr_grid = pearson_corr(fE_arr, grid_arr)\n    corr_solver = pearson_corr(fE_arr, p_arr)\n\n    # Final print statement in the exact required format.\n    # Convert nested lists to string without additional text.\n    output_items = []\n    # Three case results\n    for pair in results:\n        output_items.append(f\"[{pair[0]},{pair[1]}]\")\n    # Correlations\n    output_items.append(str(corr_grid))\n    output_items.append(str(corr_solver))\n    print(f\"[{','.join(output_items)}]\")\n\nsolve()\n```", "id": "3533079"}]}