{"hands_on_practices": [{"introduction": "在开始任何数值相对论模拟之前，我们必须首先构建一个在初始时刻 $t=0$ 精确满足爱因斯坦约束方程的初始数据集。这个过程是确保模拟物理真实性的基石。该练习 [@problem_id:3533369] 将引导您动手实践广义相对论中哈密顿约束和动量约束的离散化，这是生成致密天体并合初始数据的核心步骤。通过在一个精确解已知的受控环境中验证您的数值实现，您将深入理解离散化误差的来源以及如何量化代码的收敛阶。", "problem": "您的任务是构建和分析适用于致密天体并合模拟的、在单一空间切片上的广义相对论约束的离散评估。请在标准的 $3+1$ 分解框架下工作，并使用几何化单位制（$G=c=1$），以使所有物理量均为无量纲量。从 Arnowitt–Deser–Misner (ADM) 约束出发，这些约束被认为是数值相对论初始数据的基本法则：\n- 哈密顿约束为 $\\mathcal{H} \\equiv R + K^2 - K_{ij} K^{ij} - 16\\pi \\rho$，其中 $R$ 是空间度规的标量曲率，$K_{ij}$ 是外禀曲率，$K \\equiv \\gamma^{ij} K_{ij}$ 是其迹，$\\rho$ 是欧拉观测者测量的能量密度。\n- 动量约束为 $\\mathcal{M}_i \\equiv D_j\\!\\left(K^j{}_i - \\delta^j{}_i K\\right) - 8\\pi S_i$，其中 $D_j$ 是与 $\\gamma_{ij}$ 相容的协变导数，$S_i$ 是动量密度。\n\n为确保一个科学上真实且受控的设定，请考虑在立方体区域 $[-L,L]^3$（其中 $L=1$）上的共形平直空间度规，即 $\\gamma_{ij} = \\psi^4 \\delta_{ij}$，以及一个与度规成正比的各向同性外禀曲率 $K_{ij} = \\kappa(\\mathbf{x})\\,\\gamma_{ij}$。选择光滑且具有紧致支撑的场，这些场是黑洞-中子星并合初始数据生成中的典型代表：\n- 共形因子 $\\psi(\\mathbf{x}) = 1 + A\\,\\exp\\!\\left(-\\frac{x^2 + y^2 + z^2}{\\sigma^2}\\right)$，\n- 曲率振幅 $\\kappa(\\mathbf{x}) = B\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\,\\sin(\\pi z)$。\n\n请从 ADM 约束出发，推导物质场 $\\rho$ 和 $S_i$ 的表达式，使得对于上述 ansatz，连续谱约束恒成立。具体来说：\n- 在共形平直条件下，用 $\\psi$ 及其导数表示 $R$。\n- 用 $\\kappa$ 和度规表示 $K$ 和 $K_{ij}K^{ij}$。\n- 用 $\\kappa$、$\\psi$ 及其导数表示 $D_j\\!\\left(K^j{}_i - \\delta^j{}_i K\\right)$。\n\n在包含 $N^3$ 个点的均匀网格上（其中 $N \\in \\{33,49,65\\}$）实现二阶中心有限差分。令 $h = 2L/(N-1)$ 为网格间距。在计算导数和范数时，仅使用内部点（不包括边界）。在每种分辨率下：\n- 使用二阶中心差分近似导数。\n- 计算内部点上的离散哈密顿残差 $\\mathcal{H}_{\\text{num}}$ 和动量残差向量 $\\mathcal{M}_{i,\\text{num}}$。\n- 计算哈密顿残差的 $L_2$ 范数，其定义为内部点上 $\\mathcal{H}_{\\text{num}}^2$ 均值的平方根。\n- 计算动量残差的 $L_2$ 范数，方法是先逐点计算平方范数 $\\mathcal{M}_{x,\\text{num}}^2 + \\mathcal{M}_{y,\\text{num}}^2 + \\mathcal{M}_{z,\\text{num}}^2$，然后取其在内部点上均值的平方根。\n\n对于二阶差分格式，分析两个约束关于 $h$ 的观测收敛阶。对于每个测试用例，通过比较连续分辨率下的 $L_2$ 残差来估计阶数 $p$，公式为 $p \\equiv \\log\\!\\left(e(h_1)/e(h_2)\\right)/\\log\\!\\left(h_1/h_2\\right)$，其中 $e(h)$ 表示间距为 $h$ 时的 $L_2$ 残差。分别计算 $(N=33,N=49)$ 和 $(N=49,N=65)$ 之间的阶数，并分别报告哈密頓约束和动量约束的平均值。\n\n使用以下参数值测试套件来探究不同情况：\n1. 情况1（理想路径）：$A=0.2$, $\\sigma=0.6$, $B=0.05$。\n2. 情况2（宽共形隆起）：$A=0.1$, $\\sigma=0.9$, $B=0.04$。\n3. 情况3（窄且更强的曲率）：$A=0.5$, $\\sigma=0.4$, $B=0.08$。\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是一个包含两个浮点数的列表 $[p_{\\mathcal{H}},p_{\\mathcal{M}}]$。例如，输出应类似于 \"[[pH_case1,pM_case1],[pH_case2,pM_case2],[pH_case3,pM_case3]]\"。所有输出都是无量纲的，表示为没有单位或百分号的浮点数。", "solution": "我们从 Arnowitt–Deser–Misner (ADM) 约束出发，这是数值相对论中构建初始数据的基础：\n$$\n\\mathcal{H} \\equiv R + K^2 - K_{ij}K^{ij} - 16\\pi \\rho,\n$$\n$$\n\\mathcal{M}_i \\equiv D_j\\!\\left(K^j{}_i - \\delta^j{}_i K\\right) - 8\\pi S_i.\n$$\n我们设定一个共形平直空间度规 $\\gamma_{ij} = \\psi^4 \\delta_{ij}$ 和一个各向同性的外禀曲率 $K_{ij} = \\kappa(\\mathbf{x})\\,\\gamma_{ij}$。在致密天体并合的初始数据中，这种选择是常见且科学上真实的。待定的物质场 $\\rho$ 和 $S_i$ 的选择應使得连续谱约束被精确满足。\n\n步骤1：共形平直下的几何恒等式。对于 $\\gamma_{ij} = \\psi^4 \\delta_{ij}$，标量曲率为\n$$\nR = -8\\,\\psi^{-5}\\,\\nabla^2 \\psi,\n$$\n其中 $\\nabla^2$ 是关于 $\\delta_{ij}$ 的平直空间拉普拉斯算子。空间度规的 Christoffel 符号为\n$$\n\\Gamma^i{}_{jk} = 2\\left(\\delta^i{}_j\\,\\partial_k \\ln\\psi + \\delta^i{}_k\\,\\partial_j \\ln\\psi - \\delta_{jk}\\,\\delta^{im}\\,\\partial_m \\ln\\psi\\right),\n$$\n其前两个指标的迹为\n$$\n\\Gamma^j{}_{jk} = 6\\,\\partial_k \\ln\\psi.\n$$\n\n步骤2：外禀曲率的缩并。当 $K_{ij} = \\kappa\\,\\gamma_{ij}$ 时，我们得到\n$$\nK \\equiv \\gamma^{ij} K_{ij} = \\gamma^{ij}\\,\\kappa\\,\\gamma_{ij} = \\kappa\\,\\delta^i{}_i = 3\\,\\kappa,\n$$\n和\n$$\nK_{ij}K^{ij} = \\kappa\\,\\gamma_{ij}\\;\\kappa\\,\\gamma^{ij} = 3\\,\\kappa^2.\n$$\n因此\n$$\nK^2 - K_{ij}K^{ij} = 9\\kappa^2 - 3\\kappa^2 = 6\\kappa^2.\n$$\n\n步骤3：动量约束的散度。定义 $T^j{}_i \\equiv K^j{}_i - \\delta^j{}_i K$。将一个指标升标后，$K^j{}_i = \\gamma^{jk}K_{ki} = \\gamma^{jk}\\,\\kappa\\,\\gamma_{ki} = \\kappa\\,\\delta^j{}_i$。因此\n$$\nT^j{}_i = \\kappa\\,\\delta^j{}_i - \\delta^j{}_i K = -2\\,\\kappa\\,\\delta^j{}_i.\n$$\n其散度为\n$$\nD_j T^j{}_i = \\partial_j T^j{}_i + \\Gamma^j{}_{jk}T^k{}_i - \\Gamma^k{}_{ji}T^j{}_k.\n$$\n给定 $T^j{}_i = -2\\,\\kappa\\,\\delta^j{}_i$，第一项变为 $\\partial_j T^j{}_i = -2\\,\\partial_i \\kappa$。对于 Christoffel 项，我们使用 $\\Gamma^j{}_{jk} = 6\\,\\partial_k \\ln\\psi$ 并观察到 $T^k{}_i = -2\\kappa\\,\\delta^k{}_i$ 和 $T^j{}_k = -2\\kappa\\,\\delta^j{}_k$。因此\n$$\n\\Gamma^j{}_{jk}T^k{}_i = -12\\,\\kappa\\,\\partial_i \\ln\\psi,\\quad\n\\Gamma^k{}_{ji}T^j{}_k = -12\\,\\kappa\\,\\partial_i \\ln\\psi,\n$$\n它们相互抵消：\n$$\nD_j T^j{}_i = -2\\,\\partial_i\\kappa.\n$$\n因此，为强制满足连续谱动量约束 $\\mathcal{M}_i=0$，我们必须选择\n$$\nS_i = \\frac{1}{8\\pi} D_j T^j{}_i = -\\frac{1}{4\\pi}\\,\\partial_i\\kappa.\n$$\n\n步骤4：哈密顿约束的物质场。使用 $R = -8\\,\\psi^{-5}\\,\\nabla^2\\psi$ 和 $K^2 - K_{ij}K^{ij} = 6\\kappa^2$，哈密顿约束 $\\mathcal{H} = 0$ 意味着\n$$\n\\rho = \\frac{1}{16\\pi}\\left(R + K^2 - K_{ij}K^{ij}\\right)\n= \\frac{1}{16\\pi}\\left(-8\\,\\psi^{-5}\\,\\nabla^2\\psi + 6\\,\\kappa^2\\right).\n$$\n\n步骤5：所选场的解析导数。我们选择\n$$\n\\psi(\\mathbf{x}) = 1 + A\\,\\exp\\!\\left(-\\frac{r^2}{\\sigma^2}\\right),\\quad r^2 \\equiv x^2+y^2+z^2,\n$$\n其拉普拉斯算子为\n$$\n\\nabla^2 \\psi = A\\,\\exp\\!\\left(-\\frac{r^2}{\\sigma^2}\\right)\\left(\\frac{4r^2}{\\sigma^4} - \\frac{6}{\\sigma^2}\\right),\n$$\n以及\n$$\n\\kappa(\\mathbf{x}) = B\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\,\\sin(\\pi z),\n$$\n其梯度分量为\n$$\n\\partial_x \\kappa = B\\,\\pi\\,\\cos(\\pi x)\\,\\sin(\\pi y)\\,\\sin(\\pi z),\\quad\n\\partial_y \\kappa = B\\,\\pi\\,\\sin(\\pi x)\\,\\cos(\\pi y)\\,\\sin(\\pi z),\\quad\n\\partial_z \\kappa = B\\,\\pi\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\,\\cos(\\pi z).\n$$\n至此，连续谱的 $\\rho$ 和 $S_i$ 已被完全确定。\n\n步骤6：离散算子与预期标度关系。在具有 $N^3$ 个点和间距 $h = 2L/(N-1)$ 的均匀网格上实现二阶中心差分，仅使用内部点计算导数：\n- 对于标量 $f$，内部点上 $x$ 方向的离散一阶导数为 $(f_{i+1,j,k}-f_{i-1,j,k})/(2h)$，二阶导数为 $(f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k})/h^2$，$y$ 和 $z$ 方向有类似公式。\n- 离散拉普拉斯算子是 $x, y, z$ 方向二阶导数的和。\n\n我们如下评估数值约束：\n- 哈密顿残差：\n$$\n\\mathcal{H}_{\\text{num}} = R_{\\text{num}} + K^2 - K_{ij}K^{ij} - 16\\pi\\rho,\n\\quad R_{\\text{num}} = -8\\,\\psi^{-5}\\,\\nabla^2_{\\text{num}}\\psi,\n$$\n使用内部点上 $\\psi$ 的离散拉普拉斯算子计算。注意 $K=3\\kappa$ 和 $K_{ij}K^{ij}=3\\kappa^2$ 是逐点代数关系。\n- 内部点的动量残差分量：\n$$\n\\mathcal{M}_{i,\\text{num}} = D_j^{\\text{num}} T^j{}_i - 8\\pi S_i,\n$$\n其中 $T^j{}_i = -2\\,\\kappa\\,\\delta^j{}_i$，且\n$$\nD_j^{\\text{num}} T^j{}_i = \\partial_j^{\\text{num}} T^j{}_i + \\Gamma^j{}_{jk,\\text{num}}\\,T^k{}_i - \\Gamma^k{}_{ji,\\text{num}}\\,T^j{}_k,\n$$\n其中 $\\Gamma^j{}_{jk,\\text{num}} = 6\\,\\partial_k^{\\text{num}}\\ln\\psi$，而 $\\Gamma^k{}_{ji,\\text{num}}$ 对 $j$ 缩并后变为 $6\\,\\partial_i^{\\text{num}}\\ln\\psi$。在数值上，由于截断误差，抵消并非精确的，残差的大小与差分误差成标度关系。\n\n在光滑性假设下，二阶中心差分的截断误差为 $\\mathcal{O}(h^2)$ 阶。由于通过构造，连续谱约束是精确满足的，残差完全来自于有限差分误差，因此其 $L_2$ 范数应具有 $e(h) = C\\,h^2 + \\mathcal{O}(h^3)$ 的标度关系，这意味着在比较连续分辨率时，观测到的收敛阶 $p \\approx 2$。\n\n步骤7：测试套件与输出。对于由 $(A,\\sigma,B)$ 指定的三个情况中的每一个，以及分辨率 $N\\in\\{33,49,65\\}$，计算哈密顿和动量约束的 $L_2$ 残差，估计连续 $N$ 对之间的 $p$ 值，并报告每个约束的两个 $p$ 值的平均值。程序的最终输出必须是遵循精确格式的单行文本\n$$\n\\text{[[}p_{\\mathcal{H},1}\\text{,}p_{\\mathcal{M},1}\\text{],[}p_{\\mathcal{H},2}\\text{,}p_{\\mathcal{M},2}\\text{],[}p_{\\mathcal{H},3}\\text{,}p_{\\mathcal{M},3}\\text{]]},\n$$\n其中每个 $p$ 都是一个浮点数。在几何化单位制中，所有量都是无量纲的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_grid(L, N):\n    x = np.linspace(-L, L, N)\n    y = np.linspace(-L, L, N)\n    z = np.linspace(-L, L, N)\n    X, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n    h = (2 * L) / (N - 1)\n    return X, Y, Z, h\n\ndef analytic_fields(A, sigma, B, X, Y, Z):\n    r2 = X**2 + Y**2 + Z**2\n    psi = 1.0 + A * np.exp(-r2 / (sigma**2))\n    # Laplacian of psi from analytic derivative\n    lap_psi = A * np.exp(-r2 / (sigma**2)) * (4.0 * r2 / (sigma**4) - 6.0 / (sigma**2))\n    # kappa and its analytic gradients\n    pi = np.pi\n    sinx = np.sin(pi * X)\n    siny = np.sin(pi * Y)\n    sinz = np.sin(pi * Z)\n    cosx = np.cos(pi * X)\n    cosy = np.cos(pi * Y)\n    cosz = np.cos(pi * Z)\n    kappa = B * sinx * siny * sinz\n    dkappa_dx_true = B * pi * cosx * siny * sinz\n    dkappa_dy_true = B * pi * sinx * cosy * sinz\n    dkappa_dz_true = B * pi * sinx * siny * cosz\n    # Scalar curvature R (continuum)\n    R_true = -8.0 * (psi**-5) * lap_psi\n    # K and K_ij K^ij\n    K = 3.0 * kappa\n    KK = 3.0 * (kappa**2)\n    # Matter density rho from Hamiltonian constraint\n    rho_true = (R_true + K**2 - KK) / (16.0 * np.pi)\n    # Momentum density S_i from momentum constraint\n    Sx_true = -(1.0 / (4.0 * np.pi)) * dkappa_dx_true\n    Sy_true = -(1.0 / (4.0 * np.pi)) * dkappa_dy_true\n    Sz_true = -(1.0 / (4.0 * np.pi)) * dkappa_dz_true\n    return psi, kappa, R_true, K, KK, rho_true, (Sx_true, Sy_true, Sz_true)\n\ndef central_diff_first(f, h, axis):\n    \"\"\"\n    Compute first derivative with second-order central differences along given axis.\n    Returns derivative at interior points only.\n    \"\"\"\n    if axis == 0:\n        return (f[2:, 1:-1, 1:-1] - f[:-2, 1:-1, 1:-1]) / (2.0 * h)\n    elif axis == 1:\n        return (f[1:-1, 2:, 1:-1] - f[1:-1, :-2, 1:-1]) / (2.0 * h)\n    elif axis == 2:\n        return (f[1:-1, 1:-1, 2:] - f[1:-1, 1:-1, :-2]) / (2.0 * h)\n    else:\n        raise ValueError(\"Invalid axis\")\n\ndef central_diff_second(f, h, axis):\n    \"\"\"\n    Compute second derivative with second-order central differences along given axis.\n    Returns derivative at interior points only.\n    \"\"\"\n    if axis == 0:\n        return (f[2:, 1:-1, 1:-1] - 2.0 * f[1:-1, 1:-1, 1:-1] + f[:-2, 1:-1, 1:-1]) / (h * h)\n    elif axis == 1:\n        return (f[1:-1, 2:, 1:-1] - 2.0 * f[1:-1, 1:-1, 1:-1] + f[1:-1, :-2, 1:-1]) / (h * h)\n    elif axis == 2:\n        return (f[1:-1, 1:-1, 2:] - 2.0 * f[1:-1, 1:-1, 1:-1] + f[1:-1, 1:-1, :-2]) / (h * h)\n    else:\n        raise ValueError(\"Invalid axis\")\n\ndef compute_residuals(A, sigma, B, L, N):\n    # Build grid and fields\n    X, Y, Z, h = generate_grid(L, N)\n    psi, kappa, R_true, K, KK, rho_true, S_true = analytic_fields(A, sigma, B, X, Y, Z)\n    Sx_true, Sy_true, Sz_true = S_true\n\n    # Interior slices\n    psi_i = psi[1:-1, 1:-1, 1:-1]\n    kappa_i = kappa[1:-1, 1:-1, 1:-1]\n    K_i = K[1:-1, 1:-1, 1:-1]\n    KK_i = KK[1:-1, 1:-1, 1:-1]\n    rho_i = rho_true[1:-1, 1:-1, 1:-1]\n    Sx_i = Sx_true[1:-1, 1:-1, 1:-1]\n    Sy_i = Sy_true[1:-1, 1:-1, 1:-1]\n    Sz_i = Sz_true[1:-1, 1:-1, 1:-1]\n\n    # Discrete Laplacian of psi\n    d2x_psi = central_diff_second(psi, h, axis=0)\n    d2y_psi = central_diff_second(psi, h, axis=1)\n    d2z_psi = central_diff_second(psi, h, axis=2)\n    lap_psi_num = d2x_psi + d2y_psi + d2z_psi\n\n    # Numerical R\n    R_num = -8.0 * (psi_i**-5) * lap_psi_num\n\n    # Hamiltonian residual\n    H_num = R_num + K_i**2 - KK_i - 16.0 * np.pi * rho_i\n\n    # Momentum residual: compute covariant divergence numerically\n    # T^j_i = -2 kappa delta^j_i - components: T^x_x = T^y_y = T^z_z = -2 kappa, others 0\n    # Partial derivatives\n    dkappa_dx_num = central_diff_first(kappa, h, axis=0)\n    dkappa_dy_num = central_diff_first(kappa, h, axis=1)\n    dkappa_dz_num = central_diff_first(kappa, h, axis=2)\n    # Christoffel traces from ln(psi)\n    lnpsi = np.log(psi)\n    dlnpsi_dx_num = central_diff_first(lnpsi, h, axis=0)\n    dlnpsi_dy_num = central_diff_first(lnpsi, h, axis=1)\n    dlnpsi_dz_num = central_diff_first(lnpsi, h, axis=2)\n    Gamma_tr_x = 6.0 * dlnpsi_dx_num\n    Gamma_tr_y = 6.0 * dlnpsi_dy_num\n    Gamma_tr_z = 6.0 * dlnpsi_dz_num\n\n    # Assemble D_j T^j_i for each i\n    # For i = x: ∂_x T^x_x + Γ^j_{jk} T^k_x - Γ^k_{jx} T^j_k\n    # T^k_x nonzero only for k=x and equals -2 kappa_i\n    # T^j_k nonzero only when j=k; thus sum gives -2 kappa_i\n    Tx_div = -2.0 * dkappa_dx_num + Gamma_tr_x * (-2.0 * kappa_i) - (6.0 * dlnpsi_dx_num) * (-2.0 * kappa_i)\n    Ty_div = -2.0 * dkappa_dy_num + Gamma_tr_y * (-2.0 * kappa_i) - (6.0 * dlnpsi_dy_num) * (-2.0 * kappa_i)\n    Tz_div = -2.0 * dkappa_dz_num + Gamma_tr_z * (-2.0 * kappa_i) - (6.0 * dlnpsi_dz_num) * (-2.0 * kappa_i)\n\n    Mx_num = Tx_div - 8.0 * np.pi * Sx_i\n    My_num = Ty_div - 8.0 * np.pi * Sy_i\n    Mz_num = Tz_div - 8.0 * np.pi * Sz_i\n\n    # L2 norms over interior\n    H_l2 = float(np.sqrt(np.mean(H_num**2)))\n    M_l2 = float(np.sqrt(np.mean(Mx_num**2 + My_num**2 + Mz_num**2)))\n\n    return H_l2, M_l2, h\n\ndef observed_order(errors, hs):\n    # errors: list [e1, e2, e3], hs: list [h1, h2, h3]\n    p1 = np.log(errors[0] / errors[1]) / np.log(hs[0] / hs[1])\n    p2 = np.log(errors[1] / errors[2]) / np.log(hs[1] / hs[2])\n    return float((p1 + p2) / 2.0)\n\ndef run_case(A, sigma, B):\n    L = 1.0\n    Ns = [33, 49, 65]\n    H_errors = []\n    M_errors = []\n    hs = []\n    for N in Ns:\n        H_l2, M_l2, h = compute_residuals(A, sigma, B, L, N)\n        H_errors.append(H_l2)\n        M_errors.append(M_l2)\n        hs.append(h)\n    pH = observed_order(H_errors, hs)\n    pM = observed_order(M_errors, hs)\n    return pH, pM\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.2, 0.6, 0.05),  # Case 1\n        (0.1, 0.9, 0.04),  # Case 2\n        (0.5, 0.4, 0.08),  # Case 3\n    ]\n\n    results = []\n    for (A, sigma, B) in test_cases:\n        pH, pM = run_case(A, sigma, B)\n        # format to a reasonable number of decimals\n        results.append([round(pH, 6), round(pM, 6)])\n\n    # Final print statement in the exact required format.\n    # Produce a single line like [[pH1,pM1],[pH2,pM2],[pH3,pM3]]\n    inner = \",\".join(\"[\" + \",\".join(map(str, pair)) + \"]\" for pair in results)\n    print(f\"[{inner}]\")\n\nsolve()\n```", "id": "3533369"}, {"introduction": "预测和提取引力波信号是致密天体并合模拟的一个核心科学目标。然而，由于计算域是有限的，我们在有限半径的“提取区”测量引力波时，不可避免地会遇到来自人工外部边界的虚假反射，这会污染物理信号。本练习 [@problem_id:3533381] 提供了一个简化的球对称模型，让您能够从第一性原理出发，定量分析边界条件的有效性。通过推导反射系数，您将亲自揭示数值误差与波频率及计算域大小之间的关键关系，这是设计高保真度引力波数值模拟时必须考虑的核心问题。", "problem": "您正在对致密天体并合的数值模拟中的引力波 (GW) 提取进行建模，其中计算域被截断在半径为 $R$ 的有限外边界处。在物理上真实的区域中，出射的引力波信号可以近似为一个角频率为 $\\omega = 2\\pi f$、波数为 $k = \\omega / c$ 的单色球面波，其中 $f$ 是频率（单位为 $\\mathrm{Hz}$），$c$ 是真空中的光速。域截断采用在 $r = R$ 处施加的一阶出射辐射边界条件 (Sommerfeld)，\n$$\n\\partial_t \\psi + c\\,\\partial_r \\psi = 0,\n$$\n其中 $\\psi(r,t)$ 表示代表引力波自由度的辐射场，$c$ 是引力波在真空中的传播速度。\n\n在外边界附近，假设该场是具有复振幅的出射和入射球面波的叠加，\n$$\n\\psi(r,t) = \\frac{A_{\\mathrm{out}} e^{i(kr - \\omega t)} + A_{\\mathrm{in}} e^{-i(kr + \\omega t)}}{r}.\n$$\n边界的不完美吸收将导致出射波的部分反射。从第一性原理出发，基于上述边界条件和单色球面波拟设，推导在 $r = R$ 处的复反射系数 $\\mathcal{R} = A_{\\mathrm{in}}/A_{\\mathrm{out}}$ 及其模 $|\\mathcal{R}|$ 作为 $c$、$R$ 和 $\\omega$ 的函数的表达式。然后，确定所需的最小边界半径 $R_{\\mathrm{req}}(f,\\varepsilon)$，以保证在频率 $f$ 下由反射引起的振幅污染满足 $|\\mathcal{R}| \\le \\varepsilon$，其中 $\\varepsilon$ 是一个预设界限；在本问题中，设 $\\varepsilon = 0.01$。\n\n您的程序必须：\n- 使用 $c = 299{,}792{,}458\\,\\mathrm{m/s}$。\n- 对每个测试用例计算：\n  1. 反射振幅 $|\\mathcal{R}|$ (无量纲)。\n  2. 在给定频率下确保 $|\\mathcal{R}| \\le 0.01$ 所需的最小半径 $R_{\\mathrm{req}}$ (单位为米)。\n  3. 一个布尔值，指示所提供的边界半径 $R$ 是否在给定频率下满足 $0.01$ 的污染目标 (即 $|\\mathcal{R}| \\le 0.01$ 是否成立)。\n- 将反射振幅表示为四舍五入到六位小数的小数。\n- 将 $R_{\\mathrm{req}}$ 以米为单位表示，并四舍五入到三位有效数字。\n- 将 $f$ 的单位视为 $\\mathrm{Hz}$，所有角度隐式地以弧度为单位。\n- 最终输出为单行：一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是按上述顺序排列的包含三个值的列表。\n\n测试套件：\n- 用例 1 (典型中频，中等半径)：$f = 150\\,\\mathrm{Hz}$, $R = 1.0\\times 10^{7}\\,\\mathrm{m}$。\n- 用例 2 (低频，小半径)：$f = 30\\,\\mathrm{Hz}$, $R = 1.0\\times 10^{7}\\,\\mathrm{m}$。\n- 用例 3 (高频，中等半径)：$f = 1000\\,\\mathrm{Hz}$, $R = 1.0\\times 10^{8}\\,\\mathrm{m}$。\n- 用例 4 (大半径，中频)：$f = 400\\,\\mathrm{Hz}$, $R = 5.0\\times 10^{9}\\,\\mathrm{m}$。\n- 用例 5 (近阈值半径)：$f = 150\\,\\mathrm{Hz}$, $R = 1.6\\times 10^{7}\\,\\mathrm{m}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个结果必须是 $[\\;|\\mathcal{R}|,\\;R_{\\mathrm{req}},\\;\\text{布尔值}\\;]$ 形式的列表。", "solution": "该问题是有效的，因为它科学地基于计算物理学中使用的波传播和边界条件的原理，问题陈述清晰，目标明确，信息充分，并使用了客观、正式的语言。测试用例的参数对于数值相对论模拟是物理上合理的。\n\n解决方案需要推导反射系数 $\\mathcal{R}$ 的表达式，然后用它来找到在给定反射容差 $\\varepsilon$ 下所需的最小边界半径 $R_{\\mathrm{req}}$。\n\n代表引力波自由度的辐射场 $\\psi(r,t)$ 被给出为出射和入射球面波的叠加：\n$$\n\\psi(r,t) = \\frac{A_{\\mathrm{out}} e^{i(kr - \\omega t)} + A_{\\mathrm{in}} e^{-i(kr + \\omega t)}}{r}\n$$\n这里，$A_{\\mathrm{out}}$ 是出射波的复振幅，$A_{\\mathrm{in}}$ 是（伪）入射波的复振幅，$r$ 是径向坐标，$t$ 是时间，$\\omega = 2\\pi f$ 是角频率，$k = \\omega/c$ 是波数。\n\n计算域在半径 $r=R$ 处被截断，那里施加了一阶 Sommerfeld 出射辐射边界条件：\n$$\n\\partial_t \\psi + c\\,\\partial_r \\psi = 0 \\quad \\text{at } r=R\n$$\n为了求出反射系数 $\\mathcal{R} = A_{\\mathrm{in}}/A_{\\mathrm{out}}$，我们必须使用给定形式的 $\\psi(r,t)$ 来计算此边界条件。\n\n首先，我们计算 $\\psi(r,t)$ 的必要偏导数。\n关于时间 $t$ 的偏导数是：\n$$\n\\partial_t \\psi(r,t) = \\frac{1}{r} \\left[ A_{\\mathrm{out}}(-i\\omega)e^{i(kr - \\omega t)} + A_{\\mathrm{in}}(-i\\omega)e^{-i(kr + \\omega t)} \\right] = -\\frac{i\\omega}{r} \\left[ A_{\\mathrm{out}}e^{i(kr - \\omega t)} + A_{\\mathrm{in}}e^{-i(kr + \\omega t)} \\right]\n$$\n关于径向坐标 $r$ 的偏导数使用乘法法则求得：\n$$\n\\partial_r \\psi(r,t) = -\\frac{1}{r^2}\\left[ A_{\\mathrm{out}} e^{i(kr - \\omega t)} + A_{\\mathrm{in}} e^{-i(kr + \\omega t)} \\right] + \\frac{1}{r}\\left[ A_{\\mathrm{out}}(ik)e^{i(kr - \\omega t)} + A_{\\mathrm{in}}(-ik)e^{-i(kr + \\omega t)} \\right]\n$$\n$$\n\\partial_r \\psi(r,t) = -\\frac{1}{r^2}\\left[ A_{\\mathrm{out}} e^{i(kr - \\omega t)} + A_{\\mathrm{in}} e^{-i(kr + \\omega t)} \\right] + \\frac{ik}{r}\\left[ A_{\\mathrm{out}} e^{i(kr - \\omega t)} - A_{\\mathrm{in}} e^{-i(kr + \\omega t)} \\right]\n$$\n\n现在，我们将这些导数代入 $r=R$ 处的边界条件，并使用关系式 $\\omega = ck$：\n$$\n\\left. \\left( \\partial_t \\psi + c\\,\\partial_r \\psi \\right) \\right|_{r=R} = 0\n$$\n$$\n-\\frac{i(ck)}{R} \\left[ \\dots \\right]_{r=R} + c \\left( -\\frac{1}{R^2}\\left[ \\dots \\right]_{r=R} + \\frac{ik}{R}\\left[ \\dots' \\right]_{r=R} \\right) = 0\n$$\n其中 $[\\dots]$ 代表求和项 $(A_{\\mathrm{out}} e^{i(kR - \\omega t)} + A_{\\mathrm{in}} e^{-i(kR + \\omega t)})$ 而 $[\\dots']$ 代表求差项 $(A_{\\mathrm{out}} e^{i(kR - \\omega t)} - A_{\\mathrm{in}} e^{-i(kR + \\omega t)})$。\n\n提出公共的时间相关项 $e^{-i\\omega t}$ 并将整个方程乘以 $R^2$ 得到：\n$$\n-ickR \\left[ A_{\\mathrm{out}}e^{ikR} + A_{\\mathrm{in}}e^{-ikR} \\right] - c \\left[ A_{\\mathrm{out}}e^{ikR} + A_{\\mathrm{in}}e^{-ikR} \\right] + ickR \\left[ A_{\\mathrm{out}}e^{ikR} - A_{\\mathrm{in}}e^{-ikR} \\right] = 0\n$$\n我们按 $A_{\\mathrm{out}}$ 和 $A_{\\mathrm{in}}$ 对各项进行分组：\n$$\nA_{\\mathrm{out}}e^{ikR}(-ickR - c + ickR) + A_{\\mathrm{in}}e^{-ikR}(-ickR - c - ickR) = 0\n$$\n$$\nA_{\\mathrm{out}}e^{ikR}(-c) + A_{\\mathrm{in}}e^{-ikR}(-c - 2ickR) = 0\n$$\n$$\nA_{\\mathrm{in}}e^{-ikR}(-c(1 + 2ikR)) = A_{\\mathrm{out}}e^{ikR}(c)\n$$\n求解复反射系数 $\\mathcal{R} = A_{\\mathrm{in}}/A_{\\mathrm{out}}$：\n$$\n\\mathcal{R} = \\frac{A_{\\mathrm{in}}}{A_{\\mathrm{out}}} = \\frac{c e^{ikR}}{-c(1 + 2ikR) e^{-ikR}} = - \\frac{e^{2ikR}}{1 + 2ikR}\n$$\n反射系数的模 $|\\mathcal{R}|$ 是：\n$$\n|\\mathcal{R}| = \\left| - \\frac{e^{2ikR}}{1 + 2ikR} \\right| = \\frac{|-1| \\cdot |e^{2ikR}|}{|1 + 2ikR|} = \\frac{1}{\\sqrt{1^2 + (2kR)^2}} = \\frac{1}{\\sqrt{1 + 4(kR)^2}}\n$$\n代入 $k = 2\\pi f / c$，我们得到反射振幅的最终表达式：\n$$\n|\\mathcal{R}| = \\frac{1}{\\sqrt{1 + 4 \\left(\\frac{2\\pi f R}{c}\\right)^2}} = \\frac{1}{\\sqrt{1 + \\frac{16\\pi^2 f^2 R^2}{c^2}}}\n$$\n此公式用于计算每个测试用例的第一个值。\n\n接下来，我们推导所需的最小半径 $R_{\\mathrm{req}}$，以确保反射振幅被容差 $\\varepsilon$ 所限制，即 $|\\mathcal{R}| \\le \\varepsilon$。\n$$\n\\frac{1}{\\sqrt{1 + 4(kR)^2}} \\le \\varepsilon\n$$\n$$\n\\sqrt{1 + 4(kR)^2} \\ge \\frac{1}{\\varepsilon}\n$$\n$$\n1 + 4(kR)^2 \\ge \\frac{1}{\\varepsilon^2}\n$$\n$$\n4(kR)^2 \\ge \\frac{1}{\\varepsilon^2} - 1\n$$\n$$\nR^2 \\ge \\frac{1}{4k^2} \\left( \\frac{1}{\\varepsilon^2} - 1 \\right)\n$$\n因此，最小半径 $R_{\\mathrm{req}}$ 为：\n$$\nR_{\\mathrm{req}} = \\frac{1}{2k} \\sqrt{\\frac{1}{\\varepsilon^2} - 1}\n$$\n代入 $k = 2\\pi f / c$：\n$$\nR_{\\mathrm{req}}(f, \\varepsilon) = \\frac{c}{4\\pi f} \\sqrt{\\frac{1}{\\varepsilon^2} - 1}\n$$\n在给定的容差 $\\varepsilon = 0.01$ 下，此公式用于计算每个测试用例的第二个值。\n\n最后，对于第三个值，我们检查所提供的边界半径 $R$ 是否满足污染目标。如果给定 $f$ 和 $R$ 的反射振幅满足 $|\\mathcal{R}| \\le \\varepsilon$，则为真。因此，对于每个测试用例，我们计算 $|\\mathcal{R}|$ 并检查它是否小于或等于 $0.01$。\n\n程序将为每个测试用例实现这些公式，并应用指定的舍入规则。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave reflection problem for a set of test cases.\n    \"\"\"\n    \n    # Constants\n    # Speed of light in vacuum (m/s)\n    c = 299792458.0 \n    # Reflection amplitude tolerance\n    epsilon = 0.01\n\n    # Test suite: (frequency in Hz, boundary radius in m)\n    test_cases = [\n        (150.0, 1.0e7),    # Case 1\n        (30.0, 1.0e7),     # Case 2\n        (1000.0, 1.0e8),   # Case 3\n        (400.0, 5.0e9),    # Case 4\n        (150.0, 1.6e7)     # Case 5\n    ]\n\n    results = []\n\n    def round_to_significant_figures(num, sig_figs):\n        \"\"\"\n        Rounds a number to a specified number of significant figures.\n        \"\"\"\n        if num == 0:\n            return 0.0\n        \n        # Calculate the power of 10 to shift the decimal\n        power = sig_figs - int(np.floor(np.log10(abs(num)))) - 1\n        return round(num, power)\n\n    for f, R in test_cases:\n        # Calculate wave number k\n        k = 2.0 * np.pi * f / c\n\n        # 1. Calculate the reflection amplitude |R|\n        mag_R = 1.0 / np.sqrt(1.0 + 4.0 * (k * R)**2)\n        \n        # 2. Calculate the minimal required radius R_req\n        # The term sqrt(1/epsilon^2 - 1) is constant for all cases\n        sqrt_term = np.sqrt(1.0 / epsilon**2 - 1.0)\n        R_req = (c / (4.0 * np.pi * f)) * sqrt_term\n        \n        # 3. Check if the given radius R is sufficient\n        is_sufficient = (mag_R = epsilon)\n\n        # Format results according to problem specification\n        # Round |R| to six decimal places\n        rounded_mag_R = round(mag_R, 6)\n        \n        # Round R_req to three significant figures\n        rounded_R_req = round_to_significant_figures(R_req, 3)\n        \n        # Append the list of results for this test case\n        results.append([rounded_mag_R, rounded_R_req, is_sufficient])\n\n    # Final print statement in the exact required format.\n    # The output is a string representation of a list of lists.\n    # Note: str(bool) correctly produces 'True' or 'False'.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    # To match the example format better, remove spaces after commas in lists\n    print(output_str.replace(' ', ''))\n\nsolve()\n```", "id": "3533381"}, {"introduction": "在完成一次复杂的数值模拟后，最关键的问题是：我们如何相信得到的结果？在计算科学中，答案在于严格的收敛性测试，这是验证代码正确性的“黄金标准”。本练习 [@problem_id:3533416] 模拟了这一至关重要的验证过程，为您提供了来自不同分辨率下中子星并合模拟的合成数据。您的任务是运用收敛性分析的基本原理，为约束违反、引力波相位和质量守恒等关键诊断量计算观测到的收敛阶。这项实践将使您掌握评估和验证复杂数值模拟结果的核心技能。", "problem": "您将获得来自三个中子星-中子星（NS-NS）并合模拟的综合但科学上合理的多分辨率诊断数据。目标是估算三个量的观测收敛阶：哈密顿约束违反（作为域积分的$L^{2}$范数）、在固定推迟时间的引力波（GW）相位，以及重子质量不守恒分数。您的程序必须从主导阶截断误差模型出发，根据第一性原理实现收敛阶估计，并且必须报告每种模拟情况下所有三个量的估计阶数。\n\n从以下基本原理开始：\n- 在间距为 $h$ 的均匀网格上测量的足够光滑的量 $Q$ 的离散化误差，通常表现出渐进行为 $Q(h)=Q_{\\infty}+C\\,h^{p}+O\\!\\left(h^{p+1}\\right)$，其中 $Q_{\\infty}$ 是连续极限值，$C$ 是一个与 $h$ 无关的常数，$p$ 是该方法在渐进区域内的形式精度阶。\n- 对于本身就是误差的量，例如约束的范数或守恒缺陷分数，主导阶行为简化为 $E(h)=A\\,h^{p}+O\\!\\left(h^{p+1}\\right)$，其中 $A$ 为常数。\n- 对于相位类的诊断量，例如在不同分辨率下测量的同一物理事件的引力波相位，在常数加密因子下，连续分辨率之间的差值可以消除主导阶中未知的 $Q_{\\infty}$。\n\n您的程序必须实现以下估计策略，不得使用任何预先提供的目标公式：\n- 对于约束和质量守恒误差：通过识别并利用误差的对数与网格间距的对数之间隐含的线性关系来确定观测阶 $p$。在每种情况下使用所有可用的分辨率水平。\n- 对于引力波相位：通过使用至少三个共享相同加密比率的连续分辨率水平来消除未知的连续谱相位 $Q_{\\infty}$，从而确定观测阶 $p$。在每种情况下使用所有可用的三元组，并一致地汇总估计值。\n\n单位与定义：\n- 网格间距 $h$ 的单位是米。在所有情况下，计算域长度为 $L=1.0\\times 10^{5}\\,\\mathrm{m}$，网格点数为 $N$，因此 $h=L/N$。\n- 哈密顿约束的 $L^{2}$ 范数是无量纲的。\n- 引力波相位的单位是弧度。\n- 重子质量不守恒分数是无量纲的（一个无单位的分数）。\n- 在计算相位差和比率时，将相位视为以弧度为单位的连续实数角度。\n\n返回格式与四舍五入：\n- 对于每种情况，计算三个浮点数：哈密顿约束、引力波相位和质量守恒的观测阶，按此顺序排列。\n- 将每个观测阶四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个案例按相同顺序贡献一个子列表。例如：“[$[p_{H}^{(1)},p_{\\phi}^{(1)},p_{M}^{(1)}]$,$[p_{H}^{(2)},p_{\\phi}^{(2)},p_{M}^{(2)}]$,$[p_{H}^{(3)},p_{\\phi}^{(3)},p_{M}^{(3)}]$]”。\n\n测试套件（三个案例）：\n- A案例（理想情况，三个级别，常数加密因子 $r=2$）：$L=1.0\\times 10^{5}\\,\\mathrm{m}$，$N \\in \\{64,128,256\\}$，因此 $h=L/N$。并合时刻的哈密顿约束 $L^{2}$ 误差：$[2.80\\times 10^{-3},\\,6.70\\times 10^{-4},\\,1.60\\times 10^{-4}]$。固定推迟时间的引力波相位（以弧度为单位）：$[12.345+0.038147,\\,12.345+0.004768,\\,12.345+0.000596]$。重子质量不守恒分数：$[3.08708\\times 10^{-4},\\,1.09265\\times 10^{-4},\\,3.86810\\times 10^{-5}]$。\n- B案例（四个级别，常数加密因子 $r=2$，中等噪声容限）：$L=1.0\\times 10^{5}\\,\\mathrm{m}$，$N \\in \\{48,96,192,384\\}$。哈密顿约束 $L^{2}$ 误差：$[1.2000\\times 10^{-2},\\,3.2145\\times 10^{-3},\\,8.6130\\times 10^{-4},\\,2.3080\\times 10^{-4}]$。引力波相位（以弧度为单位）：$[9.876+0.05173,\\,9.876+0.00796,\\,9.876+0.001225,\\,9.876+0.0001885]$。重子质量不守恒分数：$[2.0000\\times 10^{-4},\\,5.0000\\times 10^{-5},\\,1.2500\\times 10^{-5},\\,3.1250\\times 10^{-6}]$。\n- C案例（三个级别，常数加密因子 $r=2$）：$L=1.0\\times 10^{5}\\,\\mathrm{m}$，$N \\in \\{72,144,288\\}$。哈密顿约束 $L^{2}$ 误差：$[4.2000\\times 10^{-3},\\,1.4860\\times 10^{-3},\\,5.2570\\times 10^{-4}]$。引力波相位（以弧度为单位）：$[15.555+0.03000,\\,15.555+0.005303,\\,15.555+0.0009375]$。重子质量不守恒分数：$[1.8000\\times 10^{-4},\\,9.0000\\times 10^{-5},\\,4.5000\\times 10^{-5}]$。\n\n角度单位是弧度。没有用户输入。程序必须硬编码上述测试套件，计算观测阶，并完全按照指定格式打印最终的单行输出，其中包含嵌套列表，每个数字四舍五入到三位小数。", "solution": "该问题要求估算从中子星并合数值模拟中获得的三种不同物理量的收敛阶 $p$。该估计必须从提供的主导阶误差模型中推导出来。我们将通过首先建立估计程序的数学基础，然后将这些程序应用于所提供的三个案例的每个数据，来解决这个问题。\n\n该问题指定了两种类型的诊断量，每种都有不同的误差模型。\n\n**1. 类误差量的估计**\n\n对于本质上是误差度量的诊断量，例如哈密顿约束违反 $E_H$（一个 $L^2$ 范数）和重子质量不守恒分数 $E_M$，其作为网格间距 $h$ 的函数的主导阶行为由下式给出：\n$$E(h) = A h^p + \\mathcal{O}(h^{p+1})$$\n其中 $A$ 是一个与 $h$ 无关的常数，$p$ 是收敛阶。\n\n为了从一组对应于不同分辨率的数据点 $(h_i, E_i)$ 中确定 $p$，对于足够小的 $h$，我们可以忽略高阶项：\n$$E(h) \\approx A h^p$$\n对两边取自然对数，将此幂律关系转换为线性关系：\n$$\\ln(E) \\approx \\ln(A h^p) = \\ln(A) + p \\ln(h)$$\n该方程具有直线形式 $y = c + mx$，其中 $y = \\ln(E)$，$x = \\ln(h)$，y轴截距为 $c = \\ln(A)$，斜率即为收敛阶 $m = p$。\n\n问题要求使用所有可用的分辨率水平来估计 $p$。最好的方法是对变换后的数据点集 $\\{(\\ln(h_i), \\ln(E_i))\\}$ 执行线性回归。最佳拟合线的斜率提供了对收敛阶 $p$ 的稳健估计。对于每种情况，我们将使用最小二乘法来找到 $E_H$ 和 $E_M$ 的斜率。网格间距 $h$ 是根据给定的计算域长度 $L = 1.0 \\times 10^5 \\, \\mathrm{m}$ 和网格点数 $N$ 计算得出的，即 $h = L/N$。\n\n**2. 类相位量的估计**\n\n对于一个类相位量，例如收敛到非零连续谱值 $\\phi_\\infty$ 的引力波（GW）相位 $\\phi$，其误差模型为：\n$$\\phi(h) = \\phi_\\infty + C h^p + \\mathcal{O}(h^{p+1})$$\n此处，$\\phi_\\infty$ 和常数 $C$ 都是未知的。为了估计 $p$，我们必须首先消除 $\\phi_\\infty$。这可以通过使用来自具有恒定加密比率 $r$ 的三个分辨率的数据点来完成。设三个连续分辨率的网格间距为 $h_c$（粗）、$h_m$（中）和 $h_f$（细），使得 $h_c = r h_m$ 和 $h_m = r h_f$。相应的相位测量值为 $\\phi_c$、$\\phi_m$ 和 $\\phi_f$。\n\n忽略高阶项，我们为每个分辨率写出模型：\n$$ \\phi_c \\approx \\phi_\\infty + C h_c^p $$\n$$ \\phi_m \\approx \\phi_\\infty + C h_m^p $$\n$$ \\phi_f \\approx \\phi_\\infty + C h_f^p $$\n\n我们通过取连续差值来消除 $\\phi_\\infty$：\n$$ \\phi_c - \\phi_m \\approx C(h_c^p - h_m^p) $$\n$$ \\phi_m - \\phi_f \\approx C(h_m^p - h_f^p) $$\n\n取这两个差值的比率可以消除常数 $C$：\n$$ \\frac{\\phi_c - \\phi_m}{\\phi_m - \\phi_f} \\approx \\frac{h_c^p - h_m^p}{h_m^p - h_f^p} $$\n代入 $h_c = r h_m$ 和 $h_f = h_m/r$：\n$$ \\frac{\\phi_c - \\phi_m}{\\phi_m - \\phi_f} \\approx \\frac{(r h_m)^p - h_m^p}{h_m^p - (h_m/r)^p} = \\frac{h_m^p(r^p - 1)}{h_m^p(1 - r^{-p})} = \\frac{r^p - 1}{1 - r^{-p}} = \\frac{r^p(r^p - 1)}{r^p - 1} = r^p $$\n这就得出了一个计算收敛阶 $p$ 的直接方程：\n$$ p \\approx \\frac{\\ln\\left(\\frac{\\phi_c - \\phi_m}{\\phi_m - \\phi_f}\\right)}{\\ln(r)} $$\n\n问题要求使用所有可用的分辨率三元组。对于具有 $k  3$ 个级别的模拟，我们将为每个连续的三元组计算一个 $p$ 的估计值，然后计算这些估计值的算术平均值，以获得 $p_\\phi$ 的最终汇总值。\n\n**3. 实现摘要**\n\n对于三个测试案例中的每一个，我们将：\n1.  为每个分辨率级别 $N_i$ 计算网格间距 $h_i = L/N_i$。\n2.  对于哈密顿约束违反 $p_H$ 和质量不守恒 $p_M$，计算误差和网格间距的自然对数。然后，使用线性回归（具体来说是次数为 1 的 `numpy.polyfit`）来找到 $\\ln(E)$ 相对于 $\\ln(h)$ 的斜率，该斜率即为 $p$。\n3.  对于引力波相位 $p_\\phi$，识别所有连续的分辨率三元组。对于每个三元组，使用推导出的比率公式计算 $p$。最终的 $p_\\phi$ 将是这些单个估计值的平均值。在给定的测试案例中，加密比率 $r$ 始终为 $2$。\n4.  将最终计算出的阶数 $p_H$、$p_\\phi$ 和 $p_M$ 四舍五入到三位小数。\n\n最终输出将是一个列表，其中包含每个案例的一个子列表，每个子列表按指定顺序包含三个估计的阶数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the convergence analysis on the provided test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"L\": 1.0e5,\n            \"N\": np.array([64, 128, 256]),\n            \"r\": 2.0,\n            \"EH\": np.array([2.80e-3, 6.70e-4, 1.60e-4]),\n            \"phi\": np.array([12.345 + 0.038147, 12.345 + 0.004768, 12.345 + 0.000596]),\n            \"EM\": np.array([3.08708e-4, 1.09265e-4, 3.86810e-5]),\n        },\n        {\n            \"name\": \"Case B\",\n            \"L\": 1.0e5,\n            \"N\": np.array([48, 96, 192, 384]),\n            \"r\": 2.0,\n            \"EH\": np.array([1.2000e-2, 3.2145e-3, 8.6130e-4, 2.3080e-4]),\n            \"phi\": np.array([9.876 + 0.05173, 9.876 + 0.00796, 9.876 + 0.001225, 9.876 + 0.0001885]),\n            \"EM\": np.array([2.0000e-4, 5.0000e-5, 1.2500e-5, 3.1250e-6]),\n        },\n        {\n            \"name\": \"Case C\",\n            \"L\": 1.0e5,\n            \"N\": np.array([72, 144, 288]),\n            \"r\": 2.0,\n            \"EH\": np.array([4.2000e-3, 1.4860e-3, 5.2570e-4]),\n            \"phi\": np.array([15.555 + 0.03000, 15.555 + 0.005303, 15.555 + 0.0009375]),\n            \"EM\": np.array([1.8000e-4, 9.0000e-5, 4.5000e-5]),\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        h = case[\"L\"] / case[\"N\"]\n        \n        # --- Estimate order for error-like quantities (EH, EM) ---\n        # The model is E = A*h^p, so log(E) = log(A) + p*log(h).\n        # We find p as the slope of the linear fit of log(E) vs log(h).\n        log_h = np.log(h)\n        \n        log_EH = np.log(case[\"EH\"])\n        p_H = np.polyfit(log_h, log_EH, 1)[0]\n        \n        log_EM = np.log(case[\"EM\"])\n        p_M = np.polyfit(log_h, log_EM, 1)[0]\n        \n        # --- Estimate order for phase-like quantities (phi) ---\n        # The model is phi = phi_inf + C*h^p.\n        # The ratio of differences (phi_c-phi_m)/(phi_m-phi_f) = r^p.\n        # So, p = log(ratio) / log(r).\n        phis = case[\"phi\"]\n        r = case[\"r\"]\n        num_levels = len(case[\"N\"])\n        p_phi_estimates = []\n        \n        for i in range(num_levels - 2):\n            phi_c, phi_m, phi_f = phis[i], phis[i+1], phis[i+2]\n            \n            # Numerator and denominator of the ratio\n            num = phi_c - phi_m\n            den = phi_m - phi_f\n            \n            # Avoid division by zero or log of non-positive if data is noisy\n            if den != 0 and (num / den) > 0:\n                ratio = num / den\n                p_est = np.log(ratio) / np.log(r)\n                p_phi_estimates.append(p_est)\n                \n        # Aggregate estimates by averaging\n        p_phi = np.mean(p_phi_estimates) if p_phi_estimates else np.nan\n\n        # Round results to three decimal places\n        case_results = [round(p_H, 3), round(p_phi, 3), round(p_M, 3)]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified\n    def format_sublist(res_list):\n        return f\"[{','.join(f'{x:.3f}' for x in res_list)}]\"\n\n    output_str = f\"[{','.join([format_sublist(r) for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3533416"}]}