{"hands_on_practices": [{"introduction": "理论知识必须通过实践来巩固。通量限制扩散（FLD）的一个关键应用是在宇宙学中，用于模拟膨胀宇宙中的辐射输运。本练习将引导您在共动坐标系中正确地推导和求解辐射能量方程，其中必须考虑宇宙膨胀引起的绝热冷却效应以及扩散算符的相应标度变换。通过完成这项实践[@problem_id:3511262]，您将掌握在动态天体物理背景下应用辐射输运模型的基本技能。", "problem": "考虑在一个经历哈勃式流的膨胀、均匀、各向同性介质中的辐射通量限制扩散 (Flux-Limited Diffusion, FLD)，其物理速度场由 $v_{\\mathrm{phys}}(\\mathbf{r},t)=H(t)\\,\\mathbf{r}$ 给出，其中 $H(t)$ 是哈勃参数，$\\mathbf{r}$ 是物理位置矢量。设 $a(t)$ 为宇宙学尺度因子，满足 $\\dot{a}(t)=H(t)\\,a(t)$，初始条件为 $a(0)=a_{0}$。我们在共动坐标 $x$ 的一维空间周期性域中进行计算，使得物理坐标为 $r(t)=a(t)\\,x$。单位物理体积的辐射能量密度用 $E(x,t)$ 表示，辐射压强为 $P_{\\mathrm{rad}}(x,t)=E(x,t)/3$。FLD 通量定义为 $F_{\\mathrm{phys}}(x,t)=-D(x,t)\\,\\nabla_{\\mathrm{phys}}E(x,t)$，其中 $\\nabla_{\\mathrm{phys}}$ 是物理空间梯度，扩散系数为 $D(x,t)=\\dfrac{c\\,\\lambda(R)}{\\kappa_{R}}$，其中 $c$ 是光速，$\\kappa_{R}$ 是 Rosseland 平均不透明度，$\\lambda(R)$ 是一个通量限制器，依赖于无量纲量 $R=\\dfrac{\\lvert\\nabla_{\\mathrm{phys}}E\\rvert}{\\kappa_{R}\\,E}$。使用 Levermore–Pomraning 通量限制器 $\\lambda(R)=\\dfrac{1}{R}\\left(\\coth R-\\dfrac{1}{R}\\right)$，其极限行为为 $\\lambda(0)=\\dfrac{1}{3}$。\n\n从混合参考系中的辐射能量方程出发，并利用物理导数和共动导数之间的变换关系，推导包含膨胀效应的共动参考系 FLD 方程的形式。特别地，推导当扩散算子用共动坐标表示时的修正形式以及由膨胀驱动的绝热项。然后，设计一个稳定、显式的有限差分算法，用于在一维周期性共动网格上对推导出的方程进行积分。该算法必须确保在没有扩散时，辐射的绝热红移定律 $E\\propto a^{-4}$ 得以保持，并且必须正确地包含扩散算子的共动标度。\n\n您的程序必须实现以下模型假设和数值细节：\n- 共动梯度满足 $\\nabla_{\\mathrm{phys}}=\\dfrac{1}{a(t)}\\,\\nabla_{\\mathrm{com}}$，扩散算子的共动散度也相应地进行标度变换。\n- 共动参考系中的辐射能量演化方程包含一个与 $H(t)$ 成正比的绝热功项和一个具有适当 $a(t)$ 标度因子的共动扩散算子。\n- 网格单元面上的数值通量应使用一个可变扩散系数来计算，该系数基于由共动梯度求得的局部通量限制器。\n- 在共动坐标中使用周期性边界条件。\n- 使用算子分裂时间积分器，分别推进绝热项和扩散项。\n- 对扩散部分使用前向时间、中心空间 (Forward-Time, Centered-Space) 离散化，并选择考虑稳定性的时间步长。\n\n在适用情况下，使用厘米-克-秒 (cgs) 单位制。然而，所要求的输出是如下指定的无量纲浮点数。\n\n测试套件：\n在一个长度为 $L=\\;10^{5}\\,$cm、离散为 $N=\\;128$ 个单元的一维周期性共动域上实现以下三个测试案例。使用 $a_{0}=\\;1$ 和 $c=\\;3.0\\times 10^{10}\\,$cm/s。对于所有案例，均匀初始化共动坐标网格，并使用常数 $H(t)=H_{0}$。\n\n1. 案例 A（均匀场，存在扩散但无梯度）：\n   - 参数：$\\kappa_{R}=\\;10.0\\,$cm$^{-1}$，$H_{0}=\\;0.01\\,$s$^{-1}$，最终时间 $t_{\\mathrm{end}}=\\;0.1\\,$s。\n   - 初始条件：$E(x,0)=E_{0}$，其中 $E_{0}=\\;1.0\\,$erg/cm$^{3}$ 为均匀值。\n   - 要求结果：一个浮点数，等于数值空间平均值 $\\langle E(x,t_{\\mathrm{end}})\\rangle$ 与精确绝热值 $E_{0}\\,\\exp(-4\\,H_{0}\\,t_{\\mathrm{end}})$ 之间的相对误差，计算公式为 $\\left\\lvert \\dfrac{\\langle E\\rangle_{\\mathrm{num}}-E_{0}\\,e^{-4H_{0}t_{\\mathrm{end}}}}{E_{0}\\,e^{-4H_{0}t_{\\mathrm{end}}}}\\right\\rvert$。\n\n2. 案例 B（正弦场，光学厚，因此扩散可忽略）：\n   - 参数：$\\kappa_{R}=\\;100.0\\,$cm$^{-1}$，$H_{0}=\\;0.02\\,$s$^{-1}$，最终时间 $t_{\\mathrm{end}}=\\;0.1\\,$s。\n   - 初始条件：$E(x,0)=E_{0}\\left[1+0.1\\,\\sin\\left(\\dfrac{2\\pi x}{L}\\right)\\right]$，其中 $E_{0}=\\;1.0\\,$erg/cm$^{3}$。\n   - 要求结果：一个浮点数，等于数值解 $E(x,t_{\\mathrm{end}})$ 与仅考虑绝热的精确解 $E(x,0)\\,\\exp(-4\\,H_{0}\\,t_{\\mathrm{end}})$ 在整个网格上的平均绝对相对误差，计算方法为对所有网格点求 $\\left\\lvert \\dfrac{E_{\\mathrm{num}}(x_{i},t_{\\mathrm{end}})-E(x_{i},0)\\,e^{-4H_{0}t_{\\mathrm{end}}}}{E(x_{i},0)\\,e^{-4H_{0}t_{\\mathrm{end}}}}\\right\\rvert$ 的平均值。\n\n3. 案例 C（正弦场，有限扩散和膨胀；共动不变量守恒）：\n   - 参数：$\\kappa_{R}=\\;1.0\\,$cm$^{-1}$，$H_{0}=\\;0.01\\,$s$^{-1}$，最终时间 $t_{\\mathrm{end}}=\\;0.2\\,$s。\n   - 初始条件：$E(x,0)=E_{0}\\left[1+0.2\\,\\sin\\left(\\dfrac{4\\pi x}{L}\\right)\\right]$，其中 $E_{0}=\\;1.0\\,$erg/cm$^{3}$。\n   - 要求结果：一个浮点数，等于共动不变量 $a(t)^{4}E(x,t)$ 的空间平均值在初始和最终时刻之间的相对偏差，计算公式为 $\\left\\lvert \\dfrac{\\langle a(t_{\\mathrm{end}})^{4}E(x,t_{\\mathrm{end}})\\rangle-\\langle a(0)^{4}E(x,0)\\rangle}{\\langle a(0)^{4}E(x,0)\\rangle}\\right\\rvert$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个案例的结果，形式为方括号括起来的逗号分隔列表（例如，$\\left[\\mathrm{resultA},\\mathrm{resultB},\\mathrm{resultC}\\right]$）。每个条目必须是如上定义的浮点数，不带单位。", "solution": "该问题陈述清晰，具有科学依据，并为获得唯一解提供了足够的信息。这是一个计算天体物理学中的标准问题，我将继续进行推导和实现。\n\n### 第 1 部分：共动参考系通量限制扩散方程的推导\n\n我们从混合参考系中的辐射能量守恒方程开始，在该参考系中，流体变量在流体的共动参考系中测量，但导数在实验室（欧拉）参考系中计算。对于以物理速度 $\\mathbf{v}_{\\mathrm{phys}}$ 运动的流体，该方程为：\n$$\n\\frac{\\partial E}{\\partial t} + \\nabla_{\\mathrm{phys}} \\cdot (E \\mathbf{v}_{\\mathrm{phys}}) + \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = -P_{\\mathrm{rad}} : \\nabla_{\\mathrm{phys}} \\mathbf{v}_{\\mathrm{phys}}\n$$\n其中 $E$ 是辐射能量密度，$\\mathbf{F}_{\\mathrm{phys}}$ 是辐射通量，而 $P_{\\mathrm{rad}}$ 是辐射压强张量。对于各向同性辐射场，压强是一个标量 $P_{\\mathrm{rad}} = E/3$，压强张量为 $P_{ij} = P_{\\mathrm{rad}} \\delta_{ij}$。右侧的功项简化为 $-P_{\\mathrm{rad}} (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}})$。\n\n展开平流项 $\\nabla_{\\mathrm{phys}} \\cdot (E \\mathbf{v}_{\\mathrm{phys}}) = \\mathbf{v}_{\\mathrm{phys}} \\cdot \\nabla_{\\mathrm{phys}} E + E (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}})$，方程变为：\n$$\n\\frac{\\partial E}{\\partial t} + \\mathbf{v}_{\\mathrm{phys}} \\cdot \\nabla_{\\mathrm{phys}} E + E (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}}) + \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = -P_{\\mathrm{rad}} (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}})\n$$\n识别拉格朗日时间导数 $\\frac{DE}{Dt} = \\frac{\\partial E}{\\partial t} + \\mathbf{v}_{\\mathrm{phys}} \\cdot \\nabla_{\\mathrm{phys}} E$，我们可以将方程重新整理为：\n$$\n\\frac{DE}{Dt} = -(E + P_{\\mathrm{rad}})(\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}}) - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}}\n$$\n问题指定了一个均匀、各向同性的哈勃式流，$\\mathbf{v}_{\\mathrm{phys}} = H(t) \\mathbf{r}$，其中 $\\mathbf{r}$ 是物理位置矢量。该速度场的散度为 $\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}} = 3H(t)$，表示背景三维空间的体积膨胀率。使用相对论状态方程 $P_{\\mathrm{rad}} = E/3$，我们有 $E + P_{\\mathrm{rad}} = 4E/3$。方程变为：\n$$\n\\frac{DE}{Dt} = -\\frac{4}{3}E (3H(t)) - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = -4H(t)E - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}}\n$$\n该方程描述了随宇宙膨胀运动的流体元的能量密度变化。\n\n接下来，我们变换到共动坐标。物理坐标 $\\mathbf{r}$ 通过尺度因子 $a(t)$ 与共动坐标 $\\mathbf{x}$ 相关联：$\\mathbf{r} = a(t) \\mathbf{x}$。具有固定共动坐标的点的速度为 $\\dot{\\mathbf{r}} = \\dot{a}(t) \\mathbf{x} = \\frac{\\dot{a}}{a} (a \\mathbf{x}) = H(t) \\mathbf{r} = \\mathbf{v}_{\\mathrm{phys}}$。这意味着跟随流体的拉格朗日导数与固定共动坐标处的偏时间导数相同：$\\frac{D}{Dt} = \\left. \\frac{\\partial}{\\partial t} \\right|_{\\mathbf{x}}$。\n\n用共动参考系时间导数表示的方程为：\n$$\n\\left. \\frac{\\partial E}{\\partial t} \\right|_{\\mathbf{x}} = -4H(t)E - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}}\n$$\n右边的第一项 $-4H(t)E$ 是**绝热冷却项**（或红移项），由宇宙膨胀时辐射压强做功产生。在没有源或汇的情况下，该项正确地导致 $E \\propto a^{-4}$ 的标度关系，因为 $\\frac{dE}{E} = -4H dt = -4 \\frac{da}{a}$，积分后得到 $E a^4 = \\mathrm{constant}$。\n\n现在，我们变换扩散项。物理通量由 FLD 近似给出：$\\mathbf{F}_{\\mathrm{phys}} = -D \\nabla_{\\mathrm{phys}} E$。物理梯度 $\\nabla_{\\mathrm{phys}}$ 与共动梯度 $\\nabla_{\\mathrm{com}}$ 的关系为 $\\nabla_{\\mathrm{phys}} = \\frac{1}{a(t)}\\nabla_{\\mathrm{com}}$。通量的散度变为：\n$$\n\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = \\nabla_{\\mathrm{phys}} \\cdot \\left(-D \\nabla_{\\mathrm{phys}} E\\right) = \\frac{1}{a(t)} \\nabla_{\\mathrm{com}} \\cdot \\left(-D \\frac{1}{a(t)} \\nabla_{\\mathrm{com}} E\\right) = -\\frac{1}{a(t)^2} \\nabla_{\\mathrm{com}} \\cdot \\left(D \\nabla_{\\mathrm{com}} E\\right)\n$$\n将此代入能量方程，我们得到最终的一维共动坐标系 FLD 方程：\n$$\n\\frac{\\partial E}{\\partial t} = -4H(t)E + \\frac{1}{a(t)^2} \\frac{\\partial}{\\partial x} \\left( D \\frac{\\partial E}{\\partial x} \\right)\n$$\n这就是所求的方程。扩散系数 $D = \\frac{c \\lambda(R)}{\\kappa_R}$ 依赖于无量纲量 $R = \\frac{|\\nabla_{\\mathrm{phys}} E|}{\\kappa_R E} = \\frac{1}{a(t) \\kappa_R E} \\left|\\frac{\\partial E}{\\partial x}\\right|$。\n\n### 第 2 部分：数值算法设计\n\n我们将使用算子分裂法实现一个稳定的、显式的有限差分格式来求解推导出的偏微分方程。\n\n**1. 算子分裂**\n演化方程 $\\frac{\\partial E}{\\partial t} = \\mathcal{L}_{\\mathrm{ad}}E + \\mathcal{L}_{\\mathrm{diff}}E$ 在每个时间增量 $\\Delta t$ 内被分成两个子步骤。\n1.  **绝热步骤：** 求解 $\\frac{\\partial E}{\\partial t} = -4H(t)E$。对于常数哈勃参数 $H(t)=H_0$，这有精确解：\n    $$ E^* = E^n e^{-4H_0 \\Delta t} $$\n    其中 $E^n$ 是时间步开始时的能量密度。\n\n2.  **扩散步骤：** 使用前向时间、中心空间 (FTCS) 格式求解 $\\frac{\\partial E}{\\partial t} = \\frac{1}{a(t)^2} \\frac{\\partial}{\\partial x} \\left( D \\frac{\\partial E}{\\partial x} \\right)$，以 $E^*$ 为初始条件。\n    $$ \\frac{E_i^{n+1} - E_i^*}{\\Delta t} = \\frac{1}{a(t^n)^2} \\left[ \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} \\right] $$\n    其中 $\\Delta x$ 是共动网格间距，而 $F_{i+1/2}$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。\n\n**2. 空间离散化与通量计算**\n网格由 $N$ 个大小为 $\\Delta x = L/N$ 的单元组成。单元面 $x_{i+1/2}$ 上的数值通量为：\n$$\nF_{i+1/2} = -D_{i+1/2} \\left( \\frac{E_{i+1}^* - E_i^*}{\\Delta x} \\right)\n$$\n扩散系数 $D_{i+1/2}$ 在单元面上计算。这需要在面上计算限制器 $\\lambda(R)$，而它又依赖于面中心的梯度和能量密度。\n$$\nE_{i+1/2}^* = \\frac{E_{i+1}^* + E_i^*}{2}\n$$\n$$\nR_{i+1/2} = \\frac{1}{a(t^n) \\kappa_R E_{i+1/2}^*} \\left| \\frac{E_{i+1}^* - E_i^*}{\\Delta x} \\right|\n$$\nLevermore–Pomraning 通量限制器为 $\\lambda(R) = \\frac{1}{R}(\\coth R - \\frac{1}{R})$。为避免小 $R$ 值的数值抵消，我们对 $R  10^{-4}$ 使用其泰勒展开 $\\lambda(R) \\approx 1/3 - R^2/45$。\n最后，面中心的扩散系数为 $D_{i+1/2} = \\frac{c \\lambda(R_{i+1/2})}{\\kappa_R}$。\n单元 $i$ 的扩散更新为：\n$$\nE_i^{n+1} = E_i^* + \\frac{\\Delta t}{a(t^n)^2 (\\Delta x)^2} \\left[ D_{i+1/2}(E_{i+1}^* - E_i^*) - D_{i-1/2}(E_i^* - E_{i-1}^*) \\right]\n$$\n周期性边界条件通过确保索引环绕来处理，例如，$E_N = E_0$ 和 $E_{-1} = E_{N-1}$。\n\n**3. 时间步稳定性**\n对于扩散方程，只要时间步长 $\\Delta t$ 满足 CFL 条件，显式 FTCS 格式就是稳定的。我们方程中的有效扩散率为 $D_{\\text{eff}} = D/a^2$。稳定性条件是：\n$$\n\\Delta t \\le \\frac{(\\Delta x)^2}{2 \\max(D_{\\text{eff}})} = \\frac{a(t)^2 (\\Delta x)^2}{2 \\max(D)}\n$$\n扩散系数的最大值出现在 $R \\to 0$ 时，此时 $\\lambda(0) = 1/3$，因此 $D_{\\max} = \\frac{c}{3\\kappa_R}$。稳定的时间步长为：\n$$\n\\Delta t_{\\mathrm{diff}} = \\eta \\frac{3 \\kappa_R a(t)^2 (\\Delta x)^2}{2c}\n$$\n其中 $\\eta \\le 1$ 是一个安全因子（我们使用 $\\eta=0.5$）。总时间步长也受限于膨胀时间尺度 $1/H_0$ 的一小部分，且不能超过最终时间 $t_{\\mathrm{end}}$。\n\n**4. 守恒性**\n空间积分量 $\\int_0^L a(t)^4 E(x,t) \\, dx$ 是守恒的。对时间求导得到 $\\int_0^L a^2 \\frac{\\partial}{\\partial x} (D \\frac{\\partial E}{\\partial x}) \\, dx$。由于周期性边界条件，该积分为零，证实了守恒性。我们的有限差分格式作为通量散度的直接离散化，将在机器精度内数值上保持该量守恒。这在案例 C 中进行了测试。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the flux-limited diffusion problem in an expanding medium\n    for three test cases and prints the results.\n    \"\"\"\n\n    def lambda_lp(R, R_thresh=1e-4):\n        \"\"\"\n        Computes the Levermore-Pomraning flux limiter.\n        Uses a Taylor expansion for small R to avoid numerical instability.\n        \"\"\"\n        # Ensure R is a numpy array\n        R = np.asanyarray(R)\n        \n        # Initialize result array\n        lambda_val = np.zeros_like(R, dtype=float)\n        \n        # Condition for small R\n        small_R_mask = R  R_thresh\n        \n        # Taylor expansion for small R\n        R_small = R[small_R_mask]\n        lambda_val[small_R_mask] = 1.0 / 3.0 - R_small**2 / 45.0\n        \n        # Full expression for large R\n        R_large = R[~small_R_mask]\n        # Use 1/tanh(R) to avoid overflow issues of coth at R=0\n        # which is already guarded by the mask.\n        lambda_val[~small_R_mask] = (1.0 / np.tanh(R_large) - 1.0 / R_large) / R_large\n        \n        return lambda_val\n\n    def run_simulation(params):\n        \"\"\"\n        Runs a single 1D FLD simulation.\n        \n        Args:\n            params (dict): A dictionary containing all model and simulation parameters.\n            \n        Returns:\n            tuple: Final energy density array E, initial energy E0, scale factor a(t_end).\n        \"\"\"\n        # Unpack parameters\n        L = params['L']\n        N = params['N']\n        k_R = params['k_R']\n        H0 = params['H0']\n        t_end = params['t_end']\n        E_initial_func = params['E_initial_func']\n        a0 = params['a0']\n        c = params['c']\n        \n        # Grid setup\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        # Initial conditions\n        E = E_initial_func(x, L) \n        E_initial = E.copy()\n        \n        t = 0.0\n        a = a0\n        \n        # CFL safety factor\n        cfl_safety_factor = 0.5\n        \n        while t  t_end:\n            # Update scale factor for the start of the step\n            a = a0 * np.exp(H0 * t)\n            \n            # Time step calculation\n            # Diffusion timestep constraint\n            dt_diff = cfl_safety_factor * (3.0 * k_R * a**2 * dx**2) / (2.0 * c)\n            # Expansion timestep constraint\n            dt_exp = 0.01 / H0 if H0  0 else t_end\n            \n            dt = min(dt_diff, dt_exp)\n            if t + dt  t_end:\n                dt = t_end - t\n            \n            # --- Operator Splitting ---\n\n            # 1. Adiabatic step (analytically solved)\n            if H0  0:\n                E_star = E * np.exp(-4.0 * H0 * dt)\n            else:\n                E_star = E.copy()\n\n            # 2. Diffusion step (FTCS)\n            # Calculate face-centered diffusion coefficients\n            E_plus = np.roll(E_star, -1)\n            E_minus = np.roll(E_star, 1)\n\n            # Face-centered energy and gradient\n            E_face = 0.5 * (E_star + E_plus)\n            # Add a small number to prevent division by zero for uniform fields\n            E_face[E_face == 0] = 1e-99\n            \n            grad_com_E_face = (E_plus - E_star) / dx\n\n            # Dimensionless parameter R at faces\n            R_face = np.abs(grad_com_E_face) / (a * k_R * E_face)\n            \n            # Limiter and diffusion coefficient at forward faces (i+1/2)\n            lambda_face_fwd = lambda_lp(R_face)\n            D_face_fwd = c * lambda_face_fwd / k_R\n            \n            # Diffusion coefficient at backward faces (i-1/2) by rolling\n            D_face_bwd = np.roll(D_face_fwd, 1)\n\n            # Fluxes at forward and backward faces\n            F_fwd = -D_face_fwd * (E_plus - E_star) / dx\n            F_bwd = -D_face_bwd * (E_star - E_minus) / dx\n            \n            # Update energy density using flux divergence\n            E = E_star - (dt / (a**2 * dx)) * (F_fwd - F_bwd)\n            \n            # Advance time\n            t += dt\n\n        a_final = a0 * np.exp(H0 * t_end)\n        return E, E_initial, a_final\n\n    # --- Global and Test Case Parameters ---\n    L_domain = 1.0e5   # cm\n    N_cells = 128\n    a0_val = 1.0\n    c_light = 3.0e10   # cm/s\n    E0_val = 1.0       # erg/cm^3\n\n    test_cases = [\n        { # Case A\n            'k_R': 10.0, 'H0': 0.01, 't_end': 0.1,\n            'E_initial_func': lambda x, L: np.full_like(x, E0_val)\n        },\n        { # Case B\n            'k_R': 100.0, 'H0': 0.02, 't_end': 0.1,\n            'E_initial_func': lambda x, L: E0_val * (1.0 + 0.1 * np.sin(2.0 * np.pi * x / L))\n        },\n        { # Case C\n            'k_R': 1.0, 'H0': 0.01, 't_end': 0.2,\n            'E_initial_func': lambda x, L: E0_val * (1.0 + 0.2 * np.sin(4.0 * np.pi * x / L))\n        }\n    ]\n    \n    results = []\n    \n    # --- Run simulations and compute results ---\n    \n    # Case A\n    params_A = {**test_cases[0], 'L': L_domain, 'N': N_cells, 'a0': a0_val, 'c': c_light}\n    E_final_A, _, _ = run_simulation(params_A)\n    E_avg_num = np.mean(E_final_A)\n    E_exact_A = E0_val * np.exp(-4.0 * params_A['H0'] * params_A['t_end'])\n    rel_error_A = np.abs((E_avg_num - E_exact_A) / E_exact_A)\n    results.append(rel_error_A)\n    \n    # Case B\n    params_B = {**test_cases[1], 'L': L_domain, 'N': N_cells, 'a0': a0_val, 'c': c_light}\n    E_final_B, E_initial_B, _ = run_simulation(params_B)\n    E_exact_B = E_initial_B * np.exp(-4.0 * params_B['H0'] * params_B['t_end'])\n    mean_abs_rel_error_B = np.mean(np.abs((E_final_B - E_exact_B) / E_exact_B))\n    results.append(mean_abs_rel_error_B)\n    \n    # Case C\n    params_C = {**test_cases[2], 'L': L_domain, 'N': N_cells, 'a0': a0_val, 'c': c_light}\n    E_final_C, E_initial_C, a_final_C = run_simulation(params_C)\n    invariant_initial = np.mean(a0_val**4 * E_initial_C)\n    invariant_final = np.mean(a_final_C**4 * E_final_C)\n    rel_dev_C = np.abs((invariant_final - invariant_initial) / invariant_initial)\n    results.append(rel_dev_C)\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3511262"}, {"introduction": "一个数值方法的鲁棒性和物理真实性至关重要。在具有挑战性的情况下，例如当时间步长较大或存在剧烈梯度时，简单的显式格式可能会产生非物理的负能量密度，从而导致模拟失败。本练习[@problem_id:3511282]将教您一种强大的技术，即通过设计一种能够保证解的正定性的通量限制机制来避免此类问题。这是开发可靠的模拟程序所必备的一项核心技能。", "problem": "您需要推导并实现一个一维显式通量限制扩散 (Flux-Limited Diffusion, FLD) 求解器，用于求解灰体辐射能量密度 $E$。该求解器通过使用局部波速和局部单元含量界限来限制面通量，从而保证保持非负性。所有量均为无量纲。\n\n出发点与定义：\n- 在扩散近似下，灰体辐射能量方程为\n$$\n\\frac{\\partial E}{\\partial t} + \\nabla \\cdot \\mathbf{F} = 0,\n$$\n扩散通量为\n$$\n\\mathbf{F} = - D \\nabla E,\n$$\n其中 $D$ 是扩散系数。在通量限制扩散闭合关系中，\n$$\nD = \\frac{c \\, \\lambda(R)}{\\chi},\n$$\n其中 $c$ 是（无量纲）光速，$\\chi$ 是总输运不透明度，$\\lambda(R)$ 是一个通量限制器。类似于瑞利数的比值 $R$ 为\n$$\nR = \\frac{\\lvert \\nabla E \\rvert}{\\chi \\, E}.\n$$\n- 使用 Levermore-Pomraning 通量限制器\n$$\n\\lambda(R) = \\frac{1}{R}\\left(\\coth R - \\frac{1}{R}\\right),\n$$\n其极限情况为当 $R \\to 0$ 时 $\\lambda \\to 1/3$ 以及当 $R \\to \\infty$ 时 $\\lambda \\to 1/R$。\n- 总不透明度由下式给出\n$$\n\\chi = \\rho \\, \\kappa_R(\\rho, T),\n$$\n使用 Rosseland 平均不透明度模型\n$$\n\\kappa_R(\\rho, T) = \\kappa_0 \\, \\rho^{a} \\, T^{b},\n$$\n其中 $\\rho$ 是质量密度，$T$ 是温度，通过灰体平衡由辐射能量定义\n$$\nT = \\left(\\frac{E}{a_r}\\right)^{1/4},\n$$\n其中 $a_r$ 是辐射常数。您必须采用 $a_r = 1$ 和 $c = 1$ 以保持在无量纲单位体系中。\n- 使用包含 $N$ 个有限体积单元的均匀网格，单元宽度为 $\\Delta x = L/N$，并采用零通量（Neumann）边界条件。\n\n半离散有限体积更新：\n- 对于单元索引 $i$，显式更新公式为\n$$\nE_i^{n+1} = E_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n其中 $F_{i+\\frac{1}{2}}$ 是在面 $i+\\tfrac{1}{2}$ 处与 $F = -D \\nabla E$ 一致的数值通量。\n\n保正限制器目标：\n- 从第一性原理出发，设计一个基于面的限制器，保证对所有 $i$ 和 $n$ 都有 $E_i^{n+1} \\ge 0$，而无需 $\\Delta t$ 满足严格的抛物型稳定性界限。您的限制器必须：\n  1. 强制施加一个离散的能量含量界限，防止单个面从其相邻单元中移走的辐射能量在一个时间步内导致该单元变为负值。\n  2. 使用由扩散系数和网格尺度构建的特征局部波速，并以自由流极限为上限，强制施加一个具有物理动机的速度界限。\n- 您的限制器必须被构造成在每个面 $i+\\tfrac{1}{2}$ 处，受限通量的量级不超过以下两者：\n  - 一个与相邻单元能量和 $\\Delta x/\\Delta t$ 成正比的能量含量界限，以及\n  - 一个与特征速度和相邻单元能量尺度成正比的速度界限。\n- 清楚地说明您使用的特征速度，以及它是如何从基本扩散模型及其自由流极限推导出来的。\n\n算法要求：\n- 实现一个具有以下特点的一维显式更新：\n  - 单元中心的 $E_i$。\n  - 面中心的 $D_{i+\\frac{1}{2}}$，由通量限制器 $\\lambda(R)$ 和面插值的不透明度 $\\chi_{i+\\frac{1}{2}}$ 计算得出。\n  - 使用中心差分计算的面中心梯度。\n  - 使用面中心梯度和面中心能量尺度计算的 $R$。\n  - 零通量边界，即 $F_{-\\frac{1}{2}} = 0$ 和 $F_{N-\\frac{1}{2}} = 0$。\n- 在同一程序中实现两个求解器：\n  - 一个不带保正限制器（但带有通量限制器 $\\lambda$）的基准 FLD 显式求解器。\n  - 您推导的保正限制求解器。\n- 温度必须根据 $T = (E/a_r)^{1/4}$ 计算，其中 $a_r = 1$。为了在基准求解器中数值地检测非物理温度，如果任何单元的 $E  0$，则将最低温度报告为带符号的四次方根 $T_{\\min} = -(\\lvert E_{\\min}\\rvert)^{1/4}$，以便负值表示违规。在数值通量计算中，所有其他对 $T$ 的使用都应通过将 $E$ 替换为 $\\max(E, \\varepsilon)$（使用一个极小的 $\\varepsilon$）来正则化计算，以避免除以零，同时不掩盖所报告的最低温度的符号。\n\n测试套件：\n- 使用三个指定的测试。在所有测试中，使用 $L = 1$，$a_r = 1$，$c = 1$，$N = 256$。令 $\\Delta x = L/N$。时间步长 $\\Delta t$ 必须选择为\n$$\n\\Delta t = \\beta \\, \\frac{\\Delta x^2}{2 \\, \\max D^{(0)}},\n$$\n其中 $\\max D^{(0)}$ 是从初始场计算出的最大初始面中心扩散系数，$\\beta$ 是为每个测试指定的因子，用以故意违反标准抛物型稳定性极限。对于每个测试，积分固定的步数 $N_{\\text{steps}}$。\n\n- 测试 1（中度非均匀不透明度）：\n  - $\\kappa_0 = 1$，$a = 1$，$b = -3.5$。\n  - $\\rho(x) = 1 + 0.5 \\sin(4 \\pi x)$。\n  - $E(x,0) = 1 + \\exp\\left(-\\frac{(x-0.5)^2}{0.05^2}\\right)$。\n  - $\\beta = 2$，$N_{\\text{steps}} = 50$。\n\n- 测试 2（具有尖峰的高度非均匀不透明度）：\n  - $\\kappa_0 = 5$，$a = 1$，$b = -3.5$。\n  - $\\rho(x) = 0.1 + 10 \\exp\\left(-\\frac{(x-0.25)^2}{0.02^2}\\right) + 30 \\exp\\left(-\\frac{(x-0.75)^2}{0.01^2}\\right)$。\n  - $E(x,0) = 0.5 + 2 \\exp\\left(-\\frac{(x-0.5)^2}{0.03^2}\\right)$。\n  - $\\beta = 5$，$N_{\\text{steps}} = 30$。\n\n- 测试 3（近真空区以探测自由流极限）：\n  - $\\kappa_0 = 1$，$a = 1$，$b = -3.5$。\n  - $\\rho(x) = 1 + 0 \\times x$，对于所有 $x$ 成立，除了中心凹陷区域 $\\lvert x - 0.5 \\rvert  0.05$ 时 $\\rho(x) = 10^{-4}$。\n  - $E(x,0) = 1 + 0.8 \\tanh\\left(\\frac{0.5 - x}{0.02}\\right)$。\n  - $\\beta = 10$，$N_{\\text{steps}} = 20$。\n\n输出要求：\n- 对于每个测试，在完成所有时间步后，计算四个标量：\n  - $m_E^{\\text{lim}}$：保正限制求解器在所有单元上的 $E$ 的最小值。\n  - $m_E^{\\text{base}}$：基准求解器在所有单元上的 $E$ 的最小值。\n  - $m_T^{\\text{lim}}$：限制求解器在所有单元上的 $T$ 的最小值。\n  - $m_T^{\\text{base}}$：基准求解器在所有单元上的 $T$ 的最小值，当任何单元中 $E0$ 时，按上述带符号四次方根的方法计算。\n- 您的程序应生成一行输出，其中包含三个测试的 12 个结果，以逗号分隔列表的形式包含在方括号内，顺序如下\n$$\n\\big[m_E^{\\text{lim}}(1),\\, m_E^{\\text{base}}(1),\\, m_T^{\\text{lim}}(1),\\, m_T^{\\text{base}}(1),\\, m_E^{\\text{lim}}(2),\\, m_E^{\\text{base}}(2),\\, m_T^{\\text{lim}}(2),\\, m_T^{\\text{base}}(2),\\, m_E^{\\text{lim}}(3),\\, m_E^{\\text{base}}(3),\\, m_T^{\\text{lim}}(3),\\, m_T^{\\text{base}}(3)\\big].\n$$\n所有输出均为无量纲实数。\n\n您的任务是：\n- 从基本的 FLD 模型推导出一个保正通量上限，该上限由离散的能量含量界限和局部波速界限构成，能够恢复抛物型和自由流特征速度，并解释为什么它能在显式更新中保证 $E \\ge 0$。\n- 完全按照描述实现基准 FLD 求解器和您的保正限制求解器，并将它们应用于上述测试。\n- 确保零通量边界条件和指定的无量纲常数。", "solution": "该问题要求为一维灰体通量限制扩散 (FLD) 方程推导并实现一个保正显式数值格式。该格式必须通过基于局部能量含量和特征波速来限制面通量，以保证其正定性，即使在时间步违反标准抛物型稳定性条件时也是如此。\n\n辐射能量密度 $E$ 的控制方程由以下守恒律给出：\n$$\n\\frac{\\partial E}{\\partial t} + \\nabla \\cdot \\mathbf{F} = 0\n$$\n在通量限制扩散近似中，通量 $\\mathbf{F}$ 被建模为：\n$$\n\\mathbf{F} = -D \\nabla E\n$$\n其中扩散系数 $D$ 由下式给出：\n$$\nD = \\frac{c \\, \\lambda(R)}{\\chi}\n$$\n这里，$c$ 是光速，$\\chi$ 是不透明度，$\\lambda(R)$ 是 Levermore-Pomraning 通量限制器，它依赖于无量纲比值 $R = |\\nabla E| / (\\chi E)$。\n\n在单元宽度为 $\\Delta x$ 的均匀网格上，一个半离散有限体积格式给出了单元 $i$ 中单元平均能量 $E_i$ 的显式更新：\n$$\nE_i^{n+1} = E_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\n其中 $F_{i+\\frac{1}{2}}^n$ 是在时间步 $n$ 时，单元 $i$ 和 $i+1$ 之间交界面上的数值通量。为确保对于任何初始状态 $E_i^n \\ge 0$，更新后的能量 $E_i^{n+1}$ 保持非负，我们必须对通量进行约束。\n\n正定性条件为 $E_i^{n+1} \\ge 0$，这意味着：\n$$\nE_i^n \\ge \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\n项 $F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n$ 代表从单元 $i$ 的净流出量。如果 $E_i$ 是一个局部最大值（$E_{i-1}  E_i > E_{i+1}$），那么 $F_{i+\\frac{1}{2}}  0$ 且 $F_{i-\\frac{1}{2}}  0$，导致在两个面上都有流出。从单元 $i$ 的总流出量是 $\\max(0, F_{i+\\frac{1}{2}}) - \\min(0, F_{i-\\frac{1}{2}})$。为保证正定性，在 $\\Delta t$ 时间内从单元 $i$ 移走的总能量不能超过其初始能量 $E_i^n$。\n一种确保这一点的鲁棒、局部、基于面的方法是，将单元能量含量的一半分配给其两个面中的每一个。也就是说，从单元 $i$ 通过面 $i+\\frac{1}{2}$ 的流出量不应耗尽超过 $E_i^n/2$，对于面 $i-\\frac{1}{2}$ 也是如此。\n\n这个逻辑引出了对面通量量级的 **能量含量界限** 的推导。考虑单元 $i$ 和 $i+1$ 之间的通量 $F_{i+\\frac{1}{2}}$。流动方向是从较高的 $E$ 到较低的 $E$。让“迎风”单元为能量较高、通量发源的那个单元。为防止从面 $i+\\frac{1}{2}$ 的流出导致单元 $i$ 或 $i+1$ 变为负值，我们限制其量级。如果我们将迎风单元含量的一半分配给这个面，则允许的最大通量量级是：\n$$\n|F_{i+\\frac{1}{2}}| \\le \\frac{E_{\\text{upwind}}^n}{2} \\frac{\\Delta x}{\\Delta t}\n$$\n其中，如果 $E_i^n  E_{i+1}^n$，则 $E_{\\text{upwind}}^n = E_i^n$；如果 $E_{i+1}^n  E_i^n$，则 $E_{\\text{upwind}}^n = E_{i+1}^n$。我们来验证这一点。在单元 $i$ 的最坏情况（两个面都有流出）下，总流出量受限于：\n$$\n\\frac{\\Delta t}{\\Delta x} \\left( |F_{i+\\frac{1}{2}}| + |F_{i-\\frac{1}{2}}| \\right) \\le \\frac{\\Delta t}{\\Delta x} \\left( \\frac{E_i^n \\Delta x}{2 \\Delta t} + \\frac{E_i^n \\Delta x}{2 \\Delta t} \\right) = E_i^n\n$$\n因此，$E_i^{n+1} = E_i^n - (\\text{流出量}) + (\\text{流入量}) \\ge E_i^n - E_i^n + 0 = 0$。这保证了正定性。\n\n接下来，我们推导 **速度界限**。FLD 模型必须与辐射的物理速度极限 $c$ 一致。通量量级 $|F|$ 不能超过 $c E$。在自由流极限（$R \\to \\infty$）下，Levermore-Pomraning 限制器确保 $|F| \\to cE$。此外，在数值扩散格式中，信息以与扩散系数 $D$ 和网格尺度 $\\Delta x$ 相关的特征速度传播，即 $v_{\\text{diff}} \\sim D/\\Delta x$。一个有效的通量速度不能超过这两者中的任何一个。我们在面上定义一个特征局部波速：\n$$\nv_{\\text{char}, i+\\frac{1}{2}} = \\min\\left(\\frac{D_{i+\\frac{1}{2}}}{\\Delta x}, c\\right)\n$$\n然后，通量量级受此速度乘以迎风单元的能量密度的限制：\n$$\n|F_{i+\\frac{1}{2}}| \\le v_{\\text{char}, i+\\frac{1}{2}} E_{\\text{upwind}}^n\n$$\n\n最终的保正限制器按规定结合了这两个界限。受限通量的量级 $|F^{\\text{lim}}_{i+\\frac{1}{2}}|$，既不能超过原始不受限通量的量级 $|F^{\\text{unlim}}_{i+\\frac{1}{2}}|$，也不能超过这两个上限。\n设不受限通量为 $F^{\\text{unlim}}_{i+\\frac{1}{2}} = -D_{i+\\frac{1}{2}} \\frac{E_{i+1}^n - E_i^n}{\\Delta x}$。\n通量量级的上限是：\n$$\nF_{\\text{cap}, i+\\frac{1}{2}} = \\min \\left( \\frac{E_{\\text{upwind}}^n \\Delta x}{2 \\Delta t}, v_{\\text{char}, i+\\frac{1}{2}} E_{\\text{upwind}}^n \\right)\n$$\n其中 $E_{\\text{upwind}}^n = \\max(E_i^n, E_{i+1}^n)$。\n最终的受限通量通过限制不受限通量的量级来构造：\n$$\nF^{\\text{lim}}_{i+\\frac{1}{2}} = \\text{sign}\\left(F^{\\text{unlim}}_{i+\\frac{1}{2}}\\right) \\min\\left( \\left|F^{\\text{unlim}}_{i+\\frac{1}{2}}\\right|, F_{\\text{cap}, i+\\frac{1}{2}} \\right)\n$$\n此公式确保了通量是守恒的并尊重物理约束，从而保证 $E^{n+1} \\ge 0$。\n\n实现将按以下方式进行。对于每个测试案例，我们运行两个模拟：一个使用不受限通量 $F^{\\text{unlim}}$ 的基准求解器，和一个使用受限通量 $F^{\\text{lim}}$ 的限制求解器。\n所有面中心量均使用相邻单元中心值的算术平均值计算。具体来说，对于不透明度 $\\chi = \\rho \\kappa_R = \\kappa_0 \\rho^{a+1} T^b$，我们计算 $T_i = (\\max(E_i, \\varepsilon))^{1/4}$，然后将 $\\rho$ 和 $T$ 平均到面上来计算 $\\chi_{i+\\frac{1}{2}}$。瑞利数 $R$ 使用面中心梯度和面中心能量尺度 $E_{i+\\frac{1}{2}} = (E_i + E_{i+1})/2$。在 $R=0$ 附近，对通量限制器 $\\lambda(R)$ 的数值计算要特别小心，此时使用渐近极限 $\\lambda(R) \\approx 1/3$ 以避免数值抵消误差。时间步长 $\\Delta t$ 由初始状态的最大扩散系数和给定的因子 $\\beta$ 决定，该因子被故意选择为违反简单显式抛物型格式的 CFL 条件，从而凸显通量限制器的必要性和有效性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a 1D explicit positivity-preserving\n    Flux-Limited Diffusion (FLD) solver.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"kappa0\": 1.0, \"a\": 1.0, \"b\": -3.5,\n            \"rho_func\": lambda x: 1.0 + 0.5 * np.sin(4 * np.pi * x),\n            \"E_func\": lambda x: 1.0 + np.exp(-((x - 0.5)**2) / 0.05**2),\n            \"beta\": 2.0, \"N_steps\": 50\n        },\n        {\n            \"id\": 2,\n            \"kappa0\": 5.0, \"a\": 1.0, \"b\": -3.5,\n            \"rho_func\": lambda x: 0.1 + 10 * np.exp(-((x - 0.25)**2) / 0.02**2) + 30 * np.exp(-((x - 0.75)**2) / 0.01**2),\n            \"E_func\": lambda x: 0.5 + 2 * np.exp(-((x - 0.5)**2) / 0.03**2),\n            \"beta\": 5.0, \"N_steps\": 30\n        },\n        {\n            \"id\": 3,\n            \"kappa0\": 1.0, \"a\": 1.0, \"b\": -3.5,\n            \"rho_func\": lambda x: np.where(np.abs(x - 0.5)  0.05, 1e-4, 1.0),\n            \"E_func\": lambda x: 1.0 + 0.8 * np.tanh((0.5 - x) / 0.02),\n            \"beta\": 10.0, \"N_steps\": 20\n        }\n    ]\n\n    all_results = []\n    \n    # Global parameters\n    L = 1.0\n    N = 256\n    ar = 1.0\n    c_light = 1.0\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    EPSILON = 1e-100\n\n    def compute_lambda(R):\n        \"\"\"Computes the Levermore-Pomraning flux limiter.\"\"\"\n        R_small_tol = 1e-6\n        lambda_val = np.zeros_like(R)\n        \n        mask_small = R  R_small_tol\n        mask_large = ~mask_small\n\n        R_large = R[mask_large]\n        lambda_val[mask_large] = (1.0 / R_large) * (1.0 / np.tanh(R_large) - 1.0 / R_large)\n        \n        # Taylor expansion for small R: 1/3 - R^2/45 + ...\n        # For simplicity and as per problem, we can use the limit directly.\n        lambda_val[mask_small] = 1.0 / 3.0\n        \n        return lambda_val\n\n    def get_face_properties(E, rho, k0, a, b):\n        \"\"\"Computes all necessary face-centered quantities.\"\"\"\n        # Cell-centered temperatures, regularized for flux computation\n        T_cell = np.power(np.maximum(E, EPSILON), 0.25)\n        \n        # Arithmetic mean for face-centered quantities\n        E_face = (E[:-1] + E[1:]) / 2.0\n        rho_face = (rho[:-1] + rho[1:]) / 2.0\n        T_face = (T_cell[:-1] + T_cell[1:]) / 2.0\n\n        # Face-centered opacity and gradient\n        chi_face = k0 * np.power(rho_face, a + 1.0) * np.power(T_face, b)\n        grad_E_face = (E[1:] - E[:-1]) / dx\n\n        # Rayleigh number R\n        R_face = np.abs(grad_E_face) / (chi_face * E_face + EPSILON)\n\n        # Flux-limiter lambda and diffusion coefficient D\n        lambda_face = compute_lambda(R_face)\n        D_face = c_light * lambda_face / (chi_face + EPSILON)\n        \n        return D_face, grad_E_face\n\n    def run_simulation(E_init, rho, params, limited):\n        \"\"\"Runs a single simulation (baseline or limited).\"\"\"\n        k0, a, b = params[\"kappa0\"], params[\"a\"], params[\"b\"]\n        N_steps, beta = params[\"N_steps\"], params[\"beta\"]\n\n        # Calculate timestep dt based on initial conditions\n        D0_face, _ = get_face_properties(E_init, rho, k0, a, b)\n        max_D0 = np.max(D0_face) if D0_face.size > 0 else 1.0\n        dt = beta * dx**2 / (2.0 * max_D0)\n\n        E = E_init.copy()\n\n        for _ in range(N_steps):\n            D_face, grad_E_face = get_face_properties(E, rho, k0, a, b)\n            \n            # 1. Compute unlimited physical flux\n            F_unlimited = -D_face * grad_E_face\n            \n            F_final = F_unlimited\n            if limited:\n                # 2. Compute positivity-preserving flux caps\n                E_upwind = np.where(E[:-1] > E[1:], E[:-1], E[1:])\n                \n                # Energy content bound\n                F_cap_content = E_upwind * dx / (2.0 * dt)\n                \n                # Characteristic speed and speed bound\n                v_char = np.minimum(D_face / dx, c_light)\n                F_cap_speed = v_char * E_upwind\n                \n                # Combined cap\n                F_cap = np.minimum(F_cap_content, F_cap_speed)\n                \n                # 3. Apply the limiter\n                F_limited = np.sign(F_unlimited) * np.minimum(np.abs(F_unlimited), F_cap)\n                F_final = F_limited\n\n            # 4. Update energy using final fluxes\n            # Flux array with boundary conditions F=0 on both ends\n            F_bnd = np.zeros(N + 1)\n            F_bnd[1:-1] = F_final\n            \n            E -= (dt / dx) * (F_bnd[1:] - F_bnd[:-1])\n\n        # Post-process to find minimums\n        min_E = np.min(E)\n        if not limited and min_E  0:\n            min_T = -np.power(np.abs(min_E), 0.25)\n        else:\n            # For the limited solver, min_E should be >= 0\n            # For the baseline, if min_E happens to be positive\n            min_T = np.power(max(min_E, 0), 0.25)\n            \n        return min_E, min_T\n\n    for case in test_cases:\n        rho_init = case[\"rho_func\"](x)\n        E_init = case[\"E_func\"](x)\n        \n        # Run baseline solver\n        m_E_base, m_T_base = run_simulation(E_init, rho_init, case, limited=False)\n        \n        # Run limited solver\n        m_E_lim, m_T_lim = run_simulation(E_init, rho_init, case, limited=True)\n        \n        all_results.extend([m_E_lim, m_E_base, m_T_lim, m_T_base])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3511282"}, {"introduction": "除了保证结果的正确性和鲁棒性，评估数值解的质量也同样重要。通量限制器本身是近似模型，它可能会引入被称为“阶梯效应”（staircasing）的数值伪影，这是一种人为增宽锋面的数值弥散形式。最后的这项实践[@problem_id:3511263]旨在培养您的批判性分析能力，您将通过量化不同限制器所产生的数值弥散，学会评估和比较不同数值方法的性能。", "problem": "考虑在静态均匀介质中，由通量限制扩散 (FLD) 关系封闭的扩散近似下的一维灰色辐射输运。令 $x \\in [0,1]$ 为无量纲空间坐标，$t \\ge 0$ 为无量纲时间。未知量是无量纲辐射能量密度 $E(x,t) \\ge 0$。基本框架包括：(i) 扩散近似下的辐射能量守恒，这产生一个抛物型守恒律；(ii) 带有通量限制器的辐射通量本构关系。具体来说，假设如下：\n\n- 守恒律为\n$$\n\\frac{\\partial E}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( D(E,\\partial_x E)\\, \\frac{\\partial E}{\\partial x} \\right),\n$$\n其扩散系数 $D$ 通过一个通量限制器依赖于 $E$ 及其梯度。\n\n- 定义通量限制扩散系数的本构关系为\n$$\nD(E,\\partial_x E) = \\lambda(R),\n\\quad\nR = \\frac{|\\partial_x E|}{\\max(E,\\epsilon)},\n$$\n其中 $\\epsilon  0$ 是一个小的正则化常数，以防止除以零。通量限制器 $\\lambda(R)$ 必须满足扩散极限约束 $\\lambda(R) \\to 1/3$ (当 $R \\to 0$ 时) 和自由流动约束 $\\lambda(R) \\to 1/R$ (当 $R \\to \\infty$ 时)。\n\n- 将比较两种限制器的选择：\n  1. Levermore–Pomraning 限制器\n  $$\n  \\lambda_{\\mathrm{LP}}(R) = \\frac{1}{R}\\left(\\coth R - \\frac{1}{R}\\right),\n  $$\n  其中 $\\coth R = \\frac{\\cosh R}{\\sinh R}$，并且为了数值稳健性，可以使用小 $R$ 极限展开，\n  $$\n  \\lambda_{\\mathrm{LP}}(R) \\approx \\frac{1}{3} - \\frac{R^2}{45} \\quad \\text{当 } R \\to 0.\n  $$\n  2. 一种为减少阶梯效应同时保持渐近极限而提出的改进限制器，\n  $$\n  \\lambda^\\ast(R) = \\frac{1}{\\sqrt{9 + R^2}},\n  $$\n  其满足 $\\lambda^\\ast(0)=1/3$ 且当 $R \\to \\infty$ 时 $\\lambda^\\ast(R) \\sim 1/R$。\n\n本任务旨在通过测量两种限制器 $\\lambda_{\\mathrm{LP}}(R)$ 和 $\\lambda^\\ast(R)$ 的波前厚度与网格分辨率 $N$ 的关系，来研究由限制器引起的非线性所引入的数值扩散。在具有 $N$ 个单元的均匀网格上，使用零通量边界条件，实现一个守恒的显式有限体积格式。令单元中心的未知量为 $E_i(t)$ (其中 $i=0,\\dots,N-1$)，网格间距为 $\\Delta x = 1/N$。使用两点梯度和在面上求值的限制器所定义的面心扩散系数来近似面心通量。为保证稳定性，选择一个满足基于最大可能扩散系数的标准扩散限制的时间步长 $\\Delta t$。使用一个恒定的最终时间 $t_{\\mathrm{final}}$，并从下面指定的初始条件开始积分。\n\n初始条件和参数：\n- 初始数据为黎曼型波前：\n$$\nE(x,0) = \\begin{cases}\nE_{\\mathrm{L}},  x  1/2, \\\\\nE_{\\mathrm{R}},  x \\ge 1/2,\n\\end{cases}\n$$\n其中 $E_{\\mathrm{L}} = 1$ 且 $E_{\\mathrm{R}} = 10^{-3}$。\n- 在 $x=0$ 和 $x=1$ 处的边界条件为零通量（齐次诺伊曼）。\n- 使用 $t_{\\mathrm{final}} = 2 \\times 10^{-2}$ 和 $\\epsilon = 10^{-12}$。\n\n将给定时间的波前厚度 $w$ 定义为 $E$ 达到阈值\n$$\nE_{0.1} = E_{\\mathrm{R}} + 0.1\\,(E_{\\mathrm{L}} - E_{\\mathrm{R}}), \\quad\nE_{0.9} = E_{\\mathrm{R}} + 0.9\\,(E_{\\mathrm{L}} - E_{\\mathrm{R}}),\n$$\n的两点之间的空间距离，使用相邻单元中心之间的线性插值来定位位置 $x_{0.1}$ 和 $x_{0.9}$，使得 $E(x_{0.1},t_{\\mathrm{final}}) = E_{0.1}$ 和 $E(x_{0.9},t_{\\mathrm{final}}) = E_{0.9}$。那么 $w = |x_{0.9} - x_{0.1}|$。\n\n你的程序必须：\n- 实现显式有限体积更新\n$$\nE_i^{n+1} = E_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\n附带数值通量\n$$\nF_{i+\\frac{1}{2}}^n = - D_{i+\\frac{1}{2}}^n \\left(\\frac{E_{i+1}^n - E_i^n}{\\Delta x}\\right),\n\\quad\nD_{i+\\frac{1}{2}}^n = \\lambda\\!\\left(R_{i+\\frac{1}{2}}^n\\right),\n\\quad\nR_{i+\\frac{1}{2}}^n = \\frac{\\left|E_{i+1}^n - E_i^n\\right|/\\Delta x}{\\max\\!\\big(\\tfrac{1}{2}(E_{i+1}^n + E_i^n),\\,\\epsilon\\big)}.\n$$\n通过设置 $F_{-1/2}^n = 0$ 和 $F_{N-1/2}^n = 0$ 来强制执行零通量边界。\n\n- 使用满足\n$$\n\\Delta t \\le \\frac{\\Delta x^2}{2\\,D_{\\max}},\n$$\n的时间步长，其中 $D_{\\max} = 1/3$，并应用 0.9 的安全系数。\n\n- 对于每种限制器选择 $\\lambda \\in \\{\\lambda_{\\mathrm{LP}}, \\lambda^\\ast\\}$ 和网格分辨率 $N \\in \\{32, 64, 128, 256\\}$，计算在 $t_{\\mathrm{final}}$ 时的波前厚度 $w(N,\\lambda)$。\n\n- 对于每种限制器，通过对四个 $N$ 值的数据 $\\{\\log \\Delta x, \\log w\\}$ 进行线性拟合来估计标度指数 $s(\\lambda)$，其中 $\\Delta x = 1/N$。也就是说，找到 $s(\\lambda)$ 使得\n$$\n\\log w \\approx s(\\lambda)\\, \\log \\Delta x + b(\\lambda).\n$$\n\n- 为了在 $R=0$ 附近获得数值稳健性，当 $R  10^{-6}$ 时，使用其小 $R$ 展开式来计算 $\\lambda_{\\mathrm{LP}}(R)$。\n\n测试套件和所需输出：\n- 测试套件包括针对两种限制器在指定的 $N$ 值下的八个波前厚度计算，以及两个拟合的标度指数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n\\big[ w(32,\\lambda_{\\mathrm{LP}}),\\, w(64,\\lambda_{\\mathrm{LP}}),\\, w(128,\\lambda_{\\mathrm{LP}}),\\, w(256,\\lambda_{\\mathrm{LP}}),\\, w(32,\\lambda^\\ast),\\, w(64,\\lambda^\\ast),\\, w(128,\\lambda^\\ast),\\, w(256,\\lambda^\\ast),\\, s(\\lambda_{\\mathrm{LP}}),\\, s(\\lambda^\\ast) \\big].\n$$\n所有量都是无量纲实数。程序必须在没有任何用户输入的情况下运行至完成，并按规定精确打印此单行内容。", "solution": "用户提供了一个有效的问题陈述。任务是使用显式有限体积方法模拟一维通量限制辐射扩散，比较两种不同的通量限制器，并分析产生的数值扩散。\n\n### 原理与方法\n\n控制方程是关于辐射能量密度 $E(x,t)$ 的非线性抛物型偏微分方程：\n$$\n\\frac{\\partial E}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( D(E,\\partial_x E)\\, \\frac{\\partial E}{\\partial x} \\right) = \\frac{\\partial F}{\\partial x}\n$$\n其中 $F = -D \\frac{\\partial E}{\\partial x}$ 是辐射通量。扩散系数 $D$ 通过其对通量限制器 $\\lambda(R)$ 的依赖性而变得非线性。在计算天体物理学中，这是一种标准技术，用于模拟光学厚（扩散）和光学薄（自由流动）两种状态下的辐射转移。\n\n关键参数 $R$ 是辐射能量密度的无量纲梯度：\n$$\nR = \\frac{|\\partial_x E|}{\\max(E,\\epsilon)}\n$$\n在具有陡峭梯度的区域（光学薄或波前区域），$R$ 值较大；在平滑区域（光学厚），$R$ 值较小。通量限制器 $\\lambda(R)$ 必须满足两个物理极限：\n1.  **扩散极限 ($R \\to 0$)：** 在光学厚介质中，输运是扩散性的。对于灰色输运，这对应于 $\\lambda(R) \\to 1/3$。\n2.  **自由流动极限 ($R \\to \\infty$)：** 在光学薄介质中，辐射以光速（在我们的无量纲单位中为 $c=1$）流动。通量大小 $|F|$ 不应超过 $cE = E$。由于 $|F| = \\lambda(R) |\\partial_x E| = \\lambda(R) R E$，这要求 $\\lambda(R)R \\le 1$，在 $R \\to \\infty$ 时最优情况为 $\\lambda(R) \\to 1/R$。\n\n问题比较了经典的 Levermore–Pomraning 限制器 $\\lambda_{\\mathrm{LP}}(R)$ 和一种改进形式 $\\lambda^\\ast(R)$，两者都满足这些渐近约束。\n\n### 数值实现\n\n问题规定了使用一种守恒的有限体积方法。计算域 $[0, 1]$ 被离散化为 $N$ 个宽度均匀的单元，单元宽度为 $\\Delta x = 1/N$。单元 $i$ 的单元中心能量密度记为 $E_i$。时间演化由显式前向欧拉格式控制：\n$$\n\\frac{E_i^{n+1} - E_i^n}{\\Delta t} = \\frac{F_{i+1/2}^n - F_{i-1/2}^n}{\\Delta x}\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。\n\n数值通量定义为：\n$$\nF_{i+1/2}^n = - D_{i+1/2}^n \\left(\\frac{E_{i+1}^n - E_i^n}{\\Delta x}\\right)\n$$\n界面扩散系数 $D_{i+1/2}^n$ 通过使用面心量计算限制器 $\\lambda$ 来得到：\n$$\nD_{i+1/2}^n = \\lambda\\left(R_{i+1/2}^n\\right)\n$$\n其中\n$$\nR_{i+1/2}^n = \\frac{|E_{i+1}^n - E_i^n|/\\Delta x}{\\max\\left(\\frac{1}{2}(E_{i+1}^n + E_i^n), \\epsilon\\right)}\n$$\n该格式由问题陈述完全定义，包括零通量边界条件（$F_{-1/2} = F_{N-1/2} = 0$）和基于最大可能扩散系数 $D_{\\max} = 1/3$ 的稳定时间步长 $\\Delta t$。\n\n### 波前厚度和标度分析\n\n模拟以一个阶跃函数（一个黎曼问题）进行初始化，该函数会演化为一个传播的波前。某些通量限制器（特别是 $\\lambda_{\\mathrm{LP}}$）的一个已知的人为效应是“阶梯效应”，即陡峭的波前被渲染成一系列阶梯。这是一种数值扩散形式，其中波前宽度与网格分辨率相关联。\n\n为了量化这一点，在固定的时间 $t_{\\mathrm{final}}$ 测量波前厚度 $w$。厚度定义为距离 $|x_{0.9} - x_{0.1}|$，其中 $x_{0.1}$ 和 $x_{0.9}$ 分别是能量密度 $E$ 等于 $E_{\\mathrm{R}} + 0.1(E_{\\mathrm{L}} - E_{\\mathrm{R}})$ 和 $E_{\\mathrm{R}} + 0.9(E_{\\mathrm{L}} - E_{\\mathrm{R}})$ 的位置。这些位置通过对最终的离散解进行线性插值找到。\n\n通过对一系列网格分辨率 $N$ 运行模拟，我们得到 $w$ 作为网格间距 $\\Delta x = 1/N$ 的函数。该关系被建模为幂律，$w \\propto (\\Delta x)^s$。标度指数 $s$ 通过对对数空间中的数据进行线性最小二乘拟合来确定：\n$$\n\\log w = s \\log \\Delta x + b\n$$\n$s$ 的值表示波前宽度依赖于网格的程度。一个理想的限制器将产生一个与 $\\Delta x$ 无关的物理波前宽度，对应于 $s=0$。较大的 $s$ 意味着更大的数值扩散。目标是计算 $\\lambda_{\\mathrm{LP}}$ 和 $\\lambda^\\ast$ 的 $s$ 值并进行比较。\n\n实现将按以下步骤进行：\n1.  一个主循环遍历指定的网格分辨率 $N \\in \\{32, 64, 128, 256\\}$ 和两个限制器函数。\n2.  对于每种情况，调用一个模拟函数 `run_simulation`。它初始化网格和状态，然后在时间上迭代直到 $t_{\\mathrm{final}}$，在每一步计算通量并更新状态向量。\n3.  模拟结束后，`run_simulation` 使用一个插值辅助函数计算波前厚度 $w$。\n4.  收集所有 $w$ 值后，使用 `numpy.polyfit` 对对数变换后的数据计算标度指数 $s$。\n5.  最后，将收集到的结果格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation, analysis, and output.\n    It encapsulates all helper functions and constants as specified by the problem.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    E_L = 1.0\n    E_R = 1e-3\n    T_FINAL = 2e-2\n    EPSILON = 1e-12\n    D_MAX = 1.0 / 3.0\n    CFL_FACTOR = 0.9\n    R_LP_THRESHOLD = 1e-6\n\n    # --- Helper Functions ---\n\n    def limiter_lp(R):\n        \"\"\"\n        Computes the Levermore-Pomraning flux limiter.\n        This is a vectorized implementation with a small-R Taylor expansion for robustness.\n        \"\"\"\n        R = np.asanyarray(R)\n        result = np.zeros_like(R, dtype=float)\n        \n        small_r_mask = R  R_LP_THRESHOLD\n        large_r_mask = ~small_r_mask\n\n        # Small R expansion: lambda(R) ~ 1/3 - R^2/45\n        r_small = R[small_r_mask]\n        result[small_r_mask] = (1.0/3.0) - (r_small**2 / 45.0)\n\n        # Full expression for larger R: lambda(R) = (1/R) * (coth(R) - 1/R)\n        r_large = R[large_r_mask]\n        with np.errstate(divide='ignore', invalid='ignore'):\n            coth_r = 1.0 / np.tanh(r_large)\n            val = (1.0 / r_large) * (coth_r - 1.0 / r_large)\n        result[large_r_mask] = val\n        \n        # Explicitly handle R=0 if it appears\n        result[R == 0] = 1.0 / 3.0\n        \n        return result\n\n    def limiter_star(R):\n        \"\"\"\n        Computes the modified flux limiter lambda*.\n        This function is naturally vectorized using numpy operations.\n        \"\"\"\n        R = np.asanyarray(R)\n        return 1.0 / np.sqrt(9.0 + R**2)\n\n    def find_x_interpolated(E, x_centers, dx, E_threshold):\n        \"\"\"\n        Finds the spatial coordinate x where the energy density E equals E_threshold,\n        using linear interpolation between cell centers. E is assumed to be monotonic.\n        \"\"\"\n        # Find indices 'i' where the profile crosses the threshold E_threshold.\n        # This handles the case where the profile might be decreasing.\n        indices = np.where(\n            ((E[:-1] >= E_threshold)  (E[1:]  E_threshold)) | \n            ((E[:-1] = E_threshold)  (E[1:] > E_threshold))\n        )[0]\n\n        if not indices.size:\n            return np.nan # Should not happen in this problem\n\n        i = indices[0]\n        \n        x_i = x_centers[i]\n        E_i = E[i]\n        E_i_plus_1 = E[i+1]\n        \n        # Linear interpolation formula: x = x_i + dx * (E_target - E_i) / (E_{i+1} - E_i)\n        x_interp = x_i + (E_threshold - E_i) * dx / (E_i_plus_1 - E_i)\n        \n        return x_interp\n\n    def run_simulation(N, limiter_func):\n        \"\"\"\n        Runs the 1D FLD simulation for a given grid size N and limiter function.\n        Returns the computed front thickness w.\n        \"\"\"\n        # 1. Grid, Initial Conditions, and Parameters\n        dx = 1.0 / N\n        x_centers = np.linspace(dx / 2.0, 1.0 - dx / 2.0, N)\n        \n        E = np.full(N, E_R)\n        mid_point_idx = int(N / 2)\n        E[:mid_point_idx] = E_L\n        \n        dt = CFL_FACTOR * (dx**2) / (2.0 * D_MAX)\n        t = 0.0\n        \n        # 2. Time Integration Loop\n        while t  T_FINAL:\n            current_dt = min(dt, T_FINAL - t)\n            \n            # 3. Compute fluxes at internal cell faces\n            dE = E[1:] - E[:-1]\n            grad_E = dE / dx\n            E_face = 0.5 * (E[1:] + E[:-1])\n            R_face = np.abs(grad_E) / np.maximum(E_face, EPSILON)\n            D_face = limiter_func(R_face)\n            F_internal = -D_face * grad_E\n            \n            # 4. Update energy density using conservative finite-volume formula\n            F_all = np.zeros(N + 1)\n            F_all[1:-1] = F_internal\n            \n            E -= (current_dt / dx) * (F_all[1:] - F_all[:-1])\n            \n            t += current_dt\n\n        # 5. Compute front thickness at t_final\n        E_01 = E_R + 0.1 * (E_L - E_R)\n        E_09 = E_R + 0.9 * (E_L - E_R)\n\n        x_01 = find_x_interpolated(E, x_centers, dx, E_01)\n        x_09 = find_x_interpolated(E, x_centers, dx, E_09)\n        \n        w = np.abs(x_09 - x_01)\n        \n        return w\n\n    # --- Main Execution Logic ---\n    \n    # Define test suite parameters\n    N_values = np.array([32, 64, 128, 256])\n    limiters = {'lp': limiter_lp, 'star': limiter_star}\n    \n    w_results = {}\n    \n    # Run simulations for each limiter and grid resolution\n    for name, func in limiters.items():\n        w_values = []\n        for N in N_values:\n            w = run_simulation(N, func)\n            w_values.append(w)\n        w_results[name] = w_values\n        \n    # Calculate scaling exponents from a log-log linear fit\n    dx_values = 1.0 / N_values\n    log_dx = np.log(dx_values)\n    \n    log_w_lp = np.log(w_results['lp'])\n    s_lp = np.polyfit(log_dx, log_w_lp, 1)[0]\n    \n    log_w_star = np.log(w_results['star'])\n    s_star = np.polyfit(log_dx, log_w_star, 1)[0]\n    \n    # Format the final output list as specified\n    final_results = w_results['lp'] + w_results['star'] + [s_lp, s_star]\n    \n    print(f\"[{','.join(f'{x:.10f}' for x in final_results)}]\")\n\n\nsolve()\n```", "id": "3511263"}]}