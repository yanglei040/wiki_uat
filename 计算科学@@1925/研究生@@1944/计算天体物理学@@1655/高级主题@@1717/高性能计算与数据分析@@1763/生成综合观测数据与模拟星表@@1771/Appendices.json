{"hands_on_practices": [{"introduction": "在构建模拟星系表之前，我们必须首先建立我们模拟宇宙的几何框架。这个练习将抽象的$\\Lambda$CDM宇宙学模型与巡天体积元的具体概念联系起来，这是将理论上的星系数量密度转换为可观测计数的关键第一步。通过这个计算 [@problem_id:3512721]，您将掌握如何量化特定红移切片的共动深度，这是生成任何实际模拟星表的基础技能。", "problem": "您正在为一次综合测光巡天构建一个模拟星系表。为了将目标共动数密度转换为一个薄红移切片内每立体角的预期计数，您需要该切片在给定红移处的共动径向厚度。考虑一个空间平坦的 Lambda 冷暗物质 (ΛCDM) 宇宙学模型，其中物质密度参数 $\\Omega_{m}=0.3$，暗能量密度参数 $\\Omega_{\\Lambda}=0.7$，哈勃常数 $H_{0}=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$。假设在相关红移处辐射密度可忽略不计，且空间是平坦的，因此 $\\Omega_{m}+\\Omega_{\\Lambda}=1$。使用共动径向距离的定义和 ΛCDM 的弗里德曼方程，推导一个以 $z=1$ 为中心、宽度为 $\\Delta z$ 的红移切片的共动径向厚度 $\\Delta \\chi$ 的一阶表达式，并计算其在 $\\Delta z=0.1$ 时的数值。使用光速 $c=2.99792458\\times 10^{5}\\,\\mathrm{km\\,s^{-1}}$。将您的最终数值答案以百万秒差距 (Mpc) 为单位表示，并四舍五入到四位有效数字。", "solution": "在空间平坦的 Friedmann–Lemaître–Robertson–Walker 时空中，共动径向距离定义为\n$$\n\\chi(z)=c\\int_{0}^{z}\\frac{dz'}{H(z')}\\,,\n$$\n其中 $c$ 是光速，$H(z)$ 是依赖于红移的哈勃参数。对于一个以 $z$ 为中心、宽度为 $\\Delta z$ 的薄红移切片，当 $\\Delta z$ 的高阶项可以忽略时，其共动径向厚度的一阶近似为\n$$\n\\Delta \\chi \\approx \\left.\\frac{d\\chi}{dz}\\right|_{z}\\,\\Delta z = \\frac{c}{H(z)}\\,\\Delta z\\,.\n$$\n因此，任务简化为在给定的宇宙学模型中计算 $z=1$ 时的 $H(z)$。对于一个空间平坦、物质密度参数为 $\\Omega_{m}$、暗能量密度参数为 $\\Omega_{\\Lambda}$ 的 Lambda 冷暗物质 (ΛCDM) 宇宙学模型（假设辐射可忽略），弗里德曼方程给出\n$$\nH(z)=H_{0}\\,\\sqrt{\\Omega_{m}(1+z)^{3}+\\Omega_{\\Lambda}}\\,.\n$$\n使用所给参数，在 $z=1$ 处进行计算，\n$$\nH(1)=H_{0}\\,\\sqrt{\\Omega_{m}(1+1)^{3}+\\Omega_{\\Lambda}}=H_{0}\\,\\sqrt{\\Omega_{m}\\cdot 8+\\Omega_{\\Lambda}}=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}\\times \\sqrt{0.3\\times 8+0.7}\\,.\n$$\n计算平方根内的参数：\n$$\n0.3\\times 8+0.7=2.4+0.7=3.1\\,,\n$$\n所以\n$$\nH(1)=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}\\times \\sqrt{3.1}\\,.\n$$\n因此，\n$$\n\\Delta \\chi \\approx \\frac{c}{H(1)}\\,\\Delta z=\\frac{2.99792458\\times 10^{5}\\,\\mathrm{km\\,s^{-1}}}{70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}\\,\\sqrt{3.1}}\\times 0.1\\,.\n$$\n消去 $\\mathrm{km\\,s^{-1}}$ 单位并简化前置因子，\n$$\n\\Delta \\chi = \\frac{2.99792458\\times 10^{5}}{70\\,\\sqrt{3.1}}\\,\\mathrm{Mpc}\\times 0.1\\,.\n$$\n现在分步进行数值计算，在最终计算前保留符号常量：\n- 计算 $\\sqrt{3.1}$：$\\sqrt{3.1}\\approx 1.7606816861659$。\n- 计算 $H(1)=70\\times \\sqrt{3.1}\\approx 70\\times 1.7606816861659\\approx 123.247718031613\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$。\n- 计算 $c/H(1)\\approx \\frac{2.99792458\\times 10^{5}}{123.247718031613}\\,\\mathrm{Mpc}\\approx 2{,}432.438205\\,\\mathrm{Mpc}$。\n- 乘以 $\\Delta z=0.1$：\n$$\n\\Delta \\chi \\approx 243.2438205\\,\\mathrm{Mpc}\\,.\n$$\n按要求四舍五入到四位有效数字，得到\n$$\n\\Delta \\chi \\approx 243.2\\,\\mathrm{Mpc}\\,.\n$$", "answer": "$$\\boxed{243.2}$$", "id": "3512721"}, {"introduction": "定义了巡天体积后，下一步是模拟哪些星系能被实际探测到。并非所有存在的星系都会进入我们的最终星表；这个过程受制于所谓的“选择效应”。这个练习 [@problem_id:3512735] 是一个实用的编程任务，旨在模拟一个真实的光度巡天的完备性，同时考虑了星系的内禀亮度分布、不均匀的巡天深度以及测量噪声，这些都是塑造我们观测样本的关键因素。", "problem": "给定一个由分层等面积等纬度像素化（HEALPix）图描述的综合天图，对于每个由其角中心 $\\vec{\\theta}_i$ 索引的像素，该图存储了在单个巡天波段中当地的 $5\\sigma$ 深度极限星等，记为 $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$。假设一个星系群，其真实视星等 $m$ 在有界区间 $[m_{\\min}, m_{\\max}]$ 上根据微分星数计数模型 $p(m)$ 分布，并假设仪器对星等的测量噪声是高斯噪声。具体来说，以真实星等 $m$ 为条件的测量星等 $m_{\\mathrm{meas}}$ 服从均值为 $m$、标准差为 $\\sigma_m$ 的正态随机变量分布，且一个源被探测到的充要条件是 $m_{\\mathrm{meas}} \\le m_{\\mathrm{lim}}(\\vec{\\theta})$。将局部完备性 $C(\\vec{\\theta})$ 定义为在位置 $\\vec{\\theta}$ 处被探测到的内禀星系群的比例，该比例是在区间 $[m_{\\min}, m_{\\max}]$ 内对真实星等分布取平均得到的。\n\n从概率论和上述指定的高斯模型出发，推导一个用关于 $m$ 的积分表示的 $C(\\vec{\\theta})$ 表达式，并实现一个数值算法。该算法在给定 $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$ 的 HEALPix 图以及 $p(m)$ 和 $\\sigma_m$ 的参数后，为图中的每个像素 $i$ 计算 $C(\\vec{\\theta}_i)$。对于本问题，取星等分布为\n$$\np(m) \\propto 10^{\\beta m} \\quad \\text{for} \\quad m \\in [m_{\\min}, m_{\\max}],\n$$\n在该区间外 $p(m) = 0$。比例常数无需显式确定，因为 $C(\\vec{\\theta})$ 是一个积分之比，其中任何常数归一化因子都会被抵消。\n\n您的程序必须对下面指定的每个测试用例计算 $C(\\vec{\\theta}_i)$，并将所有测试用例的结果输出到单行，格式化为一个逗号分隔的 Python 风格列表，其元素是浮点数列表。每个内部列表对应一个测试用例，并包含每个像素的完备性值，其顺序与输入的 $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$ 值相同。将每个完备性值四舍五入到小数点后 $4$ 位。不需要进行物理单位转换，因为根据定义，天文学中的星等是无量纲的；角度 $\\vec{\\theta}$ 不直接用于计算，但如果引用任何角度，应以弧度为单位。探测阈值规则是本问题中使用的唯一仪器模型。\n\n使用以下测试套件实现解决方案，其中每个测试用例提供 HEALPix 像素的极限星等 $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$、$p(m)$ 的斜率参数 $\\beta$、星等边界 $m_{\\min}$ 和 $m_{\\max}$，以及测量噪声 $\\sigma_m$：\n\n- 测试用例 $1$（一般情况，不同深度）：\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[24.5, 24.0, 23.0, 25.5\\right]$\n  - $\\beta = 0.6$\n  - $m_{\\min} = 20.0$, $m_{\\max} = 26.0$\n  - $\\sigma_m = 0.1$\n\n- 测试用例 $2$（亮端极限边界，预期完备性低）：\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[21.0, 21.5\\right]$\n  - $\\beta = 0.6$\n  - $m_{\\min} = 20.0$, $m_{\\max} = 26.0$\n  - $\\sigma_m = 0.05$\n\n- 测试用例 $3$（暗端极限情况，预期完备性高）：\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[26.0, 26.5, 27.0\\right]$\n  - $\\beta = 0.4$\n  - $m_{\\min} = 20.0$, $m_{\\max} = 27.0$\n  - $\\sigma_m = 0.2$\n\n- 测试用例 $4$（星等均匀分布，$\\beta = 0$）：\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[24.0, 25.0, 26.0\\right]$\n  - $\\beta = 0.0$\n  - $m_{\\min} = 22.0$, $m_{\\max} = 26.0$\n  - $\\sigma_m = 0.2$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素本身是对应一个测试用例的列表。例如，输出应类似于 $\\left[[c_{1,1}, c_{1,2}, \\dots], [c_{2,1}, c_{2,2}, \\dots], \\dots\\right]$，其中每个 $c_{t,i}$ 是一个四舍五入到小数点后 $4$ 位的浮点数。", "solution": "用户提供的问题是有效的。它在科学上基于观测天文学和统计分析的原理，问题陈述清晰，所有必要参数均已定义，并以客观、正式的语言表述。它代表了天体物理学中为表征巡天选择效应而执行的一项标准计算。\n\n该问题要求推导并实现局部完备性 $C(\\vec{\\theta})$ 的公式，它被定义为在特定天空位置 $\\vec{\\theta}$ 处探测到的内禀星系群的比例。探测受到极限星等 $m_{\\mathrm{lim}}(\\vec{\\theta})$ 和高斯测量噪声的影响。\n\n首先，我们形式化计算的各个组成部分。星系的内禀真实视星等 $m$ 的分布由一个星数计数模型 $p(m)$ 给出，该模型仅在区间 $[m_{\\min}, m_{\\max}]$ 上非零。问题指定在该区间上 $p(m) \\propto 10^{\\beta m}$。从这个分布中抽取一个星系。然后测量其星等，得到一个值 $m_{\\mathrm{meas}}$。这个测量值是一个随机变量，服从均值为真实星等 $m$、标准差为 $\\sigma_m$ 的正态分布。我们可以将其写作 $P(m_{\\mathrm{meas}} | m) = \\mathcal{N}(m, \\sigma_m^2)$。一个星系被探测到的充要条件是其测量星等小于或等于当地的极限星等，即 $m_{\\mathrm{meas}} \\le m_{\\mathrm{lim}}(\\vec{\\theta})$。\n\n在给定其真实星等 $m$ 和当地极限星等 $m_{\\mathrm{lim}} \\equiv m_{\\mathrm{lim}}(\\vec{\\theta})$ 的条件下，探测到一个星系的概率是 $P(m_{\\mathrm{meas}} \\le m_{\\mathrm{lim}} | m)$。这个概率由正态分布 $\\mathcal{N}(m, \\sigma_m^2)$ 在 $m_{\\mathrm{lim}}$ 处的累积分布函数 (CDF) 给出。\n$$ P(\\text{detection}|m, m_{\\mathrm{lim}}) = \\int_{-\\infty}^{m_{\\mathrm{lim}}} \\frac{1}{\\sqrt{2\\pi}\\sigma_m} \\exp\\left(-\\frac{(x-m)^2}{2\\sigma_m^2}\\right) dx $$\n通过变量替换 $z = (x-m)/\\sigma_m$，该积分变为标准正态分布的累积分布函数 $\\Phi(z)$ 在 $z = (m_{\\mathrm{lim}} - m)/\\sigma_m$ 处的值。\n$$ P(\\text{detection}|m, m_{\\mathrm{lim}}) = \\Phi\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sigma_m}\\right) $$\n标准正态累积分布函数 $\\Phi(z)$ 与误差函数 $\\text{erf}(x)$ 通过恒等式 $\\Phi(z) = \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right)$ 相关联。将此代入我们的表达式，得到探测概率：\n$$ P(\\text{detection}|m, m_{\\mathrm{lim}}) = \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sqrt{2}\\sigma_m}\\right)\\right) $$\n\n完备性 $C(\\vec{\\theta})$ 是被探测到的星系的总比例，它是探测概率 $P(\\text{detection}|m, m_{\\mathrm{lim}})$ 按内禀星等分布 $p(m)$ 加权平均的结果。这被计算为探测到的星系数量与星系总数之比。用概率密度表示，该比率为：\n$$ C(m_{\\mathrm{lim}}) = \\frac{\\int_{m_{\\min}}^{m_{\\max}} p(m) P(\\text{detection}|m, m_{\\mathrm{lim}}) \\,dm}{\\int_{m_{\\min}}^{m_{\\max}} p(m) \\,dm} $$\n注意，对 $\\vec{\\theta}$ 的依赖完全通过 $m_{\\mathrm{lim}}(\\vec{\\theta})$ 体现，因此我们写作 $C(m_{\\mathrm{lim}})$。代入 $p(m)$ 和探测概率的表达式，我们得到：\n$$ C(m_{\\mathrm{lim}}) = \\frac{\\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\cdot \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sqrt{2}\\sigma_m}\\right)\\right) \\,dm}{\\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\,dm} $$\n$p(m)$ 的比例常数在分子和分母中是相同的，因此它被抵消了，正如问题中所述。\n\n分母可以解析求解。积分为 $\\int 10^{\\beta m} dm = \\int e^{\\beta m \\ln(10)} dm$。\n当 $\\beta \\neq 0$ 时：\n$$ \\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\,dm = \\left[ \\frac{10^{\\beta m}}{\\beta \\ln(10)} \\right]_{m_{\\min}}^{m_{\\max}} = \\frac{10^{\\beta m_{\\max}} - 10^{\\beta m_{\\min}}}{\\beta \\ln(10)} $$\n对于 $\\beta = 0$ 的特殊情况，被积函数为 $10^0 = 1$，所以积分就是：\n$$ \\int_{m_{\\min}}^{m_{\\max}} 1 \\,dm = m_{\\max} - m_{\\min} $$\n\n分子，\n$$ I_{\\text{num}} = \\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\cdot \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sqrt{2}\\sigma_m}\\right)\\right) \\,dm $$\n没有简单的闭合形式解析解，必须使用数值积分来计算。\n\n解决该问题的算法如下：\n$1$. 对每个测试用例，解析输入参数：极限星等列表 $\\{m_{\\mathrm{lim},i}\\}$、斜率 $\\beta$、边界 $m_{\\min}$ 和 $m_{\\max}$，以及噪声 $\\sigma_m$。\n$2$. 对列表中的每个 $m_{\\mathrm{lim},i}$：\n    a. 将分子的被积函数定义为 $m$ 的函数, $f(m) = 10^{\\beta m} \\cdot \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim},i} - m}{\\sqrt{2}\\sigma_m}\\right)\\right)$。\n    b.对 $f(m)$ 从 $m_{\\min}$ 到 $m_{\\max}$ 进行数值积分，以获得分子 $I_{\\text{num}}$。\n    c. 使用给定 $\\beta$ 的相应公式解析计算分母 $I_{\\text{den}}$。\n    d. 计算完备性 $C_i = I_{\\text{num}} / I_{\\text{den}}$。\n    e. 将结果四舍五入到小数点后4位。\n$3$. 将每个测试用例计算出的完备性值收集到一个列表中。\n$4$. 将所有测试用例的列表组合成一个最终的列表的列表。\n这个过程将使用 Python 实现，使用 `scipy.integrate.quad` 函数进行数值积分，以及使用 `scipy.special.erf` 计算误差函数。", "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the galaxy completeness problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: general case, varied depths\n        {'m_lims': [24.5, 24.0, 23.0, 25.5], 'beta': 0.6, 'm_min': 20.0, 'm_max': 26.0, 'sigma_m': 0.1},\n        # Test Case 2: bright-limit boundary, expected low completeness\n        {'m_lims': [21.0, 21.5], 'beta': 0.6, 'm_min': 20.0, 'm_max': 26.0, 'sigma_m': 0.05},\n        # Test Case 3: faint-limit case, expected high completeness\n        {'m_lims': [26.0, 26.5, 27.0], 'beta': 0.4, 'm_min': 20.0, 'm_max': 27.0, 'sigma_m': 0.2},\n        # Test Case 4: uniform distribution across magnitudes, beta = 0\n        {'m_lims': [24.0, 25.0, 26.0], 'beta': 0.0, 'm_min': 22.0, 'm_max': 26.0, 'sigma_m': 0.2},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        m_lims = case['m_lims']\n        beta = case['beta']\n        m_min = case['m_min']\n        m_max = case['m_max']\n        sigma_m = case['sigma_m']\n        \n        case_results = []\n        \n        # Calculate the denominator integral once per test case\n        if beta == 0.0:\n            denominator = m_max - m_min\n        else:\n            log_10 = np.log(10)\n            denominator = (10**(beta * m_max) - 10**(beta * m_min)) / (beta * log_10)\n\n        if denominator == 0:\n            # This case should not be reached with the given inputs, but is a safeguard.\n            # If the denominator is 0, it means no galaxies in the range, so completeness is ill-defined.\n            # We can treat it as 0 detected galaxies out of 0 total, or just set completeness to 0.\n            case_results = [0.0] * len(m_lims)\n            all_results.append(case_results)\n            continue\n            \n        for m_lim in m_lims:\n            # Define the integrand for the numerator\n            def numerator_integrand(m):\n                # Unnormalized galaxy number counts p(m)\n                p_m = 10**(beta * m)\n                \n                # Detection probability P(detection|m)\n                arg_erf = (m_lim - m) / (np.sqrt(2) * sigma_m)\n                p_det = 0.5 * (1.0 + erf(arg_erf))\n                \n                return p_m * p_det\n\n            # Numerically integrate the numerator\n            # The second return value of quad is the error estimate, which we ignore.\n            numerator, _ = quad(numerator_integrand, m_min, m_max)\n            \n            # Calculate completeness\n            completeness = numerator / denominator\n            case_results.append(round(completeness, 4))\n            \n        all_results.append(case_results)\n\n    # Print the final result in the exact specified format.\n    # The default str() representation of a list of lists is \"[[], [], ...]\" which is a valid Python-style list format.\n    print(all_results)\n\nsolve()\n```", "id": "3512735"}, {"introduction": "生成合成观测的最终目的之一是理解和量化复杂的系统误差，这是高精度宇宙学分析的基石。这个高级练习 [@problem_id:3512765] 将带您超越简单的探测模拟，进入一个更复杂的场景：星系在拥挤天区中的光度混淆。您将通过正向建模来量化这种混淆效应对宇宙学测量（如弱引力透镜）产生的偏差，这是验证分析流程和确保宇宙学结论稳健性的核心步骤。", "problem": "您的任务是构建一个正向建模流程，该流程生成一个拥挤的双星系场的合成观测数据，将光度混合效应传播到形状和光度红移估计中，并量化宇宙剪切和星系-星系透镜信号中的偏差。您将在一个简化的、但科学上一致且自包含的环境中工作，该环境使用一个源星系（“目标星系”）与一个邻近星系混合。目标星系和邻近星系都具有通过高斯点扩展函数（PSF）观测到的二维高斯表面亮度分布。假设存在弱引力透镜剪切。程序必须从第一性原理出发，实现以下建模元素和计算。\n\n建模假设和基本依据：\n\n- 每个星系的表面亮度被建模为具有各向同性协方差的二维高斯分布。对于索引为 $i$ 的星系，其在给定波段的总通量为 $F_i$，内禀各向同性尺寸参数为 $s_i$（以任意像素单位计），其未卷积的（关于其自身质心的）二阶矩张量为 $$\\mathbf{S}_i = s_i^2 \\mathbf{I},$$ 其中 $\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵。PSF是高斯函数，其各向同性协方差为 $$\\mathbf{P} = \\sigma_{\\mathrm{psf}}^2 \\mathbf{I}.$$\n- 两个高斯函数的卷积结果是一个高斯函数，其协方差等于各协方差之和。因此，星系 $i$ 卷积后的二阶矩张量为 $$\\mathbf{Q}_i = \\mathbf{S}_i + \\mathbf{P}.$$\n- 在弱引力透镜机制下，对于较小的约化剪切 $(g_1, g_2)$ 和零汇聚，通过一阶线性化来近似二阶矩的映射。设 $$\\mathbf{G} = \\begin{pmatrix} g_1  g_2 \\\\ g_2  -g_1 \\end{pmatrix}, \\quad \\mathbf{A} = \\mathbf{I} + \\mathbf{G}.$$ 被剪切的二阶矩张量为 $$\\mathbf{Q}_i' = \\mathbf{A}\\,\\mathbf{Q}_i\\,\\mathbf{A}^\\top.$$\n- 混合光分布是两个高斯分量的线性叠加。设目标星系的质心为 $\\mathbf{x}_t = (0, 0)$，邻近星系的质心为 $\\mathbf{x}_n = (d, 0)$，即邻近星系沿x轴方向，相距为 $d$。在给定的 $B$ 波段，通量分别为 $F_{t,B}$ 和 $F_{n,B}$，通量加权的混合质心为 $$\\bar{\\mathbf{x}}_B = \\frac{F_{t,B}\\,\\mathbf{x}_t + F_{n,B}\\,\\mathbf{x}_n}{F_{t,B} + F_{n,B}}.$$ 关于 $\\bar{\\mathbf{x}}_B$ 的混合二阶矩张量是各分量二阶矩的通量加权和，再加上质心偏移的贡献，$$\\mathbf{M}_B = \\frac{F_{t,B}\\left(\\mathbf{Q}_t' + (\\mathbf{x}_t - \\bar{\\mathbf{x}}_B)(\\mathbf{x}_t - \\bar{\\mathbf{x}}_B)^\\top\\right) + F_{n,B}\\left(\\mathbf{Q}_n' + (\\mathbf{x}_n - \\bar{\\mathbf{x}}_B)(\\mathbf{x}_n - \\bar{\\mathbf{x}}_B)^\\top\\right)}{F_{t,B} + F_{n,B}}.$$\n- 使用标准的二阶矩椭率定义，根据混合二阶矩（在形状测量波段）定义椭率分量 $(e_1, e_2)$，其中分母中的迹用于归一化各向异性。对仅有目标星系的情况使用相同的定义，以获得在没有混合的情况下，受剪切影响的基准“真实”椭率。\n- 光度红移由两个波段 $r$ 和 $i$ 构建的单一颜色估计得出。设颜色为 $$C = -2.5\\,\\log_{10}\\left(\\frac{F_r}{F_i}\\right),$$ 使用这些波段的总混合通量，并估计 $$\\hat{z} = a\\,C + b,$$ 其中 $a$ 和 $b$ 是固定的校准参数。\n- 对于星系-星系透镜，测得的超表面密度 $\\Delta\\Sigma$ 与真实切向剪切和临界表面密度 $\\Sigma_{\\mathrm{crit}}$ 的乘积成比例。在平坦、低红移近似下，使用与红移成正比的角直径距离，即 $$D(z) \\propto z,$$ 因此 $$\\Sigma_{\\mathrm{crit}}(z_l, z_s) \\propto \\frac{D(z_s)}{D(z_l)\\left[D(z_s) - D(z_l)\\right]} = \\frac{z_s}{z_l\\,(z_s - z_l)}.$$ 由剪切校准和光度红移误差引起的 $\\Delta\\Sigma$ 的分数偏差为 $$\\delta_{\\Delta\\Sigma} = (1 + m)\\,\\frac{\\Sigma_{\\mathrm{crit}}(z_l, \\hat{z})}{\\Sigma_{\\mathrm{crit}}(z_l, z_t)} - 1,$$ 其中 $m$ 是下面定义的乘性剪切偏差，$z_l$ 是透镜红移，$z_t$ 是目标星系的真实源红移，$\\hat{z}$ 是根据混合颜色估计的光度红移。\n\n每个测试案例需要计算的量：\n\n1.  计算目标星系在形状波段 $i$ 中的二阶矩张量、其在剪切作用下的椭率 $(e_{1,\\mathrm{true}}, e_{2,\\mathrm{true}})$，以及使用 $i$ 波段通量计算的混合二阶矩张量和椭率 $(e_{1,\\mathrm{obs}}, e_{2,\\mathrm{obs}})$。\n2.  通过关系式 $$\\mathbf{e}_{\\mathrm{obs}} = (1 + m)\\,\\mathbf{e}_{\\mathrm{true}} + \\mathbf{c},$$ 定义乘性剪切偏差 $m$ 和加性剪切偏差向量 $\\mathbf{c} = (c_1, c_2)$，并计算它们。将 $m$ 视为使沿 $\\mathbf{e}_{\\mathrm{true}}$ 方向的残差平方最小化的标量（即 $$m = \\frac{\\mathbf{e}_{\\mathrm{obs}} \\cdot \\mathbf{e}_{\\mathrm{true}}}{\\mathbf{e}_{\\mathrm{true}} \\cdot \\mathbf{e}_{\\mathrm{true}}} - 1$$），且 $$\\mathbf{c} = \\mathbf{e}_{\\mathrm{obs}} - (1 + m)\\,\\mathbf{e}_{\\mathrm{true}}.$$\n3.  计算光度红移偏差 $$\\delta z = \\hat{z} - z_t,$$ 其中 $z_t$ 是目标星系的真实源红移，$\\hat{z}$ 是根据上述颜色定义得到的混合估计值。\n4.  在低红移近似下，使用简化的临界表面密度比例关系，计算星系-星系透镜中的分数偏差 $$\\delta_{\\Delta\\Sigma}$$。\n\n测试套件：\n\n使用以下四个测试案例，每个案例都按顺序指定为参数元组 $(s_t, s_n, F_{t,i}, F_{t,r}, F_{n,i}, F_{n,r}, d, \\sigma_{\\mathrm{psf}}, g_1, g_2, z_t, z_l, a, b)$:\n\n- 案例A（一般拥挤场混合）：$(\\,$$1.0$$, $$0.8$$, $$1.0$$, $$0.6$$, $$0.3$$, $$0.9$$, $$0.5$$, $$0.5$$, $$0.02$$, $$-0.01$$, $$0.7$$, $$0.3$$, $$-1.2$$, $$0.8$$)。\n- 案例B（几乎完全重叠）：$(\\,$$0.9$$, $$0.9$$, $$1.2$$, $$0.7$$, $$1.0$$, $$1.5$$, $$0.0$$, $$0.7$$, $$0.03$$, $$0.0$$, $$0.6$$, $$0.3$$, $$-1.2$$, $$0.8$$)。\n- 案例C（邻近星系遥远，混合效应极小）：$(\\,$$1.0$$, $$1.0$$, $$1.0$$, $$0.8$$, $$0.5$$, $$0.5$$, $$5.0$$, $$0.6$$, $$0.01$$, $$0.01$$, $$0.5$$, $$0.2$$, $$-1.2$$, $$0.8$$)。\n- 案例D（仅光度污染，i波段无形状混合）：$(\\,$$1.1$$, $$0.7$$, $$1.0$$, $$0.9$$, $$0.0$$, $$1.0$$, $$2.0$$, $$0.5$$, $$0.02$$, $$0.02$$, $$0.65$$, $$0.25$$, $$-1.2$$, $$0.8$$)。\n\n您的程序必须：\n\n- 使用双精度浮点运算，以数值稳定的方式实现上述建模和计算。\n- 对于每个测试案例，输出列表 $[m, c_1, c_2, \\delta z, \\delta_{\\Delta\\Sigma}]$。\n- 将所有四个测试案例的结果汇总到一行：一个用方括号括起来的逗号分隔列表，其中每个元素是上述的单个案例列表。例如，一个有效的输出格式是 $$[ [x_1, x_2, x_3, x_4, x_5], [y_1, y_2, y_3, y_4, y_5], [z_1, z_2, z_3, z_4, z_5], [w_1, w_2, w_3, w_4, w_5] ]$$。\n\n所有输出都是无量纲浮点数。最终答案中不需要物理单位或角度单位。您的实现必须是自包含的，并且不需要外部输入。使用的缩写词是点扩展函数（PSF）、星系-星系透镜（GGL）。", "solution": "该问题被评估为有效。它在科学上基于已建立的星系形状、透镜效应和混合模型，尽管经过了简化。该问题是良构的、自包含的，并为计算唯一解提供了所有必要的数据和定义。测试案例旨在探测参数空间中不同且具有物理意义的区域。\n\n解决方案通过系统地实现问题陈述中描述的正向模型链来进行。对于由参数元组 $(s_t, s_n, F_{t,i}, F_{t,r}, F_{n,i}, F_{n,r}, d, \\sigma_{\\mathrm{psf}}, g_1, g_2, z_t, z_l, a, b)$ 指定的每个测试案例，我们计算五个所要求的量：乘性剪切偏差 $m$、加性剪切偏差分量 $(c_1, c_2)$、光度红移偏差 $\\delta z$ 和分数星系-星系透镜偏差 $\\delta_{\\Delta\\Sigma}$。\n\n**1. 初步定义**\n我们定义基本的矩阵和向量。$2 \\times 2$ 单位矩阵是 $\\mathbf{I}$。弱引力透镜剪切由矩阵 $\\mathbf{G}$ 描述，相应的线性变换矩阵是 $\\mathbf{A}$：\n$$\n\\mathbf{G} = \\begin{pmatrix} g_1  g_2 \\\\ g_2  -g_1 \\end{pmatrix}, \\quad \\mathbf{A} = \\mathbf{I} + \\mathbf{G}\n$$\n目标星系和邻近星系的质心分别为 $\\mathbf{x}_t = (0, 0)^\\top$ 和 $\\mathbf{x}_n = (d, 0)^\\top$。\n\n**2. 内禀和剪切后的星系属性**\n目标星系（$t$）和邻近星系（$n$）的未卷积二阶矩张量为 $\\mathbf{S}_t = s_t^2 \\mathbf{I}$ 和 $\\mathbf{S}_n = s_n^2 \\mathbf{I}$。点扩展函数（PSF）由其二阶矩张量 $\\mathbf{P} = \\sigma_{\\mathrm{psf}}^2 \\mathbf{I}$ 建模。\n卷积后的（孤立观测的）二阶矩张量是内禀协方差与PSF协方差之和：\n$$\n\\mathbf{Q}_t = \\mathbf{S}_t + \\mathbf{P} = (s_t^2 + \\sigma_{\\mathrm{psf}}^2) \\mathbf{I} \\\\\n\\mathbf{Q}_n = \\mathbf{S}_n + \\mathbf{P} = (s_n^2 + \\sigma_{\\mathrm{psf}}^2) \\mathbf{I}\n$$\n然后，这些矩受到弱引力透镜剪切的变换。假设两个星系都在同一源平面上，并受到相同的剪切影响，它们被剪切后的二阶矩张量为：\n$$\n\\mathbf{Q}_t' = \\mathbf{A}\\,\\mathbf{Q}_t\\,\\mathbf{A}^\\top \\quad \\text{和} \\quad \\mathbf{Q}_n' = \\mathbf{A}\\,\\mathbf{Q}_n\\,\\mathbf{A}^\\top\n$$\n\n**3. 无混合时的“真实”椭率**\n基准或“真实”椭率 $\\mathbf{e}_{\\mathrm{true}} = (e_{1,\\mathrm{true}}, e_{2,\\mathrm{true}})$ 对应于单独为目标星系测量的、经过剪切和卷积后的形状。它使用标准二阶矩椭率定义从 $\\mathbf{Q}_t'$ 计算得出：\n$$\ne_{1,\\mathrm{true}} = \\frac{Q'_{t,11} - Q'_{t,22}}{\\mathrm{Tr}(\\mathbf{Q}_t')}, \\quad e_{2,\\mathrm{true}} = \\frac{2 Q'_{t,12}}{\\mathrm{Tr}(\\mathbf{Q}_t')}\n$$\n其中 $\\mathrm{Tr}(\\mathbf{Q}_t') = Q'_{t,11} + Q'_{t,22}$。\n\n**4. 混合属性与“观测”椭率**\n当两个星系混合时，总光分布是一个叠加。形状测量在 $i$ 波段进行。此波段的总通量为 $F_{\\mathrm{tot},i} = F_{t,i} + F_{n,i}$。混合天体的通量加权质心为：\n$$\n\\bar{\\mathbf{x}}_i = \\frac{F_{t,i}\\,\\mathbf{x}_t + F_{n,i}\\,\\mathbf{x}_n}{F_{\\mathrm{tot},i}} = \\left(\\frac{F_{n,i} d}{F_{t,i} + F_{n,i}}, 0\\right)^\\top\n$$\n混合二阶矩张量 $\\mathbf{M}_i$ 是围绕这个新质心，使用混合分量的平行轴定理计算的：\n$$\n\\mathbf{M}_i = \\frac{F_{t,i}\\left(\\mathbf{Q}_t' + (\\mathbf{x}_t - \\bar{\\mathbf{x}}_i)(\\mathbf{x}_t - \\bar{\\mathbf{x}}_i)^\\top\\right) + F_{n,i}\\left(\\mathbf{Q}_n' + (\\mathbf{x}_n - \\bar{\\mathbf{x}}_i)(\\mathbf{x}_n - \\bar{\\mathbf{x}}_i)^\\top\\right)}{F_{t,i} + F_{n,i}}\n$$\n混合天体的“观测”椭率 $\\mathbf{e}_{\\mathrm{obs}} = (e_{1,\\mathrm{obs}}, e_{2,\\mathrm{obs}})$ 从 $\\mathbf{M}_i$ 计算得出：\n$$\ne_{1,\\mathrm{obs}} = \\frac{M_{i,11} - M_{i,22}}{\\mathrm{Tr}(\\mathbf{M}_i)}, \\quad e_{2,\\mathrm{obs}} = \\frac{2 M_{i,12}}{\\mathrm{Tr}(\\mathbf{M}_i)}\n$$\n\n**5. 剪切校准偏差（$m$ 和 $c$）**\n乘性偏差 $m$ 和加性偏差 $\\mathbf{c}=(c_1, c_2)$ 通过将观测椭率建模为真实椭率的线性变换来定义：$\\mathbf{e}_{\\mathrm{obs}} = (1 + m)\\,\\mathbf{e}_{\\mathrm{true}} + \\mathbf{c}$。使用所提供的定义，我们计算：\n$$\nm = \\frac{\\mathbf{e}_{\\mathrm{obs}} \\cdot \\mathbf{e}_{\\mathrm{true}}}{\\mathbf{e}_{\\mathrm{true}} \\cdot \\mathbf{e}_{\\mathrm{true}}} - 1\n$$\n$$\n\\mathbf{c} = \\mathbf{e}_{\\mathrm{obs}} - (1 + m)\\,\\mathbf{e}_{\\mathrm{true}}\n$$\n\n**6. 光度红移偏差（$\\delta z$）**\n光度红移估计 $\\hat{z}$ 基于来自 $r$ 和 $i$ 波段总混合通量的颜色：$F_{\\mathrm{tot},r} = F_{t,r} + F_{n,r}$ 和 $F_{\\mathrm{tot},i} = F_{t,i} + F_{n,i}$。颜色 $C$ 和估计红移 $\\hat{z}$ 为：\n$$\nC = -2.5\\,\\log_{10}\\left(\\frac{F_{\\mathrm{tot},r}}{F_{\\mathrm{tot},i}}\\right)\n$$\n$$\n\\hat{z} = a\\,C + b\n$$\n光度红移偏差是估计红移与目标星系真实红移之差：\n$$\n\\delta z = \\hat{z} - z_t\n$$\n\n**7. 星系-星系透镜偏差（$\\delta_{\\Delta\\Sigma}$）**\n星系-星系透镜信号中的分数偏差 $\\delta_{\\Delta\\Sigma}$ 结合了剪切校准偏差 ($m$) 和光度红移偏差的影响。该偏差取决于在真实源红移 $z_t$ 和估计红移 $\\hat{z}$ 下评估的临界表面密度 $\\Sigma_{\\mathrm{crit}}$ 的比率。使用给定的低红移近似 $\\Sigma_{\\mathrm{crit}}(z_l, z_s) \\propto \\frac{z_s}{z_l\\,(z_s - z_l)}$，该比率为：\n$$\n\\frac{\\Sigma_{\\mathrm{crit}}(z_l, \\hat{z})}{\\Sigma_{\\mathrm{crit}}(z_l, z_t)} = \\frac{\\hat{z}}{z_l(\\hat{z} - z_l)} \\cdot \\frac{z_l(z_t - z_l)}{z_t} = \\frac{\\hat{z}(z_t - z_l)}{z_t(\\hat{z} - z_l)}\n$$\n最终的分数偏差为：\n$$\n\\delta_{\\Delta\\Sigma} = (1 + m)\\,\\frac{\\Sigma_{\\mathrm{crit}}(z_l, \\hat{z})}{\\Sigma_{\\mathrm{crit}}(z_l, z_t)} - 1 = (1 + m)\\,\\frac{\\hat{z}(z_t - z_l)}{z_t(\\hat{z} - z_l)} - 1\n$$\n对每个测试案例评估此公式以获得最终所需量。对于所有测试案例，该计算都是可行的，因为对于所有提供的输入，都有 $\\hat{z} > z_l$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and print results for all test cases.\n    \"\"\"\n    # Test cases parameters are provided in the following order:\n    # (s_t, s_n, F_ti, F_tr, F_ni, F_nr, d, sigma_psf, g1, g2, z_t, z_l, a, b)\n    test_cases = [\n        # Case A (general crowded-field blending)\n        (1.0, 0.8, 1.0, 0.6, 0.3, 0.9, 0.5, 0.5, 0.02, -0.01, 0.7, 0.3, -1.2, 0.8),\n        # Case B (near-complete overlap)\n        (0.9, 0.9, 1.2, 0.7, 1.0, 1.5, 0.0, 0.7, 0.03, 0.0, 0.6, 0.3, -1.2, 0.8),\n        # Case C (neighbor far away, minimal blending)\n        (1.0, 1.0, 1.0, 0.8, 0.5, 0.5, 5.0, 0.6, 0.01, 0.01, 0.5, 0.2, -1.2, 0.8),\n        # Case D (photometric contamination only, no shape blending in i)\n        (1.1, 0.7, 1.0, 0.9, 0.0, 1.0, 2.0, 0.5, 0.02, 0.02, 0.65, 0.25, -1.2, 0.8)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_biases_for_case(case)\n        # Format each number in the list to a consistent representation if needed,\n        # but Python's default float representation is fine.\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists in Python matches the required format.\n    # Using the suggested template's join method for robustness.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_biases_for_case(params):\n    \"\"\"\n    Computes all specified biases for a single test case.\n    \"\"\"\n    s_t, s_n, f_ti, f_tr, f_ni, f_nr, d, sigma_psf, g1, g2, z_t, z_l, a, b = params\n\n    # Use double-precision floating-point arithmetic (numpy default)\n    I = np.identity(2)\n    xt = np.array([0.0, 0.0])\n    xn = np.array([d, 0.0])\n\n    G = np.array([[g1, g2], [g2, -g1]])\n    A = I + G\n\n    # 1. Compute target-only properties and true ellipticity\n    Q_t = (s_t**2 + sigma_psf**2) * I\n    Q_t_prime = A @ Q_t @ A.T\n    \n    trace_qt = np.trace(Q_t_prime)\n    e1_true = (Q_t_prime[0, 0] - Q_t_prime[1, 1]) / trace_qt\n    e2_true = 2 * Q_t_prime[0, 1] / trace_qt\n    e_true = np.array([e1_true, e2_true])\n    \n    # 2. Compute blended properties and observed ellipticity\n    # Convolved, sheared second moments for neighbor\n    Q_n = (s_n**2 + sigma_psf**2) * I\n    Q_n_prime = A @ Q_n @ A.T\n\n    # Total flux in i-band for shape measurement\n    f_tot_i = f_ti + f_ni\n\n    if f_tot_i == 0.0:\n        # Avoid division by zero, though not expected for these test cases.\n        # If total flux is zero, the object is unobservable.\n        # Biases would be ill-defined. Return NaNs or handle as error.\n        # For this problem, we can assume f_tot_i > 0.\n        pass\n\n    # Blended centroid in i-band\n    x_bar_i = (f_ti * xt + f_ni * xn) / f_tot_i\n\n    # Parallel axis theorem terms (outer products)\n    xt_offset = xt - x_bar_i\n    xn_offset = xn - x_bar_i\n    v_t = np.outer(xt_offset, xt_offset)\n    v_n = np.outer(xn_offset, xn_offset)\n\n    # Blended second-moment tensor in i-band\n    M_i = (f_ti * (Q_t_prime + v_t) + f_ni * (Q_n_prime + v_n)) / f_tot_i\n\n    # Observed ellipticity from blended moments\n    trace_mi = np.trace(M_i)\n    e1_obs = (M_i[0, 0] - M_i[1, 1]) / trace_mi\n    e2_obs = 2 * M_i[0, 1] / trace_mi\n    e_obs = np.array([e1_obs, e2_obs])\n    \n    # 3. Compute shear calibration biases (m, c)\n    e_true_sq_norm = np.dot(e_true, e_true)\n    if e_true_sq_norm == 0.0:\n       # if g1=g2=0, e_true is zero, m is ill-defined.\n       # Problem constraints ensure g1,g2 are not both zero.\n       m = 0.0\n    else:\n       m = np.dot(e_obs, e_true) / e_true_sq_norm - 1.0\n\n    c = e_obs - (1 + m) * e_true\n    c1, c2 = c[0], c[1]\n\n    # 4. Compute photometric redshift bias (delta_z)\n    f_tot_r = f_tr + f_nr\n    if f_tot_i = 0 or f_tot_r = 0: # Physical fluxes must be positive\n        # Handle log of non-positive number. Not expected in test cases.\n        delta_z = np.nan\n    else:\n        color = -2.5 * np.log10(f_tot_r / f_tot_i)\n        z_hat = a * color + b\n        delta_z = z_hat - z_t\n\n    # 5. Compute GGL bias (delta_DeltaSigma)\n    if z_hat = z_l or z_t = z_l:\n        # Unphysical configuration or division by zero. Not in test cases.\n        delta_DeltaSigma = np.nan\n    else:\n        # Ratio of critical surface density scaling factors\n        sigma_crit_ratio = (z_hat * (z_t - z_l)) / (z_t * (z_hat - z_l))\n        delta_DeltaSigma = (1 + m) * sigma_crit_ratio - 1.0\n        \n    return [m, c1, c2, delta_z, delta_DeltaSigma]\n\nsolve()\n```", "id": "3512765"}]}