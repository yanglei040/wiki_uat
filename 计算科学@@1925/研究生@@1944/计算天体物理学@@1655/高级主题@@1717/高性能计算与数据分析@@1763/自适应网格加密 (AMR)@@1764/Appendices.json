{"hands_on_practices": [{"introduction": "自适应网格加密（AMR）的核心在于其“自适应”能力，即能够识别并仅在需要更高分辨率的区域加密网格。这个决策过程需要一个可靠的误差估计器来量化局部截断误差。本练习将通过理查森外推法（Richardson extrapolation）推导出一个关键的误差估计器[@problem_id:3503443]，它通过比较粗网格和细网格上的解来工作，为我们理解AMR如何智能地分配计算资源提供了理论基础。", "problem": "考虑一个一维空间中的标量双曲守恒律，其写为在控制体上的积分形式，并用一个形式精度阶为 $p \\geq 1$ 的有限体积格式进行离散。在自适应网格加密（AMR）中——其中自适应网格加密（AMR）指具有整数加密比的动态、分层网格加密——一种常见的做法是通过比较嵌套网格上的解来估计局部截断误差，从而驱动加密决策。\n\n设一个均匀粗网格的网格间距为 $h$，嵌套于其中的一个细网格的网格间距为 $h/r$，其中整数加密比 $r > 1$。用 $u$ 表示在给定单元覆盖范围上的精确单元平均解，用 $u_h$ 表示在粗网格上计算并限制在共同覆盖范围上的数值单元平均解，用 $u_{h/r}$ 表示在细网格上计算并作类似限制的数值单元平均解。假设存在如下的渐近误差展开式\n$$\nu_h = u + C h^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right), \\qquad\nu_{h/r} = u + C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right),\n$$\n其中 $C$ 是一个光滑系数，它不依赖于 $h$ 或 $r$，但可能依赖于位置、时间和解的光滑性。\n\n仅使用这些渐近展开式和形式精度阶的定义，为给定位置的细网格解 $u_{h/r}$ 定义一个基于理查森外推的截断误差估计器，该估计器仅用 $u_h$、$u_{h/r}$、$r$ 和 $p$ 表示。推导在 $h \\to 0$ 且 $r$ 固定的渐近区域中，该估计器如何随加密比 $r$ 和形式精度阶 $p$ 缩放。你的最终答案必须是该估计器的单个闭式解析表达式。不需要进行数值计算。", "solution": "光滑解的有限体积离散允许一个包含形式精度阶信息的渐近误差展开。形式精度阶 $p$ 的定义是，主离散误差的缩放行为与 $h^{p}$ 一致，因此在网格尺寸为 $h$ 上的数值解满足\n$$\nu_h = u + C h^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right),\n$$\n其中系数 $C$ 不依赖于 $h$，并且对于固定的加密比 $r$，也不依赖于 $r$。在间距为 $h/r$ 的加密网格上，类似的展开式为\n$$\nu_{h/r} = u + C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n将两个展开式相减可以消去未知的精确解 $u$，并分离出对 $h$、$r$ 和 $p$ 的主阶依赖关系：\n$$\nu_h - u_{h/r} = \\left[u + C h^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right)\\right] - \\left[u + C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right)\\right].\n$$\n因此，\n$$\nu_h - u_{h/r} = C h^{p} - C h^{p} r^{-p} + \\mathcal{O}\\!\\left(h^{p+1}\\right) = C h^{p} \\left(1 - r^{-p}\\right) + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n我们关心的细网格解的截断误差是细网格上的主阶离散误差，\n$$\ne_{h/r} \\equiv u - u_{h/r} = -\\,C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n我们可以利用这两个关系式消去未知的 $C h^{p}$。从差值表达式中，\n$$\nC h^{p} = \\frac{u_h - u_{h/r}}{1 - r^{-p}} + \\mathcal{O}\\!\\left(h\\right),\n$$\n将其代入细网格误差表达式，得到\n$$\ne_{h/r} = -\\,\\left(\\frac{h}{r}\\right)^{p} \\frac{u_h - u_{h/r}}{h^{p}\\left(1 - r^{-p}\\right)} + \\mathcal{O}\\!\\left(h^{p+1}\\right)\n= -\\,\\frac{r^{-p}}{1 - r^{-p}}\\left(u_h - u_{h/r}\\right) + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n注意到以下关系，可以更清晰地写出乘法因子\n$$\n\\frac{r^{-p}}{1 - r^{-p}} = \\frac{1}{r^{p} - 1}.\n$$\n因此，细网格解的主阶截断误差为\n$$\ne_{h/r} = \\frac{u_h - u_{h/r}}{r^{p} - 1} + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n这导出了一个基于理查森外推的截断误差估计器，它使用粗细网格解之差，\n$$\n\\widehat{e}_{h/r} \\equiv \\frac{u_h - u_{h/r}}{r^{p} - 1}.\n$$\n它随加密比 $r$ 和精度阶 $p$ 的缩放关系可直接得出：原始的粗细网格解之差 $u_h - u_{h/r}$ 的缩放行为类似于 $h^{p}\\left(1 - r^{-p}\\right)$，而该估计器除以了 $r^{p} - 1$，得到的主阶依赖关系为 $\\widehat{e}_{h/r} \\sim C h^{p} r^{-p}$，即相对于粗网格误差，细网格截断误差的衰减与 $r^{-p}$ 成正比，这与 $p$ 阶精度是一致的。在 $h \\to 0$ 且 $r$ 固定的渐近区域中，高阶项 $\\mathcal{O}\\!\\left(h^{p+1}\\right)$ 消失，该估计器收敛到真实的主阶截断误差：\n$$\n\\widehat{e}_{h/r} \\to e_{h/r} \\quad \\text{as} \\quad h \\to 0.\n$$\n因此，所要求的仅用 $u_h$、$u_{h/r}$、$r$ 和 $p$ 表示的闭式估计器为\n$$\n\\widehat{e}_{h/r} = \\frac{u_h - u_{h/r}}{r^{p} - 1}.\n$$", "answer": "$$\\boxed{\\frac{u_h - u_{h/r}}{r^{p} - 1}}$$", "id": "3503443"}, {"introduction": "当一个区域被标记需要加密后，下一步是从粗网格数据生成新的细网格上的初始数据，这个过程称为“延拓”（prolongation）。为了在保持守恒的同时避免在激波或接触间断等特征附近产生伪振荡，我们必须使用复杂的技术。本实践练习[@problem_id:3503480]将指导您通过编程实现一个包含斜率限制器和边界保持裁剪的分段线性重构方法，这是确保AMR模拟既准确又稳定的关键一步。", "problem": "考虑在计算天体物理学背景下，带有接触间断的可压缩流的一维有限体积密度表示。自适应网格加密（AMR）旨在从粗网格单元平均值构造细网格初始数据，同时保持守恒并避免伪极值。其基本原理是单元平均值的有限体积定义和带有斜率限制器的总变差减小（TVD）重构。\n\n设粗网格为均匀网格，单元中心位于 $x_i$，宽度为 $\\Delta x$。粗网格单元平均密度为 $\\bar{\\rho}_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho(x)\\,dx$。对于加密过程，每个粗单元 $i$ 被细分为 $r$ 个细子单元，索引为 $j \\in \\{0,1,\\dots,r-1\\}$，每个子单元的宽度为 $\\Delta x / r$。在每个粗单元 $i$ 内使用分段线性重构，\n$$\n\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x},\n$$\n其中 $s_i$ 是根据相邻粗网格平均值计算的限制斜率，以强制执行 TVD 属性。定义后向和前向差分\n$$\n\\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1}, \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i,\n$$\n以及以下斜率限制器：\n- Minmod 限制器：$\\mathrm{mm}(a,b) = \\begin{cases}\\mathrm{sign}(a)\\min(|a|,|b|),  ab > 0, \\\\ 0,  \\text{otherwise.}\\end{cases}$，使用 $s_i = \\mathrm{mm}(\\Delta_-,\\Delta_+)$。\n- 单调中心（MC）限制器：$s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)$，其中，如果 $a,b,c$ 符号全部相同，$\\mathrm{mm}_3(a,b,c)$ 返回 $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$，否则返回 $0$。\n- Van Leer 限制器：$s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+},  \\Delta_- \\Delta_+ > 0, \\\\ 0,  \\text{otherwise.}\\end{cases}$。\n\n在区域边界，当邻近单元不可用时，设置 $s_i = 0$ 以保持守恒。粗单元 $i$ 内子单元 $j$ 的子单元平均密度为\n$$\n\\bar{\\rho}_{i,j} = \\frac{r}{\\Delta x}\\int_{x_{i-1/2} + \\frac{j}{r}\\Delta x}^{x_{i-1/2} + \\frac{j+1}{r}\\Delta x} \\rho_i(x)\\,dx.\n$$\n对于上述分段线性的 $\\rho_i(x)$，子单元平均值等于子单元中点处的值，从而得到\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j,\\quad c_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right).\n$$\n为避免在接触间断处产生伪极值，对每个粗单元 $i$ 施加一个保界裁剪，其局部界限为\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\\quad \\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\n$$\n在边界处仅使用可用的邻近单元。强制执行\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right).\n$$\n\n实现一个程序，该程序：\n1. 根据指定的限制器计算限制斜率 $s_i$。\n2. 使用上述公式，根据给定的加密比 $r$ 计算细网格子单元平均值 $\\bar{\\rho}_{i,j}$。\n3. 对每个粗单元应用保界裁剪。\n4. 将每个测试用例的加密后子单元平均值输出为浮点数列表。\n\n所有密度均采用无量纲代码单位；无需进行物理单位转换。不涉及角度。程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个由方括号括起来的逗号分隔列表，表示相应测试用例的加密后单元平均密度，且不含空格。例如：`[[a_1,a_2,...],[b_1,b_2,...]]`。\n\n使用以下测试套件，其设计旨在覆盖平滑行为、尖锐接触间断、振荡模式和边界效应：\n- 测试 $1$（平滑单调递增，Minmod，$r=2$）：粗网格平均值 $\\left[\\,1.0,\\,1.1,\\,1.2,\\,1.3\\,\\right]$。\n- 测试 $2$（接触间断，MC，$r=2$）：粗网格平均值 $\\left[\\,1.0,\\,1.0,\\,5.0,\\,5.0\\,\\right]$。\n- 测试 $3$（振荡模式，Van Leer，$r=4$）：粗网格平均值 $\\left[\\,3.0,\\,1.0,\\,3.0,\\,1.0\\,\\right]$。\n- 测试 $4$（对称邻居下的孤立跳跃，Minmod，$r=2$）：粗网格平均值 $\\left[\\,0.5,\\,0.5,\\,2.0,\\,0.5,\\,0.5\\,\\right]$。\n\n对于每个测试用例，输出应为展平的细网格列表 $\\left[\\,\\bar{\\rho}_{0,0},\\dots,\\bar{\\rho}_{0,r-1},\\bar{\\rho}_{1,0},\\dots,\\bar{\\rho}_{1,r-1},\\dots\\,\\right]$，并遵循指定格式。最终输出必须是单行形式 $[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list}, \\text{case4\\_list} ]$，且不含任何空格。", "solution": "问题陈述经评估有效。它提出了一个定义明确的计算任务，该任务基于流体动力学数值方法的既定原则，特别是关于自适应网格加密（AMR）。提供的分段线性重构、斜率限制器和子单元平均化公式是标准且正确的。该问题是自洽的，指定了所有必要的数据和边界条件，从而使每个测试用例都能得到唯一的解。\n\n将粗网格单元平均密度 $\\bar{\\rho}_i$ 加密到加密比为 $r$ 的细网格上的过程包括三个主要步骤：斜率计算、子单元平均值计算和保界裁剪。\n\n### 1. 限制斜率计算\n对于每个粗单元 $i$，计算一个斜率 $s_i$ 来定义一个分段线性重构，$\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x}$，其中 $x_i$ 是单元 $i$ 的中心，$\\Delta x$ 是其宽度。为了防止在尖锐特征附近引入伪振荡（这一特性被称为总变差减小或 TVD），斜率 $s_i$ 会根据局部数据进行限制。\n\n计算取决于单元的位置：\n-   **边界单元**：对于域中的第一个（$i=0$）和最后一个（$i=N-1$）单元，无法获得完整的邻近单元集。为保持守恒和简化处理，斜率设为零，即 $s_0 = 0$ 和 $s_{N-1} = 0$。这对应于边界处的分段常数重构。\n-   **内部单元**：对于任何内部单元 $i$，斜率由其直接邻居确定。我们首先计算后向和前向差分：\n    $$\n    \\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1} \\quad ; \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i\n    $$\n    然后将这些差分传递给斜率限制器函数。问题指定了三种此类限制器：\n\n    1.  **Minmod 限制器**：这是耗散性最强的限制器，它能强烈抑制振荡。斜率由下式给出：\n        $$\n        s_i = \\mathrm{mm}(\\Delta_-, \\Delta_+) = \\begin{cases}\\mathrm{sign}(\\Delta_-)\\min(|\\Delta_-|,|\\Delta_+|),  \\Delta_- \\Delta_+ > 0 \\\\ 0,  \\text{otherwise}\\end{cases}\n        $$\n        只有当数据在局部是单调的（即 $\\Delta_-$ 和 $\\Delta_+$ 符号相同），斜率才非零。在局部极值点，斜率为零。\n\n    2.  **单调中心（MC）限制器**：该限制器设计用于在平滑区域比 Minmod 更精确。它使用一个三参数的 minmod 函数定义：\n        $$\n        s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)\n        $$\n        其中，如果 $a, b, c$ 符号全部相同，$\\mathrm{mm}_3(a,b,c)$ 返回 $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$，否则返回 $0$。该限制器考虑中心差分斜率 $(\\Delta_- + \\Delta_+)/2$，并用两倍的单边差分来限制它。\n\n    3.  **Van Leer 限制器**：该限制器在单边差分之间提供平滑过渡，并以能为接触间断提供良好分辨率而闻名。它是两个差分的调和平均数：\n        $$\n        s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+},  \\Delta_- \\Delta_+ > 0 \\\\ 0,  \\text{otherwise}\\end{cases}\n        $$\n\n### 2. 子单元平均值加密\n一旦每个粗单元 $i$ 的斜率 $s_i$ 已知，我们就可以确定其中每个（共 $r$ 个）子单元的平均密度 $\\bar{\\rho}_{i,j}$。一个子单元的索引为 $j \\in \\{0, 1, \\dots, r-1\\}$。线性函数在区间上的平均值等于该函数在区间中点处的值。这将积分定义简化为代数定义。粗单元 $i$ 中子单元 $j$ 的中点与粗单元中心 $x_i$ 之间存在一个距离因子的偏移。这引出了以下公式：\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j\n$$\n其中系数 $c_j$ 仅取决于子单元索引 $j$ 和加密比 $r$：\n$$\nc_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right)\n$$\n这些系数代表每个子单元中心与其父单元中心的归一化距离。例如，对于 $r=2$，我们有 $c_0 = -0.25$ 和 $c_1 = 0.25$。\n\n### 3. 保界裁剪\nTVD 斜率限制器旨在防止在单元界面上重构的点值产生新的极值。然而，为严格确保新的*单元平均值*也不会产生新的局部极值，需要应用一个额外的裁剪步骤。对于每个粗单元 $i$，我们根据其单元平均值本身及其可用的邻近单元定义局部界限：\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n$$\n\\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n对于边界单元 $i=0$，邻域为 $\\{0, 1\\}$。对于内部单元，邻域为 $\\{i-1, i, i+1\\}$。\n\n然后，每个计算出的子单元平均值 $\\bar{\\rho}_{i,j}$ 都被强制约束在这些界限内：\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right)\n$$\n这确保了加密后的数据场在局部上仍受原始粗糙数据的约束，这对于稳定性以及物理真实性至关重要，尤其是在接触间断处。\n\n### 示例演练：测试用例 1\n-   **输入**：粗网格平均值 $\\bar{\\rho} = [1.0, 1.1, 1.2, 1.3]$，限制器：Minmod，$r=2$。\n-   **斜率**：\n    -   $s_0 = 0$（边界）。\n    -   $i=1$：$\\Delta_- = 1.1-1.0=0.1$, $\\Delta_+ = 1.2-1.1=0.1$。$\\mathrm{mm}(0.1, 0.1) = 0.1$。因此，$s_1=0.1$。\n    -   $i=2$：$\\Delta_- = 1.2-1.1=0.1$, $\\Delta_+ = 1.3-1.2=0.1$。$\\mathrm{mm}(0.1, 0.1) = 0.1$。因此，$s_2=0.1$。\n    -   $s_3 = 0$（边界）。\n    -   斜率向量为 $s = [0, 0.1, 0.1, 0]$。\n-   **子单元平均值（$r=2 \\implies c_0=-0.25, c_1=0.25$）**：\n    -   $i=0$：$\\bar{\\rho}_{0,0} = 1.0 + 0 \\cdot (-0.25) = 1.0$；$\\bar{\\rho}_{0,1} = 1.0 + 0 \\cdot (0.25) = 1.0$。\n    -   $i=1$：$\\bar{\\rho}_{1,0} = 1.1 + 0.1 \\cdot (-0.25) = 1.075$；$\\bar{\\rho}_{1,1} = 1.1 + 0.1 \\cdot (0.25) = 1.125$。\n    -   $i=2$：$\\bar{\\rho}_{2,0} = 1.2 + 0.1 \\cdot (-0.25) = 1.175$；$\\bar{\\rho}_{2,1} = 1.2 + 0.1 \\cdot (0.25) = 1.225$。\n    -   $i=3$：$\\bar{\\rho}_{3,0} = 1.3 + 0 \\cdot (-0.25) = 1.3$；$\\bar{\\rho}_{3,1} = 1.3 + 0 \\cdot (0.25) = 1.3$。\n-   **裁剪**：\n    -   $i=0$：界限为 $[\\min(1.0, 1.1), \\max(1.0, 1.1)] = [1.0, 1.1]$。值 $[1.0, 1.0]$ 在界限内。\n    -   $i=1$：界限为 $[\\min(1.0, 1.1, 1.2), \\max(1.0, 1.1, 1.2)] = [1.0, 1.2]$。值 $[1.075, 1.125]$ 在界限内。\n    -   $i=2$：界限为 $[\\min(1.1, 1.2, 1.3), \\max(1.1, 1.2, 1.3)] = [1.1, 1.3]$。值 $[1.175, 1.225]$ 在界限内。\n    -   $i=3$：界限为 $[\\min(1.2, 1.3), \\max(1.2, 1.3)] = [1.2, 1.3]$。值 $[1.3, 1.3]$ 在界限内。\n    -   在此情况下，裁剪步骤不会改变任何值，因为 Minmod 限制器已确保重构是非振荡的。\n-   **最终结果**：展平后的细单元平均值列表为 $[1.0, 1.0, 1.075, 1.125, 1.175, 1.225, 1.3, 1.3]$。", "answer": "```python\nimport numpy as np\n\ndef minmod_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Minmod limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        return np.sign(delta_minus) * min(abs(delta_minus), abs(delta_plus))\n    return 0.0\n\ndef mm3(a, b, c):\n    \"\"\"Generalized minmod function for three arguments.\"\"\"\n    sa, sb, sc = np.sign(a), np.sign(b), np.sign(c)\n    if sa == sb and sa == sc:\n        return sa * min(abs(a), abs(b), abs(c))\n    return 0.0\n\ndef mc_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Monotonized Central (MC) limited slope.\"\"\"\n    return mm3((delta_minus + delta_plus) / 2.0, 2.0 * delta_minus, 2.0 * delta_plus)\n\ndef van_leer_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Van Leer limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        # The check for d- * d+ > 0 prevents division by zero,\n        # as d- + d+ could only be zero if both were zero.\n        return (2.0 * delta_minus * delta_plus) / (delta_minus + delta_plus)\n    return 0.0\n\ndef process_case(coarse_rho, limiter_name, r):\n    \"\"\"\n    Performs AMR prolongation for a given set of coarse cell averages.\n\n    Args:\n        coarse_rho (list[float]): The coarse-level cell averages.\n        limiter_name (str): The name of the slope limiter to use ('Minmod', 'MC', 'Van Leer').\n        r (int): The refinement ratio.\n\n    Returns:\n        list[float]: The flattened list of fine-level cell averages after clipping.\n    \"\"\"\n    limiter_funcs = {\n        'Minmod': minmod_limiter,\n        'MC': mc_limiter,\n        'Van Leer': van_leer_limiter\n    }\n    \n    n_coarse = len(coarse_rho)\n    slopes = np.zeros(n_coarse)\n    limiter_func = limiter_funcs[limiter_name]\n\n    # 1. Compute limited slopes for interior cells\n    for i in range(1, n_coarse - 1):\n        delta_minus = coarse_rho[i] - coarse_rho[i-1]\n        delta_plus = coarse_rho[i+1] - coarse_rho[i]\n        slopes[i] = limiter_func(delta_minus, delta_plus)\n    # Slopes at boundaries (i=0, i=n_coarse-1) remain 0\n\n    # 2. Compute fine-level subcell averages with bound-preserving clipping\n    c_j_coeffs = (np.arange(r, dtype=float) + 0.5) / r - 0.5\n    fine_rho = []\n    \n    for i in range(n_coarse):\n        # Determine local bounds from available neighbors\n        neighbors = [coarse_rho[i]]\n        if i > 0:\n            neighbors.append(coarse_rho[i-1])\n        if i  n_coarse - 1:\n            neighbors.append(coarse_rho[i+1])\n        \n        rho_min_i = min(neighbors)\n        rho_max_i = max(neighbors)\n\n        # Compute, clip, and store subcell values\n        for j in range(r):\n            # Calculate value from piecewise linear reconstruction\n            val = coarse_rho[i] + slopes[i] * c_j_coeffs[j]\n            # Apply bound-preserving clipping\n            clipped_val = min(rho_max_i, max(rho_min_i, val))\n            fine_rho.append(clipped_val)\n            \n    return fine_rho\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        {'coarse_rho': [1.0, 1.1, 1.2, 1.3], 'limiter': 'Minmod', 'r': 2},\n        {'coarse_rho': [1.0, 1.0, 5.0, 5.0], 'limiter': 'MC', 'r': 2},\n        {'coarse_rho': [3.0, 1.0, 3.0, 1.0], 'limiter': 'Van Leer', 'r': 4},\n        {'coarse_rho': [0.5, 0.5, 2.0, 0.5, 0.5], 'limiter': 'Minmod', 'r': 2},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        result = process_case(case['coarse_rho'], case['limiter'], case['r'])\n        # Format the list of floats into a string \"[f1,f2,...]\"\n        result_str = '[' + ','.join(map(str, result)) + ']'\n        all_results_str.append(result_str)\n\n    # Combine all case strings into the final output format \"[[...],[...],...]\"\n    # with no spaces.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3503480"}, {"introduction": "在AMR中管理多层级网格演化带来了独特的时间步进挑战，因为更精细的网格出于稳定性（CFL条件）的考虑需要更小的时间步。为了高效地进行模拟，我们采用一种称为“子循环”（subcycling）的策略，即细网格在每个粗网格时间步内执行多个子步骤。本练习[@problem_id:3503472]提供了一个具体的计算场景，用于确定各级网格允许的最大时间步和同步方案，这是实现高效稳定AMR模拟的基本实践。", "problem": "考虑一个用于计算天体物理学模拟中双曲守恒律的一维显式有限体积求解器，该模拟采用自适应网格加密（AMR）。网格层级结构包括三个层次：一个粗网格层 $\\ell = 0$；一个相对于 $\\ell = 0$ 层加密因子为 $r_{1} = 3$ 的较细网格层 $\\ell = 1$；以及一个相对于 $\\ell = 1$ 层加密因子为 $r_{2} = 2$ 的最细网格层 $\\ell = 2$。粗网格层的空间步长为 $\\Delta x_{0} = 9.6 \\times 10^{9}$ 米，因此 $\\Delta x_{1} = \\Delta x_{0}/r_{1}$ 且 $\\Delta x_{2} = \\Delta x_{1}/r_{2}$。在每一层上解析的最大特征速度（通量雅可比矩阵特征值的最大绝对值）分别为：在 $\\ell = 0$ 层上为 $a_{0} = 2.0 \\times 10^{7}$ 米/秒，在 $\\ell = 1$ 层上为 $a_{1} = 3.3 \\times 10^{7}$ 米/秒，在 $\\ell = 2$ 层上为 $a_{2} = 4.0 \\times 10^{7}$ 米/秒。Courant–Friedrichs–Lewy (CFL) 数为 $C_{\\mathrm{CFL}} = 0.45$。\n\n使用适用于双曲型系统显式有限体积离散化的 Courant–Friedrichs–Lewy 稳定性要求，首先计算每个 AMR 层上允许的时间步长，记为 $\\Delta t_{\\ell}^{\\max}$，其中 $\\ell \\in \\{0,1,2\\}$。然后，假设粗网格层前进一个长度为 $\\Delta t_{0} = \\Delta t_{0}^{\\max}$ 的时间步。通过选择整数 $n_{1}$ 和 $n_{2}$ 在较细层级上实现层级同步的子循环，使得在粗网格层单步推进过程中，$\\ell = 1$ 层进行 $n_{1}$ 个子步，$\\ell = 2$ 层进行 $n_{2}$ 个子步，且满足 $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$ 和 $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$，同时 $n_{2}$ 是 $n_{1}$ 的正整数倍以确保嵌套同步。在所有允许的选择中，选取满足这些约束的最小 $n_{1}$ 和最小倍数 $n_{2}$。\n\n将在区间 $[0,\\Delta t_{0}]$ 内的同步时间定义为所有更细层级同时完成了整数个子步，从而可以与其父层级进行通量校正的时刻集合；在上述 $n_{2}$ 是 $n_{1}$ 的倍数的约束下，这些时刻即为 $\\ell = 1$ 层的子步边界。列出这些时间，包括粗网格层步长的开始和结束。所有时间量均以秒表示。\n\n在最终答案中，按顺序以单行的形式提供三元组 $\\left(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}\\right)$、实际的子循环时间步长 $\\left(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}\\right)$ 以及一个粗网格层步长内的有序同步时间 $\\left(t_{0}, t_{1}, t_{2}, t_{3}, t_{4}, t_{5}\\right)$。无需四舍五入。", "solution": "用户提供了一个计算天体物理学中的问题，涉及自适应网格加密（AMR）模拟中的时间步进。该问题要求基于 Courant-Friedrichs-Lewy (CFL) 稳定性条件计算时间步长，并确定子循环参数和同步时间。\n\n首先根据所需标准对问题进行验证。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- AMR 层级：$\\ell \\in \\{0, 1, 2\\}$。\n- 从 $\\ell=0$ 层到 $\\ell=1$ 层的加密因子：$r_{1} = 3$。\n- 从 $\\ell=1$ 层到 $\\ell=2$ 层的加密因子：$r_{2} = 2$。\n- 粗网格层空间步长：$\\Delta x_{0} = 9.6 \\times 10^{9}$ 米。\n- 空间步长关系：$\\Delta x_{1} = \\Delta x_{0}/r_{1}$ 且 $\\Delta x_{2} = \\Delta x_{1}/r_{2}$。\n- 各层最大特征速度：$a_{0} = 2.0 \\times 10^{7}$ 米/秒, $a_{1} = 3.3 \\times 10^{7}$ 米/秒, $a_{2} = 4.0 \\times 10^{7}$ 米/秒。\n- Courant-Friedrichs-Lewy (CFL) 数：$C_{\\mathrm{CFL}} = 0.45$。\n- 用于推进的粗网格层时间步长：$\\Delta t_{0} = \\Delta t_{0}^{\\max}$。\n- 子循环约束：\n  - $\\ell=1$ 层进行 $n_{1}$ 个子步，其中 $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$。\n  - $\\ell=2$ 层进行 $n_{2}$ 个子步，其中 $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$。\n- 同步约束：$n_{2}$ 是 $n_{1}$ 的正整数倍。\n- 最小性约束：$n_{1}$ 是满足其约束的最小整数，而 $n_{2}$ 是满足其约束的 $n_{1}$ 的最小倍数。\n- 同步时间：在粗网格层步长区间 $[0, \\Delta t_{0}]$ 内的 $\\ell=1$ 层子步的边界。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学基础**：该问题基于CFL条件，这是双曲型方程显式数值方法稳定性的基本原理。带子循环的AMR是计算流体动力学和天体物理学中一种标准的、科学上有效的技术。该问题牢固地植根于成熟的数值分析理论。\n- **适定性**：所有必需的参数（$\\Delta x_0$, $r_1$, $r_2$, $a_\\ell$, $C_{\\mathrm{CFL}}$）均已提供。对子循环整数（$n_1, n_2$）的约束定义清晰，并能导出一个唯一的最小解。该问题是自洽的，并且在数学上是适定的。\n- **客观性**：该问题使用精确、无歧义的数学术语和物理量进行表述，不含主观性语言。\n\n**第3步：结论与行动**\n该问题是有效的，因为它科学上合理、适定且客观。将提供完整的解答。\n\n### 解答\n\n解答过程分为几个步骤：\n1.  计算每一层 $\\ell$ 的空间步长 $\\Delta x_{\\ell}$。\n2.  使用CFL条件计算每一层的最大允许时间步长 $\\Delta t_{\\ell}^{\\max}$。\n3.  确定满足给定约束的整数子循环次数 $n_{1}$ 和 $n_{2}$。\n4.  计算用于子循环推进的实际时间步长 $\\Delta t_{\\ell}$。\n5.  列出一个粗网格层步长内的同步时间。\n\n**1. 空间步长**\n较细层的空间步长由给定的加密因子确定。\n- $\\ell=0$ 层：$\\Delta x_{0} = 9.6 \\times 10^{9} \\, \\text{m}$。\n- $\\ell=1$ 层：$\\Delta x_{1} = \\frac{\\Delta x_{0}}{r_{1}} = \\frac{9.6 \\times 10^{9}}{3} = 3.2 \\times 10^{9} \\, \\text{m}$。\n- $\\ell=2$ 层：$\\Delta x_{2} = \\frac{\\Delta x_{1}}{r_{2}} = \\frac{3.2 \\times 10^{9}}{2} = 1.6 \\times 10^{9} \\, \\text{m}$。\n\n**2. 最大允许时间步长**\n对于一维显式有限体积格式，CFL条件规定，为保证稳定性，时间步长 $\\Delta t$ 必须满足 $\\Delta t \\le C_{\\mathrm{CFL}} \\frac{\\Delta x}{a}$，其中 $a$ 是最大特征速度。因此，$\\ell$ 层的最大允许时间步长为 $\\Delta t_{\\ell}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{\\ell}}{a_{\\ell}}$。\n\n- $\\ell=0$ 层：\n$$ \\Delta t_{0}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{0}}{a_{0}} = 0.45 \\times \\frac{9.6 \\times 10^{9} \\, \\text{m}}{2.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (4.8 \\times 10^{2} \\, \\text{s}) = 216 \\, \\text{s} $$\n- $\\ell=1$ 层：\n$$ \\Delta t_{1}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{1}}{a_{1}} = 0.45 \\times \\frac{3.2 \\times 10^{9} \\, \\text{m}}{3.3 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times \\frac{3.2}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{1.44}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{144}{3.3} \\, \\text{s} = \\frac{1440}{33} \\, \\text{s} = \\frac{480}{11} \\, \\text{s} $$\n- $\\ell=2$ 层：\n$$ \\Delta t_{2}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{2}}{a_{2}} = 0.45 \\times \\frac{1.6 \\times 10^{9} \\, \\text{m}}{4.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (0.4 \\times 10^{2} \\, \\text{s}) = 18 \\, \\text{s} $$\n第一组要求的值是 $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$。\n\n**3. 子循环整数**\n粗网格层以大小为 $\\Delta t_{0} = \\Delta t_{0}^{\\max} = 216 \\, \\text{s}$ 的步长推进。\n对于 $\\ell=1$ 层，子步数 $n_{1}$ 必须满足 $\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} \\le \\Delta t_{1}^{\\max}$。这意味着：\n$$ n_{1} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{1}^{\\max}} = \\frac{216}{\\frac{480}{11}} = \\frac{216 \\times 11}{480} = \\frac{9 \\times 24 \\times 11}{20 \\times 24} = \\frac{99}{20} = 4.95 $$\n因为 $n_{1}$ 必须是整数，所以 $n_{1}$ 的最小值为 $\\lceil 4.95 \\rceil = 5$。\n\n对于 $\\ell=2$ 层，子步数 $n_{2}$ 必须满足 $\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} \\le \\Delta t_{2}^{\\max}$。这意味着：\n$$ n_{2} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{2}^{\\max}} = \\frac{216}{18} = 12 $$\n此外，$n_{2}$ 必须是 $n_{1}=5$ 的正整数倍。我们必须找到大于或等于12的最小的5的倍数。5的相关倍数有 $5, 10, 15, \\dots$。其中最小的倍数是 $15$。\n因此，选定的子循环整数为 $n_{1} = 5$ 和 $n_{2} = 15$。\n\n**4. 实际子循环时间步长**\n每一层的实际时间步长根据子循环整数计算。\n- $\\ell=0$ 层：$\\Delta t_{0} = 216 \\, \\text{s}$。\n- $\\ell=1$ 层：$\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} = \\frac{216}{5} = 43.2 \\, \\text{s}$。\n- $\\ell=2$ 层：$\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} = \\frac{216}{15} = \\frac{72}{5} = 14.4 \\, \\text{s}$。\n第二组要求的值是 $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$。\n\n**5. 同步时间**\n同步时间是 $\\ell=1$ 层子步的边界。由于 $\\ell=1$ 层进行 $n_{1}=5$ 个子步，每个子步持续时间为 $\\Delta t_{1} = 43.2 \\, \\text{s}$，因此同步时间 $t_j$ 由 $t_j = j \\cdot \\Delta t_{1}$ 给出，其中 $j=0, 1, \\dots, 5$。\n- $t_{0} = 0 \\times 43.2 = 0 \\, \\text{s}$\n- $t_{1} = 1 \\times 43.2 = 43.2 \\, \\text{s}$\n- $t_{2} = 2 \\times 43.2 = 86.4 \\, \\text{s}$\n- $t_{3} = 3 \\times 43.2 = 129.6 \\, \\text{s}$\n- $t_{4} = 4 \\times 43.2 = 172.8 \\, \\text{s}$\n- $t_{5} = 5 \\times 43.2 = 216.0 \\, \\text{s}$\n第三组要求的值是 $(0, 43.2, 86.4, 129.6, 172.8, 216.0)$。\n\n这三组结果合并成一个单行矩阵作为最终答案。\n- $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$\n- $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$\n- $(t_0, \\dots, t_5) = (0, 43.2, 86.4, 129.6, 172.8, 216)$", "answer": "$$\n\\boxed{\\begin{pmatrix} 216  \\frac{480}{11}  18  216  43.2  14.4  0  43.2  86.4  129.6  172.8  216 \\end{pmatrix}}\n$$", "id": "3503472"}]}