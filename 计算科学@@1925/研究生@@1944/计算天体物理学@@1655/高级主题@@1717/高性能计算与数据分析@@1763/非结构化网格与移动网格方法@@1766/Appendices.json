{"hands_on_practices": [{"introduction": "任何显式的流体动力学数值模拟都受到一个稳定性条件的制约，该条件限制了时间步长的大小。本练习 [@problem_id:3541461] 提供了在移动非结构网格上计算这一关键参数——Courant-Friedrichs-Lewy (CFL) 时间步长——的实践机会。通过计算来自不同网格单元和交界面的贡献，你将具体理解流体属性、网格几何形状和网格运动如何共同决定模拟的“心跳”。", "problem": "考虑一组多边形控制体上的可压缩双曲守恒律的二维非结构化移动网格有限体积离散化。假设采用显式时间积分，并采用基于在局部面参考系中评估的单元间数值通量的谱半径的 Courant-Friedrichs-Lewy (CFL) 稳定性判据。数值通量使用 Harten-Lax-van Leer (HLL) 近似黎曼求解器构建，且面信号速度是相对于面法向网格速度来测量的。给定一个包含三个单元的小网格，所有量均以一致的代码单位表示：长度单位为千米，时间单位为秒，速度单位为千米/秒。\n\n三个单元的面积（在二维中作为体积）为：\n- 单元 $1$：$V_{1} = 3.0$\n- 单元 $2$：$V_{2} = 2.4$\n- 单元 $3$：$V_{3} = 2.1$\n\n每个单元具有恒定的速度矢量和局部声速：\n- 单元 $1$：$\\boldsymbol{u}_{1} = (0.8,\\,0.1)$，$c_{1} = 1.5$\n- 单元 $2$：$\\boldsymbol{u}_{2} = (0.2,\\,-0.2)$，$c_{2} = 1.2$\n- 单元 $3$：$\\boldsymbol{u}_{3} = (-0.3,\\,0.6)$，$c_{3} = 1.0$\n\n内部面（单位法向量 $\\boldsymbol{n}_{f}$ 从左侧单元指向右侧单元）具有以下数据，包括面长度 $A_{f}$ 和面法向网格速度 $w_{n,f}$：\n- 单元 $1$（左）和单元 $2$（右）之间的面 $f_{12}$：$A_{f_{12}} = 1.5$，$\\boldsymbol{n}_{12} = (1,\\,0)$，$w_{n,12} = 0.2$。\n- 单元 $2$（左）和单元 $3$（右）之间的面 $f_{23}$：$A_{f_{23}} = 1.0$，$\\boldsymbol{n}_{23} = (0,\\,1)$，$w_{n,23} = -0.1$。\n- 单元 $3$（左）和单元 $1$（右）之间的面 $f_{31}$：$A_{f_{31}} = 1.2$，$\\boldsymbol{n}_{31} = (-1,\\,0)$，$w_{n,31} = 0.05$。\n\n每个单元还有一个边界面，其透射条件通过等于边界另一侧相邻单元内部状态的虚拟状态来实现。边界面数据（具有向外的单位法向量和零网格法向速度）如下：\n- 单元 $1$：$A_{b,1} = 1.1$，$\\boldsymbol{n}_{b,1} = (0,\\,-1)$，$w_{n,b,1} = 0$。\n- 单元 $2$：$A_{b,2} = 1.0$，$\\boldsymbol{n}_{b,2} = (1,\\,0)$，$w_{n,b,2} = 0$。\n- 单元 $3$：$A_{b,3} = 0.9$，$\\boldsymbol{n}_{b,3} = (0,\\,1)$，$w_{n,b,3} = 0$。\n\n令 Courant 因子为 $C_{\\mathrm{CFL}} = 0.4$。使用面参考系中的 Harten-Lax-van Leer (HLL) 波速估计和非结构化网格的标准显式稳定性界限，通过取所有单元的最小值来计算允许的全局时间步长 $\\Delta t$。以秒为单位表示最终结果，并将答案四舍五入到四位有效数字。", "solution": "首先验证问题，以确保其科学基础扎实、适定且客观。逐字提取给定条件。\n- **问题类型**：可压缩双曲守恒律的二维非结构化移动网格有限体积离散化。\n- **时间积分**：显式。\n- **稳定性判据**：Courant-Friedrichs-Lewy (CFL) 判据，Courant 因子 $C_{\\mathrm{CFL}} = 0.4$。\n- **数值通量**：Harten-Lax-van Leer (HLL) 近似黎曼求解器，信号速度相对于面法向网格速度。\n- **单元面积**：$V_{1} = 3.0$，$V_{2} = 2.4$，$V_{3} = 2.1$。\n- **单元状态**：\n  - 单元 $1$：$\\boldsymbol{u}_{1} = (0.8,\\,0.1)$，$c_{1} = 1.5$。\n  - 单元 $2$：$\\boldsymbol{u}_{2} = (0.2,\\,-0.2)$，$c_{2} = 1.2$。\n  - 单元 $3$：$\\boldsymbol{u}_{3} = (-0.3,\\,0.6)$，$c_{3} = 1.0$。\n- **内部面**：\n  - $f_{12}$ (单元 $1$ 左, $2$ 右)：$A_{f_{12}} = 1.5$，$\\boldsymbol{n}_{12} = (1,\\,0)$，$w_{n,12} = 0.2$。\n  - $f_{23}$ (单元 $2$ 左, $3$ 右)：$A_{f_{23}} = 1.0$，$\\boldsymbol{n}_{23} = (0,\\,1)$，$w_{n,23} = -0.1$。\n  - $f_{31}$ (单元 $3$ 左, $1$ 右)：$A_{f_{31}} = 1.2$，$\\boldsymbol{n}_{31} = (-1,\\,0)$，$w_{n,31} = 0.05$。\n- **边界面**：\n  - 单元 $1$：$A_{b,1} = 1.1$，$\\boldsymbol{n}_{b,1} = (0,\\,-1)$，$w_{n,b,1} = 0$。\n  - 单元 $2$：$A_{b,2} = 1.0$，$\\boldsymbol{n}_{b,2} = (1,\\,0)$，$w_{n,b,2} = 0$。\n  - 单元 $3$：$A_{b,3} = 0.9$，$\\boldsymbol{n}_{b,3} = (0,\\,1)$，$w_{n,b,3} = 0$。\n- **边界条件**：透射条件，虚拟状态等于内部状态。\n\n该问题在科学上是合理的，因为它描述了计算天体物理学和流体动力学中的一种标准数值方法。所有必要的数据都已提供，且没有矛盾之处。问题是适定的和客观的。验证成功。\n\n解题过程是计算全局时间步长 $\\Delta t$。对于非结构化网格上的显式格式，每个单元 $i$ 的 CFL 条件由下式给出：\n$$ \\Delta t_i \\le C_{\\mathrm{CFL}} \\frac{V_i}{\\sum_{f \\in \\partial V_i} S_f A_f} $$\n其中 $V_i$ 是单元体积（二维中为面积），$A_f$ 是面面积（二维中为长度），$S_f$ 是垂直于面 $f$ 的最大信号速度。全局时间步长是所有单元中的最小值：$\\Delta t = \\min_i(\\Delta t_i)$。\n\n信号速度 $S_f$ 来自 HLL 波速估计。问题指明这些是在局部面参考系中，相对于法向网格速度 $w_{n,f}$ 进行评估的。令 $\\boldsymbol{u}_L$ 和 $\\boldsymbol{u}_R$ 为与面 $f$ 相邻的左右单元中的流体速度，$c_L, c_R$ 为声速。法向流体速度为 $u_{n,L} = \\boldsymbol{u}_L \\cdot \\boldsymbol{n}_f$ 和 $u_{n,R} = \\boldsymbol{u}_R \\cdot \\boldsymbol{n}_f$。相对于移动面的流体速度为 $u'_{n,L} = u_{n,L} - w_{n,f}$ 和 $u'_{n,R} = u_{n,R} - w_{n,f}$。\n\n在面参考系中的 HLL 波速估计 ($S'_L, S'_R$) 为：\n$$ S'_L = \\min(u'_{n,L} - c_L, u'_{n,R} - c_R) $$\n$$ S'_R = \\max(u'_{n,L} + c_L, u'_{n,R} + c_R) $$\n用于 CFL 计算的面最大信号速度是这些相对于参考系的波速的最大绝对值：\n$$ S_f = \\max(|S'_L|, |S'_R|) $$\n\n对于具有透射条件的边界面，虚拟状态与内部状态相同。因此，对于单元 $i$ 的一个边界面，我们有 $L=R=i$。这简化了波速计算：$u'_{n,i} = (\\boldsymbol{u}_i \\cdot \\boldsymbol{n}_{b,i}) - w_{n,b,i}$，从而得到 $S'_L = u'_{n,i} - c_i$ 和 $S'_R = u'_{n,i} + c_i$。信号速度为 $S_f = \\max(|u'_{n,i} - c_i|, |u'_{n,i} + c_i|) = |u'_{n,i}| + c_i$。\n\n我们现在系统地计算每个面的 $S_f$。\n\n**1. 内部面**\n\n- **面 $f_{12}$ (L=1, R=2):** $\\boldsymbol{n}_{12}=(1,\\,0)$，$w_{n,12}=0.2$。\n  - $u_{n,L} = \\boldsymbol{u}_1 \\cdot \\boldsymbol{n}_{12} = 0.8$。$u_{n,R} = \\boldsymbol{u}_2 \\cdot \\boldsymbol{n}_{12} = 0.2$。\n  - $u'_{n,L} = 0.8 - 0.2 = 0.6$。$u'_{n,R} = 0.2 - 0.2 = 0.0$。\n  - $c_L = 1.5$，$c_R = 1.2$。\n  - $S'_L = \\min(0.6 - 1.5, 0.0 - 1.2) = \\min(-0.9, -1.2) = -1.2$。\n  - $S'_R = \\max(0.6 + 1.5, 0.0 + 1.2) = \\max(2.1, 1.2) = 2.1$。\n  - $S_{12} = \\max(|-1.2|, |2.1|) = 2.1$。\n\n- **面 $f_{23}$ (L=2, R=3):** $\\boldsymbol{n}_{23}=(0,\\,1)$，$w_{n,23}=-0.1$。\n  - $u_{n,L} = \\boldsymbol{u}_2 \\cdot \\boldsymbol{n}_{23} = -0.2$。$u_{n,R} = \\boldsymbol{u}_3 \\cdot \\boldsymbol{n}_{23} = 0.6$。\n  - $u'_{n,L} = -0.2 - (-0.1) = -0.1$。$u'_{n,R} = 0.6 - (-0.1) = 0.7$。\n  - $c_L = 1.2$，$c_R = 1.0$。\n  - $S'_L = \\min(-0.1 - 1.2, 0.7 - 1.0) = \\min(-1.3, -0.3) = -1.3$。\n  - $S'_R = \\max(-0.1 + 1.2, 0.7 + 1.0) = \\max(1.1, 1.7) = 1.7$。\n  - $S_{23} = \\max(|-1.3|, |1.7|) = 1.7$。\n\n- **面 $f_{31}$ (L=3, R=1):** $\\boldsymbol{n}_{31}=(-1,\\,0)$，$w_{n,31}=0.05$。\n  - $u_{n,L} = \\boldsymbol{u}_3 \\cdot \\boldsymbol{n}_{31} = 0.3$。$u_{n,R} = \\boldsymbol{u}_1 \\cdot \\boldsymbol{n}_{31} = -0.8$。\n  - $u'_{n,L} = 0.3 - 0.05 = 0.25$。$u'_{n,R} = -0.8 - 0.05 = -0.85$。\n  - $c_L = 1.0$，$c_R = 1.5$。\n  - $S'_L = \\min(0.25 - 1.0, -0.85 - 1.5) = \\min(-0.75, -2.35) = -2.35$。\n  - $S'_R = \\max(0.25 + 1.0, -0.85 + 1.5) = \\max(1.25, 0.65) = 1.25$。\n  - $S_{31} = \\max(|-2.35|, |1.25|) = 2.35$。\n\n**2. 边界面**\n\n- **单元 1 的边界 ($f_{b,1}$):**\n  - $u'_{n,1} = (\\boldsymbol{u}_1 \\cdot \\boldsymbol{n}_{b,1}) - w_{n,b,1} = ((0.8,\\,0.1) \\cdot (0,\\,-1)) - 0 = -0.1$。\n  - $S_{b,1} = |u'_{n,1}| + c_1 = |-0.1| + 1.5 = 1.6$。\n\n- **单元 2 的边界 ($f_{b,2}$):**\n  - $u'_{n,2} = (\\boldsymbol{u}_2 \\cdot \\boldsymbol{n}_{b,2}) - w_{n,b,2} = ((0.2,\\,-0.2) \\cdot (1,\\,0)) - 0 = 0.2$。\n  - $S_{b,2} = |u'_{n,2}| + c_2 = |0.2| + 1.2 = 1.4$。\n\n- **单元 3 的边界 ($f_{b,3}$):**\n  - $u'_{n,3} = (\\boldsymbol{u}_3 \\cdot \\boldsymbol{n}_{b,3}) - w_{n,b,3} = ((-0.3,\\,0.6) \\cdot (0,\\,1)) - 0 = 0.6$。\n  - $S_{b,3} = |u'_{n,3}| + c_3 = |0.6| + 1.0 = 1.6$。\n\n**3. 每个单元的时间步长计算**\n\n- **单元 1:** 面为 $f_{12}, f_{31}, f_{b,1}$。\n  - $\\sum S_f A_f = S_{12} A_{12} + S_{31} A_{31} + S_{b,1} A_{b,1}$\n  - $\\sum S_f A_f = (2.1)(1.5) + (2.35)(1.2) + (1.6)(1.1) = 3.15 + 2.82 + 1.76 = 7.73$。\n  - $\\Delta t_1 = C_{\\mathrm{CFL}} \\frac{V_1}{\\sum S_f A_f} = 0.4 \\times \\frac{3.0}{7.73} = \\frac{1.2}{7.73} \\approx 0.155239$。\n\n- **单元 2:** 面为 $f_{12}, f_{23}, f_{b,2}$。\n  - $\\sum S_f A_f = S_{12} A_{12} + S_{23} A_{23} + S_{b,2} A_{b,2}$\n  - $\\sum S_f A_f = (2.1)(1.5) + (1.7)(1.0) + (1.4)(1.0) = 3.15 + 1.7 + 1.4 = 6.25$。\n  - $\\Delta t_2 = C_{\\mathrm{CFL}} \\frac{V_2}{\\sum S_f A_f} = 0.4 \\times \\frac{2.4}{6.25} = \\frac{0.96}{6.25} = 0.1536$。\n\n- **单元 3:** 面为 $f_{23}, f_{31}, f_{b,3}$。\n  - $\\sum S_f A_f = S_{23} A_{23} + S_{31} A_{31} + S_{b,3} A_{b,3}$\n  - $\\sum S_f A_f = (1.7)(1.0) + (2.35)(1.2) + (1.6)(0.9) = 1.7 + 2.82 + 1.44 = 5.96$。\n  - $\\Delta t_3 = C_{\\mathrm{CFL}} \\frac{V_3}{\\sum S_f A_f} = 0.4 \\times \\frac{2.1}{5.96} = \\frac{0.84}{5.96} \\approx 0.140939$。\n\n**4. 全局时间步长**\n\n全局时间步长是各个单元时间步长的最小值。\n$$ \\Delta t = \\min(\\Delta t_1, \\Delta t_2, \\Delta t_3) = \\min(0.155239..., 0.1536, 0.140939...) = \\Delta t_3 $$\n最严格的时间步长限制来自单元 3。\n$$ \\Delta t = \\frac{0.84}{5.96} \\approx 0.140939597... $$\n将结果四舍五入到四位有效数字，得到 $0.1409$。", "answer": "$$\n\\boxed{0.1409}\n$$", "id": "3541461"}, {"introduction": "为了精确捕捉复杂的天体物理现象，数值格式必须达到高阶精度。本练习 [@problem_id:3541478] 深入探讨了高阶方法的核心：空间重构。你将实现并比较一个标准的二阶线性重构方案与一个更复杂的三阶二次方案，并凭经验验证它们的收敛阶，这是代码验证与开发的一项基本技能。", "problem": "你需要编写一个完整、可运行的程序，在一个带周期性边界条件的一维质心 Voronoi 网格上，对一个光滑标量函数，定量比较线性守恒律单调上游中心格式 (MUSCL) 重构与二次最小二乘重构，并估计在网格加密下的观测精度阶。\n\n计算域为周期性区间 $[0,1]$。带周期性边界条件的一维质心 Voronoi 剖分等价于一个划分为 $N$ 个单元的均匀分区。设单元界面位于 $x_{i+\\frac{1}{2}} = \\frac{i+1}{N}$，单元质心位于 $x_i = \\frac{i+\\frac{1}{2}}{N}$，其中 $i=0,\\dots,N-1$。定义光滑函数\n$$\n\\phi(x) = \\sin(2\\pi x) + 0.1 \\cos(6\\pi x).\n$$\n对于每个网格，取单元中心采样值 $u_i = \\phi(x_i)$。\n\n需要实现的重构方法：\n1. 不带限制器的线性守恒律单调上游中心格式 (MUSCL) 重构：\n   - 对于每个单元 $i$，使用中心差分计算斜率\n     $$\n     s_i = \\frac{u_{i+1} - u_{i-1}}{x_{i+1} - x_{i-1}},\n     $$\n     其中索引周期性循环。将右界面 $x_{i+\\frac{1}{2}}$ 处的左状态重构为\n     $$\n     u_{i+\\frac{1}{2}}^{-} = u_i + s_i \\left(x_{i+\\frac{1}{2}} - x_i\\right).\n     $$\n2. 二次最小二乘重构：\n   - 对于每个单元 $i$，拟合一个以 $x_i$ 为中心的二次多项式，即\n     $$\n     p_i(\\xi) = a_0 + a_1 \\xi + a_2 \\xi^2,\\quad \\xi = x - x_i,\n     $$\n     方法是在对称模板 $\\{i-2,i-1,i,i+1,i+2\\}$ 上使用点采样值 $\\{(x_j - x_i,\\;u_j)\\}$ 最小化残差平方和。邻居单元的索引根据需要进行周期性循环。通过以下方式计算右界面的左状态\n     $$\n     u_{i+\\frac{1}{2}}^{-} = p_i\\!\\left(x_{i+\\frac{1}{2}} - x_i\\right).\n     $$\n\n对于每个网格，将一个格式的界面误差定义为来自左侧单元的重构左状态与界面处精确函数值之间的差值，\n$$\ne_{i+\\frac{1}{2}} = u_{i+\\frac{1}{2}}^{-} - \\phi\\!\\left(x_{i+\\frac{1}{2}}\\right).\n$$\n计算所有界面上的均方根 $L^2$ 误差，\n$$\nE = \\left(\\frac{1}{N}\\sum_{i=0}^{N-1} e_{i+\\frac{1}{2}}^2\\right)^{1/2}.\n$$\n对于一系列加密 $N \\to 2N$，观测精度阶计算如下\n$$\np = \\frac{\\log\\left(E(N)/E(2N)\\right)}{\\log(2)}.\n$$\n\n从光滑函数的泰勒展开和上述定义的第一性原理出发，目标是经验性地证明线性守恒律单调上游中心格式 (MUSCL) 重构在质心 Voronoi 网格上是二阶精度的，而二次最小二乘重构是三阶精度的。\n\n你的程序必须：\n- 为每个 $N$ 构建网格。\n- 计算所有单元的 $u_i$。\n- 对于每种方法，在所有界面上重构 $u_{i+\\frac{1}{2}}^{-}$，计算误差 $e_{i+\\frac{1}{2}}$ 和均方根 $L^2$ 误差 $E$。\n- 对于每个连续的加密对 $(N,2N)$，按定义计算观测阶 $p$。\n\n测试套件 (请精确使用这些网格尺寸)：\n- $N \\in \\{8, 16, 32, 64\\}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个顶层列表，其中含有四个列表：\n  - 第一个列表包含线性守恒律单调上游中心格式 (MUSCL) 方法在 $N=8,16,32,64$ 时的 $L^2$ 误差。\n  - 第二个列表包含二次最小二乘方法在 $N=8,16,32,64$ 时的 $L^2$ 误差。\n  - 第三个列表包含线性守恒律单调上游中心格式 (MUSCL) 方法在加密对 $(8,16)$、$(16,32)$、$(32,64)$ 上的观测阶。\n  - 第四个列表包含二次最小二乘方法在加密对 $(8,16)$、$(16,32)$、$(32,64)$ 上的观测阶。\n\n例如，程序必须打印类似\n$$\n\\big[\\,[E^\\mathrm{lin}_8,E^\\mathrm{lin}_{16},E^\\mathrm{lin}_{32},E^\\mathrm{lin}_{64}],\\;[E^\\mathrm{quad}_8,E^\\mathrm{quad}_{16},E^\\mathrm{quad}_{32},E^\\mathrm{quad}_{64}],\\;[p^\\mathrm{lin}_{8\\to16},p^\\mathrm{lin}_{16\\to32},p^\\mathrm{lin}_{32\\to64}],\\;[p^\\mathrm{quad}_{8\\to16},p^\\mathrm{quad}_{16\\to32},p^\\mathrm{quad}_{32\\to64}]\\,\\big]\n$$\n的单行内容，用实际数值代替符号。\n\n角度单位为弧度。本问题中没有物理单位。所有返回的数值必须是浮点数。代码必须完全自包含，且不得读取输入。", "solution": "用户要求在一个一维周期性网格上，对线性守恒律单调上游中心格式 (MUSCL) 重构和二次最小二乘重构进行定量比较。这涉及实现这两种格式，在一系列不断加密的网格上计算它们对一个光滑函数的重构误差，并根据这些误差估计每种方法的观测精度阶。该问题是数值分析中一个适定的练习，对于发展计算天体物理学等领域中使用的高阶有限体积法至关重要。\n\n### 基于原理的设计\n\n问题的核心在于在离散单元内逼近一个光滑函数 $\\phi(x)$，并在单元界面上评估此逼近。这种界面重构的精度决定了基于它构建的数值格式的整体精度。我们将分析并实现两种这样的重构方法。\n\n**1. 准备工作：网格和函数**\n\n计算域是周期性区间 $[0,1]$。带周期性边界条件的一维质心 Voronoi 剖分等价于一个均匀网格。对于 $N$ 个单元，单元宽度为 $\\Delta x = 1/N$。问题将单元界面定义在 $x_{i+\\frac{1}{2}} = (i+1)/N$，单元质心定义在 $x_i = (i+\\frac{1}{2})/N$，其中 $i=0, \\dots, N-1$。根据这些定义，第 $i$ 个单元占据区间 $[i/N, (i+1)/N]$，其宽度确实是 $1/N$，且 $x_i$ 是其中心。从单元中心 $x_i$ 到其右界面 $x_{i+\\frac{1}{2}}$ 的距离是 $x_{i+\\frac{1}{2}} - x_i = (i+1)/N - (i+0.5)/N = 0.5/N = \\Delta x/2$。\n\n光滑测试函数为 $\\phi(x) = \\sin(2\\pi x) + 0.1 \\cos(6\\pi x)$。重构格式可用的精确数据是单元中心的采样值 $u_i = \\phi(x_i)$。\n\n**2. 线性 MUSCL 重构**\n\n该方法在每个单元内构建函数的分段线性逼近 $p_i(x) = u_i + s_i(x-x_i)$。关键是确定斜率 $s_i$。问题指定了一个中心差分公式：\n$$\ns_i = \\frac{u_{i+1} - u_{i-1}}{x_{i+1} - x_{i-1}}\n$$\n其中索引是周期性处理的。在我们的均匀网格上，$x_{i+1} - x_{i-1} = 2\\Delta x$。对于一个光滑函数 $\\phi(x)$，泰勒展开表明此公式以二阶精度逼近真实导数 $\\phi'(x_i)$：$s_i = \\phi'(x_i) + O(\\Delta x^2)$。\n\n在右界面 $x_{i+\\frac{1}{2}}$ 处的重构值是线性多项式在该点的求值：\n$$\nu_{i+\\frac{1}{2}}^{-} = u_i + s_i (x_{i+\\frac{1}{2}} - x_i) = u_i + s_i \\frac{\\Delta x}{2}\n$$\n界面处的误差为 $e_{i+\\frac{1}{2}} = u_{i+\\frac{1}{2}}^{-} - \\phi(x_{i+\\frac{1}{2}})$。为了分析这个误差，我们使用泰勒级数。\n重构值为：\n$$\nu_{i+\\frac{1}{2}}^{-} = \\phi(x_i) + \\left(\\phi'(x_i) + O(\\Delta x^2)\\right) \\frac{\\Delta x}{2} = \\phi(x_i) + \\phi'(x_i)\\frac{\\Delta x}{2} + O(\\Delta x^3)\n$$\n精确值为：\n$$\n\\phi(x_{i+\\frac{1}{2}}) = \\phi\\left(x_i + \\frac{\\Delta x}{2}\\right) = \\phi(x_i) + \\phi'(x_i)\\frac{\\Delta x}{2} + \\frac{1}{2}\\phi''(x_i)\\left(\\frac{\\Delta x}{2}\\right)^2 + O(\\Delta x^3)\n$$\n界面误差是这两个表达式之差：\n$$\ne_{i+\\frac{1}{2}} = -\\frac{1}{8}\\phi''(x_i)\\Delta x^2 + O(\\Delta x^3)\n$$\n局部误差为 $O(\\Delta x^2)$ 阶。因此，均方根 (RMS) 误差 $E$（即在网格上对这些局部误差求平均）预期具有二阶精度，即 $E \\propto \\Delta x^2$。这预测了观测精度阶 $p \\approx 2$。\n\n**3. 二次最小二乘重构**\n\n该方法在每个单元内构建一个分段二次逼近 $p_i(\\xi) = a_0 + a_1 \\xi + a_2 \\xi^2$，其中 $\\xi = x - x_i$。单元 $i$ 的系数 $(a_0, a_1, a_2)$ 通过对来自对称 5 点模板 $\\{i-2, i-1, i, i+1, i+2\\}$ 的数据样本 $u_j$ 进行最小二乘拟合来确定。\n\n这个最小化问题等价于求解一个超定线性系统。对于每个单元 $i$，我们希望找到系数向量 $\\mathbf{c} = [a_0, a_1, a_2]^T$ 来最小化 $\\|\\mathbf{A}\\mathbf{c} - \\mathbf{b}\\|_2^2$，其中：\n- $\\mathbf{b} = [u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}]^T$ (使用周期性索引)。\n- $\\mathbf{A}$ 是一个 $5 \\times 3$ 的类范德蒙设计矩阵，其行为 $[1, \\xi_k, \\xi_k^2]$，其中 $\\xi_k = (k\\cdot \\Delta x)$，$k \\in \\{-2, -1, 0, 1, 2\\}$。\n标准解由正规方程给出，$\\mathbf{c} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T \\mathbf{b}$。由于网格是均匀的，矩阵 $\\mathbf{A}$ 仅依赖于 $\\Delta x$，而不依赖于单元索引 $i$。因此，对于每个网格分辨率 $N$，伪逆 $\\mathbf{A}^+ = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T$ 可以只计算一次。\n\n重构的界面值是此多项式在 $\\xi = \\Delta x/2$ 处的求值：\n$$\nu_{i+\\frac{1}{2}}^{-} = p_i(\\Delta x/2) = a_0 + a_1\\frac{\\Delta x}{2} + a_2\\left(\\frac{\\Delta x}{2}\\right)^2\n$$\n对于光滑函数，在对称模板上的这种高阶多项式拟合会产生更精确的重构。理论分析表明，由此产生的界面误差 $e_{i+\\frac{1}{2}}$ 为 $O(\\Delta x^3)$ 阶。因此，RMS 误差 $E$ 预期为三阶精度 ($E \\propto \\Delta x^3$)，预测观测精度阶 $p \\approx 3$。\n\n**4. 实现与验证**\n\n程序将实现这两种格式。对于每个网格分辨率 $N \\in \\{8, 16, 32, 64\\}$，它会计算两种方法的 RMS 误差 $E(N)$。二次重构将通过预先计算设计矩阵的伪逆，并使用向量化操作同时计算所有单元的系数来实现高效计算。最后，对于每个加密步骤，计算观测精度阶 $p = \\log_2(E(N)/E(2N))$。预期数值结果将证实随着网格加密，线性 MUSCL 方法的 $p \\to 2$ 和二次最小二乘方法的 $p \\to 3$ 的理论预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares reconstruction errors and observed orders of accuracy\n    for linear MUSCL and quadratic least-squares schemes.\n    \"\"\"\n\n    # Define the smooth scalar function\n    def phi(x):\n        return np.sin(2 * np.pi * x) + 0.1 * np.cos(6 * np.pi * x)\n\n    # Test suite of mesh sizes\n    N_values = [8, 16, 32, 64]\n\n    # Lists to store the final results\n    E_muscl_list = []\n    E_quad_list = []\n    p_muscl_list = []\n    p_quad_list = []\n\n    # Main loop over the mesh sizes\n    for N in N_values:\n        # Define mesh properties\n        dx = 1.0 / N\n        # Cell centroids x_i = (i + 0.5) / N\n        x_centroids = (np.arange(N) + 0.5) / N\n        # Cell interfaces x_{i+1/2} = (i + 1) / N\n        x_interfaces = (np.arange(N) + 1.0) / N\n        \n        # Compute cell-centered samples of the function\n        u = phi(x_centroids)\n\n        # 1. Linear MUSCL Reconstruction (without limiter)\n        # Get neighbor values using periodic wrapping\n        u_ip1 = np.roll(u, -1)\n        u_im1 = np.roll(u, 1)\n\n        # Compute slope s_i = (u_{i+1} - u_{i-1}) / (x_{i+1} - x_{i-1})\n        # For a uniform periodic grid, x_{i+1} - x_{i-1} is always 2*dx\n        s = (u_ip1 - u_im1) / (2.0 * dx)\n\n        # Reconstruct at right interface: u_i + s_i * (x_{i+1/2} - x_i)\n        # The distance to the interface is 0.5*dx\n        dist_to_interface = 0.5 * dx\n        u_recon_muscl = u + s * dist_to_interface\n\n        # 2. Quadratic Least-Squares Reconstruction\n        # Stencil uses 5 points: {i-2, i-1, i, i+1, i+2}\n        # Relative coordinates xi = (x_j - x_i) = k*dx for k in {-2,...,2}\n        xi_stencil = np.array([-2.0, -1.0, 0.0, 1.0, 2.0]) * dx\n        \n        # Build the design matrix A for p(xi) = a0 + a1*xi + a2*xi^2\n        A = np.vstack([np.ones(5), xi_stencil, xi_stencil**2]).T\n\n        # Gather stencil data for all cells using vectorized operations\n        u_im2 = np.roll(u, 2)\n        # u_im1 is already computed\n        u_ip2 = np.roll(u, -2)\n        # u_ip1 is already computed\n        U_stencils = np.vstack([u_im2, u_im1, u, u_ip1, u_ip2]).T\n\n        # Solve for all coefficient vectors at once: C = pinv(A) @ U.T\n        # We need C.T = pinv(A) @ U.T, so C = (pinv(A) @ U.T).T = U @ pinv(A).T\n        Coeffs = U_stencils @ np.linalg.pinv(A).T\n        \n        # Evaluate all polynomials at the right interface (xi = 0.5*dx)\n        xi_interface = 0.5 * dx\n        xi_vec = np.array([1.0, xi_interface, xi_interface**2])\n        u_recon_quad = Coeffs @ xi_vec\n        \n        # 3. Compute Errors\n        # Get exact function values at the interfaces\n        phi_exact_interfaces = phi(x_interfaces)\n        \n        # Compute L2 RMS error for MUSCL\n        error_muscl = u_recon_muscl - phi_exact_interfaces\n        E_muscl = np.sqrt(np.mean(error_muscl**2))\n        E_muscl_list.append(E_muscl)\n        \n        # Compute L2 RMS error for Quadratic LS\n        error_quad = u_recon_quad - phi_exact_interfaces\n        E_quad = np.sqrt(np.mean(error_quad**2))\n        E_quad_list.append(E_quad)\n        \n    # 4. Compute Observed Order of Accuracy\n    for i in range(len(N_values) - 1):\n        # Order p = log(E(N)/E(2N)) / log(2)\n        p_muscl = np.log(E_muscl_list[i] / E_muscl_list[i+1]) / np.log(2)\n        p_muscl_list.append(p_muscl)\n        \n        p_quad = np.log(E_quad_list[i] / E_quad_list[i+1]) / np.log(2)\n        p_quad_list.append(p_quad)\n\n    # Final print statement in the exact required format.\n    results = [E_muscl_list, E_quad_list, p_muscl_list, p_quad_list]\n    print(results)\n\nsolve()\n```", "id": "3541478"}, {"introduction": "虽然高阶格式在光滑流场中能提高精度，但在激波附近或高度扭曲的网格上，它们可能会引入虚假的数值振荡，这是天体物理模拟中的一个普遍挑战。这项高级练习 [@problem_id:3541412] 要求你推导并实现一个考虑几何因素的斜率限制器，旨在维持极端纵横比网格上的稳健性。本练习超越了标准方法的使用，转向开发更具弹性的新算法，反映了计算科学家面临的实际问题。", "problem": "您的任务是为计算天体物理学中的非结构化、可能移动的网格上的线性重构设计、推导和实现一个经过鲁棒性测试的斜率限制器。其科学基础是任意拉格朗日-欧拉 (ALE) 公式中的标量守恒律以及总变差递减 (TVD) 格式所要求的单调性约束。考虑一个标量 $u(\\mathbf{x},t)$，它在一个可以随网格速度 $\\mathbf{w}(\\mathbf{x},t)$ 移动的控制体积 $\\Omega(t)$ 上满足守恒律，其积分形式为\n$$\n\\frac{d}{dt}\\int_{\\Omega(t)} u\\,dA + \\int_{\\partial \\Omega(t)}\\left(\\mathbf{F}(u) - u\\,\\mathbf{w}\\right)\\cdot \\mathbf{n}\\,ds = 0,\n$$\n其中 $\\mathbf{F}(u)$ 是通量函数，$\\mathbf{n}$ 是 $\\partial\\Omega(t)$ 上的单位外法向量。为了在二维中创建一个激波主导的验证场景，我们沿 $x$ 轴使用一维无粘性 Burgers 方程，其通量为 $\\mathbf{F}(u) = (u^2/2,\\,0)$。已知该方程会从光滑的初始数据发展出激波，并且在用黎曼型跳跃进行初始化时会产生强间断。\n\n在一个非结构化的多边形网格上，假设每个单元 $C$ 内的分段线性重构定义为\n$$\nu(\\mathbf{x}) \\approx u_C + \\phi_C\\,\\mathbf{g}_C\\cdot(\\mathbf{x} - \\mathbf{x}_C),\n$$\n其中 $u_C$ 是单元平均值，$\\mathbf{x}_C$ 是选定的代表点（例如，质心或生成点），$\\mathbf{g}_C$ 是通过对邻居信息进行最小二乘拟合得到的无约束梯度，而 $\\phi_C\\in[0,1]$ 是一个强制单调性的标量斜率限制器。标准的 TVD 要求是，在每个面心 $\\mathbf{x}_f$ 处的重构值必须位于由该单元及其面相邻邻居单元所形成的闭区间内，即：\n$$\nu(\\mathbf{x}_f) \\in \\big[\\min\\{u_C,u_{N_1},\\dots\\},\\,\\max\\{u_C,u_{N_1},\\dots\\}\\big].\n$$\n然而，在极端纵横比下，仅强制面心处的界限仍可能因多边形内部距离的巨大变化而在顶点附近产生内部过冲。为解决此问题，定义单元内切圆半径 $R_i$ 为从 $\\mathbf{x}_C$ 到多边形任意边的最小距离，以及外接圆半径 $R_c$ 为从 $\\mathbf{x}_C$ 到任意顶点的最大距离。您必须推导一个限制器 $\\phi_\\chi$，其构造明确且定量地考虑了以下比率：\n$$\n\\chi \\equiv \\frac{R_c}{R_i},\n$$\n然后在具有极端 $\\chi$ 值的单元上验证其抵抗激波诱导振荡的鲁棒性。\n\n从 ALE 守恒律和 TVD 要求产生的单调性约束出发，推导一个与几何相关的重构界限，该界限能保证在每个多边形单元内的面心和顶点处都不产生新的极值，并用 $R_i$ 和 $R_c$ 表示。推导必须从第一性原理出发：从守恒律、线性重构的定义、基于邻居的单调性区间以及连接从 $\\mathbf{x}_C$ 到面和顶点的距离的几何不等式开始。避免使用任何现成的或简化的公式；从这些基本元素出发，通过逻辑步骤构建该界限。\n\n程序的实现要求：\n- 构建一个二维矩形网格，作为非结构化多边形网格的一个特例（矩形是多边形）。使用单元质心作为 $\\mathbf{x}_C$。对矩形使用精确的内切圆半径和外接圆半径：$R_i$ 是半宽和半高中较小的一个，而 $R_c$ 是从质心到角的距离。对于一般多边形，您可以将 $R_i$ 计算为从 $\\mathbf{x}_C$ 到每条边线的最小距离，将 $R_c$ 计算为从 $\\mathbf{x}_C$ 到顶点的最大欧几里得距离。\n- 在每个单元中，通过对面相邻邻居单元质心处的值进行最小二乘拟合来计算无约束梯度 $\\mathbf{g}_C$。\n- 每个测试案例实现两种重构：一种使用传统的基于面心的 TVD 限制器，另一种使用您推导的、包含了 $R_i$ 和 $R_c$ 的几何感知限制器 $\\phi_\\chi$。\n- 将激波主导的初始条件定义为黎曼型跳跃：\n$$\nu(\\mathbf{x},0) = \\begin{cases}\n1 & \\text{if } x < 0,\\\\\n0 & \\text{if } x \\ge 0.\n\\end{cases}\n$$\n- 为了验证，计算每个单元顶点处相对于由该单元及其面相邻邻居形成的局部单调区间的最大重构过冲。对于一个单元 $C$，令 $u_{\\min,C}$ 和 $u_{\\max,C}$ 分别为 $\\{u_C,u_{N_1},u_{N_2},u_{N_3},u_{N_4}\\}$（仅考虑存在的邻居）中的最小值和最大值。对于 $C$ 的每个顶点 $\\mathbf{v}$，计算 $u_\\text{rec}(\\mathbf{v}) = u_C + \\phi\\,\\mathbf{g}_C\\cdot(\\mathbf{v}-\\mathbf{x}_C)$ 并将局部过冲幅度定义为\n$$\n\\delta(\\mathbf{v}) = \\max\\big(0,\\,u_\\text{rec}(\\mathbf{v}) - u_{\\max,C}\\big) + \\max\\big(0,\\,u_{\\min,C}-u_\\text{rec}(\\mathbf{v})\\big).\n$$\n单元的过冲是其所有顶点上 $\\delta(\\mathbf{v})$ 的最大值，而全网格的过冲是所有单元过冲的最大值。为常规限制器和您的 $\\phi_\\chi$ 计算此过冲，并以浮点数形式报告。\n- 测试套件：\n    - 案例1：$N_x=40$，$N_y=40$，具有单位纵横比缩放 ($s_y=1$) 的矩形单元，以及零网格速度 $\\mathbf{w}=(0,0)$。\n    - 案例2：$N_x=40$，$N_y=40$，通过垂直压缩 ($s_y=0.1$) 产生的极端纵横比，$\\mathbf{w}=(0,0)$。\n    - 案例3：$N_x=40$，$N_y=40$，极端纵横比 $s_y=0.1$，具有在 $x$ 方向上恒定的移动网格速度场 ($\\mathbf{w}=(0.2,0)$)。尽管过冲度量是纯粹基于几何重构的，但包含 $\\mathbf{w}$ 可以确保该场景符合移动网格的背景，同时限制器的鲁棒性仍然是焦点。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含全网格重构过冲幅度，形式为用方括号括起来的逗号分隔列表。该列表必须恰好包含六个浮点数，顺序为\n$$\n[\\Delta_\\text{std}^{(1)},\\Delta_\\chi^{(1)},\\Delta_\\text{std}^{(2)},\\Delta_\\chi^{(2)},\\Delta_\\text{std}^{(3)},\\Delta_\\chi^{(3)}],\n$$\n其中 $\\Delta_\\text{std}^{(i)}$ 是案例 $i$ 使用传统面心 TVD 限制器的过冲幅度，而 $\\Delta_\\chi^{(i)}$ 是案例 $i$ 使用您的几何感知限制器的过冲幅度。不涉及单位，所有内部可能出现的角度都必须以弧度处理。输出应为纯十进制浮点数，不带任何百分号。", "solution": "我们从任意拉格朗日-欧拉 (ALE) 公式中的标量守恒律开始。对于一个控制体积 $\\Omega(t)$，其边界 $\\partial\\Omega(t)$ 以速度 $\\mathbf{w}$ 移动，守恒声明为\n$$\n\\frac{d}{dt}\\int_{\\Omega(t)} u\\,dA + \\int_{\\partial \\Omega(t)}\\left(\\mathbf{F}(u) - u\\,\\mathbf{w}\\right)\\cdot \\mathbf{n}\\,ds = 0.\n$$\n这体现了穿过移动边界的通量必须相对于网格运动来计算。为了进行激波主导的验证，我们将一维 Burgers 通量沿 $x$ 轴嵌入到二维空间中：\n$$\n\\mathbf{F}(u) = \\left(\\frac{u^2}{2},\\,0\\right),\n$$\n并采用黎曼型初始条件，$u(\\mathbf{x},0)$ 在 $x<0$ 时等于 $1$，在 $x\\ge 0$ 时等于 $0$，这确保了在 $x=0$ 处存在强间断（激波）。\n\n在一个多边形单元 $C$ 上，我们使用线性重构，\n$$\nu(\\mathbf{x}) \\approx u_C + \\phi_C\\,\\mathbf{g}_C\\cdot(\\mathbf{x}-\\mathbf{x}_C),\n$$\n其中 $u_C$ 是单元平均值，$\\mathbf{x}_C$ 是一个代表点（我们使用质心），$\\mathbf{g}_C$ 是通过最小二乘法获得的无约束梯度，而 $\\phi_C\\in[0,1]$ 是一个斜率限制器。最小二乘梯度通过最小化以下函数得到\n$$\nJ(\\mathbf{g}) = \\sum_{k\\in\\mathcal{N}(C)} w_k\\left(u_k - u_C - \\mathbf{g}\\cdot(\\mathbf{x}_k - \\mathbf{x}_C)\\right)^2,\n$$\n其中 $w_k$ 是权重（我们取 $w_k=1$），得到正规方程组\n$$\n\\left(\\sum_k w_k\\,\\mathbf{d}_k\\mathbf{d}_k^\\top\\right)\\mathbf{g} = \\sum_k w_k\\,\\mathbf{d}_k\\,(u_k - u_C),\n$$\n其中 $\\mathbf{d}_k = \\mathbf{x}_k - \\mathbf{x}_C$。如果对称矩阵是可逆的，则解为\n$$\n\\mathbf{g} = \\left(\\sum_k w_k\\,\\mathbf{d}_k\\mathbf{d}_k^\\top\\right)^{-1}\\left(\\sum_k w_k\\,\\mathbf{d}_k\\,(u_k - u_C)\\right).\n$$\n\n总变差递减 (TVD) 的单调性要求重构过程不产生新的极值。一个常见的充分条件是要求在面心处的重构值位于由该单元及其面相邻邻居单元所张成的区间内。令\n$$\nu_{\\min,C} = \\min\\{u_C,u_{N_1},u_{N_2},u_{N_3},u_{N_4}\\},\\quad u_{\\max,C} = \\max\\{u_C,u_{N_1},u_{N_2},u_{N_3},u_{N_4}\\},\n$$\n其中该集合仅包含存在的邻居。对于每个面心 $\\mathbf{x}_f$，其偏移量为 $\\mathbf{d}_f=\\mathbf{x}_f-\\mathbf{x}_C$，单调性要求\n$$\nu_C + \\phi_C\\,\\mathbf{g}_C\\cdot \\mathbf{d}_f \\in [u_{\\min,C},u_{\\max,C}].\n$$\n这导出了传统的基于面心的限制器界限。定义\n$$\n\\Delta_f = \\mathbf{g}_C\\cdot \\mathbf{d}_f.\n$$\n如果 $\\Delta_f>0$，则上界强制\n$$\n\\phi_C \\le \\frac{u_{\\max,C}-u_C}{\\Delta_f},\n$$\n如果 $\\Delta_f<0$，则下界强制\n$$\n\\phi_C \\le \\frac{u_{\\min,C}-u_C}{\\Delta_f},\n$$\n如果 $\\Delta_f=0$，则该面没有限制。传统的基于面心的限制器使用\n$$\n\\phi_\\text{std} = \\min\\left(1,\\ \\min_f \\phi_f\\right),\n$$\n其中每个 $\\phi_f$ 根据其符号按上述方法计算，并被裁剪为非负值。\n\n然而，在极端纵横比下，仅约束面心值可能会允许在顶点附近出现内部过冲。要理解其原因，请考虑一个具有代表点 $\\mathbf{x}_C$ 的多边形单元 $C$ 的几何形状。定义内切圆半径 $R_i$ 为从 $\\mathbf{x}_C$ 到任意边线的最小距离，外接圆半径 $R_c$ 为从 $\\mathbf{x}_C$ 到任意顶点的最大欧几里得距离。对于单元内任意距 $\\mathbf{x}_C$ 为 $r=\\|\\mathbf{v}-\\mathbf{x}_C\\|$ 的向量 $\\mathbf{v}$，线性重构的变化量为\n$$\n|u(\\mathbf{v})-u_C| = |\\phi_C\\,\\mathbf{g}_C\\cdot(\\mathbf{v}-\\mathbf{x}_C)| \\le \\phi_C\\,\\|\\mathbf{g}_C\\|\\,r.\n$$\n面心约束在 $r$ 与到面的距离相当的偏移处限制了 $|u(\\mathbf{x}_f)-u_C|$；最严格的界限由最小的此类 $r$ 控制，即 $R_i$。与此同时，单元内的最大变化可能发生在最远顶点附近，其距离为 $r=R_c$。如果我们只保证面心处的界限，那么可能对于所有面都有\n$$\n|u(\\mathbf{x}_f)-u_C|\\le \\Delta_{\\max}\n$$\n然而在某个顶点处的变化可能大至\n$$\n|u(\\mathbf{v})-u_C|\\le \\phi_C\\,\\|\\mathbf{g}_C\\|\\,R_c,\n$$\n如果面约束有效地限制了在 $R_i$ 附近距离上的变化，那么这个值可能会超过 $\\Delta_{\\max}$ 约 $R_c/R_i$ 倍。这表明，为了不仅在面心处，而且在顶点和内部点处都保证单调性，我们应该对 $\\phi_C$ 施加一个与比率\n$$\n\\chi = \\frac{R_c}{R_i}.\n$$\n成正比的几何缩减。\n\n一个精确的界限可以如下构造。令严格的面心约束由\n$$\n|\\phi_C\\,\\mathbf{g}_C\\cdot \\mathbf{d}_f| \\le \\Delta_{\\max},\n$$\n来概括，适用于所有面（其中 $\\Delta_{\\max}$ 由 $u_{\\min,C}$ 和 $u_{\\max,C}$ 以及 $\\mathbf{d}_f$ 的方向隐式确定）。因为 $|\\mathbf{g}_C\\cdot \\mathbf{d}_f|\\le \\|\\mathbf{g}_C\\|\\,\\|\\mathbf{d}_f\\|$ 并且对于面，在最坏情况下有 $\\|\\mathbf{d}_f\\|\\ge R_i$，所以基于面的约束限制了\n$$\n\\phi_C\\,\\|\\mathbf{g}_C\\|\\,R_i \\lesssim \\Delta_{\\max}.\n$$\n为了保证在 $C$ 内任何点，特别是在距离为 $R_c$ 的远顶点处具有相同的界限，只需强制\n$$\n\\phi_C\\,\\|\\mathbf{g}_C\\|\\,R_c \\le \\Delta_{\\max}.\n$$\n结合这两者可得\n$$\n\\phi_C \\le \\frac{R_i}{R_c}\\,\\frac{\\Delta_{\\max}}{\\|\\mathbf{g}_C\\|\\,R_i} \\le \\frac{R_i}{R_c}\\,\\phi_\\text{std}.\n$$\n由于 $\\phi_\\text{std}$ 已经确保了面心处的界限，强制内部界限的几何感知限制器继承了一个因子为 $R_i/R_c = 1/\\chi$ 的乘法缩减，从而产生\n$$\n\\phi_\\chi = \\min\\big(\\phi_\\text{std},\\,\\frac{R_i}{R_c}\\big).\n$$\n这个限制器在高纵横比单元上抑制了重构强度，提供了抵抗顶点附近内部过冲的鲁棒性，同时当单元紧凑时（$R_c/R_i$ 接近 1），它会退化为标准限制器。\n\n算法步骤：\n- 对每个单元，使用其面相邻邻居计算最小二乘梯度 $\\mathbf{g}_C$。\n- 从该单元及其邻居计算 $u_{\\min,C}$ 和 $u_{\\max,C}$。\n- 对每个面心，计算 $\\Delta_f=\\mathbf{g}_C\\cdot \\mathbf{d}_f$ 并如上推导 $\\phi_f$；构成 $\\phi_\\text{std}=\\min(1,\\min_f\\phi_f)$。\n- 计算 $R_i$ 为从 $\\mathbf{x}_C$ 到每条边线的最小距离，$R_c$ 为到顶点的最大距离；如果 $R_c=0$ 或最小二乘矩阵是病态的，则设置 $\\phi=0$ 以避免除以零或伪重构。\n- 设置 $\\phi_\\chi = \\min(\\phi_\\text{std}, R_i/R_c)$。\n- 为了验证，在每个单元顶点 $\\mathbf{v}$ 处，为 $\\phi_\\text{std}$ 和 $\\phi_\\chi$ 计算 $u_\\text{rec}(\\mathbf{v})$，评估相对于 $[u_{\\min,C},u_{\\max,C}]$ 的过冲度量 $\\delta(\\mathbf{v})$，取所有顶点的最大值，然后在所有单元上取最大值，以获得全网格过冲幅度 $\\Delta_\\text{std}$ 和 $\\Delta_\\chi$。\n\n测试套件和输出：\n- 案例1：$N_x=40$，$N_y=40$，$s_y=1$，$\\mathbf{w}=(0,0)$。\n- 案例2：$N_x=40$，$N_y=40$，$s_y=0.1$，$\\mathbf{w}=(0,0)$。\n- 案例3：$N_x=40$，$N_y=40$，$s_y=0.1$，$\\mathbf{w}=(0.2,0)$。\n\n对每个案例，计算并输出六元素列表\n$$\n[\\Delta_\\text{std}^{(1)},\\Delta_\\chi^{(1)},\\Delta_\\text{std}^{(2)},\\Delta_\\chi^{(2)},\\Delta_\\text{std}^{(3)},\\Delta_\\chi^{(3)}].\n$$\n这在一个激波主导的场景中验证了，几何感知限制器在极端纵横比单元上减少或消除了内部过冲，同时在形状良好的单元上与标准限制器表现一致。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_rect_mesh(nx, ny, sy=1.0):\n    \"\"\"\n    Build a rectangular grid mesh on [-1,1]x[-sy,sy] with nx*ny cells.\n    Returns:\n        centers: (N,2) array of cell centroids\n        verts: list of arrays of shape (4,2) for the rectangle corners (CCW)\n        faces: list of faces per cell: each face as (face_center, normal, length)\n        neighbors: list of neighbor indices [left, right, bottom, top] or -1 for boundary\n        ri_rc: array of shape (N,2) with (R_in, R_circ) per cell\n    \"\"\"\n    # Domain extents\n    x0, x1 = -1.0, 1.0\n    y0, y1 = -sy, sy\n    dx = (x1 - x0) / nx\n    dy = (y1 - y0) / ny\n\n    centers = []\n    verts = []\n    faces = []\n    neighbors = []\n    ri_rc = []\n    # We'll map cell indices to (i,j), row-major\n    def idx(i, j):\n        return j * nx + i\n\n    for j in range(ny):\n        yc = y0 + (j + 0.5) * dy\n        for i in range(nx):\n            xc = x0 + (i + 0.5) * dx\n            centers.append([xc, yc])\n            # Rectangle corners CCW: bottom-left, bottom-right, top-right, top-left\n            bl = [xc - dx/2, yc - dy/2]\n            br = [xc + dx/2, yc - dy/2]\n            tr = [xc + dx/2, yc + dy/2]\n            tl = [xc - dx/2, yc + dy/2]\n            v = np.array([bl, br, tr, tl], dtype=float)\n            verts.append(v)\n            # Faces: center, outward normal, length. Order: left, right, bottom, top\n            left_center = [xc - dx/2, yc]\n            right_center = [xc + dx/2, yc]\n            bottom_center = [xc, yc - dy/2]\n            top_center = [xc, yc + dy/2]\n            # Normals outward from cell\n            left_normal = [-1.0, 0.0]\n            right_normal = [1.0, 0.0]\n            bottom_normal = [0.0, -1.0]\n            top_normal = [0.0, 1.0]\n            left_len = dy\n            right_len = dy\n            bottom_len = dx\n            top_len = dx\n            fcs = [\n                (np.array(left_center), np.array(left_normal), left_len),\n                (np.array(right_center), np.array(right_normal), right_len),\n                (np.array(bottom_center), np.array(bottom_normal), bottom_len),\n                (np.array(top_center), np.array(top_normal), top_len),\n            ]\n            faces.append(fcs)\n            # Neighbors: left, right, bottom, top\n            nb_left = idx(i-1, j) if i-1 >= 0 else -1\n            nb_right = idx(i+1, j) if i+1  nx else -1\n            nb_bottom = idx(i, j-1) if j-1 >= 0 else -1\n            nb_top = idx(i, j+1) if j+1  ny else -1\n            neighbors.append([nb_left, nb_right, nb_bottom, nb_top])\n            # Radii: for rectangle with centroid at center\n            # Inradius = min(dx/2, dy/2), circumradius = distance to corner\n            Ri = min(dx/2.0, dy/2.0)\n            Rc = np.sqrt((dx/2.0)**2 + (dy/2.0)**2)\n            ri_rc.append([Ri, Rc])\n\n    centers = np.array(centers, dtype=float)\n    ri_rc = np.array(ri_rc, dtype=float)\n    return centers, verts, faces, neighbors, ri_rc\n\ndef least_squares_gradient(cell_idx, centers, values, neighbors):\n    \"\"\"\n    Compute least-squares gradient at cell_idx using neighbor centroids.\n    values: array of cell averages\n    Returns gradient vector (2,), and a flag for success.\n    \"\"\"\n    x_c = centers[cell_idx]\n    nb = neighbors[cell_idx]\n    M = np.zeros((2,2), dtype=float)\n    b = np.zeros(2, dtype=float)\n    count = 0\n    for k in nb:\n        if k == -1:\n            continue\n        d = centers[k] - x_c\n        # accumulate\n        M += np.outer(d, d)\n        b += d * (values[k] - values[cell_idx])\n        count += 1\n    # If fewer than 2 neighbors or singular matrix, return zero gradient\n    if count  2:\n        return np.zeros(2, dtype=float), False\n    # Regularize slightly if singular\n    det = M[0,0]*M[1,1] - M[0,1]*M[1,0]\n    if abs(det)  1e-14:\n        return np.zeros(2, dtype=float), False\n    g = np.linalg.solve(M, b)\n    return g, True\n\ndef compute_bounds(cell_idx, values, neighbors):\n    \"\"\"\n    Compute min/max bounds from cell and its neighbors.\n    \"\"\"\n    vlist = [values[cell_idx]]\n    for k in neighbors[cell_idx]:\n        if k != -1:\n            vlist.append(values[k])\n    return min(vlist), max(vlist)\n\ndef face_center_offsets(cell_idx, centers, faces):\n    \"\"\"\n    Return offsets from centroid to each face center for the given cell.\n    \"\"\"\n    x_c = centers[cell_idx]\n    offs = []\n    for fc, _, _ in faces[cell_idx]:\n        offs.append(fc - x_c)\n    return offs\n\ndef std_limiter_phi(cell_idx, centers, values, neighbors, faces, g):\n    \"\"\"\n    Conventional face-centered TVD limiter for a cell.\n    \"\"\"\n    umin, umax = compute_bounds(cell_idx, values, neighbors)\n    uc = values[cell_idx]\n    phis = []\n    for d in face_center_offsets(cell_idx, centers, faces):\n        delta = float(np.dot(g, d))\n        if delta > 0:\n            num = umax - uc\n            if delta = 1e-14:\n                phis.append(1.0)\n            else:\n                phis.append(max(0.0, min(1.0, num / delta)))\n        elif delta  0:\n            num = umin - uc\n            if delta >= -1e-14:\n                phis.append(1.0)\n            else:\n                phis.append(max(0.0, min(1.0, num / delta)))\n        else:\n            phis.append(1.0)\n    if len(phis) == 0:\n        return 0.0\n    return min(1.0, min(phis))\n\ndef geometry_aware_phi(phi_std, Ri, Rc):\n    \"\"\"\n    Geometry-aware limiter: reduce phi by min(1, Ri/Rc).\n    \"\"\"\n    if Rc  1e-14:\n        return 0.0\n    return min(phi_std, Ri / Rc)\n\ndef reconstruct_at_vertices(cell_idx, centers, values, neighbors, verts, phi, g):\n    \"\"\"\n    Compute maximum overshoot at cell vertices relative to local bounds.\n    \"\"\"\n    umin, umax = compute_bounds(cell_idx, values, neighbors)\n    uc = values[cell_idx]\n    x_c = centers[cell_idx]\n    max_overshoot = 0.0\n    for v in verts[cell_idx]:\n        u_rec = uc + phi * float(np.dot(g, (v - x_c)))\n        # Overshoot amplitude relative to [umin,umax]\n        upper_excess = max(0.0, u_rec - umax)\n        lower_excess = max(0.0, umin - u_rec)\n        delta = max(upper_excess, lower_excess)\n        if delta > max_overshoot:\n            max_overshoot = delta\n    return max_overshoot\n\ndef initial_shock_values(centers):\n    \"\"\"\n    Riemann-type initial condition: u=1 if x0, else 0.\n    \"\"\"\n    u = np.zeros(centers.shape[0], dtype=float)\n    u[centers[:,0]  0.0] = 1.0\n    return u\n\ndef run_case(nx, ny, sy, w):\n    \"\"\"\n    Build mesh, compute gradients and overshoot metrics for both limiters.\n    Returns: (overshoot_std, overshoot_geo)\n    \"\"\"\n    centers, verts, faces, neighbors, ri_rc = build_rect_mesh(nx, ny, sy)\n    values = initial_shock_values(centers)\n\n    N = centers.shape[0]\n    overs_std = 0.0\n    overs_geo = 0.0\n\n    for c in range(N):\n        g, ok = least_squares_gradient(c, centers, values, neighbors)\n        if not ok:\n            # No gradient information, no overshoot\n            continue\n        phi_std = std_limiter_phi(c, centers, values, neighbors, faces, g)\n        Ri, Rc = ri_rc[c]\n        phi_geo = geometry_aware_phi(phi_std, Ri, Rc)\n        # Evaluate overshoot at vertices\n        ostd = reconstruct_at_vertices(c, centers, values, neighbors, verts, phi_std, g)\n        ogeo = reconstruct_at_vertices(c, centers, values, neighbors, verts, phi_geo, g)\n        if ostd > overs_std:\n            overs_std = ostd\n        if ogeo > overs_geo:\n            overs_geo = ogeo\n    return overs_std, overs_geo\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (nx, ny, sy, w_x, w_y)\n        (40, 40, 1.0, 0.0, 0.0),      # Case 1: compact cells\n        (40, 40, 0.1, 0.0, 0.0),      # Case 2: extreme aspect ratio\n        (40, 40, 0.1, 0.2, 0.0),      # Case 3: extreme aspect + moving mesh velocity\n    ]\n\n    results = []\n    for nx, ny, sy, wx, wy in test_cases:\n        overs_std, overs_geo = run_case(nx, ny, sy, (wx, wy))\n        results.append(overs_std)\n        results.append(overs_geo)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3541412"}]}