{"hands_on_practices": [{"introduction": "在构建复杂的数值格式之前，我们必须首先从根本上理解高阶重构的优势。本练习[@problem_id:3514794]将通过泰勒级数分析，引导你定量地证明，将数据表示从分段常数（Godunov格式）提升到分段线性（MUSCL格式），能够如何显著提高数值通量的精度。这个推导是所有高阶方法设计的理论基石。", "problem": "考虑常数速度 $a>0$ 的线性平流方程 $u_{t} + a u_{x} = 0$，定义在具有网格中心 $x_{i}$ 和间距 $\\Delta x$ 的均匀网格上。在天体物理流体动力学中使用的有限体积离散化方法中，网格平均值 $\\bar{u}_{i}(t)$ 的半离散更新涉及每个界面 $x_{i+1/2} = x_{i} + \\tfrac{1}{2}\\Delta x$ 上的数值通量 $F_{i+1/2}$。对于 $a>0$，使用迎风格式 $F_{i+1/2} = a\\,u^{-}_{i+1/2}$，其中 $u^{-}_{i+1/2}$ 是根据 $x_{i}$ 处的网格数据在 $x_{i+1/2}$ 处构建的左偏重构状态。在光滑区域中，比较以下两种重构方法：\n\n- 分段常数 (Godunov) 方法：$u^{-}_{i+1/2} = \\bar{u}_{i}$。\n\n- 分段线性守恒律单调上游中心格式 (MUSCL)，带有一个在光滑区域中退化为中心差分斜率的总变差减小 (TVD) 限制器：$u^{-}_{i+1/2} = \\bar{u}_{i} + \\tfrac{1}{2}\\Delta x\\, s_{i}$，其中在光滑区域中 $s_{i} = \\dfrac{\\bar{u}_{i+1}-\\bar{u}_{i-1}}{2\\Delta x}$。\n\n假设 $u(x,t)$ 足够光滑，使得关于 $x_{i}$ 的泰勒展开有效，且 $\\bar{u}_{i}$ 表示精确的网格平均值 $\\bar{u}_{i} = \\dfrac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,\\mathrm{d}x$。仅使用这些基本定义和关于 $x_{i}$ 的展开式，推导每种重构方法在 $x_{i+1/2}$ 处的数值通量的主阶截断误差，即当 $\\Delta x \\to 0$ 时 $F_{i+1/2} - a\\,u(x_{i+1/2},t)$ 中的主项。根据这些主项，确定每种方法在光滑区域中数值通量的形式阶数 $p$，其定义为 $F_{i+1/2} - a\\,u(x_{i+1/2},t) = \\mathcal{O}(\\Delta x^{p})$。\n\n将您的最终答案表示为行向量 $\\left(p_{\\mathrm{Godunov}},\\,p_{\\mathrm{MUSCL}}\\right)$。无需四舍五入。最终答案必须按规定使用 LaTeX $\\mathrm{pmatrix}$ 环境以单个行向量的形式提供。", "solution": "该问题要求推导对于线性平流方程 $u_t + a u_x = 0$（其中平流速度 $a$ 为正常数），两种有限体积重构格式中数值通量 $F_{i+1/2}$ 的形式精度阶 $p$。阶数 $p$ 由解的光滑区域中的截断误差 $F_{i+1/2} - a\\,u(x_{i+1/2},t) = \\mathcal{O}(\\Delta x^p)$ 定义。分析将通过将所有量表示为泰勒级数展开来进行。\n\n当 $a > 0$ 时，数值通量由迎风公式 $F_{i+1/2} = a\\,u^{-}_{i+1/2}$ 给出，其中 $u^{-}_{i+1/2}$ 是在界面 $x_{i+1/2}$ 左侧的解的重构值。因此，通量的截断误差为 $a\\,(u^{-}_{i+1/2} - u(x_{i+1/2},t))$。分析的核心是确定重构的主阶误差 $u^{-}_{i+1/2} - u(x_{i+1/2},t)$。\n\n为此分析，我们将所有量在界面位置 $x_{i+1/2}$ 处进行泰勒级数展开。令 $z = x_{i+1/2}$ 并令 $v(x) = u(x,t)$ 表示在时间 $t$ 的精确解。目标是分析 $u^{-}_{i+1/2} - v(z)$。重构基于精确的网格平均值 $\\bar{u}_{j} = \\frac{1}{\\Delta x}\\int_{x_{j-1/2}}^{x_{j+1/2}} v(x)\\,\\mathrm{d}x$。\n\n首先，我们通过将 $v(x)$ 在 $z = x_{i+1/2}$ 处展开，来建立网格平均值 $\\bar{u}_j$ 的一般表达式。对于任意网格 $j$，其平均值由下式给出：\n$$ \\bar{u}_{j} = \\frac{1}{\\Delta x} \\int_{x_{j-1/2}}^{x_{j+1/2}} \\left( v(z) + v'(z)(x-z) + \\frac{v''(z)}{2}(x-z)^2 + \\mathcal{O}((x-z)^3) \\right) \\mathrm{d}x $$\n让我们对与 $x_{i+1/2}$ 处的重构相关的网格，即网格 $i$、$i+1$ 和 $i-1$，计算该表达式。\n\n对于网格 $i$，积分区间为 $[x_{i-1/2}, x_{i+1/2}] = [z-\\Delta x, z]$。\n$$ \\bar{u}_{i} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z-\\Delta x}^{z} $$\n$$ \\bar{u}_{i} = \\frac{1}{\\Delta x} \\left( 0 - \\left( v(z)(-\\Delta x) + \\frac{v'(z)}{2}(-\\Delta x)^2 + \\frac{v''(z)}{6}(-\\Delta x)^3 + \\dots \\right) \\right)  $$\n$$ \\bar{u}_{i} = v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\n对于网格 $i+1$，积分区间为 $[x_{i+1/2}, x_{i+3/2}] = [z, z+\\Delta x]$。\n$$ \\bar{u}_{i+1} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z}^{z+\\Delta x} $$\n$$ \\bar{u}_{i+1} = v(z) + \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\n对于网格 $i-1$，积分区间为 $[x_{i-3/2}, x_{i-1/2}] = [z-2\\Delta x, z-\\Delta x]$。\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z-2\\Delta x}^{z-\\Delta x} $$\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left( v(z)((-\\Delta x) - (-2\\Delta x)) + \\frac{v'(z)}{2}((-\\Delta x)^2 - (-2\\Delta x)^2) + \\frac{v''(z)}{6}((-\\Delta x)^3 - (-2\\Delta x)^3) + \\dots \\right) $$\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left( v(z)\\Delta x - \\frac{3}{2}v'(z)\\Delta x^2 + \\frac{7}{6}v''(z)\\Delta x^3 + \\dots \\right) $$\n$$ \\bar{u}_{i-1} = v(z) - \\frac{3}{2}v'(z)\\Delta x + \\frac{7}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\n有了这些表达式，我们现在可以分析每一种重构方法。\n\n**1. 分段常数 (Godunov) 重构**\n\nGodunov 重构直接使用网格平均值：\n$$ u^{-}_{i+1/2} = \\bar{u}_{i} $$\n重构误差为 $u^{-}_{i+1/2} - v(z) = \\bar{u}_i - v(z)$。使用我们对 $\\bar{u}_i$ 的展开式：\n$$ \\bar{u}_{i} - v(z) = \\left( v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) \\right) - v(z) $$\n$$ \\bar{u}_{i} - v(z) = -\\frac{1}{2}v'(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\n主阶误差项是 $\\Delta x$ 阶。通量的截断误差为：\n$$ F_{i+1/2} - a\\,v(z) = a(\\bar{u}_{i} - v(z)) = -\\frac{a}{2}v'(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\n这是一个 $\\mathcal{O}(\\Delta x)$ 的误差，所以 Godunov 通量的形式阶数为 $p_{\\mathrm{Godunov}} = 1$。\n\n**2. 分段线性 (MUSCL) 重构**\n\nMUSCL 重构由下式给出：\n$$ u^{-}_{i+1/2} = \\bar{u}_{i} + \\frac{1}{2}\\Delta x\\, s_{i} $$\n其中在光滑区域的斜率 $s_i$ 是 $s_{i} = \\frac{\\bar{u}_{i+1}-\\bar{u}_{i-1}}{2\\Delta x}$。首先，我们使用网格平均值的表达式来找到斜率项的展开式：\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = \\left( v(z) + \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 \\right) - \\left( v(z) - \\frac{3}{2}v'(z)\\Delta x + \\frac{7}{6}v''(z)\\Delta x^2 \\right) + \\mathcal{O}(\\Delta x^3) $$\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = \\left(\\frac{1}{2} + \\frac{3}{2}\\right) v'(z)\\Delta x + \\left(\\frac{1}{6} - \\frac{7}{6}\\right) v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = 2v'(z)\\Delta x - v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n现在，我们计算斜率 $s_i$：\n$$ s_{i} = \\frac{2v'(z)\\Delta x - v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3)}{2\\Delta x} = v'(z) - \\frac{1}{2}v''(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\n接下来，我们将 $\\bar{u}_i$ 和 $s_i$ 的展开式代入重构公式：\n$$ u^{-}_{i+1/2} = \\left( v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 \\right) + \\frac{1}{2}\\Delta x \\left( v'(z) - \\frac{1}{2}v''(z)\\Delta x \\right) + \\mathcal{O}(\\Delta x^3) $$\n$$ u^{-}_{i+1/2} = v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\frac{1}{2}v'(z)\\Delta x - \\frac{1}{4}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n包含 $v'(z)\\Delta x$ 的项相互抵消：\n$$ u^{-}_{i+1/2} = v(z) + \\left(\\frac{1}{6} - \\frac{1}{4}\\right)v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n$$ u^{-}_{i+1/2} = v(z) - \\frac{1}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n重构误差为 $u^{-}_{i+1/2} - v(z) = -\\frac{1}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3)$。主阶项是 $\\Delta x^2$ 阶。通量的截断误差为：\n$$ F_{i+1/2} - a\\,v(z) = a(u^{-}_{i+1/2} - v(z)) = -\\frac{a}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n这是一个 $\\mathcal{O}(\\Delta x^2)$ 的误差，所以 MUSCL 通量的形式阶数为 $p_{\\mathrm{MUSCL}} = 2$。\n\nGodunov 和 MUSCL 方法的数值通量阶数分别为 1 和 2。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  2\n\\end{pmatrix}\n}\n$$", "id": "3514794"}, {"introduction": "虽然高阶重构在光滑区域能提高精度，但它在激波等尖锐特征附近会引入非物理的振荡。本动手编程练习[@problem_id:3514787]将通过对比一个无限制的重构方案和一个总变差递减（TVD）限制的方案，来直观展示这一关键问题。你将亲眼见证并量化斜率极限器（slope limiter）在清晰捕捉间断时的必要性。", "problem": "考虑线性平流的标量守恒律，由 $u_t + a\\,u_x = 0$ 给出，其中平流速度 $a > 0$ 为常数。在空间域 $[0,1]$ 上的一个包含 $N$ 个单元的均匀、周期性一维网格上，使用守恒型有限体积法。单元平均值用 $u_i^n$ 表示，代表在时间层 $n$ 时单元 $i$ 上的平均值。设 $\\Delta x = 1/N$，并采用单个显式欧拉时间步，步长为 $\\Delta t = \\nu\\,\\Delta x/a$，其中库朗数 $\\nu \\in (0,1)$ 在下面指定。使用单调 Godunov（迎风）数值通量 $F_{i+1/2} = a\\,u_{i+1/2}^-$，其中左界面状态 $u_{i+1/2}^-$ 通过单元 $i$ 的分段线性重构计算得出。更新公式为\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2} - F_{i-1/2}\\right).\n$$\n重构使用斜率 $s_i$ 进行，因此\n$$\nu_{i+1/2}^- = u_i + \\frac{1}{2}\\,s_i.\n$$\n您将比较两种斜率定义：\n- 一种不满足极值原理的“过冲偏向”中心斜率（称为 $\\beta$-中心斜率）：\n$$\ns_i^{(\\beta)} = \\beta\\,\\frac{u_{i+1} - u_{i-1}}{2},\n$$\n其中放大系数 $\\beta > 0$ 是固定的。这个选择可能违反局部极值原理，因为重构的界面状态可能超出相邻单元平均值所跨越的范围。\n- 一种总变差递减（TVD）的 minmod 限制器斜率，定义为\n$$\n\\operatorname{minmod}(a,b) = \n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min(|a|,|b|),  \\text{if } ab>0,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n和\n$$\ns_i^{(\\operatorname{mm})} = \\operatorname{minmod}\\left(u_i - u_{i-1},\\,u_{i+1} - u_i\\right).\n$$\n单调迎风通量保证了通量层面的单调性；然而，违反局部极值原理的重构仍可能在间断附近产生新的下冲。\n\n从有限体积守恒更新和上述定义出发，为两种重构实现单步更新，并评估一个时间步后产生的任何新下冲的幅度。将下冲幅度定义如下。设 $L = \\inf_x u_0(x)$ 是初始数据的下界，设 $u_{\\min}^{n+1}$ 是更新后所有单元中的最小值；则下冲幅度为\n$$\n\\max\\{\\,0,\\,L - u_{\\min}^{n+1}\\,\\}.\n$$\n此量为非负值，如果没有发生下冲，则等于零。\n\n使用以下测试组。对于每个测试，取 $a = 1$，$N = 200$，库朗数 $\\nu = 0.45$，并只进行一个前向欧拉时间步，步长为 $\\Delta t = \\nu\\,\\Delta x/a$。区域是周期性的，但最终时间为一个时间步，因此在这些情况下没有波到达边界。所有初始数据都是分段常数且位于 $[0,1]$ 内，因此在每个测试中下界均为 $L = 0$：\n1. 上升阶跃：当 $x  x_0$ 时 $u_0(x) = 0$，当 $x \\ge x_0$ 时 $u_0(x) = 1$，其中 $x_0 = 0.30$（不适用于弧度或角度；$x$ 是 $[0,1]$ 上的无量纲坐标）。\n2. 下降阶跃：当 $x  x_0$ 时 $u_0(x) = 1$，当 $x \\ge x_0$ 时 $u_0(x) = 0$，其中 $x_0 = 0.70$。\n3. 方波：当 $|x - 0.50| \\le 0.20$ 时 $u_0(x) = 1$，否则 $u_0(x) = 0$。\n4. 在网格界面对齐的阶跃：当 $x  x_0$ 时 $u_0(x) = 0$，当 $x \\ge x_0$ 时 $u_0(x) = 1$，其中 $x_0$ 被选择为与某个整数 $j$ 的网格界面位置 $x_{j+1/2} = (j+1/2)\\Delta x$ 完全重合。\n\n在 $\\beta$-中心斜率中设置放大系数 $\\beta = 2.0$。对于四个测试中的每一个，计算两种重构的下冲幅度：首先是 $\\beta$-中心斜率，然后是 minmod 斜率，按此顺序进行。您的程序应生成单行输出，其中包含八个结果，格式为逗号分隔的列表并用方括号括起，顺序如下\n$$\n[\\text{bad}_1,\\text{good}_1,\\text{bad}_2,\\text{good}_2,\\text{bad}_3,\\text{good}_3,\\text{bad}_4,\\text{good}_4],\n$$\n其中 $\\text{bad}_k$ 是测试 $k$ 中 $\\beta$-中心斜率的下冲幅度，$\\text{good}_k$ 是测试 $k$ 中 minmod 斜率的下冲幅度。将每个数字表示为小数点后保留六位的小数。不涉及物理单位；所有量都是无量纲的。输出必须严格为这种指定格式的一行，不得有其他文本。程序必须完全自包含，不需要用户输入或外部数据文件。", "solution": "用户提供了一个来自计算物理领域的有效且定义明确的问题陈述。任务是在线性平流方程的有限体积法中，比较两种不同的分段线性重构格式，并量化每种格式产生的下冲。\n\n控制偏微分方程是标量线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是守恒量，$a  0$ 是恒定的平流速度。我们在一个一维周期性区域 $x \\in [0,1]$ 上使用守恒型有限体积法求解此方程。\n\n首先，我们将空间域离散化为 $N$ 个均匀单元，每个单元的宽度为 $\\Delta x = 1/N$。设单元 $i$ 为区间 $[x_{i-1/2}, x_{i+1/2}]$，其中界面位置为 $x_{i+1/2} = (i+1)\\Delta x$，对于 $i=0, \\ldots, N-1$。单元中心为 $x_i = (i+0.5)\\Delta x$。在时间 $t^n$ 时，单元 $i$ 上 $u$ 的单元平均值用 $u_i^n$ 表示。\n$$\nu_i^n \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t^n) \\, dx\n$$\n单元平均值 $u_i$ 变化率的半离散有限体积公式为：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面的数值通量。我们采用显式前向欧拉格式进行时间积分，时间步长为 $\\Delta t = \\nu \\Delta x / a$，其中 $\\nu$ 是 Courant-Friedrichs-Lewy (CFL) 数。全离散更新公式为：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n对于 $a  0$ 的线性平流方程，信息从左向右传播。Godunov（迎风）通量由界面左侧的状态决定，记为 $u_{i+1/2}^-$。通量为 $F_{i+1/2} = a u_{i+1/2}^-$。状态 $u_{i+1/2}^-$ 是通过在单元 $i$ 内进行分段线性重构得到的。\n$$\nu(x) = u_i^n + s_i \\frac{x - x_i}{\\Delta x} \\quad \\text{for } x \\in [x_{i-1/2}, x_{i+1/2}]\n$$\n其中 $s_i$ 是单元 $i$ 中的斜率。在右界面 $x_{i+1/2} = x_i + \\Delta x/2$ 处对此进行求值，我们得到重构状态：\n$$\nu_{i+1/2}^- = u_i^n + \\frac{1}{2} s_i\n$$\n单元 $i$ 左界面的通量 $F_{i-1/2}$ 由单元 $i-1$ 中的重构决定，因此 $F_{i-1/2} = a u_{i-1/2}^- = a (u_{i-1}^n + \\frac{1}{2}s_{i-1})$。将这些通量表达式代入更新公式，并使用 $\\nu = a \\Delta t / \\Delta x$，我们得到：\n$$\nu_i^{n+1} = u_i^n - \\nu \\left[ \\left(u_i^n + \\frac{1}{2}s_i\\right) - \\left(u_{i-1}^n + \\frac{1}{2}s_{i-1}\\right) \\right]\n$$\n该公式将用于单个时间步的实现。\n\n比较了两种斜率定义：\n1.  $\\beta=2.0$ 的 $\\beta$-中心斜率：这是一个无限制的中心差分斜率。\n    $$\n    s_i^{(\\beta)} = \\beta \\frac{u_{i+1}^n - u_{i-1}^n}{2} = u_{i+1}^n - u_{i-1}^n\n    $$\n    这种重构在空间上是形式二阶精度的，但已知它不保持单调性，导致在间断附近出现虚假的振荡（下冲和过冲）。\n\n2.  minmod 限制器斜率：这是一种总变差递减（TVD）斜率限制器。\n    $$\n    s_i^{(\\operatorname{mm})} = \\operatorname{minmod}(u_i^n - u_{i-1}^n, u_{i+1}^n - u_i^n)\n    $$\n    其中 $\\operatorname{minmod}$ 函数定义为：\n    $$\n    \\operatorname{minmod}(a,b) = \n    \\begin{cases}\n    \\operatorname{sign}(a)\\,\\min(|a|,|b|),  \\text{if } ab0,\\\\\n    0,  \\text{otherwise}.\n    \\end{cases}\n    $$\n    如果前向和后向差分斜率符号相同，此限制器选择其中较小的一个；否则选择零斜率。这防止了新局部极值的引入，确保了格式是 TVD 并且没有振荡，代价是在极值和间断点处精度降至一阶。\n\n对于每个测试用例，我们首先在 $t=0$ 时初始化单元平均值 $u_i^n$。对于分段常数初始条件 $u_0(x)$，单元平均值为 $u_i^n = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} u_0(x) \\, dx$。\n- 对于测试 1、2 和 3，$u_0(x)$ 的间断点位于 $x=0.30=60\\Delta x$ 和/或 $x=0.70=140\\Delta x$，这些是单元界面。因此，初始单元平均值 $u_i^n$ 全为 $0$ 或 $1$。\n- 对于测试 4，间断点位于 $x_0 = (j+1/2)\\Delta x$，其中 $j$ 为整数。我们选择 $j=60$，将阶跃置于单元 60 的中心。这导致 $u_{60}^n=0.5$，而所有其他单元初始化为 $0$ 或 $1$。\n\n在为两种斜率方法计算出所有 $i=0, \\ldots, N-1$ 的 $u_i^{n+1}$ 后，我们量化下冲。所有测试的初始数据下界为 $L=0$。下冲幅度定义为：\n$$\n\\max\\{0, L - u_{\\min}^{n+1}\\} = \\max\\{0, -\\min_i u_i^{n+1}\\}\n$$\n只有当更新后的解中包含一个小于初始最小值 $0$ 的单元平均值时，此量才为正。\n\n数值实现过程如下：\n- 设置参数：$N=200$，$a=1$，$\\nu=0.45$，$\\beta=2.0$。\n- 对于四个测试用例中的每一个：\n    - 根据测试用例的 $u_0(x)$ 初始化数组 $u_i^n$。\n    - 对于 $\\beta$-中心斜率：\n        - 使用周期性边界条件（例如 $u_{-1}=u_{N-1}$）计算所有单元的斜率 $s_i^{(\\beta)}$。\n        - 应用更新公式求得 $u_i^{n+1}$。\n        - 计算并存储下冲幅度。\n    - 对于 minmod 斜率：\n        - 使用周期性边界计算所有单元的斜率 $s_i^{(\\operatorname{mm})}$。\n        - 应用更新公式求得 $u_i^{n+1}$。\n        - 计算并存储下冲幅度。\n- 收集八个结果并格式化为逗号分隔的列表。正如 TVD 格式理论所预测的，minmod 限制器应该不会产生下冲，因此在所有情况下下冲幅度都为 $0$。无限制的中心斜率预计会产生显著的下冲。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating undershoot magnitudes for two reconstruction\n    schemes in a finite volume method for linear advection.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 200\n    a = 1.0\n    nu = 0.45  # Courant number\n    beta = 2.0  # Amplification for the central slope\n\n    # --- Discretization ---\n    dx = 1.0 / N\n\n    def minmod(a, b):\n        \"\"\"\n        Vectorized minmod function.\n        \"\"\"\n        ab = a * b\n        s = np.sign(a)\n        abs_res = np.minimum(np.abs(a), np.abs(b))\n        return np.where(ab  0, s * abs_res, 0.0)\n\n    def compute_undershoot(u_init, slope_type, N, nu, beta_val=None):\n        \"\"\"\n        Performs a single time step and computes the undershoot magnitude.\n        \"\"\"\n        u = u_init.copy()\n\n        # Get neighboring cell values using periodic boundaries\n        u_p1 = np.roll(u, -1)  # u_{i+1}\n        u_m1 = np.roll(u, 1)   # u_{i-1}\n\n        # --- 1. Slope Calculation ---\n        if slope_type == 'beta':\n            # s_i = beta * (u_{i+1} - u_{i-1}) / 2\n            s = beta_val * (u_p1 - u_m1) / 2.0\n        elif slope_type == 'minmod':\n            # s_i = minmod(u_i - u_{i-1}, u_{i+1} - u_i)\n            # Forward and backward differences\n            d_forward = u_p1 - u\n            d_backward = u - u_m1\n            s = minmod(d_backward, d_forward)\n        else:\n            raise ValueError(\"Invalid slope type specified.\")\n\n        # --- 2. Flux Calculation ---\n        # Reconstruct state at the right interface of each cell\n        # u_{i+1/2}^- = u_i + s_i / 2\n        u_interface = u + s / 2.0\n        \n        # Flux at the left interface of cell i is the right flux of cell i-1\n        u_interface_m1 = np.roll(u_interface, 1)\n\n        # Godunov flux for a > 0 (upwind)\n        # F_{i+1/2} = a * u_{i+1/2}^-\n        F_iphalf = a * u_interface\n        # F_{i-1/2} = a * u_{i-1/2}^-\n        F_imhalf = a * u_interface_m1\n\n\n        # --- 3. Update Cell Averages ---\n        # u_i^{n+1} = u_i^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n        # Note: nu = a * dt / dx\n        u_new = u - (nu / a) * (F_iphalf - F_imhalf)\n\n        # --- 4. Calculate Undershoot ---\n        # L = 0 for all test cases\n        L = 0.0\n        u_min_new = np.min(u_new)\n        undershoot = np.maximum(L, L - u_min_new)\n\n        return undershoot\n\n    # --- Test Cases ---\n    \n    # Test Case 1: Upward jump at interface x=0.3\n    # Discontinuity is at 0.3 / dx = 60. Interface between cells 59 and 60.\n    j_jump1 = int(0.3 / dx)\n    u1 = np.zeros(N)\n    u1[j_jump1:] = 1.0\n\n    # Test Case 2: Downward jump at interface x=0.7\n    # Discontinuity is at 0.7 / dx = 140. Interface between cells 139 and 140.\n    j_jump2 = int(0.7 / dx)\n    u2 = np.ones(N)\n    u2[j_jump2:] = 0.0\n\n    # Test Case 3: Block from x=0.3 to x=0.7\n    j_left = int(0.3 / dx)\n    j_right = int(0.7 / dx)\n    u3 = np.zeros(N)\n    u3[j_left:j_right] = 1.0\n\n    # Test Case 4: Upward jump aligned at a cell center.\n    # Problem states \"aligned with some integer j's grid interface location x_{j+1/2}\"\n    # This is a bit ambiguous. Let's assume they mean it's at an interface, like Case 1.\n    # The wording \"x_0 is chosen to be exactly coincident with some integer j's grid interface location\"\n    # means x_0 = (j+1)*dx. Let's take j=60, x_0 = 61*dx = 0.305.\n    # This leads to an initial condition where one cell is partially filled.\n    # However, the problem text for all cases states \"All initial data are piecewise constant\".\n    # And the solution text states: \"initial cell averages u_i^n are all either 0 or 1.\"\n    # and then mentions test 4 as an exception with one cell being 0.5. Let's follow the solution text's interpretation.\n    # \"where x_0 is chosen to be exactly coincident with some integer j's grid *interface* location x_{j+1/2}\" -> This means x_0 = (j+0.5) * dx.\n    # This creates a split cell. Wait, the problem says \"grid *interface* location x_{j+1/2} = (j+1/2)dx\". Let's assume cell centers are at (i+0.5)dx and interfaces are at i*dx.\n    # No, that's not standard. Standard is cell i is [x_{i-1/2}, x_{i+1/2}] with x_{i+1/2} = (i+1)dx.\n    # The problem description is slightly confusing. Let's stick with the code's interpretation in the provided solution text: a jump at a cell *center*.\n    # So we take `x0` to be a cell center, e.g., `x0 = (j+0.5)*dx`.\n    # Let's take `j=60`.\n    u4 = np.zeros(N)\n    j_center_idx = 60 # Cell index for the jump\n    u4[j_center_idx+1:] = 1.0\n    u4[j_center_idx] = 0.5 # The cell containing the jump has an average value of 0.5\n\n    test_initial_conditions = [u1, u2, u3, u4]\n    results = []\n\n    for u_init in test_initial_conditions:\n        # Calculate undershoot for the beta-central slope (\"bad\" scheme)\n        undershoot_beta = compute_undershoot(u_init, 'beta', N, nu, beta_val=beta)\n        results.append(f\"{undershoot_beta:.6f}\")\n        \n        # Calculate undershoot for the minmod slope (\"good\" scheme)\n        undershoot_minmod = compute_undershoot(u_init, 'minmod', N, nu)\n        results.append(f\"{undershoot_minmod:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3514787"}, {"introduction": "TVD格式虽然稳健，但其精度通常被限制在二阶。为了在保持非振荡特性的同时达到更高阶的精度，我们转向加权基本非振荡（WENO）格式。本练习[@problem_id:3514861]将聚焦于实现WENO5算法的核心——对子模板重构进行非线性加权——这是即使在存在激波时也能实现高阶精度的关键技术。", "problem": "考虑一维线性平流守恒律\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\n该定律描述了在间距为 $\\Delta x$ 的均匀网格上，具有恒定平流速度 $a$ 的情况，并采用有限体积表示法，其单元平均值为 $\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx$。在计算天体物理学的高分辨率激波捕捉方法中，单元交界面处的数值通量是通过高阶无振荡重构来构造的。加权基本无振荡 (WENO) 格式旨在在光滑区域保持高阶精度，同时避免在间断附近产生伪振荡。带有斜率限制器的总变差递减 (TVD) 格式也能实现类似目标，但仅限于较低阶精度；WENO 格式通过基于光滑度指示子的非线性权推广了这一概念。\n\n从守恒型有限体积公式和适用于平流的迎风偏置要求出发，使用 Lax-Friedrichs 通量分裂将物理通量 $f(u)=a u$ 写为 $f(u)=f^+(u)+f^-(u)$，其中\n$$\nf^\\pm(u) = \\frac{1}{2}\\left(f(u)\\pm \\alpha u\\right),\\quad \\alpha = |a|.\n$$\n对于 $a\\ge 0$ 和均匀网格的情况，左偏置状态 $u_{i+1/2}^-$ 是使用一个五阶 WENO 过程从单元平均值 $\\{\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}\\}$ 重构的。该过程基于三个重叠的子模板和从 Jiang–Shu 光滑度指示子派生的非线性权。用于数值正则化的小参数必须设置为 $\\varepsilon = 10^{-6}$，权指数设置为 $p=2$。假设使用适用于均匀网格的标准线性权。每个给定数据集的最终目标量是重构的左交界面状态 $u_{i+1/2}^-$，表示为一个浮点数。\n\n您的任务是实现一个完整的、可运行的程序，该程序针对每个测试用例，接收给定的五个单元平均值 $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2})$，并计算出单个重构值 $u_{i+1/2}^-$。平流速度应取为 $a=1$（无量纲），您应在概念上使用 Lax-Friedrichs 通量分裂来证明迎风偏置的左重构的合理性，但要求的输出是重构的左状态 $u_{i+1/2}^-$ 本身。不涉及物理单位；所有量均为无量纲实数。不出现角度。不出现百分比。\n\n以一种普遍适用于任何现代编程语言的方式实现该算法。网格、$a$、$\\varepsilon$ 和 $p$ 的具体值已如上固定。使用以下离散数据集测试套件：\n\n- 案例 1：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (0.1,\\,0.2,\\,0.3,\\,0.4,\\,0.5)$。\n- 案例 2：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (\\sin(-2),\\,\\sin(-1),\\,\\sin(0),\\,\\sin(1),\\,\\sin(2))$，使用标准正弦函数（弧度），数值上为 $( -0.9092974268256817,\\,-0.8414709848078965,\\,0.0,\\,0.8414709848078965,\\,0.9092974268256817)$。\n- 案例 3：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.0)$。\n- 案例 4：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (0.7,\\,0.7,\\,0.7,\\,0.7,\\,0.7)$。\n- 案例 5：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (1.0,\\,0.0,\\,-1.0,\\,0.0,\\,1.0)$。\n\n您的程序应生成单行输出，其中包含五个案例的重构值，格式为方括号内以逗号分隔的列表，顺序如上所示，例如\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5].\n$$\n所有输出必须是浮点数。不应打印任何其他文本。", "solution": "该问题要求计算在单元交界面处状态变量 $u$ 的一个左偏置、五阶加权基本无振荡 (WENO) 重构，记为 $u_{i+1/2}^-$。所提供的背景是在均匀网格上的一维线性平流方程 $\\partial_t u + a\\,\\partial_x u = 0$，这是计算天体物理学中遇到的双曲守恒律的原型。对于正的平流速度 $a  0$，迎风偏置的有限体积格式需要重构交界面 $x_{i+1/2}$ 左侧的状态以计算数值通量。问题指定 $a=1$，这证实了计算 $u_{i+1/2}^-$ 的必要性。\n\n重构将使用一个由单元平均数据组成的五点模板 $\\{\\bar{u}_{i-2}, \\bar{u}_{i-1}, \\bar{u}_{i}, \\bar{u}_{i+1}, \\bar{u}_{i+2}\\}$ 来执行。五阶 WENO 过程，特别是 Jiang and Shu 提出的 WENO-JS 格式，通过形成几个低阶重构的非线性组合，在光滑区域实现高精度，并防止在间断处产生伪振荡。\n\n该过程如下：\n\n1.  **子模板重构**：将五点模板划分为三个重叠的三点子模板，$S_k$，$k \\in \\{0,1,2\\}$：\n    -   $S_0 = \\{\\bar{u}_{i-2}, \\bar{u}_{i-1}, \\bar{u}_{i}\\}$\n    -   $S_1 = \\{\\bar{u}_{i-1}, \\bar{u}_{i}, \\bar{u}_{i+1}\\}$\n    -   $S_2 = \\{\\bar{u}_{i}, \\bar{u}_{i+1}, \\bar{u}_{i+2}\\}$\n\n    在每个子模板 $S_k$ 上，构造一个二次多项式 $p_k(x)$，其在交界面 $x_{i+1/2}$ 处的值提供了一个三阶精度的候选重构，$u_{i+1/2, k}^- = p_k(x_{i+1/2})$。在均匀网格上，这些重构的标准公式为：\n    $$\n    \\begin{aligned}\n    u_{i+1/2, 0}^- = \\frac{1}{3}\\bar{u}_{i-2} - \\frac{7}{6}\\bar{u}_{i-1} + \\frac{11}{6}\\bar{u}_{i} \\\\\n    u_{i+1/2, 1}^- = -\\frac{1}{6}\\bar{u}_{i-1} + \\frac{5}{6}\\bar{u}_{i} + \\frac{1}{3}\\bar{u}_{i+1} \\\\\n    u_{i+1/2, 2}^- = \\frac{1}{3}\\bar{u}_{i} + \\frac{5}{6}\\bar{u}_{i+1} - \\frac{1}{6}\\bar{u}_{i+2}\n    \\end{aligned}\n    $$\n\n2.  **光滑度指示子**：为了衡量每个子模板中是否存在间断，需要计算光滑度指示子 $IS_k$。这些指示子基于重构多项式 $p_k(x)$ 的缩放导数的平方和。对于 WENO5 格式，标准的 Jiang-Shu 指示子为：\n    $$\n    \\begin{aligned}\n    IS_0 = \\frac{13}{12}(\\bar{u}_{i-2} - 2\\bar{u}_{i-1} + \\bar{u}_i)^2 + \\frac{1}{4}(\\bar{u}_{i-2} - 4\\bar{u}_{i-1} + 3\\bar{u}_i)^2 \\\\\n    IS_1 = \\frac{13}{12}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1})^2 + \\frac{1}{4}(\\bar{u}_{i-1} - \\bar{u}_{i+1})^2 \\\\\n    IS_2 = \\frac{13}{12}(\\bar{u}_i - 2\\bar{u}_{i+1} + \\bar{u}_{i+2})^2 + \\frac{1}{4}(3\\bar{u}_i - 4\\bar{u}_{i+1} + \\bar{u}_{i+2})^2\n    \\end{aligned}\n    $$\n\n3.  **非线性权**：最终的重构是候选重构 $u_{i+1/2, k}^-$ 的凸组合。权 $\\omega_k$ 的计算方式使得来自更光滑模板（$IS_k$ 值较小）的重构具有更大的影响。首先，使用标准线性权 $d_k$、光滑度指示子 $IS_k$、小正则化参数 $\\varepsilon$ 和指数 $p$ 计算未归一化的权 $\\alpha_k$：\n    $$\n    \\alpha_k = \\frac{d_k}{(IS_k + \\varepsilon)^p}\n    $$\n    问题指定 $\\varepsilon = 10^{-6}$ 和 $p=2$。为实现 $u_{i+1/2}^-$ 重构的五阶精度，标准线性权为 $d_0=0.1$，$d_1=0.6$ 和 $d_2=0.3$。这些权的和为 1。\n\n    最终的非线性权 $\\omega_k$ 通过对 $\\alpha_k$ 进行归一化得到：\n    $$\n    \\omega_k = \\frac{\\alpha_k}{\\sum_{j=0}^{2} \\alpha_j}\n    $$\n\n4.  **最终重构**：交界面处的 WENO5 重构值是候选重构的加权平均：\n    $$\n    u_{i+1/2}^- = \\sum_{k=0}^{2} \\omega_k u_{i+1/2, k}^-\n    $$\n\n该算法是确定性的，对于给定的五个输入单元平均值，它提供一个单一的 $u_{i+1/2}^-$ 数值。实现将系统地将这些公式应用于每个提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the fifth-order WENO reconstruction for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Linear data\n        (0.1, 0.2, 0.3, 0.4, 0.5),\n        # Case 2: Sine function\n        (math.sin(-2.0), math.sin(-1.0), math.sin(0.0), math.sin(1.0), math.sin(2.0)),\n        # Case 3: Step function (discontinuity)\n        (1.0, 1.0, 1.0, 0.0, 0.0),\n        # Case 4: Constant data\n        (0.7, 0.7, 0.7, 0.7, 0.7),\n        # Case 5: Oscillatory data\n        (1.0, 0.0, -1.0, 0.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = weno5_reconstruct(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\ndef weno5_reconstruct(u_stencil):\n    \"\"\"\n    Calculates the 5th order WENO reconstruction u_{i+1/2}^-\n    from a 5-point stencil of cell averages.\n\n    Args:\n        u_stencil: A tuple or list of 5 floating-point numbers representing\n                   (u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}).\n\n    Returns:\n        The reconstructed value at the interface u_{i+1/2}^-.\n    \"\"\"\n    u_im2, u_im1, u_i, u_ip1, u_ip2 = u_stencil\n    \n    # WENO parameters as specified in the problem\n    epsilon = 1e-6\n    p = 2\n    \n    # Canonical linear weights for u_{i+1/2}^-\n    d = np.array([0.1, 0.6, 0.3])\n\n    # Sub-stencil reconstructions (3rd order)\n    u_rec = np.array([\n        (1/3)*u_im2 - (7/6)*u_im1 + (11/6)*u_i,\n        (-1/6)*u_im1 + (5/6)*u_i + (1/3)*u_ip1,\n        (1/3)*u_i + (5/6)*u_ip1 - (1/6)*u_ip2\n    ])\n\n    # Jiang-Shu smoothness indicators\n    IS = np.array([\n        (13/12)*(u_im2 - 2*u_im1 + u_i)**2 + (1/4)*(u_im2 - 4*u_im1 + 3*u_i)**2,\n        (13/12)*(u_im1 - 2*u_i + u_ip1)**2 + (1/4)*(u_im1 - u_ip1)**2,\n        (13/12)*(u_i - 2*u_ip1 + u_ip2)**2 + (1/4)*(3*u_i - 4*u_ip1 + u_ip2)**2\n    ])\n    \n    # Un-normalized nonlinear weights\n    alpha = d / (IS + epsilon)**p\n    \n    # Normalized nonlinear weights\n    omega = alpha / np.sum(alpha)\n    \n    # Final reconstructed value\n    u_reconstructed = np.dot(omega, u_rec)\n    \n    return u_reconstructed\n\nsolve()\n```", "id": "3514861"}]}