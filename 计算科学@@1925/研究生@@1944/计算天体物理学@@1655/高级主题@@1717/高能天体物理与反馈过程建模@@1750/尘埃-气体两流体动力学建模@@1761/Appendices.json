{"hands_on_practices": [{"introduction": "任何尘埃-气体动力学模拟的出发点都是阻力。本练习将对最简单的情形进行建模：在均匀气体中单个尘埃包裹的运动。您将探索不同阻力定律下相对速度衰减的解析解和数值解。这项基础实践旨在磨练您对照解析解验证数值代码以及量化不同数值误差来源的核心计算科学技能。[@problem_id:3519080]", "problem": "要求您验证在一维情况下，尘埃包裹与气体在阻力作用下相对速度时间演化的 Dustybox 模型，并量化两种不同的数值误差来源：时间积分误差和插值误差。考虑两种阻力定律：线性（类 Stokes）阻力和二次（高雷诺数）阻力。您的出发点必须是应用于尘埃-气体系统的 Newton 第二定律以及相对速度的定义，并且您必须在一个气体速度在空间上均匀且不随时间变化的体系中进行分析。一维相对速度用 $w(t)$ 表示，初始条件为 $w(0)=w_0$，单位为 $\\mathrm{m\\,s^{-1}}$，时间 $t$ 的单位为 $\\mathrm{s}$。对于线性阻力，阻力系数为 $\\lambda$，单位为 $\\mathrm{s^{-1}}$。对于二次阻力，系数为 $\\alpha$，单位为 $\\mathrm{m^{-1}}$。\n\n1) 使用 Newton 第二定律为每种阻力定律下的相对速度动力学建模：\n- 线性阻力：写出关于 $w(t)$ 的常微分方程（Ordinary Differential Equation (ODE)），用 $\\lambda$ 表示。\n- 二次阻力：写出关于 $w(t)$ 的常微分方程，用 $\\alpha$ 表示。\n\n2) 从第一性原理出发，推导每种情况下的解析解 $w(t)$。您必须推导并使用正确的函数依赖关系：\n- 对于线性阻力，精确解必须用 $w_0$、$\\lambda$ 和 $t$ 表示。\n- 对于二次阻力，精确解必须用 $w_0$、$\\alpha$ 和 $t$ 表示，并且必须一致地处理 $w_0>0$ 和 $w_00$ 两种情况。\n\n3) 为两种阻力定律实现一个 $w(t)$ 的前向 Euler 时间积分器，使用恒定的时间步长 $\\Delta t$（单位为 $\\mathrm{s}$），从 $t=0$ 推进到指定的最终时间 $t_{\\mathrm{end}}$（单位为 $\\mathrm{s}$）。如果 $t_{\\mathrm{end}}$ 不是 $\\Delta t$ 的整数倍，则必须截断最后一个时间步长以精确达到 $t_{\\mathrm{end}}$。\n\n4) 定义并计算两个无量纲的误差度量：\n- 时间积分误差 $\\varepsilon_{\\mathrm{time}}$：数值解与在前向 Euler 方法使用的离散积分器时间样本 $\\{t_n\\}$ 处计算的精确解析解之间的最大绝对相对误差。形式上，\n$$\n\\varepsilon_{\\mathrm{time}}=\\max_n \\frac{\\left|w_{\\mathrm{num}}(t_n)-w_{\\mathrm{exact}}(t_n)\\right|}{\\max\\left(\\left|w_{\\mathrm{exact}}(t_n)\\right|,\\epsilon\\right)},\n$$\n其中 $\\epsilon$ 是一个用于避免除以零的小下限值；设 $\\epsilon=10^{-12}\\ \\mathrm{m\\,s^{-1}}$。\n- 插值误差 $\\varepsilon_{\\mathrm{interp}}$：在中间点 $t_{n+\\frac{1}{2}}=\\frac{1}{2}\\left(t_n+t_{n+1}\\right)$ 处，精确端点值的线性插值与中间点处的精确解析值之间的最大绝对相对误差。形式上，\n$$\nw_{\\mathrm{lin}}(t_{n+\\frac{1}{2}})=\\frac{1}{2}\\left[w_{\\mathrm{exact}}(t_n)+w_{\\mathrm{exact}}(t_{n+1})\\right],\\quad\n\\varepsilon_{\\mathrm{interp}}=\\max_n \\frac{\\left|w_{\\mathrm{lin}}(t_{n+\\frac{1}{2}})-w_{\\mathrm{exact}}(t_{n+\\frac{1}{2}})\\right|}{\\max\\left(\\left|w_{\\mathrm{exact}}(t_{n+\\frac{1}{2}})\\right|,\\epsilon\\right)}.\n$$\n\n5) 测试套件。您的程序必须评估以下五组参数，并为每组参数报告配对 $[\\varepsilon_{\\mathrm{time}},\\varepsilon_{\\mathrm{interp}}]$：\n- 情况 A（线性阻力，良好解析）：$w_0=10\\ \\mathrm{m\\,s^{-1}}$, $\\lambda=2\\ \\mathrm{s^{-1}}$, $t_{\\mathrm{end}}=1\\ \\mathrm{s}$, $\\Delta t=0.1\\ \\mathrm{s}$。\n- 情况 B（线性阻力，粗略步长接近稳定性边界）：$w_0=10\\ \\mathrm{m\\,s^{-1}}$, $\\lambda=2\\ \\mathrm{s^{-1}}$, $t_{\\mathrm{end}}=1\\ \\mathrm{s}$, $\\Delta t=0.95\\ \\mathrm{s}$。\n- 情况 C（二次阻力，良好解析）：$w_0=10\\ \\mathrm{m\\,s^{-1}}$, $\\alpha=0.1\\ \\mathrm{m^{-1}}$, $t_{\\mathrm{end}}=1\\ \\mathrm{s}$, $\\Delta t=0.05\\ \\mathrm{s}$。\n- 情况 D（二次阻力，粗略步长）：$w_0=10\\ \\mathrm{m\\,s^{-1}}$, $\\alpha=0.1\\ \\mathrm{m^{-1}}$, $t_{\\mathrm{end}}=1\\ \\mathrm{s}$, $\\Delta t=0.5\\ \\mathrm{s}$。\n- 情况 E（二次阻力，负初始速度）：$w_0=-5\\ \\mathrm{m\\,s^{-1}}$, $\\alpha=0.2\\ \\mathrm{m^{-1}}$, $t_{\\mathrm{end}}=2\\ \\mathrm{s}$, $\\Delta t=0.1\\ \\mathrm{s}$。\n\n6) 最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个条目是一个双元素列表，对应一个情况的两个误差，顺序为 $[\\varepsilon_{\\mathrm{time}},\\varepsilon_{\\mathrm{interp}}]$，与上述情况的顺序相同。例如，输出应如下所示\n\"[[x_A_time,x_A_interp],[x_B_time,x_B_interp],[x_C_time,x_C_interp],[x_D_time,x_D_interp],[x_E_time,x_E_interp]]\"\n其中每个 $x$ 是一个浮点值（无量纲）。不应打印任何额外文本。", "solution": "该问题要求在两种不同的阻力定律下，验证一维尘埃-气体相对速度模型，并量化两种不同的数值误差：来自前向 Euler 格式的时间积分误差和来自线性近似的插值误差。分析从第一性原理开始。\n\n### 1. 源于第一性原理的控制方程\n\n设尘埃包裹和气体的一维速度分别为 $v_d(t)$ 和 $v_g(t)$。相对速度定义为 $w(t) = v_d(t) - v_g(t)$。问题陈述气体速度是恒定的，因此 $\\frac{dv_g}{dt} = 0$。相对速度的变化率则完全由尘埃的加速度决定：\n$$\n\\frac{dw}{dt} = \\frac{d}{dt}(v_d - v_g) = \\frac{dv_d}{dt} - \\frac{dv_g}{dt} = \\frac{dv_d}{dt}\n$$\n对于质量为 $m_d$ 的尘埃颗粒，Newton 第二定律指出其加速度是由气体施加的阻力 $F_{drag}$ 引起的：\n$$\nm_d \\frac{dv_d}{dt} = F_{drag}\n$$\n结合这些，我们得到相对速度的控制方程：\n$$\n\\frac{dw}{dt} = \\frac{1}{m_d} F_{drag}\n$$\n阻力总是与相对运动方向相反，即其方向与 $w$ 的符号相反。\n\n**线性阻力（类 Stokes）：**\n对于低雷诺数，阻力与相对速度成线性比例，$F_{drag} = -K w$，其中 $K$ 是一个正常数。将其代入运动方程得到：\n$$\n\\frac{dw}{dt} = -\\frac{K}{m_d} w\n$$\n我们定义阻力系数 $\\lambda = K/m_d$，其单位为 $\\mathrm{s^{-1}}$。线性阻力的最终常微分方程（ODE）是：\n$$\n\\frac{dw}{dt} = -\\lambda w\n$$\n\n**二次阻力：**\n对于高雷诺数，阻力与相对速度的平方成正比。为确保力始终与运动方向相反，它表示为 $F_{drag} = -C w|w|$，其中 $C$ 是一个正常数。这种形式等价于 $-C \\cdot \\mathrm{sgn}(w) \\cdot w^2$。运动方程变为：\n$$\n\\frac{dw}{dt} = -\\frac{C}{m_d} w|w|\n$$\n我们定义阻力系数 $\\alpha = C/m_d$，其单位为 $\\mathrm{m^{-1}}$。二次阻力的最终 ODE 是：\n$$\n\\frac{dw}{dt} = -\\alpha w|w|\n$$\n\n### 2. 解析解\n\n我们将这些 ODE 作为初始值问题求解，条件为 $w(t=0) = w_0$。\n\n**线性阻力解：**\nODE $\\frac{dw}{dt} = -\\lambda w$ 是一个可分离的一阶微分方程。\n$$\n\\frac{1}{w} dw = -\\lambda dt\n$$\n将两边从初始状态 $(0, w_0)$ 积分到一般状态 $(t, w(t))$：\n$$\n\\int_{w_0}^{w(t)} \\frac{1}{\\tilde{w}} d\\tilde{w} = \\int_{0}^{t} -\\lambda d\\tilde{t}\n$$\n$$\n[\\ln|\\tilde{w}|]_{w_0}^{w(t)} = -[\\lambda \\tilde{t}]_{0}^{t}\n$$\n$$\n\\ln|w(t)| - \\ln|w_0| = -\\lambda t \\implies \\ln\\left|\\frac{w(t)}{w_0}\\right| = -\\lambda t\n$$\n由于 $w(t)$ 只能渐近地达到零（对于 $w_0 \\neq 0$），其符号保持恒定且与 $w_0$ 的符号相同。因此，我们可以去掉绝对值符号。\n$$\n\\frac{w(t)}{w_0} = e^{-\\lambda t} \\implies w(t) = w_0 e^{-\\lambda t}\n$$\n\n**二次阻力解：**\nODE 为 $\\frac{dw}{dt} = -\\alpha w|w|$。这也是可分离的，但我们必须考虑 $w$ 的符号。\n\n情况 1: $w_0 > 0$。由于阻力不能改变速度的符号，$w(t) > 0$ 对于所有 $t \\geq 0$ 成立。因此， $|w|=w$。\n$$\n\\frac{dw}{dt} = -\\alpha w^2 \\implies \\frac{1}{w^2}dw = -\\alpha dt\n$$\n从 $(0, w_0)$ 积分到 $(t, w(t))$：\n$$\n\\int_{w_0}^{w(t)} \\frac{1}{\\tilde{w}^2} d\\tilde{w} = \\int_{0}^{t} -\\alpha d\\tilde{t}\n$$\n$$\n\\left[-\\frac{1}{\\tilde{w}}\\right]_{w_0}^{w(t)} = -\\alpha t \\implies -\\frac{1}{w(t)} + \\frac{1}{w_0} = -\\alpha t\n$$\n$$\n\\frac{1}{w(t)} = \\frac{1}{w_0} + \\alpha t = \\frac{1 + \\alpha w_0 t}{w_0} \\implies w(t) = \\frac{w_0}{1 + \\alpha w_0 t}\n$$\n\n情况 2: $w_0  0$。在这种情况下，$w(t)  0$ 对于所有 $t \\geq 0$ 成立，所以 $|w|=-w$。\n$$\n\\frac{dw}{dt} = -\\alpha w(-w) = \\alpha w^2 \\implies \\frac{1}{w^2}dw = \\alpha dt\n$$\n类似地积分：\n$$\n\\left[-\\frac{1}{\\tilde{w}}\\right]_{w_0}^{w(t)} = \\alpha t \\implies -\\frac{1}{w(t)} + \\frac{1}{w_0} = \\alpha t\n$$\n$$\n\\frac{1}{w(t)} = \\frac{1}{w_0} - \\alpha t = \\frac{1 - \\alpha w_0 t}{w_0} \\implies w(t) = \\frac{w_0}{1 - \\alpha w_0 t}\n$$\n\n这两种情况可以统一成一个表达式。对于 $w_0 > 0$，有 $|w_0|=w_0$。对于 $w_0  0$，有 $|w_0|=-w_0$。第二种情况下的分母是 $1 - \\alpha w_0 t = 1 + \\alpha (-w_0) t = 1 + \\alpha |w_0| t$。第一种情况下的分母是 $1 + \\alpha w_0 t = 1 + \\alpha |w_0| t$。因此，对于任何 $w_0 \\neq 0$，解是：\n$$\nw(t) = \\frac{w_0}{1 + \\alpha |w_0| t}\n$$\n如果 $w_0=0$，这个公式也正确地得出 $w(t)=0$。\n\n### 3. 数值积分格式：前向 Euler\n\n前向 Euler 方法是用于形如 $\\frac{dw}{dt} = f(t, w)$ 的 ODE 的一种显式一阶积分器。给定在时间 $t_n$ 的值 $w_n$，在时间 $t_{n+1} = t_n + \\Delta t$ 的值 $w_{n+1}$ 近似为：\n$$\nw_{n+1} = w_n + \\Delta t \\cdot f(t_n, w_n)\n$$\n- 对于线性阻力，$f(w) = -\\lambda w$，因此更新规则是 $w_{n+1} = w_n + \\Delta t(-\\lambda w_n) = w_n(1 - \\lambda \\Delta t)$。\n- 对于二次阻力，$f(w) = -\\alpha w|w|$，因此更新规则是 $w_{n+1} = w_n + \\Delta t(-\\alpha w_n|w_n|) = w_n(1 - \\alpha |w_n| \\Delta t)$。\n\n积分从 $t=0$ 进行到 $t=t_{\\mathrm{end}}$。如果 $t_{\\mathrm{end}}$ 不是主时间步长 $\\Delta t$ 的整数倍，则截断最后一个步长以确保积分精确地在 $t_{\\mathrm{end}}$ 终止。\n\n### 4. 误差度量\n\n定义了两个无量纲的误差度量来量化不同来源的数值不准确性。\n\n- **时间积分误差 $\\varepsilon_{\\mathrm{time}}$**：该度量衡量了数值计算解 $w_{\\mathrm{num}}$ 与在积分器使用的离散时间点 $t_n$ 上的精确解 $w_{\\mathrm{exact}}$ 之间的差异。它是对给定步长下前向 Euler 方法准确性的直接度量。\n$$\n\\varepsilon_{\\mathrm{time}} = \\max_n \\frac{\\left|w_{\\mathrm{num}}(t_n) - w_{\\mathrm{exact}}(t_n)\\right|}{\\max\\left(\\left|w_{\\mathrm{exact}}(t_n)\\right|, \\epsilon\\right)}\n$$\n其中下限值 $\\epsilon = 10^{-12}\\ \\mathrm{m\\,s^{-1}}$ 防止除以零。\n\n- **插值误差 $\\varepsilon_{\\mathrm{interp}}$**：该度量分离了因假设真实解在两个时间点之间呈线性演化而产生的误差。它比较了时间间隔中点处的精确解 $w_{\\mathrm{exact}}(t_{n+1/2})$ 与通过对区间端点处的精确解进行线性插值得到的值 $w_{\\mathrm{lin}}(t_{n+1/2})$。这个误差量化了精确解在单个时间步长 $\\Delta t$ 上的非线性程度。\n$$\nw_{\\mathrm{lin}}(t_{n+\\frac{1}{2}}) = \\frac{1}{2}\\left[w_{\\mathrm{exact}}(t_n) + w_{\\mathrm{exact}}(t_{n+1})\\right]\n$$\n$$\n\\varepsilon_{\\mathrm{interp}} = \\max_n \\frac{\\left|w_{\\mathrm{lin}}(t_{n+\\frac{1}{2}}) - w_{\\mathrm{exact}}(t_{n+\\frac{1}{2}})\\right|}{\\max\\left(\\left|w_{\\mathrm{exact}}(t_{n+\\frac{1}{2}})\\right|, \\epsilon\\right)}\n$$\n\n实现将为五个指定的测试用例中的每一个计算这些值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates the Dustybox model and quantifies numerical errors for dust-gas dynamics.\n    \"\"\"\n    \n    # Epsilon value for error normalization to avoid division by zero.\n    epsilon = 1e-12\n\n    def get_time_grid(t_end, dt):\n        \"\"\"\n        Generates the grid of time points for the integration.\n        Handles the case where t_end is not a multiple of dt.\n        \"\"\"\n        if dt = 0 or t_end  0:\n            return np.array([0.0])\n        \n        num_steps = int(t_end / dt)\n        times = [i * dt for i in range(num_steps + 1)]\n        \n        # Check if the last point is t_end\n        if not np.isclose(times[-1], t_end):\n            # If t_end was not a multiple of dt, add it\n            if times[-1]  t_end:\n                 times.append(t_end)\n            # If t_end was smaller than dt, the list is [0, dt], fix it to [0, t_end]\n            elif len(times) == 2 and t_end  dt:\n                times = [0.0, t_end]\n\n        return np.array(times, dtype=float)\n\n    def w_exact_linear(t, w0, lam):\n        return w0 * np.exp(-lam * t)\n\n    def w_exact_quadratic(t, w0, alpha):\n        return w0 / (1 + alpha * np.abs(w0) * t)\n\n    def forward_euler(w0, t_grid, f_dw_dt):\n        \"\"\"\n        Performs forward Euler integration.\n        \"\"\"\n        w_numerical = np.zeros_like(t_grid)\n        w_numerical[0] = w0\n        \n        for n in range(len(t_grid) - 1):\n            dt = t_grid[n+1] - t_grid[n]\n            w_numerical[n+1] = w_numerical[n] + dt * f_dw_dt(w_numerical[n])\n            \n        return w_numerical\n\n    def run_case(case_params):\n        \"\"\"\n        Runs a single test case and computes both error metrics.\n        \"\"\"\n        drag_type = case_params['type']\n        w0 = case_params['w0']\n        t_end = case_params['t_end']\n        dt = case_params['dt']\n\n        if drag_type == 'linear':\n            lam = case_params['coeff']\n            w_exact_func = lambda t: w_exact_linear(t, w0, lam)\n            f_dw_dt = lambda w: -lam * w\n        elif drag_type == 'quadratic':\n            alpha = case_params['coeff']\n            w_exact_func = lambda t: w_exact_quadratic(t, w0, alpha)\n            f_dw_dt = lambda w: -alpha * w * np.abs(w)\n        else:\n            raise ValueError(\"Unknown drag type specified.\")\n\n        # Generate time grid and perform numerical integration\n        t_grid = get_time_grid(t_end, dt)\n        w_num = forward_euler(w0, t_grid, f_dw_dt)\n        \n        # Calculate analytic solution at the same time points\n        w_exact_at_grid = w_exact_func(t_grid)\n        \n        # --- Calculate Time Integration Error (epsilon_time) ---\n        numerator = np.abs(w_num - w_exact_at_grid)\n        denominator = np.maximum(np.abs(w_exact_at_grid), epsilon)\n        time_errors = numerator / denominator\n        eps_time = np.max(time_errors)\n        \n        # --- Calculate Interpolation Error (epsilon_interp) ---\n        interp_errors = []\n        for n in range(len(t_grid) - 1):\n            t_n = t_grid[n]\n            t_n1 = t_grid[n+1]\n            t_mid = 0.5 * (t_n + t_n1)\n            \n            # Exact values at endpoints\n            w_exact_n = w_exact_at_grid[n]\n            w_exact_n1 = w_exact_at_grid[n+1]\n            \n            # Linearly interpolated value at midpoint\n            w_lin_mid = 0.5 * (w_exact_n + w_exact_n1)\n            \n            # Exact value at midpoint\n            w_exact_mid = w_exact_func(t_mid)\n            \n            # Error at midpoint\n            num_interp = np.abs(w_lin_mid - w_exact_mid)\n            den_interp = np.maximum(np.abs(w_exact_mid), epsilon)\n            interp_errors.append(num_interp / den_interp)\n        \n        eps_interp = np.max(interp_errors) if interp_errors else 0.0\n        \n        return [eps_time, eps_interp]\n\n    test_cases = [\n        # Case A (linear drag, well-resolved)\n        {'type': 'linear', 'w0': 10.0, 'coeff': 2.0, 't_end': 1.0, 'dt': 0.1},\n        # Case B (linear drag, coarse step near stability boundary)\n        {'type': 'linear', 'w0': 10.0, 'coeff': 2.0, 't_end': 1.0, 'dt': 0.95},\n        # Case C (quadratic drag, well-resolved)\n        {'type': 'quadratic', 'w0': 10.0, 'coeff': 0.1, 't_end': 1.0, 'dt': 0.05},\n        # Case D (quadratic drag, coarse step)\n        {'type': 'quadratic', 'w0': 10.0, 'coeff': 0.1, 't_end': 1.0, 'dt': 0.5},\n        # Case E (quadratic drag, negative initial velocity)\n        {'type': 'quadratic', 'w0': -5.0, 'coeff': 0.2, 't_end': 2.0, 'dt': 0.1},\n    ]\n\n    results = [run_case(case) for case in test_cases]\n    \n    # Format the final output string\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3519080"}, {"introduction": "在理解了阻力的基本概念之后，我们现在考虑它在一个封闭的二流体系统中的能量学效应。阻力会耗散动能，将其转化为气体的内能。一个稳健的数值格式必须精确地捕捉这种能量转换，以保证总能量守恒。本练习将指导您设计一个既稳定又能在离散层面精确保持能量守恒的半隐式积分格式，这是开发可靠的长期演化代码的关键技能。[@problem_id:3519058]", "problem": "考虑一个空间均匀的封闭盒子，其中包含气体和无压尘埃的双流体混合物。设气体的单位体积质量密度为 $\\,\\rho_g\\,$，速度为 $\\,u_g\\,$，单位体积内能为 $\\,e_g\\,$；设尘埃的单位体积质量密度为 $\\,\\rho_d\\,$，速度为 $\\,u_d\\,$。两种组分之间唯一的相互作用是由单位体积拖曳系数 $\\,K\\,$ 描述的线性拖曳力。不存在外力，也没有空间梯度，所有边界都是周期性的，因此该盒子是封闭且孤立的。\n\n从应用于每种流体组分的 Newton 第二定律和能量的定义出发，基于以下基本原理：\n- Newton 第二定律：$\\,\\rho_g\\,\\mathrm{d}u_g/\\mathrm{d}t = F_g\\,$ 和 $\\,\\rho_d\\,\\mathrm{d}u_d/\\mathrm{d}t = F_d\\,$。\n- 大小相等、方向相反的拖曳力密度：$\\,F_g = +K\\,(u_d - u_g)\\,$ 和 $\\,F_d = -K\\,(u_d - u_g)\\,$。\n- 单位体积动能：$\\,E_k = \\tfrac{1}{2}\\rho_g u_g^2 + \\tfrac{1}{2}\\rho_d u_d^2\\,$。\n- 盒子中的单位体积总能量：$\\,E_{\\mathrm{tot}} = E_k + e_g\\,$，其中尘埃被视为无压（内能为零）。\n\n您的任务是为纯拖曳动力学设计并实现一个时间积分方案，该方案在离散层面上通过将动能自由度损失的机械能以拖曳加热的形式添加到气体内部能量中，从而在封闭盒子中保持总能量守恒。具体来说，由拖曳引起的机械能损失的连续时间变化率为 $\\,\\mathrm{d}E_k/\\mathrm{d}t = -K\\,|u_d - u_g|^2\\,$，因此气体内部能量必须根据 $\\,\\mathrm{d}e_g/\\mathrm{d}t = +K\\,|u_d - u_g|^2\\,$ 变化，以确保在封闭盒子中 $\\,\\mathrm{d}E_{\\mathrm{tot}}/\\mathrm{d}t = 0\\,$。\n\n实现一个在 $\\,\\Delta t\\,$ 时间步长内对 $\\,u_g\\,$ 和 $\\,u_d\\,$ 的离散时间更新方案，该方案需遵循相对速度的纯拖曳精确演化，并守恒质量加权平均速度。然后，使用与所选离散演化一致的拖曳加热增量来更新 $\\,e_g\\,$，使得离散总能量 $\\,E_{\\mathrm{tot}}\\,$ 在数值舍入误差范围内保持恒定。您必须提供两种加热模式：\n- 时间上精确的加热模式：该模式将 $\\,K\\,|u_d - u_g|^2\\,$ 在步长 $\\,\\Delta t\\,$ 上进行积分，且与 $\\,u_d - u_g\\,$ 的精确演化保持一致。\n- 简单的显式加热模式：该模式使用在步长开始时计算的 $\\,K\\,|u_d - u_g|^2\\,\\Delta t\\,$。\n\n对每个测试用例，以步长 $\\,\\Delta t\\,$ 模拟 $\\,N\\,$ 步。在每一步中，计算单位体积总能量 $\\,E_{\\mathrm{tot}}\\,$，并跟踪整个模拟过程中其与初始总能量 $\\,E_{\\mathrm{tot},0}\\,$ 的最大绝对偏差。对于每个测试用例，返回一个布尔值，表示此最大绝对偏差是否小于容差 $\\,\\epsilon = 10^{-10}\\,$（单位：焦耳/立方米）。所有物理量必须使用以下单位处理：\n- 单位体积质量密度 $\\,\\rho_g\\,$ 和 $\\,\\rho_d\\,$：$\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,$。\n- 速度 $\\,u_g\\,$ 和 $\\,u_d\\,$：$\\,\\mathrm{m}\\,\\mathrm{s}^{-1}\\,$。\n- 单位体积拖曳系数 $\\,K\\,$：$\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}\\,$。\n- 时间步长 $\\,\\Delta t\\,$：$\\,\\mathrm{s}\\,$。\n- 单位体积能量 $\\,E_{\\mathrm{tot}}\\,$ 和 $\\,e_g\\,$：$\\,\\mathrm{J}\\,\\mathrm{m}^{-3}\\,$。\n\n使用以下测试套件，其中每个测试用例是一个元组 $\\,(\\rho_g, \\rho_d, K, u_{g,0}, u_{d,0}, e_{g,0}, \\Delta t, N, \\text{heating\\_mode})\\,$：\n1. 中等拖曳力，中等对比度：$\\,(\\,10^{-9},\\,10^{-10},\\,10^{-7},\\,20,\\,5,\\,10^{-6},\\,10^{-1},\\,10,\\,\\text{\"exact\"}\\,)\\,$.\n2. 无拖曳力（边界情况）：$\\,(\\,10^{-9},\\,10^{-10},\\,0,\\,5,\\,-5,\\,0,\\,1,\\,5,\\,\\text{\"exact\"}\\,)\\,$.\n3. 强拖曳力，小时间步长：$\\,(\\,10^{-6},\\,10^{-7},\\,10^{-3},\\,100,\\,-100,\\,0,\\,10^{-4},\\,1000,\\,\\text{\"exact\"}\\,)\\,$.\n4. 高度不对称的质量密度：$\\,(\\,10^{-8},\\,10^{-12},\\,5\\times 10^{-8},\\,0,\\,100,\\,2,\\,0.5,\\,20,\\,\\text{\"exact\"}\\,)\\,$.\n5. 与情况 $\\,1\\,$ 相同，但使用显式加热以证明其非守恒性：$\\,(\\,10^{-9},\\,10^{-10},\\,10^{-7},\\,20,\\,5,\\,10^{-6},\\,10^{-1},\\,10,\\,\\text{\"explicit\"}\\,)\\,$.\n\n您的程序应生成一行输出，其中包含五个测试用例的结果，格式为方括号括起来的逗号分隔列表，并按上述顺序排列（例如，$\\,[\\text{True},\\text{True},\\text{True},\\text{True},\\text{False}]\\,)$。", "solution": "问题要求为一种仅通过线性拖曳力相互作用的气-尘流体混合物的动力学设计并实现一个时间积分方案。该方案的构建必须能在离散层面上为一个封闭、均匀的系统精确地守恒总能量。我们将首先推导速度演化的解析解，然后构建一个遵循该解的离散更新方案，最后推导确保总能量守恒的相应加热项。\n\n所有物理量都以单位体积定义。气体由其质量密度 $\\rho_g$、速度 $u_g$ 和内能 $e_g$ 描述。尘埃是无压的，由其质量密度 $\\rho_d$ 和速度 $u_d$ 描述。相互作用由拖曳系数 $K$ 控制。\n\n根据 Newton 第二定律给出的运动方程为：\n$$\n\\rho_g \\frac{\\mathrm{d}u_g}{\\mathrm{d}t} = +K(u_d - u_g)\n$$\n$$\n\\rho_d \\frac{\\mathrm{d}u_d}{\\mathrm{d}t} = -K(u_d - u_g)\n$$\n\n将运动分解为质心速度和相对速度的演化是有利的。总质量密度为 $\\rho_t = \\rho_g + \\rho_d$。质心速度 $v_c$ 定义为质量加权平均速度：\n$$\nv_c = \\frac{\\rho_g u_g + \\rho_d u_d}{\\rho_t}\n$$\n$v_c$ 的时间导数为：\n$$\n\\frac{\\mathrm{d}v_c}{\\mathrm{d}t} = \\frac{1}{\\rho_t} \\left( \\rho_g\\frac{\\mathrm{d}u_g}{\\mathrm{d}t} + \\rho_d\\frac{\\mathrm{d}u_d}{\\mathrm{d}t} \\right) = \\frac{1}{\\rho_t} \\left( K(u_d - u_g) - K(u_d - u_g) \\right) = 0\n$$\n这证实了质心速度 $v_c$ 是一个守恒量，这是封闭系统中总动量守恒的直接结果。\n\n相对速度为 $v_r = u_d - u_g$。其时间演化由下式给出：\n$$\n\\frac{\\mathrm{d}v_r}{\\mathrm{d}t} = \\frac{\\mathrm{d}u_d}{\\mathrm{d}t} - \\frac{\\mathrm{d}u_g}{\\mathrm{d}t} = -\\frac{K}{\\rho_d}(u_d - u_g) - \\frac{K}{\\rho_g}(u_d - u_g) = -K\\left(\\frac{1}{\\rho_g} + \\frac{1}{\\rho_d}\\right)(u_d - u_g)\n$$\n$$\n\\frac{\\mathrm{d}v_r}{\\mathrm{d}t} = -K\\left(\\frac{\\rho_g + \\rho_d}{\\rho_g \\rho_d}\\right)v_r = -\\frac{1}{t_s}v_r\n$$\n这里我们定义了特征拖曳时间或“停止”时间 $t_s = \\frac{\\rho_g \\rho_d}{K(\\rho_g + \\rho_d)}$。这是一个一阶线性常微分方程，其精确解为：\n$$\nv_r(t) = v_r(0) e^{-t/t_s}\n$$\n两个组分之间的相对速度指数衰减至零。\n\n可以构建一个从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的速度离散时间更新方案，以遵循这些解析性质。设 $u_g^n$ 和 $u_d^n$ 表示时间 $t_n$ 时的速度。更新后的速度 $u_g^{n+1}$ 和 $u_d^{n+1}$ 必须满足：\n1. 质心速度守恒：$v_c^{n+1} = v_c^n$。\n2. 相对速度的精确演化：$v_r^{n+1} = v_r^n e^{-\\Delta t/t_s}$。\n\n各自的速度可以用 $v_c$ 和 $v_r$ 表示：\n$$\nu_g = v_c - \\frac{\\rho_d}{\\rho_t} v_r\n$$\n$$\nu_d = v_c + \\frac{\\rho_g}{\\rho_t} v_r\n$$\n应用 $v_c$ 和 $v_r$ 的更新规则，我们得到更新后的各自的速度：\n$$\nu_g^{n+1} = v_c^n - \\frac{\\rho_d}{\\rho_t} \\left( v_r^n e^{-\\Delta t/t_s} \\right)\n$$\n$$\nu_d^{n+1} = v_c^n + \\frac{\\rho_g}{\\rho_t} \\left( v_r^n e^{-\\Delta t/t_s} \\right)\n$$\n这种半隐式方案对任何时间步长 $\\Delta t$ 都是稳定的，并且能精确地捕捉拖曳动力学。对于 $K=0$ 的特殊情况，$t_s \\to \\infty$，因此 $e^{-\\Delta t/t_s} \\to 1$，速度保持恒定，正如预期。\n\n接下来，我们讨论总能量 $E_{\\mathrm{tot}} = E_k + e_g$ 的守恒问题。单位体积动能 $E_k$ 由下式给出：\n$$\nE_k = \\frac{1}{2}\\rho_g u_g^2 + \\frac{1}{2}\\rho_d u_d^2\n$$\n将 $u_g$ 和 $u_d$ 用 $v_c$ 和 $v_r$ 表示的表达式代入，得到：\n$$\nE_k = \\frac{1}{2}\\rho_t v_c^2 + \\frac{1}{2}\\frac{\\rho_g\\rho_d}{\\rho_g+\\rho_d} v_r^2 = \\frac{1}{2}\\rho_t v_c^2 + \\frac{1}{2}\\mu v_r^2\n$$\n其中 $\\mu = \\frac{\\rho_g\\rho_d}{\\rho_g+\\rho_d}$ 是约化质量密度。\n由于 $v_c$ 是恒定的，在一个时间步长 $\\Delta t$ 内动能的变化仅取决于 $v_r$ 的变化：\n$$\n\\Delta E_k = E_k^{n+1} - E_k^n = \\frac{1}{2}\\mu (v_r^{n+1})^2 - \\frac{1}{2}\\mu (v_r^n)^2 = \\frac{1}{2}\\mu \\left( (v_r^n e^{-\\Delta t/t_s})^2 - (v_r^n)^2 \\right)\n$$\n$$\n\\Delta E_k = -\\frac{1}{2}\\mu (v_r^n)^2 \\left( 1 - e^{-2\\Delta t/t_s} \\right)\n$$\n为了在离散层面上守恒总能量 $E_{\\mathrm{tot}}$，内能的变化量 $\\Delta e_g = e_g^{n+1} - e_g^n$ 必须精确地抵消动能的损失：\n$$\n\\Delta e_g = -\\Delta E_k = +\\frac{1}{2}\\mu (v_r^n)^2 \\left( 1 - e^{-2\\Delta t/t_s} \\right)\n$$\n这就是“时间上精确的”加热项。它精确地对应于使用 $v_r(t)$ 的精确解，将连续加热率 $\\mathrm{d}e_g/\\mathrm{d}t = K v_r(t)^2$ 在时间间隔 $\\Delta t$ 上积分的结果。\n\n作为对比，“简单的显式”加热模式定义为使用在步长开始时计算的加热率：\n$$\n\\Delta e_{g, \\text{explicit}} = \\left( K |u_d^n - u_g^n|^2 \\right) \\Delta t = K (v_r^n)^2 \\Delta t\n$$\n由于仅当 $x \\ll 1$ 时（其中 $x = 2\\Delta t/t_s$），$1 - e^{-x} \\approx x$ 才成立，因此该显式加热项是精确加热的一阶近似。除非在 $\\Delta t \\to 0$ 的极限情况下，否则它不会使总能量守恒。\n\n该实现将使用推导出的速度更新，以步长 $\\Delta t$ 对系统进行 $N$ 步模拟。它将使用“精确”或“显式”模式来计算内能更新。总能量与其初始值 $|E_{\\mathrm{tot}} - E_{\\mathrm{tot},0}|$ 的最大绝对偏差将被跟踪，并与容差 $\\epsilon = 10^{-10}$ 进行比较。\n\n必须小心处理特殊情况。如果 $K=0$，则 $t_s \\to \\infty$，速度衰减因子为 $1$，加热量 $\\Delta e_g$ 为 $0$。如果 $\\rho_g=0$ 或 $\\rho_d=0$，则 $\\mu=0$ 且 $t_s=0$。这意味着无限强的耦合；相对速度瞬间衰减为零，衰减因子为 $0$。由于 $\\mu=0$，加热项也变为零。逻辑必须能处理这些极限情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dust-gas drag problem for a series of test cases and\n    checks for energy conservation.\n    \"\"\"\n    test_cases = [\n        # (rho_g, rho_d, K, u_g_0, u_d_0, e_g_0, dt, N, heating_mode)\n        (1e-9, 1e-10, 1e-7, 20.0, 5.0, 1e-6, 0.1, 10, \"exact\"),\n        (1e-9, 1e-10, 0.0, 5.0, -5.0, 0.0, 1.0, 5, \"exact\"),\n        (1e-6, 1e-7, 1e-3, 100.0, -100.0, 0.0, 1e-4, 1000, \"exact\"),\n        (1e-8, 1e-12, 5e-8, 0.0, 100.0, 2.0, 0.5, 20, \"exact\"),\n        (1e-9, 1e-10, 1e-7, 20.0, 5.0, 1e-6, 0.1, 10, \"explicit\"),\n    ]\n    epsilon = 1e-10\n    results = []\n\n    for case in test_cases:\n        rho_g, rho_d, K, u_g_0, u_d_0, e_g_0, dt, N, mode = case\n\n        # Initialize state variables\n        u_g, u_d, e_g = float(u_g_0), float(u_d_0), float(e_g_0)\n\n        # Pre-compute constants\n        rho_t = rho_g + rho_d\n\n        # Calculate initial total energy\n        E_k_0 = 0.5 * rho_g * u_g**2 + 0.5 * rho_d * u_d**2\n        E_tot_0 = E_k_0 + e_g\n\n        max_dev = 0.0\n\n        for _ in range(N):\n            if rho_t == 0:\n                # If there's no mass, velocities and energies are trivially zero.\n                # No change occurs.\n                break\n\n            # Decompose into center-of-mass and relative velocities\n            v_c = (rho_g * u_g + rho_d * u_d) / rho_t\n            v_r = u_d - u_g\n\n            decay_factor = 1.0\n            delta_e_g = 0.0\n\n            # Calculate decay factor and heating term\n            if K > 0.0 and rho_g > 0.0 and rho_d > 0.0:\n                mu = (rho_g * rho_d) / rho_t\n                t_s = mu / K\n                \n                # A very small t_s indicates stiff coupling, relative velocity damps quickly.\n                # np.exp handles large negative exponents gracefully.\n                if t_s > 0.0:\n                    decay_factor = np.exp(-dt / t_s)\n                    if mode == \"exact\":\n                        # This term is exactly the kinetic energy lost by the relative motion\n                        delta_e_g = 0.5 * mu * v_r**2 * (1.0 - decay_factor**2)\n                    elif mode == \"explicit\":\n                        delta_e_g = K * v_r**2 * dt\n                else: # t_s is zero or negative (unphysical), means infinite coupling\n                    decay_factor = 0.0\n                    if mode == \"exact\":\n                        # All relative kinetic energy is dissipated in one step\n                        delta_e_g = 0.5 * mu * v_r**2\n                    elif mode == \"explicit\":\n                        # This would be infinite if K was infinite, but we handle via t_s\n                        delta_e_g = K * v_r**2 * dt\n\n            # For K=0, or if one density is zero, decay_factor remains 1 and delta_e_g is 0.\n\n            # Update relative velocity, which defines the new state\n            v_r_new = v_r * decay_factor\n\n            # Reconstruct individual velocities conserving center-of-mass velocity\n            # Note: v_c is constant and does not need to be updated.\n            u_g = v_c - (rho_d / rho_t) * v_r_new\n            u_d = v_c + (rho_g / rho_t) * v_r_new\n\n            # Update internal energy\n            e_g += delta_e_g\n\n            # Calculate new total energy and update maximum deviation\n            E_k_new = 0.5 * rho_g * u_g**2 + 0.5 * rho_d * u_d**2\n            E_tot_new = E_k_new + e_g\n            \n            max_dev = max(max_dev, abs(E_tot_new - E_tot_0))\n\n        results.append(max_dev  epsilon)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: 'True' if b else 'False', results))}]\")\n\nsolve()\n```", "id": "3519058"}, {"introduction": "现在，我们从简单的匣子模型（box model）推进到研究局部盘动力学的标准框架：剪切片（shearing sheet）。该模型要求实施剪切-周期性边界条件，它通过在径向边界上施加随时间变化的方位角平移和动量修正来模拟盘的较差旋转。掌握这种复杂的边界条件对于模拟原行星盘中的流体力学不稳定性（如“streaming instability”）至关重要，本练习将为您提供以严格守恒的方式实现它的实践经验。[@problem_id:3519067]", "problem": "您需要为一个二维双流体（气体和尘埃）有限体积模型在局部微分旋转盘（剪切片）中实现剪切周期性边界条件。您的实现必须保证，在浮点舍入误差范围内，两种流体在剪切周期性径向边界上的总质量和总方位角动量是守恒的。这需要通过使用守恒的方位角重映射和由背景剪切决定的正确方位角动量偏移来实现。\n\n您必须基于以下物理基础开始：\n- 局部剪切片具有背景线性剪切流，其形式为 $v_{0,y}(x) = - q \\, \\Omega \\, x$，其中 $q$ 是无量纲剪切参数，$\\Omega$ 是局部角频率。\n- 相距 $L_x$ 的两个径向边界之间的剪切周期性重映射是一个方位角平移，平移量为 $\\Delta y(t) = q \\, \\Omega \\, L_x \\, t$。\n- 每种流体的守恒变量是单元平均密度 $\\rho$ 和方位角动量 $m_y = \\rho \\, v_y$。在径向边界两侧，由于背景剪切，方位角速度相差 $\\pm q \\, \\Omega \\, L_x$。因此，为了保持扰动 $v_y' \\equiv v_y + q \\, \\Omega \\, x$ 的连续性，相应的方位角动量必须偏移 $\\pm \\rho \\, q \\, \\Omega \\, L_x$。\n\n您必须在二维空间 $(x,y)$ 中，在一个均匀的笛卡尔网格上使用单元中心进行计算。设在大小为 $L_x$ 的域中，$x$ 方向有 $N_x$ 个单元；在大小为 $L_y$ 的域中，$y$ 方向有 $N_y$ 个单元。在每个径向侧使用 $n_g$ 个虚拟单元。左、右 $x$ 边界是剪切周期性的，方位角 $y$ 边界是严格周期性的。\n\n在数学和算法上，您必须：\n1.  根据 $\\Delta y(t)$ 推导出以单元为单位的方位角位移 $s(t)$：\n   $$ s(t) \\equiv \\frac{\\Delta y(t)}{\\Delta y_{\\text{cell}}} = \\frac{q \\, \\Omega \\, L_x \\, t}{L_y/N_y}, $$\n   其中 $\\Delta y_{\\text{cell}} = L_y/N_y$ 是方位角方向的单元尺寸。\n2.  对于任意一维单元平均值数组 $a_j$（其中 $j \\in \\{0,\\dots,N_y-1\\}$），实现一个严格守恒的周期性重映射，该重映射沿 $y$ 方向移动 $s$ 个单元（$s$ 可以是任意实数）。重映射必须产生新的平均值 $b_j$，这些平均值代表平移了 $\\Delta y$ 之后的场，并且必须满足：\n   $$ \\sum_{j=0}^{N_y-1} b_j = \\sum_{j=0}^{N_y-1} a_j, $$\n   在浮点舍入误差范围内精确成立。使用由 $s$ 的整数和小数部分构建的分段常数守恒平移。对于 $s$ 个单元的位移，令 $k \\equiv \\lfloor s \\rfloor$ 且 $f \\equiv s - k \\in [0,1)$，并要求：\n   $$ b_j = (1-f) \\, a_{(j-k)\\bmod N_y} + f \\, a_{(j-k-1)\\bmod N_y}. $$\n3.  对两种流体在每个径向边界处，使用相同的守恒重映射来填充虚拟区域：\n    -   左侧虚拟区域来自右侧内部区域：重映射位移为 $+s$。\n    -   右侧虚拟区域来自左侧内部区域：重映射位移为 $-s$。\n4.  根据背景剪切，在径向边界上应用一致的方位角动量偏移：\n    -   从右侧内部到左侧虚拟区域的映射，必须在对 $\\rho$ 和 $m_y$ 进行守恒重映射后，给方位角动量加上 $+ \\rho \\, q \\, \\Omega \\, L_x$。\n    -   从左侧内部到右侧虚拟区域的映射，必须在对 $\\rho$ 和 $m_y$ 进行守恒重映射后，给方位角动量加上 $- \\rho \\, q \\, \\Omega \\, L_x$。\n    此处，偏移中使用的 $\\rho$ 是接收方虚拟单元中经过重映射的密度，以确保物理上一致的速度偏移。\n\n您的程序必须：\n-   在内部域上为气体和尘埃构建以单元为中心的初始场，使用以下平滑、非平凡且科学上合理的代码单位剖面：\n    -   背景坐标，域中心在 $x=0$：$x_i = (i+0.5)\\, \\Delta x - L_x/2$（对于 $i \\in \\{0,\\dots,N_x-1\\}$）和 $y_j = (j+0.5)\\, \\Delta y - L_y/2$（对于 $j \\in \\{0,\\dots,N_y-1\\}$），其中 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。\n    -   气体密度：\n        $$ \\rho_g(x,y) = 1 + 0.1 \\, \\sin\\!\\left(2\\pi \\frac{x}{L_x}\\right) \\cos\\!\\left(2\\pi \\frac{y}{L_y}\\right). $$\n    -   气体方位角速度：\n        $$ v_{y,g}(x,y) = - q \\, \\Omega \\, x + 0.05 \\, \\sin\\!\\left(2\\pi \\frac{y}{L_y}\\right). $$\n    -   尘埃密度：\n        $$ \\rho_d(x,y) = 0.5 + 0.2 \\, \\cos\\!\\left(2\\pi \\frac{x}{L_x}\\right) \\sin\\!\\left(4\\pi \\frac{y}{L_y}\\right). $$\n    -   尘埃方位角速度：\n        $$ v_{y,d}(x,y) = - q \\, \\Omega \\, x - 0.03 \\, \\cos\\!\\left(2\\pi \\frac{y}{L_y}\\right). $$\n    -   定义 $m_{y,g} = \\rho_g \\, v_{y,g}$ 和 $m_{y,d} = \\rho_d \\, v_{y,d}$。\n-   使用上述守恒重映射和动量偏移规则，为两种流体和两种守恒场 $(\\rho, m_y)$ 在每个径向侧建立 $n_g$ 个虚拟区域。\n-   通过比较供给内部区域和接收虚拟区域，定量验证每个径向边界上的总质量和总方位角动量的守恒性。对于左边界，供给区域是最右侧的 $n_g$ 个内部列；对于右边界，供给区域是最左侧的 $n_g$ 个内部列。令 $\\Delta A = \\Delta x \\, \\Delta y$。为每个边界和每种流体定义：\n    -   供给方质量：\n        $$ M_{\\text{don}} = \\sum \\rho_{\\text{donor}} \\, \\Delta A. $$\n    -   接收方虚拟质量：\n        $$ M_{\\text{ghost}} = \\sum \\rho_{\\text{ghost}} \\, \\Delta A. $$\n    -   供给方方位角动量：\n        $$ P_{\\text{don}} = \\sum m_{y,\\text{donor}} \\, \\Delta A. $$\n    -   接收方虚拟方位角动量：\n        $$ P_{\\text{ghost}} = \\sum m_{y,\\text{ghost}} \\, \\Delta A. $$\n    -   要求的守恒条件：\n        -   质量：$M_{\\text{ghost}} = M_{\\text{don}}$。\n        -   动量：$P_{\\text{ghost}} = P_{\\text{don}} \\pm q \\, \\Omega \\, L_x \\, M_{\\text{don}}$，其中从右到左映射用 $+$ 号，从左到右映射用 $-$ 号。\n    -   报告相对守恒误差：\n        $$ \\epsilon_M = \\frac{\\left|M_{\\text{ghost}} - M_{\\text{don}}\\right|}{\\max\\left(1, \\left|M_{\\text{don}}\\right|\\right)}, \\quad \\epsilon_P = \\frac{\\left|P_{\\text{ghost}} - \\left(P_{\\text{don}} \\pm q \\, \\Omega \\, L_x \\, M_{\\text{don}}\\right)\\right|}{\\max\\left(1, \\left|P_{\\text{don}} \\pm q \\, \\Omega \\, L_x \\, M_{\\text{don}}\\right|\\right)}. $$\n\n测试套件：\n在以下四个测试用例上运行您的实现，这些用例涵盖了零位移、整数单元位移、一般小数位移和长时间多重环绕位移。在所有情况下，使用代码单位 $q = 3/2$ 和 $\\Omega = 1$。\n-   案例 A（理想情况，零位移）：$N_x = 32$, $N_y = 64$, $n_g = 2$, $L_x = 1$, $L_y = 1$, $t = 0$。\n-   案例 B（整数单元位移）：$N_x = 32$, $N_y = 64$, $n_g = 2$, $L_x = 1$, $L_y = 1$，选择 $t$ 使得 $s = 17$，即\n    $$ t = \\frac{17}{q \\, \\Omega \\, N_y}. $$\n-   案例 C（小数单元位移）：$N_x = 32$, $N_y = 64$, $n_g = 2$, $L_x = 1$, $L_y = 1$，选择 $t$ 使得 $s = 12.37$，即\n    $$ t = \\frac{12.37}{q \\, \\Omega \\, N_y}. $$\n-   案例 D（长时间，多次环绕，不同的 $N_y$）：$N_x = 28$, $N_y = 63$, $n_g = 3$, $L_x = 1$, $L_y = 1$，选择 $t$ 使得 $s = 1234.567$，即\n    $$ t = \\frac{1234.567}{q \\, \\Omega \\, N_y}. $$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目都是一个浮点数，等于该测试用例中，气体和尘埃在两个径向边界上的 $\\epsilon_M$ 和 $\\epsilon_P$ 中的最大相对守恒误差。换句话说，生成\n$$ [E_A, E_B, E_C, E_D], $$\n其中每个 $E_\\bullet$ 是对应案例中，在左、右边界映射中四个误差（气体和尘埃的质量和动量误差）的最大值。这些 $E_\\bullet$ 是无量纲数。使用默认的 Python 浮点数格式打印这些数字。", "solution": "该问题要求为二维、双流体、有限体积流体动力学模型实现并验证剪切周期性边界条件。该模型位于局部剪切片框架中，这是研究微分旋转盘小块区域动力学的标准近似方法。解决方案必须确保质量和方位角动量守恒至机器精度。\n\n物理域是一个大小为 $L_x \\times L_y$ 的笛卡尔盒子，具有背景线性剪切流 $v_{0,y}(x) = -q \\, \\Omega \\, x$，其中 $x \\in [-L_x/2, L_x/2]$。剪切参数为 $q$，$\\Omega$ 是局部轨道频率。该域被离散化为一个 $N_x \\times N_y$ 单元的均匀网格。守恒变量是气体和尘埃流体的单元平均密度 $\\rho_g, \\rho_d$ 和方位角动量密度 $m_{y,g}, m_{y,d}$。方位角（$y$）边界是周期性的。位于 $x = \\pm L_x/2$ 的径向（$x$）边界是剪切周期性的，这意味着穿过一个径向边界的流体会被重新引入到相对的边界，并带有与背景剪切一致的方位角位移和速度调整。\n\n问题的核心在于正确实现内部域与每侧径向边界上的 $n_g$ 层虚拟单元之间的边界数据传输。此过程涉及三个主要步骤：守恒的方位角重映射、动量偏移的应用以及守恒性的定量验证。\n\n首先，我们定义随时间变化的方位角位移。相对于 $x = -L_x/2$ 处的流体，一个在 $x = L_x/2$ 处随背景流移动的流体包裹，其方位角速度差为 $\\Delta v_y = v_{0,y}(-L_x/2) - v_{0,y}(L_x/2) = q\\Omega(L_x/2) - (-q\\Omega(L_x/2)) = q\\Omega L_x$。在时间 $t$ 内，这导致方位角位移 $\\Delta y(t) = q \\, \\Omega \\, L_x \\, t$。通过方位角单元尺寸 $\\Delta y_{\\text{cell}} = L_y/N_y$ 对其进行归一化，我们得到以网格单元为单位的位移：\n$$ s(t) \\equiv \\frac{\\Delta y(t)}{\\Delta y_{\\text{cell}}} = \\frac{q \\, \\Omega \\, L_x \\, t}{L_y/N_y} $$\n\n接下来，我们处理守恒重映射。为了填充虚拟单元，我们必须将内部域的一列单元平均数据平移一个位移 $s$。简单的插值不会使总量守恒。问题指定了分段常数守恒平移。对于一维单元平均值数组 $a_j$（$j \\in \\{0, \\dots, N_y-1\\}$），我们寻求一个新的平均值数组 $b_j$，表示数据移动了 $s$ 个单元。我们将位移 $s$ 分解为其整数和小数部分：$k \\equiv \\lfloor s \\rfloor$ 和 $f \\equiv s - k \\in [0,1)$。重映射平均值的公式为：\n$$ b_j = (1-f) \\, a_{(j-k)\\bmod N_y} + f \\, a_{(j-k-1)\\bmod N_y} $$\n此操作是守恒的，意味着 $\\sum_{j=0}^{N_y-1} b_j = \\sum_{j=0}^{N_y-1} a_j$ 在浮点误差范围内成立。这可以通过对所有 $j$ 求和 $b_j$ 来证明。求和算子与线性组合可交换，而和 $\\sum_j a_{(j-k)\\bmod N_y}$ 和 $\\sum_j a_{(j-k-1)\\bmod N_y}$ 只是原始和 $\\sum_j a_j$ 的重新排序。因此，$\\sum_j b_j = (1-f)\\sum_j a_j + f\\sum_j a_j = \\sum_j a_j$。\n\n虚拟单元填充过程如下：\n1.  **左侧虚拟单元（来自右侧内部）**：左边界（$x  -L_x/2$）的虚拟单元由右边界（$x \\approx L_x/2$）的内部单元填充。该映射涉及一个正的方位角位移 $\\Delta y(t)$，对应于一个单元位移 $+s$。对于左侧虚拟区域中的每一列，从右侧内部确定相应的供给列。使用位移 $+s$ 的守恒公式对方位角重映射该供给列中的守恒量（$\\rho$ 和 $m_y$）。\n2.  **右侧虚拟单元（来自左侧内部）**：对称地，右侧虚拟单元（$x > L_x/2$）由左侧内部单元（$x \\approx -L_x/2$）填充。此映射需要一个负的方位角位移 $-\\Delta y(t)$，或一个单元位移 $-s$。\n\n重映射后，必须调整方位角动量。物理速度扰动 $v_y' \\equiv v_y + q \\, \\Omega \\, x$ 必须在边界上是连续的。当流体从右边界（$x=L_x/2$）映射到左边界（$x=-L_x/2$）时，其总方位角速度必须跳跃 $\\Delta v_y = q\\Omega L_x$ 以保持 $v_y'$ 不变。因此，方位角动量 $m_y = \\rho v_y$ 被调整为 $m_{y, \\text{ghost}} = m_{y,\\text{remap}} + \\rho_{\\text{ghost}} q \\Omega L_x$。密度 $\\rho_{\\text{ghost}}$ 是已经重映射过的密度，确保速度跳跃被正确应用。对于从左到右的映射，速度必须跳跃 $-q\\Omega L_x$，因此动量调整为 $m_{y, \\text{ghost}} = m_{y,\\text{remap}} - \\rho_{\\text{ghost}} q \\Omega L_x$。\n\n最后，我们验证守恒性质。一个包含 $n_g$ 列虚拟单元的区域中的总质量和修正后的总方位角动量，必须精确等于对应的 $n_g$ 列内部供给区域中的总量。设 $\\Delta A = \\Delta x \\Delta y$ 为单元面积。\n对于从右到左的映射：\n$$ M_{\\text{ghost}} = \\sum_{\\text{left ghost}} \\rho_{\\text{ghost}} \\, \\Delta A = \\sum_{\\text{right donor}} \\rho_{\\text{donor}} \\, \\Delta A = M_{\\text{don}} $$\n$$ P_{\\text{ghost}} = \\sum_{\\text{left ghost}} m_{y,\\text{ghost}} \\, \\Delta A = P_{\\text{don}} + q \\, \\Omega \\, L_x \\, M_{\\text{don}} $$\n对于从左到右的映射：\n$$ M_{\\text{ghost}} = \\sum_{\\text{right ghost}} \\rho_{\\text{ghost}} \\, \\Delta A = \\sum_{\\text{left donor}} \\rho_{\\text{donor}} \\, \\Delta A = M_{\\text{don}} $$\n$$ P_{\\text{ghost}} = \\sum_{\\text{right ghost}} m_{y,\\text{ghost}} \\, \\Delta A = P_{\\text{don}} - q \\, \\Omega \\, L_x \\, M_{\\text{don}} $$\n通过构造，该算法满足这些恒等式。实现部分计算相对误差 $\\epsilon_M$ 和 $\\epsilon_P$，预计其量级为机器精度。数值实现使用 `numpy` 进行高效的基于数组的计算，特别是使用 `numpy.roll` 处理方位角位移的整数部分。根据提供的函数，在单元中心的网格上生成气体和尘埃场（$\\rho_g$, $v_{y,g}$, $\\rho_d$, $v_{y,d}$）的初始条件。然后对每个测试用例执行该过程，并报告两种流体和两个边界上的最大相对误差。", "answer": "```python\nimport numpy as np\n\ndef conservative_remap(arr_1d, shift):\n    \"\"\"\n    Performs a 1D conservative periodic remap on cell-averaged data.\n\n    Args:\n        arr_1d (np.ndarray): 1D array of cell averages.\n        shift (float): The shift distance in units of cells.\n\n    Returns:\n        np.ndarray: The remapped 1D array.\n    \"\"\"\n    ny = len(arr_1d)\n    k = int(np.floor(shift))\n    f = shift - k\n\n    # The remap formula is b_j = (1-f)a_{j-k} + f*a_{j-k-1}\n    # np.roll(a, s) creates a result where result[i] = a[i-s].\n    term1 = np.roll(arr_1d, k)\n    term2 = np.roll(arr_1d, k + 1)\n    \n    remapped_arr = (1.0 - f) * term1 + f * term2\n    return remapped_arr\n\ndef apply_bcs(rho_interior, my_interior, Nx, Ny, ng, s, q, Omega, Lx):\n    \"\"\"\n    Applies shearing-periodic boundary conditions to a fluid's fields.\n\n    Args:\n        rho_interior (np.ndarray): 2D array of interior density.\n        my_interior (np.ndarray): 2D array of interior azimuthal momentum.\n        Nx, Ny, ng (int): Grid parameters.\n        s (float): Azimuthal shift in cells.\n        q, Omega, Lx (float): Physical parameters.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: Full 2D arrays for density and momentum\n                                       including ghost zones.\n    \"\"\"\n    rho_full = np.zeros((Nx + 2 * ng, Ny))\n    my_full = np.zeros((Nx + 2 * ng, Ny))\n\n    rho_full[ng:ng+Nx, :] = rho_interior\n    my_full[ng:ng+Nx, :] = my_interior\n\n    # Fill left ghost zones (from right interior)\n    for i in range(ng):\n        donor_idx = Nx - ng + i # Index in interior array\n        ghost_idx = i           # Index in full array\n        \n        rho_donor_col = rho_interior[donor_idx, :]\n        rho_ghost_col = conservative_remap(rho_donor_col, s)\n        rho_full[ghost_idx, :] = rho_ghost_col\n\n        my_donor_col = my_interior[donor_idx, :]\n        my_ghost_col_remap = conservative_remap(my_donor_col, s)\n        \n        my_offset = rho_ghost_col * (q * Omega * Lx)\n        my_full[ghost_idx, :] = my_ghost_col_remap + my_offset\n\n    # Fill right ghost zones (from left interior)\n    for i in range(ng):\n        donor_idx = i           # Index in interior array\n        ghost_idx = ng + Nx + i # Index in full array\n        \n        rho_donor_col = rho_interior[donor_idx, :]\n        rho_ghost_col = conservative_remap(rho_donor_col, -s)\n        rho_full[ghost_idx, :] = rho_ghost_col\n\n        my_donor_col = my_interior[donor_idx, :]\n        my_ghost_col_remap = conservative_remap(my_donor_col, -s)\n        \n        my_offset = rho_ghost_col * (q * Omega * Lx)\n        my_full[ghost_idx, :] = my_ghost_col_remap - my_offset\n    \n    return rho_full, my_full\n\ndef verify_conservation(rho_int, my_int, rho_full, my_full, Nx, Ny, ng, dx, dy, q, Omega, Lx):\n    \"\"\"\n    Verifies mass and momentum conservation across boundaries and returns max error.\n    \"\"\"\n    dA = dx * dy\n    errors = []\n\n    # Left boundary (right interior -> left ghost)\n    rho_donor_L = rho_int[Nx-ng:Nx, :]\n    my_donor_L = my_int[Nx-ng:Nx, :]\n    rho_ghost_L = rho_full[0:ng, :]\n    my_ghost_L = my_full[0:ng, :]\n    \n    M_don_L = np.sum(rho_donor_L) * dA\n    M_ghost_L = np.sum(rho_ghost_L) * dA\n    P_don_L = np.sum(my_donor_L) * dA\n    P_ghost_L = np.sum(my_ghost_L) * dA\n    \n    P_target_L = P_don_L + q * Omega * Lx * M_don_L\n    \n    err_M_L = np.abs(M_ghost_L - M_don_L) / max(1.0, np.abs(M_don_L))\n    err_P_L = np.abs(P_ghost_L - P_target_L) / max(1.0, np.abs(P_target_L))\n    errors.extend([err_M_L, err_P_L])\n    \n    # Right boundary (left interior -> right ghost)\n    rho_donor_R = rho_int[0:ng, :]\n    my_donor_R = my_int[0:ng, :]\n    rho_ghost_R = rho_full[ng+Nx:ng+Nx+ng, :]\n    my_ghost_R = my_full[ng+Nx:ng+Nx+ng, :]\n    \n    M_don_R = np.sum(rho_donor_R) * dA\n    M_ghost_R = np.sum(rho_ghost_R) * dA\n    P_don_R = np.sum(my_donor_R) * dA\n    P_ghost_R = np.sum(my_ghost_R) * dA\n    \n    P_target_R = P_don_R - q * Omega * Lx * M_don_R\n    \n    err_M_R = np.abs(M_ghost_R - M_don_R) / max(1.0, np.abs(M_don_R))\n    err_P_R = np.abs(P_ghost_R - P_target_R) / max(1.0, np.abs(P_target_R))\n    errors.extend([err_M_R, err_P_R])\n\n    return max(errors)\n    \ndef run_case(params):\n    \"\"\"\n    Runs a single test case and returns the maximum conservation error.\n    \"\"\"\n    Nx, Ny, ng, Lx, Ly, t, q, Omega = params\n\n    dx = Lx / Nx\n    dy = Ly / Ny\n    x = (np.arange(Nx) + 0.5) * dx - Lx / 2\n    y = (np.arange(Ny) + 0.5) * dy - Ly / 2\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # Initial conditions for gas\n    rho_g_int = 1.0 + 0.1 * np.sin(2 * np.pi * xx / Lx) * np.cos(2 * np.pi * yy / Ly)\n    vy_g_int = -q * Omega * xx + 0.05 * np.sin(2 * np.pi * yy / Ly)\n    my_g_int = rho_g_int * vy_g_int\n\n    # Initial conditions for dust\n    rho_d_int = 0.5 + 0.2 * np.cos(2 * np.pi * xx / Lx) * np.sin(4 * np.pi * yy / Ly)\n    vy_d_int = -q * Omega * xx - 0.03 * np.cos(2 * np.pi * yy / Ly)\n    my_d_int = rho_d_int * vy_d_int\n\n    s = (q * Omega * Lx * t) / dy\n\n    # Apply boundary conditions\n    rho_g_full, my_g_full = apply_bcs(rho_g_int, my_g_int, Nx, Ny, ng, s, q, Omega, Lx)\n    rho_d_full, my_d_full = apply_bcs(rho_d_int, my_d_int, Nx, Ny, ng, s, q, Omega, Lx)\n\n    # Verify conservation and get errors\n    err_g = verify_conservation(rho_g_int, my_g_int, rho_g_full, my_g_full, Nx, Ny, ng, dx, dy, q, Omega, Lx)\n    err_d = verify_conservation(rho_d_int, my_d_int, rho_d_full, my_d_full, Nx, Ny, ng, dx, dy, q, Omega, Lx)\n    \n    return max(err_g, err_d)\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    q = 1.5\n    Omega = 1.0\n    \n    # (Nx, Ny, ng, Lx, Ly, t)\n    case_params = [\n        (32, 64, 2, 1.0, 1.0, 0.0),\n        (32, 64, 2, 1.0, 1.0, 17.0 / (q * Omega * 64)),\n        (32, 64, 2, 1.0, 1.0, 12.37 / (q * Omega * 64)),\n        (28, 63, 3, 1.0, 1.0, 1234.567 / (q * Omega * 63)),\n    ]\n\n    # Append q and Omega to each case's parameters\n    test_cases = [case + (q, Omega) for case in case_params]\n\n    results = []\n    for case in test_cases:\n        max_error = run_case(case)\n        results.append(max_error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3519067"}]}