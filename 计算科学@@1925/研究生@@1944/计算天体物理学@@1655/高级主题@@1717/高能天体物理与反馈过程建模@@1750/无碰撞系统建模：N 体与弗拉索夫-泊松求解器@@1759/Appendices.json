{"hands_on_practices": [{"introduction": "$N$-body 模拟通过使用有限数量的粒子来近似连续的相空间流体。我们放置这些粒子的方式并非无足轻重，可能会引入被称为“散粒噪声”的人为噪声。本练习 [@problem_id:3518281] 探讨了不同的采样技术，并利用傅里叶分析来量化每种方法产生的伪密度涨落，这对于建立避免因数值效应而过早坍缩的“宁静”初始条件至关重要。", "problem": "构建一个程序，通过测量指定傅里叶模式下伪密度波动的振幅，来量化不同粒子采样策略如何将一维周期性区域上的均匀无碰撞质量分布离散化。在长度为 $L = 1$ 的无量纲周期性区间中进行计算。考虑一个由 $N$ 个等质量粒子表示的均匀质量密度，粒子位置为 $\\{x_i\\}_{i=1}^N$，其中 $x_i \\in [0,L)$。将整数模式指数 $n \\in \\mathbb{Z}$ 处的离散密度衬比的复傅里叶振幅定义为\n$$\n\\delta_k(n) \\equiv \\frac{1}{N}\\sum_{i=1}^N \\exp\\!\\left(-\\mathrm{i}\\,k_n\\,x_i\\right),\\quad k_n \\equiv \\frac{2\\pi n}{L},\n$$\n并将在模式 $n$ 处测得的功率定义为\n$$\nP_\\mathrm{meas}(n) \\equiv \\left|\\delta_k(n)\\right|^2.\n$$\n你必须为粒子位置实现三种采样策略：\n\n- 泊松采样（独立同分布的均匀采样）：从 $[0,L)$ 上的均匀分布中独立抽取 $x_i$。\n- 宁静态晶格采样（也称为宁静态启动）：设置 $x_i = \\left(i-\\tfrac{1}{2}\\right)\\frac{L}{N}$，其中 $i \\in \\{1,2,\\dots,N\\}$。\n- 带高斯位移的抖动晶格采样：设置 $x_i = \\left(i-\\tfrac{1}{2}\\right)\\frac{L}{N} + \\varepsilon_i$，其中 $\\varepsilon_i$ 是独立的、均值为 $0$、方差为 $\\sigma^2$ 的高斯随机变量。\n\n从无碰撞系统在构型空间中表示为 Dirac delta 函数之和的基本形式、$[0,L)$ 上的周期性傅里叶表示以及独立随机变量的基本性质出发，推导以下对于 $n \\neq 0$ 的期望值：\n- 对于泊松采样，期望功率满足 $ \\mathbb{E}\\!\\left[P_\\mathrm{meas}(n)\\right] = \\frac{1}{N}$。\n- 对于宁静态晶格采样，对于所有满足 $1 \\le n  N$ 的整数 $n$，$P_\\mathrm{meas}(n) = 0$。\n- 对于方差为 $\\sigma^2$ 的独立高斯位移的抖动晶格采样，单个位移的特征函数为 $\\phi(k) = \\exp\\!\\left(-\\tfrac{1}{2}\\sigma^2 k^2\\right)$，并且模式 $n$ 处的期望功率为\n$$\n\\mathbb{E}\\!\\left[P_\\mathrm{meas}(n)\\right] = \\frac{1}{N}\\left(1 - \\left|\\phi(k_n)\\right|^2\\right) = \\frac{1}{N}\\left(1 - \\exp\\!\\left(-\\sigma^2 k_n^2\\right)\\right).\n$$\n\n实现一个程序，对于每个指定的测试用例，根据所选的采样策略构建 $\\{x_i\\}_{i=1}^N$，计算 $P_\\mathrm{meas}(n)$，并基于上述公式计算相应的理论预测值 $P_\\mathrm{theory}(n)$。当涉及随机性时，使用固定的随机数生成器种子以确保结果的可复现性。\n\n使用以下测试套件，该套件探测了典型情况、宁静态启动中的精确抵消、弱抖动以及接近类奈奎斯特区域的强抖动：\n- 情况 A（泊松采样）：$N = 1024$，$L = 1$，$n = 1$，随机数种子 $= 7$。\n- 情况 B（宁静态晶格）：$N = 64$，$L = 1$，$n = 1$。\n- 情况 C（抖动晶格）：$N = 256$，$L = 1$，$n = 3$，$\\sigma = 0.01$，随机数种子 $= 123$。\n- 情况 D（抖动晶格）：$N = 64$，$L = 1$，$n = 31$，$\\sigma = 0.1$，随机数种子 $= 1$。\n\n对于每种情况，你的程序必须计算并输出两个浮点数：首先是该情况下的 $P_\\mathrm{meas}(n)$，然后是 $P_\\mathrm{theory}(n)$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{情况 A }P_\\mathrm{meas}, \\text{情况 A }P_\\mathrm{theory}, \\text{情况 B }P_\\mathrm{meas}, \\text{情况 B }P_\\mathrm{theory}, \\text{情况 C }P_\\mathrm{meas}, \\text{情况 C }P_\\mathrm{theory}, \\text{情况 D }P_\\mathrm{meas}, \\text{情况 D }P_\\mathrm{theory}]$。所有量都是无量纲的，不需要物理单位。通过傅里叶相位 $k_n x$，角度被隐式地以弧度为单位。", "solution": "问题要求推导在一维周期性区域中，三种不同粒子采样策略所产生的伪密度波动的期望功率谱，然后通过数值实现来验证这些理论预测。我们首先给出每种情况的推导过程。\n\n该物理系统是周期性区间 $[0, L)$ 上的一个均匀质量分布，被离散化为 $N$ 个等质量的粒子。第 $i$ 个粒子的位置是 $x_i$。与完美均匀连续密度的偏离由粒子分布的傅里叶分量来量化。模式 $n$ 处的密度衬比的复振幅定义为\n$$\n\\delta_k(n) \\equiv \\frac{1}{N}\\sum_{i=1}^N \\exp\\!\\left(-\\mathrm{i}\\,k_n\\,x_i\\right)\n$$\n其中 $k_n = \\frac{2\\pi n}{L}$ 是整数模式指数 $n \\in \\mathbb{Z}$ 对应的波数。功率谱 $P_\\mathrm{meas}(n)$ 是此振幅的模平方：\n$$\nP_\\mathrm{meas}(n) \\equiv \\left|\\delta_k(n)\\right|^2 = \\delta_k(n) \\delta_k^*(n)\n$$\n其中 $\\delta_k^*(n)$ 是 $\\delta_k(n)$ 的复共轭。我们关心的是对于随机采样方法，此功率的期望值 $\\mathbb{E}\\!\\left[P_\\mathrm{meas}(n)\\right]$，或对于确定性方法，其直接值。我们将考虑 $n \\neq 0$ 的情况，因为 $n=0$ 模式对应于平均密度，而不是波动。\n\n**1. 泊松采样**\n\n在泊松采样中，粒子位置 $\\{x_i\\}_{i=1}^N$ 是从区间 $[0, L)$ 上的均匀概率分布中抽取的独立同分布（i.i.d.）随机变量。功率谱的期望值为\n$$\n\\mathbb{E}\\!\\left[P_\\mathrm{meas}(n)\\right] = \\mathbb{E}\\!\\left[ \\left( \\frac{1}{N}\\sum_{i=1}^N e^{-\\mathrm{i}k_n x_i} \\right) \\left( \\frac{1}{N}\\sum_{j=1}^N e^{\\mathrm{i}k_n x_j} \\right) \\right] = \\frac{1}{N^2} \\sum_{i=1}^N \\sum_{j=1}^N \\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n(x_i - x_j)} \\right]\n$$\n我们将这个双重求和分为对角项（$i=j$）和非对角项（$i \\neq j$）。\n\n对于对角项（$i=j$），我们有 $x_i - x_j = 0$，所以 $e^{-\\mathrm{i}k_n(x_i - x_j)} = e^0 = 1$。其期望值为 $\\mathbb{E}[1] = 1$。共有 $N$ 个这样的项。它们对总和的贡献是 $N$。\n\n对于非对角项（$i \\neq j$），位置 $x_i$ 和 $x_j$ 是独立的随机变量。因此，乘积的期望等于期望的乘积：\n$$\n\\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n(x_i - x_j)} \\right] = \\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n x_i} \\right] \\mathbb{E}\\!\\left[ e^{\\mathrm{i}k_n x_j} \\right]\n$$\n对于一个在 $[0, L)$ 上均匀分布的随机变量 $x$，$e^{-\\mathrm{i}k_n x}$ 的期望为\n$$\n\\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n x} \\right] = \\int_0^L \\frac{1}{L} e^{-\\mathrm{i}k_n x} dx = \\frac{1}{L} \\left[ \\frac{e^{-\\mathrm{i}k_n x}}{-\\mathrm{i}k_n} \\right]_0^L\n$$\n代入 $k_n = 2\\pi n / L$ 并假设 $n \\neq 0$：\n$$\n\\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n x} \\right] = \\frac{1}{L} \\frac{L}{-\\mathrm{i}2\\pi n} \\left( e^{-\\mathrm{i}2\\pi n} - e^0 \\right) = \\frac{1}{-\\mathrm{i}2\\pi n} (1 - 1) = 0\n$$\n由于 $\\mathbb{E}[e^{\\mathrm{i}k_n x_j}]$ 也为零，每个非对角项的期望都是 $0$。共有 $N^2 - N$ 个这样的项。\n\n结合对角项和非对角项的贡献，总和为 $N + 0 = N$。期望功率为：\n$$\n\\mathbb{E}\\!\\left[P_\\mathrm{meas}(n)\\right] = \\frac{1}{N^2} (N) = \\frac{1}{N}\n$$\n这个结果是粒子泊松分布的众所周知的散粒噪声水平。\n\n**2. 宁静态晶格采样**\n\n在宁静态晶格（或宁静态启动）采样中，粒子被放置在一个规则的网格上。其位置是确定性的：\n$$\nx_i = \\left(i - \\frac{1}{2}\\right)\\frac{L}{N} \\quad \\text{for } i \\in \\{1, 2, \\dots, N\\}\n$$\n复振幅 $\\delta_k(n)$ 为\n$$\n\\delta_k(n) = \\frac{1}{N} \\sum_{i=1}^N \\exp\\!\\left(-\\mathrm{i}k_n x_i\\right) = \\frac{1}{N} \\sum_{i=1}^N \\exp\\!\\left(-\\mathrm{i}\\frac{2\\pi n}{L} \\left(i - \\frac{1}{2}\\right)\\frac{L}{N}\\right) = \\frac{1}{N} \\sum_{i=1}^N \\exp\\!\\left(-\\mathrm{i}\\frac{2\\pi n}{N}\\left(i - \\frac{1}{2}\\right)\\right)\n$$\n我们可以分解出一个相位项：\n$$\n\\delta_k(n) = \\frac{1}{N} \\exp\\!\\left(\\mathrm{i}\\frac{\\pi n}{N}\\right) \\sum_{i=1}^N \\exp\\!\\left(-\\mathrm{i}\\frac{2\\pi n i}{N}\\right)\n$$\n该和是一个几何级数。令 $r = \\exp(-\\mathrm{i} \\frac{2\\pi n}{N})$。则该和为 $\\sum_{i=1}^N r^i = r + r^2 + \\dots + r^N = r \\frac{1-r^N}{1-r}$。问题指定了范围 $1 \\le n  N$，这确保了 $n$ 不是 $N$ 的倍数。因此，$r \\neq 1$。$r^N$ 项为\n$$\nr^N = \\left(\\exp\\!\\left(-\\mathrm{i}\\frac{2\\pi n}{N}\\right)\\right)^N = \\exp(-\\mathrm{i} 2\\pi n) = 1\n$$\n因为 $n$ 是一个整数。和的分子是 $1 - r^N = 1 - 1 = 0$。因此，整个和为零。\n这意味着 $\\delta_k(n) = 0$，所以对于所有满足 $1 \\le n  N$ 的整数模式 $n$，功率为\n$$\nP_\\mathrm{meas}(n) = \\left|\\delta_k(n)\\right|^2 = 0\n$$\n这种完美的抵消正是这种方法被称为“宁静”启动的原因。\n\n**3. 抖动晶格采样**\n\n抖动晶格采样从一个宁静态晶格开始，并添加小的随机位移。位置为\n$$\nx_i = x_{i,0} + \\varepsilon_i = \\left(i - \\frac{1}{2}\\right)\\frac{L}{N} + \\varepsilon_i\n$$\n其中 $\\varepsilon_i$ 是从均值为 $0$、方差为 $\\sigma^2$ 的高斯分布中抽取的独立同分布随机变量。期望功率的分析遵循与泊松采样相同的初始步骤：\n$$\n\\mathbb{E}\\!\\left[P_\\mathrm{meas}(n)\\right] = \\frac{1}{N^2} \\sum_{i=1}^N \\sum_{j=1}^N \\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n(x_i - x_j)} \\right]\n$$\n期望项为 $\\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n(x_{i,0} - x_{j,0})} e^{-\\mathrm{i}k_n(\\varepsilon_i - \\varepsilon_j)} \\right] = e^{-\\mathrm{i}k_n(x_{i,0} - x_{j,0})} \\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n(\\varepsilon_i - \\varepsilon_j)} \\right]$。\n\n对于对角项（$i=j$），$x_{i,0} - x_{j,0} = 0$ 且 $\\varepsilon_i - \\varepsilon_j = 0$。该项为 $1$。共有 $N$ 个这样的项。\n\n对于非对角项（$i \\neq j$），位移 $\\varepsilon_i$ 和 $\\varepsilon_j$ 是独立的。因此，\n$$\n\\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n(\\varepsilon_i - \\varepsilon_j)} \\right] = \\mathbb{E}\\!\\left[ e^{-\\mathrm{i}k_n \\varepsilon_i} \\right] \\mathbb{E}\\!\\left[ e^{\\mathrm{i}k_n \\varepsilon_j} \\right]\n$$\n项 $\\mathbb{E}[e^{-\\mathrm{i}k \\varepsilon}]$ 是随机变量 $\\varepsilon$ 的特征函数的定义，记作 $\\phi(k)$。所以，$\\mathbb{E}[e^{-\\mathrm{i}k_n \\varepsilon_i}] = \\phi(k_n)$ 且 $\\mathbb{E}[e^{\\mathrm{i}k_n \\varepsilon_j}] = \\phi(-k_n)$。对于实值概率分布，$\\phi(-k) = \\phi^*(k)$，即复共轭。因此，乘积为 $|\\phi(k_n)|^2$。非对角项的期望变为 $e^{-\\mathrm{i}k_n(x_{i,0} - x_{j,0})} |\\phi(k_n)|^2$。\n\n总期望为：\n$$\n\\mathbb{E}\\!\\left[P_\\mathrm{meas}(n)\\right] = \\frac{1}{N^2} \\left( N + \\sum_{i \\neq j} e^{-\\mathrm{i}k_n(x_{i,0} - x_{j,0})} |\\phi(k_n)|^2 \\right)\n$$\n对 $i \\neq j$ 的求和可以重写为：\n$$\n\\sum_{i \\neq j} (\\dots) = \\left( \\sum_{i,j} e^{-\\mathrm{i}k_n(x_{i,0} - x_{j,0})} \\right) - \\left( \\sum_{i=j} e^0 \\right) = \\left| \\sum_i e^{-\\mathrm{i}k_n x_{i,0}} \\right|^2 - N\n$$\n从宁静态晶格的推导中我们知道，对于 $1 \\le n  N$，和 $\\sum_i e^{-\\mathrm{i}k_n x_{i,0}}$ 为零。因此，对 $i \\neq j$ 的求和结果为 $-N$。\n将此代回，非对角项的贡献为 $-N|\\phi(k_n)|^2$。总期望功率为：\n$$\n\\mathbb{E}\\!\\left[P_\\mathrm{meas}(n)\\right] = \\frac{1}{N^2} \\left( N - N|\\phi(k_n)|^2 \\right) = \\frac{1}{N}\\left(1 - |\\phi(k_n)|^2\\right)\n$$\n对于高斯位移 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2)$，其特征函数为 $\\phi(k) = \\exp(-\\frac{1}{2}\\sigma^2 k^2)$。它是实数，所以 $|\\phi(k_n)|^2 = \\left(\\exp(-\\frac{1}{2}\\sigma^2 k_n^2)\\right)^2 = \\exp(-\\sigma^2 k_n^2)$。\n这就得出了最终的表达式：\n$$\n\\mathbb{E}\\!\\left[P_\\mathrm{meas}(n)\\right] = \\frac{1}{N}\\left(1 - \\exp(-\\sigma^2 k_n^2)\\right)\n$$\n此推导证实了问题陈述中提供的理论公式。这些公式构成了后续数值计算的基础。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes measured and theoretical power of density fluctuations\n    for different particle sampling strategies.\n    \"\"\"\n    test_cases = [\n        {'type': 'poisson', 'N': 1024, 'L': 1.0, 'n': 1, 'seed': 7},\n        {'type': 'quiet', 'N': 64, 'L': 1.0, 'n': 1},\n        {'type': 'jittered', 'N': 256, 'L': 1.0, 'n': 3, 'sigma': 0.01, 'seed': 123},\n        {'type': 'jittered', 'N': 64, 'L': 1.0, 'n': 31, 'sigma': 0.1, 'seed': 1},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        n = case['n']\n        \n        # Calculate the wavenumber\n        k_n = 2 * np.pi * n / L\n\n        # Generate particle positions based on the sampling strategy\n        if case['type'] == 'poisson':\n            rng = np.random.default_rng(case['seed'])\n            x = L * rng.random(size=N)\n            p_theory = 1.0 / N\n        \n        elif case['type'] == 'quiet':\n            # Particle positions for quiet lattice sampling\n            # x_i = (i - 1/2) * L / N for i = 1, ..., N\n            i = np.arange(1, N + 1)\n            x = (i - 0.5) * L / N\n            p_theory = 0.0\n\n        elif case['type'] == 'jittered':\n            sigma = case['sigma']\n            rng = np.random.default_rng(case['seed'])\n            \n            # Base lattice positions\n            i = np.arange(1, N + 1)\n            x_lattice = (i - 0.5) * L / N\n            \n            # Add Gaussian displacements\n            displacements = rng.normal(loc=0.0, scale=sigma, size=N)\n            \n            # Final positions with periodic boundary conditions\n            x = (x_lattice + displacements) % L\n            \n            p_theory = (1.0 / N) * (1.0 - np.exp(-sigma**2 * k_n**2))\n\n        # Calculate the measured power\n        # delta_k(n) = 1/N * sum(exp(-i * k_n * x_i))\n        # The mean of the complex exponentials is equivalent to the normalized sum\n        delta_k = np.mean(np.exp(-1j * k_n * x))\n        p_meas = np.abs(delta_k)**2\n        \n        results.append(p_meas)\n        results.append(p_theory)\n\n    # Format the final output as a single comma-separated line in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3518281"}, {"introduction": "在放置粒子后，下一步是计算引力。为了提高效率，粒子-网格（PM）方法在网格上求解泊松方程，其中一个关键选择是如何处理网格的边界。本练习 [@problem_id:3518246] 对比了两种常见方法：周期性边界条件（适用于宇宙学）和孤立边界条件（适用于星系等孤立物体）。它提供了一种动手测量周期性在模拟孤立物体时可能引入的“伪镜像力”的方法，这是初学者常见的陷阱。", "problem": "您需要为一个无碰撞系统实现并比较两种粒子-网格（PM）引力求解器，这两种求解器仅在边界条件上有所不同：一种是使用傅里叶空间解（等效于 Ewald 求和）的周期性边界，另一种是使用零填充卷积和软化格林函数的孤立边界。其目的是量化相对于孤立自由空间解，位于盒子边缘附近的晕所受到的虚假镜像力。\n\n从无碰撞动力学的 Vlasov-Poisson 描述开始。相空间分布函数 $f(\\boldsymbol{x},\\boldsymbol{v},t)$ 根据无碰撞玻尔兹曼方程（也称 Vlasov 方程）演化，引力势 $\\phi(\\boldsymbol{x},t)$ 求解泊松方程。在 PM 求解器中，质量密度 $\\rho(\\boldsymbol{x})$ 在网格上被离散化，引力势 $\\phi(\\boldsymbol{x})$ 通过求解泊松方程获得。您将实现：\n- 一个周期性傅里叶空间求解器，它将零频模式设置为零（背景扣除），这在数学上等效于对周期性镜像的长程势进行 Ewald 求和处理。\n- 一个孤立求解器，它通过零填充和快速傅里叶变换（FFT）将密度与软化格林函数进行卷积，从而计算自由空间势。\n\n密度场代表一个单独的 Plummer 晕：\n- 质量密度由 Plummer 剖面给出：$\\,\\rho(\\boldsymbol{x}) = \\dfrac{3 M}{4 \\pi a^3} \\left(1 + \\dfrac{|\\boldsymbol{x}-\\boldsymbol{x}_0|^2}{a^2}\\right)^{-5/2}\\,$，其中 $M$ 是晕质量，$a$ 是 Plummer 尺度，$\\boldsymbol{x}_0$ 是晕中心。\n- 盒子是一个边长为 $L$ 的立方体，具有一个均匀的 $N \\times N \\times N$ 笛卡尔网格，网格点位于单元中心位置。\n\n定义和约束：\n- 使用引力常数 $G = 1$。\n- 使用边长 $L = 1$。\n- 使用网格大小 $N = 48$。\n- 使用晕质量 $M = 1$。\n- 使用 Plummer 尺度 $a = 0.05$。\n- 使用格林函数软化长度 $\\epsilon = 2 \\Delta x$，其中 $\\Delta x = L/N$ 是网格间距。\n- 在周期性求解器中，在傅里叶空间中用波矢 $\\boldsymbol{k} = (k_x,k_y,k_z)$ 求解泊松方程，对于 $|\\boldsymbol{k}| \\neq 0$ 使用 $\\phi_{\\boldsymbol{k}} = - 4 \\pi G \\,\\rho_{\\boldsymbol{k}} / |\\boldsymbol{k}|^2$，并设置 $\\phi_{\\boldsymbol{0}} = 0$。在傅里叶空间中计算加速度为 $\\boldsymbol{a}_{\\boldsymbol{k}} = - i \\boldsymbol{k} \\,\\phi_{\\boldsymbol{k}}$，然后逆变换到实空间。\n- 在孤立求解器中，在一个大小为 $(2N)^3$ 的零填充网格上构造软化格林函数 $\\,g(\\boldsymbol{r}) = - \\dfrac{G}{\\sqrt{|\\boldsymbol{r}|^2 + \\epsilon^2}}\\,$，其中离散网格坐标覆盖每轴 $[-N,N)$ 个单元，并通过 FFT 在填充网格上使用循环卷积计算 $\\,\\phi(\\boldsymbol{x}) \\approx (\\rho \\star g)(\\boldsymbol{x}) \\,\\Delta x^3\\,$，然后提取原始 $N^3$ 域上的势。通过有限差分计算加速度为 $\\boldsymbol{a}(\\boldsymbol{x}) = - \\nabla \\phi(\\boldsymbol{x})$。\n\n用于评估虚假镜像力的误差度量：\n- 对于位于位置 $\\boldsymbol{x}_{\\mathrm{t}}$ 的无质量示踪粒子，定义通过各自加速度网格进行三线性插值得到的孤立边界加速度 $\\boldsymbol{a}_{\\mathrm{iso}}$ 和周期性边界加速度 $\\boldsymbol{a}_{\\mathrm{per}}$。\n- 定义相对虚假镜像力为 $\\,\\delta = \\dfrac{\\left\\|\\boldsymbol{a}_{\\mathrm{per}} - \\boldsymbol{a}_{\\mathrm{iso}}\\right\\|}{\\left\\|\\boldsymbol{a}_{\\mathrm{iso}}\\right\\|}\\,$。\n\n实现以下包含三个案例的测试套件，每个案例都指定了晕中心 $\\boldsymbol{x}_0$ 和相对于晕中心的示踪粒子偏移量 $\\boldsymbol{d}$，所有坐标都在盒子域内。选择偏移量以确保示踪粒子在盒子内部：\n- 案例 1（理想情况，晕位于盒子中心）：$\\boldsymbol{x}_0 = (0.5, 0.5, 0.5)$，$\\boldsymbol{d} = (0.05, 0, 0)$，因此 $\\boldsymbol{x}_{\\mathrm{t}} = \\boldsymbol{x}_0 + \\boldsymbol{d}$。\n- 案例 2（晕靠近一个面）：$\\boldsymbol{x}_0 = (0.9, 0.5, 0.5)$，$\\boldsymbol{d} = (-0.05, 0, 0)$，因此 $\\boldsymbol{x}_{\\mathrm{t}} = \\boldsymbol{x}_0 + \\boldsymbol{d}$。\n- 案例 3（晕靠近一个角）：$\\boldsymbol{x}_0 = (0.95, 0.95, 0.95)$，$\\boldsymbol{d} = (-0.03, -0.03, -0.03)$，因此 $\\boldsymbol{x}_{\\mathrm{t}} = \\boldsymbol{x}_0 + \\boldsymbol{d}$。\n\n算法要求：\n- 在单元中心上构造密度场。\n- 对于周期性求解器，在谱空间计算 $\\phi_{\\boldsymbol{k}}$ 和 $\\boldsymbol{a}$，应用零模式移除和适当的波矢网格。\n- 对于孤立求解器，计算填充后的格林函数，并执行基于 FFT 的卷积，其中包含软化 $\\epsilon$，按 $\\Delta x^3$ 缩放，提取原始域上的势，并通过有限差分计算 $\\boldsymbol{a}$。\n- 对两个求解器（周期性情况下使用周期性环绕；孤立情况下钳位在域内），使用三线性插值在 $\\boldsymbol{x}_{\\mathrm{t}}$ 处插值加速度。\n\n您的程序必须为每个案例输出相对虚假镜像力 $\\delta$ 作为实数。因为所有量都是无量纲的（$G=L=M=1$），所以没有物理单位需要报告。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为方括号内的逗号分隔列表，按三个案例的顺序排列，例如 $[\\delta_1,\\delta_2,\\delta_3]$。", "solution": "该问题是有效的，因为它提出了一个定义明确、具有科学依据的计算天体物理学任务。所有参数、方程和算法都足够清晰，可以得出一个唯一且可验证的解。\n\n该问题要求比较两种用于单个 Plummer 晕的引力势和加速度的粒子-网格（PM）求解器。PM 方法的核心在于在离散网格上求解泊松方程 $\\nabla^2\\phi = 4\\pi G \\rho$。这两种求解器在边界条件的处理上有所不同，这从根本上改变了求解方法。\n\n首先，我们将 Plummer 晕的质量密度离散化到一个均匀的笛卡尔网格上。模拟盒子的边长为 $L=1$，并被划分为 $N^3 = 48^3$ 个单元。网格间距为 $\\Delta x = L/N$。Plummer 剖面的质量密度 $\\rho(\\boldsymbol{x}) = \\frac{3M}{4\\pi a^2}\\left(1 + \\frac{|\\boldsymbol{x}-\\boldsymbol{x}_0|^2}{a^2}\\right)^{-5/2}$ 在每个网格单元的中心 $\\boldsymbol{x}_{ijk}$ 处进行评估。这里，$M=1$ 是晕的质量，$a=0.05$ 是其尺度长度。\n\n**1. 周期性边界条件求解器**\n\n该求解器假设模拟盒子在整个空间中周期性地复制。这一假设允许使用快速傅里叶变换（FFT）高效地求解泊松方程。泊松方程的傅里叶变换是代数形式的：\n$$\n(-|\\boldsymbol{k}|^2) \\phi_{\\boldsymbol{k}} = 4\\pi G \\rho_{\\boldsymbol{k}} \\implies \\phi_{\\boldsymbol{k}} = -\\frac{4\\pi G \\rho_{\\boldsymbol{k}}}{|\\boldsymbol{k}|^2}\n$$\n其中 $\\phi_{\\boldsymbol{k}}$ 和 $\\rho_{\\boldsymbol{k}}$ 分别是势和密度的傅里叶系数，$\\boldsymbol{k}$ 是波矢。离散波矢由 $\\boldsymbol{k} = (k_x, k_y, k_z)$ 给出，其中 $k_i = 2\\pi n_i/L$，整数 $n_i \\in [-N/2, N/2-1]$。\n\n$|\\boldsymbol{k}|^2=0$（零频或直流）模式对应于平均势，需要特殊处理。按照规定，我们设置 $\\phi_{\\boldsymbol{k}=\\boldsymbol{0}} = 0$，这相当于减去宇宙的平均密度，并确保盒子上的净引力为零。这种处理在数学上等效于对所有周期性镜像产生的势进行 Ewald 求和。\n\n加速度 $\\boldsymbol{a} = -\\nabla\\phi$ 也在谱空间中计算。傅里叶空间中的梯度算子对应于乘以 $i\\boldsymbol{k}$。因此，加速度的傅里叶变换是：\n$$\n\\boldsymbol{a}_{\\boldsymbol{k}} = -i\\boldsymbol{k} \\phi_{\\boldsymbol{k}}\n$$\n然后，通过对 $\\boldsymbol{a}_{\\boldsymbol{k}}$ 应用逆 FFT 获得加速度场 $\\boldsymbol{a}_{\\mathrm{per}}(\\boldsymbol{x})$。\n\n**2. 孤立边界条件求解器**\n\n该求解器计算自由空间势，将晕视为无限空宇宙中的一个孤立物体。在这种情况下，泊松方程的解由卷积积分给出：\n$$\n\\phi(\\boldsymbol{x}) = \\int \\rho(\\boldsymbol{x}') g(\\boldsymbol{x} - \\boldsymbol{x}') d^3\\boldsymbol{x}' \\approx \\sum_j \\rho(\\boldsymbol{x}_j) g(\\boldsymbol{x} - \\boldsymbol{x}_j) (\\Delta x)^3\n$$\n其中 $g(\\boldsymbol{r})$ 是势的格林函数。为了避免在 $\\boldsymbol{r}=0$ 处的奇点，使用了一个软化的格林函数：\n$$\ng(\\boldsymbol{r}) = -\\frac{G}{\\sqrt{|\\boldsymbol{r}|^2 + \\epsilon^2}}\n$$\n软化长度为 $\\epsilon = 2\\Delta x$。\n\n卷积可以通过 FFT 利用卷积定理高效计算：$\\mathcal{F}\\{\\rho \\star g\\} = \\mathcal{F}\\{\\rho\\} \\cdot \\mathcal{F}\\{g\\}$。为了防止 FFT 计算循环卷积（这会重新引入周期性假象），密度场被零填充。将 $N^3$ 的密度网格放置在一个更大的、填满零的 $(2N)^3$ 网格的一角。格林函数也构建在这个更大的网格上，并遵循基于 FFT 的卷积所需的环绕索引。在对变换后场的乘积进行逆 FFT 后，将结果乘以单元体积 $(\\Delta x)^3$ 以近似积分。然后从填充网格中提取势场 $\\phi_{\\mathrm{iso}}(\\boldsymbol{x})$，取与原始模拟域对应的 $N^3$ 子网格。\n\n然后，通过对势场取数值梯度来计算加速度场 $\\boldsymbol{a}_{\\mathrm{iso}}(\\boldsymbol{x})$，即 $\\boldsymbol{a} = -\\nabla\\phi$，使用有限差分法。\n\n**3. 误差度量计算**\n\n对于每个测试案例，必须在特定的示踪粒子位置 $\\boldsymbol{x}_{\\mathrm{t}}$ 处评估加速度矢量 $\\boldsymbol{a}_{\\mathrm{per}}$ 和 $\\boldsymbol{a}_{\\mathrm{iso}}$。由于 $\\boldsymbol{x}_{\\mathrm{t}}$ 通常不与网格点重合，因此使用三线性插值从包围它的网格单元的 8 个角点的值来估计加速度。对于周期性求解器，插值通过环绕网格索引来处理跨边界情况。对于孤立求解器，索引被钳位以保持在网格域 $[0, N-1]$ 内。\n\n然后，相对虚假镜像力 $\\delta$ 被计算为两个加速度矢量之差的模与更物理精确的孤立加速度的模之比：\n$$\n\\delta = \\frac{\\|\\boldsymbol{a}_{\\mathrm{per}}(\\boldsymbol{x}_{\\mathrm{t}}) - \\boldsymbol{a}_{\\mathrm{iso}}(\\boldsymbol{x}_{\\mathrm{t}})\\|}{\\|\\boldsymbol{a}_{\\mathrm{iso}}(\\boldsymbol{x}_{\\mathrm{t}})\\|}\n$$\n该度量量化了由周期性边界假设引入的相对误差，当晕更靠近盒子边界时，预计该误差会更大。", "answer": "```python\nimport numpy as np\n\ndef trilinear_interp(field, pos, box_L, periodic=False):\n    \"\"\"\n    Performs trilinear interpolation on a 3D vector field.\n\n    Args:\n        field (np.ndarray): The (N, N, N, 3) vector field on the grid.\n        pos (np.ndarray): The (3,) position vector to interpolate at.\n        box_L (float): The side length of the simulation box.\n        periodic (bool): If True, use periodic boundary conditions.\n    \n    Returns:\n        np.ndarray: The interpolated (3,) vector.\n    \"\"\"\n    N = field.shape[0]\n    dx = box_L / N\n    \n    # Position in grid units, relative to cell centers\n    # A point at position p is at grid coordinate (p/dx - 0.5)\n    # relative to the grid node indices.\n    grid_coord = pos / dx - 0.5\n    \n    # Get lower-left corner index and fractional distance\n    ijk = np.floor(grid_coord).astype(int)\n    t = grid_coord - ijk\n    tx, ty, tz = t\n\n    # Get integer indices of 8 corners\n    i0, j0, k0 = ijk\n    i1, j1, k1 = ijk + 1\n    \n    # Boundary handling\n    if periodic:\n        i0, i1 = i0 % N, i1 % N\n        j0, j1 = j0 % N, j1 % N\n        k0, k1 = k0 % N, k1 % N\n    else: # Clamping\n        i0, i1 = np.clip([i0, i1], 0, N - 1)\n        j0, j1 = np.clip([j0, j1], 0, N - 1)\n        k0, k1 = np.clip([k0, k1], 0, N - 1)\n    \n    # Get field values at the 8 corners\n    v000 = field[i0, j0, k0, :]\n    v100 = field[i1, j0, k0, :]\n    v010 = field[i0, j1, k0, :]\n    v001 = field[i0, j0, k1, :]\n    v110 = field[i1, j1, k0, :]\n    v101 = field[i1, j0, k1, :]\n    v011 = field[i0, j1, k1, :]\n    v111 = field[i1, j1, k1, :]\n\n    # Interpolate along x\n    v_00 = v000 * (1 - tx) + v100 * tx\n    v_10 = v010 * (1 - tx) + v110 * tx\n    v_01 = v001 * (1 - tx) + v101 * tx\n    v_11 = v011 * (1 - tx) + v111 * tx\n    \n    # Interpolate along y\n    v__0 = v_00 * (1 - ty) + v_10 * ty\n    v__1 = v_01 * (1 - ty) + v_11 * ty\n\n    # Interpolate along z\n    return v__0 * (1 - tz) + v__1 * tz\n\ndef solve():\n    \"\"\"\n    Implements and compares periodic and isolated PM solvers.\n    \"\"\"\n    # Define constants and parameters\n    G = 1.0\n    L = 1.0\n    N = 48\n    M = 1.0\n    a = 0.05\n    \n    # Define test cases: (halo_center, tracer_offset)\n    test_cases = [\n        ((0.5, 0.5, 0.5), (0.05, 0.0, 0.0)),\n        ((0.9, 0.5, 0.5), (-0.05, 0.0, 0.0)),\n        ((0.95, 0.95, 0.95), (-0.03, -0.03, -0.03)),\n    ]\n\n    # Derived parameters\n    dx = L / N\n    epsilon = 2.0 * dx\n\n    # --- Pre-computation of grids and kernels ---\n\n    # Real space grid (cell centers) for N^3 box\n    x_1d = (np.arange(N) + 0.5) * dx\n    X, Y, Z = np.meshgrid(x_1d, x_1d, x_1d, indexing='ij')\n\n    # Fourier space wavevectors for N^3 box\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    Kx, Ky, Kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n    Ksq = Kx**2 + Ky**2 + Kz**2\n\n    # A. Periodic solver potential kernel\n    with np.errstate(divide='ignore', invalid='ignore'):\n        phi_kernel_k_periodic = -4.0 * np.pi * G / Ksq\n    phi_kernel_k_periodic[0, 0, 0] = 0.0\n\n    # B. Isolated solver Green's function\n    Np = 2 * N\n    # Coordinates for convolution kernel on padded grid\n    i_p = np.arange(Np)\n    r_1d_p = np.where(i_p  Np / 2, i_p - Np, i_p) * dx\n    Rx_p, Ry_p, Rz_p = np.meshgrid(r_1d_p, r_1d_p, r_1d_p, indexing='ij')\n    Rsq_p = Rx_p**2 + Ry_p**2 + Rz_p**2\n    \n    green_func = -G / np.sqrt(Rsq_p + epsilon**2)\n    green_func_k = np.fft.fftn(green_func)\n\n    results = []\n    for x0_tuple, d_tuple in test_cases:\n        x0 = np.array(x0_tuple)\n        d = np.array(d_tuple)\n        xt = x0 + d\n\n        # 1. Construct Density Field on the N^3 grid\n        r_sq = (X - x0[0])**2 + (Y - x0[1])**2 + (Z - x0[2])**2\n        rho = (3.0 * M / (4.0 * np.pi * a**3)) * (1.0 + r_sq / a**2)**(-2.5)\n\n        # 2. Periodic Solver\n        rho_k = np.fft.fftn(rho)\n        phi_k = rho_k * phi_kernel_k_periodic\n        \n        ax_k = -1j * Kx * phi_k\n        ay_k = -1j * Ky * phi_k\n        az_k = -1j * Kz * phi_k\n\n        ax_per = np.fft.ifftn(ax_k).real\n        ay_per = np.fft.ifftn(ay_k).real\n        az_per = np.fft.ifftn(az_k).real\n        a_per_grid = np.stack((ax_per, ay_per, az_per), axis=-1)\n\n        # 3. Isolated Solver\n        rho_padded = np.zeros((Np, Np, Np))\n        rho_padded[:N, :N, :N] = rho\n        \n        rho_padded_k = np.fft.fftn(rho_padded)\n        phi_padded_k = rho_padded_k * green_func_k\n        phi_padded = np.fft.ifftn(phi_padded_k).real\n        \n        phi_iso = phi_padded[:N, :N, :N] * (dx**3)\n\n        grad_phi = np.gradient(-phi_iso, dx)\n        a_iso_grid = np.stack(grad_phi, axis=-1)\n\n        # 4. Interpolation and Comparison\n        a_per = trilinear_interp(a_per_grid, xt, L, periodic=True)\n        a_iso = trilinear_interp(a_iso_grid, xt, L, periodic=False)\n\n        # 5. Calculate fractional spurious image force\n        delta = np.linalg.norm(a_per - a_iso) / np.linalg.norm(a_iso)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3518246"}, {"introduction": "计算出作用力后，我们必须更新粒子的位置和速度。积分器的选择对模拟的长期保真度至关重要。本练习 [@problem_id:3518329] 实现并比较了标准的二阶蛙跳积分器与一种更高阶的辛方法。它侧重于验证两个关键特性：能量守恒误差的标度关系和相空间体积的保持性，这些都是优秀的辛积分器的标志，对于在多个动力学时标上模拟无碰撞系统至关重要。", "problem": "你必须实现并比较用于静态、孤立的Hernquist晕势中无碰撞示踪粒子运动的时间积分器。该系统模拟一个在固定球对称势下演化的单一相空间点，是无碰撞动力学的一个特例，可由带有不随时变的泊松求解场的Vlasov方程描述。基本模型是牛顿引力，采用哈密顿力学和正则坐标。使用以下基本事实，不要使用简化公式：\n- 牛顿定律指出 $d\\boldsymbol{r}/dt = \\boldsymbol{v}$ 和 $d\\boldsymbol{v}/dt = \\boldsymbol{a}(\\boldsymbol{r})$，其中 $\\boldsymbol{a}(\\boldsymbol{r})$ 是加速度场。\n- 对于不随时变的势 $\\Phi(\\boldsymbol{r})$，单位质量粒子的哈密顿量为 $H = T + V = \\tfrac{1}{2}\\lvert \\boldsymbol{v} \\rvert^{2} + \\Phi(\\boldsymbol{r})$。\n- Hernquist晕势为 $\\Phi(r) = -\\dfrac{G M}{r + a}$，其中 $r = \\lVert \\boldsymbol{r} \\rVert$；力为 $\\boldsymbol{F}(\\boldsymbol{r}) = -\\nabla \\Phi = -\\dfrac{G M}{(r + a)^{2}} \\dfrac{\\boldsymbol{r}}{r}$。\n- 辛分裂源于将哈密顿流分解为由 $T(\\boldsymbol{v})$ 和 $V(\\boldsymbol{r})$ 生成的精确子流，这些子流组合后产生辛映射。\n\n你的任务：\n1. 实现一个使用踢-漂-踢（kick-drift-kick）组合的二阶蛙跳积分器。推导并编码在步长为 $h$ 的时间步内，组合 $T$ 和 $V$ 的精确流所隐含的正则更新。\n2. 实现一个四阶辛分裂方法，该方法通过组合具有适当选择的标量系数的二阶踢-漂-踢步骤获得，以达到形式上的四阶精度。推导该组合的结构，并论证产生四阶方法的系数选择的合理性。\n3. 对每种方法，通过以步长 $h$ 和 $h/2$ 积分轨道总时间 $T$，计算整个轨道相对于初始能量 $E_0$ 的最大绝对相对能量偏差，并报告在步长 $h$ 下的该值与在步长 $h/2$ 下的相同值之比，即 $\\max_{t \\in [0,T]} \\lvert E(t) - E_{0} \\rvert / \\lvert E_{0} \\rvert$ 在 $h$ 的值除以在 $h/2$ 的值。\n4. 通过在六维 $(\\boldsymbol{r}, \\boldsymbol{v})$ 空间上使用有限差分来近似初始条件下单步映射的雅可比行列式，评估相空间体积的守恒性，并报告绝对偏差 $\\lvert \\det(J) - 1 \\rvert$。使用足够小的扰动大小以捕捉局部线性化。\n\n使用无量纲单位，其中 $G = 1$, $M = 1$, $a = 1$，单位质量 $m = 1$。位置单位为 $a$，时间单位为 $(a^{3}/G M)^{1/2}$，速度单位为 $(G M / a)^{1/2}$。所有输出均表示为无量纲浮点数。\n\n测试套件：\n- 情况1（大半径近圆轨道）：$\\boldsymbol{r}_{0} = (5, 0, 0)$，$\\boldsymbol{v}_{0} = (0, v_{\\mathrm{circ}}(5), 0)$ 其中 $v_{\\mathrm{circ}}(r) = \\sqrt{ r \\, \\dfrac{G M}{(r + a)^{2}} }$；使用 $h = 0.02$ 和 $T = 200$。\n- 情况2（低于逃逸速度的径向轨道）：$\\boldsymbol{r}_{0} = (2, 0, 0)$，$\\boldsymbol{v}_{0} = (0.5 \\, v_{\\mathrm{esc}}(2), 0, 0)$ 其中 $v_{\\mathrm{esc}}(r) = \\sqrt{ \\dfrac{2 G M}{r + a} }$；使用 $h = 0.02$ 和 $T = 200$。\n- 情况3（穿越中心的低角动量轨道）：$\\boldsymbol{r}_{0} = (0.5, 0, 0)$，$\\boldsymbol{v}_{0} = (-0.2 \\, v_{\\mathrm{circ}}(0.5), 0.2 \\, v_{\\mathrm{circ}}(0.5), 0)$；使用 $h = 0.02$ 和 $T = 200$。\n\n对于每种情况，计算：\n- 蛙跳积分器的能量误差标度比：$\\mathsf{ratio}_{\\mathrm{LF}} = \\dfrac{\\max_{t} \\lvert E_{h}(t) - E_{0} \\rvert / \\lvert E_{0} \\rvert}{\\max_{t} \\lvert E_{h/2}(t) - E_{0} \\rvert / \\lvert E_{0} \\rvert}$。\n- 四阶方法的能量误差标度比：$\\mathsf{ratio}_{\\mathrm{S4}}$ 定义类似。\n- 蛙跳积分器的相空间体积偏差：$\\delta_{\\mathrm{vol, LF}} = \\lvert \\det(J_{\\mathrm{LF}}) - 1 \\rvert$ 在步长为 $h$ 的一步后。\n- 四阶方法的相空间体积偏差：$\\delta_{\\mathrm{vol, S4}} = \\lvert \\det(J_{\\mathrm{S4}}) - 1 \\rvert$ 在步长为 $h$ 的一步后。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况1、2、3的以下顺序列出结果：\n$[\\mathsf{ratio}_{\\mathrm{LF},1}, \\mathsf{ratio}_{\\mathrm{S4},1}, \\delta_{\\mathrm{vol, LF},1}, \\delta_{\\mathrm{vol, S4},1}, \\mathsf{ratio}_{\\mathrm{LF},2}, \\mathsf{ratio}_{\\mathrm{S4},2}, \\delta_{\\mathrm{vol, LF},2}, \\delta_{\\mathrm{vol, S4},2}, \\mathsf{ratio}_{\\mathrm{LF},3}, \\mathsf{ratio}_{\\mathrm{S4},3}, \\delta_{\\mathrm{vol, LF},3}, \\delta_{\\mathrm{vol, S4},3}]$。\n所有量均为浮点数。\n\n角度不是必需的；不要输出任何角度。由于所有量都指定为无量纲，因此无需打印物理单位。答案仅为数值浮点数。该测试套件是自足的，涵盖了近圆轨道、径向轨道和穿越中心附近的低角动量轨道，从而在质적으로不同的动力学区域中探究精度和体积守恒性。", "solution": "该问题要求实现并比较两种辛积分器——二阶蛙跳方法和四阶分裂方法——用于静态Hernquist势中示踪粒子的运动。分析涉及量化几种不同轨道的能量守恒误差和相空间体积守恒性。\n\n该系统由一个单位质量（$m=1$）粒子的不随时变的哈密顿量控制：\n$$\nH(\\boldsymbol{r}, \\boldsymbol{v}) = T(\\boldsymbol{v}) + V(\\boldsymbol{r}) = \\frac{1}{2} |\\boldsymbol{v}|^2 + \\Phi(\\boldsymbol{r})\n$$\n其中 $\\boldsymbol{r}$ 是位置矢量，$\\boldsymbol{v}$ 是速度矢量，$\\Phi(\\boldsymbol{r})$ 是引力势。Hernquist势由以下公式给出：\n$$\n\\Phi(r) = -\\frac{G M}{r + a}\n$$\n其中 $r = \\lVert \\boldsymbol{r} \\rVert$ 是径向距离。在指定的无量纲单位中，$G=1$，$M=1$，且 $a=1$，因此势简化为 $\\Phi(r) = -1/(r+1)$。运动方程是哈密顿方程：\n$$\n\\frac{d\\boldsymbol{r}}{dt} = \\frac{\\partial H}{\\partial \\boldsymbol{v}} = \\boldsymbol{v}\n$$\n$$\n\\frac{d\\boldsymbol{v}}{dt} = -\\frac{\\partial H}{\\partial \\boldsymbol{r}} = -\\nabla\\Phi(\\boldsymbol{r})\n$$\n加速度 $\\boldsymbol{a}(\\boldsymbol{r}) = -\\nabla\\Phi(\\boldsymbol{r})$ 从势计算得出：\n$$\n\\boldsymbol{a}(\\boldsymbol{r}) = -\\frac{d\\Phi}{dr} \\frac{\\boldsymbol{r}}{r} = -\\left( \\frac{d}{dr} \\left(-\\frac{1}{r+1}\\right) \\right) \\frac{\\boldsymbol{r}}{r} = -\\frac{1}{(r+1)^2} \\frac{\\boldsymbol{r}}{r}\n$$\n\n运动方程的形式解通过李算子 $\\mathcal{L}_H = \\{\\cdot, H\\}$ 的指数，将状态矢量 $\\boldsymbol{z} = (\\boldsymbol{r}, \\boldsymbol{v})$ 在一个时间步 $h$ 内向前推进：$\\boldsymbol{z}(t+h) = \\exp(h \\mathcal{L}_H) \\boldsymbol{z}(t)$。辛积分器是通过使用Baker-Campbell-Hausdorff (BCH) 公式分裂此算子来构造的。我们将哈密顿量分裂为其动能 $T$ 和势能 $V$ 部分。算子变为 $\\mathcal{L}_H = \\mathcal{L}_T + \\mathcal{L}_V$。在每个部分下的演化都很容易精确求解：\n1. 由 $T(\\boldsymbol{v})$ 在时间 $h$ 内生成的流，记为 $\\exp(h\\mathcal{L}_T)$，对应于 $\\dot{\\boldsymbol{r}} = \\boldsymbol{v}$ 和 $\\dot{\\boldsymbol{v}} = 0$。其精确解是一个“漂移”（drift）：\n$$\n\\boldsymbol{r}(t+h) = \\boldsymbol{r}(t) + h \\boldsymbol{v}(t), \\quad \\boldsymbol{v}(t+h) = \\boldsymbol{v}(t)\n$$\n2. 由 $V(\\boldsymbol{r})$ 在时间 $h$ 内生成的流，记为 $\\exp(h\\mathcal{L}_V)$，对应于 $\\dot{\\boldsymbol{r}} = 0$ 和 $\\dot{\\boldsymbol{v}} = \\boldsymbol{a}(\\boldsymbol{r})$。其精确解是一个“踢”（kick）：\n$$\n\\boldsymbol{r}(t+h) = \\boldsymbol{r}(t), \\quad \\boldsymbol{v}(t+h) = \\boldsymbol{v}(t) + h \\boldsymbol{a}(\\boldsymbol{r}(t))\n$$\n通过组合这些精确的基本流，我们构造了辛数值积分器。\n\n**1. 二阶蛙跳（Kick-Drift-Kick）积分器**\n二阶蛙跳方法可以从Strang分裂推导出来。漂移和踢算子的对称组合产生一个二阶精度的映射。踢-漂-踢（KDK）的公式为：\n$$\n\\mathcal{M}_{\\mathrm{LF}}(h) = \\exp\\left(\\frac{h}{2} \\mathcal{L}_V\\right) \\exp\\left(h \\mathcal{L}_T\\right) \\exp\\left(\\frac{h}{2} \\mathcal{L}_V\\right)\n$$\n将此算子序列应用于时间 $t_n$ 的状态 $(\\boldsymbol{r}_n, \\boldsymbol{v}_n)$ 以求得 $t_{n+1} = t_n+h$ 时的状态，得到以下算法步骤：\n1. **第一次踢（半步）**：应用 $\\exp(\\frac{h}{2}\\mathcal{L}_V)$。这会使用当前位置的加速度来更新速度。计算一个临时速度 $\\boldsymbol{v}_{n+1/2}$。\n$$\n\\boldsymbol{v}_{n+1/2} = \\boldsymbol{v}_n + \\frac{h}{2} \\boldsymbol{a}(\\boldsymbol{r}_n)\n$$\n2. **漂移（全步）**：应用 $\\exp(h\\mathcal{L}_T)$。这会使用新的中间速度来更新位置。\n$$\n\\boldsymbol{r}_{n+1} = \\boldsymbol{r}_n + h \\boldsymbol{v}_{n+1/2}\n$$\n3. **第二次踢（半步）**：应用 $\\exp(\\frac{h}{2}\\mathcal{L}_V)$。这会使用新位置 $\\boldsymbol{r}_{n+1}$ 处的加速度来完成速度更新。\n$$\n\\boldsymbol{v}_{n+1} = \\boldsymbol{v}_{n+1/2} + \\frac{h}{2} \\boldsymbol{a}(\\boldsymbol{r}_{n+1})\n$$\n该方案是对称、显式的，并具有二阶精度，意味着其局部截断误差为 $\\mathcal{O}(h^3)$。\n\n**2. 四阶辛积分器**\n高阶辛积分器可以通过组合对称的二阶方法来构造。设 $S_2(h)$ 表示步长为 $h$ 的二阶蛙跳映射。一个四阶对称方法 $S_4(h)$ 可以构造为三个具有特定时间步长的二阶步骤的组合：\n$$\nS_4(h) = S_2(c_1 h) S_2(c_2 h) S_2(c_1 h)\n$$\n为了使得到的方法具有四阶精度，系数 $c_1$ 和 $c_2$ 必须满足从BCH展开推导出的方程组。对于对称组合，条件是：\n$$\n2c_1 + c_2 = 1 \\quad \\text{和} \\quad 2c_1^3 + c_2^3 = 0\n$$\n第一个条件确保总时间步长为 $h$。第二个条件消除了组合映射的三阶误差项。求解该方程组可得：\n$$\nc_1 = \\frac{1}{2 - 2^{1/3}}, \\quad c_2 = \\frac{-2^{1/3}}{2 - 2^{1/3}}\n$$\n因此，一个大小为 $h$ 的单步四阶算法是连续应用三次二阶蛙跳步骤，时间步长分别为 $c_1 h$、 $c_2 h$ 和 $c_1 h$。该方法的局部截断误差为 $\\mathcal{O}(h^5)$。\n\n**3. 能量误差标度**\n对于哈密顿系统，能量是一个运动积分。虽然辛积分器不能精确守恒真实的哈密顿量 $H$，但它们能精确守恒一个附近的“影子”哈密顿量 $H'$。这导致了长期稳定性和有界的能量涨落，而不是长期漂移。对于一个 $p$ 阶积分器，在固定时间间隔 $T$ 内的全局能量误差预计会以 $\\mathcal{O}(h^p)$ 的方式缩放。我们可以通过数值方式验证这一点。最大绝对相对能量误差定义为 $\\epsilon_{\\max}(h) = \\max_{t \\in [0,T]} \\lvert E(t) - E_0 \\rvert / \\lvert E_0 \\rvert$。用步长 $h$ 和 $h/2$ 计算的此误差之比应为：\n$$\n\\mathsf{ratio} = \\frac{\\epsilon_{\\max}(h)}{\\epsilon_{\\max}(h/2)} \\approx \\frac{C h^p}{C (h/2)^p} = 2^p\n$$\n对于二阶蛙跳方法（$p=2$），我们预期 $\\mathsf{ratio}_{\\mathrm{LF}} \\approx 2^2 = 4$。对于四阶方法（$p=4$），我们预期 $\\mathsf{ratio}_{\\mathrm{S4}} \\approx 2^4 = 16$。\n\n**4. 相空间体积守恒**\n刘维尔定理指出，哈密顿系统的流在相空间中保持体积元不变。这意味着，如果我们考虑一个初始条件区域，其体积会随着时间演化而保持恒定。这个性质在数学上等价于流映射的雅可比行列式为1的陈述。\n一个数值积分器是辛的，当且仅当其单步映射 $\\mathcal{M}: \\boldsymbol{z}_n \\mapsto \\boldsymbol{z}_{n+1}$ 的雅可比矩阵行列式为1，即 $\\det(J) = \\det(\\partial \\boldsymbol{z}_{n+1} / \\partial \\boldsymbol{z}_n) = 1$。通过分裂哈密顿量构造的积分器在构造上就是辛的。我们通过数值方法对此进行验证，方法是使用中心差分在六维相空间矢量 $\\boldsymbol{z} = (r_x, r_y, r_z, v_x, v_y, v_z)$ 上计算单步映射的雅可比矩阵 $J$。$J$ 的第 $j$ 列由 $(\\mathcal{M}(\\boldsymbol{z}_0 + \\delta \\boldsymbol{e}_j) - \\mathcal{M}(\\boldsymbol{z}_0 - \\delta \\boldsymbol{e}_j)) / (2\\delta)$ 近似，其中 $\\boldsymbol{e}_j$ 是第 $j$ 个标准基矢量，$\\delta$ 是一个小扰动。我们感兴趣的量是偏差 $\\delta_{\\mathrm{vol}} = |\\det(J) - 1|$，对于正确的实现，该值应在机器浮点精度的量级。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares second-order and fourth-order symplectic integrators\n    for orbital motion in a Hernquist potential.\n    \"\"\"\n\n    # Dimensionless constants\n    G_const = 1.0\n    M_const = 1.0\n    a_const = 1.0\n\n    # Fourth-order integrator coefficients (Yoshida 1990)\n    cbrt_2 = 2**(1/3)\n    c1 = 1.0 / (2.0 - cbrt_2)\n    c2 = -cbrt_2 / (2.0 - cbrt_2)\n    S4_COEFFS = [c1, c2, c1]\n\n    def acceleration(r_vec):\n        \"\"\"Computes acceleration for a Hernquist potential.\"\"\"\n        r_mag = np.linalg.norm(r_vec)\n        if r_mag == 0.0:\n            return np.zeros(3)\n        # a(r) = - (GM / (r+a)^2) * (r_vec / r)\n        magnitude = - (G_const * M_const) / (r_mag + a_const)**2\n        return magnitude * (r_vec / r_mag)\n\n    def energy(r_vec, v_vec):\n        \"\"\"Computes specific energy for a Hernquist potential.\"\"\"\n        r_mag = np.linalg.norm(r_vec)\n        # H = 0.5*|v|^2 - GM/(r+a)\n        kinetic = 0.5 * np.dot(v_vec, v_vec)\n        potential = - (G_const * M_const) / (r_mag + a_const)\n        return kinetic + potential\n\n    def leapfrog_step(r, v, h):\n        \"\"\"Performs one step of the KDK leapfrog integrator.\"\"\"\n        v_half = v + 0.5 * h * acceleration(r)\n        r_new = r + h * v_half\n        v_new = v_half + 0.5 * h * acceleration(r_new)\n        return r_new, v_new\n\n    def s4_step(r, v, h):\n        \"\"\"Performs one step of the 4th-order symplectic integrator.\"\"\"\n        r_curr, v_curr = r, v\n        for coeff in S4_COEFFS:\n            r_curr, v_curr = leapfrog_step(r_curr, v_curr, h * coeff)\n        return r_curr, v_curr\n\n    def compute_energy_error_max(integrator, r0, v0, h, T):\n        \"\"\"Integrates an orbit and returns the max relative energy error.\"\"\"\n        n_steps = int(round(T / h))\n        r, v = r0.copy(), v0.copy()\n        \n        e0 = energy(r0, v0)\n        \n        max_err = 0.0\n        for _ in range(n_steps):\n            r, v = integrator(r, v, h)\n            e_t = energy(r, v)\n            err = abs((e_t - e0) / e0)\n            if err  max_err:\n                max_err = err\n        return max_err\n\n    def compute_volume_deviation(integrator, r0, v0, h):\n        \"\"\"Computes |det(J) - 1| for the one-step map using finite differences.\"\"\"\n        dim = 6\n        J = np.zeros((dim, dim))\n        z0 = np.concatenate((r0, v0))\n        eps = 1e-8\n\n        # Central difference for Jacobian columns\n        for j in range(dim):\n            z_plus = z0.copy()\n            z_plus[j] += eps\n            \n            z_minus = z0.copy()\n            z_minus[j] -= eps\n\n            r_p, v_p = integrator(z_plus[:3], z_plus[3:], h)\n            z1_p = np.concatenate((r_p, v_p))\n\n            r_m, v_m = integrator(z_minus[:3], z_minus[3:], h)\n            z1_m = np.concatenate((r_m, v_m))\n            \n            J[:, j] = (z1_p - z1_m) / (2 * eps)\n            \n        det_J = np.linalg.det(J)\n        return abs(det_J - 1.0)\n\n\n    # Case 1: Near-circular orbit\n    r1 = 5.0\n    v_circ1 = np.sqrt(r1 * G_const * M_const / (r1 + a_const)**2)\n    r0_1 = np.array([r1, 0.0, 0.0])\n    v0_1 = np.array([0.0, v_circ1, 0.0])\n\n    # Case 2: Radial orbit\n    r2 = 2.0\n    v_esc2 = np.sqrt(2 * G_const * M_const / (r2 + a_const))\n    r0_2 = np.array([r2, 0.0, 0.0])\n    v0_2 = np.array([0.5 * v_esc2, 0.0, 0.0])\n\n    # Case 3: Low-angular-momentum orbit\n    r3 = 0.5\n    v_circ3 = np.sqrt(r3 * G_const * M_const / (r3 + a_const)**2)\n    r0_3 = np.array([r3, 0.0, 0.0])\n    v0_3 = np.array([-0.2 * v_circ3, 0.2 * v_circ3, 0.0])\n\n    test_cases = [\n        (r0_1, v0_1),\n        (r0_2, v0_2),\n        (r0_3, v0_3)\n    ]\n    \n    h = 0.02\n    T = 200.0\n\n    results = []\n    \n    for r0, v0 in test_cases:\n        # Leapfrog analysis\n        e_err_lf_h = compute_energy_error_max(leapfrog_step, r0, v0, h, T)\n        e_err_lf_h2 = compute_energy_error_max(leapfrog_step, r0, v0, h/2, T)\n        ratio_lf = e_err_lf_h / e_err_lf_h2 if e_err_lf_h2  0 else 0.0\n        \n        vol_dev_lf = compute_volume_deviation(leapfrog_step, r0, v0, h)\n        \n        # S4 analysis\n        e_err_s4_h = compute_energy_error_max(s4_step, r0, v0, h, T)\n        e_err_s4_h2 = compute_energy_error_max(s4_step, r0, v0, h/2, T)\n        ratio_s4 = e_err_s4_h / e_err_s4_h2 if e_err_s4_h2  0 else 0.0\n        \n        vol_dev_s4 = compute_volume_deviation(s4_step, r0, v0, h)\n\n        results.extend([ratio_lf, ratio_s4, vol_dev_lf, vol_dev_s4])\n        \n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3518329"}]}