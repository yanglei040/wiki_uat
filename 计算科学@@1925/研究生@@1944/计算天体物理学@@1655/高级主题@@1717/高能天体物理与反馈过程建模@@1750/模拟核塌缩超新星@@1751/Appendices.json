{"hands_on_practices": [{"introduction": "任何流体动力学模拟的第一步都是精确地设置初始条件。这个练习将指导你将一个连续的、球对称的前身星物理剖面（如密度和温度）映射到一个离散的计算网格上。关键挑战在于确保这个映射过程严格遵守基本守恒律，例如重子数守恒，从而保证模拟从一个物理上自洽的状态开始。[@problem_id:3533781]", "problem": "给定您由连续函数描述的球对称前身星剖面，包括质量密度 $\\rho(r)$（单位为 $\\mathrm{g\\,cm^{-3}}$）、热力学温度 $T(r)$（单位为 $\\mathrm{K}$）和电子分数 $Y_e(r)$（无量纲）。目标是将这些函数映射到一个由同心球壳组成的有限体积球坐标网格上，并以一种强制实施重子质量守恒且保持强度标量的质量加权积分不变的方式计算单元平均量。您必须从第一性原理推导出一个算法，该算法能够构建映射后的球壳平均场并验证积分的保持性。\n\n从以下基本原理开始：\n- 球坐标体积元 $dV = 4\\pi r^2 dr$。\n- 球壳体积 $V_i = \\int_{r_{i-1/2}}^{r_{i+1/2}} 4\\pi r^2\\,dr$。\n- 总重子质量 $M = \\int_0^{R_{\\max}} \\rho(r)\\,dV$（单位为 $\\mathrm{g}$）。\n- 强度标量 $\\phi(r)$（例如，电子分数或温度）的质量加权积分是 $I_\\phi = \\int_0^{R_{\\max}} \\rho(r)\\,\\phi(r)\\,dV$。\n\n定义需要从连续场计算的有限体积球壳平均量：\n- 球壳平均密度 $\\bar{\\rho}_i$ 必须满足 $\\bar{\\rho}_i V_i = \\int_{r_{i-1/2}}^{r_{i+1/2}} \\rho(r)\\,dV$ 以确保每个球壳中的重子质量守恒。\n- 对于任何强度标量 $\\phi(r)$，球壳平均的质量加权值 $\\bar{\\phi}_i$ 必须满足 $\\bar{\\phi}_i \\left(\\bar{\\rho}_i V_i\\right) = \\int_{r_{i-1/2}}^{r_{i+1/2}} \\rho(r)\\,\\phi(r)\\,dV$ 以保持球壳积分的质量加权量不变。\n\n您的程序必须：\n- 使用几何间距（比例为 $q \\ge 1$）在 $[0,R_{\\max}]$ 上构建一个包含 $N$ 个球壳的球坐标网格。令 $\\Delta r_i = \\Delta r_0\\,q^i$ 对于 $i=0,\\dots,N-1$，其中 $\\sum_{i=0}^{N-1}\\Delta r_i = R_{\\max}$。这定义了球壳边界 $r_{i+1/2}$，其中 $r_{1/2}=0$ 且 $r_{N+1/2}=R_{\\max}$。\n- 对于每个球壳，通过计算所需的体积和质量加权积分来计算 $V_i$、$\\bar{\\rho}_i$、$\\overline{Y_e}_i$ 和 $\\bar{T}_i$。对所需积分使用数值稳定且精确的求积方法。如果一个剖面是分段定义的，在已知半径 $r = r_\\star$ 处有不连续点，则应在 $r_\\star$ 处分割任何积分以确保稳健性。\n- 通过为每个测试用例计算以下相对误差来验证守恒性：\n  - 总质量的相对误差 $\\epsilon_M = \\left|\\sum_i \\bar{\\rho}_i V_i - \\int_0^{R_{\\max}} \\rho(r)\\,dV\\right| \\big/ \\left(\\int_0^{R_{\\max}} \\rho(r)\\,dV\\right)$。\n  - 质量加权电子分数积分的相对误差 $\\epsilon_{Y} = \\left|\\sum_i \\bar{\\rho}_i \\overline{Y_e}_i V_i - \\int_0^{R_{\\max}} \\rho(r) Y_e(r)\\,dV\\right| \\big/ \\left(\\int_0^{R_{\\max}} \\rho(r) Y_e(r)\\,dV\\right)$。\n  - 质量加权温度积分的相对误差 $\\epsilon_{T} = \\left|\\sum_i \\bar{\\rho}_i \\bar{T}_i V_i - \\int_0^{R_{\\max}} \\rho(r) T(r)\\,dV\\right| \\big/ \\left(\\int_0^{R_{\\max}} \\rho(r) T(r)\\,dV\\right)$。\n这三个误差都是无量纲的，并且必须以十进制浮点数的形式报告。\n\n使用以下测试套件，所有半径单位为 $\\mathrm{cm}$，密度单位为 $\\mathrm{g\\,cm^{-3}}$，温度单位为 $\\mathrm{K}$，电子分数为无量纲：\n\n测试用例1（光滑的、类多方球核心）：\n- 域半径 $R_{\\max} = 3\\times 10^8$。\n- 网格参数 $N=128$，$q=1.03$。\n- 剖面：\n  - $\\rho(r) = \\dfrac{\\rho_c}{\\left(1 + \\left(\\dfrac{r}{r_c}\\right)^2\\right)^n}$，其中 $\\rho_c = 10^{10}$，$r_c = 10^7$，$n = 1.5$。\n  - $T(r) = \\dfrac{T_c}{1 + \\left(\\dfrac{r}{2\\times 10^7}\\right)^{1.3}}$，其中 $T_c = 7\\times 10^9$。\n  - $Y_e(r) = 0.5 - 0.1\\,\\dfrac{r}{R_{\\max}}$。\n\n测试用例2（不连续的核心-包层过渡）：\n- 域半径 $R_{\\max} = 3\\times 10^8$。\n- 网格参数 $N=96$，$q=1.05$。\n- 过渡半径 $r_{\\mathrm{core}} = 1.5\\times 10^8$。\n- 剖面：\n  - $\\rho(r) = \\begin{cases}\n    6\\times 10^9,   r \\le r_{\\mathrm{core}},\\\\\n    6\\times 10^9 \\left(\\dfrac{r}{r_{\\mathrm{core}}}\\right)^{-3},   r  r_{\\mathrm{core}}.\n    \\end{cases}$\n  - $T(r) = 8\\times 10^9 \\exp\\!\\left(-\\dfrac{r}{1.2\\times 10^8}\\right)$。\n  - $Y_e(r) = \\begin{cases}\n    0.44,   r \\le r_{\\mathrm{core}},\\\\\n    0.50,   r  r_{\\mathrm{core}}.\n    \\end{cases}$\n对于此用例，在积分时必须显式处理 $r=r_{\\mathrm{core}}$ 处的不连续点。\n\n测试用例3（中心陡峭、快速变化的核心）：\n- 域半径 $R_{\\max} = 2.5\\times 10^8$。\n- 网格参数 $N=200$，$q=1.02$。\n- 剖面：\n  - $\\rho(r) = 2\\times 10^{10}\\,\\exp\\!\\left(-\\left(\\dfrac{r}{2\\times 10^7}\\right)^{1/2}\\right)$。\n  - $T(r) = \\dfrac{10^{10}}{1 + \\left(\\dfrac{r}{5\\times 10^7}\\right)^{1.5}}$。\n  - $Y_e(r) = 0.48 - 0.05\\,\\tanh\\!\\left(\\dfrac{r}{10^8}\\right)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的所有九个相对误差，按顺序串联为 $\\left[\\epsilon_M^{(1)},\\epsilon_{Y}^{(1)},\\epsilon_{T}^{(1)},\\epsilon_M^{(2)},\\epsilon_{Y}^{(2)},\\epsilon_{T}^{(2)},\\epsilon_M^{(3)},\\epsilon_{Y}^{(3)},\\epsilon_{T}^{(3)}\\right]$，以逗号分隔列表的形式并用方括号括起来（例如，$\\left[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0\\right]$）。这些值必须是十进制浮点数。不涉及角度。所有报告的值都是无单位的相对误差。", "solution": "该问题要求开发并实现一个算法，用于将连续的、球对称的前身星剖面映射到离散的有限体积网格上。该映射必须严格遵守重子质量守恒，并保持强度热力学量的总质量加权积分不变。所实现算法的有效性将通过计算离散求和与“精确”连续积分之间的相对误差来验证。\n\n理论推导从第一性原理出发，过程如下。\n\n**1. 球坐标网格构建**\n一维径向域 $[0, R_{\\max}]$ 被离散化为 $N$ 个连续、不重叠的同心球壳。设球壳索引为 $i = 0, 1, \\dots, N-1$。球壳 $i$ 是半径为 $r_i$ 和 $r_{i+1}$ 的球面之间所包含的体积。这定义了在半径 $r_0, r_1, \\dots, r_N$ 处的 $N+1$ 个界面，其中 $r_0 = 0$ 且 $r_N = R_{\\max}$。\n\n网格间距是几何的，意味着每个球壳的宽度 $\\Delta r_i = r_{i+1} - r_i$ 遵循关系 $\\Delta r_i = \\Delta r_0 \\, q^i$，其中比例常数 $q \\ge 1$。第一个球壳的宽度 $\\Delta r_0$ 由所有球壳宽度之和必须等于总域大小的约束条件确定：\n$$ R_{\\max} = \\sum_{i=0}^{N-1} \\Delta r_i = \\sum_{i=0}^{N-1} \\Delta r_0 \\, q^i = \\Delta r_0 \\sum_{i=0}^{N-1} q^i $$\n对于 $q  1$，几何级数和为 $\\frac{q^N-1}{q-1}$，这给出 $\\Delta r_0 = R_{\\max} \\frac{q-1}{q^N-1}$。对于 $q=1$ 的均匀间距，和为 $N$，给出 $\\Delta r_0 = R_{\\max}/N$。\n\n界面半径随后被完全确定。从 $r_0=0$ 开始，每个后续半径计算如下：\n$$ r_{j} = \\sum_{k=0}^{j-1} \\Delta r_k = \\sum_{k=0}^{j-1} \\Delta r_0 \\, q^k = \\Delta r_0 \\frac{q^j - 1}{q-1} \\quad (\\text{对于 } j=1, \\dots, N \\text{ 和 } q  1) $$\n对于 $q=1$，这简化为 $r_j = j \\cdot \\Delta r_0$。\n\n**2. 物理量的离散化**\n目标是定义满足守恒定律的球壳平均量（$\\bar{\\rho}_i$、$\\overline{Y_e}_i$、$\\bar{T}_i$）。\n\n**球壳体积**\n球壳 $i$ 的体积 $V_i$ 是球坐标体积元 $dV = 4\\pi r^2 dr$ 在其边界半径 $r_i$ 和 $r_{i+1}$ 之间的积分：\n$$ V_i = \\int_{r_i}^{r_{i+1}} 4\\pi r^2 dr = 4\\pi \\left[\\frac{r^3}{3}\\right]_{r_i}^{r_{i+1}} = \\frac{4\\pi}{3} (r_{i+1}^3 - r_i^3) $$\n这是一个精确的解析公式。\n\n**质量守恒与球壳平均密度**\n包含在球壳 $i$ 内的重子质量（记为 $M_i$）是连续密度函数 $\\rho(r)$ 在该球壳体积上的积分：\n$$ M_i = \\int_{V_i} \\rho(r) \\, dV = \\int_{r_i}^{r_{i+1}} \\rho(r) (4\\pi r^2) dr $$\n质量守恒原理要求，分配给离散单元的质量（由 $\\bar{\\rho}_i V_i$ 给出）必须与连续质量 $M_i$ 完全相等。这定义了球壳平均密度 $\\bar{\\rho}_i$：\n$$ \\bar{\\rho}_i V_i = M_i \\implies \\bar{\\rho}_i = \\frac{M_i}{V_i} = \\frac{\\int_{r_i}^{r_{i+1}} 4\\pi \\rho(r) r^2 dr}{\\frac{4\\pi}{3} (r_{i+1}^3 - r_i^3)} = \\frac{3}{r_{i+1}^3 - r_i^3} \\int_{r_i}^{r_{i+1}} \\rho(r) r^2 dr $$\n\n**质量加权标量积分的保持**\n对于任何强度标量 $\\phi(r)$（例如温度 $T(r)$ 或电子分数 $Y_e(r)$），我们必须保持其质量加权积分。在球壳 $i$ 中，量 $\\rho \\phi$ 的总量是 $\\int_{V_i} \\rho(r) \\phi(r) dV$。在离散化方案中，这表示为 $\\bar{\\phi}_i M_i$。将两者等同，定义了质量加权的球壳平均值 $\\bar{\\phi}_i$：\n$$ \\bar{\\phi}_i M_i = \\int_{V_i} \\rho(r) \\phi(r) dV = \\int_{r_i}^{r_{i+1}} \\rho(r) \\phi(r) (4\\pi r^2) dr $$\n$$ \\implies \\bar{\\phi}_i = \\frac{1}{M_i} \\int_{r_i}^{r_{i+1}} \\rho(r) \\phi(r) (4\\pi r^2) dr $$\n这种表述确保了所有球壳上的离散量之和能正确再现连续量的全局积分。\n\n**3. 数值计算与验证**\n$M_i$ 和 $\\bar{\\phi}_i M_i$ 的积分通常无法对任意剖面 $\\rho(r)$ 和 $\\phi(r)$ 进行解析求解。它们必须使用数值求积法计算。高质量的自适应求积程序，例如 Python 中的 `scipy.integrate.quad`，适合此任务。这些程序可以达到接近机器精度的准确性。\n\n对于具有已知不连续点的剖面，例如测试用例2中在 $r=r_{\\mathrm{core}}$ 处的点，向求积算法告知这些点至关重要。如果一个球壳 $[r_i, r_{i+1}]$ 包含 $r_{\\mathrm{core}}$，则必须分割积分，或将该点传递给积分器，以避免数值误差并确保结果准确。\n\n验证过程确认了映射的完整性。根据构造，离散球壳上的量之和必须等于连续域上的总积分，其差异仅受限于数值积分和浮点运算的精度。\n来自网格的总质量是 $M_{\\mathrm{grid}} = \\sum_{i=0}^{N-1} \\bar{\\rho}_i V_i = \\sum_{i=0}^{N-1} M_i$。\n“精确”的总质量是 $M_{\\mathrm{tot}} = \\int_0^{R_{\\max}} \\rho(r) dV$。\n质量的相对误差是：\n$$ \\epsilon_M = \\frac{\\left| M_{\\mathrm{grid}} - M_{\\mathrm{tot}} \\right|}{M_{\\mathrm{tot}}} $$\n类似地，对于一个标量 $\\phi$，来自网格的总质量加权量是 $I_{\\phi, \\mathrm{grid}} = \\sum_{i=0}^{N-1} \\bar{\\phi}_i M_i$。\n“精确”的总量是 $I_{\\phi, \\mathrm{tot}} = \\int_0^{R_{\\max}} \\rho(r) \\phi(r) dV$。\n相对误差是：\n$$ \\epsilon_\\phi = \\frac{\\left| I_{\\phi, \\mathrm{grid}} - I_{\\phi, \\mathrm{tot}} \\right|}{I_{\\phi, \\mathrm{tot}}} $$\n这些误差量化了数值方法的自洽性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Test Case 1: Smooth, polytrope-like core\n    case1 = {\n        \"R_max\": 3e8,\n        \"N\": 128,\n        \"q\": 1.03,\n        \"discontinuity_points\": None,\n        \"rho_func\": lambda r: 1e10 / (1 + (r / 1e7)**2)**1.5,\n        \"T_func\": lambda r: 7e9 / (1 + (r / 2e7)**1.3),\n        \"Ye_func\": lambda r: 0.5 - 0.1 * r / 3e8,\n    }\n\n    # Test Case 2: Discontinuous core-envelope transition\n    r_core_case2 = 1.5e8\n    \n    def rho_case2(r):\n        return np.where(r = r_core_case2, 6e9, 6e9 * (r / r_core_case2)**(-3))\n\n    def T_case2(r):\n        return 8e9 * np.exp(-r / 1.2e8)\n\n    def Ye_case2(r):\n        return np.where(r = r_core_case2, 0.44, 0.50)\n\n    case2 = {\n        \"R_max\": 3e8,\n        \"N\": 96,\n        \"q\": 1.05,\n        \"discontinuity_points\": [r_core_case2],\n        \"rho_func\": rho_case2,\n        \"T_func\": T_case2,\n        \"Ye_func\": Ye_case2,\n    }\n\n    # Test Case 3: Centrally peaked, rapidly varying core\n    case3 = {\n        \"R_max\": 2.5e8,\n        \"N\": 200,\n        \"q\": 1.02,\n        \"discontinuity_points\": None,\n        \"rho_func\": lambda r: 2e10 * np.exp(-(r / 2e7)**0.5),\n        \"T_func\": lambda r: 1e10 / (1 + (r / 5e7)**1.5),\n        \"Ye_func\": lambda r: 0.48 - 0.05 * np.tanh(r / 1e8),\n    }\n\n    test_cases = [case1, case2, case3]\n    all_results = []\n\n    for case in test_cases:\n        errors = process_case(case)\n        all_results.extend(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case: builds the grid, computes averaged quantities,\n    and returns the relative errors.\n    \"\"\"\n    R_max = case_params[\"R_max\"]\n    N = case_params[\"N\"]\n    q = case_params[\"q\"]\n    rho_func = case_params[\"rho_func\"]\n    T_func = case_params[\"T_func\"]\n    Ye_func = case_params[\"Ye_func\"]\n    points = case_params[\"discontinuity_points\"]\n\n    # 1. Grid Construction\n    interfaces = np.zeros(N + 1)\n    if q == 1.0:\n        interfaces = np.linspace(0, R_max, N + 1)\n    else:\n        # dr_0 = R_max * (q - 1) / (q^N - 1)\n        dr0 = R_max * (q - 1) / (q**N - 1)\n        # r_j = dr_0 * (q^j - 1) / (q - 1)\n        # Using a loop to avoid potential floating point issues with large powers\n        # A closed form is also good: r_j = dr0 * (q**j - 1) / (q - 1)\n        for j in range(1, N + 1):\n             interfaces[j] = dr0 * (q**j - 1) / (q - 1)\n    \n    # 2. Define Integrands\n    # Integrand for mass: rho(r) * 4 * pi * r^2\n    mass_integrand = lambda r: rho_func(r) * 4.0 * np.pi * r**2\n    # Integrand for mass-weighted Ye: Ye(r) * rho(r) * 4 * pi * r^2\n    Ye_integrand = lambda r: Ye_func(r) * rho_func(r) * 4.0 * np.pi * r**2\n    # Integrand for mass-weighted T: T(r) * rho(r) * 4 * pi * r^2\n    T_integrand = lambda r: T_func(r) * rho_func(r) * 4.0 * np.pi * r**2\n\n    # 3. Calculate \"Exact\" Total Integrals\n    M_total = quad(mass_integrand, 0, R_max, points=points)[0]\n    IY_total = quad(Ye_integrand, 0, R_max, points=points)[0]\n    IT_total = quad(T_integrand, 0, R_max, points=points)[0]\n    \n    # 4. Compute Shell Quantities and Sums\n    shell_masses = np.zeros(N)\n    shell_I_Ye = np.zeros(N)\n    shell_I_T = np.zeros(N)\n\n    for i in range(N):\n        r_a, r_b = interfaces[i], interfaces[i+1]\n        \n        # Integrate over the shell\n        # M_i = integral of mass_integrand from r_a to r_b\n        shell_masses[i] = quad(mass_integrand, r_a, r_b, points=points)[0]\n        # I_{Y,i} = integral of Ye_integrand from r_a to r_b\n        shell_I_Ye[i] = quad(Ye_integrand, r_a, r_b, points=points)[0]\n        # I_{T,i} = integral of T_integrand from r_a to r_b\n        shell_I_T[i] = quad(T_integrand, r_a, r_b, points=points)[0]\n\n    # Sum up the discrete shell quantities\n    # By construction, M_grid = Sum(M_i)\n    M_grid = np.sum(shell_masses)\n    \n    # By construction, IY_grid = Sum(Ye_bar_i * M_i) = Sum(I_{Y,i}/M_i * M_i) = Sum(I_{Y,i})\n    IY_grid = np.sum(shell_I_Ye)\n    IT_grid = np.sum(shell_I_T)\n\n    # 5. Calculate Relative Errors\n    eps_M = np.abs(M_grid - M_total) / M_total if M_total != 0 else 0.0\n    eps_Y = np.abs(IY_grid - IY_total) / IY_total if IY_total != 0 else 0.0\n    eps_T = np.abs(IT_grid - IT_total) / IT_total if IT_total != 0 else 0.0\n    \n    return [eps_M, eps_Y, eps_T]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3533781"}, {"introduction": "核塌缩超新星的模拟涉及在极大不同时标上发生的多种物理过程，这导致了数值求解上的“刚性”问题。本练习将介绍一种强大的解决方案——隐式-显式（IMEX）方法，它通过对不同项采用不同的时间积分格式来高效地处理刚性问题。你将为一个关键的物理过程——电子俘获——实现并分析一个简化但核心的IMEX更新格式，并评估其稳定性和准确性。[@problem_id:3533784]", "problem": "考虑一个在核坍缩超新星内爆阶段的拉格朗日流体元。在所关心的时间步长上，忽略平流和中微子输运反馈的影响，电子分数因原子核和自由质子上的电子俘获而演化，其遵循以下常微分方程（ODE）\n$$\n\\frac{dY_e}{dt}=-\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e,\n$$\n其中 $Y_e$ 是电子分数，$\\lambda_{\\mathrm{ec}}(\\rho)$ 是电子俘获率，这里将其建模为仅与密度相关的幂律形式\n$$\n\\lambda_{\\mathrm{ec}}(\\rho)=\\lambda_0\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\alpha}.\n$$\n假设常数为\n$$\n\\lambda_0=5\\,\\mathrm{s^{-1}},\\quad \\rho_0=10^9\\,\\mathrm{g\\,cm^{-3}},\\quad \\alpha=0.6.\n$$\n使用 $\\theta$ 方法对线性源项在单个大小为 $\\Delta t$ 的时间步长上进行分裂，为刚性源项实现一个单参数的隐式-显式（IMEX）更新：\n$$\nY_e^{n+1}=Y_e^n+\\Delta t\\left[-(1-\\theta)\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^n-\\theta\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^{n+1}\\right],\n$$\n使用一个固定的隐式参数\n$$\n\\theta=0.3.\n$$\n对于这个线性测试问题，更新是一个线性放大映射 $Y_e^{n+1}=G\\,Y_e^n$，其放大因子为 $G(\\Delta t,\\rho,\\theta)$。您必须使用此放大因子，根据两个属性对每个 $(\\Delta t,\\rho)$ 对进行分类：\n\n- 具有物理单调性的数值稳定性：当且仅当 $0\\le G(\\Delta t,\\rho,\\theta)\\le 1$ 时，声明该步长为“稳定”（stable），这保证了 $Y_e$ 不会改变符号且不会增加。\n- 局部精度：如果单步相对误差（相对于精确解）低于容差 $\\varepsilon$，则声明该步长为“精确”（accurate），\n$$\n\\frac{\\left|G(\\Delta t,\\rho,\\theta)-e^{-\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}\\right|}{e^{-\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}}\\le \\varepsilon,\\quad \\varepsilon=10^{-3}.\n$$\n\n您必须推导出 $G(\\Delta t,\\rho,\\theta)$ 并将其应用于以下密度和时间步长的测试集：\n\n- 密度（单位 $\\mathrm{g\\,cm^{-3}}$）：$\\rho\\in\\{10^8,10^{10},10^{12}\\}$。\n- 时间步长（单位 $\\mathrm{s}$）：$\\Delta t\\in\\{10^{-6},10^{-4},10^{-3},5\\times 10^{-3},2\\times 10^{-2}\\}$。\n\n对于每个有序对 $(\\rho,\\Delta t)$，按如下定义赋予一个分类代码 $c$：\n- 如果步长是稳定且精确的，则 $c=2$，\n- 如果步长是稳定的但不精确，则 $c=1$，\n- 如果步长是不稳定的（即，在单调稳定区域之外），则 $c=0$。\n\n您的程序必须计算上述集合的笛卡尔积的所有分类，其中 $\\rho$ 按升序作为外层循环，$\\Delta t$ 按升序作为内层循环。输出必须是单行，包含按此顺序排列的 15 个整数代码，形式为方括号括起来的逗号分隔列表，例如 $[c_1,c_2,\\dots,c_{15}]$。所有计算都应使用上面为 $\\rho$ 和 $\\Delta t$ 提供的单位，输出代码是无单位的整数。不应打印任何其他文本。\n\n您的实现必须是一个完整、可运行的程序，通过推导和使用 $G(\\Delta t,\\rho,\\theta)$ 来执行上述分类；不要硬编码答案。", "solution": "我们从拉格朗日流体元的电子分数演化方程开始，\n$$\n\\frac{dY_e}{dt}=-\\lambda_{\\mathrm{ec}}(\\rho)Y_e,\n$$\n其中电子俘获率建模为\n$$\n\\lambda_{\\mathrm{ec}}(\\rho)=\\lambda_0\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\alpha},\\quad \\lambda_0=5\\,\\mathrm{s^{-1}},\\ \\rho_0=10^9\\,\\mathrm{g\\,cm^{-3}},\\ \\alpha=0.6.\n$$\n对于单个时间步长内固定的 $\\rho$，该常微分方程是常系数线性的，在大小为 $\\Delta t$ 的一个步长上的精确解是\n$$\nY_e(t+\\Delta t)=Y_e(t)\\,e^{-\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}.\n$$\n为了设计一个在处理刚性时隐式进行、同时保留隐式-显式（IMEX）分裂概念的数值稳健的更新方法，我们考虑对源项进行 $\\theta$ 方法划分。设 $Y_e^n$ 为时间 $t^n$ 的状态，$Y_e^{n+1}$ 为时间 $t^{n+1}=t^n+\\Delta t$ 的状态。我们将其离散化为\n$$\nY_e^{n+1}=Y_e^n+\\Delta t\\left[-(1-\\theta)\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^n-\\theta\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^{n+1}\\right],\n$$\n其中 $\\theta$ 是一个固定的隐式参数。这是一种有效的 IMEX 处理方法，因为它隐式地处理一部分刚性项，而显式地处理其余部分；当只有刚性源存在时，它简化为单参数的线性隐式更新族。重新整理这个离散方程得到\n$$\nY_e^{n+1}+\\Delta t\\,\\theta\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^{n+1}=Y_e^n-\\Delta t\\,(1-\\theta)\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^n,\n$$\n因此\n$$\nY_e^{n+1}=\\frac{1-(1-\\theta)\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}{1+\\theta\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}\\,Y_e^n.\n$$\n定义无量纲刚性参数 $z=\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t$。放大因子则为\n$$\nG(z,\\theta)=\\frac{1-(1-\\theta)\\,z}{1+\\theta\\,z}.\n$$\n对于这个物理衰变问题，我们施加的稳定性要求是具有物理单调性的数值稳定性，即 $0\\le G\\le 1$。因为对于 $z\\ge 0$ 和 $\\theta\\ge 0$，分母 $1+\\theta z$ 恒为正，所以条件 $0\\le G\\le 1$ 可简化为\n$$\n0\\le 1-(1-\\theta)\\,z\\le 1+\\theta\\,z.\n$$\n右侧不等式 $1-(1-\\theta)z\\le 1+\\theta z$ 对于 $z\\ge 0$ 总是成立的。左侧不等式 $1-(1-\\theta)z\\ge 0$ 给出了单调稳定区域\n$$\n0\\le z\\le \\frac{1}{1-\\theta}.\n$$\n对于给定的选择 $\\theta=0.3$，这个界限是\n$$\n0\\le z\\le \\frac{1}{1-0.3}=\\frac{1}{0.7}\\approx 1.428571\\ldots\n$$\n因此，任何满足 $z=\\lambda_{\\mathrm{ec}}(\\rho)\\Delta t\\le 1/(1-\\theta)$ 的 $(\\rho,\\Delta t)$ 对都是单调稳定的，否则该方法会得出 $G0$ 并违反物理上的单调衰减，我们将其归类为不稳定。\n\n为了评估精度，我们将数值单步更新与精确的单步解进行比较。精确的放大因子是 $e^{-z}$，数值放大因子是 $G(z,\\theta)$。单步相对误差为\n$$\n\\mathrm{err}(z,\\theta)=\\frac{\\left|G(z,\\theta)-e^{-z}\\right|}{e^{-z}}.\n$$\n如果 $\\mathrm{err}(z,\\theta)\\le \\varepsilon$ 且 $\\varepsilon=10^{-3}$，我们声明该步长是精确的。对于小的 $z$，泰勒展开证实了一阶精度：$G(z,\\theta)=1-z+\\theta(1-\\theta)z^2+\\mathcal{O}(z^3)$ 而 $e^{-z}=1-z+\\tfrac{1}{2}z^2+\\mathcal{O}(z^3)$，这给出了一个主导阶与 $|(\\theta(1-\\theta)-\\tfrac{1}{2})z^2|$ 成正比的局部误差。随着 $z$ 的增加，误差会增大，并在一个与问题相关的阈值处超过容差。\n\n为了评估测试集，我们计算\n$$\n\\lambda_{\\mathrm{ec}}(\\rho)=5\\left(\\frac{\\rho}{10^9\\,\\mathrm{g\\,cm^{-3}}}\\right)^{0.6}\\,\\mathrm{s^{-1}}\n$$\n对每个指定的密度 $\\rho\\in\\{10^8,10^{10},10^{12}\\}\\,\\mathrm{g\\,cm^{-3}}$，然后对每个 $\\Delta t\\in\\{10^{-6},10^{-4},10^{-3},5\\times 10^{-3},2\\times 10^{-2}\\}\\,\\mathrm{s}$ 计算 $z=\\lambda_{\\mathrm{ec}}(\\rho)\\Delta t$。对于每一对，我们计算 $G(z,0.3)$，通过 $0\\le G\\le 1$ 检验其稳定性，并计算误差 $\\mathrm{err}(z,0.3)$ 与 $\\varepsilon=10^{-3}$ 进行比较。如果稳定且精确，则分类代码 $c$ 被赋值为 2；如果稳定但不精确，则为 1；如果不稳定，则为 0。\n\n算法上，这可以归结为：\n- 按升序遍历 $\\rho$ 和 $\\Delta t$。\n- 计算 $\\lambda_{\\mathrm{ec}}(\\rho)$ 和 $z$。\n- 计算 $G$ 并检查 $0\\le G\\le 1$ 以判断稳定性。\n- 计算 $\\mathrm{err}$ 并与 $\\varepsilon$ 比较以判断精度。\n- 将相应的整数代码追加到结果列表中。\n\n最后，以 $[c_1,c_2,\\dots,c_{15}]$ 的确切格式单行打印结果。此过程确保了在 $(\\Delta t,\\rho)$ 平面上为指定的 IMEX 更新和速率模型绘制稳定性和精度区域的映射，其使用的物理意义标准植根于刚性源项的指数衰减动力学。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lambda_ec(rho, lambda0=5.0, rho0=1e9, alpha=0.6):\n    \"\"\"\n    Electron-capture rate model: lambda_ec = lambda0 * (rho / rho0)^alpha\n    rho in g/cm^3, lambda in 1/s\n    \"\"\"\n    return lambda0 * (rho / rho0) ** alpha\n\ndef amplification_factor(z, theta):\n    \"\"\"\n    Amplification factor G for the theta-IMEX update on y' = -lambda y with z=lambda*dt.\n    G = (1 - (1-theta)*z) / (1 + theta*z)\n    \"\"\"\n    return (1.0 - (1.0 - theta) * z) / (1.0 + theta * z)\n\ndef classify_case(rho, dt, theta=0.3, eps=1e-3):\n    \"\"\"\n    Classify one (rho, dt) pair.\n    Returns:\n        2 if stable and accurate,\n        1 if stable but not accurate,\n        0 if unstable (violates monotone stability 0 = G = 1).\n    \"\"\"\n    lam = lambda_ec(rho)\n    z = lam * dt\n    G = amplification_factor(z, theta)\n    # Monotone stability: non-negative and no growth.\n    stable = (G >= 0.0) and (G = 1.0)\n    if not stable:\n        return 0\n    # Relative one-step error vs exact exponential decay.\n    exact = np.exp(-z)\n    rel_err = abs(G - exact) / exact if exact != 0.0 else np.inf\n    if rel_err = eps:\n        return 2\n    else:\n        return 1\n\ndef solve():\n    # Define the test cases from the problem statement.\n    densities = [1e8, 1e10, 1e12]  # g/cm^3\n    timesteps = [1e-6, 1e-4, 1e-3, 5e-3, 2e-2]  # s\n    theta = 0.3\n    eps = 1e-3\n\n    results = []\n    for rho in densities:\n        for dt in timesteps:\n            c = classify_case(rho, dt, theta=theta, eps=eps)\n            results.append(c)\n\n    # Final print statement in the exact required format: no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3533784"}, {"introduction": "理解超新星的爆炸机制是计算天体物理学的一个核心目标，其中关键在于解释停滞激波的复苏。本练习将通过建立一个简化的物理模型来探讨这一复杂现象，该模型基于中微子加热时标和物质吸积时标之间的竞争。通过推导和计算这些时标，你将得出一个定量的激波复苏判据，从而深入理解驱动爆炸所需满足的物理条件。[@problem_id:3533769]", "problem": "你的任务是推导、实现并测试一个用于核塌缩超新星增益区（gain region）的球对称、光学薄（optically thin）加热模型。你的目标是计算中微子加热效率，并基于特征时间尺度的比值来评估激波复苏（shock revival）条件。结果必须是一个完整的、可运行的程序，能够针对指定的测试集输出所要求的值。\n\n从以下基本依据和核心定义开始：\n- 牛顿引力和引力势能：在中心质量 $M_{\\mathrm{NS}}$ 的势场中，位于半径 $r$ 处的质量元的比引力势能为 $-\\dfrac{G M_{\\mathrm{NS}}}{r}$，其中 $G$ 是引力常数。\n- 稳恒流中的质量守恒：控制体积内质量的平流驻留时间等于体积内的总质量除以通过它的质量通量。\n- 纯吸收情况下的光学薄辐射转移：沿着穿过质量面密度为 $\\Sigma$ 的板层的径向轨迹，入射能量通量的吸收分数为 $1-e^{-\\tau}$，其中光学深度 $\\tau=\\kappa\\,\\Sigma$，$\\kappa$ 是质量吸收不透明度。\n- 带电流（charged-current）电子味中微子吸收截面与中微子能量的平方成正比：$\\sigma_{\\mathrm{abs}}(\\varepsilon)\\approx \\sigma_0\\left(\\dfrac{\\varepsilon}{\\mathrm{MeV}}\\right)^2$，其中 $\\sigma_0$ 是一个常数。\n\n假设一个球对称的增益区，从半径 $R_g$（增益半径）延伸到 $R_s$（激波半径），其密度分布为幂律形式\n$$\n\\rho(r)=\\rho_g\\left(\\dfrac{r}{R_g}\\right)^{-n},\n$$\n为便于解析处理，取 $n=2$。给定中微子光度 $L_\\nu$ 和有效平均中微子能量 $\\langle \\varepsilon_\\nu \\rangle$。\n\n仅使用上述基本依据，推导并实现以下内容（不要引用任何其他专门的超新星标度关系）：\n\n1) 加热效率。使用光学薄吸收模型，将加热效率表示为整个增益层吸收的中微子光度分数，\n$$\n\\eta \\equiv \\dfrac{\\dot{Q}_{\\mathrm{heat}}}{L_\\nu} = 1 - e^{-\\tau_{\\mathrm{gain}}}, \\quad \\tau_{\\mathrm{gain}} = \\int_{R_g}^{R_s} \\kappa\\,\\rho(r)\\,dr,\n$$\n其中质量吸收不透明度为\n$$\n\\kappa = \\dfrac{\\sigma_{\\mathrm{abs}}}{m_b} = \\dfrac{\\sigma_0}{m_b}\\left(\\dfrac{\\langle \\varepsilon_\\nu \\rangle}{\\mathrm{MeV}}\\right)^2,\n$$\n$m_b$ 是重子质量。对于 $n=2$，计算增益区的面密度\n$$\n\\Sigma \\equiv \\int_{R_g}^{R_s} \\rho(r)\\,dr = \\rho_g R_g \\left(1 - \\dfrac{R_g}{R_s}\\right),\n$$\n因此 $\\tau_{\\mathrm{gain}}=\\kappa\\,\\Sigma$。\n\n2) 平流时间尺度。使用质量守恒，计算平流驻留时间\n$$\n\\tau_{\\mathrm{adv}} = \\dfrac{M_{\\mathrm{gain}}}{\\dot{M}},\n$$\n其中，当 $n=2$ 时，增益区质量为\n$$\nM_{\\mathrm{gain}} = 4\\pi \\int_{R_g}^{R_s} \\rho(r)\\,r^2\\,dr = 4\\pi \\rho_g R_g^2 \\left(R_s - R_g\\right).\n$$\n\n3) 加热时间尺度。计算增益区引力束缚能的大小为\n$$\nE_{\\mathrm{bind}} = 4\\pi G M_{\\mathrm{NS}} \\int_{R_g}^{R_s} \\rho(r)\\,r\\,dr = 4\\pi G M_{\\mathrm{NS}} \\rho_g R_g^2 \\ln\\!\\left(\\dfrac{R_s}{R_g}\\right),\n$$\n净中微子加热率为 $\\dot{Q}_{\\mathrm{heat}}=\\eta L_\\nu$。然后定义\n$$\n\\tau_{\\mathrm{heat}} = \\dfrac{E_{\\mathrm{bind}}}{\\dot{Q}_{\\mathrm{heat}}}.\n$$\n\n4) 激波复苏条件。定义激波复苏诊断量为\n$$\n\\mathcal{R} \\equiv \\dfrac{\\tau_{\\mathrm{adv}}}{\\tau_{\\mathrm{heat}}},\n$$\n如果 $\\mathcal{R}  1$，则宣告复苏。\n\n使用的常数和单位：\n- 所有计算必须使用厘米-克-秒（cgs）单位制。\n- 引力常数 $G = 6.674\\times 10^{-8}\\,\\mathrm{cm^3\\,g^{-1}\\,s^{-2}}$。\n- 太阳质量 $M_\\odot = 1.98847\\times 10^{33}\\,\\mathrm{g}$。\n- 中子星质量 $M_{\\mathrm{NS}} = 1.4\\,M_\\odot$。\n- 增益半径 $R_g = 100\\,\\mathrm{km} = 1.0\\times 10^{7}\\,\\mathrm{cm}$。\n- 增益半径处的密度归一化值 $\\rho_g = 1.0\\times 10^{9}\\,\\mathrm{g\\,cm^{-3}}$。\n- 密度幂律指数 $n=2$（如上所述）。\n- 中微子光度 $L_\\nu = 3.0\\times 10^{52}\\,\\mathrm{erg\\,s^{-1}}$。\n- 有效平均中微子能量 $\\langle \\varepsilon_\\nu \\rangle = 12\\,\\mathrm{MeV}$。\n- 重子质量 $m_b = 1.674\\times 10^{-24}\\,\\mathrm{g}$。\n- 带电流吸收截面系数 $\\sigma_0 = 9.0\\times 10^{-44}\\,\\mathrm{cm^2}$。\n\n测试集。对于每种情况，给定吸积率 $\\dot{M}$（单位 $M_\\odot\\,\\mathrm{s^{-1}}$）和激波半径 $R_s$（单位 $\\mathrm{km}$）：\n- 情况 A: $\\dot{M} = 0.3$, $R_s=150$。\n- 情况 B: $\\dot{M} = 0.05$, $R_s=150$。\n- 情况 C: $\\dot{M} = 1.0$, $R_s=150$。\n- 情况 D: $\\dot{M} = 0.3$, $R_s=250$。\n- 情况 E (极低吸积率的边缘情况): $\\dot{M} = 0.01$, $R_s=150$。\n\n对每种情况，计算：\n- 加热效率 $\\eta$（无量纲）。\n- 比值 $\\mathcal{R}=\\tau_{\\mathrm{adv}}/\\tau_{\\mathrm{heat}}$（无量纲）。\n- 布尔标志 $\\mathrm{revive}$，定义为如果 $\\mathcal{R}1$ 则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n最终输出格式：\n- 你的程序必须生成单行文本，其中包含五个测试情况的结果列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D, 情况 E]。\n- 每个情况的结果必须是一个嵌套列表，形式为 $[\\mathrm{revive}, \\eta, \\mathcal{R}]$，其中 $\\mathrm{revive}$ 是一个布尔值，$\\eta$ 和 $\\mathcal{R}$ 是四舍五入到六位小数的浮点数。\n- 最终输出必须是包含整个列表的单行文本，不含其他内容，例如：$[[\\mathrm{False},0.012345,0.678901],[\\mathrm{True},0.023456,1.234567],\\dots]$。\n\n角度单位不适用。无需其他输入。所有常数和参数已在上方提供。所有结果都是无量纲的，并且必须按照指定要求打印为四舍五入到六位小数的浮点数。", "solution": "该问题要求推导并实现一个用于核塌缩超新星增益区的简化球对称中微子加热模型。目标是计算中微子加热效率 $\\eta$、特征时间尺度的比值 $\\mathcal{R} = \\tau_{\\mathrm{adv}}/\\tau_{\\mathrm{heat}}$，并根据此比值为一组给定的参数确定激波复苏条件。所有计算都将在厘米-克-秒（cgs）单位制下进行。\n\n该模型基于一组基本原理和定义。增益区从增益半径 $R_g$ 延伸到激波半径 $R_s$。该区域内的密度分布遵循幂律 $\\rho(r)=\\rho_g(r/R_g)^{-n}$，指数指定为 $n=2$。\n\n推导过程分为三个主要步骤，随后是计算实现的描述。\n\n1.  **加热效率 $\\eta$**\n\n加热效率 $\\eta$ 定义为增益区内物质吸收的总中微子光度 $L_\\nu$ 的分数。因此，净加热率为 $\\dot{Q}_{\\mathrm{heat}} = \\eta L_\\nu$。\n\n使用所提供的纯吸收光学薄辐射转移模型，效率由下式给出：\n$$\n\\eta = 1 - e^{-\\tau_{\\mathrm{gain}}}\n$$\n其中 $\\tau_{\\mathrm{gain}}$ 是增益区对中微子的总光学深度。光学深度通过沿从 $R_g$ 到 $R_s$ 的径向路径对质量吸收不透明度 $\\kappa$ 和质量密度 $\\rho(r)$ 的乘积进行积分来计算：\n$$\n\\tau_{\\mathrm{gain}} = \\int_{R_g}^{R_s} \\kappa\\,\\rho(r)\\,dr\n$$\n假设不透明度 $\\kappa$ 在整个增益区内是恒定的。它由每个重子的中微子吸收截面 $\\sigma_{\\mathrm{abs}}$ 和重子质量 $m_b$ 导出。鉴于截面对中微子能量 $\\varepsilon$ 的平方依赖关系 $\\sigma_{\\mathrm{abs}}(\\varepsilon) \\approx \\sigma_0 (\\varepsilon/\\mathrm{MeV})^2$，对于具有有效平均能量 $\\langle \\varepsilon_\\nu \\rangle$ 的中微子，其不透明度为：\n$$\n\\kappa = \\dfrac{\\sigma_{\\mathrm{abs}}}{m_b} = \\dfrac{\\sigma_0}{m_b}\\left(\\dfrac{\\langle \\varepsilon_\\nu \\rangle}{\\mathrm{MeV}}\\right)^2\n$$\n光学深度的积分简化为 $\\tau_{\\mathrm{gain}} = \\kappa \\Sigma$，其中 $\\Sigma$ 是增益区的总质量面密度。问题给出了特定情况 $n=2$ 下的积分结果：\n$$\n\\Sigma = \\int_{R_g}^{R_s} \\rho(r)\\,dr = \\int_{R_g}^{R_s} \\rho_g \\left(\\dfrac{r}{R_g}\\right)^{-2} dr = \\rho_g R_g \\left(1 - \\dfrac{R_g}{R_s}\\right)\n$$\n通过由给定常数计算 $\\kappa$ 以及为每个测试用例的 $R_s$ 计算 $\\Sigma$，我们可以确定 $\\tau_{\\mathrm{gain}}$，并随后确定加热效率 $\\eta$。\n\n2.  **特征时间尺度：$\\tau_{\\mathrm{adv}}$ 和 $\\tau_{\\mathrm{heat}}$**\n\n超新星激波的复苏受两个过程的竞争控制：物质通过增益区的平流和中微子对该物质的加热。这些过程分别由平流时间尺度 $\\tau_{\\mathrm{adv}}$ 和加热时间尺度 $\\tau_{\\mathrm{heat}}$ 来表征。\n\n**平流时间尺度** $\\tau_{\\mathrm{adv}}$ 是物质在增益区中的驻留时间。基于稳恒流中的质量守恒，它是增益区中的总质量 $M_{\\mathrm{gain}}$ 与质量吸积率 $\\dot{M}$ 的比值：\n$$\n\\tau_{\\mathrm{adv}} = \\dfrac{M_{\\mathrm{gain}}}{\\dot{M}}\n$$\n增益区中的质量 $M_{\\mathrm{gain}}$ 通过对从 $R_g$ 到 $R_s$ 的球壳体积内的密度进行积分得到。对于给定的 $n=2$ 密度分布，积分结果已提供：\n$$\nM_{\\mathrm{gain}} = 4\\pi \\int_{R_g}^{R_s} \\rho(r)\\,r^2\\,dr = 4\\pi \\int_{R_g}^{R_s} \\rho_g \\left(\\dfrac{r}{R_g}\\right)^{-2} r^2\\,dr = 4\\pi \\rho_g R_g^2 (R_s - R_g)\n$$\n**加热时间尺度** $\\tau_{\\mathrm{heat}}$ 表示吸收的中微子能量克服增益区中物质的引力束缚所需的时间。它定义为增益质量的引力束缚能大小 $E_{\\mathrm{bind}}$ 与净加热率 $\\dot{Q}_{\\mathrm{heat}}$ 的比值：\n$$\n\\tau_{\\mathrm{heat}} = \\dfrac{E_{\\mathrm{bind}}}{\\dot{Q}_{\\mathrm{heat}}}\n$$\n束缚能 $E_{\\mathrm{bind}}$ 通过对增益区中所有质量元的比引力势能进行积分来计算。中心天体是质量为 $M_{\\mathrm{NS}}$ 的中子星。对于 $n=2$ 的密度分布，此积分已提供：\n$$\nE_{\\mathrm{bind}} = 4\\pi G M_{\\mathrm{NS}} \\int_{R_g}^{R_s} \\rho(r)\\,r\\,dr = 4\\pi G M_{\\mathrm{NS}} \\int_{R_g}^{R_s} \\rho_g \\left(\\dfrac{r}{R_g}\\right)^{-2} r\\,dr = 4\\pi G M_{\\mathrm{NS}} \\rho_g R_g^2 \\ln\\left(\\dfrac{R_s}{R_g}\\right)\n$$\n分母 $\\dot{Q}_{\\mathrm{heat}}$ 使用先前确定的加热效率 $\\eta$ 和给定的中微子光度 $L_\\nu$ 计算。\n\n3.  **激波复苏条件**\n\n平流与加热之间的竞争由无量纲比值 $\\mathcal{R}$ 来量化：\n$$\n\\mathcal{R} \\equiv \\dfrac{\\tau_{\\mathrm{adv}}}{\\tau_{\\mathrm{heat}}}\n$$\n$\\mathcal{R}  1$ 的值表示加热时间尺度短于平流时间尺度。这意味着物质在被平流吸积到中子星上之前，已被充分加热以至于变得不受束缚。因此，该模型中激波成功复苏的条件是 $\\mathcal{R}  1$。\n\n计算流程如下：\n首先，所有物理常数（$G$，$M_\\odot$ 等）都以 cgs 单位定义。计算中子星质量 $M_{\\mathrm{NS}}$。质量吸收不透明度 $\\kappa$ 对所有测试用例都是一个常数，只需计算一次。\n\n对于每个由吸积率 $\\dot{M}$（单位 $M_\\odot\\,\\mathrm{s^{-1}}$）和激波半径 $R_s$（单位 km）指定的测试用例：\n1.  将 $\\dot{M}$ 转换为 $\\mathrm{g\\,s^{-1}}$，将 $R_s$ 转换为 $\\mathrm{cm}$。\n2.  使用给定的 $R_s$ 计算面密度 $\\Sigma$。\n3.  计算光学深度 $\\tau_{\\mathrm{gain}} = \\kappa\\Sigma$ 和加热效率 $\\eta = 1 - e^{-\\tau_{\\mathrm{gain}}}$。\n4.  计算增益区中的质量 $M_{\\mathrm{gain}}$。\n5.  计算平流时间尺度 $\\tau_{\\mathrm{adv}} = M_{\\mathrm{gain}}/\\dot{M}$。\n6.  计算增益区的束缚能 $E_{\\mathrm{bind}}$。\n7.  计算总加热率 $\\dot{Q}_{\\mathrm{heat}} = \\eta L_\\nu$。\n8.  计算加热时间尺度 $\\tau_{\\mathrm{heat}} = E_{\\mathrm{bind}}/\\dot{Q}_{\\mathrm{heat}}$。\n9.  计算诊断比值 $\\mathcal{R} = \\tau_{\\mathrm{adv}}/\\tau_{\\mathrm{heat}}$。\n10. 确定复苏标志：如果 $\\mathcal{R}  1$ 则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n11. 按照要求的精度存储并格式化结果（$\\mathrm{revive}$，$\\eta$，$\\mathcal{R}$）。\n\n系统地应用这些推导出的公式，就可以对每个指定场景评估其激波复苏条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the neutrino heating efficiency and shock revival condition for\n    a simplified core-collapse supernova model.\n    \"\"\"\n    \n    # Constants and units (all in cgs)\n    G = 6.674e-8        # Gravitational constant [cm^3 g^-1 s^-2]\n    M_SOLAR = 1.98847e33 # Solar mass [g]\n    M_NS = 1.4 * M_SOLAR # Neutron star mass [g]\n    R_g = 1.0e7          # Gain radius [cm] (100 km)\n    rho_g = 1.0e9        # Density at gain radius [g cm^-3]\n    L_nu = 3.0e52        # Neutrino luminosity [erg s^-1]\n    eps_nu_mean = 12.0   # Effective mean neutrino energy [MeV]\n    m_b = 1.674e-24      # Baryon mass [g]\n    sigma_0 = 9.0e-44    # Cross-section coefficient [cm^2]\n\n    # Pre-calculate constant mass absorption opacity kappa [cm^2 g^-1]\n    kappa = (sigma_0 / m_b) * (eps_nu_mean**2)\n\n    # Test suite: (M_dot [M_solar/s], R_s [km])\n    test_cases = [\n        (0.3, 150.0),   # Case A\n        (0.05, 150.0),  # Case B\n        (1.0, 150.0),   # Case C\n        (0.3, 250.0),   # Case D\n        (0.01, 150.0),  # Case E\n    ]\n\n    results = []\n    for m_dot_msun_s, r_s_km in test_cases:\n        # Convert inputs to cgs units\n        m_dot = m_dot_msun_s * M_SOLAR  # Mass accretion rate [g s^-1]\n        r_s = r_s_km * 1.0e5          # Shock radius [cm]\n\n        # 1) Heating efficiency eta\n        # Column density Sigma [g cm^-2]\n        Sigma = rho_g * R_g * (1.0 - R_g / r_s)\n        \n        # Optical depth tau_gain (dimensionless)\n        tau_gain = kappa * Sigma\n        \n        # Heating efficiency eta (dimensionless)\n        eta = 1.0 - np.exp(-tau_gain)\n\n        # 2) Advective timescale tau_adv\n        # Mass in the gain region M_gain [g]\n        M_gain = 4.0 * np.pi * rho_g * R_g**2 * (r_s - R_g)\n        \n        # Advective timescale tau_adv [s]\n        tau_adv = M_gain / m_dot\n\n        # 3) Heating timescale tau_heat\n        # Gravitational binding energy of the gain region E_bind [erg]\n        E_bind = 4.0 * np.pi * G * M_NS * rho_g * R_g**2 * np.log(r_s / R_g)\n        \n        # Net heating rate Q_heat_dot [erg s^-1]\n        Q_heat_dot = eta * L_nu\n        \n        # Heating timescale tau_heat [s]\n        tau_heat = E_bind / Q_heat_dot\n\n        # 4) Shock revival condition\n        # Diagnostic ratio R (dimensionless)\n        R_ratio = tau_adv / tau_heat\n        \n        # Revival flag (boolean)\n        revive = R_ratio > 1.0\n        \n        results.append([revive, eta, R_ratio])\n\n    # Final print statement in the exact required format.\n    # Format: [[bool,float,float],[bool,float,float],...]\n    output_strings = []\n    for res in results:\n        bool_str = str(res[0])\n        eta_str = f\"{res[1]:.6f}\"\n        R_str = f\"{res[2]:.6f}\"\n        output_strings.append(f\"[{bool_str},{eta_str},{R_str}]\")\n    \n    print(f\"[{','.join(output_strings)}]\")\n\nsolve()\n```", "id": "3533769"}]}