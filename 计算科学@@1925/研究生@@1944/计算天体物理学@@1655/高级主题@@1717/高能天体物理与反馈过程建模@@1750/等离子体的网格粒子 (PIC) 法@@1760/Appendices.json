{"hands_on_practices": [{"introduction": "在许多天体物理粒子模拟（PIC）中，一个关键的挑战是如何准确地模拟等离子体流（如喷流）进入计算区域。这个实践练习关注于设计和评估移动注入器，这是实现连续入流边界条件的核心技术。通过对比一个物理上自洽的注入器和一个不自洽的注入器，本练习 [@problem_id:3529051] 强调了在离散化格式中严格遵守电荷守恒定律的重要性，以避免产生会破坏模拟真实性的非物理效应。", "problem": "考虑一维相对论性等离子体射流连续流入一个采用“质点网格法”（Particle-In-Cell, PIC）的计算区域。等离子体射流以速度 $v$ 沿 $x$ 轴移动，无量纲速度参数为 $\\beta = v/c$，其中 $c$ 被归一化为 $c = 1$。静止参考系（固有）下的粒子数密度分布为 $n_{0}(\\xi)$，其中 $\\xi = x - v t$，每个粒子的电荷为 $q = 1$。实验室参考系下的电荷密度为 $\\rho(x,t)$，电流密度为 $J(x,t)$。计算区域为 $x \\in [0,L]$，包含一个具有 $N$ 个单元的均匀网格，单元中心位于 $x_{i} = (i + 0.5)\\Delta x$（$i = 0,\\dots,N-1$），单元面位于 $x_{i+1/2} = (i + 1)\\Delta x$（$i = 0,\\dots,N-2$），其中 $\\Delta x = L/N$。时间网格为 $t^{n} = n \\Delta t$（$n = 0,\\dots,N_{t}$），时间步长 $\\Delta t$ 是均匀的。\n\n基本原理：\n- 电荷的局域守恒由连续性方程表示：$\\partial \\rho / \\partial t + \\partial J / \\partial x = 0$。\n- 从静止参考系到实验室参考系的四维电流变换意味着，对于沿 $x$ 轴的单向增强，实验室参考系下的电荷密度和电流满足 $\\rho(x,t) = q \\gamma n_{0}(x - v t)$ 和 $J(x,t) = \\rho(x,t) v$，其中 $\\gamma = 1/\\sqrt{1-\\beta^{2}}$。\n\n在一个与许多“质点网格法”（PIC）离散化方案中使用的标准交错网格布局相符的离散守恒律中，将单元 $i$ 和时间步 $n$ 处的电荷守恒离散残差定义为\n$$\nr_{i}^{n} = \\rho_{i}^{n+1} - \\rho_{i}^{n} + \\frac{\\Delta t}{\\Delta x} \\left( J_{i+1/2}^{n+1/2} - J_{i-1/2}^{n+1/2} \\right),\n$$\n其中 $\\rho_{i}^{n} = \\rho(x_{i}, t^{n})$ 且 $J_{i+1/2}^{n+1/2} = J(x_{i+1/2}, t^{n} + \\Delta t/2)$。对于一个物理上一致的移动入流注入器，$\\rho$ 和 $J$ 的分布必须满足上述关系，以使 $r_{i}^{n}$ 最小化。\n\n考虑两种注入器策略：\n1. 匹配的增强参考系注入器，定义为\n$$\n\\rho_{\\mathrm{match}}(x,t) = q \\gamma n_{0}(x - v t), \\quad J_{\\mathrm{match}}(x,t) = \\rho_{\\mathrm{match}}(x,t) v.\n$$\n2. 不匹配的注入器，它直接使用静止参考系粒子数密度来计算电流，而没有计入洛伦兹因子，\n$$\n\\rho_{\\mathrm{mis}}(x,t) = q \\gamma n_{0}(x - v t), \\quad J_{\\mathrm{mis}}(x,t) = q\\, n_{0}(x - v t)\\, v,\n$$\n这在 $\\gamma \\neq 1$ 时违反了连续性方程。\n\n设静止参考系的粒子数密度为高斯分布，\n$$\nn_{0}(\\xi) = n_{\\mathrm{pk}} \\exp\\left(-\\frac{\\xi^{2}}{2 \\sigma^{2}}\\right),\n$$\n峰值密度 $n_{\\mathrm{pk}} = 1$，宽度参数 $\\sigma  0$。对于每种注入器，计算在内部单元 $i = 1,\\dots,N-2$ 和所有时间步 $n = 0,\\dots,N_{t}-1$ 上的离散守恒残差的均方根（RMS）：\n$$\n\\mathrm{RMS} = \\sqrt{ \\frac{1}{(N-2) N_{t}} \\sum_{n=0}^{N_{t}-1} \\sum_{i=1}^{N-2} \\left( r_{i}^{n} \\right)^{2} }.\n$$\n将性能指标定义为比率，\n$$\n\\mathcal{R} = \\frac{\\mathrm{RMS}_{\\mathrm{mis}}}{\\mathrm{RMS}_{\\mathrm{match}}},\n$$\n该比率量化了在使用匹配的增强参考系分布计算 $J$ 和 $n$ 时伪电荷的减少程度。\n\n你的任务是编写一个完整的、可运行的程序，该程序针对以下每个测试用例，构建区域和时间网格，评估 $\\mathrm{RMS}_{\\mathrm{match}}$ 和 $\\mathrm{RMS}_{\\mathrm{mis}}$，并返回比率 $\\mathcal{R}$：\n\n测试套件（所有量均为无量纲，且 $c = 1$，$q = 1$，$n_{\\mathrm{pk}} = 1$）：\n- 用例 A (理想路径)：$\\beta = 0.8$, $L = 10.0$, $N = 512$, $\\sigma = 0.4$, $\\Delta t = 0.5 \\Delta x$, $N_{t} = 100$。\n- 用例 B (高度相对论性)：$\\beta = 0.99$, $L = 10.0$, $N = 512$, $\\sigma = 0.2$, $\\Delta t = 0.3 \\Delta x$, $N_{t} = 150$。\n- 用例 C (边界 CFL 条件)：$\\beta = 0.5$, $L = 10.0$, $N = 256$, $\\sigma = 0.6$, $\\Delta t = 1.0 \\Delta x$, $N_{t} = 80$。\n- 用例 D (慢速射流)：$\\beta = 0.1$, $L = 10.0$, $N = 128$, $\\sigma = 1.0$, $\\Delta t = 0.8 \\Delta x$, $N_{t} = 60$。\n\n程序应独立计算每个用例的 $\\mathcal{R}$，并将结果汇总到一行中。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按测试用例顺序排列的结果，例如 $[\\mathcal{R}_{A},\\mathcal{R}_{B},\\mathcal{R}_{C},\\mathcal{R}_{D}]$。由于所有量均为无量纲，因此不使用单位。", "solution": "用户提供了一个问题陈述，该陈述已经过验证，被认为是科学上合理、适定、客观且自洽的。该问题要求计算一个性能指标 $\\mathcal{R}$，该指标比较了将相对论性等离子体射流注入“质点网格法”（PIC）计算区域的两种不同策略。解决方案如下。\n\n### 理论基础\n\n这个问题的基石是局域电荷守恒原理，其数学表达式为连续性方程：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial J}{\\partial x} = 0\n$$\n其中 $\\rho$ 是电荷密度，$J$ 是电流密度。在狭义相对论中，电荷-电流密度构成一个四维矢量 $J^{\\mu} = (c\\rho, \\mathbf{J})$。对于一个相对于实验室参考系以速度 $v$ 沿 $x$ 轴移动的参考系，四维电流的分量根据洛伦兹变换进行转换。如果在等离子体的静止参考系中没有净电流（即 $J'_{x} = 0$，其中带撇号的量表示在静止参考系中）且固有电荷密度为 $\\rho' = q n_0$，那么实验室参考系中的量为：\n$$\n\\rho = \\gamma \\rho' = q \\gamma n_{0}\n$$\n$$\nJ = v \\rho = q \\gamma v n_{0}\n$$\n其中 $\\gamma = 1/\\sqrt{1 - (v/c)^2}$ 是洛伦兹因子。一个关键的观察是，任何形式为 $\\rho(x,t) = f(x-vt)$ 和 $J(x,t) = v f(x-vt)$ 的密度和电流分布都会自动满足连续的连续性方程，因为 $\\partial_t \\rho = -v f'(x-vt)$ 且 $\\partial_x J = v f'(x-vt)$。“匹配”的注入器模型就是为了遵循这一基本一致性而构建的。\n\n### 离散格式与注入器模型\n\n该问题在交错网格上定义了连续性方程的离散版本，这对于 PIC 和其他有限体积法是典型的。在单元 $i$ 和时间步 $n$ 处的电荷守恒残差为：\n$$\nr_{i}^{n} = \\rho_{i}^{n+1} - \\rho_{i}^{n} + \\frac{\\Delta t}{\\Delta x} \\left( J_{i+1/2}^{n+1/2} - J_{i-1/2}^{n+1/2} \\right)\n$$\n这是连续性方程的二阶精度中心差分近似。它将一个单元在一个时间步 $\\Delta t$ 内的电荷变化与其通过单元面的净电流通量联系起来。\n\n比较了两种注入器模型：\n1.  **匹配的注入器**：\n    $$\n    \\rho_{\\mathrm{match}}(x,t) = q \\gamma n_{0}(x - v t), \\quad J_{\\mathrm{match}}(x,t) = \\rho_{\\mathrm{match}}(x,t) v\n    $$\n    该模型正确地对电荷和电流都实施了洛伦兹变换。由于它满足连续的连续性方程，离散残差 $r_{i}^{n}$ 将仅由于数值格式的截断误差而为非零，对于足够精细的网格，该误差预计会很小。\n\n2.  **不匹配的注入器**：\n    $$\n    \\rho_{\\mathrm{mis}}(x,t) = q \\gamma n_{0}(x - v t), \\quad J_{\\mathrm{mis}}(x,t) = q n_{0}(x - v t) v = \\frac{1}{\\gamma} J_{\\mathrm{match}}(x,t)\n    $$\n    该模型代表了一种常见的实现错误，即电荷密度被正确地增强，而电流却没有。这在连续层面上违反了连续性方程，引入了一个源项：\n    $$\n    \\frac{\\partial \\rho_{\\mathrm{mis}}}{\\partial t} + \\frac{\\partial J_{\\mathrm{mis}}}{\\partial x} = q v n'_{0}(x-vt) \\left(1 - \\gamma\\right) \\neq 0 \\quad \\text{for } v \\neq 0\n    $$\n    因此，这种情况下的离散残差 $r_{i}^{n}$ 将主要由这种物理不一致性决定，而不仅仅是数值截断误差，并且预计会显著大于匹配情况下的残差。\n\n### 计算策略\n\n目标是计算比率 $\\mathcal{R} = \\mathrm{RMS}_{\\mathrm{mis}} / \\mathrm{RMS}_{\\mathrm{match}}$。对于每种注入器类型，均方根（RMS）残差是在区域的内部单元（$i=1, \\dots, N-2$）和所有指定的时间步（$n=0, \\dots, N_t-1$）上计算的。\n\n每个测试用例的算法如下：\n1.  **网格与参数设置**：对于一组给定的参数（$\\beta, L, N, \\sigma, \\Delta t, N_t$），定义计算网格参数：$\\Delta x = L/N$，$v=\\beta$，以及 $\\gamma=1/\\sqrt{1-\\beta^2}$。\n2.  **定义网格点**：为所有需要求值的点创建坐标数组。这可以通过使用 `numpy` 的 `meshgrid` 函数高效地完成，以生成对应于 $(\\text{时间点}) \\times (\\text{空间点})$ 的二维坐标数组。所需的点是：\n    - 密度：在时间 $t^n=n\\Delta t$ 和 $t^{n+1}$ 的单元中心 $x_i=(i+0.5)\\Delta x$。\n    - 电流：在时间 $t^{n+1/2}=(n+0.5)\\Delta t$ 的单元面 $x_{i\\pm1/2}$。\n3.  **函数求值**：根据注入器类型（`match` 或 `mismatch`），在相应的网格点矩阵上对 $\\rho(x,t)$ 和 $J(x,t)$ 的解析函数进行求值。\n4.  **计算残差**：使用提供的公式，通过单次向量化操作计算离散残差矩阵 $r_i^n$。\n5.  **计算 RMS**：通过对残差矩阵的所有元素进行平方、求均值然后取平方根来计算 RMS 值。这对 `match` 和 `mismatch` 两种情况都执行，以得到 $\\mathrm{RMS}_{\\mathrm{match}}$ 和 $\\mathrm{RMS}_{\\mathrm{mis}}$。\n6.  **计算比率**：最终的性能指标计算为 $\\mathcal{R} = \\mathrm{RMS}_{\\mathrm{mis}} / \\mathrm{RMS}_{\\mathrm{match}}$。\n\n对所提供的四个测试用例中的每一个重复此过程，并将所得的比率收集到一个列表中作为最终输出。预期对于相对论性情况（$\\beta$ 接近 $1$），$\\mathcal{R}$ 将显著大于 $1$，而对于非相对论性情况（$\\beta \\ll 1$），$\\mathcal{R}$ 将接近 $1$，这表明了一致的电荷-电流注入方案的重要性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rms_for_case(beta, L, N, sigma, dt_factor, Nt, injector_type):\n    \"\"\"\n    Calculates the RMS discrete conservation residual for a given test case.\n    \n    Args:\n        beta (float): Dimensionless velocity v/c.\n        L (float): Domain length.\n        N (int): Number of grid cells.\n        sigma (float): Width of the Gaussian profile.\n        dt_factor (float): Factor for time step, dt = dt_factor * dx.\n        Nt (int): Number of time steps.\n        injector_type (str): 'match' or 'mismatch'.\n\n    Returns:\n        float: The calculated RMS residual.\n    \"\"\"\n    # Physical and numerical constants from the problem description\n    q = 1.0\n    v = beta  # c=1\n    if beta = 1.0:\n        gamma = float('inf')\n    else:\n        gamma = 1.0 / np.sqrt(1.0 - beta**2)\n    \n    dx = L / N\n    dt = dt_factor * dx\n\n    # Define the spatiotemporal grid for interior cells\n    # Interior cell indices: i = 1, ..., N-2\n    i_indices = np.arange(1, N - 1)\n    # Time step indices: n = 0, ..., Nt-1\n    n_indices = np.arange(Nt)\n\n    # Create 2D meshgrids for vectorized calculations. Shape: (Nt, N-2)\n    # Cell centers for density evaluation\n    x_centers_mesh, t_n_mesh = np.meshgrid((i_indices + 0.5) * dx, n_indices * dt)\n    _, t_np1_mesh = np.meshgrid((i_indices + 0.5) * dx, (n_indices + 1) * dt)\n\n    # Cell faces for current evaluation\n    x_faces_l_mesh, t_nph_mesh = np.meshgrid(i_indices * dx, (n_indices + 0.5) * dt)\n    x_faces_r_mesh, _ = np.meshgrid((i_indices + 1) * dx, (n_indices + 0.5) * dt)\n\n    # Define the rest-frame number density profile function n0(xi)\n    def n0(xi, s):\n        # n_pk is 1\n        return np.exp(-xi**2 / (2 * s**2))\n\n    # --- Calculate density terms rho ---\n    # rho is the same for both matched and mismatched injectors\n    \n    # rho at time t^n\n    xi_rho_n = x_centers_mesh - v * t_n_mesh\n    rho_n = q * gamma * n0(xi_rho_n, sigma)\n\n    # rho at time t^{n+1}\n    xi_rho_np1 = x_centers_mesh - v * t_np1_mesh\n    rho_np1 = q * gamma * n0(xi_rho_np1, sigma)\n\n    # --- Calculate current terms J ---\n    # J depends on the injector type\n    \n    # xi for currents at t^{n+1/2} on left and right faces\n    xi_J_l = x_faces_l_mesh - v * t_nph_mesh\n    xi_J_r = x_faces_r_mesh - v * t_nph_mesh\n\n    if injector_type == 'match':\n        # J_match = rho_match * v = q * gamma * n0 * v\n        J_l = q * gamma * v * n0(xi_J_l, sigma)\n        J_r = q * gamma * v * n0(xi_J_r, sigma)\n    elif injector_type == 'mismatch':\n        # J_mis = q * n0 * v\n        J_l = q * v * n0(xi_J_l, sigma)\n        J_r = q * v * n0(xi_J_r, sigma)\n    else:\n        raise ValueError(\"Invalid injector_type specified.\")\n\n    # --- Calculate residual r_i^n for all (i, n) ---\n    residuals = (rho_np1 - rho_n) + (dt / dx) * (J_r - J_l)\n\n    # --- Calculate the final RMS value ---\n    # Sum of squares over all interior cells and time steps\n    sum_sq = np.sum(residuals**2)\n    # Total number of elements in the sum\n    num_elements = (N - 2) * Nt\n    \n    if num_elements == 0:\n        return 0.0\n\n    rms = np.sqrt(sum_sq / num_elements)\n    \n    return rms\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (beta, L, N, sigma, dt_factor, Nt)\n        (0.8, 10.0, 512, 0.4, 0.5, 100),   # Case A\n        (0.99, 10.0, 512, 0.2, 0.3, 150),  # Case B\n        (0.5, 10.0, 256, 0.6, 1.0, 80),    # Case C\n        (0.1, 10.0, 128, 1.0, 0.8, 60),    # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, L, N, sigma, dt_factor, Nt = case\n        \n        rms_match = calculate_rms_for_case(beta, L, N, sigma, dt_factor, Nt, 'match')\n        rms_mis = calculate_rms_for_case(beta, L, N, sigma, dt_factor, Nt, 'mismatch')\n\n        # ratio = rms_mis / rms_match avoids ZeroDivisionError if rms_match is exactly 0.\n        if rms_match  0:\n            ratio = rms_mis / rms_match\n        else:\n            ratio = float('inf') if rms_mis  0 else 1.0\n        \n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3529051"}, {"introduction": "显式PIC模拟的计算成本往往受到光速所决定的严格时间步长限制。为了解决这个问题，研究人员有时会使用“降低光速”近似，即在代码中人为地使用一个小于真实光速 $c$ 的值 $c_{\\mathrm{red}}$。本练习 [@problem_id:3529033] 旨在通过编程实践，量化这种近似对两个关键物理诊断量——磁重联出流速度和激波压缩比——所引入的误差。通过这个过程，你将深入理解在计算效率和物理保真度之间进行权衡的艺术，这是计算天体物理学中的一个核心议题。", "problem": "要求您量化在计算天体物理学的等离子体粒子模拟 (PIC) 方法中使用约化光速近似所带来的影响。约化光速近似用一个较小的值 $c_{\\mathrm{red}}$ 替代真实光速 $c$ 以放宽时间步长的限制，但这会改变信号速度以及场与粒子之间的耦合。请量化两个物理相关的诊断量（磁重联出流速度和一维垂直快磁声激波压缩比）由此产生的误差，该误差是相对于使用完整光速 $c$ 的基准线而言的。\n\n从以下基本定律和经过充分检验的事实出发：\n- Lorentz力和Maxwell方程组意味着等离子体中的信号传播速度是有限的，其上限为光速 $c$。\n- 在相对论磁流体力学 (RMHD) 中，对于单个粒子质量为 $m$ 的对等离子体，磁场强度为 $B$（单位：$\\mathrm{Tesla}$），数密度为 $n$（单位：$\\mathrm{m^{-3}}$），真空磁导率为 $\\mu_0$，磁化参数为 $\\sigma = \\dfrac{B^2}{\\mu_0 n m c^2}$。相应的相对论阿尔芬速度为 $v_{\\mathrm{A}}(c) = c \\sqrt{\\dfrac{\\sigma}{1+\\sigma}}$。\n- 对于绝热指数为 $\\gamma$、上游压力为 $p$（单位：$\\mathrm{Pascal}$）、质量密度为 $\\rho = n m$（单位：$\\mathrm{kg/m^3}$）的理想气体，其相对论声速为 $a_s(c) = c \\sqrt{\\dfrac{\\gamma p}{\\rho c^2 + \\dfrac{\\gamma}{\\gamma - 1} p}}$。这可由相对论焓密度的定义 $w = \\rho c^2 + \\dfrac{\\gamma}{\\gamma - 1} p$ 推导得出。\n- 在 RMHD 中，对于垂直传播，一个近似的快磁声速为 $v_{\\mathrm{ms}}^2(c) = a_s^2(c) + v_{\\mathrm{A}}^2(c) - \\dfrac{a_s^2(c)\\, v_{\\mathrm{A}}^2(c)}{c^2}$。该表达式在极限情况下能正确地简化，并被广泛用作特征速度的闭合关系。\n- 在可压缩气体动力学中，一个常用的、以上游马赫数 $M$ 表示的激波压缩比公式为 $r(M,\\gamma) = \\dfrac{(\\gamma + 1) M^2}{(\\gamma - 1) M^2 + 2}$。此处 $M = \\dfrac{u_1}{v_{\\mathrm{ms}}}$，其中 $u_1$ 是相对于激波法向的上游流速，单位为 $\\mathrm{m/s}$。该公式提供了一个在数值求解器中使用的稳健估计，此处将其作为诊断量的定义。\n\n将两个诊断量及其误差定义如下：\n- 磁重联出流速度诊断量：$v_{\\mathrm{out,true}} = v_{\\mathrm{A}}(c)$，而在一个约化光速的PIC离散化方案中，出流速度不能超过 $c_{\\mathrm{red}}$，因此采用 $v_{\\mathrm{out,red}} = \\min\\!\\left(v_{\\mathrm{A}}(c), c_{\\mathrm{red}}\\right)$。相对误差为 $\\varepsilon_{\\mathrm{out}} = \\dfrac{v_{\\mathrm{out,red}} - v_{\\mathrm{out,true}}}{v_{\\mathrm{out,true}}}$，这是一个无量纲量，应以小数（非百分比）形式报告。\n- 激波压缩比诊断量：$v_{\\mathrm{ms,true}}$ 在各处均使用 $c$，而约化近似则在 $\\sigma$、$v_{\\mathrm{A}}$ 和 $a_s$ 的定义中一致地用 $c_{\\mathrm{red}}$ 替换 $c$。即 $\\sigma_{\\mathrm{red}} = \\dfrac{B^2}{\\mu_0 n m c_{\\mathrm{red}}^2}$，$v_{\\mathrm{A,red}} = c_{\\mathrm{red}} \\sqrt{\\dfrac{\\sigma_{\\mathrm{red}}}{1+\\sigma_{\\mathrm{red}}}}$，以及 $a_{s,\\mathrm{red}} = c_{\\mathrm{red}} \\sqrt{\\dfrac{\\gamma p}{\\rho c_{\\mathrm{red}}^2 + \\dfrac{\\gamma}{\\gamma - 1} p}}$。然后有 $v_{\\mathrm{ms,red}}^2 = a_{s,\\mathrm{red}}^2 + v_{\\mathrm{A,red}}^2 - \\dfrac{a_{s,\\mathrm{red}}^2\\, v_{\\mathrm{A,red}}^2}{c_{\\mathrm{red}}^2}$。相应的马赫数为 $M_{\\mathrm{true}} = \\dfrac{u_1}{v_{\\mathrm{ms,true}}}$ 和 $M_{\\mathrm{red}} = \\dfrac{u_1}{v_{\\mathrm{ms,red}}}$，压缩比为 $r_{\\mathrm{true}} = r(M_{\\mathrm{true}},\\gamma)$ 和 $r_{\\mathrm{red}} = r(M_{\\mathrm{red}},\\gamma)$。相对误差为 $\\varepsilon_r = \\dfrac{r_{\\mathrm{red}} - r_{\\mathrm{true}}}{r_{\\mathrm{true}}}$，这是一个无量纲量，应以小数形式报告。\n\n实现一个程序，对于每个测试用例，根据上述定义计算并报告数组 $(\\varepsilon_{\\mathrm{out}}, \\varepsilon_r)$。使用以下物理常数和测试套件。所有输入均采用国际单位制 (SI)，所有输出均为无量纲小数：\n- 光速: $c = 2.99792458 \\times 10^8\\,\\mathrm{m/s}$。\n- 真空磁导率: $\\mu_0 = 4 \\pi \\times 10^{-7}\\,\\mathrm{H/m}$。\n\n测试套件参数集 (每个元组为 $(B, n, m, p, u_1, \\gamma, c_{\\mathrm{red}})$):\n1. $(0.01\\,\\mathrm{T}, 10^{16}\\,\\mathrm{m^{-3}}, 9.10938356 \\times 10^{-31}\\,\\mathrm{kg}, 0.01\\, n m c^2\\,\\mathrm{Pa}, 0.6\\, c\\,\\mathrm{m/s}, \\dfrac{4}{3}, 0.7\\, c\\,\\mathrm{m/s})$。\n2. $(0.5\\,\\mathrm{T}, 10^{15}\\,\\mathrm{m^{-3}}, 9.10938356 \\times 10^{-31}\\,\\mathrm{kg}, 0.001\\, n m c^2\\,\\mathrm{Pa}, 0.9\\, c\\,\\mathrm{m/s}, \\dfrac{4}{3}, 0.5\\, c\\,\\mathrm{m/s})$。\n3. $(0.001\\,\\mathrm{T}, 10^{16}\\,\\mathrm{m^{-3}}, 9.10938356 \\times 10^{-31}\\,\\mathrm{kg}, 0.05\\, n m c^2\\,\\mathrm{Pa}, 0.2\\, c\\,\\mathrm{m/s}, \\dfrac{4}{3}, 0.2\\, c\\,\\mathrm{m/s})$。\n4. $(0.1\\,\\mathrm{T}, 10^{15}\\,\\mathrm{m^{-3}}, 9.10938356 \\times 10^{-31}\\,\\mathrm{kg}, 0.02\\, n m c^2\\,\\mathrm{Pa}, 0.5\\, c\\,\\mathrm{m/s}, \\dfrac{4}{3}, c\\,\\mathrm{m/s})$。\n5. $(0.3\\,\\mathrm{T}, 10^{15}\\,\\mathrm{m^{-3}}, 9.10938356 \\times 10^{-31}\\,\\mathrm{kg}, 0.005\\, n m c^2\\,\\mathrm{Pa}, 0.8\\, c\\,\\mathrm{m/s}, \\dfrac{4}{3}, 0.1\\, c\\,\\mathrm{m/s})$。\n\n注意：\n- 在每个元组中，像 $0.01\\, n m c^2\\,\\mathrm{Pa}$ 这样的表达式表示压力 $p$ 的值为 $0.01 \\times n \\times m \\times c^2$，单位为 $\\mathrm{Pa}$。\n- 该等离子体是正负电子对等离子体，其中每个载流子的质量取为 $m$；质量密度为 $\\rho = n m$，绝热指数为 $\\gamma = \\dfrac{4}{3}$，这与相对论理想气体闭合关系一致。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其顺序为 $[\\varepsilon_{\\mathrm{out},1}, \\varepsilon_{r,1}, \\varepsilon_{\\mathrm{out},2}, \\varepsilon_{r,2}, \\ldots, \\varepsilon_{\\mathrm{out},5}, \\varepsilon_{r,5}]$，每个条目都是一个浮点小数。", "solution": "所提供的问题是有效的。它在科学上基于相对论磁流体力学 (RMHD) 的原理，提法恰当，提供了所有必要信息，并且表述客观。任务是量化约化光速近似（计算等离子体物理学中的一种真实技术）对两个关键物理诊断量引入的误差。这是一个定义明确且具有实质意义的问题。\n\n解决方案首先使用光速 $c$ 计算诊断量的真实值，然后使用约化光速 $c_{\\mathrm{red}}$ 计算相应的值。然后计算每个诊断量的相对误差。\n\n### 控制方程和定义\n\n该问题基于以下 RMHD 方程组，这些方程是我们计算的基础。\n使用的物理常数是光速 $c = 2.99792458 \\times 10^8\\,\\mathrm{m/s}$ 和真空磁导率 $\\mu_0 = 4 \\pi \\times 10^{-7}\\,\\mathrm{H/m}$。\n\n对于磁场强度为 $B$、数密度为 $n$、单个粒子质量为 $m$ 的等离子体，其质量密度为 $\\rho = n m$。\n\n1.  **磁化参数 ($\\sigma$)**: 这个无量纲参数衡量磁能密度相对于静止质量能密度的比值。\n    $$ \\sigma = \\frac{B^2}{\\mu_0 n m c^2} $$\n\n2.  **相对论阿尔芬速度 ($v_{\\mathrm{A}}$)**: 这是磁场线扰动的特征速度。\n    $$ v_{\\mathrm{A}}(c) = c \\sqrt{\\frac{\\sigma}{1+\\sigma}} $$\n\n3.  **相对论声速 ($a_s$)**: 这是纵向压力波的速度。对于绝热指数为 $\\gamma$、压力为 $p$ 的理想气体，其公式为：\n    $$ a_s(c) = c \\sqrt{\\frac{\\gamma p}{\\rho c^2 + \\frac{\\gamma}{\\gamma - 1} p}} $$\n\n4.  **垂直快磁声速 ($v_{\\mathrm{ms}}$)**: 这是垂直于磁场传播的最快波速。\n    $$ v_{\\mathrm{ms}}^2(c) = a_s^2(c) + v_{\\mathrm{A}}^2(c) - \\frac{a_s^2(c) v_{\\mathrm{A}}^2(c)}{c^2} $$\n\n5.  **激波压缩比 ($r$)**: 对于上游马赫数为 $M = u_1/v_{\\mathrm{ms}}$ 的激波，其中 $u_1$ 是上游流速，其压缩比定义为：\n    $$ r(M,\\gamma) = \\frac{(\\gamma + 1) M^2}{(\\gamma - 1) M^2 + 2} $$\n\n### 误差计算方法\n\n对于每个测试用例，我们计算两个相对误差：磁重联出流速度的相对误差 $\\varepsilon_{\\mathrm{out}}$ 和激波压缩比的相对误差 $\\varepsilon_r$。\n\n#### 1. 磁重联出流速度误差 ($\\varepsilon_{\\mathrm{out}}$)\n\n磁重联出流由阿尔芬速度建模。\n- **真实出流速度**是使用真实光速 $c$ 计算的相对论阿尔芬速度：\n  $$ v_{\\mathrm{out,true}} = v_{\\mathrm{A}}(c) = c \\sqrt{\\frac{\\sigma_{\\mathrm{true}}}{1+\\sigma_{\\mathrm{true}}}}, \\quad \\text{其中} \\quad \\sigma_{\\mathrm{true}} = \\frac{B^2}{\\mu_0 n m c^2} $$\n- 在使用约化光速 $c_{\\mathrm{red}}$ 的模拟中，任何信号能传播的最大速度是 $c_{\\mathrm{red}}$。因此，**近似出流速度**的上限为 $c_{\\mathrm{red}}$：\n  $$ v_{\\mathrm{out,red}} = \\min(v_{\\mathrm{out,true}}, c_{\\mathrm{red}}) $$\n- **相对误差**则为：\n  $$ \\varepsilon_{\\mathrm{out}} = \\frac{v_{\\mathrm{out,red}} - v_{\\mathrm{out,true}}}{v_{\\mathrm{out,true}}} $$\n  仅当真实阿尔芬速度超过约化光速时 ($v_{\\mathrm{A}}(c) > c_{\\mathrm{red}}$)，此误差才非零。\n\n#### 2. 激波压缩比误差 ($\\varepsilon_r$)\n\n此误差的计算需要分别在两种情况下计算压缩比 $r$：一种是使用真实光速 $c$（“真实”路径），另一种是统一使用约化光速 $c_{\\mathrm{red}}$（“约化”路径）。\n\n**真实路径 (使用 $c$):**\n1.  如上所述，计算真实阿尔芬速度 $v_{\\mathrm{A,true}} = v_{\\mathrm{A}}(c)$。\n2.  计算真实声速 $a_{s,\\mathrm{true}} = a_s(c)$：\n    $$ a_{s,\\mathrm{true}} = c \\sqrt{\\frac{\\gamma p}{\\rho c^2 + \\frac{\\gamma}{\\gamma - 1} p}} $$\n3.  计算真实快磁声速 $v_{\\mathrm{ms,true}}$：\n    $$ v_{\\mathrm{ms,true}}^2 = a_{s,\\mathrm{true}}^2 + v_{\\mathrm{A,true}}^2 - \\frac{a_{s,\\mathrm{true}}^2 v_{\\mathrm{A,true}}^2}{c^2} $$\n4.  计算真实马赫数 $M_{\\mathrm{true}} = u_1 / v_{\\mathrm{ms,true}}$。注意，上游参数 $u_1$ 和 $p$ 对两条路径都是固定输入。\n5.  计算真实压缩比 $r_{\\mathrm{true}} = r(M_{\\mathrm{true}}, \\gamma)$。\n\n**约化路径 (使用 $c_{\\mathrm{red}}$):**\n1.  计算约化磁化参数 $\\sigma_{\\mathrm{red}}$：\n    $$ \\sigma_{\\mathrm{red}} = \\frac{B^2}{\\mu_0 n m c_{\\mathrm{red}}^2} $$\n2.  计算约化阿尔芬速度 $v_{\\mathrm{A,red}} = v_{\\mathrm{A}}(c_{\\mathrm{red}})$：\n    $$ v_{\\mathrm{A,red}} = c_{\\mathrm{red}} \\sqrt{\\frac{\\sigma_{\\mathrm{red}}}{1+\\sigma_{\\mathrm{red}}}} $$\n3.  计算约化声速 $a_{s,\\mathrm{red}} = a_s(c_{\\mathrm{red}})$：\n    $$ a_{s,\\mathrm{red}} = c_{\\mathrm{red}} \\sqrt{\\frac{\\gamma p}{\\rho c_{\\mathrm{red}}^2 + \\frac{\\gamma}{\\gamma - 1} p}} $$\n4.  计算约化快磁声速 $v_{\\mathrm{ms,red}}$：\n    $$ v_{\\mathrm{ms,red}}^2 = a_{s,\\mathrm{red}}^2 + v_{\\mathrm{A,red}}^2 - \\frac{a_{s,\\mathrm{red}}^2 v_{\\mathrm{A,red}}^2}{c_{\\mathrm{red}}^2} $$\n5.  计算约化马赫数 $M_{\\mathrm{red}} = u_1 / v_{\\mathrm{ms,red}}$。\n6.  计算约化压缩比 $r_{\\mathrm{red}} = r(M_{\\mathrm{red}}, \\gamma)$。\n\n**相对误差计算:**\n最后，压缩比的相对误差计算如下：\n$$ \\varepsilon_r = \\frac{r_{\\mathrm{red}} - r_{\\mathrm{true}}}{r_{\\mathrm{true}}} $$\n\n通过对测试套件中提供的每个参数集执行这些步骤，我们可以量化约化光速近似的影响。我们开发了一个 Python 脚本来系统地执行这些计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the relative errors in reconnection outflow speed and shock compression ratio\n    due to the reduced speed-of-light approximation in PIC simulations.\n    \"\"\"\n    # Physical constants in SI units\n    C = 2.99792458e8  # Speed of light (m/s)\n    MU0 = 4 * np.pi * 1e-7  # Vacuum permeability (H/m)\n    \n    # Test suite parameter sets:\n    # (B, n, m, p_factor, u1_factor, gamma, c_red_factor)\n    test_cases = [\n        (0.01, 1e16, 9.10938356e-31, 0.01, 0.6, 4./3., 0.7),\n        (0.5, 1e15, 9.10938356e-31, 0.001, 0.9, 4./3., 0.5),\n        (0.001, 1e16, 9.10938356e-31, 0.05, 0.2, 4./3., 0.2),\n        (0.1, 1e15, 9.10938356e-31, 0.02, 0.5, 4./3., 1.0),\n        (0.3, 1e15, 9.10938356e-31, 0.005, 0.8, 4./3., 0.1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        B, n, m, p_factor, u1_factor, gamma, c_red_factor = case\n        \n        # Calculate full physical parameters from factors\n        p = p_factor * n * m * C**2\n        u1 = u1_factor * C\n        c_red = c_red_factor * C\n        \n        # --- Calculate epsilon_out ---\n        \n        # True outflow speed calculation\n        sigma_true = B**2 / (MU0 * n * m * C**2)\n        v_A_true = C * np.sqrt(sigma_true / (1.0 + sigma_true))\n        v_out_true = v_A_true\n        \n        # Reduced outflow speed is capped by c_red\n        v_out_red = np.minimum(v_out_true, c_red)\n        \n        # Relative error in outflow speed\n        # Handle the case where v_out_true is zero to avoid division by zero.\n        if v_out_true == 0:\n            eps_out = 0.0 if v_out_red == 0.0 else float('inf')\n        else:\n            eps_out = (v_out_red - v_out_true) / v_out_true\n            \n        # --- Calculate epsilon_r ---\n        \n        rho = n * m\n        gamma_term = gamma / (gamma - 1.0) # Precompute for efficiency\n        \n        # True Path Calculation (using C)\n        a_s_true_sq = C**2 * (gamma * p) / (rho * C**2 + gamma_term * p)\n        v_A_true_sq = v_A_true**2\n        v_ms_true_sq = a_s_true_sq + v_A_true_sq - (a_s_true_sq * v_A_true_sq) / C**2\n        v_ms_true = np.sqrt(v_ms_true_sq)\n        M_true = u1 / v_ms_true\n        r_true = ((gamma + 1.0) * M_true**2) / ((gamma - 1.0) * M_true**2 + 2.0)\n        \n        # Reduced Path Calculation (using c_red)\n        sigma_red = B**2 / (MU0 * n * m * c_red**2)\n        v_A_red_sq = c_red**2 * (sigma_red / (1.0 + sigma_red))\n        a_s_red_sq = c_red**2 * (gamma * p) / (rho * c_red**2 + gamma_term * p)\n        v_ms_red_sq = a_s_red_sq + v_A_red_sq - (a_s_red_sq * v_A_red_sq) / c_red**2\n        v_ms_red = np.sqrt(v_ms_red_sq)\n        M_red = u1 / v_ms_red\n        r_red = ((gamma + 1.0) * M_red**2) / ((gamma - 1.0) * M_red**2 + 2.0)\n        \n        # Relative error in compression ratio\n        # Handle the case where r_true is zero to avoid division by zero.\n        if r_true == 0:\n            eps_r = 0.0 if r_red == 0.0 else float('inf')\n        else:\n            eps_r = (r_red - r_true) / r_true\n\n        results.extend([eps_out, eps_r])\n\n    # Format the results into the required string format\n    # The format specifier ensures standard decimal representation, not scientific notation.\n    formatted_results = [f\"{res:.15f}\".rstrip('0').rstrip('.') if res != 0 else \"0.0\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3529033"}, {"introduction": "当模拟高密度等离子体时，显式的PIC方法会因为 $\\omega_p \\Delta t \\gt 1$ 而变得不稳定或需要极小的时间步长，导致计算成本过高。隐式时间步进方案通过提供无条件的数值稳定性来克服这一限制，但这需要求解一个大型线性方程组。本练习 [@problem_id:3529066] 将指导你为一个静电PIC模型实现一个隐式求解器，不仅介绍了共轭梯度法这一强大的迭代工具，还展示了基于物理洞察力的预条件子（preconditioner）如何能够极大地加速收敛，为你提供了解决极端等离子体参数下模拟挑战的数值武器。", "problem": "考虑一种用于冷、单电荷电子等离子体的一维静电隐式粒子模拟（Particle-In-Cell）方法，该方法具有周期性边界。计算目标是在等离子体频率 $ \\omega_p $ 相对于时间步长大（具体满足 $ \\omega_p \\Delta t \\gg 1 $）的稠密等离子体条件下，将电场从时间步 $n$ 推进到 $n+1$。从基本定律和经过充分检验的公式出发：电子的动量方程、适用于静电条件的麦克斯韦方程组以及连续性方程。假设存在一个数密度为 $ n_e $ 的冷的、均匀的电子等离子体，其中包含固定的、中性化的离子，并将研究范围限制在一维空间 $ x \\in [0,1) $ 内，采用周期性边界条件。在整个过程中使用无量纲变量，因此最终的数值答案中不需要物理单位。\n\n基于这些基础，执行后向时间隐式离散化，为电场 $ E^{n+1} $ 的网格表示推导出一个线性对称正定系统。证明所得到的算子包含一个与单位矩阵成正比且依赖于 $ \\omega_p^2 \\Delta t^2 $ 的局域响应项，以及一个由麦克斯韦方程组产生的、在周期性网格上简化为离散拉普拉斯算子的空间耦合项。将得到的线性系统表示为\n$$\n\\mathbf{A} \\mathbf{E}^{n+1} = \\mathbf{b},\n$$\n其中 $ \\mathbf{A} $ 是一个结合了局域等离子体响应和离散拉普拉斯算子的对称正定矩阵，$ \\mathbf{E}^{n+1} $ 是时间步 $ n+1 $ 时电场的未知网格向量，$ \\mathbf{b} $ 是由时间步 $ n $ 的数据和任何外部源确定的已知向量。在迭代求解中使用零初始猜测 $ \\mathbf{E}^{(0)} = \\mathbf{0} $。\n\n实现共轭梯度法来求解 $ \\mathbf{A} \\mathbf{E}^{n+1} = \\mathbf{b} $，并记录每次迭代 $ k $ 时的残差范数 $ \\| \\mathbf{r}^{(k)} \\|_2 $，其中 $ \\mathbf{r}^{(k)} = \\mathbf{b} - \\mathbf{A} \\mathbf{E}^{(k)} $。在两种情况下分析收敛性：\n1. 不使用任何预条件子。\n2. 使用一个基于物理的预条件子，该预条件子通过忽略空间耦合来模拟局域等离子体响应，即应用当离散拉普拉斯算子被舍弃时所得到的对角算子的逆。\n\n在 $ [0,1) $ 上使用一个具有周期性边界条件的 $ N $ 个点的均匀网格。在此网格上，离散拉普拉斯算子作用于向量 $ \\mathbf{x} $ 的方式为\n$$\n(D \\mathbf{x})_i = \\mathbf{x}_{i+1} - 2 \\mathbf{x}_i + \\mathbf{x}_{i-1},\n$$\n其中索引对 $ N $ 取模。在推导出的算子 $ \\mathbf{A} $ 中，离散拉普拉斯算子必须由一个非负耦合参数 $ \\lambda $ 进行缩放，该参数编码了隐式场更新产生的空间耦合强度。从波数为 $ m $ 的单个正弦傅里叶模式构造右端向量 $ \\mathbf{b} $，具体为\n$$\nb_i = \\sin(2 \\pi m x_i), \\quad x_i = \\frac{i}{N}, \\quad i = 0, 1, \\ldots, N-1.\n$$\n\n对于每个测试用例，运行不带预处理的共轭梯度法和带基于物理的预条件子的共轭梯度法。使用基于相对残差的停止准则：当 $ \\| \\mathbf{r}^{(k)} \\|_2 / \\| \\mathbf{r}^{(0)} \\|_2 \\leq 10^{-8} $ 或当 $ k $ 达到 $ N $ 时停止，以先到者为准。记录每种情况下所需的迭代次数。\n\n测试套件：\n- 情况1（一般稠密等离子体，中等空间耦合）：$ N = 128 $，$ \\omega_p = 100 $，$ \\Delta t = 10 $，$ \\lambda = 1 $，$ m = 1 $。\n- 情况2（极稠密等离子体，中等空间耦合）：$ N = 128 $，$ \\omega_p = 1000 $，$ \\Delta t = 20 $，$ \\lambda = 1 $，$ m = 3 $。\n- 情况3（无空间耦合，纯局域响应）：$ N = 128 $，$ \\omega_p = 100 $，$ \\Delta t = 10 $，$ \\lambda = 0 $，$ m = 5 $。\n- 情况4（稠密等离子体，强空间耦合和更高分辨率）：$ N = 256 $，$ \\omega_p = 300 $，$ \\Delta t = 15 $，$ \\lambda = 50 $，$ m = 2 $。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔的数对列表，其中每个数对对于一个测试用例是 $ [k_{\\text{no}},k_{\\text{pre}}] $，$ k_{\\text{no}} $ 和 $ k_{\\text{pre}} $ 分别表示不使用和使用基于物理的预条件子时的迭代次数。例如，输出格式必须是\n$$\n\\texttt{[[k\\_no1,k\\_pre1],[k\\_no2,k\\_pre2],[k\\_no3,k\\_pre3],[k\\_no4,k\\_pre4]]}.\n$$", "solution": "该问题要求在一个一维、隐式粒子模拟（PIC）的冷电子等离子体模型中，推导并求解一个关于电场的线性系统。该系统将使用共轭梯度（CG）法求解，包括使用和不使用基于物理的预条件子两种情况。\n\n### 电场线性系统的推导\n\n我们从用于冷、无磁化电子等离子体的线性化一维流体方程开始，其中存在密度为 $n_0$ 的固定中性化离子背景。电子电荷为 $q_e = -e$，质量为 $m_e$。在无量纲单位中，我们可以设置 $e=1$，$m_e=1$ 和 $\\epsilon_0=1$。\n\n1.  **动量方程（冷流体的欧拉方程）：**\n    $$\n    \\frac{\\partial v_e}{\\partial t} = -E\n    $$\n2.  **电流密度：** 电子电流密度为 $J_e = -n_e v_e$。在平衡态（$n_e \\approx n_0$, $v_e \\approx 0$）附近进行线性化，我们得到 $J_e \\approx -n_0 v_e$。\n3.  **安培-麦克斯韦定律：** 在一维无磁场的情况下，该定律为 $\\frac{\\partial E}{\\partial t} = -J_{tot}$。在我们的等离子体中，总电流由电子电流 $J_e$ 和任何其他源组成，我们将这些源合并到最终系统的右侧。因此，我们将 $E$ 的时间演化与等离子体电流联系起来：$\\frac{\\partial E}{\\partial t} = -J_e$。\n\n我们采用后向时间（全隐式）离散格式来处理高频等离子体振荡，即使在 $\\omega_p \\Delta t \\gg 1$ 的情况下，该格式也是稳定的。\n离散化动量方程：\n$$\n\\frac{v_e^{n+1} - v_e^n}{\\Delta t} = -E^{n+1} \\implies v_e^{n+1} = v_e^n - \\Delta t E^{n+1}\n$$\n那么，时间步 $n+1$ 的电流为：\n$$\nJ_e^{n+1} = -n_0 v_e^{n+1} = -n_0 (v_e^n - \\Delta t E^{n+1}) = J_e^n + n_0 \\Delta t E^{n+1}\n$$\n等离子体频率定义为 $\\omega_p^2 = n_0 e^2 / (\\epsilon_0 m_e)$。在我们的无量纲单位中，这变为 $\\omega_p^2 = n_0$。因此，我们有：\n$$\nJ_e^{n+1} = J_e^n + \\omega_p^2 \\Delta t E^{n+1}\n$$\n现在，我们对安培-麦克斯韦定律进行隐式离散化：\n$$\n\\frac{E^{n+1} - E^n}{\\Delta t} = -J_e^{n+1}\n$$\n代入 $J_e^{n+1}$ 的表达式：\n$$\n\\frac{E^{n+1} - E^n}{\\Delta t} = -(J_e^n + \\omega_p^2 \\Delta t E^{n+1})\n$$\n重新整理以求解 $E^{n+1}$：\n$$\nE^{n+1} - E^n = -\\Delta t J_e^n - \\omega_p^2 \\Delta t^2 E^{n+1}\n$$\n$$\n(1 + \\omega_p^2 \\Delta t^2) E^{n+1} = E^n - \\Delta t J_e^n\n$$\n这个方程描述了局域等离子体响应。项 $(1 + \\omega_p^2 \\Delta t^2)E^{n+1}$ 显示了电场如何被等离子体的惯性响应所屏蔽。由于 $\\omega_p \\Delta t \\gg 1$，我们可以将其近似为 $(\\omega_p^2 \\Delta t^2) E^{n+1}$。\n\n空间耦合源于麦克斯韦方程组，特别是高斯定律（泊松方程），它将场与其源联系起来。使用“直接隐式”方法进行完整推导，会得到一个亥姆霍兹型的电场方程。为解决此问题，我们采用所提供的结构，这是此类推导的常见结果：\n$$\n(\\omega_p^2 \\Delta t^2) \\mathbf{E}^{n+1} - \\lambda \\nabla^2 \\mathbf{E}^{n+1} = \\mathbf{b}'\n$$\n其中 $\\mathbf{b}'$ 是从时间 $n$ 的条件推导出的源项，而 $\\lambda$ 是控制空间耦合强度的参数。算子 $\\nabla^2$ 是一维拉普拉斯算子 $\\frac{\\partial^2}{\\partial x^2}$。\n\n我们在 $N$ 个点 $x_i = i/N$（$i=0, \\dots, N-1$）的均匀网格上离散化此方程。电场由其在网格点上的值 $E_i$ 组成的向量 $\\mathbf{E}$ 表示。指定的离散拉普拉斯算子为 $(D\\mathbf{E})_i = E_{i+1} - 2E_i + E_{i-1}$，这对应于 $h^2 \\nabla^2 E$，其中 $h=1/N$ 是网格间距。因子 $h^2$ 可以被吸收到 $\\lambda$ 中。得到的线性系统是 $\\mathbf{A} \\mathbf{E}^{n+1} = \\mathbf{b}$，其中矩阵 $\\mathbf{A}$ 作用于向量 $\\mathbf{E}$ 的方式如下：\n$$\n(\\mathbf{A} \\mathbf{E})_i = (\\omega_p^2 \\Delta t^2) E_i + \\lambda (- (E_{i+1} - 2E_i + E_{i-1}))\n$$\n令 $c = \\omega_p^2 \\Delta t^2$。矩阵 $\\mathbf{A}$ 可以写成：\n$$\n\\mathbf{A} = c \\mathbf{I} - \\lambda \\mathbf{D}\n$$\n其中 $\\mathbf{I}$ 是单位矩阵，$\\mathbf{D}$ 是具有周期性边界条件的离散拉普拉斯算子的矩阵表示。矩阵 $-\\mathbf{D}$ 是一个对称半正定矩阵。其特征值为 $2(1 - \\cos(2\\pi k/N)) \\ge 0$，对于 $k=0, \\dots, N-1$。$\\mathbf{A}$ 的特征值为 $\\mu_k = c + 2\\lambda(1 - \\cos(2\\pi k/N))$。由于 $c = (\\omega_p \\Delta t)^2 > 0$ 且 $\\lambda \\ge 0$，所有特征值 $\\mu_k$ 均为正。因此，$\\mathbf{A}$ 是一个对称正定（SPD）矩阵，这是标准共轭梯度算法的一个要求。\n\n右端向量 $\\mathbf{b}$ 被给定为单个傅里叶模式：\n$$\nb_i = \\sin(2 \\pi m x_i) = \\sin(2 \\pi m i / N)\n$$\n\n### 共轭梯度法\n\n共轭梯度（CG）法是求解线性系统 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ 的一种迭代算法，其中 $\\mathbf{A}$ 是对称正定的。从初始猜测 $\\mathbf{x}^{(0)} = \\mathbf{0}$ 开始，该算法迭代地改进解。对于每个测试用例，我们将运行标准的 CG 算法，并计算迭代次数 $k_{\\text{no}}$，直到相对残差范数 $\\| \\mathbf{r}^{(k)} \\|_2 / \\| \\mathbf{r}^{(0)} \\|_2$ 低于 $10^{-8}$ 的容差。\n\n### 预条件共轭梯度法\n\n预处理是一种提高迭代方法收敛速度的技术。预条件子 $\\mathbf{M}$ 是一个近似于 $\\mathbf{A}$ 但更容易求逆的矩阵。预条件共轭梯度（PCG）法有效地求解变换后的系统 $\\mathbf{M}^{-1}\\mathbf{A}\\mathbf{x} = \\mathbf{M}^{-1}\\mathbf{b}$。\n\n问题指定了一个基于物理的预条件子，它通过从 $\\mathbf{A}$ 中舍去空间耦合（拉普拉斯）项来模拟主导的局域等离子体响应。算子 $\\mathbf{A}$ 由局域响应项 $c\\mathbf{I}$ 和空间耦合项 $-\\lambda \\mathbf{D}$ 组成。舍去空间项后剩下算子 $c\\mathbf{I}$。预条件子 $\\mathbf{M}$ 就是这个算子本身。PCG 中的预处理步骤需要求解 $\\mathbf{M}\\mathbf{z}^{(k)} = \\mathbf{r}^{(k)}$，这变得非常简单：\n$$\n(c\\mathbf{I}) \\mathbf{z}^{(k)} = \\mathbf{r}^{(k)} \\implies \\mathbf{z}^{(k)} = \\frac{1}{c} \\mathbf{r}^{(k)}\n$$\n这是一个对残差向量的简单缩放。对于 $\\omega_p \\Delta t \\gg 1$ 的稠密等离子体状态，项 $c\\mathbf{I}$ 在 $\\mathbf{A}$ 中占主导地位，使其成为强对角占优矩阵。这表明该预条件子应该非常有效。我们将使用此预条件子运行 PCG 算法，并计算迭代次数 $k_{\\text{pre}}$。\n\n该实现将包含两个函数，一个用于 CG，一个用于 PCG。它们不会显式地构造矩阵 $\\mathbf{A}$，而是使用一个函数来计算矩阵向量乘积 $\\mathbf{A}\\mathbf{p}$，这对于像 $\\mathbf{A}$ 这样的稀疏/结构化矩阵更高效。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified linear systems using Conjugate Gradient methods\n    and outputs the number of iterations for each test case.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (general dense plasma, moderate spatial coupling)\n        (128, 100.0, 10.0, 1.0, 1),\n        # Case 2 (very dense plasma, moderate spatial coupling)\n        (128, 1000.0, 20.0, 1.0, 3),\n        # Case 3 (no spatial coupling, purely local response)\n        (128, 100.0, 10.0, 0.0, 5),\n        # Case 4 (dense plasma, strong spatial coupling and higher resolution)\n        (256, 300.0, 15.0, 50.0, 2),\n    ]\n\n    results = []\n    \n    # Tolerance for stopping criterion\n    tol = 1e-8\n\n    for case in test_cases:\n        N, omega_p, dt, lam, m = case\n        \n        # Calculate the constant for the identity matrix part of the operator\n        c = omega_p**2 * dt**2\n\n        # Construct the right-hand side vector b\n        x_grid = np.arange(N) / N\n        b = np.sin(2 * np.pi * m * x_grid)\n\n        # Define the matrix-vector product function for A*p\n        # A*p = (c*I - lam*D)*p, where Dp_i = p_{i+1} - 2p_i + p_{i-1}\n        # (A*p)_i = c*p_i - lam*(p_{i+1} - 2p_i + p_{i-1})\n        #         = (c + 2*lam)*p_i - lam*(p_{i+1} + p_{i-1})\n        def matvec(p):\n            return (c + 2 * lam) * p - lam * (np.roll(p, -1) + np.roll(p, 1))\n\n        # --- Unpreconditioned Conjugate Gradient ---\n        def cg(A_matvec, b_vec):\n            x = np.zeros_like(b_vec)\n            r = b_vec.copy()\n            p = r.copy()\n            \n            rs_old = np.dot(r, r)\n            r_norm_0 = np.sqrt(rs_old)\n            if r_norm_0 == 0:\n                return 0\n\n            max_iter = N\n            for k in range(1, max_iter + 1):\n                Ap = A_matvec(p)\n                alpha = rs_old / np.dot(p, Ap)\n                x += alpha * p\n                r -= alpha * Ap\n                \n                rs_new = np.dot(r, r)\n                \n                if np.sqrt(rs_new) / r_norm_0 = tol:\n                    return k\n                \n                p = r + (rs_new / rs_old) * p\n                rs_old = rs_new\n            return max_iter\n\n        k_no = cg(matvec, b)\n\n        # --- Preconditioned Conjugate Gradient ---\n        # The preconditioning step z = M_inv * r, where M = c*I\n        def precond_inv(r_vec):\n            # If c is zero, the operator is singular and M is not invertible.\n            # Based on problem constraints, c will be large.\n            return (1/c) * r_vec\n\n        def pcg(A_matvec, b_vec, P_inv_vec):\n            x = np.zeros_like(b_vec)\n            r = b_vec.copy()\n            \n            r_norm_0 = np.linalg.norm(r)\n            if r_norm_0 == 0:\n                return 0\n            \n            z = P_inv_vec(r)\n            p = z.copy()\n            rz_old = np.dot(r, z)\n            \n            max_iter = N\n            for k in range(1, max_iter + 1):\n                Ap = A_matvec(p)\n                alpha = rz_old / np.dot(p, Ap)\n                x += alpha * p\n                r -= alpha * Ap\n                \n                if np.linalg.norm(r) / r_norm_0 = tol:\n                    return k\n\n                z = P_inv_vec(r)\n                rz_new = np.dot(r, z)\n                \n                p = z + (rz_new / rz_old) * p\n                rz_old = rz_new\n            return max_iter\n\n        k_pre = pcg(matvec, b, precond_inv)\n        \n        results.append(f\"[{k_no},{k_pre}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3529066"}]}