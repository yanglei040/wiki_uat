{"hands_on_practices": [{"introduction": "有限元分析的准确性不仅取决于网格密度，也取决于单个单元的形状质量。此练习将引导你动手推导，量化几何畸变（特别是剪切变形）如何引入数值积分误差，从而深入理解单元的等参映射、雅可比行列式及其对计算结果的影响。这是一个理解网格质量控制准则的基础性概念。", "problem": "考虑一个在计算岩土力学中用于有限元法 (FEM) 的八节点一阶三线性六面体单元 (Q1)。设母 (参考) 域为立方体 $\\{(\\xi,\\eta,\\zeta)\\,|\\,\\xi,\\eta,\\zeta\\in[-1,1]\\}$。通过如下规定节点物理坐标来定义到物理坐标 $(x,y,z)$ 的等参映射。对于每个母坐标为 $(\\xi_i,\\eta_i,\\zeta_i)\\in\\{\\pm 1\\}^{3}$ 的节点，指定\n$$\nx_i \\;=\\; L\\,\\xi_i \\;+\\; \\varepsilon\\,L\\,\\xi_i\\,\\eta_i,\\qquad\ny_i \\;=\\; L\\,\\eta_i,\\qquad\nz_i \\;=\\; L\\,\\zeta_i,\n$$\n其中 $L0$ 是一个长度尺度，$\\varepsilon$ 是一个小的无量纲偏斜参数，满足 $|\\varepsilon|\\ll 1$。使用标准三线性形函数的等参插值随之导出一个三线性映射 $(\\xi,\\eta,\\zeta)\\mapsto(x(\\xi,\\eta,\\zeta),y(\\xi,\\eta,\\zeta),z(\\xi,\\eta,\\zeta))$ 及其雅可比矩阵 $\\mathbf{J}(\\xi,\\eta,\\zeta)=\\partial(x,y,z)/\\partial(\\xi,\\eta,\\zeta)$ 和行列式 $\\det \\mathbf{J}(\\xi,\\eta,\\zeta)$。\n\n设物理空间中的标量应力场为多项式\n$$\n\\sigma(x,y,z)\\;=\\;\\beta\\,y,\n$$\n其中 $\\beta$ 是一个常数。考虑应力在物理单元上的单元体积积分，\n$$\nI \\;=\\; \\int_{\\Omega_e} \\sigma(x,y,z)\\,\\mathrm{d}\\Omega \\;=\\; \\int_{-1}^{1}\\int_{-1}^{1}\\int_{-1}^{1} \\sigma\\!\\bigl(x(\\xi,\\eta,\\zeta),y(\\xi,\\eta,\\zeta),z(\\xi,\\eta,\\zeta)\\bigr)\\,\\det\\mathbf{J}(\\xi,\\eta,\\zeta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta,\n$$\n并用母空间中的单点高斯积分法则对其进行近似，\n$$\nI_G \\;=\\; 8\\,\\sigma\\!\\bigl(x(0,0,0),y(0,0,0),z(0,0,0)\\bigr)\\,\\det\\mathbf{J}(0,0,0).\n$$\n\n仅从等参映射的定义、雅可比行列式和体积积分的变量替换公式以及单点高斯积分法则出发，通过显式分析由给定偏斜引起的 $\\det\\mathbf{J}$ 在整个单元上的变化，推导出一阶 (关于 $\\varepsilon$) 绝对积分误差\n$$\nE \\;=\\; I - I_G,\n$$\n假设 $|\\varepsilon|\\ll 1$ 并忽略 $\\varepsilon^{2}$ 及更高阶的项。将您的最终结果表示为以 $\\beta$、$L$ 和 $\\varepsilon$ 表示的闭式解析表达式。最终表达式中不要包含单位。不需要进行数值舍入。", "solution": "本题旨在确定使用单点高斯求积法则近似计算一个特定偏斜六面体有限元上线性应力场的体积积分时的一阶积分误差。求解过程首先推导等参坐标映射，然后计算该映射的雅可比行列式，最后计算精确积分和近似积分以求得它们的差值。\n\n首先，我们建立从母坐标 $(\\xi, \\eta, \\zeta) \\in [-1, 1]^3$ 到物理坐标 $(x, y, z)$ 的等参映射。该映射由标准三线性形函数 $N_i(\\xi, \\eta, \\zeta)$ 和给定的节点坐标 $(x_i, y_i, z_i)$ 定义。物理坐标由下式给出：\n$$x(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_i(\\xi, \\eta, \\zeta) x_i$$\n$$y(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_i(\\xi, \\eta, \\zeta) y_i$$\n$$z(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_i(\\xi, \\eta, \\zeta) z_i$$\n节点坐标规定为 $x_i = L\\,\\xi_i + \\varepsilon\\,L\\,\\xi_i\\,\\eta_i$，$y_i = L\\,\\eta_i$ 和 $z_i = L\\,\\zeta_i$，其中 $(\\xi_i, \\eta_i, \\zeta_i)$ 是节点 $i$ 的母坐标。\n\n由于三线性插值的性质，如果函数 $f$ 是 $1, \\xi, \\eta, \\zeta, \\xi\\eta, \\eta\\zeta, \\zeta\\xi, \\xi\\eta\\zeta$ 等项的线性组合，则形式为 $\\sum_{i=1}^{8} N_i(\\xi, \\eta, \\zeta) f(\\xi_i, \\eta_i, \\zeta_i)$ 的表达式能精确插值函数 $f$。节点坐标的定义属于此类。\n对于 $y$ 和 $z$ 坐标，我们有：\n$$y(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_i(\\xi, \\eta, \\zeta) (L\\,\\eta_i) = L \\left(\\sum_{i=1}^{8} N_i \\eta_i\\right) = L\\,\\eta$$\n$$z(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_i(\\xi, \\eta, \\zeta) (L\\,\\zeta_i) = L \\left(\\sum_{i=1}^{8} N_i \\zeta_i\\right) = L\\,\\zeta$$\n对于 $x$ 坐标，映射为：\n$$x(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_i (L\\,\\xi_i + \\varepsilon L\\,\\xi_i\\eta_i) = L \\left(\\sum_{i=1}^{8} N_i \\xi_i\\right) + \\varepsilon L \\left(\\sum_{i=1}^{8} N_i \\xi_i\\eta_i\\right) = L\\xi + \\varepsilon L\\xi\\eta$$\n因此，完整的坐标映射为：\n$$x(\\xi, \\eta, \\zeta) = L(\\xi + \\varepsilon\\xi\\eta)$$\n$$y(\\xi, \\eta, \\zeta) = L\\eta$$\n$$z(\\xi, \\eta, \\zeta) = L\\zeta$$\n\n接下来，我们计算雅可比矩阵 $\\mathbf{J} = \\frac{\\partial(x,y,z)}{\\partial(\\xi,\\eta,\\zeta)}$。其分量是物理坐标对母坐标的偏导数：\n$$J_{11} = \\frac{\\partial x}{\\partial \\xi} = L(1 + \\varepsilon\\eta), \\quad J_{12} = \\frac{\\partial x}{\\partial \\eta} = L\\varepsilon\\xi, \\quad J_{13} = \\frac{\\partial x}{\\partial \\zeta} = 0$$\n$$J_{21} = \\frac{\\partial y}{\\partial \\xi} = 0, \\quad J_{22} = \\frac{\\partial y}{\\partial \\eta} = L, \\quad J_{23} = \\frac{\\partial y}{\\partial \\zeta} = 0$$\n$$J_{31} = \\frac{\\partial z}{\\partial \\xi} = 0, \\quad J_{32} = \\frac{\\partial z}{\\partial \\eta} = 0, \\quad J_{33} = \\frac{\\partial z}{\\partial \\zeta} = L$$\n雅可比矩阵为：\n$$\\mathbf{J}(\\xi, \\eta, \\zeta) = \\begin{pmatrix} L(1 + \\varepsilon\\eta)  L\\varepsilon\\xi  0 \\\\ 0  L  0 \\\\ 0  0  L \\end{pmatrix}$$\n雅可比矩阵的行列式 $\\det\\mathbf{J}$ 为：\n$$\\det\\mathbf{J}(\\xi, \\eta, \\zeta) = L(1 + \\varepsilon\\eta) \\cdot (L \\cdot L - 0 \\cdot 0) - L\\varepsilon\\xi \\cdot (0 \\cdot L - 0 \\cdot 0) = L^3(1 + \\varepsilon\\eta)$$\n\n现在，我们可以计算精确积分 $I$。应力场为 $\\sigma(x, y, z) = \\beta y$。在母坐标中，这变为 $\\sigma = \\beta y(\\xi, \\eta, \\zeta) = \\beta L\\eta$。被积函数为 $\\sigma \\det\\mathbf{J}$：\n$$\\sigma \\det\\mathbf{J} = (\\beta L\\eta) \\cdot (L^3(1 + \\varepsilon\\eta)) = \\beta L^4 (\\eta + \\varepsilon\\eta^2)$$\n精确积分 $I$ 为：\n$$I = \\int_{-1}^{1}\\int_{-1}^{1}\\int_{-1}^{1} \\beta L^4 (\\eta + \\varepsilon\\eta^2) \\, \\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$$\n我们可以分离积分：\n$$I = \\beta L^4 \\left(\\int_{-1}^{1} \\mathrm{d}\\xi\\right) \\left(\\int_{-1}^{1} \\mathrm{d}\\zeta\\right) \\left(\\int_{-1}^{1} (\\eta + \\varepsilon\\eta^2) \\, \\mathrm{d}\\eta\\right)$$\n关于 $\\xi$ 和 $\\zeta$ 的积分为 $\\int_{-1}^{1} \\mathrm{d}\\xi = 2$ 和 $\\int_{-1}^{1} \\mathrm{d}\\zeta = 2$。\n关于 $\\eta$ 的积分为：\n$$\\int_{-1}^{1} (\\eta + \\varepsilon\\eta^2) \\, \\mathrm{d}\\eta = \\left[ \\frac{\\eta^2}{2} + \\varepsilon\\frac{\\eta^3}{3} \\right]_{-1}^{1} = \\left(\\frac{1}{2} + \\frac{\\varepsilon}{3}\\right) - \\left(\\frac{(-1)^2}{2} + \\varepsilon\\frac{(-1)^3}{3}\\right) = \\left(\\frac{1}{2} + \\frac{\\varepsilon}{3}\\right) - \\left(\\frac{1}{2} - \\frac{\\varepsilon}{3}\\right) = \\frac{2\\varepsilon}{3}$$\n将这些结果代回 $I$ 的表达式中：\n$$I = \\beta L^4 \\cdot (2) \\cdot (2) \\cdot \\left(\\frac{2\\varepsilon}{3}\\right) = \\frac{8}{3}\\beta L^4 \\varepsilon$$\n\n接下来，我们使用单点高斯积分法则计算近似积分 $I_G$。该法则在母域中心 $(\\xi, \\eta, \\zeta)=(0, 0, 0)$ 处计算被积函数的值，并乘以该域的体积，即 $8$。\n$$I_G = 8\\,\\sigma\\bigl(x(0,0,0),y(0,0,0),z(0,0,0)\\bigr)\\,\\det\\mathbf{J}(0,0,0)$$\n首先，计算在 $(\\xi, \\eta, \\zeta)=(0, 0, 0)$ 处的值：\n$$y(0,0,0) = L \\cdot 0 = 0$$\n因此，单元中心的应力为：\n$$\\sigma\\bigl(x(0,0,0),y(0,0,0),z(0,0,0)\\bigr) = \\beta \\cdot y(0,0,0) = 0$$\n中心的雅可比行列式为：\n$$\\det\\mathbf{J}(0,0,0) = L^3(1 + \\varepsilon \\cdot 0) = L^3$$\n将这些值代入 $I_G$ 的公式中：\n$$I_G = 8 \\cdot (0) \\cdot (L^3) = 0$$\n\n最后，积分误差 $E$ 是差值 $I - I_G$。\n$$E = I - I_G = \\frac{8}{3}\\beta L^4 \\varepsilon - 0 = \\frac{8}{3}\\beta L^4 \\varepsilon$$\n该表达式在 $\\varepsilon$ 上是线性的，因此它代表了一阶误差，没有出现或需要忽略 $\\varepsilon^2$ 或更高阶的项。", "answer": "$$\\boxed{\\frac{8}{3}\\beta L^4 \\varepsilon}$$", "id": "3567421"}, {"introduction": "在应力分析中，使用正确的本构模型至关重要。本练习探讨了一个常见的陷阱：在三维六面体单元中错误地应用简化的二维平面应变假说。通过对比正确的 $3$D 公式与错误方法计算出的应力，你将对三维空间中所有应变和应力分量之间的耦合效应有一个更深刻的定量理解。", "problem": "在小应变假设下，使用单个八节点三线性六面体单元在三维有限元法（FEM）分析中对一小块土壤样本进行建模。材料为各向同性线弹性固体，其杨氏模量 $E = 30$ MPa，泊松比 $\\nu = 0.3$。在单元形心处，测得的工程应变向量（Voigt 顺序，使用工程剪应变）为\n$[\\varepsilon_{xx},\\, \\varepsilon_{yy},\\, \\varepsilon_{zz},\\, \\gamma_{yz},\\, \\gamma_{zx},\\, \\gamma_{xy}]^{\\mathsf{T}} = [1.0\\times 10^{-3},\\, 5.0\\times 10^{-4},\\, -2.0\\times 10^{-4},\\, 4.0\\times 10^{-4},\\, -1.0\\times 10^{-4},\\, 3.0\\times 10^{-4}]^{\\mathsf{T}}$。\n\n假设小变形，并使用三维各向同性线弹性应力-应变本构关系计算形心处的应力向量 $[\\sigma_{xx},\\, \\sigma_{yy},\\, \\sigma_{zz},\\, \\tau_{yz},\\, \\tau_{zx},\\, \\tau_{xy}]^{\\mathsf{T}}$。现在，假设一位经验不足的分析师在组装三维六面体单元时，错误地为法向分量选择了二维平面应变本构矩阵，具体操作如下：\n- 他们根据平面内应变计算 $\\sigma_{xx}$ 和 $\\sigma_{yy}$，如同 $\\varepsilon_{zz} = 0$ 一样（因此忽略了 $\\varepsilon_{zz}$ 对 $\\sigma_{xx}$ 和 $\\sigma_{yy}$ 的耦合影响），\n- 他们将 $\\sigma_{zz}$ 设为 0，\n- 他们使用三维剪切模量计算所有三个剪切分量，即 $\\tau_{ij} = G\\,\\gamma_{ij}$。\n\n下列哪个陈述最能从定性和定量上描述这种不恰当的本构选择对形心处计算应力的影响？\n\nA. 错误计算的 $\\sigma_{xx}$ 和 $\\sigma_{yy}$ 均比正确的三维值高出 $-\\lambda\\,\\varepsilon_{zz}$，而 $\\sigma_{zz}$ 被错误地设为零；剪切分量不变。对于给定数据，法向应力误差为 $\\Delta \\sigma_{xx} = \\Delta \\sigma_{yy} = 3.461538462\\times 10^{-3}$ MPa，且错误的平面外法向应力为 $\\sigma_{zz}^{\\text{wrong}} = 0$ MPa。\n\nB. 错误计算的 $\\sigma_{xx}$ 等于正确的三维 $\\sigma_{xx}$ 值，但 $\\sigma_{yy}$ 比正确的三维 $\\sigma_{yy}$ 值低 $\\lambda\\,\\varepsilon_{zz}$；$\\sigma_{zz}$ 的计算仍然正确。\n\nC. 剪应力也受到影响：错误计算的 $\\tau_{xy}$ 恰好是正确三维值的两倍，而 $\\tau_{yz}$ 和 $\\tau_{zx}$ 保持正确。\n\nD. 使用平面应变本构矩阵不会改变平均（静水）应力 $p = (\\sigma_{xx} + \\sigma_{yy} + \\sigma_{zz})/3$ 的值，即使当 $\\varepsilon_{zz} \\neq 0$ 时也是如此，因此应力张量的迹得以保留。", "solution": "### 推导与分析\n\n问题的核心是比较使用正确的3D各向同性线弹性定律计算的应力向量与使用分析师的错误步骤计算的应力向量。\n\n**1. 材料常数**\n\n首先，我们根据给定的杨氏模量 $E = 30$ MPa 和泊松比 $\\nu = 0.3$ 计算必要的弹性常数。\n\n剪切模量 $G$ 为：\n$$ G = \\frac{E}{2(1+\\nu)} = \\frac{30 \\text{ MPa}}{2(1+0.3)} = \\frac{30}{2.6} \\text{ MPa} \\approx 11.53846 \\text{ MPa} $$\n\nLamé第一参数 $\\lambda$ 为：\n$$ \\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)} = \\frac{(30 \\text{ MPa})(0.3)}{(1+0.3)(1 - 2(0.3))} = \\frac{9}{1.3 \\times 0.4} = \\frac{9}{0.52} \\text{ MPa} \\approx 17.30769 \\text{ MPa} $$\n\n**2. 正确的应力计算（3D弹性力学）**\n\n对于3D各向同性线弹性材料，其应力-应变关系可以用 $\\lambda$ 和 $G$ 写成：\n$$ \\sigma_{ij} = \\lambda \\delta_{ij} \\varepsilon_v + 2G \\varepsilon_{ij} $$\n其中 $\\varepsilon_v = \\varepsilon_{kk} = \\varepsilon_{xx} + \\varepsilon_{yy} + \\varepsilon_{zz}$ 是体积应变，$\\delta_{ij}$ 是克罗内克符号，$\\varepsilon_{ij}$ 是张量应变的分量。用工程应变表示，应力分量的方程为：\n\n$$ \\sigma_{xx}^{\\text{corr}} = \\lambda \\varepsilon_v + 2G \\varepsilon_{xx} $$\n$$ \\sigma_{yy}^{\\text{corr}} = \\lambda \\varepsilon_v + 2G \\varepsilon_{yy} $$\n$$ \\sigma_{zz}^{\\text{corr}} = \\lambda \\varepsilon_v + 2G \\varepsilon_{zz} $$\n$$ \\tau_{yz}^{\\text{corr}} = G \\gamma_{yz} $$\n$$ \\tau_{zx}^{\\text{corr}} = G \\gamma_{zx} $$\n$$ \\tau_{xy}^{\\text{corr}} = G \\gamma_{xy} $$\n\n首先，我们根据给定数据计算体积应变：\n$$ \\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy} + \\varepsilon_{zz} = (1.0\\times 10^{-3}) + (5.0\\times 10^{-4}) + (-2.0\\times 10^{-4}) = (10 \\times 10^{-4}) + (5 \\times 10^{-4}) - (2 \\times 10^{-4}) = 13.0\\times 10^{-4} $$\n\n现在，我们计算正确的应力分量：\n$$ \\sigma_{xx}^{\\text{corr}} = (17.30769 \\text{ MPa})(13.0\\times 10^{-4}) + 2(11.53846 \\text{ MPa})(1.0\\times 10^{-3}) = 0.022500 + 0.023077 = 0.045577 \\text{ MPa} $$\n$$ \\sigma_{yy}^{\\text{corr}} = (17.30769 \\text{ MPa})(13.0\\times 10^{-4}) + 2(11.53846 \\text{ MPa})(5.0\\times 10^{-4}) = 0.022500 + 0.011538 = 0.034038 \\text{ MPa} $$\n$$ \\sigma_{zz}^{\\text{corr}} = (17.30769 \\text{ MPa})(13.0\\times 10^{-4}) + 2(11.53846 \\text{ MPa})(-2.0\\times 10^{-4}) = 0.022500 - 0.004615 = 0.017885 \\text{ MPa} $$\n$$ \\tau_{yz}^{\\text{corr}} = (11.53846 \\text{ MPa})(4.0\\times 10^{-4}) = 0.004615 \\text{ MPa} $$\n$$ \\tau_{zx}^{\\text{corr}} = (11.53846 \\text{ MPa})(-1.0\\times 10^{-4}) = -0.001154 \\text{ MPa} $$\n$$ \\tau_{xy}^{\\text{corr}} = (11.53846 \\text{ MPa})(3.0\\times 10^{-4}) = 0.003462 \\text{ MPa} $$\n\n**3. 错误的应力计算（分析师的方法）**\n\n分析师的步骤如下：\n1.  **平面内法向应力：** 使用二维平面应变本构关系，该关系在 $\\varepsilon_{zz}=0$ 的假设下将平面内应力与平面内应变联系起来。方程为：\n    $$ \\sigma_{xx} = (\\lambda+2G)\\varepsilon_{xx} + \\lambda\\varepsilon_{yy} $$\n    $$ \\sigma_{yy} = \\lambda\\varepsilon_{xx} + (\\lambda+2G)\\varepsilon_{yy} $$\n    分析师将这些方程应用于给定的 $\\varepsilon_{xx}$ 和 $\\varepsilon_{yy}$ 值。\n    $$ \\lambda+2G = 17.30769 + 2(11.53846) = 40.38461 \\text{ MPa} $$\n    $$ \\sigma_{xx}^{\\text{wrong}} = (40.38461)(1.0\\times 10^{-3}) + (17.30769)(5.0\\times 10^{-4}) = 0.040385 + 0.008654 = 0.049039 \\text{ MPa} $$\n    $$ \\sigma_{yy}^{\\text{wrong}} = (17.30769)(1.0\\times 10^{-3}) + (40.38461)(5.0\\times 10^{-4}) = 0.017308 + 0.020192 = 0.037500 \\text{ MPa} $$\n\n2.  **平面外法向应力：** 将其设为零。\n    $$ \\sigma_{zz}^{\\text{wrong}} = 0 \\text{ MPa} $$\n\n3.  **剪应力：** 使用3D剪切模量计算所有三个剪切分量。\n    $$ \\tau_{yz}^{\\text{wrong}} = G \\gamma_{yz} = (11.53846 \\text{ MPa})(4.0\\times 10^{-4}) = 0.004615 \\text{ MPa} $$\n    $$ \\tau_{zx}^{\\text{wrong}} = G \\gamma_{zx} = (11.53846 \\text{ MPa})(-1.0\\times 10^{-4}) = -0.001154 \\text{ MPa} $$\n    $$ \\tau_{xy}^{\\text{wrong}} = G \\gamma_{xy} = (11.53846 \\text{ MPa})(3.0\\times 10^{-4}) = 0.003462 \\text{ MPa} $$\n\n**4. 比较与误差分析**\n\n让我们比较正确和错误的应力向量。\n\n-   **剪应力：** 分析师计算剪应力（$\\tau_{ij} = G\\gamma_{ij}$）的步骤与正确的3D公式相同。因此，所有剪应力分量都被正确计算：$\\tau_{ij}^{\\text{wrong}} = \\tau_{ij}^{\\text{corr}}$。\n\n-   **法向应力：**\n    -   让我们用代数方法找出 $\\sigma_{xx}$ 和 $\\sigma_{yy}$ 的误差。\n    $\\sigma_{xx}$ 的正确表达式可以重写为：\n    $$ \\sigma_{xx}^{\\text{corr}} = \\lambda(\\varepsilon_{xx}+\\varepsilon_{yy}+\\varepsilon_{zz}) + 2G\\varepsilon_{xx} = (\\lambda+2G)\\varepsilon_{xx} + \\lambda\\varepsilon_{yy} + \\lambda\\varepsilon_{zz} $$\n    错误的表达式为：\n    $$ \\sigma_{xx}^{\\text{wrong}} = (\\lambda+2G)\\varepsilon_{xx} + \\lambda\\varepsilon_{yy} $$\n    因此，误差 $\\Delta\\sigma_{xx} = \\sigma_{xx}^{\\text{wrong}} - \\sigma_{xx}^{\\text{corr}}$ 为：\n    $$ \\Delta\\sigma_{xx} = [(\\lambda+2G)\\varepsilon_{xx} + \\lambda\\varepsilon_{yy}] - [(\\lambda+2G)\\varepsilon_{xx} + \\lambda\\varepsilon_{yy} + \\lambda\\varepsilon_{zz}] = -\\lambda\\varepsilon_{zz} $$\n    同样，对于 $\\sigma_{yy}$：\n    $$ \\sigma_{yy}^{\\text{corr}} = \\lambda\\varepsilon_{xx} + (\\lambda+2G)\\varepsilon_{yy} + \\lambda\\varepsilon_{zz} $$\n    $$ \\sigma_{yy}^{\\text{wrong}} = \\lambda\\varepsilon_{xx} + (\\lambda+2G)\\varepsilon_{yy} $$\n    误差 $\\Delta\\sigma_{yy} = \\sigma_{yy}^{\\text{wrong}} - \\sigma_{yy}^{\\text{corr}}$ 为：\n    $$ \\Delta\\sigma_{yy} = -\\lambda\\varepsilon_{zz} $$\n    两个平面内法向应力的误差是相同的，都等于 $-\\lambda\\varepsilon_{zz}$。\n\n    -   让我们计算这个误差的数值：\n    $$ \\text{误差} = -\\lambda\\varepsilon_{zz} = -(17.30769 \\text{ MPa})(-2.0\\times 10^{-4}) = 3.461538\\times 10^{-3} \\text{ MPa} $$\n    这个正误差意味着错误计算的应力比正确的值要 *高*。\n    让我们用完整的计算来核对这一点：\n    $\\Delta\\sigma_{xx} = 0.049039 - 0.045577 = 0.003462 \\approx 3.46 \\times 10^{-3}$ MPa。\n    $\\Delta\\sigma_{yy} = 0.037500 - 0.034038 = 0.003462 \\approx 3.46 \\times 10^{-3}$ MPa。\n    数值结果证实了代数推导。\n\n    -   对于平面外法向应力，误差为：\n    $$ \\Delta\\sigma_{zz} = \\sigma_{zz}^{\\text{wrong}} - \\sigma_{zz}^{\\text{corr}} = 0 - 0.017885 = -0.017885 \\text{ MPa} $$\n    分析师的方法错误地将此应力设为零。\n\n### 逐项分析选项\n\n**A. 错误计算的 $\\sigma_{xx}$ 和 $\\sigma_{yy}$ 均比正确的三维值高出 $-\\lambda\\,\\varepsilon_{zz}$，而 $\\sigma_{zz}$ 被错误地设为零；剪切分量不变。对于给定数据，法向应力误差为 $\\Delta \\sigma_{xx} = \\Delta \\sigma_{yy} = 3.461538462\\times 10^{-3}$ MPa 和错误的平面外法向应力为 $\\sigma_{zz}^{\\text{wrong}} = 0$ MPa。**\n- $\\sigma_{xx}$ 和 $\\sigma_{yy}$ 的误差确实是 $\\Delta\\sigma = \\sigma^{\\text{wrong}} - \\sigma^{\\text{corr}} = -\\lambda\\varepsilon_{zz}$。由于 $\\lambda > 0$ 且 $\\varepsilon_{zz}  0$，误差项 $-\\lambda\\varepsilon_{zz}$ 为正，意味着错误的值更高。这一点陈述正确。\n- 误差的代数形式 $-\\lambda\\varepsilon_{zz}$ 是正确的。\n- 剪切分量不变，这是正确的。\n- $\\sigma_{zz}$ 被错误地设为零，这是正确的。\n- 误差的数值 $-\\lambda\\varepsilon_{zz} = 3.461538...\\times 10^{-3}$ MPa 是正确的。\n- 错误的值 $\\sigma_{zz}^{\\text{wrong}} = 0$ MPa 是正确的。\n该陈述的每一部分都与我们的推导一致。\n**结论：正确**\n\n**B. 错误计算的 $\\sigma_{xx}$ 等于正确的三维 $\\sigma_{xx}$ 值，但 $\\sigma_{yy}$ 比正确的三维 $\\sigma_{yy}$ 值低 $\\lambda\\,\\varepsilon_{zz}$；$\\sigma_{zz}$ 的计算仍然正确。**\n- 不正确。$\\sigma_{xx}$ 不等于正确值；其误差为 $-\\lambda\\varepsilon_{zz} \\neq 0$。\n- 不正确。$\\sigma_{yy}$ 更高，而不是更低，且误差量为 $-\\lambda\\varepsilon_{zz}$，不是 $\\lambda\\varepsilon_{zz}$。\n- 不正确。$\\sigma_{zz}$ 被错误地设为 $0$。\n**结论：不正确**\n\n**C. 剪应力也受到影响：错误计算的 $\\tau_{xy}$ 恰好是正确三维值的两倍，而 $\\tau_{yz}$ 和 $\\tau_{zx}$ 保持正确。**\n- 不正确。问题陈述明确指出，所有三个剪切分量都是使用 $\\tau_{ij} = G\\gamma_{ij}$ 计算的，这是正确的3D公式。因此，所有剪应力都被正确计算且保持不变。\n**结论：不正确**\n\n**D. 使用平面应变本构矩阵不会改变平均（静水）应力 $p = (\\sigma_{xx} + \\sigma_{yy} + \\sigma_{zz})/3$ 的值，即使当 $\\varepsilon_{zz} \\neq 0$ 时也是如此，因此应力张量的迹得以保留。**\n- 让我们检查应力张量的迹，$\\text{tr}(\\sigma) = \\sigma_{xx} + \\sigma_{yy} + \\sigma_{zz}$。\n- 正确的迹：$\\text{tr}(\\sigma^{\\text{corr}}) = \\sigma_{xx}^{\\text{corr}} + \\sigma_{yy}^{\\text{corr}} + \\sigma_{zz}^{\\text{corr}}$。我们从弹性理论知道 $\\text{tr}(\\sigma) = (3\\lambda+2G)\\varepsilon_v$。根据我们的数据，$\\text{tr}(\\sigma^{\\text{corr}}) = (0.045577 + 0.034038 + 0.017885) \\text{ MPa} = 0.0975 \\text{ MPa}$。\n- 错误的迹：$\\text{tr}(\\sigma^{\\text{wrong}}) = \\sigma_{xx}^{\\text{wrong}} + \\sigma_{yy}^{\\text{wrong}} + \\sigma_{zz}^{\\text{wrong}} = (0.049039 + 0.037500 + 0) \\text{ MPa} = 0.086539 \\text{ MPa}$。\n- 由于 $0.0975 \\neq 0.086539$，迹没有被保留，平均应力也没有保持不变。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3567423"}, {"introduction": "标准低阶单元（如Q1六面体单元）在模拟近不可压缩材料时会遭受“体积锁定”问题，导致结果过于刚硬且不准确。这个高级实践将指导你推导并实现增强假设应变（EAS）方法，这是一种缓解锁定的强大技术。本练习将理论与实践相结合，展示了如何通过改进单元列式来克服其固有的数值局限性。", "problem": "您需要推导并实现一种针对三线性八节点六面体 (Q1) 砖块单元的增强假定应变 (Enhanced Assumed Strain, EAS) 公式，该公式包含体积增强模式。然后，静态凝聚增强参数，并在一个位移控制的压缩基准问题上演示体积锁定的减弱。工作应在有限元法 (FEM) 框架下，基于小应变、三维、线性弹性理论进行。\n\n从适用于计算岩土力学和低阶有限元的如下第一性原理出发：\n- 虚功原理：对于一个占据域 $\\Omega$、外法线为 $\\mathbf{n}$ 的物体，在小应变运动学和线性弹性本构响应下，其内虚功为 $\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\delta \\mathbf{u}) : \\boldsymbol{\\sigma} \\,\\mathrm{d}\\Omega$，其中 $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\tfrac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top})$。\n- 各向同性线性弹性（胡克定律）：$\\boldsymbol{\\sigma} = \\mathbb{D} \\boldsymbol{\\varepsilon}$，其中拉梅参数 $\\lambda$ 和 $\\mu$ 与杨氏模量 $E$ 及泊松比 $\\nu$ 的关系为 $\\mu = \\dfrac{E}{2(1+\\nu)}$ 和 $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$。\n- Q1 砖块单元从母空间 $(\\xi,\\eta,\\zeta)\\in[-1,1]^3$ 到物理坐标的等参映射，使用标准的八个三线性形函数。\n\n您必须：\n- 建立一个 Q1 砖块单元的公式，其基于位移的应变为 $\\boldsymbol{\\varepsilon}^{\\mathrm{std}} = \\mathbf{B}\\mathbf{u}_e$，其中 $\\mathbf{B}$ 是应变-位移矩阵，$\\mathbf{u}_e$ 是单元节点位移。\n- 引入一个增强假定应变 (EAS) 增强项，通过一个增强 $\\boldsymbol{\\varepsilon}^{\\mathrm{eas}} = \\mathbf{G}(\\xi,\\eta,\\zeta)\\,\\boldsymbol{\\alpha}$ 和一个内参数向量 $\\boldsymbol{\\alpha}$ 实现，其中 $\\mathbf{G}$ 由体积模式构成。这些模式从一个在单元边界上为零以保持单元间协调性的气泡函数构造而来。使用单个体积模式：$\\mathbf{G}(\\xi,\\eta,\\zeta) = p(\\xi,\\eta,\\zeta)\\,\\mathbf{v}$，其中 $p(\\xi,\\eta,\\zeta) = (1-\\xi^2)(1-\\eta^2)(1-\\zeta^2)$ 且 $\\mathbf{v} = [1,1,1,0,0,0]^{\\top}$。该模式注入一个内部体积应变场，同时保持边界位移不变。\n- 从虚功原理出发，推导涉及 $(\\mathbf{u}_e,\\boldsymbol{\\alpha})$ 的单元级代数系统，并对 $\\boldsymbol{\\alpha}$ 进行静态凝聚，以获得一个仅依赖于 $\\mathbf{u}_e$ 的凝聚单元刚度 $\\overline{\\mathbf{K}}_{uu}$。不得假定任何快捷公式；须从第一性原理推导。\n- 在母空间中使用 $2\\times 2\\times 2$ 个高斯点，通过张量积高斯求积法实现数值积分。\n\n用于演示体积锁定减弱的基准问题：\n- 考虑一个单位立方体域 $\\Omega = [0,1]\\times[0,1]\\times[0,1]$，该域在结构化网格上用 Q1 砖块单元进行剖分。网格是轴对齐的，且所有单元映射均为仿射映射。\n- 施加位移控制的轴向压缩：在 $z=1$ 的顶面上设置竖向位移 $u_z = -\\Delta$，在 $z=0$ 的底面上固定 $u_z = 0$。侧面无牵引力。为消除刚体模式，钉扎最少的侧向位移：在左下角前点 $(x,y,z)=(0,0,0)$ 处固定 $u_x=u_y=0$，并在 $(x,y,z)=(1,0,0)$ 处固定 $u_y=0$。\n- 使用材料参数 $(E,\\nu)$，其中 $\\nu$ 取接近 $0.5$ 的值，以模拟近不可压缩性。在均匀轴向应变 $\\varepsilon_{zz} = -\\Delta/H$（其中 $H=1$）和侧面无牵引力条件下，精确的轴向反力为 $F_{\\mathrm{exact}} = \\sigma_{zz}A = E\\,\\varepsilon_{zz}\\,A$，其中 $A$ 是横截面积 $A=1$。这个精确结果不依赖于 $\\nu$，这使其非常适合在 $\\nu\\rightarrow 0.5$ 时揭示低阶位移公式中的伪刚度（体积锁定）。\n\n要求的计算和输出：\n- 对每个测试案例，组装并求解全局系统两次：一次使用标准 Q1 公式，一次使用 EAS 凝聚公式。使用齐次外部荷载，并将位移作为本质边界条件施加。通过对顶面所有节点的 $z$ 方向节点反力求和，计算该面上的总轴向反力。\n- 所有力以牛顿表示，所有长度以米表示。角度不出现。输出浮点数。\n- 数值积分和组装必须在三维空间中进行。不允许使用外部数据或用户输入。\n\n测试套件：\n- 案例 1（理想情况）：$(E,\\nu,\\Delta,N_x,N_y,N_z) = (10^7\\,\\mathrm{Pa},\\,0.3,\\,0.01\\,\\mathrm{m},\\,1,\\,1,\\,1)$。\n- 案例 2（近不可压缩，粗网格）：$(E,\\nu,\\Delta,N_x,N_y,N_z) = (10^7\\,\\mathrm{Pa},\\,0.4999,\\,0.01\\,\\mathrm{m},\\,1,\\,1,\\,1)$。\n- 案例 3（近不可压缩，厚度方向轻微加密）：$(E,\\nu,\\Delta,N_x,N_y,N_z) = (10^7\\,\\mathrm{Pa},\\,0.4999,\\,0.01\\,\\mathrm{m},\\,1,\\,1,\\,2)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试案例的结果，形式为一个扁平的、逗号分隔的列表，并用方括号括起来，顺序为 $[F^{\\mathrm{std}}_1,F^{\\mathrm{eas}}_1,F^{\\mathrm{exact}}_1,F^{\\mathrm{std}}_2,F^{\\mathrm{eas}}_2,F^{\\mathrm{exact}}_2,F^{\\mathrm{std}}_3,F^{\\mathrm{eas}}_3,F^{\\mathrm{exact}}_3]$，其中每个 $F$ 是在顶面计算得到的对应公式的轴向反力（单位：牛顿）以及精确值。", "solution": "### 1. 理论公式\n\n该公式的根基是虚功原理。对于一个占据域 $\\Omega$ 的线性弹性体，该原理指出内虚功等于外虚功。为推导单元刚度，我们考虑在没有体力的情况下，单元对内虚功的贡献 $\\delta W_e^{\\mathrm{int}}$：\n$$\n\\delta W_e^{\\mathrm{int}} = \\int_{\\Omega_e} \\delta \\boldsymbol{\\varepsilon}^\\top \\boldsymbol{\\sigma} \\, \\mathrm{d}\\Omega = 0\n$$\n其中 $\\Omega_e$ 是单个单元的体积，$\\boldsymbol{\\sigma}$ 是柯西应力张量，$\\delta \\boldsymbol{\\varepsilon}$ 是虚应变张量。在 Voigt 记法中，这写作 $\\int_{\\Omega_e} \\delta \\boldsymbol{\\varepsilon}^\\top \\boldsymbol{\\sigma} \\, \\mathrm{d}\\Omega = 0$。\n\n本构关系是线性、各向同性弹性（胡克定律）：$\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{D}$ 是材料弹性矩阵。\n\n#### 1.1. 运动学：标准应变与增强应变\n\n在增强假定应变 (EAS) 方法中，一个单元内的总应变 $\\boldsymbol{\\varepsilon}$ 被加法分解为一个源自节点位移 $\\mathbf{u}_e$ 的标准（协调）部分 $\\boldsymbol{\\varepsilon}^{\\mathrm{std}}$，以及一个作为单元级内参数 $\\boldsymbol{\\alpha}$ 函数的增强部分 $\\boldsymbol{\\varepsilon}^{\\mathrm{eas}}$：\n$$\n\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}^{\\mathrm{std}} + \\boldsymbol{\\varepsilon}^{\\mathrm{eas}}\n$$\n标准应变通过对称梯度算子从位移场 $\\mathbf{u} = \\mathbf{N}\\mathbf{u}_e$ 获得，结果为 $\\boldsymbol{\\varepsilon}^{\\mathrm{std}} = \\mathbf{B}\\mathbf{u}_e$。这里，$\\mathbf{N}$ 包含单元形函数，$\\mathbf{B}$ 是标准应变-位移矩阵。\n\n增强应变定义为 $\\boldsymbol{\\varepsilon}^{\\mathrm{eas}} = \\mathbf{G}(\\boldsymbol{\\xi})\\boldsymbol{\\alpha}$，其中 $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ 是母坐标。矩阵 $\\mathbf{G}$ 包含增强应变模式的插值函数。至关重要的是，变分 $\\delta\\mathbf{u}_e$ 和 $\\delta\\boldsymbol{\\alpha}$ 是独立的。虚总应变为：\n$$\n\\delta\\boldsymbol{\\varepsilon} = \\mathbf{B}\\delta\\mathbf{u}_e + \\mathbf{G}\\delta\\boldsymbol{\\alpha}\n$$\n\n#### 1.2. 单元级系统的推导\n\n将应变分解和本构定律代入虚功方程可得：\n$$\n\\int_{\\Omega_e} (\\mathbf{B}\\delta\\mathbf{u}_e + \\mathbf{G}\\delta\\boldsymbol{\\alpha})^\\top \\mathbf{D} (\\mathbf{B}\\mathbf{u}_e + \\mathbf{G}\\boldsymbol{\\alpha}) \\, \\mathrm{d}\\Omega = 0\n$$\n由于此式必须对任意独立的变分 $\\delta\\mathbf{u}_e$ 和 $\\delta\\boldsymbol{\\alpha}$ 成立，我们可以将方程分为两部分：\n\n1.  平衡部分，来自 $\\delta\\mathbf{u}_e^\\top$ 的系数：\n    $$\n    \\left( \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega \\right) \\mathbf{u}_e + \\left( \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{G} \\, \\mathrm{d}\\Omega \\right) \\boldsymbol{\\alpha} = \\mathbf{f}_e\n    $$\n    其中 $\\mathbf{f}_e$ 是单元节点力向量。\n\n2.  正交条件（或一致性方程），来自 $\\delta\\boldsymbol{\\alpha}^\\top$ 的系数：\n    $$\n    \\left( \\int_{\\Omega_e} \\mathbf{G}^\\top \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega \\right) \\mathbf{u}_e + \\left( \\int_{\\Omega_e} \\mathbf{G}^\\top \\mathbf{D} \\mathbf{G} \\, \\mathrm{d}\\Omega \\right) \\boldsymbol{\\alpha} = \\mathbf{0}\n    $$\n\n这两个方程在单元级别形成一个耦合系统：\n$$\n\\begin{pmatrix} \\mathbf{K}_{uu}  \\mathbf{K}_{u\\alpha} \\\\ \\mathbf{K}_{\\alpha u}  \\mathbf{K}_{\\alpha\\alpha} \\end{pmatrix}\n\\begin{pmatrix} \\mathbf{u}_e \\\\ \\boldsymbol{\\alpha} \\end{pmatrix}\n=\n\\begin{pmatrix} \\mathbf{f}_e \\\\ \\mathbf{0} \\end{pmatrix}\n$$\n其中子矩阵定义为：\n$\\mathbf{K}_{uu} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega$ (标准刚度矩阵)\n$\\mathbf{K}_{u\\alpha} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{G} \\, \\mathrm{d}\\Omega$\n$\\mathbf{K}_{\\alpha u} = \\mathbf{K}_{u\\alpha}^\\top = \\int_{\\Omega_e} \\mathbf{G}^\\top \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega$\n$\\mathbf{K}_{\\alpha\\alpha} = \\int_{\\Omega_e} \\mathbf{G}^\\top \\mathbf{D} \\mathbf{G} \\, \\mathrm{d}\\Omega$\n\n#### 1.3. 静态凝聚\n\n由于参数 $\\boldsymbol{\\alpha}$ 是单元内部的，它们可以在全局组装前在单元级别上被消去。这个过程称为静态凝聚。从矩阵系统的第二行，我们求解 $\\boldsymbol{\\alpha}$：\n$$\n\\mathbf{K}_{\\alpha u} \\mathbf{u}_e + \\mathbf{K}_{\\alpha\\alpha} \\boldsymbol{\\alpha} = \\mathbf{0} \\implies \\boldsymbol{\\alpha} = -\\mathbf{K}_{\\alpha\\alpha}^{-1} \\mathbf{K}_{\\alpha u} \\mathbf{u}_e\n$$\n将 $\\boldsymbol{\\alpha}$ 的表达式代回到第一行，得到：\n$$\n\\mathbf{K}_{uu} \\mathbf{u}_e + \\mathbf{K}_{u\\alpha} (-\\mathbf{K}_{\\alpha\\alpha}^{-1} \\mathbf{K}_{\\alpha u} \\mathbf{u}_e) = \\mathbf{f}_e\n$$\n这可以写成一个标准刚度关系 $\\overline{\\mathbf{K}}_{uu} \\mathbf{u}_e = \\mathbf{f}_e$，其中 $\\overline{\\mathbf{K}}_{uu}$ 是凝聚（或增强）单元刚度矩阵：\n$$\n\\overline{\\mathbf{K}}_{uu} = \\mathbf{K}_{uu} - \\mathbf{K}_{u\\alpha} \\mathbf{K}_{\\alpha\\alpha}^{-1} \\mathbf{K}_{\\alpha u}\n$$\n这个凝聚矩阵将被组装到 EAS 单元的全局系统中。\n\n### 2. Q1 砖块单元的实现\n\n具体实现需要为三线性8节点六面体 (Q1) 单元定义矩阵 $\\mathbf{B}$、$\\mathbf{G}$ 和 $\\mathbf{D}$，并进行数值积分。\n\n-   **等参映射**：坐标 $\\mathbf{x} = (x,y,z)$ 通过形函数 $N_i$ 从母立方体 $(\\xi, \\eta, \\zeta) \\in [-1,1]^3$ 映射而来：$\\mathbf{x} = \\sum_{i=1}^8 N_i(\\xi, \\eta, \\zeta) \\mathbf{x}_i$。此映射的雅可比矩阵是 $\\mathbf{J} = \\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}}$。\n\n-   **应变-位移矩阵 $\\mathbf{B}$**：这个 $6 \\times 24$ 矩阵将 6 个应变分量与 24 个节点位移关联起来。对于每个节点 $i$，其贡献 $\\mathbf{B}_i$ 是一个由形函数 $N_i$ 的空间导数构成的 $6 \\times 3$ 矩阵。这些导数通过雅可比矩阵的逆求得：$\\nabla_{\\mathbf{x}} N_i = \\mathbf{J}^{-1} \\nabla_{\\boldsymbol{\\xi}} N_i$。\n\n-   **本构矩阵 $\\mathbf{D}$**：对于具有拉梅参数 $\\lambda$ 和 $\\mu$ 的三维各向同性线性弹性，针对工程应变的 $6 \\times 6$ 矩阵 $\\mathbf{D}$ 在 Voigt 记法中为：\n    $$\n    \\mathbf{D} = \\begin{pmatrix} \\lambda+2\\mu  \\lambda  \\lambda  0  0  0 \\\\ \\lambda  \\lambda+2\\mu  \\lambda  0  0  0 \\\\ \\lambda  \\lambda  \\lambda+2\\mu  0  0  0 \\\\ 0  0  0  \\mu  0  0 \\\\ 0  0  0  0  \\mu  0 \\\\ 0  0  0  0  0  \\mu \\end{pmatrix}\n    $$\n\n-   **增强矩阵 $\\mathbf{G}$**：该问题指定了一个单一的体积增强模式。这意味着 $\\boldsymbol{\\alpha}$ 是一个标量，我们记为 $\\alpha$。矩阵 $\\mathbf{G}$ 是一个 $6 \\times 1$ 的向量：\n    $$\n    \\mathbf{G}(\\xi,\\eta,\\zeta) = p(\\xi,\\eta,\\zeta)\\,\\mathbf{v}\n    $$\n    其中 $p(\\xi,\\eta,\\zeta) = (1-\\xi^2)(1-\\eta^2)(1-\\zeta^2)$ 是一个在单元边界上为零的气泡函数，而 $\\mathbf{v} = [1,1,1,0,0,0]^{\\top}$ 将增强指向体积应变分量。由于 $\\alpha$ 是一个标量，$\\mathbf{K}_{\\alpha\\alpha}$ 也是一个标量，而 $\\mathbf{K}_{u\\alpha}$ 是一个 $24 \\times 1$ 的向量。静态凝聚简化为一个秩-1 更新：\n    $$\n    \\overline{\\mathbf{K}}_{uu} = \\mathbf{K}_{uu} - \\frac{1}{K_{\\alpha\\alpha}} \\mathbf{K}_{u\\alpha} \\mathbf{K}_{u\\alpha}^\\top\n    $$\n\n-   **数值积分**：刚度子矩阵的积分使用 $2 \\times 2 \\times 2$ 张量积高斯求积法进行评估。对每个高斯点，评估矩阵 $\\mathbf{B}$ 和 $\\mathbf{G}$，并将它们的乘积，乘以材料矩阵 $\\mathbf{D}$、雅可比行列式 $\\det(\\mathbf{J})$ 和高斯点权重的加权和，累加起来形成最终的矩阵。\n\n### 3. 基准问题执行\n\n该实现在指定的压缩问题上进行测试。生成结构化网格，并通过迭代所有单元来组装全局刚度矩阵，为每个单元计算标准刚度 $\\mathbf{K}_{uu}$ 或凝聚刚度 $\\overline{\\mathbf{K}}_{uu}$，并将其映射到全局自由度 (DOF)。\n\n通过将全局方程系统划分为自由自由度和规定自由度来施加位移边界条件。求解系统 $\\mathbf{K}_{ff}\\mathbf{U}_f = -\\mathbf{K}_{fp}\\mathbf{U}_p$ 以获得未知位移 $\\mathbf{U}_f$。一旦知道了完整的位移向量 $\\mathbf{U}$，节点反力向量 $\\mathbf{R}$ 就通过 $\\mathbf{R} = \\mathbf{K}_{\\mathrm{global}} \\mathbf{U}$ 计算得出。总轴向反力是顶面（$z=1$）上所有节点的 $\\mathbf{R}$ 的 $z$ 分量之和。这个计算出的力是正值（向上的阻力），将与给定的解析公式 $F_{\\mathrm{exact}} = -E \\Delta$ 进行比较，该公式表示外部施加的力（向下，因此为负值）。", "answer": "```python\n# 完整的、可运行的 Python 3 代码位于此处。导入的库必须符合指定的执行环境。\nimport numpy as np\nfrom scipy import linalg\n\ndef get_shape_functions_and_derivs(xi, eta, zeta):\n    \"\"\"\n    为8节点六面体计算形函数及其在母坐标系下的导数。\n    \"\"\"\n    nodes_xi = np.array([-1, 1, 1, -1, -1, 1, 1, -1])\n    nodes_eta = np.array([-1, -1, 1, 1, -1, -1, 1, 1])\n    nodes_zeta = np.array([-1, -1, -1, -1, 1, 1, 1, 1])\n\n    N = 0.125 * (1 + nodes_xi * xi) * (1 + nodes_eta * eta) * (1 + nodes_zeta * zeta)\n    \n    dN_dxi = 0.125 * nodes_xi * (1 + nodes_eta * eta) * (1 + nodes_zeta * zeta)\n    dN_deta = 0.125 * nodes_eta * (1 + nodes_xi * xi) * (1 + nodes_zeta * zeta)\n    dN_dzeta = 0.125 * nodes_zeta * (1 + nodes_xi * xi) * (1 + nodes_eta * eta)\n\n    dN_dxi_eta_zeta = np.vstack([dN_dxi, dN_deta, dN_dzeta])\n    \n    return N, dN_dxi_eta_zeta\n\ndef get_constitutive_matrix(E, nu):\n    \"\"\"\n    计算三维各向同性线弹性本构矩阵D。\n    \"\"\"\n    mu = E / (2 * (1 + nu))\n    lmbda = (E * nu) / ((1 + nu) * (1 - 2 * nu))\n    \n    c1 = lmbda + 2 * mu\n    c2 = lmbda\n    c3 = mu\n    \n    D = np.array([\n        [c1, c2, c2, 0,  0,  0],\n        [c2, c1, c2, 0,  0,  0],\n        [c2, c2, c1, 0,  0,  0],\n        [0,  0,  0,  c3, 0,  0],\n        [0,  0,  0,  0,  c3, 0],\n        [0,  0,  0,  0,  0,  c3]\n    ])\n    return D\n\ndef get_element_stiffness(elem_coords, E, nu, use_eas):\n    \"\"\"\n    计算Q1单元（标准或EAS）的单元刚度矩阵。\n    \"\"\"\n    D = get_constitutive_matrix(E, nu)\n    n_nodes_per_elem = 8\n    n_dof_per_elem = n_nodes_per_elem * 3\n    \n    K_uu = np.zeros((n_dof_per_elem, n_dof_per_elem))\n    K_ua = np.zeros((n_dof_per_elem, 1)) if use_eas else None\n    K_aa = 0.0 if use_eas else None\n\n    # 2x2x2 高斯积分\n    gp_loc = 1.0 / np.sqrt(3.0)\n    gauss_points = [\n        (-gp_loc, -gp_loc, -gp_loc), ( gp_loc, -gp_loc, -gp_loc),\n        ( gp_loc,  gp_loc, -gp_loc), (-gp_loc,  gp_loc, -gp_loc),\n        (-gp_loc, -gp_loc,  gp_loc), ( gp_loc, -gp_loc,  gp_loc),\n        ( gp_loc,  gp_loc,  gp_loc), (-gp_loc,  gp_loc,  gp_loc)\n    ]\n    gauss_weight = 1.0\n    \n    for xi, eta, zeta in gauss_points:\n        _N, dN_dxi_eta_zeta = get_shape_functions_and_derivs(xi, eta, zeta)\n        \n        J = np.dot(elem_coords, dN_dxi_eta_zeta.T)\n        detJ = np.linalg.det(J)\n        J_inv = np.linalg.inv(J)\n        \n        dN_dxyz = np.dot(J_inv, dN_dxi_eta_zeta)\n\n        B = np.zeros((6, n_dof_per_elem))\n        for i in range(n_nodes_per_elem):\n            B[0, 3*i    ] = dN_dxyz[0, i]\n            B[1, 3*i + 1] = dN_dxyz[1, i]\n            B[2, 3*i + 2] = dN_dxyz[2, i]\n            B[3, 3*i    ] = dN_dxyz[1, i]; B[3, 3*i + 1] = dN_dxyz[0, i]\n            B[4, 3*i + 1] = dN_dxyz[2, i]; B[4, 3*i + 2] = dN_dxyz[1, i]\n            B[5, 3*i    ] = dN_dxyz[2, i]; B[5, 3*i + 2] = dN_dxyz[0, i]\n\n        dV = detJ * gauss_weight * gauss_weight * gauss_weight\n        \n        K_uu += B.T @ D @ B * dV\n        \n        if use_eas:\n            p = (1 - xi**2) * (1 - eta**2) * (1 - zeta**2)\n            v = np.array([1, 1, 1, 0, 0, 0]).reshape(-1, 1)\n            G = p * v\n            \n            K_ua += B.T @ D @ G * dV\n            K_aa += (G.T @ D @ G * dV).item()\n\n    if use_eas:\n        if np.abs(K_aa) > 1e-15:\n            Ke = K_uu - (K_ua @ K_ua.T) / K_aa\n        else:\n            Ke = K_uu # 如果 K_aa 为零则回退\n    else:\n        Ke = K_uu\n        \n    return Ke\n\ndef run_analysis(E, nu, Delta, Nx, Ny, Nz, use_eas):\n    \"\"\"\n    针对一个配置的主分析驱动程序。\n    \"\"\"\n    # 1. 生成网格\n    L, W, H = 1.0, 1.0, 1.0\n    \n    x = np.linspace(0, L, Nx + 1)\n    y = np.linspace(0, W, Ny + 1)\n    z = np.linspace(0, H, Nz + 1)\n    \n    nodes = []\n    node_map = {}\n    node_idx = 0\n    for k in range(Nz + 1):\n        for j in range(Ny + 1):\n            for i in range(Nx + 1):\n                nodes.append([x[i], y[j], z[k]])\n                node_map[(i, j, k)] = node_idx\n                node_idx += 1\n    nodes = np.array(nodes)\n    n_nodes = len(nodes)\n    n_dofs = n_nodes * 3\n\n    elements = []\n    for k in range(Nz):\n        for j in range(Ny):\n            for i in range(Nx):\n                n1 = node_map[(i,   j,   k)]\n                n2 = node_map[(i+1, j,   k)]\n                n3 = node_map[(i+1, j+1, k)]\n                n4 = node_map[(i,   j+1, k)]\n                n5 = node_map[(i,   j,   k+1)]\n                n6 = node_map[(i+1, j,   k+1)]\n                n7 = node_map[(i+1, j+1, k+1)]\n                n8 = node_map[(i,   j+1, k+1)]\n                elements.append([n1, n2, n3, n4, n5, n6, n7, n8])\n\n    # 2. 组装全局刚度矩阵\n    K_global = np.zeros((n_dofs, n_dofs))\n    for elem_nodes_indices in elements:\n        elem_coords = nodes[elem_nodes_indices].T\n        Ke = get_element_stiffness(elem_coords, E, nu, use_eas)\n        \n        dof_indices = []\n        for node_idx in elem_nodes_indices:\n            dof_indices.extend([3 * node_idx, 3 * node_idx + 1, 3 * node_idx + 2])\n        \n        ix = np.ix_(dof_indices, dof_indices)\n        K_global[ix] += Ke\n\n    # 3. 施加边界条件\n    prescribed_dofs = {}\n    top_face_dofs_z = []\n\n    for idx, node in enumerate(nodes):\n        # Bottom face z=0\n        if np.isclose(node[2], 0.0):\n            prescribed_dofs[3 * idx + 2] = 0.0\n        # Top face z=1\n        if np.isclose(node[2], 1.0):\n            prescribed_dofs[3 * idx + 2] = -Delta\n            top_face_dofs_z.append(3 * idx + 2)\n        # Pinning at (0,0,0)\n        if np.isclose(node[0], 0.0) and np.isclose(node[1], 0.0) and np.isclose(node[2], 0.0):\n            prescribed_dofs[3 * idx] = 0.0\n            prescribed_dofs[3 * idx + 1] = 0.0\n        # Pinning at (1,0,0)\n        if np.isclose(node[0], 1.0) and np.isclose(node[1], 0.0) and np.isclose(node[2], 0.0):\n            prescribed_dofs[3 * idx + 1] = 0.0\n\n    # 4. 求解系统\n    K_original = K_global.copy()\n    \n    dof_indices = np.arange(n_dofs)\n    prescribed_indices = list(prescribed_dofs.keys())\n    free_indices = np.setdiff1d(dof_indices, prescribed_indices, assume_unique=True)\n    \n    U = np.zeros(n_dofs)\n    for dof, val in prescribed_dofs.items():\n        U[dof] = val\n\n    K_ff = K_global[np.ix_(free_indices, free_indices)]\n    K_fp = K_global[np.ix_(free_indices, prescribed_indices)]\n    U_p = U[prescribed_indices]\n\n    F_f = -K_fp @ U_p\n    \n    U_f = linalg.solve(K_ff, F_f)\n    U[free_indices] = U_f\n\n    # 5. 计算反力\n    R = K_original @ U\n    total_reaction = np.sum(R[top_face_dofs_z])\n    \n    return total_reaction\n\ndef solve():\n    \"\"\"\n    运行所有测试用例并打印结果的主函数。\n    \"\"\"\n    test_cases = [\n        (1.0e7, 0.3, 0.01, 1, 1, 1),\n        (1.0e7, 0.4999, 0.01, 1, 1, 1),\n        (1.0e7, 0.4999, 0.01, 1, 1, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, nu, Delta, Nx, Ny, Nz = case\n        \n        force_std = run_analysis(E, nu, Delta, Nx, Ny, Nz, use_eas=False)\n        force_eas = run_analysis(E, nu, Delta, Nx, Ny, Nz, use_eas=True)\n        \n        # 精确值源自问题陈述: F_exact = E * eps_zz * A,\n        # 其中 eps_zz = -Delta/H, H=1, A=1\n        force_exact = -E * Delta\n        \n        results.extend([force_std, force_eas, force_exact])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3567399"}]}