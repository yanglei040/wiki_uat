{"hands_on_practices": [{"introduction": "本次动手实践将带领我们将达西定律应用于一个核心的岩土工程问题。我们将利用一个渗透仪实验中的假设数据，来计算砂土样本的固有渗透率。这项练习不仅强化了对水力梯度、流量和介质属性之间关系的理解，还引入了一个关键步骤：使用雷诺数来验证达西流态假设的有效性。[@problem_id:3515848]", "problem": "一个刚性壁常水头渗透仪包含一个均质、各向同性、完全饱和的砂样，砂样中存在温度均匀的稳定一维水流。在大小为 $i = 0.0200$ 的受控水头梯度下，测得的体积通量（比流量）为 $q_{\\mathrm{meas}} = 3.60 \\times 10^{-6} \\ \\mathrm{m/s}$。孔隙度为 $n = 0.35$，代表性粒径为 $d_{50} = 3.50 \\times 10^{-4} \\ \\mathrm{m}$。试验温度下，水的密度为 $\\rho = 998 \\ \\mathrm{kg/m^3}$，动力黏度为 $\\mu = 1.002 \\times 10^{-3} \\ \\mathrm{Pa \\cdot s}$。取重力加速度为 $g = 9.81 \\ \\mathrm{m/s^2}$。假设流动为不可压缩流，且在连续介质尺度上惯性效应可以忽略，除非您的分析结果与此相悖。\n\n从稳定一维饱和流的质量守恒和水头的定义出发，结合通量与水头梯度之间的线性层流多孔介质本构关系，推导连接测量的体积通量、水头梯度、水力传导系数、固有渗透率、流体密度、黏度和重力加速度之间的关系。然后：\n\n1) 使用测量数据计算砂的标量固有渗透率 $k$。\n\n2) 基于测量的体积通量和代表性粒径 $d_{50}$，使用表观（Darcy）速度估算一个合适的孔隙尺度雷诺数，并根据常用的阈值判断推断的流态是否在线性 Darcy 范围内。\n\n最终数值答案仅报告标量固有渗透率 $k$。以 $\\mathrm{m^2}$ 为单位表示 $k$，并四舍五入至三位有效数字。", "solution": "该问题被评估为有效，因为它科学地基于流体在多孔介质中流动的原理，包含一套完整、一致且物理上现实的数据，并且问题提法得当，能够导出一个唯一且有意义的解。\n\n该问题要求推导流体通量、水头梯度与流体及多孔介质性质之间的关系，然后计算固有渗透率并分析流态。\n\n分析从描述的物理系统的基本原理开始。对于通过饱和多孔介质的稳定、一维、不可压缩流动，质量守恒定律规定体积通量（或称比流量）$q$ 沿流动路径保持不变。\n\n水头 $h$ 定义为高程水头 $z$ 与压力水头 $\\frac{P}{\\rho g}$ 之和：\n$$h = z + \\frac{P}{\\rho g}$$\n其中 $P$ 是流体压力，$\\rho$ 是流体密度，$g$ 是重力加速度。流动是由水头梯度驱动的。水头梯度 $i$ 定义为水头沿流动路径 $s$ 的变化率的大小。由于水流从高水头流向低水头，水头损失在流动方向上为正，因此我们有：\n$$i = -\\frac{dh}{ds}$$\n\n问题指明了通量和水头梯度之间的线性层流本构关系，即 Darcy 定律。在一维情况下，Darcy 定律指出比流量 $q$ 与水头梯度 $i$ 成正比：\n$$q = K i$$\n在此，比例常数 $K$ 是水力传导系数。该参数取决于多孔介质和流体的性质。\n\n为了分离出介质的性质，引入了固有渗透率 $k$。固有渗透率仅是多孔介质自身的属性，表征其传输流体的能力。水力传导系数 $K$ 和固有渗透率 $k$ 之间的关系由下式给出：\n$$K = \\frac{k \\rho g}{\\mu}$$\n其中 $\\mu$ 是流体的动力黏度。\n\n通过将 $K$ 的表达式代入 Darcy 定律，我们得到所要求的连接测量的体积通量 $q$、水头梯度 $i$、固有渗透率 $k$、流体密度 $\\rho$、动力黏度 $\\mu$ 和重力加速度 $g$ 之间的关系式：\n$$q = \\left( \\frac{k \\rho g}{\\mu} \\right) i$$\n\n**1) 固有渗透率 ($k$) 的计算**\n\n为了计算标量固有渗透率 $k$，我们对推导出的方程进行重排：\n$$k = \\frac{q \\mu}{i \\rho g}$$\n\n问题提供了以下数值：\n体积通量, $q = q_{\\mathrm{meas}} = 3.60 \\times 10^{-6} \\ \\mathrm{m/s}$\n水头梯度, $i = 0.0200$\n流体动力黏度, $\\mu = 1.002 \\times 10^{-3} \\ \\mathrm{Pa \\cdot s}$\n流体密度, $\\rho = 998 \\ \\mathrm{kg/m^{3}}$\n重力加速度, $g = 9.81 \\ \\mathrm{m/s^{2}}$\n\n将这些值代入 $k$ 的方程中：\n$$k = \\frac{(3.60 \\times 10^{-6}) \\cdot (1.002 \\times 10^{-3})}{0.0200 \\cdot 998 \\cdot 9.81}$$\n$$k = \\frac{3.6072 \\times 10^{-9}}{195.8076} \\ \\mathrm{m^2}$$\n$$k \\approx 1.8422 \\times 10^{-11} \\ \\mathrm{m^2}$$\n\n**2) 流态分析**\n\n为了评估流动是否属于线性 Darcy 范围，我们计算孔隙尺度的雷诺数 $Re$。问题指定使用表观（Darcy）速度 $q$ 和代表性粒径 $d_{50}$ 分别作为特征速度和特征长度。雷诺数定义为：\n$$Re = \\frac{\\rho q d}{\\mu}$$\n使用给定值：\n$q = 3.60 \\times 10^{-6} \\ \\mathrm{m/s}$\n$d = d_{50} = 3.50 \\times 10^{-4} \\ \\mathrm{m}$\n$\\rho = 998 \\ \\mathrm{kg/m^{3}}$\n$\\mu = 1.002 \\times 10^{-3} \\ \\mathrm{Pa \\cdot s}$\n\n$$Re = \\frac{998 \\cdot (3.60 \\times 10^{-6}) \\cdot (3.50 \\times 10^{-4})}{1.002 \\times 10^{-3}}$$\n$$Re = \\frac{1.25748 \\times 10^{-6}}{1.002 \\times 10^{-3}}$$\n$$Re \\approx 1.25 \\times 10^{-3}$$\n\nDarcy 定律的有效性通常被接受的雷诺数范围是小于一个临界值，该临界值通常取在 1 到 10 的范围内。由于计算出的雷诺数 $Re \\approx 1.25 \\times 10^{-3}$ 远小于 1，流动处于黏性力占主导地位且惯性效应可忽略的深度层流状态。这一结果证实了在本问题中使用 Darcy 定律的有效性，并与初始的忽略惯性效应的假设相一致。\n\n要求的最终答案是标量固有渗透率 $k$，四舍五入至三位有效数字。\n$$k = 1.84 \\times 10^{-11} \\ \\mathrm{m^2}$$", "answer": "$$\\boxed{1.84 \\times 10^{-11}}$$", "id": "3515848"}, {"introduction": "在第一个练习的基础上，我们现在将探讨当流速增加，达西定律不再适用时的情况。本次实践要求您对一组实验数据同时拟合线性的达西模型和非线性的福希海默（Forchheimer）模型。您将学习如何量化惯性效应，并确定惯性力开始变得显著的过渡流速，这对于分析粗颗粒材料中的高流速问题至关重要。[@problem_id:3515828]", "problem": "一个实验室测量了不可压缩牛顿流体在长度为 $L$、横截面积为 $A$ 的均质砾石堆积层中的稳态一维流动。测量数据包括体积流量 $Q$ 和样品两端的总压降 $\\Delta p$。假设表观速度 $v$ 由 $v = Q/A$ 给出，对于均匀样品，压力梯度为 $-\\mathrm{d}p/\\mathrm{d}x \\approx \\Delta p/L$。仅从以下两点出发：(i) 不可压缩流体的质量守恒（这在稳态条件下对于给定的横截面积意味着表观速度恒定），以及 (ii) 多孔介质流动在代表性单元体积（REV）尺度上的线性动量平衡（其可以由一个与 $v$ 呈线性的粘性阻力项和一个与 $v$ 呈二次方的惯性阻力项来建模），为压力梯度和表观速度之间的关系建立两个相互竞争的本构假设。第一个假设在足够低的 $v$ 下忽略惯性阻力。第二个假设保留粘性阻力和惯性阻力的贡献。使用这些假设：\n\n- 推导可测量对 $(\\Delta p, Q)$ 与未知参数之间的适用于回归的关系式，这些未知参数包括固有渗透率 $k$ 和量化二次阻力贡献的惯性系数 $\\beta$。\n- 给定流体密度 $\\rho$、动力粘度 $\\mu$ 和重力加速度 $g_{\\mathrm{acc}}$，计算单位为 $\\mathrm{m}^2$ 的固有渗透率 $k$ 和单位为 $\\mathrm{m/s}$ 的相应导水率 $K$，其中 $K$ 将同一多孔介质和流体的流量与水头梯度关联起来。\n- 在保留阻力的假设中，基于粘性阻力贡献和惯性阻力贡献相等，定义一个定量过渡准则，并据此计算单位为 $\\mathrm{m/s}$ 的过渡表观速度 $v_t$ 和单位为 $\\mathrm{m}^3/\\mathrm{s}$ 的过渡流量 $Q_t$。\n\n算法和数值要求：\n\n- 对于低速假设，使用每个数据集中的三个最小非零流量，执行一个约束通过原点的回归。使用普通最小二乘法（OLS）获得一个单一的斜率参数，并推断渗透率 $k$ 和导水率 $K$。\n- 对于保留阻力假设，使用所有数据点执行通过原点的OLS回归，以获得与 $v$ 中线性和二次贡献相对应的两个系数。从这些系数中，推断渗透率 $k$ 和惯性系数 $\\beta$，然后计算由线性和二次阻力贡献相等定义的过渡速度 $v_t$。报告相应的过渡流量 $Q_t = v_t A$。\n- 所有物理常数和输出必须使用指定单位。使用 $g_{\\mathrm{acc}} = 9.81\\,\\mathrm{m/s}^2$。$k$ 以 $\\mathrm{m}^2$ 表示，$K$ 以 $\\mathrm{m/s}$ 表示，$\\beta$ 以 $\\mathrm{m}^{-1}$ 表示，$v_t$ 以 $\\mathrm{m/s}$ 表示，$Q_t$ 以 $\\mathrm{m}^3/\\mathrm{s}$ 表示。将所有报告的浮点输出四舍五入到六位有效数字。\n\n测试套件和数据：\n\n所有案例均使用水，其 $\\rho = 1000\\,\\mathrm{kg/m}^3$ 且 $\\mu = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$。所有案例均使用 $g_{\\mathrm{acc}} = 9.81\\,\\mathrm{m/s}^2$。\n\n- 案例1（粗砾石，宽范围）：\n  - 几何尺寸：$L = 0.5\\,\\mathrm{m}$，$A = 0.01\\,\\mathrm{m}^2$。\n  - 流量 $Q$（单位 $\\mathrm{m}^3/\\mathrm{s}$）：$[0.0,\\; 1.0\\times 10^{-4},\\; 3.0\\times 10^{-4},\\; 6.0\\times 10^{-4},\\; 1.0\\times 10^{-3},\\; 1.5\\times 10^{-3},\\; 2.2\\times 10^{-3},\\; 3.0\\times 10^{-3}]$。\n  - 测量的 $\\Delta p$（单位 $\\mathrm{Pa}$）：$[0.0,\\; 126.0,\\; 518.0,\\; 1512.0,\\; 3488.0,\\; 7140.0,\\; 14280.0,\\; 25420.0]$。\n\n- 案例2（次粗砾石，较弱惯性）：\n  - 几何尺寸：$L = 0.5\\,\\mathrm{m}$，$A = 0.01\\,\\mathrm{m}^2$。\n  - 流量 $Q$（单位 $\\mathrm{m}^3/\\mathrm{s}$）：$[0.0,\\; 1.0\\times 10^{-4},\\; 3.0\\times 10^{-4},\\; 6.0\\times 10^{-4},\\; 1.0\\times 10^{-3},\\; 1.5\\times 10^{-3},\\; 2.2\\times 10^{-3},\\; 3.0\\times 10^{-3}]$。\n  - 测量的 $\\Delta p$（单位 $\\mathrm{Pa}$）：$[0.0,\\; 49.5,\\; 191.0,\\; 525.0,\\; 1160.0,\\; 2320.0,\\; 4540.0,\\; 7990.0]$。\n\n- 案例3（与案例1相同的粗砾石，但仅限于低流量）：\n  - 几何尺寸：$L = 0.5\\,\\mathrm{m}$，$A = 0.01\\,\\mathrm{m}^2$。\n  - 流量 $Q$（单位 $\\mathrm{m}^3/\\mathrm{s}$）：$[0.0,\\; 1.0\\times 10^{-4},\\; 2.0\\times 10^{-4},\\; 3.0\\times 10^{-4},\\; 4.0\\times 10^{-4},\\; 5.0\\times 10^{-4}]$。\n  - 测量的 $\\Delta p$（单位 $\\mathrm{Pa}$）：$[0.0,\\; 126.0,\\; 298.0,\\; 523.0,\\; 802.0,\\; 1127.0]$。\n\n每个案例的所需输出，按此确切顺序：\n\n1. 在低速假设下推断出的 $k_{\\mathrm{D}}$，单位 $\\mathrm{m}^2$。\n2. 在低速假设下推断出的 $K_{\\mathrm{D}}$，单位 $\\mathrm{m/s}$。\n3. 在保留阻力假设下推断出的 $k_{\\mathrm{F}}$，单位 $\\mathrm{m}^2$。\n4. 在保留阻力假设下推断出的 $\\beta$，单位 $\\mathrm{m}^{-1}$。\n5. 由粘性阻力和惯性阻力贡献相等定义的 $v_t$，单位 $\\mathrm{m/s}$。\n6. $Q_t$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个扁平的浮点数列表，四舍五入到六位有效数字，并用方括号括起来，其顺序为：案例1的六个输出，然后是案例2的六个输出，最后是案例3的六个输出。例如，输出格式必须与 $[r_1,\\; r_2,\\; \\dots,\\; r_{18}]$ 完全一样，无任何多余文本。", "solution": "该问题是有效的，因为它科学上基于多孔介质流体力学的原理，具有充足的数据和明确的目标，是适定的，并且没有歧义或矛盾。\n\n此分析的基础是流体流过多孔介质时在代表性单元体积（REV）尺度上的线性动量平衡。对于稳态一维流动，驱动力（即压力梯度的负值 $(-\\mathrm{d}p/\\mathrm{d}x)$）与固体基质施加在流体上的阻力相平衡。问题规定，该阻力由一个与表观速度 $v$ 呈线性的粘性分量和一个与 $v$ 呈二次方的惯性分量组成。这导出了Forchheimer方程：\n$$\n-\\frac{\\mathrm{d}p}{\\mathrm{d}x} = \\frac{\\mu}{k} v + \\rho \\beta v^2\n$$\n此处，$\\mu$ 是流体的动力粘度，$\\rho$ 是流体密度，$k$ 是多孔介质的固有渗透率，$\\beta$ 是一个非达西或惯性系数。表观速度 $v$ 通过 $v = Q/A$ 与体积流量 $Q$ 和横截面积 $A$ 相关。对于长度为 $L$ 的均质样品，压力梯度可近似为 $-\\mathrm{d}p/\\mathrm{d}x \\approx \\Delta p/L$。\n\n我们基于此方程建立两个假设。\n\n**假设1：低速（达西）流动**\n在足够低的速度下，惯性效应被认为可以忽略不计。通过去掉 $v$ 的二次项，Forchheimer方程简化为达西定律：\n$$\n-\\frac{\\mathrm{d}p}{\\mathrm{d}x} = \\frac{\\mu}{k_D} v\n$$\n下标 $D$ 表示在该假设下推断的参数。使用压力梯度和表观速度的近似值，我们得到可测量量 $\\Delta p$ 和 $Q$ 之间的关系：\n$$\n\\frac{\\Delta p}{L} = \\frac{\\mu}{k_D} \\frac{Q}{A}\n$$\n为了从实验数据中确定 $k_D$，我们将其重排为一个通过原点的线性回归模型。方便起见，我们用单位长度的压力梯度来表示，记为 $\\nabla p = \\Delta p/L$：\n$$\n\\nabla p = \\left(\\frac{\\mu}{k_D}\\right) v = C_D v\n$$\n我们使用对应于最小三个非零流量的数据点，对 $\\nabla p$ 和 $v$ 进行约束通过原点的线性回归。此回归的斜率 $C_D$ 使用普通最小二乘法（OLS）估计为 $C_D = (\\sum v_i \\nabla p_i) / (\\sum v_i^2)$。根据估计的斜率，固有渗透率计算如下：\n$$\nk_D = \\frac{\\mu}{C_D}\n$$\n然后，使用标准关系式计算导水率 $K_D$：\n$$\nK_D = \\frac{k_D \\rho g_{\\mathrm{acc}}}{\\mu}\n$$\n其中 $g_{\\mathrm{acc}}$ 是重力加速度。\n\n**假设2：保留阻力（Forchheimer）流动**\n该假设保留了粘性阻力项和惯性阻力项，并由完整的Forchheimer方程描述。再次代入 $\\nabla p$ 和 $v$ 的近似值：\n$$\n\\frac{\\Delta p}{L} = \\frac{\\mu}{k_F} v + \\rho \\beta v^2\n$$\n下标 $F$ 表示从Forchheimer模型推断的参数。该方程是多元线性回归模型通过原点的形式：\n$$\ny_i = C_1 x_{1i} + C_2 x_{2i}\n$$\n其中 $y_i = \\nabla p_i = \\Delta p_i/L$，$x_{1i} = v_i$，$x_{2i} = v_i^2$，系数为 $C_1 = \\mu/k_F$ 和 $C_2 = \\rho \\beta$。我们通过使用所有可用数据点执行OLS回归来确定系数 $C_1$ 和 $C_2$。解是通过求解正规方程组 $(\\mathbf{X}^T\\mathbf{X})\\mathbf{c} = \\mathbf{X}^T\\mathbf{y}$ 得到的，其中 $\\mathbf{y}$ 是 $\\nabla p_i$ 值的向量，$\\mathbf{c} = [C_1, C_2]^T$，$\\mathbf{X}$ 是以 $\\mathbf{v}$ 和 $\\mathbf{v}^2$ 为列的设计矩阵。\n从拟合的系数中，我们推断出物理参数：\n$$\nk_F = \\frac{\\mu}{C_1} \\quad \\text{和} \\quad \\beta = \\frac{C_2}{\\rho}\n$$\n一个定量的过渡准则由表观速度 $v_t$ 定义，在该速度下，粘性阻力和惯性阻力对压力梯度的贡献相等：\n$$\nC_1 v_t = C_2 v_t^2\n$$\n对于非零速度，这得出过渡速度：\n$$\nv_t = \\frac{C_1}{C_2}\n$$\n相应的过渡流量则为 $Q_t = v_t A$。\n\n数值实现将对每个测试案例执行这些回归分析，以计算所需的六个输出参数，然后将它们四舍五入到六位有效数字。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the porous media flow problem for three test cases.\n    It calculates permeability and other parameters based on Darcy and\n    Forchheimer flow models by performing linear regressions on\n    experimental data.\n    \"\"\"\n\n    # Define physical constants\n    rho = 1000.0  # Density of water in kg/m^3\n    mu = 1.0e-3   # Dynamic viscosity of water in Pa.s\n    g_acc = 9.81  # Gravitational acceleration in m/s^2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"L\": 0.5, \"A\": 0.01,\n            \"Q\": np.array([0.0, 1.0e-4, 3.0e-4, 6.0e-4, 1.0e-3, 1.5e-3, 2.2e-3, 3.0e-3]),\n            \"dp\": np.array([0.0, 126.0, 518.0, 1512.0, 3488.0, 7140.0, 14280.0, 25420.0])\n        },\n        {\n            \"name\": \"Case 2\",\n            \"L\": 0.5, \"A\": 0.01,\n            \"Q\": np.array([0.0, 1.0e-4, 3.0e-4, 6.0e-4, 1.0e-3, 1.5e-3, 2.2e-3, 3.0e-3]),\n            \"dp\": np.array([0.0, 49.5, 191.0, 525.0, 1160.0, 2320.0, 4540.0, 7990.0])\n        },\n        {\n            \"name\": \"Case 3\",\n            \"L\": 0.5, \"A\": 0.01,\n            \"Q\": np.array([0.0, 1.0e-4, 2.0e-4, 3.0e-4, 4.0e-4, 5.0e-4]),\n            \"dp\": np.array([0.0, 126.0, 298.0, 523.0, 802.0, 1127.0])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        A = case[\"A\"]\n        Q = case[\"Q\"]\n        dp = case[\"dp\"]\n\n        # Calculate superficial velocity and pressure gradient\n        v = Q / A\n        grad_p = dp / L\n\n        # -- Hypothesis 1: Darcy Model --\n        # Use a regression on the three smallest non-zero discharges\n        v_darcy = v[1:4]\n        grad_p_darcy = grad_p[1:4]\n\n        # OLS for y = mx (regression through origin)\n        C_D = np.sum(v_darcy * grad_p_darcy) / np.sum(v_darcy**2)\n        \n        # Infer parameters\n        k_D = mu / C_D\n        K_D = k_D * rho * g_acc / mu\n\n        # -- Hypothesis 2: Forchheimer Model --\n        # Use all data points for OLS regression through the origin\n        # Model: grad_p = C1*v + C2*v^2\n        X_forch = np.vstack((v, v**2)).T\n        y_forch = grad_p\n\n        # Solve the linear system using np.linalg.lstsq\n        coeffs, _, _, _ = np.linalg.lstsq(X_forch, y_forch, rcond=None)\n        C1, C2 = coeffs[0], coeffs[1]\n        \n        # Infer parameters\n        k_F = mu / C1\n        beta = C2 / rho\n        v_t = C1 / C2\n        Q_t = v_t * A\n\n        # Collect results for the current case\n        case_results = [k_D, K_D, k_F, beta, v_t, Q_t]\n        all_results.extend(case_results)\n\n    # Format results to six significant figures and create the output string\n    # The '.6g' format specifier handles rounding to 6 significant figures\n    results_str = [f\"{r:.6g}\" for r in all_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3515828"}, {"introduction": "最后的这项实践将理论与计算岩土力学联系起来。您将为一个二维稳态达西流问题开发一个简单的有限体积法求解器。这项练习强调了在数值格式中确保局部质量守恒的重要性，并提供了离散化控制方程和边界条件的实践经验，这是现代仿真工具的核心基础。[@problem_id:3515849]", "problem": "您的任务是构建并实现一种计算方法，用于施加多孔介质中稳定 Darcy 流的井源项和通量边界条件，以确保每个控制体积内局部质量守恒精确成立。目标是从第一性原理推导离散化格式，并使用一个小型测试套件在简单网格上验证局部质量守恒。您的最终程序必须按照下文指示，以单行输出测试套件的结果。\n\n推导目标与控制原理：\n- 从质量守恒定律出发，对于稳定不可压缩流体，该定律指出体积通量的散度等于单位体积的体积源项。其微分形式的控制关系为\n$$\n\\nabla \\cdot \\boldsymbol{q} = w,\n$$\n其中 $\\boldsymbol{q}$ 表示 Darcy 体积通量矢量，单位为 $\\text{m/s}$；$w$ 表示单位体积的体积源项，单位为 $\\text{s}^{-1}$，使得在一个大小为 $V$ 的控制体积上，速率为 $Q$（单位 $\\text{m}^3/\\text{s}$）的注水井贡献为 $w = Q/V$。\n- 使用 Darcy 定律，该定律通过以下公式将体积通量与压力梯度联系起来\n$$\n\\boldsymbol{q} = -\\frac{\\boldsymbol{k}}{\\mu} \\nabla p,\n$$\n其中 $\\boldsymbol{k}$ 是渗透率张量，其主分量为 $k_x$ 和 $k_y$（单位 $\\text{m}^2$），$\\mu$ 是动力粘度（单位 $\\text{Pa}\\cdot\\text{s}$），$p$ 是流体压力（单位 $\\text{Pa}$）。\n\n离散化框架与要求：\n- 使用由矩形控制体积组成的结构化、轴对齐网格，并在每个控制体积 $\\Omega_i$ 上对守恒方程进行积分。利用散度定理将 $\\nabla \\cdot \\boldsymbol{q}$ 的体积积分转换为跨越控制体积表面的法向通量之和。每个控制体积中的离散局部守恒必须精确执行为向外表面通量之和加上井流量等于零：\n$$\n\\sum_{f \\in \\partial \\Omega_i} F_{i,f} + Q_i = 0,\n$$\n其中 $F_{i,f}$ 是通过控制体积 $\\Omega_i$ 表面 $f$ 的向外体积面通量，单位为 $\\text{m}^3/\\text{s}$；$Q_i$ 是井的体积速率，单位为 $\\text{m}^3/\\text{s}$（注入为正，采出为负）。\n- 对于两个相邻控制体积之间的内部面，使用与 Darcy 定律一致的两点公式表示面通量：\n$$\nF_{i \\to j} = T_{ij} \\left(p_i - p_j\\right),\n$$\n其中导压系数 $T_{ij}$ 取决于渗透率的法向分量、面面积、单元中心之间的距离以及粘度。对于与坐标轴对齐的各向异性，对垂直于 x 方向的面使用 $k_x$，对垂直于 y 方向的面使用 $k_y$，并采用一种能保持通量连续性且具有物理依据的法向渗透率平均方案（不要使用任何简化公式）。\n- 对于给定边界压力 $p_b$ 的狄利克雷压力边界条件，根据 Darcy 定律一致地处理边界面，使得向外通量为\n$$\nF_{i,b} = T_{i,b} \\left(p_i - p_b\\right),\n$$\n其中 $T_{i,b}$ 使用法向渗透率、面面积以及到边界的半单元距离来定义。\n- 对于规定法向比流量 $f_b$（单位 $\\text{m/s}$，向外为正）的诺伊曼通量边界条件，直接将向外面通量设置为\n$$\nF_{i,b} = f_b A_f,\n$$\n其中 $A_f$ 是面面积，单位为 $\\text{m}^2$。\n- 为未知的单元压力 $p_i$ 组装线性系统，以确保每个控制体积中的离散局部守恒条件都得到精确满足。您的推导必须从上述基本定律开始，并为内部面、狄利克雷面、诺伊曼面和井源项推导离散贡献，不得假设任何预先推导出的公式。明确解释组装过程如何通过反对称的内部通量对以及对边界和源项的正确处理来保证精确的局部质量守恒。\n\n计算要求：\n- 在程序中实现上述方法，该程序构建导压系数和线性系统，求解压力，计算所有面通量，然后计算每个控制体积中的局部质量守恒残差：\n$$\nR_i = \\sum_{f \\in \\partial \\Omega_i} F_{i,f} + Q_i,\n$$\n其中 $R_i$ 的单位为 $\\text{m}^3/\\text{s}$。\n- 对于每个测试用例，报告所有控制体积中的最大绝对残差：\n$$\nR_{\\max} = \\max_i |R_i|,\n$$\n以 $\\text{m}^3/\\text{s}$ 表示。输出值必须为浮点数。\n\n单位与几何：\n- 使用一个恒定的厚度 $b$（单位 $\\text{m}$），通过 $F = f_b A_f$ 将比流量（单位 $\\text{m/s}$）转换为体积面通量（单位 $\\text{m}^3/\\text{s}$），其中 $A_f$ 等于面长度乘以厚度。压力必须以 $\\text{Pa}$ 为单位，渗透率以 $\\text{m}^2$ 为单位，动力粘度以 $\\text{Pa}\\cdot\\text{s}$ 为单位，所有通量和井速率均以 $\\text{m}^3/\\text{s}$ 为单位。\n\n测试套件：\n- 用例 A（理想情况，各向同性渗透率，混合狄利克雷边界和一个井）：\n  - 区域：长度 $L_x = 2.0 \\ \\text{m}$，高度 $L_y = 1.0 \\ \\text{m}$，厚度 $b = 1.0 \\ \\text{m}$ 的矩形。\n  - 网格：$n_x = 2$, $n_y = 2$ 个控制体积。\n  - 渗透率：各向同性，$k = 1.0 \\times 10^{-12} \\ \\text{m}^2$。\n  - 动力粘度：$\\mu = 1.0 \\times 10^{-3} \\ \\text{Pa}\\cdot\\text{s}$。\n  - 边界条件：左边界狄利克雷条件 $p = 2.0 \\times 10^5 \\ \\text{Pa}$，右边界狄利克雷条件 $p = 1.0 \\times 10^5 \\ \\text{Pa}$，顶部和底部边界诺伊曼零通量条件 $f = 0 \\ \\text{m/s}$。\n  - 井：注入井 $Q = 1.0 \\times 10^{-7} \\ \\text{m}^3/\\text{s}$，位于索引 $(i_x = 0, i_y = 1)$ 处，其中 $i_y = 0$ 表示底层，$i_y = 1$ 表示顶层。\n- 用例 B（非均质各向异性，混合边界和一个井）：\n  - 区域：$L_x = 2.0 \\ \\text{m}$，$L_y = 1.0 \\ \\text{m}$，$b = 1.0 \\ \\text{m}$。\n  - 网格：$n_x = 2$, $n_y = 2$。\n  - 渗透率：各向异性，主分量为 $k_x = 5.0 \\times 10^{-13} \\ \\text{m}^2$ 和 $k_y = 1.0 \\times 10^{-12} \\ \\text{m}^2$（与坐标轴对齐且在整个区域内均匀）。\n  - 动力粘度：$\\mu = 1.0 \\times 10^{-3} \\ \\text{Pa}\\cdot\\text{s}$。\n  - 边界条件：左边界狄利克雷条件 $p = 1.5 \\times 10^5 \\ \\text{Pa}$，右边界狄利克雷条件 $p = 1.2 \\times 10^5 \\ \\text{Pa}$，底部边界诺伊曼向外通量条件 $f_{\\text{bottom}} = 2.0 \\times 10^{-7} \\ \\text{m/s}$，顶部边界诺伊曼零通量条件 $f_{\\text{top}} = 0 \\ \\text{m/s}$。\n  - 井：注入井 $Q = 4.0 \\times 10^{-7} \\ \\text{m}^3/\\text{s}$，位于 $(i_x = 1, i_y = 0)$ 处。\n- 用例 C（单控制体积边缘情况，边界通量与井的一致性）：\n  - 区域：$L_x = 1.0 \\ \\text{m}$，$L_y = 1.0 \\ \\text{m}$，$b = 1.0 \\ \\text{m}$。\n  - 网格：$n_x = 1$, $n_y = 1$。\n  - 渗透率：各向同性，$k = 2.0 \\times 10^{-12} \\ \\text{m}^2$。\n  - 动力粘度：$\\mu = 1.0 \\times 10^{-3} \\ \\text{Pa}\\cdot\\text{s}$。\n  - 边界条件：左边界狄利克雷条件 $p = 1.0 \\times 10^5 \\ \\text{Pa}$，右边界狄利克雷条件 $p = 1.0 \\times 10^5 \\ \\text{Pa}$，顶部边界诺伊曼向外通量条件 $f_{\\text{top}} = 1.0 \\times 10^{-6} \\ \\text{m/s}$，底部边界诺伊曼零通量条件 $f_{\\text{bottom}} = 0 \\ \\text{m/s}$。\n  - 井：速率 $Q = -1.0 \\times 10^{-6} \\ \\text{m}^3/\\text{s}$，以精确抵消通过面积 $A_{\\text{top}} = L_x \\times b$ 的指定顶部边界向外通量，使得局部质量守恒应精确成立。\n\n输出规格：\n- 对于每个测试用例 $A$、$B$ 和 $C$，计算所有控制体积中的最大绝对局部质量不平衡量 $R_{\\max}$（单位 $\\text{m}^3/\\text{s}$）。您的程序应生成单行输出，其中包含三个结果，以逗号分隔并用方括号括起来，例如\n$$\n[\\text{value}_A,\\text{value}_B,\\text{value}_C].\n$$\n\n您的实现必须是一个完整且可运行的程序，该程序根据所述物理模型构建导压系数，组装线性系统，求解 $p$，计算通量，并通过计算每个测试用例的 $R_{\\max}$（以指定单位）来验证局部质量守恒。不允许外部输入；所有参数必须完全按照上面给定的值进行硬编码。", "solution": "任务是为稳态 Darcy 流推导并实现一种能够确保精确局部质量守恒的有限体积法。我们将在二维结构化网格上求解压力，并对三个测试用例进行质量守恒验证。\n\n### 1. 控制方程与离散化\n\n基本原理是稳定、不可压缩流体的质量守恒，在一个任意控制体积 $\\Omega_i$ 上进行积分：\n$$\n\\int_{\\Omega_i} (\\nabla \\cdot \\boldsymbol{q}) \\, dV = \\int_{\\Omega_i} w \\, dV\n$$\n其中 $\\boldsymbol{q}$ 是 Darcy 体积通量矢量（$\\text{m/s}$），$w$ 是单位体积的体积源速率（$\\text{s}^{-1}$）。\n\n应用散度定理，散度的体积积分被转换为沿边界 $\\partial\\Omega_i$ 的通量面积分：\n$$\n\\oint_{\\partial\\Omega_i} \\boldsymbol{q} \\cdot \\boldsymbol{n} \\, dA = \\int_{\\Omega_i} w \\, dV\n$$\n左侧表示总的向外体积通量，可以离散化为控制体积各个面 $f$ 上的通量 $F_{i,f}$ 之和。右侧是体积内的总体积源速率，记为 $Q_i^{\\text{src}}$ (单位 $\\text{m}^3/\\text{s}$)。这给出了物理守恒方程：\n$$\n\\sum_{f \\in \\partial\\Omega_i} F_{i,f} = Q_i^{\\text{src}}\n$$\n问题陈述将井速率 $Q_i$ 定义为注入时（作为源）为正，并提供了要实现的守恒方程如下：\n$$\n\\sum_{f \\in \\partial\\Omega_i} F_{i,f} + Q_i = 0\n$$\n其中 $F_{i,f}$ 是从单元 $i$ 通过面 $f$ 的向外通量。这是一个特定的符号约定，意味着向外通量之和必须等于注入速率的负值，即 $\\sum F_{i,f} = -Q_i$。我们将遵守此约定。\n\n通量 $\\boldsymbol{q}$ 通过 Darcy 定律与压力梯度 $\\nabla p$ 相关联：\n$$\n\\boldsymbol{q} = -\\frac{\\boldsymbol{k}}{\\mu} \\nabla p\n$$\n其中 $\\boldsymbol{k}$ 是渗透率张量，$\\mu$ 是动力粘度，$p$ 是压力。对于主轴与坐标系对齐的各向异性介质，该张量是对角阵：$\\boldsymbol{k} = \\text{diag}(k_x, k_y)$。\n\n### 2. 通量项的离散化\n\n我们对尺寸为 $\\Delta x \\times \\Delta y$、厚度恒为 $b$ 的矩形单元组成的结构化网格使用两点通量近似 (TPFA)。\n\n#### 内部面通量\n考虑两个相邻的单元，$i$ 和 $j$，它们共享一个面积为 $A_f = \\Delta y \\cdot b$ 的垂直面。该面垂直于 x 轴。单元中心相距 $\\Delta x$。从单元 $i$ 到单元 $j$ 的通量（记为 $F_{i \\to j}$）由压力差 $(p_i - p_j)$ 驱动。为了在非均质渗透率下保持通量连续性，我们将流动建模为一个包含两个串联段的一维系统：从单元 $i$ 的中心到面，以及从面到单元 $j$ 的中心。比流量 $q_x$ 是恒定的。\n$$\nq_x = -\\frac{k_{x,i}}{\\mu} \\frac{p_f - p_i}{\\Delta x/2} = -\\frac{k_{x,j}}{\\mu} \\frac{p_j - p_f}{\\Delta x/2}\n$$\n求解界面压力 $p_f$ 并回代，得到以单元中心压力 $p_i$ 和 $p_j$ 表示的通量表达式。\n$$\nF_{i \\to j} = q_x A_f = \\frac{A_f}{\\mu} \\frac{1}{\\frac{\\Delta x/2}{k_{x,i}} + \\frac{\\Delta x/2}{k_{x,j}}} (p_i - p_j)\n$$\n乘以压力差的项是导压系数 $T_{ij}$。对于均质介质，其中 $k_{x,i}=k_{x,j}=k_x$，这简化为：\n$$\nT_{ij,x} = \\frac{\\Delta y \\cdot b \\cdot k_x}{\\mu \\cdot \\Delta x}\n$$\n类似地，对于两个单元之间面积为 $A_f = \\Delta x \\cdot b$ 的水平面：\n$$\nT_{ij,y} = \\frac{\\Delta x \\cdot b \\cdot k_y}{\\mu \\cdot \\Delta y}\n$$\n通量则为 $F_{i \\to j} = T_{ij} (p_i - p_j)$。\n\n#### 狄利克雷边界面通量\n对于一个规定了压力 $p_b$ 的边界面，通量的计算与内部情况类似，但从单元中心到边界的距离是半个单元的距离，例如 $\\Delta x/2$。从单元 $i$ 通过边界面 $b$ 的向外通量是：\n$$\nF_{i,b} = \\frac{A_f k_n}{\\mu (\\Delta n/2)} (p_i - p_b) = T_{i,b} (p_i - p_b)\n$$\n其中 $\\Delta n$ 是垂直于面的单元尺寸（$\\Delta x$ 或 $\\Delta y$），$k_n$ 是相应的渗透率（$k_x$ 或 $k_y$）。因此，边界导压系数 $T_{i,b}$ 是内部面导压系数的两倍。对于 x 方向的边界：\n$$\nT_{i,b,x} = \\frac{2 \\Delta y \\cdot b \\cdot k_x}{\\mu \\cdot \\Delta x}\n$$\n\n#### 诺伊曼边界面通量\n对于一个规定了比流量 $f_b$（向外为正）的边界面，体积通量直接由下式给出：\n$$\nF_{i,b} = f_b \\cdot A_f\n$$\n这是一个已知的常数值，贡献于质量守恒方程。\n\n### 3. 线性系统的组装\n\n通过将通量表达式代入守恒方程 $\\sum F_{i,f} + Q_i = 0$，可以组装每个控制体积 $\\Omega_i$ 的离散质量守恒方程。\n$$\n\\sum_{j \\in \\text{neighbors}(i)} T_{ij}(p_i-p_j) + \\sum_{b \\in \\partial\\Omega_i, \\text{Dirichlet}} T_{i,b}(p_i-p_b) + \\sum_{b \\in \\partial\\Omega_i, \\text{Neumann}} f_b A_f + Q_i = 0\n$$\n该方程对于未知的单元中心压力 $p_i$ 是线性的。我们通过将包含未知压力的项与常数项分开来重新整理它。\n$$\n\\left( \\sum_{j \\in \\text{neighbors}(i)} T_{ij} + \\sum_{b \\in \\partial\\Omega_i, \\text{Dirichlet}} T_{i,b} \\right) p_i - \\sum_{j \\in \\text{neighbors}(i)} T_{ij} p_j = \\sum_{b \\in \\partial\\Omega_i, \\text{Dirichlet}} T_{i,b} p_b - \\sum_{b \\in \\partial\\Omega_i, \\text{Neumann}} f_b A_f - Q_i\n$$\n此方程构成了线性系统 $\\mathbf{A}\\mathbf{p} = \\mathbf{b}$ 中的一行，其中 $\\mathbf{p}$ 是未知单元压力的向量。\n- 矩阵 $\\mathbf{A}$ 中单元 $i$ 的对角线元素是所有连接到它的导压系数之和：$A_{ii} = \\sum_{j} T_{ij} + \\sum_{b,D} T_{i,b}$。\n- 连接到邻居 $j$ 的非对角线元素是单元间导压系数的负值：$A_{ij} = -T_{ij}$。\n- 右侧向量 $\\mathbf{b}$ 中对应的元素由所有已知的源项和边界项组成：$b_i = \\sum_{b,D} T_{i,b} p_b - \\sum_{b,N} f_b A_f - Q_i$。\n\n### 4. 局部质量守恒的验证\n\n在求解线性系统 $\\mathbf{A}\\mathbf{p} = \\mathbf{b}$ 得到压力向量 $\\mathbf{p}$ 后，我们可以使用已解出的压力计算所有面通量。然后计算每个单元 $i$ 的局部质量守恒残差：\n$$\nR_i = \\sum_{f \\in \\partial \\Omega_i} F_{i,f} + Q_i\n$$\n根据构造，我们求解的线性系统是条件 $R_i=0$ 的直接代数表述。因此，当我们使用解 $\\mathbf{p}$ 计算 $R_i$ 时，结果应在数值计算的浮点精度范围内为零。最大绝对残差 $R_{\\max} = \\max_i|R_i|$ 应该是一个非常小的数，这证实了该方法强制执行了局部质量守恒。这是有限体积法的一个关键特性。\n该实现将为每个测试用例构建矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$，求解 $\\mathbf{p}$，然后计算 $R_{\\max}$。", "answer": "```python\nimport numpy as np\n\ndef run_case(Lx, Ly, b, nx, ny, kx, ky, mu, bcs, wells):\n    \"\"\"\n    Solves the steady-state Darcy flow problem and computes the max mass balance residual.\n\n    Args:\n        Lx, Ly, b (float): Domain dimensions and thickness.\n        nx, ny (int): Number of control volumes in x and y.\n        kx, ky (float): Permeabilities.\n        mu (float): Dynamic viscosity.\n        bcs (dict): Boundary conditions.\n        wells (list): List of well specifications.\n\n    Returns:\n        float: The maximum absolute mass balance residual.\n    \"\"\"\n    dx = Lx / nx\n    dy = Ly / ny\n    N = nx * ny\n\n    A = np.zeros((N, N))\n    rhs = np.zeros(N)\n\n    def cell_idx(ix, iy):\n        return iy * nx + ix\n\n    # Assemble matrix A and vector rhs\n    for iy in range(ny):\n        for ix in range(nx):\n            k = cell_idx(ix, iy)\n            \n            # Left face (at x = ix * dx)\n            if ix == 0:  # Boundary face\n                bc_type, bc_val = bcs['left']\n                if bc_type == 'D':\n                    T_b = (2 * dy * b * kx) / (mu * dx)\n                    A[k, k] += T_b\n                    rhs[k] += T_b * bc_val\n                elif bc_type == 'N':\n                    F_b = bc_val * (dy * b)\n                    rhs[k] -= F_b\n            else:  # Interior face\n                k_neighbor = cell_idx(ix - 1, iy)\n                T = (dy * b * kx) / (mu * dx)\n                A[k, k] += T\n                A[k, k_neighbor] -= T\n\n            # Right face (at x = (ix + 1) * dx)\n            if ix == nx - 1:  # Boundary face\n                bc_type, bc_val = bcs['right']\n                if bc_type == 'D':\n                    T_b = (2 * dy * b * kx) / (mu * dx)\n                    A[k, k] += T_b\n                    rhs[k] += T_b * bc_val\n                elif bc_type == 'N':\n                    F_b = bc_val * (dy * b)\n                    rhs[k] -= F_b\n            else:  # Interior face\n                k_neighbor = cell_idx(ix + 1, iy)\n                T = (dy * b * kx) / (mu * dx)\n                A[k, k] += T\n                A[k, k_neighbor] -= T\n\n            # Bottom face (at y = iy * dy)\n            if iy == 0:  # Boundary face\n                bc_type, bc_val = bcs['bottom']\n                if bc_type == 'D':\n                    T_b = (2 * dx * b * ky) / (mu * dy)\n                    A[k, k] += T_b\n                    rhs[k] += T_b * bc_val\n                elif bc_type == 'N':\n                    F_b = bc_val * (dx * b)\n                    rhs[k] -= F_b\n            else:  # Interior face\n                k_neighbor = cell_idx(ix, iy - 1)\n                T = (dx * b * ky) / (mu * dy)\n                A[k, k] += T\n                A[k, k_neighbor] -= T\n\n            # Top face (at y = (iy + 1) * dy)\n            if iy == ny - 1:  # Boundary face\n                bc_type, bc_val = bcs['top']\n                if bc_type == 'D':\n                    T_b = (2 * dx * b * ky) / (mu * dy)\n                    A[k, k] += T_b\n                    rhs[k] += T_b * bc_val\n                elif bc_type == 'N':\n                    F_b = bc_val * (dx * b)\n                    rhs[k] -= F_b\n            else:  # Interior face\n                k_neighbor = cell_idx(ix, iy + 1)\n                T = (dx * b * ky) / (mu * dy)\n                A[k, k] += T\n                A[k, k_neighbor] -= T\n\n    # Add well terms based on convention sum(F_out) + Q_inj = 0\n    well_vector = np.zeros(N)\n    for well_ix, well_iy, well_Q in wells:\n        well_k = cell_idx(well_ix, well_iy)\n        well_vector[well_k] = well_Q\n        rhs[well_k] -= well_Q  # Balance eq: sum(T*(p-p')) = ... - Q\n\n    # Solve for pressures\n    p = np.linalg.solve(A, rhs)\n\n    # Calculate residuals\n    residuals = np.zeros(N)\n    for iy in range(ny):\n        for ix in range(nx):\n            k = cell_idx(ix, iy)\n            flux_sum = 0\n            \n            # Left flux\n            if ix == 0:\n                bc_type, bc_val = bcs['left']\n                if bc_type == 'D':\n                    flux_sum -= ((2 * dy * b * kx) / (mu * dx)) * (p[k] - bc_val)\n                else: flux_sum -= bc_val * (dy * b)\n            else:\n                flux_sum -= ((dy * b * kx) / (mu * dx)) * (p[k] - p[cell_idx(ix - 1, iy)])\n\n            # Right flux\n            if ix == nx - 1:\n                bc_type, bc_val = bcs['right']\n                if bc_type == 'D':\n                    flux_sum += ((2 * dy * b * kx) / (mu * dx)) * (p[k] - bc_val)\n                else: flux_sum += bc_val * (dy * b)\n            else:\n                flux_sum += ((dy * b * kx) / (mu * dx)) * (p[cell_idx(ix + 1, iy)] - p[k])\n\n            # Bottom flux\n            if iy == 0:\n                bc_type, bc_val = bcs['bottom']\n                if bc_type == 'D':\n                    flux_sum -= ((2 * dx * b * ky) / (mu * dy)) * (p[k] - bc_val)\n                else: flux_sum -= bc_val * (dx * b)\n            else:\n                flux_sum -= ((dx * b * ky) / (mu * dy)) * (p[k] - p[cell_idx(ix, iy - 1)])\n\n            # Top flux\n            if iy == ny - 1:\n                bc_type, bc_val = bcs['top']\n                if bc_type == 'D':\n                    flux_sum += ((2 * dx * b * ky) / (mu * dy)) * (p[k] - bc_val)\n                else: flux_sum += bc_val * (dx * b)\n            else:\n                flux_sum += ((dx * b * ky) / (mu * dy)) * (p[cell_idx(ix, iy + 1)] - p[k])\n            \n            residuals[k] = flux_sum + well_vector[k]\n\n    # Re-calculate residuals by re-computing the matrix-vector product A*p and comparing to rhs\n    residuals_check = A @ p - rhs\n    # Add back the well term to match the problem's residual definition sum(F_out) + Q_inj\n    residuals_check += well_vector\n    \n    return np.max(np.abs(residuals_check))\n\n\ndef solve():\n    # Define test cases\n    k_iso_A = 1.0e-12\n    test_cases = [\n        {\n            \"Lx\": 2.0, \"Ly\": 1.0, \"b\": 1.0, \"nx\": 2, \"ny\": 2,\n            \"kx\": k_iso_A, \"ky\": k_iso_A, \"mu\": 1.0e-3,\n            \"bcs\": {\n                \"left\": ('D', 2.0e5), \"right\": ('D', 1.0e5),\n                \"top\": ('N', 0.0), \"bottom\": ('N', 0.0)\n            },\n            \"wells\": [(0, 1, 1.0e-7)]\n        },\n        {\n            \"Lx\": 2.0, \"Ly\": 1.0, \"b\": 1.0, \"nx\": 2, \"ny\": 2,\n            \"kx\": 5.0e-13, \"ky\": 1.0e-12, \"mu\": 1.0e-3,\n            \"bcs\": {\n                \"left\": ('D', 1.5e5), \"right\": ('D', 1.2e5),\n                \"top\": ('N', 0.0), \"bottom\": ('N', 2.0e-7)\n            },\n            \"wells\": [(1, 0, 4.0e-7)]\n        },\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"b\": 1.0, \"nx\": 1, \"ny\": 1,\n            \"kx\": 2.0e-12, \"ky\": 2.0e-12, \"mu\": 1.0e-3,\n            \"bcs\": {\n                \"left\": ('D', 1.0e5), \"right\": ('D', 1.0e5),\n                \"top\": ('N', 1.0e-6), \"bottom\": ('N', 0.0)\n            },\n            \"wells\": [(0, 0, -1.0e-6)]\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        # A simpler way to compute the residual is to check A*p - b = 0\n        # The problem asks to calculate R_i = sum(F_out) + Q_i\n        # My RHS is constructed as b_i = sum(known_fluxes) - Q_i\n        # My LHS is A*p = sum(unknown_flux_terms)\n        # So A*p - b = sum(unknown_flux_terms) - sum(known_fluxes) + Q_i\n        # sum(F_out) = sum(unknown_flux_terms) - sum(known_fluxes), where known_fluxes are negative if incoming\n        # Let's re-verify the logic from the solution text.\n        # Eq: (sum T_ij + sum T_ib)p_i - sum T_ij p_j = sum T_ib p_b - sum f_b A_f - Q_i\n        # This is A*p = b.\n        # The residual is defined as R_i = sum(F_out) + Q_i\n        # sum(F_out) = [ (sum T_ij p_i - sum T_ij p_j) + (sum T_ib p_i - sum T_ib p_b) + sum f_b A_f ]\n        #            = [ (sum T_ij + sum T_ib) p_i - sum T_ij p_j ] - [ sum T_ib p_b - sum f_b A_f ]\n        #            = (A*p)_i - (b_i + Q_i)\n        # So R_i = (A*p)_i - b_i - Q_i + Q_i = (A*p)_i - b_i.\n        # The residual is exactly the residual of the linear system A*p=b.\n        \n        # Original code was re-calculating fluxes, which is prone to copy-paste errors.\n        # A much more robust way is to re-use the assembled matrix and RHS vector.\n        \n        N = case_params['nx'] * case_params['ny']\n        A_mat = np.zeros((N, N))\n        rhs_vec = np.zeros(N)\n        well_q = np.zeros(N)\n        \n        # Simplified assembly logic for clarity and robustness.\n        dx, dy, b = case_params['Lx']/case_params['nx'], case_params['Ly']/case_params['ny'], case_params['b']\n        kx, ky, mu = case_params['kx'], case_params['ky'], case_params['mu']\n        \n        for iy in range(case_params['ny']):\n            for ix in range(case_params['nx']):\n                k = iy * case_params['nx'] + ix\n                # X-direction\n                if ix > 0: # Left neighbor\n                    T = dy*b*kx/(mu*dx)\n                    A_mat[k, k] += T\n                    A_mat[k, k-1] -= T\n                else: # Left BC\n                    bc = case_params['bcs']['left']\n                    if bc[0] == 'D':\n                        T = 2*dy*b*kx/(mu*dx)\n                        A_mat[k, k] += T\n                        rhs_vec[k] += T * bc[1]\n                    else: # 'N'\n                        rhs_vec[k] -= bc[1] * dy * b\n                \n                if ix  case_params['nx']-1: # Right neighbor\n                    T = dy*b*kx/(mu*dx)\n                    A_mat[k, k] += T\n                    A_mat[k, k+1] -= T\n                else: # Right BC\n                    bc = case_params['bcs']['right']\n                    if bc[0] == 'D':\n                        T = 2*dy*b*kx/(mu*dx)\n                        A_mat[k, k] += T\n                        rhs_vec[k] += T * bc[1]\n                    else: # 'N'\n                        rhs_vec[k] -= bc[1] * dy * b\n\n                # Y-direction\n                if iy > 0: # Bottom neighbor\n                    T = dx*b*ky/(mu*dy)\n                    A_mat[k, k] += T\n                    A_mat[k, k-case_params['nx']] -= T\n                else: # Bottom BC\n                    bc = case_params['bcs']['bottom']\n                    if bc[0] == 'D':\n                        T = 2*dx*b*ky/(mu*dy)\n                        A_mat[k, k] += T\n                        rhs_vec[k] += T * bc[1]\n                    else: # 'N'\n                        rhs_vec[k] -= bc[1] * dx * b\n                        \n                if iy  case_params['ny']-1: # Top neighbor\n                    T = dx*b*ky/(mu*dy)\n                    A_mat[k, k] += T\n                    A_mat[k, k+case_params['nx']] -= T\n                else: # Top BC\n                    bc = case_params['bcs']['top']\n                    if bc[0] == 'D':\n                        T = 2*dx*b*ky/(mu*dy)\n                        A_mat[k, k] += T\n                        rhs_vec[k] += T * bc[1]\n                    else: # 'N'\n                        rhs_vec[k] -= bc[1] * dx * b\n        \n        for w_ix, w_iy, w_q in case_params['wells']:\n            k = w_iy * case_params['nx'] + w_ix\n            well_q[k] = w_q\n        \n        rhs_vec -= well_q\n        \n        p = np.linalg.solve(A_mat, rhs_vec)\n        \n        # Calculate residual R = A*p - b\n        residual_vector = A_mat @ p - rhs_vec\n        results.append(np.max(np.abs(residual_vector)))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3515849"}]}