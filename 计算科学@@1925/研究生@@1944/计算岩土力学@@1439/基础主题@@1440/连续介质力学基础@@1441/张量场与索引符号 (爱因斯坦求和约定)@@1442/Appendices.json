{"hands_on_practices": [{"introduction": "在代码中运用张量指标记法的基石是正确实现张量缩并，这对应于对哑指标的求和。一个常见错误是“指标冲突”，它会导致错误的逐元素操作，而非预期的求和。本练习旨在将这一抽象错误具体化：通过计算作用在某平面上的牵引力矢量，你将同时实现正确的张量缩并与一个常见的错误版本，并设计一个诊断测试来凸显其数值差异，从而巩固你对爱因斯坦求和约定如何转化为代码的理解。[@problem_id:3566792]", "problem": "考虑一个三维柯西应力张量场，其中在单位法向量为 $n_j$ 的平面上的面力矢量 $s_i$ 满足爱因斯坦求和约定下的 $s_i = \\sigma_{ij} n_j$。设该平面法向量是由参考法向量 $n^{(0)}_k$ 通过一个真正交旋转张量 $Q_{jk}$ 进行刚体旋转生成的，即 $n_j = Q_{jk} n^{(0)}_k$。所有量都应视为无量纲（无单位）。角度必须以弧度为单位指定和使用。\n\n你的任务是用代码实现缩并 $s_i = \\sigma_{ij} n_j$，并设计一个诊断程序来揭示旋转步骤中的指标冲突错误。一个常见的指标冲突错误是写成 $n_j^{\\mathrm{bug}} = Q_{jj} n^{(0)}_j$（在 $Q_{jj}$ 上重复使用相同的指标，并再次在 $n^{(0)}_j$ 上使用它），这会抑制必要的旋转指标求和，错误地缩放每个分量，而不是混合分量。\n\n为每个测试用例实现以下内容：\n1. 根据给定的对角线元素，构造一个对角应力张量 $\\sigma_{ij} = \\mathrm{diag}(\\sigma_{11}, \\sigma_{22}, \\sigma_{33})$。\n2. 构造一个真正交旋转张量 $Q_{jk}$，用于围绕指定坐标轴按指定弧度角进行旋转。\n3. 计算旋转后的法向量 $n_j = Q_{jk} n^{(0)}_k$ 和面力 $s_i = \\sigma_{ij} n_j$。\n4. 计算错误的旋转法向量 $n_j^{\\mathrm{bug}} = Q_{jj} n^{(0)}_j$（对 $j$ 不求和），以及相应的面力 $s_i^{\\mathrm{bug}} = \\sigma_{ij} n_j^{\\mathrm{bug}}$。\n5. 计算诊断残差 $r = \\| s - s^{\\mathrm{bug}} \\|_2$，即正确面力与错误面力之差的欧几里得范数。\n\n使用以下测试套件，它涵盖了典型、边界和边缘情况：\n- 情况 1（正常路径）：$\\sigma_{11} = 10$，$\\sigma_{22} = 20$，$\\sigma_{33} = 30$，绕 $z$ 轴旋转角度 $\\theta = \\pi/4$，且 $n^{(0)} = [1, 0, 0]$。\n- 情况 2（单位旋转边界）：$\\sigma_{11} = 15$，$\\sigma_{22} = 25$，$\\sigma_{33} = 35$，绕 $z$ 轴旋转角度 $\\theta = 0$，且 $n^{(0)} = [0, 1, 0]$。\n- 情况 3（零法向量边界）：$\\sigma_{11} = 12$，$\\sigma_{22} = 7$，$\\sigma_{33} = 5$，绕 $y$ 轴旋转角度 $\\theta = 0.5$，且 $n^{(0)} = [0, 0, 0]$。\n- 情况 4（各向异性凸显）：$\\sigma_{11} = 1000$，$\\sigma_{22} = 1$，$\\sigma_{33} = 1$，绕 $z$ 轴旋转角度 $\\theta = \\pi/2$，且 $n^{(0)} = [1, 0, 0]$。\n- 情况 5（平面内各向同性带旋转）：$\\sigma_{11} = 5$，$\\sigma_{22} = 5$，$\\sigma_{33} = 0$，绕 $z$ 轴旋转角度 $\\theta = 0.1$，且 $n^{(0)} = [1/\\sqrt{2}, 1/\\sqrt{2}, 0]$。\n\n你的程序必须生成一行输出，其中包含五个测试用例的残差。输出形式为一个用方括号括起来的逗号分隔列表，每个残差四舍五入到六位小数，例如 $[r_1,r_2,r_3,r_4,r_5]$。输出值必须是浮点数。\n\n你的实现必须是完全确定性和自包含的。旋转张量 $Q_{jk}$ 必须构造为用于绕坐标轴旋转的真正交矩阵。缩并的实现方式必须遵循爱因斯坦求和约定，避免指标冲突。将所有量视为无量纲数（无单位）。", "solution": "该问题是有效的，因为它在科学上基于连续介质力学和线性代数，问题定义明确，每个案例都有唯一且可确定性计算的解，并且其表述是客观的。它提出了一个与计算科学相关的、清晰且可形式化的任务，并可作为识别张量代数中常见实现错误的有效练习。\n\n这个问题的核心在于正确应用张量缩并，特别是矩阵向量乘积，这些运算遵循爱因斯坦求和约定。我们的任务是计算作用在一个平面上的面力矢量 $s_i$，它通过柯西第一运动定律与柯西应力张量 $\\sigma_{ij}$ 和平面的单位法向量 $n_j$ 相关联：\n$$\ns_i = \\sigma_{ij} n_j\n$$\n在这个方程中，重复的指标 $j$ 意味着对三个空间维度（从1到3）进行求和，这代表了一次矩阵向量乘法。\n\n法向量 $n_j$ 不是直接给出的，而是通过使用一个真正交旋转张量 $Q_{jk}$ 旋转参考法向量 $n^{(0)}_k$ 得到的。该变换由下式给出：\n$$\nn_j = Q_{jk} n^{(0)}_k\n$$\n这里，重复的指标 $k$ 同样意味着求和，对应于矩阵 $Q$ 与向量 $n^{(0)}$ 的乘法。\n\n问题要求构造用于绕标准笛卡尔坐标轴旋转的旋转张量 $Q_{jk}$。对于绕 $x$、$y$ 和 $z$ 轴旋转角度 $\\theta$ 的情况，相应的旋转张量分别为：\n绕 $x$ 轴旋转：\n$$\nQ_x(\\theta) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{pmatrix}\n$$\n绕 $y$ 轴旋转：\n$$\nQ_y(\\theta) = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix}\n$$\n绕 $z$ 轴旋转：\n$$\nQ_z(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n应力张量 $\\sigma_{ij}$ 是一个由三个指定的主应力值 $\\sigma_{11}$、$\\sigma_{22}$ 和 $\\sigma_{33}$ 构成的对角矩阵：\n$$\n\\sigma_{ij} = \\begin{pmatrix} \\sigma_{11} & 0 & 0 \\\\ 0 & \\sigma_{22} & 0 \\\\ 0 & 0 & \\sigma_{33} \\end{pmatrix}\n$$\n\n任务的一个关键部分是诊断一个涉及指标冲突的常见编码错误。法向量旋转的错误实现定义为：\n$$\nn_j^{\\mathrm{bug}} = Q_{jj} n^{(0)}_j \\quad (\\text{不对 } j \\text{ 求和})\n$$\n这个操作不是张量缩并。它代表旋转张量 $Q$ 的对角元素与参考法向量 $n^{(0)}$ 的分量之间的逐元素乘积。对于 $j=1, 2, 3$，这对应于：\n$$\nn_1^{\\mathrm{bug}} = Q_{11} n^{(0)}_1 \\\\\nn_2^{\\mathrm{bug}} = Q_{22} n^{(0)}_2 \\\\\nn_3^{\\mathrm{bug}} = Q_{33} n^{(0)}_3\n$$\n然后，这个有缺陷的法向量被用来计算一个“错误的”面力矢量 $s_i^{\\mathrm{bug}}$：\n$$\ns_i^{\\mathrm{bug}} = \\sigma_{ij} n_j^{\\mathrm{bug}}\n$$\n这一步本身是一个正确的张量缩并（矩阵向量乘积），但它作用在不正确的输入数据 $n_j^{\\mathrm{bug}}$ 上。\n\n用于量化误差的诊断方法是正确面力矢量 $s_i$ 与错误面力矢量 $s_i^{\\mathrm{bug}}$ 之差的欧几里得范数（$L_2$-范数）。这个残差 $r$ 计算如下：\n$$\nr = \\| s - s^{\\mathrm{bug}} \\|_2 = \\sqrt{\\sum_{i=1}^{3} (s_i - s_i^{\\mathrm{bug}})^2}\n$$\n\n每个测试用例的求解算法如下：\n1. 根据给定的主应力 $\\sigma_{11}, \\sigma_{22}, \\sigma_{33}$，构造 $3 \\times 3$ 的对角应力张量 $\\sigma$。\n2. 根据指定的旋转轴和角度 $\\theta$，构造 $3 \\times 3$ 的真正交旋转张量 $Q$。\n3. 将参考法向量 $n^{(0)}$ 转换为一个三维向量。\n4. 通过矩阵向量乘积 $n = Q n^{(0)}$ 计算正确旋转后的法向量 $n$。\n5. 通过矩阵向量乘积 $s = \\sigma n$ 计算正确的面力矢量 $s$。\n6. 提取旋转张量 $Q$ 的对角线元素。\n7. 通过对 $Q$ 的对角线元素和参考法向量 $n^{(0)}$ 进行逐元素乘积，计算错误的法向量 $n^{\\mathrm{bug}}$。\n8. 通过矩阵向量乘积 $s^{\\mathrm{bug}} = \\sigma n^{\\mathrm{bug}}$ 计算错误的面力矢量 $s^{\\mathrm{bug}}$。\n9. 计算向量差 $s - s^{\\mathrm{bug}}$。\n10. 计算差向量的欧几里得范数以求得残差 $r$。\n11. 将结果四舍五入到六位小数并存储。\n\n将此过程应用于所提供的五个测试用例中的每一个，并将所得残差汇编成一个最终列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the diagnostic residual for five test cases.\n    \"\"\"\n\n    def compute_residual(sigma_diag, rot_axis, theta, n0_tuple):\n        \"\"\"\n        Computes the residual for a single test case.\n\n        Args:\n            sigma_diag (tuple): Diagonal elements (s11, s22, s33) of the stress tensor.\n            rot_axis (str): The axis of rotation ('x', 'y', or 'z').\n            theta (float): The angle of rotation in radians.\n            n0_tuple (tuple): The components of the reference normal vector n_0.\n\n        Returns:\n            float: The computed residual r, rounded to six decimal places.\n        \"\"\"\n        # 1. Construct the diagonal stress tensor sigma\n        sigma = np.diag(sigma_diag)\n        \n        # Convert reference normal to a numpy array\n        n0 = np.array(n0_tuple, dtype=float)\n\n        # 2. Construct the proper orthogonal rotation tensor Q\n        c, s = np.cos(theta), np.sin(theta)\n        if rot_axis == 'x':\n            Q = np.array([\n                [1, 0, 0],\n                [0, c, -s],\n                [0, s, c]\n            ])\n        elif rot_axis == 'y':\n            Q = np.array([\n                [c, 0, s],\n                [0, 1, 0],\n                [-s, 0, c]\n            ])\n        elif rot_axis == 'z':\n            Q = np.array([\n                [c, -s, 0],\n                [s, c, 0],\n                [0, 0, 1]\n            ])\n        else:\n            raise ValueError(\"Invalid rotation axis specified.\")\n\n        # 3. Compute the correctly rotated normal and the correct traction\n        n = Q @ n0\n        s = sigma @ n\n\n        # 4. Compute the buggy rotated normal and the corresponding traction\n        # n_j^bug = Q_jj * n0_j (no summation) is an element-wise product\n        # of the diagonal of Q with the vector n0.\n        n_bug = np.diag(Q) * n0\n        s_bug = sigma @ n_bug\n\n        # 5. Compute the diagnostic residual r\n        residual = np.linalg.norm(s - s_bug)\n        \n        return residual\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'sigma_diag': (10, 20, 30), 'rot_axis': 'z', 'theta': np.pi/4, 'n0_tuple': (1, 0, 0)},\n        {'sigma_diag': (15, 25, 35), 'rot_axis': 'z', 'theta': 0, 'n0_tuple': (0, 1, 0)},\n        {'sigma_diag': (12, 7, 5), 'rot_axis': 'y', 'theta': 0.5, 'n0_tuple': (0, 0, 0)},\n        {'sigma_diag': (1000, 1, 1), 'rot_axis': 'z', 'theta': np.pi/2, 'n0_tuple': (1, 0, 0)},\n        {'sigma_diag': (5, 5, 0), 'rot_axis': 'z', 'theta': 0.1, 'n0_tuple': (1/np.sqrt(2), 1/np.sqrt(2), 0)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_residual(**case)\n        results.append(result)\n\n    # Format the results to six decimal places\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3566792"}, {"introduction": "除了简单的缩并，指标记法的威力在于其操纵张量指标的严谨规则。区分求和的哑指标（dummy indices）和不求和的自由指标（free indices）是一条至关重要的规则，误用会导致根本上错误的物理结果。本练习通过计算材料的体积模量（$K$）来探讨这一概念，你将比较从四阶弹性张量（$C_{ijkl}$）得到的正确缩并（$C_{iikk}$）与一个不正确的缩并（$C_{ijij}$），从而直接量化指标记法的微小改变如何导致物理上无意义的结果，加深对指标“语法”重要性的认识。[@problem_id:3566793]", "problem": "设计并实现一个独立的程序，为计算岩土力学中使用的一类三维线性弹性材料，计算正确的体积模量和一个有意错误计算的体积模量，以揭示爱因斯坦求和约定中自由指标与哑指标之间的区别。程序必须遵守以下数学和物理规范。\n\n从静水加载下的小应变线性弹性基本本构关系开始，\n$$\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl},$$\n其中 $\\sigma_{ij}$ 是柯西应力张量，$C_{ijkl}$ 是四阶弹性（刚度）张量，$\\varepsilon_{kl}$ 是小应变张量。平均应力 $p$ 定义为\n$$p = \\frac{1}{3}\\,\\sigma_{ii},$$\n体积应变为\n$$\\varepsilon_v = \\varepsilon_{kk}.$$\n在静水加载下，应变为纯球形：\n$$\\varepsilon_{kl} = \\frac{\\varepsilon_v}{3}\\,\\delta_{kl},$$\n其中 $\\delta_{kl}$ 是克罗内克符号。体积模量 $K$ 定义为\n$$K = \\frac{p}{\\varepsilon_v}.$$\n\n您的实现必须：\n- 为一类由各向同性基底和偏应力各向异性扰动组成的材料构建 $C_{ijkl}$：\n  $$C_{ijkl} = \\lambda\\,\\delta_{ij}\\delta_{kl} + \\mu\\,(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + \\gamma\\,S_{ij}S_{kl},$$\n  其中 $\\lambda$ 是第一拉梅参数，$\\mu$ 是剪切模量，$\\gamma$ 是一个非负标量振幅，$S_{ij}$ 是一个对称的偏二阶张量，满足 $S_{ii}=0$。该扰动保留了次对称性和主对称性，并代表了一种物理上合理的偏应力刚化，在正确缩并时不会对纯球形应变产生贡献。\n- 使用上述定义计算正确的体积模量 $K$（应用静水应变并执行正确的张量缩并）。\n- 通过在缩并过程中交换哑指标的位置，来计算一个有意误用的体积模量 $K_{\\text{wrong}}$，即在与克罗内克符号耦合时，将张量在 $(i,j)$ 上而不是在 $(k,l)$ 上进行收缩。这个不正确的步骤会产生一个与 $C_{ijij}$ 成正比的量，而这对于球形应变来说并非正确的缩并方式。\n- 通过计算相对误差来量化误用的影响，结果以小数（而非百分比）表示，\n  $$e = \\frac{K_{\\text{wrong}} - K}{K},$$\n  适用于每个测试用例。\n\n单位和数值规范：\n- 仅报告相对误差 $e$，以无量纲小数形式表示。不包括百分号。\n- 在内部计算中，弹性模量使用吉帕斯卡（GPa），体积应变大小 $\\varepsilon_v$ 为 $10^{-3}$（无量纲）。尽管 $K$ 和 $K_{\\text{wrong}}$ 的单位是吉帕斯卡，但最终报告的 $e$ 是无量纲的。\n- 本问题不涉及角度。\n\n测试套件：\n为以下参数集提供结果，每组由 $(\\lambda,\\mu,\\gamma,S)$ 定义，其中 $\\lambda$、$\\mu$ 和 $\\gamma$ 的单位为 $\\mathrm{GPa}$，$S$ 是一个 $3\\times 3$ 的对称偏张量：\n1. 理想情况下的各向同性材料：$\\lambda = 30$, $\\mu = 20$, $\\gamma = 0$, $S = \\mathbf{0}$。\n2. 近不可压缩的各向同性基底：$\\lambda = 1000$, $\\mu = 30$, $\\gamma = 0$, $S = \\mathbf{0}$。\n3. 各向同性基底加上偏应力各向异性：\n   - $\\lambda = 30$, $\\mu = 20$, $\\gamma = 50$。\n   - $S = \\begin{bmatrix} 2  0.5  -0.5 \\\\ 0.5  -1  0 \\\\ -0.5  0  -1 \\end{bmatrix}$，该张量是对称且偏的，因为 $S_{11}+S_{22}+S_{33} = 2 + (-1) + (-1) = 0$。\n4. 纯偏的各向同性基底：$\\lambda = 0$, $\\mu = 30$, $\\gamma = 0$, $S = \\mathbf{0}$。\n5. 纯体积的各向同性基底：$\\lambda = 50$, $\\mu = 0$, $\\gamma = 0$, $S = \\mathbf{0}$。\n\n最终输出格式：\n你的程序应该生成单行输出，其中包含五个案例的相对误差，以逗号分隔并用方括号括起来，例如，\n$$[\\text{e}_1,\\text{e}_2,\\text{e}_3,\\text{e}_4,\\text{e}_5].$$\n不应打印任何其他文本。", "solution": "问题要求设计一个程序，为一类特定的各向异性线性弹性材料计算正确计算的体积模量 $K$ 与一个错误计算的体积模量 $K_{\\text{wrong}}$ 之间的相对误差。本练习旨在强调张量代数中正确放置指标和遵循求和约定（特别是在连续介质力学中普遍使用的爱因斯坦求和约定）的至关重要性。\n\n### 步骤1：问题陈述的验证\n\n对问题陈述进行严格验证。\n\n**1.1. 提取的已知条件：**\n- 本构关系：$\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}$\n- 平均应力定义：$p = \\frac{1}{3}\\,\\sigma_{ii}$\n- 体积应变定义：$\\varepsilon_v = \\varepsilon_{kk}$\n- 静水应变条件：$\\varepsilon_{kl} = \\frac{\\varepsilon_v}{3}\\,\\delta_{kl}$\n- 体积模量定义：$K = \\frac{p}{\\varepsilon_v}$\n- 刚度张量形式：$C_{ijkl} = \\lambda\\,\\delta_{ij}\\delta_{kl} + \\mu\\,(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + \\gamma\\,S_{ij}S_{kl}$\n  - 其中 $\\lambda$、$\\mu$、$\\gamma$ 是标量参数。\n  - $S_{ij}$ 是一个对称、偏（$S_{ii}=0$）二阶张量。\n- 错误的体积模量 $K_{\\text{wrong}}$ 与缩并 $C_{ijij}$ 成正比。\n- 相对误差定义：$e = \\frac{K_{\\text{wrong}} - K}{K}$\n- 用于上下文的应变数值：$\\varepsilon_v = 10^{-3}$\n- 测试用例：提供了五组参数 $(\\lambda, \\mu, \\gamma, S)$。\n\n**1.2. 依据标准进行验证：**\n- **科学依据：** 该问题牢固地植根于线性弹性理论，该理论是固体力学和岩土力学的基石。本构律、应力和应变不变量的定义，以及各向异性刚度张量的形式都是标准且物理上合理的。\n- **适定性：** 问题定义明确。为每个案例提供了所有必要的方程和参数，能够得出一个唯一、稳定且有意义的解（相对误差 $e$）。\n- **客观性：** 语言正式、数学化，并且没有主观性。\n- **完整性和一致性：** 问题是自洽的。对错误计算的描述，虽然是为了说明一个概念性错误，但其规定“与 $C_{ijij}$ 成正比”足够明确，足以进行唯一的公式化。不存在矛盾。\n\n**1.3. 结论：**\n问题被判定为**有效**。它在科学上是合理的，适定的，并且为获得唯一解提供了所有必需信息。\n\n### 步骤2：数学推导与求解设计\n\n任务的核心是从所提供的定义中推导出 $K$ 和 $K_{\\text{wrong}}$ 的解析表达式。\n\n**2.1. 正确体积模量 ($K$) 的推导**\n\n体积模量 $K$ 在静水加载条件下，将平均应力 $p$ 与体积应变 $\\varepsilon_v$ 联系起来。\n\n1. 将静水应变 $\\varepsilon_{kl} = \\frac{\\varepsilon_v}{3}\\,\\delta_{kl}$ 代入本构方程 $\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}$：\n$$ \\sigma_{ij} = C_{ijkl} \\left( \\frac{\\varepsilon_v}{3}\\,\\delta_{kl} \\right) = \\frac{\\varepsilon_v}{3} C_{ijkl}\\,\\delta_{kl} $$\n对重复指标 $l$ 的爱因斯坦求和会将张量 $C_{ijkl}$ 与 $\\delta_{kl}$ 进行缩并，这实际上等效于用指标 $k$ 替换指标 $l$。\n$$ \\sigma_{ij} = \\frac{\\varepsilon_v}{3} C_{ijkk} $$\n\n2. 通过取应力张量 $\\sigma_{ii}$ 的迹并除以3来计算平均应力 $p$：\n$$ p = \\frac{1}{3}\\sigma_{ii} = \\frac{1}{3} \\left( \\frac{\\varepsilon_v}{3} C_{iikk} \\right) = \\frac{\\varepsilon_v}{9} C_{iikk} $$\n此处，第二次缩并发生在重复指标 $i$ 上。项 $C_{iikk}$ 是四阶张量 $C_{ijkl}$ 经过两次缩并后得到的标量。\n\n3. 通过对给定的刚度张量 $C_{ijkl} = \\lambda\\,\\delta_{ij}\\delta_{kl} + \\mu\\,(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + \\gamma\\,S_{ij}S_{kl}$ 进行缩并来确定标量 $C_{iikk}$ 的表达式。我们对 $i$ 和 $k$ 同时进行求和。注意在 $n=3$ 维空间中，$\\delta_{aa} = 3$。\n- 第一项：$\\lambda\\,\\delta_{ii}\\delta_{kk} \\rightarrow \\lambda \\cdot (\\sum_i \\delta_{ii}) \\cdot (\\sum_k \\delta_{kk})$ 是不正确的。该记法意味着 $\\lambda \\sum_i \\sum_k \\delta_{ii}\\delta_{kk}$，其中 $\\delta_{ii}$ 和 $\\delta_{kk}$ 本身就是和。正确的解释是 $\\lambda(\\delta_{ii})(\\delta_{kk}) = \\lambda(3)(3) = 9\\lambda$。\n- 第二项：$\\mu\\,(\\delta_{ik}\\delta_{ik} + \\delta_{ik}\\delta_{ki}) = \\mu\\,(\\delta_{kk} + \\delta_{ii}) = \\mu\\,(3+3) = 6\\mu$。\n- 第三项：$\\gamma\\,S_{ii}S_{kk}$。由于 $S$ 是偏张量，其迹 $S_{ii} = S_{11}+S_{22}+S_{33} = 0$。因此，$\\gamma\\,S_{ii}S_{kk} = \\gamma \\cdot 0 \\cdot 0 = 0$。\n\n综合各项，我们得到：\n$$ C_{iikk} = 9\\lambda + 6\\mu + 0 = 9\\lambda + 6\\mu $$\n\n4. 将此结果代回 $p$ 的表达式并求解 $K$：\n$$ p = \\frac{\\varepsilon_v}{9} (9\\lambda + 6\\mu) = \\varepsilon_v (\\lambda + \\frac{2}{3}\\mu) $$\n$$ K = \\frac{p}{\\varepsilon_v} = \\lambda + \\frac{2}{3}\\mu $$\n这就是著名的各向同性材料体积模量的关系式。各向异性项 $\\gamma\\,S_{ij}S_{kl}$ 正确地对体积模量没有贡献，因为它代表了纯粹的偏应力刚化。\n\n**2.2. 误用体积模量 ($K_{\\text{wrong}}$) 的推导**\n\n问题陈述指出，$K_{\\text{wrong}}$ 是由于指标误用而产生的，其结果是一个与 $C_{ijij}$ 成正比的量。我们使用与推导 $K$ 时找到的相同比例常数 $1/9$ 来定义 $K_{\\text{wrong}}$，以确保这两个量具有可比性。\n$$ K_{\\text{wrong}} = \\frac{1}{9}C_{ijij} $$\n现在我们通过对 $C_{ijkl}$ 的第一和第三个指标（$k=i$）以及第二和第四个指标（$l=j$）进行缩并来计算标量 $C_{ijij}$，其中隐含了对 $i$ 和 $j$ 的求和。\n- 第一项：$\\lambda\\,\\delta_{ij}\\delta_{ij} = \\lambda\\,\\delta_{ii} = 3\\lambda$。\n- 第二项：$\\mu\\,(\\delta_{ii}\\delta_{jj} + \\delta_{ij}\\delta_{ji}) = \\mu\\,(3 \\cdot 3 + \\delta_{ii}) = \\mu\\,(9+3) = 12\\mu$。\n- 第三项：$\\gamma\\,S_{ij}S_{ij} = \\gamma \\sum_{i,j=1}^3 (S_{ij})^2 = \\gamma \\|S\\|_F^2$，其中 $\\|S\\|_F^2$ 是 $S$ 的矩阵表示的弗罗贝尼乌斯范数的平方。\n\n综合这些项得到：\n$$ C_{ijij} = 3\\lambda + 12\\mu + \\gamma \\|S\\|_F^2 $$\n因此，误用体积模量的表达式为：\n$$ K_{\\text{wrong}} = \\frac{1}{9} (3\\lambda + 12\\mu + \\gamma \\|S\\|_F^2) = \\frac{1}{3}\\lambda + \\frac{4}{3}\\mu + \\frac{\\gamma}{9}\\|S\\|_F^2 $$\n\n**2.3. 最终计算**\n\n程序将为每个测试用例实现以下推导出的公式：\n1. 计算正确的体积模量：$K = \\lambda + \\frac{2}{3}\\mu$。\n2. 计算 $S$ 的弗罗贝尼乌斯范数的平方：$\\|S\\|_F^2 = \\sum_{i,j} S_{ij}^2$。\n3. 计算错误的体积模量：$K_{\\text{wrong}} = \\frac{1}{3}\\lambda + \\frac{4}{3}\\mu + \\frac{\\gamma}{9}\\|S\\|_F^2$。\n4. 计算相对误差：$e = \\frac{K_{\\text{wrong}} - K}{K}$。\n\n对于给定的测试用例，分母 $K$ 永远不为零，因此除法总是有定义的。数值 $\\varepsilon_v$ 对于计算相对误差 $e$ 是无关的，因为它会被约掉。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the correct and miscomputed bulk modulus to find the relative error\n    for a series of test cases in computational geomechanics.\n    \"\"\"\n\n    # Test suite with parameters (lambda, mu, gamma, S).\n    # lambda, mu, gamma are in GPa. S is a 3x3 symmetric deviatoric tensor.\n    test_cases = [\n        {\n            # Case 1: Happy path isotropic material\n            \"lambda\": 30.0, \"mu\": 20.0, \"gamma\": 0.0, \n            \"S\": np.zeros((3, 3))\n        },\n        {\n            # Case 2: Near-incompressible isotropic baseline\n            \"lambda\": 1000.0, \"mu\": 30.0, \"gamma\": 0.0, \n            \"S\": np.zeros((3, 3))\n        },\n        {\n            # Case 3: Isotropic baseline plus deviatoric anisotropy\n            \"lambda\": 30.0, \"mu\": 20.0, \"gamma\": 50.0,\n            \"S\": np.array([[2.0, 0.5, -0.5], \n                           [0.5, -1.0, 0.0], \n                           [-0.5, 0.0, -1.0]])\n        },\n        {\n            # Case 4: Purely deviatoric isotropic baseline\n            \"lambda\": 0.0, \"mu\": 30.0, \"gamma\": 0.0, \n            \"S\": np.zeros((3, 3))\n        },\n        {\n            # Case 5: Purely volumetric isotropic baseline\n            \"lambda\": 50.0, \"mu\": 0.0, \"gamma\": 0.0, \n            \"S\": np.zeros((3, 3))\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lam = case[\"lambda\"]\n        mu = case[\"mu\"]\n        gamma = case[\"gamma\"]\n        S_tensor = case[\"S\"]\n\n        # Calculate the correct bulk modulus, K.\n        # K = lambda + (2/3)*mu\n        k_correct = lam + (2.0 / 3.0) * mu\n\n        # Calculate the squared Frobenius norm of the tensor S.\n        # ||S||_F^2 = sum(S_ij^2)\n        s_norm_sq = np.sum(S_tensor**2)\n\n        # Calculate the intentionally misused bulk modulus, K_wrong.\n        # K_wrong = (1/9) * (3*lambda + 12*mu + gamma * ||S||_F^2)\n        k_wrong = (1.0 / 9.0) * (3.0 * lam + 12.0 * mu + gamma * s_norm_sq)\n\n        # Calculate the relative error e = (K_wrong - K) / K.\n        # The denominator K is non-zero for all given test cases.\n        if np.isclose(k_correct, 0):\n            # This case does not occur in the test suite but is a good practice.\n            # If K is 0, relative error is infinity if K_wrong is non-zero,\n            # or undefined/0 if K_wrong is also 0.\n            # We assume K > 0 for geomechanical materials.\n            # For the purpose of this problem, we let the standard division handle it.\n            # In a real scenario, this would require specific handling.\n            pass\n        \n        relative_error = (k_wrong - k_correct) / k_correct\n        results.append(str(relative_error))\n\n    # Print the final output in the specified format: [e_1,e_2,e_3,e_4,e_5]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3566793"}, {"introduction": "涉及代数和微积分的张量运算是连续介质力学的核心。制造解法（Method of Manufactured Solutions, MMS）是综合这些技能的一个强大应用，也是验证复杂模拟软件正确性的标准技术。在这个综合性练习中，你将从一个选定的“制造”位移场 $u_i(x_j)$ 出发，应用梯度、对称化、缩并和散度等一系列基本张量运算，推导出相应的体力场 $b_i$。此练习提供了一个从数学理论到计算代码验证实用工具的完整动手实践流程。[@problem_id:3566830]", "problem": "构建一个独立的程序，该程序使用张量索引表示法和爱因斯坦求和约定，在小应变线性弹性理论框架下为计算地球力学实现制造解法（Method of Manufactured Solutions, MMS）。目标是从核心定义出发，推导出一个算法，在给定一个多项式位移场 $u_i(x_j)$ 和一个常数四阶刚度张量 $C_{ijkl}$ 的情况下，计算应力场 $\\sigma_{ij}$ 及其散度，以生成体力 $b_i$。所有量均为无量纲。程序必须应用以下基本定义和定律。\n\n基本原理：\n1. 小应变张量定义为 $ \\varepsilon_{ij} = \\dfrac{1}{2} \\left( u_{i,j} + u_{j,i} \\right) $，其中 $u_{i,j} = \\dfrac{\\partial u_i}{\\partial x_j}$ 且遵循爱因斯坦求和约定。\n2. 一般各向异性材料的线弹性本构关系（胡克定律）由 $ \\sigma_{ij} = C_{ijkl} \\varepsilon_{kl} $ 给出，其中 $C_{ijkl}$ 是一个常数四阶刚度张量，遵循次对称性 $C_{ijkl} = C_{jikl} = C_{ijlk}$ 和主对称性 $C_{ijkl} = C_{klij}$。\n3. 应力的散度给出了在静态平衡中维持制造位移场所需的体力：$ b_i = \\sigma_{ij,j} = \\dfrac{\\partial \\sigma_{ij}}{\\partial x_j} $。\n\n您的程序必须：\n- 将 $u_i(x_j)$ 表示为多元单项式的有限和。每个单项式形式为 $x_1^{\\alpha} x_2^{\\beta} x_3^{\\gamma}$，并带有一个位移分量的系数向量 $c_i$，即 $u_i(x_j) = \\sum_{(\\alpha,\\beta,\\gamma)} c_i^{(\\alpha,\\beta,\\gamma)} x_1^{\\alpha} x_2^{\\beta} x_3^{\\gamma}$。所有指数和系数均指定为有理数或整数值。\n- 对这些多项式解析地计算一阶导数 $u_{i,j}$ 和二阶导数 $u_{i,jk} = \\dfrac{\\partial^2 u_i}{\\partial x_j \\partial x_k}$。\n- 使用爱因斯坦求和约定来组合 $ \\varepsilon_{ij} = \\dfrac{1}{2}(u_{i,j} + u_{j,i}) $，然后是 $ \\sigma_{ij} = C_{ijkl} \\varepsilon_{kl} $，最后是 $ b_i = \\sigma_{ij,j} $。\n- 支持 $C_{ijkl}$ 的两种构造方式：\n  1. 使用 Lamé 参数 $ \\lambda $ 和 $ \\mu $ 的各向同性刚度，通过 $ C_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu \\left( \\delta_{ik} \\delta_{jl} + \\delta_{il} \\delta_{jk} \\right) $，其中 $ \\delta_{ij} $ 是 Kronecker 符号。\n  2. 以 Voigt 形式的 $6 \\times 6$ 矩阵 $C^{(6)}$ 提供的一般对称正定刚度，该刚度在张量应变映射（而非工程应变）中解释，其索引配对为 $ (11) \\rightarrow 0 $、$ (22) \\rightarrow 1 $、$ (33) \\rightarrow 2 $、$ (23) \\rightarrow 3 $、$ (13) \\rightarrow 4 $、$ (12) \\rightarrow 5 $，使得 $ C_{ijkl} = C^{(6)}_{I J} $，其中 $I$ 和 $J$ 是使用对称对应关系为 $(i,j)$ 和 $(k,l)$ 映射的配对索引。\n\n测试套件：\n提供并评估以下四个测试案例。对于每个案例，计算在指定点 $x_j$ 处的体力 $b_i$，并返回数值向量 $[b_1,b_2,b_3]$。\n\n- 案例 A（通用多项式，各向同性）：使用 Lamé 参数 $ \\lambda = 2 $、$ \\mu = 3 $。令\n  $ u_1 = 2 x_1^2 - x_1 x_2 + 3 x_3 $，\n  $ u_2 = - x_1 x_3 + x_2^2 + 2 x_2 $，\n  $ u_3 = x_2 x_3 + x_3^2 - x_1 $。\n  在点 $ x = (1,-1,2) $ 处进行评估。\n\n- 案例 B（刚性旋转，各向同性）：使用 Lamé 参数 $ \\lambda = 2 $、$ \\mu = 3 $。令刚性旋转为 $ u_i = \\epsilon_{ijk} \\Omega_j x_k $，其中角速度 $ \\boldsymbol{\\Omega} = (0.1,-0.2,0.3) $，$ \\epsilon_{ijk} $ 是 Levi-Civita 符号。具体为：\n  $ u_1 = \\Omega_2 x_3 - \\Omega_3 x_2 $，\n  $ u_2 = \\Omega_3 x_1 - \\Omega_1 x_3 $，\n  $ u_3 = \\Omega_1 x_2 - \\Omega_2 x_1 $。\n  在点 $ x = (2,-3,1) $ 处进行评估。\n\n- 案例 C（均匀应变，各向同性）：使用 Lamé 参数 $ \\lambda = 2 $、$ \\mu = 3 $。令 $ u_i = A_{ij} x_j $，其中系数为常数\n  $ A = \\begin{bmatrix} 0.05  0.02  0 \\\\ 0.02  -0.01  0.01 \\\\ 0  0.01  0.03 \\end{bmatrix} $。\n  在点 $ x = (3,-1,4) $ 处进行评估。\n\n- 案例 D（三次多项式，各向异性对称正定刚度）：构造 $ C^{(6)} = M^\\top M + 0.5 I $，其中\n  $ M = \\begin{bmatrix}\n  2  -1  0  0  1  2\\\\\n  0  3  -1  1  0  -2\\\\\n  1  0  2  -2  1  0\\\\\n  -1  2  0  1  -1  1\\\\\n  0  0  1  0  2  -1\\\\\n  2  -1  0  1  0  3\n  \\end{bmatrix} $，$ I $ 是 $6 \\times 6$ 的单位矩阵。使用上述张量应变 Voigt 配对，将 $ C^{(6)} $ 映射到 $ C_{ijkl} $。令\n  $ u_1 = x_1^3 + 0.5 x_1 x_2 x_3 $，\n  $ u_2 = x_2^3 - x_1^2 x_2 $，\n  $ u_3 = x_3^3 + x_2 x_3^2 $。\n  在点 $ x = (0.5,-0.7,0.9) $ 处进行评估。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来。列表中的每个元素本身是针对一个测试案例的三个浮点数列表 $[b_1,b_2,b_3]$。例如，使用格式 $ [ [b_1^{(A)},b_2^{(A)},b_3^{(A)}], [b_1^{(B)},b_2^{(B)},b_3^{(B)}], [b_1^{(C)},b_2^{(C)},b_3^{(C)}], [b_1^{(D)},b_2^{(D)},b_3^{(D)}] ] $。不需要单位，因为所有量都是无量纲的，并且通过基于 Levi-Civita 符号的旋转定义，角度已经隐含为弧度，无需明确的角度单位。每个结果必须是浮点数列表。\n\n程序必须是自包含的，且不得需要任何用户输入。它必须从第一性原理实现上述推导，并精确生成指定的输出格式。", "solution": "在尝试解决方案之前，需对问题进行验证。\n\n### 第 1 步：提取已知条件\n- **应变-位移关系：** 小应变张量为 $ \\varepsilon_{ij} = \\dfrac{1}{2} \\left( u_{i,j} + u_{j,i} \\right) $，其中 $u_{i,j} = \\dfrac{\\partial u_i}{\\partial x_j}$ 且遵循爱因斯坦求和约定。\n- **本构定律：** 胡克定律为 $ \\sigma_{ij} = C_{ijkl} \\varepsilon_{kl} $。$C_{ijkl}$ 是一个常数四阶刚度张量。\n- **刚度张量对称性：** $C_{ijkl}$ 遵循次对称性 ($C_{ijkl} = C_{jikl} = C_{ijlk}$) 和主对称性 ($C_{ijkl} = C_{klij}$)。\n- **平衡条件：** 静态平衡的体力为 $ b_i = \\sigma_{ij,j} = \\dfrac{\\partial \\sigma_{ij}}{\\partial x_j} $。\n- **位移场形式：** $u_i(x_j) = \\sum_{(\\alpha,\\beta,\\gamma)} c_i^{(\\alpha,\\beta,\\gamma)} x_1^{\\alpha} x_2^{\\beta} x_3^{\\gamma}$。\n- **各向同性刚度：** $ C_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu \\left( \\delta_{ik} \\delta_{jl} + \\delta_{il} \\delta_{jk} \\right) $。\n- **各向异性刚度：** $C_{ijkl}$ 源自一个 $6 \\times 6$ 的 Voigt 矩阵 $C^{(6)}$，使用索引映射 $ (11) \\rightarrow 0 $、$ (22) \\rightarrow 1 $、$ (33) \\rightarrow 2 $、$ (23) \\rightarrow 3 $、$ (13) \\rightarrow 4 $、$ (12) \\rightarrow 5 $ (对称对)。\n- **测试案例 A：** 各向同性，$\\lambda = 2, \\mu = 3$。$ u_1 = 2 x_1^2 - x_1 x_2 + 3 x_3 $，$ u_2 = - x_1 x_3 + x_2^2 + 2 x_2 $，$ u_3 = x_2 x_3 + x_3^2 - x_1 $。在 $ x = (1,-1,2) $ 处评估。\n- **测试案例 B：** 各向同性，$\\lambda = 2, \\mu = 3$。刚性旋转 $ u_i = \\epsilon_{ijk} \\Omega_j x_k $，其中 $ \\boldsymbol{\\Omega} = (0.1,-0.2,0.3) $。在 $ x = (2,-3,1) $ 处评估。\n- **测试案例 C：** 各向同性，$\\lambda = 2, \\mu = 3$。均匀应变源于 $ u_i = A_{ij} x_j $，其中 $ A = \\begin{bmatrix} 0.05  0.02  0 \\\\ 0.02  -0.01  0.01 \\\\ 0  0.01  0.03 \\end{bmatrix} $。在 $ x = (3,-1,4) $ 处评估。\n- **测试案例 D：** 各向异性，其中 $ C^{(6)} = M^\\top M + 0.5 I $，$M$ 是给定的 $6 \\times 6$ 矩阵。位移场为 $ u_1 = x_1^3 + 0.5 x_1 x_2 x_3 $，$ u_2 = x_2^3 - x_1^2 x_2 $，$ u_3 = x_3^3 + x_2 x_3^2 $。在 $ x = (0.5,-0.7,0.9) $ 处评估。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据：** 该问题基于标准的线性弹性理论，这是连续介质力学和地球力学的基石。所有方程和概念都是基础且完善的。制造解法（MMS）是计算科学中的一种标准验证技术。该问题在科学上是合理的。\n- **良定性：** 所有输入（$u_i$、$C_{ijkl}$、评估点 $x$）都已指定，并且期望的输出（$b_i$）是通过一系列确定性的数学运算推导出来的。每个案例都存在唯一解。该问题是良定的。\n- **客观性：** 问题使用精确、无歧义的数学符号和术语陈述。它不含主观论断。\n- **完整性与一致性：** 问题为每个测试案例提供了所有必要的数据和定义。各向异性刚度张量 $ C^{(6)} = M^\\top M + 0.5 I $ 的构造确保了其对称性和正定性，这在物理上是必需的。该问题是完整且内部一致的。\n- **其他缺陷：** 问题没有表现出任何其他缺陷，例如不切实际、不可形式化或过于琐碎。事实上，案例 B 和 C 提供了非平凡的物理校验（刚体运动和均匀应变应导致体力为零），这表明问题设计得很好。\n\n### 第 3 步：结论与行动\n问题是**有效**的。将开发一个解决方案。\n\n### 推导与算法设计\n\n目标是计算维持一个制造位移场 $u_i(x_j)$ 在静态平衡中所需的体力向量 $b_i$。$b_i$ 的控制方程从第一性原理推导得出。\n\n从体力定义为应力张量的散度开始：\n$$ b_i = \\sigma_{ij,j} = \\frac{\\partial \\sigma_{ij}}{\\partial x_j} $$\n代入胡克定律 $\\sigma_{ij} = C_{ijkl} \\varepsilon_{kl}$：\n$$ b_i = \\frac{\\partial}{\\partial x_j} (C_{ijkl} \\varepsilon_{kl}) $$\n由于刚度张量 $C_{ijkl}$ 是给定的常数，可以将其移到导数之外：\n$$ b_i = C_{ijkl} \\frac{\\partial \\varepsilon_{kl}}{\\partial x_j} = C_{ijkl} \\varepsilon_{kl,j} $$\n接下来，代入小应变定义 $\\varepsilon_{kl} = \\frac{1}{2}(u_{k,l} + u_{l,k})$：\n$$ b_i = C_{ijkl} \\frac{\\partial}{\\partial x_j} \\left[ \\frac{1}{2}(u_{k,l} + u_{l,k}) \\right] = \\frac{1}{2} C_{ijkl} (u_{k,lj} + u_{l,kj}) $$\n该表达式涉及位移场的二阶偏导数 $u_{k,lj} = \\frac{\\partial^2 u_k}{\\partial x_l \\partial x_j}$。我们可以利用刚度张量的次对称性，特别是 $C_{ijkl} = C_{ijlk}$，来简化此表达式。考虑括号中的第二项：\n$$ C_{ijkl} u_{l,kj} $$\n通过重命名哑下标 ($k \\leftrightarrow l$)，此项变为：\n$$ C_{ijlk} u_{k,lj} $$\n利用次对称性 $C_{ijlk} = C_{ijkl}$，这等价于第一项：\n$$ C_{ijlk} u_{k,lj} = C_{ijkl} u_{k,lj} $$\n因此，$b_i$ 表达式中的两项是相同的。方程简化为：\n$$ b_i = \\frac{1}{2} C_{ijkl} (u_{k,lj} + u_{k,lj}) = C_{ijkl} u_{k,lj} $$\n这个最终的紧凑方程 $b_i = C_{ijkl} u_{k,lj}$ 构成了我们算法的基础。它通过刚度张量将体力与位移场的二阶导数优雅地联系起来。爱因斯坦求和约定意味着对索引 $j, k, l$ 从 1 到 3 进行求和。\n\n算法如下：\n1.  **表示多项式：** 位移场分量 $u_i$ 是多元多项式，表示为项的集合，每个项包含一个系数和 $(x_1, x_2, x_3)$ 的指数元组。\n2.  **解析微分：** 实现一个例程来解析计算这些多项式的一阶和二阶偏导数。由于位移场是多项式，其二阶偏导数是连续的，因此微分顺序无关紧要 ($u_{k,lj} = u_{k,jl}$)。\n3.  **刚度张量构造：**\n    *   对于各向同性材料，张量 $C_{ijkl}$ 由 Lamé 参数 $\\lambda$ 和 $\\mu$ 以及 Kronecker 符号 $\\delta_{ij}$ 根据公式 $ C_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu \\left( \\delta_{ik} \\delta_{jl} + \\delta_{il} \\delta_{jk} \\right) $ 构造。\n    *   对于各向异性材料，首先计算 $6 \\times 6$ 的 Voigt 矩阵 $C^{(6)}$。然后，使用指定的张量应变 Voigt 索引映射组装完整的 $3 \\times 3 \\times 3 \\times 3$ 张量 $C_{ijkl}$。对于从 0 开始的索引，此映射为：$(0,0) \\to 0, (1,1) \\to 1, (2,2) \\to 2$，以及 $(1,2), (2,1) \\to 3$，$(0,2), (2,0) \\to 4$，$(0,1), (1,0) \\to 5$。\n4.  **体力计算：**\n    *   对于每个测试案例，通过在指定点 $x_p$ 评估符号二阶导数，计算二阶导数张量 $U_{klj} \\equiv u_{k,lj}(x_p)$。\n    *   通过将刚度张量与二阶导数张量进行缩并来计算体力向量 $b_i$：$b_i = C_{ijkl} U_{klj}$。此张量缩并可使用 `numpy.einsum` 高效执行。\n\n**典型案例验证：**\n- **案例 B（刚性旋转）：** 位移场 $u_i = \\epsilon_{ijk} \\Omega_j x_k$ 是位置 $x_k$ 的线性函数。因此，所有二阶导数 $u_{i,jk}$ 恒为零。公式 $b_i = C_{ijkl} u_{k,lj}$ 直接得出 $b_i = 0$。这在物理上是正确的，因为刚性旋转不产生应变，因此没有应力，也不需要体力来维持。\n- **案例 C（均匀应变）：** 位移场 $u_i = A_{ij} x_j$（$A_{ij}$ 为常数）也是 $x_j$ 的线性函数。与刚性旋转一样，所有二阶导数 $u_{i,jk}$ 都为零，导致 $b_i=0$。这在物理上也是正确的：均匀应变场导致恒定的应力场，其散度为零。\n\n这些解析校验确认了所推导公式的有效性，并为后续的数值实现提供了信心。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Method of Manufactured Solutions for small-strain linear elasticity.\n    \"\"\"\n\n    class Polynomial:\n        \"\"\"\n        Represents a multivariate polynomial as a sum of terms.\n        Each term is a tuple (coefficient, (exp_x1, exp_x2, exp_x3)).\n        \"\"\"\n        def __init__(self, terms_list):\n            # terms_list: e.g., [(2.0, (2,0,0)), (-1.0, (1,1,0))] for 2*x1^2 - x1*x2\n            self.terms = [term for term in terms_list if term[0] != 0]\n\n        def differentiate(self, var_index):\n            \"\"\"\n            Differentiates the polynomial with respect to a variable xi.\n            var_index: 0 for x1, 1 for x2, 2 for x3.\n            \"\"\"\n            new_terms = []\n            for coeff, exponents in self.terms:\n                exp = exponents[var_index]\n                if exp > 0:\n                    new_coeff = coeff * exp\n                    new_exponents = list(exponents)\n                    new_exponents[var_index] -= 1\n                    new_terms.append((new_coeff, tuple(new_exponents)))\n            if not new_terms:\n                return Polynomial([(0.0, (0, 0, 0))])\n            return Polynomial(new_terms)\n\n        def evaluate(self, x):\n            \"\"\"Evaluates the polynomial at a point x = (x1, x2, x3).\"\"\"\n            total = 0.0\n            for coeff, exponents in self.terms:\n                term_val = coeff\n                for i in range(3):\n                    if exponents[i] > 0:\n                        term_val *= x[i] ** exponents[i]\n                    elif exponents[i]  0: # Should not happen for polynomials\n                        if x[i] == 0: return np.nan\n                        term_val *= x[i] ** exponents[i]\n\n                total += term_val\n            return total\n\n    def get_isotropic_C(lam, mu):\n        \"\"\"Constructs the isotropic stiffness tensor C_ijkl.\"\"\"\n        delta = np.eye(3)\n        # C_ijkl = lam * delta_ij * delta_kl + mu * (delta_ik * delta_jl + delta_il * delta_jk)\n        C = (lam * np.einsum('ij,kl->ijkl', delta, delta) +\n             mu * (np.einsum('ik,jl->ijkl', delta, delta) +\n                   np.einsum('il,jk->ijkl', delta, delta)))\n        return C\n\n    def get_anisotropic_C(C6):\n        \"\"\"Constructs the anisotropic stiffness tensor C_ijkl from a 6x6 Voigt matrix.\"\"\"\n        voigt_map = {(0, 0): 0, (1, 1): 1, (2, 2): 2,\n                     (1, 2): 3, (2, 1): 3,\n                     (0, 2): 4, (2, 0): 4,\n                     (0, 1): 5, (1, 0): 5}\n        C = np.zeros((3, 3, 3, 3))\n        for i in range(3):\n            for j in range(3):\n                for k in range(3):\n                    for l in range(3):\n                        I = voigt_map[(i, j)]\n                        J = voigt_map[(k, l)]\n                        C[i, j, k, l] = C6[I, J]\n        return C\n\n    def compute_body_force(u_polys, C, point):\n        \"\"\"Computes the body force b_i = C_ijkl * u_k,lj at a given point.\"\"\"\n        u_deriv2 = np.zeros((3, 3, 3))\n        for k in range(3):\n            for l in range(3):\n                for j in range(3):\n                    # u_k,lj = d/dxj (d/dxl (u_k))\n                    deriv2_poly = u_polys[k].differentiate(l).differentiate(j)\n                    u_deriv2[k, l, j] = deriv2_poly.evaluate(point)\n        \n        # b_i = C_ijkl * u_k,lj\n        b = np.einsum('ijkl,klj->i', C, u_deriv2, optimize=True)\n        return b.tolist()\n\n    # --- Test Cases Setup ---\n    \n    # Case A: General polynomial, isotropic\n    u_A = [\n        Polynomial([(2.0, (2, 0, 0)), (-1.0, (1, 1, 0)), (3.0, (0, 0, 1))]),\n        Polynomial([(-1.0, (1, 0, 1)), (1.0, (0, 2, 0)), (2.0, (0, 1, 0))]),\n        Polynomial([(1.0, (0, 1, 1)), (1.0, (0, 0, 2)), (-1.0, (1, 0, 0))])\n    ]\n    C_A = get_isotropic_C(lam=2.0, mu=3.0)\n    point_A = (1, -1, 2)\n\n    # Case B: Rigid rotation, isotropic\n    Omega = np.array([0.1, -0.2, 0.3])\n    # u1 = O2*x3 - O3*x2 = -0.2*x3 + 0.3*x2\n    # u2 = O3*x1 - O1*x3 = 0.3*x1 - 0.1*x3\n    # u3 = O1*x2 - O2*x1 = 0.1*x2 - (-0.2)*x1 = 0.1*x2 + 0.2*x1\n    u_B = [\n        Polynomial([(Omega[1], (0, 0, 1)), (-Omega[2], (0, 1, 0))]),\n        Polynomial([(Omega[2], (1, 0, 0)), (-Omega[0], (0, 0, 1))]),\n        Polynomial([(Omega[0], (0, 1, 0)), (-Omega[1], (1, 0, 0))])\n    ]\n    C_B = get_isotropic_C(lam=2.0, mu=3.0)\n    point_B = (2, -3, 1)\n\n    # Case C: Uniform strain, isotropic\n    A = np.array([[0.05, 0.02, 0.0],\n                  [0.02, -0.01, 0.01],\n                  [0.0, 0.01, 0.03]])\n    u_C = [\n        Polynomial([(A[0, 0], (1, 0, 0)), (A[0, 1], (0, 1, 0)), (A[0, 2], (0, 0, 1))]),\n        Polynomial([(A[1, 0], (1, 0, 0)), (A[1, 1], (0, 1, 0)), (A[1, 2], (0, 0, 1))]),\n        Polynomial([(A[2, 0], (1, 0, 0)), (A[2, 1], (0, 1, 0)), (A[2, 2], (0, 0, 1))])\n    ]\n    C_C = get_isotropic_C(lam=2.0, mu=3.0)\n    point_C = (3, -1, 4)\n\n    # Case D: Cubic polynomials, anisotropic\n    M = np.array([\n        [2, -1, 0, 0, 1, 2],\n        [0, 3, -1, 1, 0, -2],\n        [1, 0, 2, -2, 1, 0],\n        [-1, 2, 0, 1, -1, 1],\n        [0, 0, 1, 0, 2, -1],\n        [2, -1, 0, 1, 0, 3]\n    ])\n    C6_D = M.T @ M + 0.5 * np.eye(6)\n    C_D = get_anisotropic_C(C6_D)\n    u_D = [\n        Polynomial([(1.0, (3, 0, 0)), (0.5, (1, 1, 1))]),\n        Polynomial([(1.0, (0, 3, 0)), (-1.0, (2, 1, 0))]),\n        Polynomial([(1.0, (0, 0, 3)), (1.0, (0, 1, 2))])\n    ]\n    point_D = (0.5, -0.7, 0.9)\n\n    test_cases = [\n        (u_A, C_A, point_A),\n        (u_B, C_B, point_B),\n        (u_C, C_C, point_C),\n        (u_D, C_D, point_D),\n    ]\n\n    results = []\n    for u_polys, C, point in test_cases:\n        b = compute_body_force(u_polys, C, point)\n        results.append(b)\n    \n    # Format the final output string exactly as requested\n    result_strings = [f\"[{','.join(f'{x:.10f}' for x in res)}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\n\nsolve()\n```", "id": "3566830"}]}