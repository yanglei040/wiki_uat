{"hands_on_practices": [{"introduction": "将连续介质力学的控制方程转化为可靠的数值代码，其核心在于验证。本练习将引导您完成一个称为“检验单元测试” (patch test) 的基本验证过程。您将首先从高斯散度定理出发，为一个矩形单元构建一个离散散度算子，然后验证该算子能否精确地再现线性应力场下的解析解。通过这个实践[@problem_id:3517016]，您将掌握验证数值方法局部一致性的关键技能，这是确保计算模型准确性的第一步。", "problem": "考虑一个二维连续介质域，其空间坐标用 $x$ 和 $y$ 表示，并令柯西应力张量场为 $\\boldsymbol{\\sigma}(x,y)\\in\\mathbb{R}^{2\\times 2}$。作用于二阶张量的散度微分算子是逐行定义的：对于行 $i\\in\\{1,2\\}$，散度为 $(\\nabla\\cdot\\boldsymbol{\\sigma})_i=\\sum_{j=1}^{2}\\frac{\\partial \\sigma_{ij}}{\\partial x_j}$，其中 $x_1=x$ 且 $x_2=y$，并且每个 $\\sigma_{ij}$ 都是 $x$ 和 $y$ 的分量函数。高斯散度定理指出，对于任何足够光滑的矢量场 $\\mathbf{a}(x,y)$，\n$$\n\\int_{\\Omega} \\nabla\\cdot \\mathbf{a}\\, \\mathrm{d}A \\;=\\; \\int_{\\partial\\Omega} \\mathbf{a}\\cdot\\mathbf{n}\\,\\mathrm{d}s,\n$$\n其中 $\\Omega\\subset\\mathbb{R}^2$ 是一个具有分段光滑边界 $\\partial\\Omega$ 的开集，$\\mathbf{n}$ 是 $\\partial\\Omega$ 上的外法向单位矢量，$\\mathrm{d}A$ 是面积测度，$\\mathrm{d}s$ 是线测度。在连续介质力学中，由 $\\boldsymbol{\\sigma}$ 导出的、作用在单位法向量为 $\\mathbf{n}$ 的边界上的面力矢量分量为 $t_i=\\sum_{j=1}^{2}\\sigma_{ij} n_j$。将高斯散度定理逐行应用，对每个 $i\\in\\{1,2\\}$ 可得：\n$$\n\\int_{\\Omega} (\\nabla\\cdot\\boldsymbol{\\sigma})_i\\, \\mathrm{d}A \\;=\\; \\int_{\\partial\\Omega} \\left(\\sum_{j=1}^{2}\\sigma_{ij} n_j\\right)\\,\\mathrm{d}s.\n$$\n\n任务：\n1. 从导数的定义和上述散度的逐行定义出发，证明对于一个空间常数应力场 $\\boldsymbol{\\sigma}(x,y)=\\boldsymbol{\\sigma}_0$（其中每个 $\\sigma_{ij}$ 都与 $x$ 和 $y$ 无关），散度 $\\nabla\\cdot\\boldsymbol{\\sigma}$ 在域内处处为零。\n\n2. 根据高斯散度定理，为矩形网格构建一个离散散度算子。考虑一个矩形单元，其在 $x$ 方向和 $y$ 方向的边长分别为 $h_x$ 和 $h_y$，面积为 $A=h_x h_y$，并有四个面：左面和右面（法向量分别为 $(-1,0)$ 和 $(1,0)$）以及底面和顶面（法向量分别为 $(0,-1)$ 和 $(0,1)$）。通过对每个面上的边界积分使用面力分量 $t_i=\\sum_{j=1}^{2}\\sigma_{ij}n_j$ 的中点求值进行近似，将四个面的贡献相加，再除以单元面积 $A$，来定义每个单元中的离散散度。在覆盖域的均匀结构化网格上实现此离散算子。\n\n3. 在计算地质力学中，“斑块检验”用于验证离散算子是否能精确再现某些多项式场。构建并验证一个斑块检验，在该检验中，体力被一个应力场精确平衡，该应力场的各分量至多是 $x$ 和 $y$ 的线性函数。具体来说，使用以下形式的应力张量：\n$$\n\\boldsymbol{\\sigma}(x,y) \\;=\\;\n\\begin{bmatrix}\na_{11} x + b_{11} y + c_{11}  a_{12} x + b_{12} y + c_{12} \\\\\na_{21} x + b_{21} y + c_{21}  a_{22} x + b_{22} y + c_{22}\n\\end{bmatrix},\n$$\n其中所有 $a_{ij}$ 和 $b_{ij}$ 的单位为 $\\mathrm{Pa/m}$，所有 $c_{ij}$ 的单位为 $\\mathrm{Pa}$。由 $\\nabla\\cdot\\boldsymbol{\\sigma}$ 所蕴含的单位体积解析体力（单位为 $\\mathrm{N/m^3}$）在空间上是恒定的，并由下式给出：\n$$\n\\mathbf{b} \\;=\\;\n\\begin{bmatrix}\n\\frac{\\partial \\sigma_{11}}{\\partial x} + \\frac{\\partial \\sigma_{12}}{\\partial y} \\\\\n\\frac{\\partial \\sigma_{21}}{\\partial x} + \\frac{\\partial \\sigma_{22}}{\\partial y}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\na_{11} + b_{12} \\\\\na_{21} + b_{22}\n\\end{bmatrix}.\n$$\n使用任务2中的离散算子，验证对于以下测试套件，每个单元计算出的离散散度与 $\\mathbf{b}$ 精确匹配。\n\n测试套件规范和单位：\n- 所有域均为矩形，长度单位为米（$\\mathrm{m}$）。网格数 $N_x$ 和 $N_y$ 为整数。所有应力系数 $a_{ij}$、$b_{ij}$ 的单位为 $\\mathrm{Pa/m}$，所有 $c_{ij}$ 的单位为 $\\mathrm{Pa}$。误差度量必须以 $\\mathrm{N/m^3}$ 报告。本问题不使用角度。\n- 计算所有单元和两个散度分量上离散散度与解析 $\\mathbf{b}$ 之间的最大绝对偏差，记为 $E$（单位为 $\\mathrm{N/m^3}$）。同时，通过输出一个布尔值，报告斑块检验是否在容差 $\\varepsilon=10^{-12}\\,\\mathrm{N/m^3}$ 内被精确满足，该布尔值为 $\\mathrm{True}$（如果 $E\\le\\varepsilon$）或 $\\mathrm{False}$（否则）。\n\n提供以下三个测试用例：\n- 情况1（常数应力场；边界条件合理性检查）：\n  - 域：$L_x=2\\,\\mathrm{m}$，$L_y=1\\,\\mathrm{m}$，网格：$N_x=4$，$N_y=2$。\n  - 系数：对所有 $i,j$，$a_{ij}=0\\,\\mathrm{Pa/m}$ 且 $b_{ij}=0\\,\\mathrm{Pa/m}$；$c_{11}=1000\\,\\mathrm{Pa}$，$c_{12}=-500\\,\\mathrm{Pa}$，$c_{21}=-500\\,\\mathrm{Pa}$，$c_{22}=2000\\,\\mathrm{Pa}$。\n  - 预期解析散度：恒为零；计算 $E_1$。\n\n- 情况2（一般线性应力；内部斑块检验）：\n  - 域：$L_x=3\\,\\mathrm{m}$，$L_y=2\\,\\mathrm{m}$，网格：$N_x=3$，$N_y=2$。\n  - 系数：\n    - $a_{11}=300\\,\\mathrm{Pa/m}$，$b_{11}=50\\,\\mathrm{Pa/m}$，$c_{11}=100\\,\\mathrm{Pa}$，\n    - $a_{12}=-20\\,\\mathrm{Pa/m}$，$b_{12}=10\\,\\mathrm{Pa/m}$，$c_{12}=30\\,\\mathrm{Pa}$，\n    - $a_{21}=45\\,\\mathrm{Pa/m}$，$b_{21}=-15\\,\\mathrm{Pa/m}$，$c_{21}=5\\,\\mathrm{Pa}$，\n    - $a_{22}=-60\\,\\mathrm{Pa/m}$，$b_{22}=25\\,\\mathrm{Pa/m}$，$c_{22}=70\\,\\mathrm{Pa}$。\n  - 解析体力：$\\mathbf{b}=\\begin{bmatrix}310\\\\70\\end{bmatrix}\\,\\mathrm{N/m^3}$；计算 $E_2$ 和布尔值 $B_2$（表示 $E_2\\le \\varepsilon$ 是否成立）。\n\n- 情况3（各向异性网格与边界影响；混合零线性应力）：\n  - 域：$L_x=5\\,\\mathrm{m}$，$L_y=0.5\\,\\mathrm{m}$，网格：$N_x=5$，$N_y=1$。\n  - 系数：\n    - $a_{11}=0\\,\\mathrm{Pa/m}$，$b_{11}=200\\,\\mathrm{Pa/m}$，$c_{11}=10\\,\\mathrm{Pa}$，\n    - $a_{12}=0\\,\\mathrm{Pa/m}$，$b_{12}=5\\,\\mathrm{Pa/m}$，$c_{12}=20\\,\\mathrm{Pa}$，\n    - $a_{21}=-80\\,\\mathrm{Pa/m}$，$b_{21}=0\\,\\mathrm{Pa/m}$，$c_{21}=15\\,\\mathrm{Pa}$，\n    - $a_{22}=0\\,\\mathrm{Pa/m}$，$b_{22}=0\\,\\mathrm{Pa/m}$，$c_{22}=40\\,\\mathrm{Pa}$。\n  - 解析体力：$\\mathbf{b}=\\begin{bmatrix}5\\\\-80\\end{bmatrix}\\,\\mathrm{N/m^3}$；计算 $E_3$ 和布尔值 $B_3$（表示 $E_3\\le \\varepsilon$ 是否成立）。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n  - $[E_1,E_2,B_2,E_3,B_3]$，\n其中 $E_1$、$E_2$ 和 $E_3$ 是代表误差（单位 $\\mathrm{N/m^3}$）的浮点数，$B_2$ 和 $B_3$ 是布尔值。不得打印任何其他文本。", "solution": "所提供的问题是有效的。它在科学上基于连续介质力学和数值分析，是良态的，具有唯一且可验证的解，并且所有术语和条件都已完整且明确地指定。\n\n解决方案将分三部分呈现，对应于问题陈述中的任务。\n\n### 任务1：常数应力场的散度\n\n第一个任务是证明空间常数应力场 $\\boldsymbol{\\sigma}(x,y) = \\boldsymbol{\\sigma}_0$ 的散度为零。$\\boldsymbol{\\sigma}_0$ 的分量是常数，我们将其表示为 $\\sigma_{ij,0}$。张量散度的逐行定义如下：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_i = \\sum_{j=1}^{2} \\frac{\\partial \\sigma_{ij}}{\\partial x_j} = \\frac{\\partial \\sigma_{i1}}{\\partial x} + \\frac{\\partial \\sigma_{i2}}{\\partial y} $$\n其中 $x_1=x$ 且 $x_2=y$。\n\n对于常数应力场，每个分量 $\\sigma_{ij}(x,y) = \\sigma_{ij,0}$ 都是一个常数值，与空间坐标 $x$ 和 $y$ 无关。常数对任何变量的偏导数均为零。\n$$ \\frac{\\partial \\sigma_{ij,0}}{\\partial x} = 0 \\quad \\text{且} \\quad \\frac{\\partial \\sigma_{ij,0}}{\\partial y} = 0 $$\n对所有 $i,j \\in \\{1,2\\}$ 成立。\n\n将这些代入第一个分量（$i=1$）的散度定义中：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_1 = \\frac{\\partial \\sigma_{11,0}}{\\partial x} + \\frac{\\partial \\sigma_{12,0}}{\\partial y} = 0 + 0 = 0 $$\n对于第二个分量（$i=2$）：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_2 = \\frac{\\partial \\sigma_{21,0}}{\\partial x} + \\frac{\\partial \\sigma_{22,0}}{\\partial y} = 0 + 0 = 0 $$\n因此，对于任何常数应力场，散度矢量均为零矢量，即 $\\nabla\\cdot\\boldsymbol{\\sigma} = \\mathbf{0}$。\n\n### 任务2：离散散度算子的构建\n\n第二个任务是使用高斯散度定理的积分形式，为矩形单元构建一个离散散度算子。该定理逐行应用于应力张量 $\\boldsymbol{\\sigma}$ 在一个单元域 $\\Omega_c$ 上的形式为：\n$$ \\int_{\\Omega_c} (\\nabla\\cdot\\boldsymbol{\\sigma})_i \\, \\mathrm{d}A = \\int_{\\partial\\Omega_c} (\\boldsymbol{\\sigma}\\mathbf{n})_i \\, \\mathrm{d}s $$\n其中 $(\\boldsymbol{\\sigma}\\mathbf{n})_i = \\sum_{j=1}^2 \\sigma_{ij}n_j$ 是面力矢量的第 $i$ 个分量。\n\n我们可以通过假设左侧被积函数在单元上为常数来近似单元平均散度，我们称之为离散散度 $(\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c}$：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c} \\cdot A_c \\approx \\int_{\\Omega_c} (\\nabla\\cdot\\boldsymbol{\\sigma})_i \\, \\mathrm{d}A $$\n其中 $A_c = h_x h_y$ 是矩形单元的面积。这导出了定义：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c} = \\frac{1}{A_c} \\int_{\\partial\\Omega_c} \\left(\\sum_{j=1}^{2}\\sigma_{ij} n_j\\right) \\, \\mathrm{d}s $$\n边界积分通过对单元的四个面——右（R）、左（L）、顶（T）和底（B）——的贡献求和来计算。设单元中心位于 $(x_c, y_c)$。各面中点分别位于 $(x_c+h_x/2, y_c)$、$(x_c-h_x/2, y_c)$、$(x_c, y_c+h_y/2)$ 和 $(x_c, y_c-h_y/2)$。我们使用中点法则来近似每个面上的积分。\n\n让我们推导第一个分量（$i=1$）的表达式：\n- **右面 (R)**：法向量 $\\mathbf{n}=(1,0)$。长度 $h_y$。面力分量 $t_1 = \\sigma_{11}n_1 + \\sigma_{12}n_2 = \\sigma_{11}(1) + \\sigma_{12}(0) = \\sigma_{11}$。积分近似为 $\\sigma_{11}(x_c+h_x/2, y_c) \\cdot h_y$。\n- **左面 (L)**：法向量 $\\mathbf{n}=(-1,0)$。长度 $h_y$。面力分量 $t_1 = \\sigma_{11}(-1) + \\sigma_{12}(0) = -\\sigma_{11}$。积分近似为 $-\\sigma_{11}(x_c-h_x/2, y_c) \\cdot h_y$。\n- **顶面 (T)**：法向量 $\\mathbf{n}=(0,1)$。长度 $h_x$。面力分量 $t_1 = \\sigma_{11}(0) + \\sigma_{12}(1) = \\sigma_{12}$。积分近似为 $\\sigma_{12}(x_c, y_c+h_y/2) \\cdot h_x$。\n- **底面 (B)**：法向量 $\\mathbf{n}=(0,-1)$。长度 $h_x$。面力分量 $t_1 = \\sigma_{11}(0) + \\sigma_{12}(-1) = -\\sigma_{12}$。积分近似为 $-\\sigma_{12}(x_c, y_c-h_y/2) \\cdot h_x$。\n\n将这些贡献相加并除以 $A_c = h_x h_y$：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = \\frac{1}{h_x h_y} \\left[ \\sigma_{11}(x_c+\\frac{h_x}{2}, y_c)h_y - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)h_y + \\sigma_{12}(x_c, y_c+\\frac{h_y}{2})h_x - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})h_x \\right] $$\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = \\frac{\\sigma_{11}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)}{h_x} + \\frac{\\sigma_{12}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})}{h_y} $$\n这是在单元中心对 $(\\nabla\\cdot\\boldsymbol{\\sigma})_1$ 的标准二阶中心差分近似。\n\n通过对第二个分量（$i=2$）执行相同的过程，我们发现：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c} = \\frac{\\sigma_{21}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{21}(x_c-\\frac{h_x}{2}, y_c)}{h_x} + \\frac{\\sigma_{22}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{22}(x_c, y_c-\\frac{h_y}{2})}{h_y} $$\n\n### 任务3：斑块检验验证\n\n第三个任务是验证此离散算子能精确再现分量为 $x$ 和 $y$ 的线性函数 $\\sigma_{ij}(x,y) = a_{ij}x+b_{ij}y+c_{ij}$ 的应力场的散度。解析散度为 $\\mathbf{b} = [a_{11}+b_{12}, a_{21}+b_{22}]^T$。\n\n让我们使用线性应力场来评估离散散度的第一个分量。\n第一项是 $\\sigma_{11}(x,y) = a_{11}x+b_{11}y+c_{11}$ 的有限差分：\n$$ \\frac{\\sigma_{11}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)}{h_x} = \\frac{[a_{11}(x_c+\\frac{h_x}{2}) + b_{11}y_c + c_{11}] - [a_{11}(x_c-\\frac{h_x}{2}) + b_{11}y_c + c_{11}]}{h_x} $$\n$$ = \\frac{a_{11}(x_c+\\frac{h_x}{2} - (x_c-\\frac{h_x}{2}))}{h_x} = \\frac{a_{11}h_x}{h_x} = a_{11} $$\n第二项是 $\\sigma_{12}(x,y) = a_{12}x+b_{12}y+c_{12}$ 的有限差分：\n$$ \\frac{\\sigma_{12}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})}{h_y} = \\frac{[a_{12}x_c + b_{12}(y_c+\\frac{h_y}{2}) + c_{12}] - [a_{12}x_c + b_{12}(y_c-\\frac{h_y}{2}) + c_{12}]}{h_y} $$\n$$ = \\frac{b_{12}(y_c+\\frac{h_y}{2} - (y_c-\\frac{h_y}{2}))}{h_y} = \\frac{b_{12}h_y}{h_y} = b_{12} $$\n将这两个结果相加，我们得到离散散度的第一个分量：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = a_{11} + b_{12} $$\n这与解析散度矢量 $\\mathbf{b}$ 的第一个分量完全匹配。结果与单元的位置 $(x_c, y_c)$ 和尺寸 $(h_x, h_y)$ 无关。\n\n对第二个分量 $(\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c}$ 重复此过程，使用 $\\sigma_{21}$ 和 $\\sigma_{22}$：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c} = \\frac{\\sigma_{21}(\\dots) - \\sigma_{21}(\\dots)}{h_x} + \\frac{\\sigma_{22}(\\dots) - \\sigma_{22}(\\dots)}{h_y} = a_{21} + b_{22} $$\n这也与解析结果完全匹配。\n\n这证实了，从高斯散度定理和用于面积分的中点法则近似构建的离散散度算子，通过了线性应力场的斑块检验。计算出的离散散度与解析值之间的任何差异都将归因于浮点运算的限制，而不是方法的缺陷。\n\n以下 Python 代码实现了此验证。`run_patch_test` 函数根据推导出的公式计算网格中每个单元的离散散度。然后，它计算所有单元和两个分量上计算出的散度与解析散度之间的最大绝对差。将此误差与给定的容差 $\\varepsilon=10^{-12}$ 进行比较，以确定测试是否通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the patch test verification for all given cases.\n    \"\"\"\n    epsilon = 1e-12\n\n    # Case 1: constant stress field\n    case1_params = {\n        \"Lx\": 2.0, \"Ly\": 1.0, \"Nx\": 4, \"Ny\": 2,\n        \"coeffs\": {\n            \"c11\": 1000.0, \"c12\": -500.0, \"c21\": -500.0, \"c22\": 2000.0\n        }\n    }\n    E1 = run_patch_test(**case1_params)\n\n    # Case 2: general linear stress\n    case2_params = {\n        \"Lx\": 3.0, \"Ly\": 2.0, \"Nx\": 3, \"Ny\": 2,\n        \"coeffs\": {\n            \"a11\": 300.0, \"b11\": 50.0, \"c11\": 100.0,\n            \"a12\": -20.0, \"b12\": 10.0, \"c12\": 30.0,\n            \"a21\": 45.0, \"b21\": -15.0, \"c21\": 5.0,\n            \"a22\": -60.0, \"b22\": 25.0, \"c22\": 70.0,\n        }\n    }\n    E2 = run_patch_test(**case2_params)\n    B2 = E2 = epsilon\n\n    # Case 3: anisotropic grid with mixed-zero linear stress\n    case3_params = {\n        \"Lx\": 5.0, \"Ly\": 0.5, \"Nx\": 5, \"Ny\": 1,\n        \"coeffs\": {\n            \"a11\": 0.0, \"b11\": 200.0, \"c11\": 10.0,\n            \"a12\": 0.0, \"b12\": 5.0, \"c12\": 20.0,\n            \"a21\": -80.0, \"b21\": 0.0, \"c21\": 15.0,\n            \"a22\": 0.0, \"b22\": 0.0, \"c22\": 40.0,\n        }\n    }\n    E3 = run_patch_test(**case3_params)\n    B3 = E3 = epsilon\n\n    results = [E1, E2, B2, E3, B3]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(Lx, Ly, Nx, Ny, coeffs):\n    \"\"\"\n    Computes discrete divergence on a grid and returns the maximum error.\n\n    Args:\n        Lx (float): Domain length in x-direction.\n        Ly (float): Domain length in y-direction.\n        Nx (int): Number of cells in x-direction.\n        Ny (int): Number of cells in y-direction.\n        coeffs (dict): Dictionary of stress coefficients a_ij, b_ij, c_ij.\n\n    Returns:\n        float: The maximum absolute error between discrete and analytical divergence.\n    \"\"\"\n    hx = Lx / Nx\n    hy = Ly / Ny\n\n    # Define stress component functions based on coefficients\n    # Use .get(key, 0.0) to handle missing coefficients (implicitly zero)\n    def s11(x, y): return coeffs.get('a11', 0.0)*x + coeffs.get('b11', 0.0)*y + coeffs.get('c11', 0.0)\n    def s12(x, y): return coeffs.get('a12', 0.0)*x + coeffs.get('b12', 0.0)*y + coeffs.get('c12', 0.0)\n    def s21(x, y): return coeffs.get('a21', 0.0)*x + coeffs.get('b21', 0.0)*y + coeffs.get('c21', 0.0)\n    def s22(x, y): return coeffs.get('a22', 0.0)*x + coeffs.get('b22', 0.0)*y + coeffs.get('c22', 0.0)\n\n    # Calculate analytical body force (divergence) vector\n    b_analytical_1 = coeffs.get('a11', 0.0) + coeffs.get('b12', 0.0)\n    b_analytical_2 = coeffs.get('a21', 0.0) + coeffs.get('b22', 0.0)\n\n    max_error = 0.0\n\n    # Iterate over all cells in the grid\n    for iy in range(Ny):\n        for ix in range(Nx):\n            # Coordinates of cell face midpoints for evaluation\n            x_center = (ix + 0.5) * hx\n            y_center = (iy + 0.5) * hy\n            \n            # Evaluate stress at the midpoints of the cell faces\n            s11_r = s11(x_center + hx / 2, y_center)\n            s11_l = s11(x_center - hx / 2, y_center)\n            s12_t = s12(x_center, y_center + hy / 2)\n            s12_b = s12(x_center, y_center - hy / 2)\n\n            s21_r = s21(x_center + hx / 2, y_center)\n            s21_l = s21(x_center - hx / 2, y_center)\n            s22_t = s22(x_center, y_center + hy / 2)\n            s22_b = s22(x_center, y_center - hy / 2)\n\n            # Compute discrete divergence for the cell\n            # This is the finite difference approximation derived in the solution\n            div_s_1 = (s11_r - s11_l) / hx + (s12_t - s12_b) / hy\n            div_s_2 = (s21_r - s21_l) / hx + (s22_t - s22_b) / hy\n\n            # Calculate error for this cell\n            error1 = abs(div_s_1 - b_analytical_1)\n            error2 = abs(div_s_2 - b_analytical_2)\n\n            # Update maximum error\n            max_error = max(max_error, error1, error2)\n\n    return max_error\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3517016"}, {"introduction": "验证了离散算子的基本一致性后，下一步是理解其在非理想条件下的性能。数值方法的精度，特别是那些依赖于简单求积规则的方法，往往对计算网格的质量非常敏感。在这个数值实验中[@problem_id:3516994]，您将研究控制体（单元）的几何畸变如何影响离散高斯散度定理的精度。通过对一个参考单元施加系统性的剪切变形，并采用一个非线性的测试场，您将量化并分析近似误差的来源，这是评估数值方案在实际复杂几何问题中稳健性的重要一步。", "problem": "您的任务是设计并实现一个数值实验，以在具有各向异性渗透率的多孔介质中的达西流背景下，评估 Gauss 散度定理的离散版本。目标是针对单个多面体控制体，量化达西通量散度的近似体积积分与通过控制体边界面通量的近似总和之间的差异，这个差异随着控制体变得越来越扭曲而变化。\n\n从以下基础开始：\n- 多孔介质中稳定不可压缩流的 Darcy 定律：比流量（达西通量）由 $\\boldsymbol{q} = -\\boldsymbol{K}\\,\\nabla h$ 给出，其中 $\\boldsymbol{K}$ 是对称正定渗透率张量，$h$ 是水力水头。\n- 散度定理：对于控制体 $K \\subset \\mathbb{R}^3$ 上的一个足够光滑的矢量场 $\\boldsymbol{q}$，其外单位法向量为 $\\boldsymbol{n}$，\n$$\n\\int_K \\nabla\\cdot\\boldsymbol{q}\\,dV \\;=\\; \\int_{\\partial K} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA \\;=\\; \\sum_{f\\subset\\partial K} \\int_f \\boldsymbol{q}\\cdot\\boldsymbol{n}\\,dA.\n$$\n\n实验设计（必须严格遵守以确保通用性和可测试性）：\n1. 几何与扭曲：\n   - 将控制体 $K_{\\delta}$ 表示为参考立方体 $[0,1]^3$ 通过 $x(\\boldsymbol{\\xi}) = \\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi} + \\boldsymbol{b}$ 的仿射像，其中 $\\boldsymbol{\\xi}\\in[0,1]^3$，$\\boldsymbol{b}=\\boldsymbol{0}$，且\n     $$\n     \\boldsymbol{A}(\\delta) \\;=\\; \\begin{bmatrix} 1  \\delta  0 \\\\ 0  1  \\delta \\\\ 0  0  1 \\end{bmatrix}.\n     $$\n     这里 $\\delta\\ge 0$ 是一个扭曲参数；$\\delta=0$ 产生单位立方体，更大的 $\\delta$ 产生越来越剪切（因而扭曲）的多面体。体积为 $|K_{\\delta}| = \\det(\\boldsymbol{A}(\\delta))$。\n   - $K_{\\delta}$ 的六个面对应于 $\\xi_i=0$ 和 $\\xi_i=1$（对于 $i\\in\\{1,2,3\\}$）的平面。对于固定索引为 $i$ 的面，按循环顺序列出其他索引为 $(j,k)$，使得 $(i,j,k)$ 是 $(1,2,3)$ 的一个循环排列。\n\n2. 各向异性渗透率与通量：\n   - 令 $\\boldsymbol{K}$ 为常数且各向异性，通过旋转一个具有特征值 $k_10$、$k_20$、$k_30$ 的对角张量来构造。具体来说，定义\n     $$\n     \\boldsymbol{K}(\\theta, r) \\;=\\; \\boldsymbol{R}(\\theta)\\,\\mathrm{diag}(r,\\;1,\\;r^{-1})\\,\\boldsymbol{R}(\\theta)^{\\top},\n     $$\n     其中 $\\theta$ 是围绕固定单位轴 $\\boldsymbol{u} = \\frac{1}{\\sqrt{1^2+2^2+3^2}}[1,2,3]^{\\top}$ 的旋转角（以弧度为单位），$r\\ge 1$ 是各向异性比。旋转矩阵 $\\boldsymbol{R}(\\theta)$ 应使用 Rodrigues 公式构成，并且必须是行列式为 $+1$ 的正交矩阵。\n   - 将水力水头场定义为三次多项式\n     $$\n     h(x,y,z) \\;=\\; \\alpha\\,x^3 + \\beta\\,y^3 + \\gamma\\,z^3 + \\delta_h\\, x\\,y\\,z,\n     $$\n     具有固定系数 $\\alpha=0.7$，$\\beta=-0.2$，$\\gamma=0.5$，$\\delta_h=0.3$。达西通量为 $\\boldsymbol{q}(x) = -\\boldsymbol{K}\\,\\nabla h(x)$。\n\n3. 实验所需的微分算子：\n   - 梯度为\n     $$\n     \\nabla h(x,y,z) \\;=\\; \\begin{bmatrix} 3\\alpha\\,x^2 + \\delta_h\\,y\\,z \\\\ 3\\beta\\,y^2 + \\delta_h\\,x\\,z \\\\ 3\\gamma\\,z^2 + \\delta_h\\,x\\,y \\end{bmatrix}.\n     $$\n   - Hessian 矩阵为\n     $$\n     \\nabla^2 h(x,y,z) \\;=\\; \\begin{bmatrix}\n     6\\alpha\\,x  \\delta_h\\,z  \\delta_h\\,y \\\\\n     \\delta_h\\,z  6\\beta\\,y  \\delta_h\\,x \\\\\n     \\delta_h\\,y  \\delta_h\\,x  6\\gamma\\,z\n     \\end{bmatrix}.\n     $$\n   - 由于 $\\boldsymbol{K}$ 在空间上是常数，达西通量的散度为\n     $$\n     \\nabla\\cdot\\boldsymbol{q}(x) \\;=\\; -\\mathrm{tr}\\big(\\boldsymbol{K}\\,\\nabla^2 h(x)\\big),\n     $$\n     它是 $x$ 的一个仿射（线性）函数。\n\n4. 待比较的离散近似：\n   - 使用 $K_{\\delta}$ 的形心 $x_c$ 处的一点法则来近似体积积分：\n     $$\n     \\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV \\;\\approx\\; |K_{\\delta}| \\,\\big(\\nabla\\cdot\\boldsymbol{q}\\big)(x_c), \\quad x_c = \\boldsymbol{A}(\\delta)\\,\\begin{bmatrix} \\tfrac12 \\\\ \\tfrac12 \\\\ \\tfrac12 \\end{bmatrix}.\n     $$\n   - 使用物理面中心处的一点法则来近似每个面积分。对于面 $\\xi_i=c$（其中 $c\\in\\{0,1\\}$），使用 $\\boldsymbol{\\xi}$-中心 $\\boldsymbol{\\xi}_f = (1/2,1/2,1/2)^{\\top}$，将其第 $i$ 个分量替换为 $c$，并将其映射到 $x_f=\\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi}_f$。该面的有向面积矢量为\n     $$\n     \\boldsymbol{a}_{i,c} \\;=\\; s_{i,c}\\,\\big(\\partial_{\\xi_j}x \\times \\partial_{\\xi_k}x\\big) \\;=\\; s_{i,c}\\,\\big(\\boldsymbol{A}\\,\\boldsymbol{e}_j \\times \\boldsymbol{A}\\,\\boldsymbol{e}_k\\big),\n     $$\n     其中对于 $c=1$，$s_{i,c}=+1$；对于 $c=0$，$s_{i,c}=-1$；且 $(i,j,k)$ 是循环的，因此 $\\boldsymbol{e}_j \\times \\boldsymbol{e}_k = \\boldsymbol{e}_i$。离散的面通量是 $\\boldsymbol{q}(x_f)\\cdot \\boldsymbol{a}_{i,c}$。离散的表面总和是这六个面贡献的总和。\n\n5. 误差度量：\n   - 定义标量差异\n     $$\n     E \\;=\\; \\frac{\\big|\\;|K_{\\delta}|\\,(\\nabla\\cdot\\boldsymbol{q})(x_c) \\;-\\; \\sum_{f\\subset\\partial K_{\\delta}} \\boldsymbol{q}(x_f)\\cdot \\boldsymbol{a}_f\\;\\big|}{\\max\\big(1,\\;\\big|\\,|K_{\\delta}|\\,(\\nabla\\cdot\\boldsymbol{q})(x_c)\\,\\big|\\big)}.\n     $$\n     这是一个无量纲的量。答案中不需要物理单位。\n\n您的程序必须实现上述内容，并为下面的测试套件中的每个测试用例计算 $E$。在指定的位置使用项目 1-4 中的精确公式，并使用所述的一点法则。不要使用任何外部网格或数据文件。角度必须以弧度为单位进行解释。\n\n测试套件：\n- 案例 1（基线，无几何扭曲，对齐的各向异性）：$\\delta=0.0$, $r=10.0$, $\\theta=0.0$。\n- 案例 2（中等扭曲，旋转的各向异性）：$\\delta=0.5$, $r=10.0$, $\\theta=0.7$。\n- 案例 3（强扭曲，旋转的各向异性）：$\\delta=1.0$, $r=10.0$, $\\theta=1.4$。\n- 案例 4（极端扭曲，旋转的各向异性）：$\\delta=2.0$, $r=10.0$, $\\theta=2.1$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是等于该案例的 $E$ 值的浮点数。不应打印任何额外文本。所有计算都必须遵循上述定义，并且不允许使用超出指定的一点法则的任何数值积分。", "solution": "所提出的问题要求设计并实现一个数值实验，以评估应用于多孔介质中达西流的 Gauss 散度定理离散公式的准确性。任务的核心是计算通量散度的体积积分的单点求积与多面体控制体边界面上通量的单点求积之和之间的差异。这个差异将作为施加于控制体的几何扭曲的函数进行研究。\n\n该问题在计算上定义明确，在科学上以流体力学和数值分析的原理为基础，并且提供了所有必要的参数和方程。它代表了计算科学中一个有效且重要的练习。以下步骤详细说明了得出解决方案的理论基础和计算策略。\n\n首先，我们建立物理和数学背景。流动由 Darcy 定律控制，该定律通过渗透率张量 $\\boldsymbol{K}$ 将比流量（达西通量）$\\boldsymbol{q}$ 与水力水头 $h$ 联系起来：\n$$\n\\boldsymbol{q} = -\\boldsymbol{K}\\,\\nabla h\n$$\n渗透率张量 $\\boldsymbol{K}$ 被指定为一个常数、对称、正定矩阵。散度定理将通量散度在体积 $K_{\\delta}$ 上的积分与通量穿过其边界 $\\partial K_{\\delta}$ 的积分联系起来：\n$$\n\\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV = \\int_{\\partial K_{\\delta}} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA\n$$\n该实验旨在量化通过低阶数值求积法则近似此方程两边所引入的误差。\n\n控制体 $K_{\\delta}$ 是一个多面体，定义为参考单位立方体 $[0,1]^3$ 的仿射像。映射由 $\\boldsymbol{x}(\\boldsymbol{\\xi}) = \\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi}$ 给出，其中 $\\boldsymbol{\\xi} \\in [0,1]^3$ 是参考坐标，$\\boldsymbol{x}$ 是物理坐标。变换矩阵为\n$$\n\\boldsymbol{A}(\\delta) = \\begin{bmatrix} 1  \\delta  0 \\\\ 0  1  \\delta \\\\ 0  0  1 \\end{bmatrix}\n$$\n参数 $\\delta \\ge 0$ 控制剪切扭曲的程度。对于所有 $\\delta$，控制体的体积为 $|K_{\\delta}| = \\det(\\boldsymbol{A}(\\delta)) = 1$。\n\n水力水头 $h$ 是一个预设的三次多项式：\n$$\nh(x,y,z) = \\alpha\\,x^3 + \\beta\\,y^3 + \\gamma\\,z^3 + \\delta_h\\, x\\,y\\,z\n$$\n具有给定系数 $\\alpha=0.7$，$\\beta=-0.2$，$\\gamma=0.5$ 和 $\\delta_h=0.3$。\n渗透率张量 $\\boldsymbol{K}$ 是各向异性的，由以下公式定义\n$$\n\\boldsymbol{K}(\\theta, r) = \\boldsymbol{R}(\\theta)\\,\\mathrm{diag}(r,\\;1,\\;r^{-1})\\,\\boldsymbol{R}(\\theta)^{\\top}\n$$\n其中 $r \\ge 1$ 是一个各向异性比，$\\boldsymbol{R}(\\theta)$ 是对应于围绕固定轴 $\\boldsymbol{u} = (1/\\sqrt{14})[1, 2, 3]^{\\top}$ 旋转角度 $\\theta$ 的旋转矩阵。矩阵 $\\boldsymbol{R}(\\theta)$ 使用 Rodrigues 旋转公式构造：\n$$\n\\boldsymbol{R}(\\theta) = \\boldsymbol{I}\\cos\\theta + (1-\\cos\\theta)(\\boldsymbol{u} \\otimes \\boldsymbol{u}) + \\sin\\theta\\,[\\boldsymbol{u}]_{\\times}\n$$\n其中 $\\boldsymbol{I}$ 是单位矩阵，$\\boldsymbol{u} \\otimes \\boldsymbol{u}$ 是外积，$[\\boldsymbol{u}]_{\\times}$ 是 $\\boldsymbol{u}$ 的叉积矩阵。\n\n由于 $\\boldsymbol{K}$ 是常数，通量的散度是 $\\nabla\\cdot\\boldsymbol{q} = -\\nabla\\cdot(\\boldsymbol{K}\\nabla h) = -\\mathrm{tr}(\\boldsymbol{K}\\nabla^2 h)$，其中 $\\nabla^2 h$ 是 $h$ 的 Hessian 矩阵。$\\nabla^2 h$ 的条目是坐标 $(x,y,z)$ 的线性函数，这使得 $\\nabla\\cdot\\boldsymbol{q}$ 成为位置的线性函数。\n\n待比较的离散散度定理的两个项是：\n1. 体积积分的近似，$I_V = \\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV$。这通过物理单元形心 $\\boldsymbol{x}_c = \\boldsymbol{A}(\\delta) [1/2, 1/2, 1/2]^{\\top}$ 处的一点求积法则来近似：\n$$\nI_V \\approx \\tilde{I}_V = |K_{\\delta}| \\,(\\nabla\\cdot\\boldsymbol{q})(\\boldsymbol{x}_c)\n$$\n一个关键的观察是，在形心处评估的一点求积法则对于任意体积上线性函数的任何积分都是精确的。由于 $\\nabla\\cdot\\boldsymbol{q}$ 是 $\\boldsymbol{x}$ 的线性函数，这个“近似”得出了体积积分的精确值，即 $\\tilde{I}_V = I_V$。\n\n2. 面积分的近似，$I_S = \\int_{\\partial K_{\\delta}} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA$。这是 $K_\\delta$ 六个面上的通量之和：\n$$\nI_S \\approx \\tilde{I}_S = \\sum_{f\\subset\\partial K_{\\delta}} \\boldsymbol{q}(\\boldsymbol{x}_f)\\cdot \\boldsymbol{a}_f\n$$\n这里，$\\boldsymbol{x}_f$ 是面 $f$ 的中心，$\\boldsymbol{a}_f$ 是其有向面积矢量。对于对应于 $\\xi_i=c$（其中 $c \\in \\{0,1\\}$）的面，其中心是 $\\boldsymbol{x}_f = \\boldsymbol{A}(\\delta)\\boldsymbol{\\xi}_f$，其中 $\\boldsymbol{\\xi}_f$ 是 $[1/2, 1/2, 1/2]^{\\top}$，其第 $i$ 个分量被设为 $c$。有向面积矢量是 $\\boldsymbol{a}_{i,c} = s_{i,c}(\\boldsymbol{A}\\boldsymbol{e}_j \\times \\boldsymbol{A}\\boldsymbol{e}_k)$，其中 $(i,j,k)$ 是 $(1,2,3)$ 的循环排列，使得 $\\boldsymbol{e}_j \\times \\boldsymbol{e}_k = \\boldsymbol{e}_i$，并且 $s_{i,c}$ 对于 $c=0$ 是 $-1$，对于 $c=1$ 是 $+1$。通量 $\\boldsymbol{q}(\\boldsymbol{x})$ 是位置的二次函数，所以这个用于面积分的单点求积通常不是精确的。\n\n离散定理两边之间的全部差异源于面积分近似的误差。误差度量 $E$ 定义为：\n$$\nE = \\frac{|\\tilde{I}_V - \\tilde{I}_S|}{\\max(1, |\\tilde{I}_V|)} = \\frac{|I_V - \\tilde{I}_S|}{\\max(1, |I_V|)}\n$$\n该度量通过精确体积积分的量级（如果积分很小则为 1）来归一化面积分近似的绝对误差。\n\n每个测试用例 $(\\delta, r, \\theta)$ 的计算过程如下：\n1. 构造矩阵 $\\boldsymbol{A}(\\delta)$ 和 $\\boldsymbol{K}(\\theta, r)$。\n2. 计算精确的体积积分项 $\\tilde{I}_V$：找到单元形心 $\\boldsymbol{x}_c$，评估 Hessian 矩阵 $\\nabla^2 h(\\boldsymbol{x}_c)$，计算散度 $\\nabla\\cdot\\boldsymbol{q}(\\boldsymbol{x}_c) = -\\mathrm{tr}(\\boldsymbol{K}\\nabla^2 h(\\boldsymbol{x}_c))$，并按体积 $|K_{\\delta}|=1$ 缩放。\n3. 计算近似的面积分项 $\\tilde{I}_S$：遍历控制体的六个面。对于每个面，确定其中心 $\\boldsymbol{x}_f$ 和有向面积矢量 $\\boldsymbol{a}_f$。评估通量矢量 $\\boldsymbol{q}(\\boldsymbol{x}_f) = -\\boldsymbol{K}\\nabla h(\\boldsymbol{x}_f)$ 并计算其与面积矢量的点积。将这些贡献相加。\n4. 使用上述公式计算最终误差度量 $E$。\n\n此过程将为四个指定的测试用例实施和执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_rotation_matrix(axis, angle):\n    \"\"\"\n    Returns the rotation matrix for a rotation around a given axis by a given angle,\n    using Rodrigues' rotation formula.\n    \n    Args:\n        axis (np.ndarray): The 3D rotation axis (must be a unit vector).\n        angle (float): The rotation angle in radians.\n        \n    Returns:\n        np.ndarray: The 3x3 rotation matrix.\n    \"\"\"\n    c = np.cos(angle)\n    s = np.sin(angle)\n    t = 1 - c\n    x, y, z = axis\n    \n    # Cross-product matrix of the axis vector\n    K = np.array([[0, -z, y],\n                  [z, 0, -x],\n                  [-y, x, 0]])\n    \n    # Rodrigues' formula: R = c*I + t*(u u^T) + s*[u]_x\n    R = c * np.identity(3) + t * np.outer(axis, axis) + s * K\n    return R\n\ndef solve():\n    \"\"\"\n    Solves the numerical experiment problem by calculating the discrepancy E\n    for a set of test cases.\n    \"\"\"\n    # Define problem constants\n    alpha = 0.7\n    beta = -0.2\n    gamma = 0.5\n    delta_h = 0.3\n    # Rotation axis must be a unit vector\n    rot_axis_u = np.array([1.0, 2.0, 3.0]) / np.sqrt(1**2 + 2**2 + 3**2)\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (delta, r, theta)\n        (0.0, 10.0, 0.0),\n        (0.5, 10.0, 0.7),\n        (1.0, 10.0, 1.4),\n        (2.0, 10.0, 2.1),\n    ]\n\n    results = []\n    \n    # Function definitions for head gradient and Hessian\n    def grad_h(p):\n        x, y, z = p\n        return np.array([\n            3 * alpha * x**2 + delta_h * y * z,\n            3 * beta * y**2 + delta_h * x * z,\n            3 * gamma * z**2 + delta_h * x * y\n        ])\n\n    def hessian_h(p):\n        x, y, z = p\n        return np.array([\n            [6 * alpha * x, delta_h * z,   delta_h * y],\n            [delta_h * z,   6 * beta * y,  delta_h * x],\n            [delta_h * y,   delta_h * x,   6 * gamma * z]\n        ])\n\n    for delta, r, theta in test_cases:\n        # Step 1: Define Geometry and Permeability\n        A = np.array([[1.0, delta, 0.0],\n                      [0.0, 1.0,   delta],\n                      [0.0, 0.0,   1.0]])\n        \n        # Volume of the sheared cube is det(A) = 1\n        vol_K_delta = 1.0\n\n        # Construct permeability tensor K\n        R = get_rotation_matrix(rot_axis_u, theta)\n        D = np.diag([r, 1.0, 1.0/r])\n        K = R @ D @ R.T\n\n        # Step 2: Calculate Volume Integral Term (this approximation is exact)\n        xi_c = np.array([0.5, 0.5, 0.5])\n        x_c = A @ xi_c\n        \n        div_q_at_xc = -np.trace(K @ hessian_h(x_c))\n        vol_integral_term = vol_K_delta * div_q_at_xc\n\n        # Step 3: Calculate Surface Integral Term\n        surface_integral_term = 0.0\n        \n        # Loop over faces, defined by axis index i and side c (0 or 1)\n        # Permutation cycles for (i,j,k)\n        cycles = {0: (1, 2), 1: (2, 0), 2: (0, 1)}\n        \n        for i in range(3): # axis index: 0, 1, 2\n            j, k = cycles[i]\n            \n            for c in range(2):  # side c=0 or c=1\n                s_ic = -1.0 if c == 0 else 1.0\n                \n                # Oriented area vector a_f = s * (A_ej x A_ek)\n                A_col_j = A[:, j]\n                A_col_k = A[:, k]\n                area_vec = s_ic * np.cross(A_col_j, A_col_k)\n                \n                # Physical location of the face center x_f\n                xi_f = np.array([0.5, 0.5, 0.5])\n                xi_f[i] = float(c)\n                x_f = A @ xi_f\n                \n                # Flux q at the face center x_f\n                q_at_xf = -K @ grad_h(x_f)\n                \n                # Add flux through the face to the sum\n                surface_integral_term += np.dot(q_at_xf, area_vec)\n        \n        # Step 4: Compute the Error Metric E\n        numerator = np.abs(vol_integral_term - surface_integral_term)\n        denominator = np.max([1.0, np.abs(vol_integral_term)])\n        error = numerator / denominator\n        \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3516994"}, {"introduction": "真实的岩土力学问题常常涉及复杂的几何区域，例如包含隧道、溶洞或地下空腔的多连通域。将高斯散度定理应用于此类区域时，必须仔细处理内部边界的定向问题，特别是“外法线”方向的定义。本练习[@problem_id:3516962]将指导您从理论上推导多连通域上的散度定理，并揭示为何内部空腔边界的通量在总和中带有负号。随后，您将通过一个数值算例来验证这一定理，从而深刻理解在处理复杂地质构造时，如何正确应用基本物理守恒定律。", "problem": "考虑一个二维多连通域，该域具有一个外边界和零个或多个内部空腔边界。在计算岩土力学中，体积通量密度场由一个至少连续可微的矢量场 $\\mathbf{v}(x,y)$ 表示，而散度算子 $\\nabla \\cdot \\mathbf{v}$ 代表局部体积源密度。从质量守恒的积分表述和适用于单连通域（无空腔）的高斯（散度）定理出发，通过切除子域并将该原理应用于每个部分，同时注意外法线的定义，推导当域包含空腔时边界通量的正确符号结构。证明在多连通域上的散度积分等于通过外边界的外向通量减去通过每个空腔边界的外向通量，其中空腔边界采用与外边界相同的几何方向。解释为什么符号反转是由于相对于域而言，外法线指向空腔内部而引起的。\n\n然后，你必须设计一个算法，对于任意多边形外边界和多边形空腔边界，该算法能为一个仿射（线性）矢量场 $\\mathbf{v}(x,y) = \\big(a x + b y + c,\\; d x + e y + f\\big)$（其散度为常数 $\\nabla \\cdot \\mathbf{v} = a + e$）计算两个量：\n- 面积分 $\\iint_{\\Omega} \\nabla \\cdot \\mathbf{v}\\, dA$，根据有符号多边形面积计算，以及\n- 边通量积分 $\\oint_{\\partial \\Omega} \\mathbf{v}\\cdot \\mathbf{n}\\, ds$，使用单位外法向量 $\\mathbf{n}$ 和弧长 $ds$ 对多边形链进行计算。\n\n你的算法必须仅依赖于基本定义，不得假定任何针对多连通域的预先推导出的公式。对于一个正向（逆时针）的简单闭合曲线 $\\Gamma$，外向通量积分可以表示为\n$$\n\\oint_{\\Gamma} \\mathbf{v}\\cdot \\mathbf{n}\\, ds \\;=\\; \\oint_{\\Gamma} \\big(v_x\\, dy - v_y\\, dx\\big),\n$$\n其中 $v_x$ 和 $v_y$ 表示 $\\mathbf{v}$ 的分量，$dx$ 和 $dy$ 是微分位移，并且曲线以逆时针方向参数化。仅在从第一性原理证明该恒等式后才能使用它。对于顶点按序为 $(x_i,y_i)$ 的多边形链，通过沿每条直线段积分来精确计算该积分。\n\n所有量均为无量纲，且下文出现的所有角度均应以弧度解释。\n\n实现一个程序来评估以下测试套件。对于每个测试用例，计算两个实数：\n- 面积分 $\\iint_{\\Omega} \\nabla \\cdot \\mathbf{v}\\, dA$ 与正确定向的边界通量之间的绝对差。在正确定向中，内部空腔边界的方向相对于外边界（逆时针）反转，使其外法线相对于域是向外的。\n- 面积分 $\\iint_{\\Omega} \\nabla \\cdot \\mathbf{v}\\, dA$ 与错误定向的边界通量之间的绝对差。在错误定向中，内部空腔边界采用与外边界相同的逆时针方向（即未反转），这用于测试对内边界方向的敏感性。\n\n测试用例 A（含两个空腔的岩溶类示例）：\n- 矢量场：$\\mathbf{v}(x,y) = \\big(2 x + y + 1,\\; -x + 4 y - 2\\big)$，因此 $\\nabla \\cdot \\mathbf{v} = 2 + 4 = 6$。\n- 外边界多边形（逆时针）：$(0,0)\\to(4,0)\\to(4,2)\\to(0,2)$。\n- 空腔 1：一个以 $(1,1)$ 为中心、半径为 $0.3$ 的正八边形，其顶点由 $(1 + 0.3 \\cos \\theta_k,\\; 1 + 0.3 \\sin \\theta_k)$ 给出，其中 $\\theta_k = k \\pi/4$，$k \\in \\{0,1,2,3,4,5,6,7\\}$，按 $k$ 递增（逆时针）列出。\n- 空腔 2：一个以 $(3,1)$ 为中心、半径为 $0.25$ 的正八边形，其顶点由 $(3 + 0.25 \\cos \\theta_k,\\; 1 + 0.25 \\sin \\theta_k)$ 给出，其中 $\\theta_k = k \\pi/4$，$k \\in \\{0,1,2,3,4,5,6,7\\}$，按 $k$ 递增（逆时针）列出。\n\n测试用例 B（零散度场）：\n- 矢量场：$\\mathbf{v}(x,y) = \\big(-y,\\; x\\big)$，因此 $\\nabla \\cdot \\mathbf{v} = 0 + 0 = 0$。\n- 外边界多边形（逆时针）：$(0,0)\\to(2,0)\\to(2,2)\\to(0,2)$。\n- 空腔 1：正方形 $(0.5,0.5)\\to(1.5,0.5)\\to(1.5,1.5)\\to(0.5,1.5)$，按逆时针列出。\n\n测试用例 C（含一个空腔的非凸外边界）：\n- 矢量场：$\\mathbf{v}(x,y) = \\big(x + 2,\\; y - 1\\big)$，因此 $\\nabla \\cdot \\mathbf{v} = 1 + 1 = 2$。\n- 外边界多边形（逆时针，L形）：$(0,0)\\to(3,0)\\to(3,1)\\to(1,1)\\to(1,3)\\to(0,3)$。\n- 空腔 1（三角形，逆时针）：$(0.3,2.2)\\to(0.8,2.1)\\to(0.6,2.6)$。\n\n你的程序必须：\n- 使用有符号鞋带公式计算外边界和每个空腔的多边形面积，并将域面积取为外边界面积减去所有空腔面积之和。\n- 使用 $\\int (v_x\\, dy - v_y\\, dx)$ 的分段积分，计算每个多边形边界上外向通量的精确线积分，该方法对于仿射场 $\\mathbf{v}$ 在直线段上是精确的。\n- 将外边界通量与所有方向反转的空腔边界通量相加（等价地，从外边界通量中减去所有逆时针方向的空腔边界通量），从而构成正确定向的总边界通量。\n- 将外边界通量与所有逆时针方向（即未反转）的空腔边界通量相加，从而构成错误定向的总边界通量。\n- 对每个测试用例，报告两个浮点数：分别对应于正确定向和错误定向的绝对误差。\n\n最终输出格式：你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含六个浮点数：\n$[\\text{A\\_correct}, \\text{A\\_incorrect}, \\text{B\\_correct}, \\text{B\\_incorrect}, \\text{C\\_correct}, \\text{C\\_incorrect}]$，\n其中每个条目是为相应测试用例定义的绝对差。", "solution": "该问题要求推导多连通域上的散度定理，并设计一个算法来验证其在多边形域上的仿射矢量场的适用性。\n\n### 第1部分：理论推导\n\n二维高斯散度定理，也称为散度形式的格林公式，建立了域内矢量场总散度与其边界通量之间的基本关系。对于一个具有分段光滑、正向（逆时针，CCW）边界 $\\partial\\Omega_s$ 的单连通域 $\\Omega_s \\subset \\mathbb{R}^2$，以及一个连续可微的矢量场 $\\mathbf{v}(x,y) = \\big(v_x(x,y), v_y(x,y)\\big)$，该定理表述为：\n$$\n\\iint_{\\Omega_s} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\oint_{\\partial\\Omega_s} \\mathbf{v} \\cdot \\mathbf{n} \\, ds\n$$\n其中 $\\nabla \\cdot \\mathbf{v} = \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y}$ 是 $\\mathbf{v}$ 的散度，$\\mathbf{n}$ 是指向边界 $\\partial\\Omega_s$ 外部的单位法向量。量 $\\mathbf{v} \\cdot \\mathbf{n}$ 表示垂直于边界的通量密度分量，其线积分给出了流出域的总通量。\n\n本问题考虑一个多连通域 $\\Omega$，它由一个外边界 $\\Gamma_0$ 和 $M$ 个不重叠的内空腔边界 $\\Gamma_1, \\Gamma_2, \\dots, \\Gamma_M$ 定义。域 $\\Omega$ 是由 $\\Gamma_0$ 包围但在所有 $\\Gamma_i$（其中 $i=1, \\dots, M$）外部的区域。由于 $\\Omega$ 不是单连通的，散度定理的基本形式不直接适用。\n\n为了应用该定理，我们将 $\\Omega$ 转化为一个单连通域。这可以通过引入一组连接各边界的不相交的“割线”来实现。对于每个内边界 $\\Gamma_i$，我们引入一个由两条无限接近的路径 $C_i^+$ 和 $C_i^-$ 组成的狭窄通道，将其连接到外边界 $\\Gamma_0$（或另一个已连接的内边界）。通过切除这些通道，我们得到一个新的单连通域 $\\Omega'$。$\\Omega'$ 的面积与 $\\Omega$ 的面积相同。\n\n这个新域的边界 $\\partial\\Omega'$ 包括原始外边界 $\\Gamma_0$、内边界 $\\Gamma_i$ 以及构成割线的路径。我们设定 $\\Gamma_0$ 为逆时针（CCW）方向，所有内边界 $\\Gamma_i$ 也为逆时针方向。$\\Omega'$ 的边界遍历方向需保证域 $\\Omega'$ 始终位于左侧。这意味着：\n- $\\Gamma_0$ 按其原始逆时针方向遍历。\n- 从 $\\Gamma_0$ 到 $\\Gamma_i$ 的每条割线，比如沿 $C_i^+$ 遍历。\n- 每个内边界 $\\Gamma_i$ 按顺时针（CW）方向遍历。\n- 每条割线从 $\\Gamma_i$ 返回 $\\Gamma_0$，沿 $C_i^-$ 遍历。\n\n将散度定理应用于单连通域 $\\Omega'$，可得：\n$$\n\\iint_{\\Omega'} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\oint_{\\partial\\Omega'} \\mathbf{v} \\cdot \\mathbf{n} \\, ds\n$$\n由于 $\\text{Area}(\\Omega') = \\text{Area}(\\Omega)$，左侧即为 $\\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA$。右侧的边界积分可以分解为：\n$$\n\\oint_{\\partial\\Omega'} \\mathbf{v} \\cdot \\mathbf{n} \\, ds = \\oint_{\\Gamma_0} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\sum_{i=1}^M \\left( \\oint_{\\Gamma_i} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\int_{C_i^+} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\int_{C_i^-} \\mathbf{v} \\cdot \\mathbf{n} \\, ds \\right)\n$$\n当路径 $C_i^+$ 和 $C_i^-$ 变得无限接近时，它们沿同一几何线但在相反方向上移动。这些路径上的外法向量也指向相反方向。因此，它们对积分的贡献相互抵消：$\\int_{C_i^+} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\int_{C_i^-} \\mathbf{v} \\cdot \\mathbf{n} \\, ds = 0$。\n\n这使定理简化为：\n$$\n\\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\oint_{\\Gamma_0, \\text{CCW}} \\mathbf{v} \\cdot \\mathbf{n}_{\\text{out}} \\, ds + \\sum_{i=1}^M \\oint_{\\Gamma_i, \\text{CW}} \\mathbf{v} \\cdot \\mathbf{n}_{\\text{out}} \\, ds\n$$\n这里，$\\mathbf{n}_{\\text{out}}$ 是从域 $\\Omega$ 指向外部的法向量。\n- 对于外边界 $\\Gamma_0$（逆时针定向），$\\mathbf{n}_{\\text{out}}$ 是标准的外法线。\n- 对于内边界 $\\Gamma_i$，域 $\\Omega$ 位于空腔外部。因此，外法线 $\\mathbf{n}_{\\text{out}}$ 从 $\\Omega$ 指向空腔内部。\n\n如果我们为任意简单闭合曲线 $\\Gamma$ 定义一个标准通量，即通过其标准逆时针定向边界的通量，记作 $\\text{Flux}(\\Gamma, \\text{CCW})$。此标准定义下的外法线指向远离 $\\Gamma$ 所围区域。对于内边界 $\\Gamma_i$，此标准法线与 $\\mathbf{n}_{\\text{out}}$（指向空腔内部）方向相反。因此，$\\oint_{\\Gamma_i, \\text{CW}} \\mathbf{v} \\cdot \\mathbf{n}_{\\text{out}} \\, ds = -\\oint_{\\Gamma_i, \\text{CCW}} \\mathbf{v} \\cdot (-\\mathbf{n}_{\\text{out}}) \\, ds$。同时，反转路径积分方向会使积分值变号：$\\oint_{\\text{CW}} = - \\oint_{\\text{CCW}}$。\n\n设 $\\text{Flux}(\\Gamma_i, \\text{CCW})$ 为在 $\\Gamma_i$ 上以逆时针方向计算的通量，使用指向远离空腔中心的法线。那么，在 $\\Gamma_i$ 上相对于 $\\Omega$ 的通量为 $-\\text{Flux}(\\Gamma_i, \\text{CCW})$。这解释了符号反转的原因。总通量等于从外边界流出的通量减去从空腔流入域内的通量（这对应于从空腔流出的通量）。\n因此，多连通域的最终正确公式为：\n$$\n\\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\text{Flux}(\\Gamma_0, \\text{CCW}) - \\sum_{i=1}^M \\text{Flux}(\\Gamma_i, \\text{CCW})\n$$\n这与题目要求的结构相符，即所有边界的通量首先使用一致的逆时针方向计算，然后用适当的符号组合。\n\n为便于计算，我们使用恒等式 $\\oint_{\\Gamma} \\mathbf{v} \\cdot \\mathbf{n} \\, ds = \\oint_{\\Gamma} (v_x dy - v_y dx)$，适用于逆时针定向的曲线 $\\Gamma$。这可以通过弧长 $s$ 参数化曲线 $\\mathbf{r}(s) = (x(s), y(s))$ 来证明。单位切向量为 $\\mathbf{t} = d\\mathbf{r}/ds = (dx/ds, dy/ds)$。对于逆时针曲线，外法向量为 $\\mathbf{n} = (dy/ds, -dx/ds)$。点积为 $\\mathbf{v} \\cdot \\mathbf{n} = v_x(dy/ds) - v_y(dx/ds)$。对 $s$ 积分得到 $\\int (v_x(dy/ds) - v_y(dx/ds))ds = \\oint (v_x dy - v_y dx)$。\n\n### 第2部分：算法设计\n\n该算法必须为给定的仿射矢量场 $\\mathbf{v}(x,y) = (ax + by + c, dx + ey + f)$ 和由多边形边界定义的域 $\\Omega$ 计算上述定理的两边。\n\n**1. 面积分计算：**\n仿射场 $\\mathbf{v}$ 的散度是一个常数：$\\nabla \\cdot \\mathbf{v} = a + e$。\n因此，面积分为：\n$$\nI_A = \\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA = (a+e) \\iint_{\\Omega} dA = (a+e) \\cdot \\text{Area}(\\Omega)\n$$\n多连通域 $\\Omega$ 的面积是外多边形 $\\Gamma_0$ 的面积减去所有空腔多边形 $\\Gamma_i$ 的面积之和。\n$$\n\\text{Area}(\\Omega) = \\text{Area}(\\Gamma_0) - \\sum_{i=1}^M \\text{Area}(\\Gamma_i)\n$$\n一个具有逆时针排序顶点 $(x_0, y_0), (x_1, y_1), \\dots, (x_{N-1}, y_{N-1})$ 的简单多边形的面积可以使用鞋带公式计算，该公式给出正的有符号面积：\n$$\n\\text{Area}(\\text{polygon}) = \\frac{1}{2} \\sum_{j=0}^{N-1} (x_j y_{j+1} - x_{j+1} y_j), \\quad \\text{其中 } (x_N, y_N) = (x_0, y_0)\n$$\n由于所有给定的多边形都以逆时针方向定向，用此公式计算出的面积将为正，通过相减可得到 $\\Omega$ 的正确面积。\n\n**2. 边通量积分计算：**\n总边界通量通过将每个多边形边界以正确定向的贡献相加来计算。我们使用恒等式 $\\oint (v_x dy - v_y dx)$。对于多边形边界，该积分变为其各直线段上积分的总和。\n考虑从 $P_j = (x_j, y_j)$ 到 $P_{j+1} = (x_{j+1}, y_{j+1})$ 的单个线段。我们可以将其参数化为 $\\mathbf{r}(t) = (x_j + t\\Delta x_j, y_j + t\\Delta y_j)$，其中 $t \\in [0,1]$，$\\Delta x_j = x_{j+1}-x_j$，$\\Delta y_j = y_{j+1}-y_j$。微分为 $dx = \\Delta x_j dt$ 和 $dy = \\Delta y_j dt$。\n此线段的积分为：\n$$\n\\int_{P_j}^{P_{j+1}} (v_x dy - v_y dx) = \\int_0^1 [v_x(\\mathbf{r}(t)) \\Delta y_j - v_y(\\mathbf{r}(t)) \\Delta x_j] dt\n$$\n由于 $\\mathbf{v}$ 是仿射场，分量 $v_x$ 和 $v_y$ 是 $x$ 和 $y$ 的线性函数。因此，被积函数 $v_x(\\mathbf{r}(t)) \\Delta y_j - v_y(\\mathbf{r}(t)) \\Delta x_j$ 是参数 $t$ 的线性函数。一个线性函数在区间上的积分精确等于其在该区间中点的值乘以区间长度。在此参数化中，中点对应于 $t=1/2$，区间长度为 $1$。线段的中点坐标为 $(\\bar{x}_j, \\bar{y}_j) = (\\frac{x_j+x_{j+1}}{2}, \\frac{y_j+y_{j+1}}{2})$。\n因此，线段通量贡献的精确值为：\n$$\n\\text{Flux}_j = v_x(\\bar{x}_j, \\bar{y}_j) \\Delta y_j - v_y(\\bar{x}_j, \\bar{y}_j) \\Delta x_j\n$$\n一个多边形的总通量 $\\text{Flux}(\\Gamma, \\text{CCW})$ 是其所有边上这些线段通量的总和。\n\n**3. 验证：**\n对于每个测试用例，算法计算：\n- 面积分：$I_A = (a+e) \\left( \\text{Area}(\\Gamma_0) - \\sum \\text{Area}(\\Gamma_i) \\right)$。\n- 每个边界（外边界 $\\Gamma_0$ 和空腔 $\\Gamma_i$）在逆时针方向下的通量：$I_{B,0}, I_{B,i}$。\n- 正确定向的总边界通量：$I_{B,\\text{correct}} = I_{B,0} - \\sum I_{B,i}$。\n- 错误定向的总边界通量：$I_{B,\\text{incorrect}} = I_{B,0} + \\sum I_{B,i}$。\n最后，它计算绝对差：\n- $\\text{Error}_{\\text{correct}} = | I_A - I_{B,\\text{correct}} |$\n- $\\text{Error}_{\\text{incorrect}} = | I_A - I_{B,\\text{incorrect}} |$\n\n$\\text{Error}_{\\text{correct}}$ 的值预计为零（或在浮点误差范围内），从而验证该定理。$\\text{Error}_{\\text{incorrect}}$ 的值通常不为零，突显了边界方向的关键作用。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by defining test cases, computing integrals,\n    and reporting the specified differences.\n    \"\"\"\n\n    def polygon_area(vertices):\n        \"\"\"\n        Calculates the signed area of a polygon using the shoelace formula.\n        Assumes vertices are given in order (e.g., counter-clockwise).\n        \"\"\"\n        area = 0.0\n        n = len(vertices)\n        for i in range(n):\n            j = (i + 1) % n\n            area += vertices[i, 0] * vertices[j, 1]\n            area -= vertices[j, 0] * vertices[i, 1]\n        return area / 2.0\n\n    def calculate_flux(polygon_vertices, v_params):\n        \"\"\"\n        Calculates the CCW boundary flux integral for a single polygon.\n        The integral is computed exactly for an affine vector field by summing\n        segment-wise contributions evaluated at the midpoint of each segment.\n        \"\"\"\n        a, b, c, d, e, f = v_params\n        total_flux = 0.0\n        n = len(polygon_vertices)\n        for i in range(n):\n            p1 = polygon_vertices[i]\n            p2 = polygon_vertices[(i + 1) % n]\n            \n            x1, y1 = p1\n            x2, y2 = p2\n            \n            dx = x2 - x1\n            dy = y2 - y1\n            \n            # Midpoint of the segment\n            mid_x = (x1 + x2) / 2.0\n            mid_y = (y1 + y2) / 2.0\n            \n            # Evaluate vector field components at the midpoint\n            v_x_mid = a * mid_x + b * mid_y + c\n            v_y_mid = d * mid_x + e * mid_y + f\n            \n            # Add segment contribution to the total flux\n            segment_flux = v_x_mid * dy - v_y_mid * dx\n            total_flux += segment_flux\n            \n        return total_flux\n\n    def generate_regular_polygon_vertices(center, radius, n_vertices):\n        \"\"\"Generates vertices for a regular polygon.\"\"\"\n        cx, cy = center\n        vertices = []\n        for k in range(n_vertices):\n            # The problem specifies k*pi/4 for an octagon, which is 2*pi*k/8.\n            theta = k * np.pi / 4.0\n            x = cx + radius * np.cos(theta)\n            y = cy + radius * np.sin(theta)\n            vertices.append((x, y))\n        return np.array(vertices)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"v_params\": (2, 1, 1, -1, 4, -2),  # a,b,c, d,e,f\n            \"outer_poly\": np.array([(0., 0.), (4., 0.), (4., 2.), (0., 2.)]),\n            \"cavity_polys\": [\n                generate_regular_polygon_vertices(center=(1.0, 1.0), radius=0.3, n_vertices=8),\n                generate_regular_polygon_vertices(center=(3.0, 1.0), radius=0.25, n_vertices=8)\n            ]\n        },\n        {\n            \"name\": \"B\",\n            \"v_params\": (0, -1, 0, 1, 0, 0),\n            \"outer_poly\": np.array([(0., 0.), (2., 0.), (2., 2.), (0., 2.)]),\n            \"cavity_polys\": [\n                np.array([(0.5, 0.5), (1.5, 0.5), (1.5, 1.5), (0.5, 1.5)])\n            ]\n        },\n        {\n            \"name\": \"C\",\n            \"v_params\": (1, 0, 2, 0, 1, -1),\n            \"outer_poly\": np.array([(0., 0.), (3., 0.), (3., 1.), (1., 1.), (1., 3.), (0., 3.)]),\n            \"cavity_polys\": [\n                np.array([(0.3, 2.2), (0.8, 2.1), (0.6, 2.6)])\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        v_params = case[\"v_params\"]\n        outer_poly = case[\"outer_poly\"]\n        cavity_polys = case[\"cavity_polys\"]\n\n        # 1. Compute Area Integral\n        divergence = v_params[0] + v_params[4]  # a + e\n        \n        area_outer = polygon_area(outer_poly)\n        area_cavities = sum(polygon_area(cavity) for cavity in cavity_polys)\n        domain_area = area_outer - area_cavities\n        \n        area_integral = divergence * domain_area\n\n        # 2. Compute Boundary Flux Integral\n        flux_outer = calculate_flux(outer_poly, v_params)\n        flux_cavities = [calculate_flux(cavity, v_params) for cavity in cavity_polys]\n        sum_flux_cavities = sum(flux_cavities)\n\n        # Correctly oriented flux (Outer - Cavities)\n        flux_correct = flux_outer - sum_flux_cavities\n        \n        # Incorrectly oriented flux (Outer + Cavities)\n        flux_incorrect = flux_outer + sum_flux_cavities\n\n        # 3. Compute absolute differences\n        diff_correct = abs(area_integral - flux_correct)\n        diff_incorrect = abs(area_integral - flux_incorrect)\n        \n        results.extend([diff_correct, diff_incorrect])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3516962"}]}