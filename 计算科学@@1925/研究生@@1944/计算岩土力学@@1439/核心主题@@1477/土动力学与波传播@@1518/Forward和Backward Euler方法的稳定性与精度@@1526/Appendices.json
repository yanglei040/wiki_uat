{"hands_on_practices": [{"introduction": "在分析了后向欧拉法的特性之后，我们现在将其与更简单的前向欧拉法（Forward Euler）进行直接对比。本练习探讨了一个带不透水边界的场景，它突显了质量守恒这一基本物理原理。通过这个练习，您将看到不稳定的显式格式如何可能违反物理约束，以及不恰当的“修复”手段（例如，简单的削波修正）为何会破坏守恒律，这进一步证明了在岩土力学问题中选择鲁棒隐式格式的必要性 [@problem_id:3525358]。", "problem": "考虑在饱和多孔柱中的一维约束固结，使用归一化变量，使得单位区间 $z \\in [0,1]$ 上的归一化孔隙压力场 $p(z,t)$ 满足扩散方程\n$$\n\\frac{\\partial p}{\\partial t} = \\frac{\\partial^2 p}{\\partial z^2},\n$$\n边界条件为零通量（不渗透）\n$$\n\\left.\\frac{\\partial p}{\\partial z}\\right|_{z=0} = 0, \\quad \\left.\\frac{\\partial p}{\\partial z}\\right|_{z=1} = 0,\n$$\n初始条件为\n$$\np(z,0) = 1 + 0.8 \\cos(3\\pi z).\n$$\n从不渗透边界固结中的质量守恒角度来看，空间平均值（归一化流体质量）\n$$\nM(t) := \\int_{0}^{1} p(z,t)\\, dz\n$$\n随时间保持恒定。对于给定的初始条件，$M(0) = 1$。将在具有 $N$ 个节点和间距 $\\Delta z = 1/(N-1)$ 的均匀网格上构建一个全离散近似，使用与零通量边界一致的二阶中心有限差分拉普拉斯算子。用 $\\mathbf{L}$ 表示离散拉普拉斯算子，使得内部格式为 $[1,-2,1]$，边界行通过镜像虚拟节点构造来强制执行零通量条件，从而第一行和最后一行的系数分别为 $[-2,2]$ 和 $[2,-2]$。时间积分将在一个固定的时间范围 $T$ 内使用前向欧拉法或后向欧拉法进行。\n\n从控制定律和边界约束出发，您的任务是：\n- 实现前向欧拉（显式）时间推进：\n$$\n\\mathbf{p}^{n+1} = \\mathbf{p}^n + r\\, \\mathbf{L} \\mathbf{p}^n,\n$$\n和后向欧拉（隐式）时间推进：\n$$\n(\\mathbf{I} - r\\, \\mathbf{L})\\, \\mathbf{p}^{n+1} = \\mathbf{p}^n,\n$$\n其中 $r := \\Delta t / \\Delta z^2$，$\\mathbf{I}$ 是单位矩阵。离散平均值为 $M^n := \\frac{1}{N}\\sum_{i=1}^{N} p_i^n$。\n- 对于前向欧拉法，评估当 $r$ 较大时，数值振荡如何可能导致非物理的负 $p_i^n$（对于归一化孔隙压力而言），以及如果应用简单的非负性修正，如何引发质量守恒的违背。您必须实现两种前向欧拉法每时间步的后处理变体：\n  1. 简单裁剪：设置 $p_i^{n+1} \\leftarrow \\max(p_i^{n+1}, 0)$。\n  2. 一种保持质量的非负性投影，通过将原始的前向欧拉更新投影到单纯形 $\\{\\mathbf{v}\\in\\mathbb{R}^N: v_i \\ge 0,\\ \\frac{1}{N}\\sum_i v_i = M^0\\}$ 上，来同时强制执行 $p_i^{n+1} \\ge 0$ 对所有 $i$ 和精确的离散质量 $M^{n+1}=M^0$。\n- 对于后向欧拉法，求解每个时间步的线性系统，并量化离散质量守恒情况。\n\n在具有 $N=51$ 个节点的均匀网格上进行初始化，初始向量由采样初始条件给出。对于每次时间积分，使用通过参数 $r$ 选择的时间步长 $\\Delta t = r\\, \\Delta z^2$，并推进 $M_{\\text{steps}} := \\left\\lfloor T / \\Delta t \\right\\rfloor$ 步，以使 $M_{\\text{steps}}\\,\\Delta t \\le T$。使用最终平均值 $M^{\\text{final}}$ 来定义相对质量误差\n$$\n\\mathcal{E} := \\left| \\frac{M^{\\text{final}} - M^0}{M^0} \\right|.\n$$\n\n您的程序必须计算以下四个测试案例的 $\\mathcal{E}$，这些案例共同探讨了稳定性、振荡和守恒性：\n- 案例1：前向欧拉法，无任何后处理（无裁剪也无投影），$r=0.25$，$T=0.01$。\n- 案例2：前向欧拉法，使用简单裁剪，$r=0.55$，$T=0.01$。\n- 案例3：前向欧拉法，使用保持质量的非负性投影，$r=0.55$，$T=0.01$。\n- 案例4：后向欧拉法，$r=5.0$，$T=0.01$。\n\n在所有案例中，要报告的结果是标量 $\\mathcal{E}$，它是无量纲的。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含四个结果，按案例1到4的顺序以逗号分隔列表形式包含在方括号中，例如，“[x1,x2,x3,x4]”，其中每个条目都是一个十进制浮点数。\n\n注释和约束：\n- 所有计算都应以双精度进行。\n- 保持质量的投影的实现对于任何实数向量都应是正确的，并能精确地（达到机器精度）强制执行非负性和规定的平均值，而不依赖于临时的迭代公差。\n- 不允许外部输入；测试套件如上所述是固定的。", "solution": "用户提供的问题是一个在计算岩土力学领域中定义明确且科学合理的问题，重点是求解一维固结方程的数值解。该问题要求实现和比较几种数值方案，评估它们的稳定性和质量守恒特性。该问题被验证为完整、一致且可形式化的。我们继续提供完整解答。\n\n问题围绕归一化孔隙压力场 $p(z,t)$ 的一维扩散方程展开：\n$$\n\\frac{\\partial p}{\\partial t} = \\frac{\\partial^2 p}{\\partial z^2}\n$$\n定义在空间域 $z \\in [0, 1]$ 上。系统受零通量（不渗透）边界条件（BCs）约束：\n$$\n\\left.\\frac{\\partial p}{\\partial z}\\right|_{z=0} = 0, \\quad \\left.\\frac{\\partial p}{\\partial z}\\right|_{z=1} = 0\n$$\n并从初始条件（IC）演化：\n$$\np(z,0) = 1 + 0.8 \\cos(3\\pi z)\n$$\n一个关键的物理原理是在不渗透柱内总流体质量的守恒。归一化总质量定义为压力场的空间平均值，$M(t) = \\int_{0}^{1} p(z,t)\\, dz$。对时间 $t$ 求导，并使用控制偏微分方程和边界条件，我们可以验证在连续设定下该量是守恒的：\n$$\n\\frac{dM}{dt} = \\int_{0}^{1} \\frac{\\partial p}{\\partial t}\\, dz = \\int_{0}^{1} \\frac{\\partial^2 p}{\\partial z^2}\\, dz = \\left[\\frac{\\partial p}{\\partial z}\\right]_{0}^{1} = \\left.\\frac{\\partial p}{\\partial z}\\right|_{z=1} - \\left.\\frac{\\partial p}{\\partial z}\\right|_{z=0} = 0 - 0 = 0\n$$\n因此，$M(t)$ 是常数。其初始值为 $M(0) = \\int_{0}^{1} (1 + 0.8 \\cos(3\\pi z))\\, dz = \\left[z + \\frac{0.8}{3\\pi} \\sin(3\\pi z)\\right]_{0}^{1} = 1$。因此，对于所有 $t \\ge 0$，$M(t)=1$。\n\n数值解是在一个有 $N=51$ 个节点的均匀网格上构建的，索引为 $i=1, \\dots, N$。网格间距为 $\\Delta z = 1/(N-1)$。节点压力向量表示为 $\\mathbf{p}(t)$。我们使用有限差分来近似空间算子 $\\frac{\\partial^2}{\\partial z^2}$。问题指定了一个离散拉普拉斯矩阵 $\\mathbf{L}$，使得半离散系统为 $\\frac{d\\mathbf{p}}{dt} = \\frac{1}{\\Delta z^2} \\mathbf{L} \\mathbf{p}$。\n\n$N \\times N$ 矩阵 $\\mathbf{L}$ 的构造如下：\n对于内部节点（$i=2, \\dots, N-1$），使用二阶中心差分：$(\\mathbf{L}\\mathbf{p})_i \\approx p_{i-1} - 2p_i + p_{i+1}$。这对应于模板 $[1, -2, 1]$。\n对于边界节点（$i=1$ 和 $i=N$），使用镜像虚拟节点来强制执行零通量条件。\n在 $z=0$（节点 $i=1$）处，条件 $\\frac{\\partial p}{\\partial z}|_{z=0}=0$ 由中心差分 $\\frac{p_2 - p_0}{2\\Delta z} = 0$ 近似，其中 $p_0$ 是虚拟节点的压力。这意味着 $p_0=p_2$。节点1处的二阶导数则为 $\\frac{p_0 - 2p_1 + p_2}{\\Delta z^2} = \\frac{p_2 - 2p_1 + p_2}{\\Delta z^2} = \\frac{-2p_1+2p_2}{\\Delta z^2}$。因此，$\\mathbf{L}$ 的第一行在前两列的系数为 $[-2, 2]$。\n在 $z=1$（节点 $i=N$）处，类似的虚拟节点 $p_{N+1}$ 给出 $p_{N+1}=p_{N-1}$。二阶导数为 $\\frac{p_{N-1} - 2p_N + p_{N+1}}{\\Delta z^2} = \\frac{p_{N-1} - 2p_N + p_{N-1}}{\\Delta z^2} = \\frac{2p_{N-1}-2p_N}{\\Delta z^2}$。因此，$\\mathbf{L}$ 的最后一行在最后两列的系数为 $[2, -2]$。\n\n离散系统的一个重要属性是它是否守恒质量。离散总质量与 $\\sum_{i=1}^{N} p_i$ 成正比。总质量的变化与 $\\sum_{i=1}^{N} (\\mathbf{L}\\mathbf{p})_i = \\mathbf{1}^T\\mathbf{L}\\mathbf{p}$ 成正比，其中 $\\mathbf{1}$ 是一个全为1的向量。如果 $\\mathbf{L}$ 的每列之和为零，则质量守恒。对于指定的 $\\mathbf{L}$，列和并非都为零。例如，第一列的和为 $L_{11} + L_{21} = -2 + 1 = -1$，第二列的和为 $L_{12} + L_{22} + L_{32} = 2 - 2 + 1 = 1$。这表明这个特定的有限差分方案本身不守恒质量，即使对于稳定方法，我们也应预期离散质量 $M^n = \\frac{1}{N}\\sum_{i=1}^{N} p_i^n$ 会有一些数值误差。\n\n时间积分使用前向欧拉法（FE）或后向欧拉法（BE）进行。设 $r = \\Delta t / \\Delta z^2$，方案为：\n1.  **前向欧拉法（显式）**：$\\mathbf{p}^{n+1} = \\mathbf{p}^n + r \\mathbf{L} \\mathbf{p}^n = (\\mathbf{I} + r\\mathbf{L})\\mathbf{p}^n$。此方案仅是条件稳定的。对于具有诺伊曼边界条件的一维扩散方程，稳定性要求 $r \\le 0.5$。大于 $0.5$ 的 $r$ 值可能导致虚假振荡和非物理的负压力。\n2.  **后向欧拉法（隐式）**：$\\mathbf{p}^{n+1} = \\mathbf{p}^n + r \\mathbf{L} \\mathbf{p}^{n+1}$，可重排为线性系统 $(\\mathbf{I} - r\\mathbf{L})\\mathbf{p}^{n+1} = \\mathbf{p}^n$。此方案对于所有 $r>0$ 都是无条件稳定的。\n\n该问题研究了处理由不稳定的FE方案产生的非物理负压力的策略。\n- **简单裁剪**：在FE更新后，任何负压力值都被设置为零：$p_i^{n+1} \\leftarrow \\max(p_i^{n+1}, 0)$。此操作是非线性的，并且不尊重质量平衡。通过移除负值，它人为地向系统增加了质量，导致违反守恒定律。\n- **保持质量的投影**：这是一种严格的方法，同时强制执行非负性和质量守恒。在原始的FE更新产生向量 $\\mathbf{v} = \\mathbf{p}^{n+1}_{\\text{raw}}$ 后，我们找到在欧几里得范数下最接近 $\\mathbf{v}$ 的向量 $\\mathbf{p}^{n+1}$，该向量受约束条件 $p_i^{n+1} \\ge 0$ 对所有 $i$ 和 $\\frac{1}{N}\\sum_i p_i^{n+1} = M^0$ 的限制。这等同于将 $\\mathbf{v}$ 投影到由这些约束定义的单纯形上。这确保了最终的更新既是物理上现实的（非负），又尊重守恒定律。\n\n我们现在为四个不同的案例计算相对质量误差 $\\mathcal{E} = |(M^{\\text{final}} - M^0)/M^0|$。初始离散质量为 $M^0 = \\frac{1}{N}\\sum_{i=1}^{N} p_i(z_i, 0) = 1.0$。\n\n- **案例1**：前向欧拉法，$r=0.25$。这在稳定极限内。我们预期演化是稳定的，但由于矩阵 $\\mathbf{L}$ 的非守恒性质，会存在非零的质量误差。\n- **案例2**：前向欧拉法，$r=0.55$。这是不稳定的。振荡将产生负压力，这些负压力被裁剪为零。这种裁剪将在每一步人为地增加总质量，导致显著的正质量误差。\n- **案例3**：前向欧拉法，$r=0.55$。这是相同的不稳定情况，但采用了保持质量的投影。投影算法在每一步强制执行 $\\sum p_i^{n+1} = N M^0$。因此，最终质量 $M^{\\text{final}}$ 应等于 $M^0$（在机器精度范围内），导致误差 $\\mathcal{E}$ 接近于零。\n- **案例4**：后向欧拉法，$r=5.0$。这个 $r$ 值远超FE的不稳定区域，但BE是无条件稳定的。解将是光滑且无振荡的。仍然预期会有小的质量误差，因为隐式更新和显式更新一样，都涉及到非守恒的算子 $\\mathbf{L}$。\n\n实现将通过设置初始条件和矩阵 $\\mathbf{L}$，然后使用指定的参数和方法对四个案例中的每一个进行时间迭代来进行。然后报告每个案例计算出的最终质量误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    使用不同的数值方案求解一维固结问题，\n    并计算四个测试案例的相对质量误差。\n    \"\"\"\n\n    def project_simplex(v, z):\n        \"\"\"\n        将向量v投影到由z缩放的概率单纯形上。\n        该单纯形定义为 {x | sum(x) = z, x_i >= 0}。\n        此函数实现了Duchi等人(2008)的算法。\n\n        Args:\n            v (np.ndarray): 要投影的向量。\n            z (float): 投影向量元素的目标总和。\n\n        Returns:\n            np.ndarray: 投影后的向量。\n        \"\"\"\n        n_features = v.shape[0]\n        u = np.sort(v)[::-1]\n        cssv = np.cumsum(u)\n        \n        # 寻找满足条件的最大索引rho。\n        # 此条件源自投影问题的KKT条件。\n        indices = np.arange(1, n_features + 1)\n        cond = u + (z - cssv) / indices > 0\n        \n        # 在本问题的背景下，v的条目将使此搜索有效。\n        rho_idx = np.where(cond)[0][-1]\n        \n        # 计算拉格朗日乘子（阈值）。\n        lambda_ = (cssv[rho_idx] - z) / (rho_idx + 1)\n        \n        # 应用投影公式。\n        return np.maximum(v - lambda_, 0)\n\n    # --- 问题设置 ---\n    # 全局参数\n    N = 51\n    T = 0.01\n\n    # 空间离散化\n    dz = 1.0 / (N - 1)\n    z_grid = np.linspace(0.0, 1.0, N, dtype=np.float64)\n\n    # 初始条件\n    p0 = 1.0 + 0.8 * np.cos(3 * np.pi * z_grid)\n    M0 = np.mean(p0)\n\n    # 适用于诺伊曼边界条件（镜像虚拟节点）的离散拉普拉斯矩阵L\n    L = np.zeros((N, N), dtype=np.float64)\n    # 内部节点（模板 [1, -2, 1]）\n    for i in range(1, N - 1):\n        L[i, i - 1] = 1.0\n        L[i, i] = -2.0\n        L[i, i + 1] = 1.0\n    # 边界节点\n    L[0, 0] = -2.0  # i=1时的模板 [-2, 2]\n    L[0, 1] = 2.0\n    L[N - 1, N - 2] = 2.0  # i=N时的模板 [2, -2]\n    L[N - 1, N - 1] = -2.0\n\n    # 问题中定义的测试案例\n    test_cases = [\n        {'method': 'FE_vanilla', 'r': 0.25},\n        {'method': 'FE_clip', 'r': 0.55},\n        {'method': 'FE_project', 'r': 0.55},\n        {'method': 'BE', 'r': 5.0}\n    ]\n\n    results = []\n\n    # --- 各案例的模拟循环 ---\n    for case in test_cases:\n        r = case['r']\n        method = case['method']\n        \n        dt = r * dz**2\n        num_steps = int(np.floor(T / dt))\n        \n        p = p0.copy()\n\n        if method.startswith('FE'):\n            # 前向欧拉更新矩阵 A = I + r*L\n            A_fe = np.eye(N, dtype=np.float64) + r * L\n            for _ in range(num_steps):\n                p_raw = A_fe @ p\n                \n                if method == 'FE_clip':\n                    p = np.maximum(p_raw, 0)\n                elif method == 'FE_project':\n                    # 将原始更新投影到单纯形 {v | v_i>=0, sum(v)=N*M0} 上\n                    p = project_simplex(p_raw, N * M0)\n                else:  # FE_vanilla\n                    p = p_raw\n        \n        elif method == 'BE':\n            # 后向欧拉系统矩阵 A = I - r*L\n            A_be = np.eye(N, dtype=np.float64) - r * L\n            for _ in range(num_steps):\n                p = np.linalg.solve(A_be, p)\n\n        # 计算最终质量和相对误差\n        M_final = np.mean(p)\n        \n        # M0为1.0，但为确保正确性使用通用公式\n        if M0 == 0.0:\n            error = np.abs(M_final - M0)\n        else:\n            error = np.abs((M_final - M0) / M0)\n        \n        results.append(error)\n\n    # --- 最终输出 ---\n    # 以方括号内逗号分隔的格式打印结果\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3525358"}, {"introduction": "真实的岩土力学问题不仅是刚性的，而且通常是高度非线性的，例如涉及弹塑性或软化行为。虽然在这种情况下，后向欧拉法仍然是首选，但其应用需要在每个时间步求解一个非线性代数方程组。本练习将引导您进入这一关键的实施细节，为一个典型的非线性软化模型部署求解器，并探索时间步长选择对牛顿法（Newton-Raphson method）收敛性的影响，最终推导出保证计算鲁棒性的自适应时间步长策略 [@problem_id:3525394]。", "problem": "考虑一个受计算岩土力学中非弹性本构更新启发的标量率相关软化模型。令 $t \\in [0,T]$ 表示时间，$\\epsilon(t)$ 为给定的总应变历史。内变量 $p(t)$ 代表一个累积的非弹性度量（例如，类似粘塑性应变的量），并根据以下非线性常微分方程 (ODE) 演化：\n$$\n\\frac{dp}{dt} = \\frac{1}{\\eta}\\,\\left[\\max\\!\\left(0,\\,f(p,\\epsilon(t))\\right)\\right]^m,\n$$\n其中粘度参数 $\\eta>0$，非线性指数 $m \\ge 2$，超应力函数表现出软化特性：\n$$\nf(p,\\epsilon) = E\\,(\\epsilon - p) - \\sigma_{y0}\\,\\bigl(1 - c\\,p\\bigr).\n$$\n此处，$E>0$ 是刚度标度，$\\sigma_{y0}>0$ 是初始屈服应力标度，$c>0$ 控制强度的软化。给定的应变为线性斜坡函数：\n$$\n\\epsilon(t) = \\epsilon_{\\max}\\,\\frac{t}{T},\n$$\n其中 $\\epsilon_{\\max}>0$ 且 $T>0$。初始条件为 $p(0)=0$。假设所有量均为无量纲。\n\n要求您使用前向欧拉法和后向欧拉法的基本离散思想，为此初值问题分析并实现一个时间积分器，并将时间步长、不动点非线性与牛顿-拉夫逊 (NR) 收敛行为联系起来。您的推导必须从 ODE 的前向和后向欧拉时间离散化定义以及求解非线性代数方程的牛顿-拉夫逊方法定义开始。\n\n1. 从 ODE 和后向欧拉法的定义出发，推导单个时间步 $t_n \\to t_{n+1}$ 中关于未知量 $p_{n+1}$ 的非线性残差，用 $p_n$、$\\Delta t = t_{n+1}-t_n$ 和 $\\epsilon_{n+1} = \\epsilon(t_{n+1})$ 表示。然后，通过计算残差对 $p_{n+1}$ 的导数，推导牛顿-拉夫逊线性化。\n\n2. 通过分析您推导出的牛顿-拉夫逊更新，获得一个关于 $\\Delta t$ 的充分局部条件，该条件在非弹性机制被激活时（即 $f(p_{n+1},\\epsilon_{n+1})>0$ 时）能促进牛顿法收敛。您的条件应以 ODE 右端项关于 $p$ 的局部斜率来表示，并应清楚地说明增加 $\\Delta t$ 如何破坏隐式不动点映射的单调性或收缩性，从而阻碍牛顿法收敛。\n\n3. 使用第 2 项中的充分条件，推导一种当牛顿法残差减小停滞时可以应用的自适应时间步长缩减启发式方法。该启发式方法必须提供一个公式，用于根据已知的步前状态 $(t_n,p_n)$ 和输入的 $\\epsilon_{n+1}$ 计算缩减后的试验时间步长 $\\Delta t_{\\text{new}}$，且仅使用局部可用信息，例如 $p_n$、$\\epsilon_{n+1}$ 以及它们导出的 ODE 右端项关于 $p$ 的局部导数的估计值。请陈述您的启发式方法并附带一个安全因子，并简要解释其合理性。\n\n4. 编写一个程序，在每个步骤中使用牛顿-拉夫逊法，对上述模型执行后向欧拉法的时间步进。实现两个驱动程序：\n   - 一个固定步长驱动程序，该程序尝试使用指定的 $\\Delta t$ 进行步进，如果牛顿-拉夫逊法在最大迭代次数内未收敛到容差，或者如果残差在几次迭代中没有有意义地减小（残差停滞），则宣布步长失败。\n   - 一个自适应驱动程序，该程序在固定步长失败时，调用您的启发式方法来减小 $\\Delta t$ 并重试，直到成功或达到最小时间步长阈值。\n\n对于数值测试，请使用以下无量纲参数，这些参数会产生一个高度非线性的软化区域：\n- $E=1$, $\\sigma_{y0}=1$, $c=2$, $\\eta=1$, $m=3$, $T=1$, $\\epsilon_{\\max}=1.5$。\n- 初始条件 $p(0)=0$。\n- 牛顿-拉夫逊法绝对残差容差为 $10^{-10}$，每步最多迭代 10 次，超过则宣布失败。\n- 残差停滞检测：如果在任何连续 3 次迭代的窗口内，绝对残差在高于容差的同时，减小幅度不足 0.5 倍，则视为停滞。\n\n您的程序必须实现以下测试套件并输出所要求的数值结果：\n\n- 测试 A（小步长下的精度）：在 $[0,1]$ 上使用固定步长 $\\Delta t = 2\\times 10^{-3}$ 的后向欧拉法。计算最终值 $p_{\\text{BE}}(T)$ 及其与使用 $\\Delta t_{\\text{ref}}=10^{-4}$ 的后向欧拉法计算的参考解 $p_{\\text{ref}}(T)$ 的绝对误差。以浮点数形式返回此误差。\n\n- 测试 B（中等步长下的牛顿法鲁棒性）：在 $[0,1]$ 上使用固定步长 $\\Delta t = 2\\times 10^{-2}$ 的后向欧拉法。报告是否有任何步骤因牛顿法不收敛或停滞而失败，如果发生任何失败则编码为整数 $1$，否则为 $0$。\n\n- 测试 C（大步长下的牛顿法鲁棒性）：在 $[0,1]$ 上使用固定步长 $\\Delta t = 2\\times 10^{-1}$ 的后向欧拉法。报告是否有任何步骤因牛顿法不收敛或停滞而失败，如果发生任何失败则编码为整数 $1$，否则为 $0$。\n\n- 测试 D（自适应缩减的有效性）：在 $[0,1]$ 上使用初始试验步长 $\\Delta t_{\\text{init}} = 2\\times 10^{-1}$ 和第 3 项中的启发式方法进行自适应后向欧拉法计算。报告执行的时间步长削减（即 $\\Delta t$ 的缩减）的总次数，结果为非负整数。\n\n所有输出均为无量纲。您的程序应生成单行输出，其中包含按以下顺序排列、用逗号分隔并用方括号括起来的结果：$[\\text{测试 A 结果}, \\text{测试 B 结果}, \\text{测试 C 结果}, \\text{测试 D 结果}]$。", "solution": "该问题要求对一个标量率相关软化模型推导并实现数值方法，这是计算岩土力学中的一个常见范式。对问题陈述的验证证实了其科学合理性、自洽性和良定性。因此，我们可以着手求解。\n\n内变量 $p(t)$ 的控制常微分方程 (ODE) 为：\n$$\n\\frac{dp}{dt} = \\frac{1}{\\eta}\\,\\left[\\max\\!\\left(0,\\,f(p,\\epsilon(t))\\right)\\right]^m\n$$\n初始条件为 $p(0)=0$。超应力函数 $f$ 和应变历史 $\\epsilon(t)$ 由下式给出：\n$$\nf(p,\\epsilon) = E\\,(\\epsilon - p) - \\sigma_{y0}\\,\\bigl(1 - c\\,p\\bigr)\n$$\n$$\n\\epsilon(t) = \\epsilon_{\\max}\\,\\frac{t}{T}\n$$\n对于特定参数 $E=1$, $\\sigma_{y0}=1$, $c=2$, $\\eta=1$, $m=3$, $\\epsilon_{\\max}=1.5$ 和 $T=1$，函数简化为：\n$$\nf(p,\\epsilon) = 1(\\epsilon-p) - 1(1-2p) = \\epsilon + p - 1\n$$\n$$\n\\epsilon(t) = 1.5t\n$$\n$$\n\\frac{dp}{dt} = \\left[\\max\\!\\left(0,\\,\\epsilon(t) + p - 1\\right)\\right]^3\n$$\n为了清晰和高效，此简化形式将在实现中使用。\n\n### 1. 后向欧拉残差和牛顿-拉夫逊线性化\n\n后向欧拉 (BE) 法将 ODE 在一个时间步 $\\Delta t = t_{n+1} - t_n$ 上离散化为：\n$$\n\\frac{p_{n+1} - p_n}{\\Delta t} = \\left.\\frac{dp}{dt}\\right|_{t=t_{n+1}}\n$$\n将在未知状态 $(p_{n+1}, t_{n+1})$ 处求值的 ODE 右端项代入，得到隐式方程：\n$$\np_{n+1} = p_n + \\frac{\\Delta t}{\\eta} \\left[ \\max(0, f(p_{n+1}, \\epsilon_{n+1})) \\right]^m\n$$\n其中 $\\epsilon_{n+1} = \\epsilon(t_{n+1})$。为了使用牛顿-拉夫逊 (NR) 方法求解 $p_{n+1}$，我们定义一个残差函数 $R(p_{n+1})$，其根即为解：\n$$\nR(p_{n+1}) = p_{n+1} - p_n - \\frac{\\Delta t}{\\eta} \\left[ \\max(0, f(p_{n+1}, \\epsilon_{n+1})) \\right]^m = 0\n$$\nNR 方法需要残差对未知量 $p_{n+1}$ 的导数，这通常被称为切线（刚度）。\n$$\nR'(p_{n+1}) = \\frac{dR}{dp_{n+1}} = 1 - \\frac{\\Delta t}{\\eta} \\frac{d}{dp_{n+1}} \\left( \\left[ \\max(0, f(p_{n+1}, \\epsilon_{n+1})) \\right]^m \\right)\n$$\n该导数取决于系统是处于弹性状态（$f \\le 0$）还是塑性/非弹性状态（$f > 0$）。\n如果 $f(p_{n+1}, \\epsilon_{n+1}) \\le 0$，则 max 项为零，其导数也为零。因此，$R'(p_{n+1}) = 1$。\n如果 $f(p_{n+1}, \\epsilon_{n+1}) > 0$，则非弹性机制被激活。我们应用链式法则：\n$$\n\\frac{d}{dp_{n+1}} \\left[ f(p_{n+1}, \\epsilon_{n+1}) \\right]^m = m \\left[ f(p_{n+1}, \\epsilon_{n+1}) \\right]^{m-1} \\frac{\\partial f}{\\partial p_{n+1}}\n$$\n$f$ 对 $p$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial p} = \\frac{\\partial}{\\partial p} \\left( E(\\epsilon - p) - \\sigma_{y0}(1 - cp) \\right) = -E + \\sigma_{y0}c\n$$\n对于给定的参数，$\\frac{\\partial f}{\\partial p} = -1 + 1(2) = 1$。\n因此，对于激活情况，切线（刚度）为：\n$$\nR'(p_{n+1}) = 1 - \\frac{\\Delta t}{\\eta} m \\left[ f(p_{n+1}, \\epsilon_{n+1}) \\right]^{m-1} (\\sigma_{y0}c - E)\n$$\n那么，在第 $(k)$ 次迭代中对 $p_{n+1}$ 的牛顿-拉夫逊更新为 $p_{n+1}^{(k+1)} = p_{n+1}^{(k)} - R(p_{n+1}^{(k)}) / R'(p_{n+1}^{(k)})$。\n\n### 2. 牛顿-拉夫逊收敛的充分条件\n\nBE 方程可以写成一个不动点问题 $p_{n+1} = G(p_{n+1})$，其中映射 $G(p) = p_n + \\Delta t \\, \\mathcal{F}(p, \\epsilon_{n+1})$，而 $\\mathcal{F}$ 是 ODE 的右端项。不动点迭代收敛的一个充分条件是该映射为压缩映射，即 $|G'(p)|  1$。这也是 NR 稳健收敛的一个强有力的指标。\n映射的导数为 $G'(p) = \\Delta t \\, \\frac{\\partial \\mathcal{F}}{\\partial p}(p, \\epsilon_{n+1})$。从第 1 部分可知，$R'(p) = 1 - G'(p)$。残差单调性的条件 $R'(p) > 0$ 等价于 $G'(p)  1$。由于 $\\sigma_{y0}c - E > 0$，我们有 $\\frac{\\partial \\mathcal{F}}{\\partial p} > 0$，因此 $G'(p) > 0$。于是，条件变为：\n$$\nG'(p) = \\Delta t \\, \\frac{\\partial \\mathcal{F}}{\\partial p}  1 \\implies \\Delta t  \\frac{1}{\\frac{\\partial \\mathcal{F}}{\\partial p}}\n$$\n代入激活情况下的导数表达式：\n$$\n\\frac{\\partial \\mathcal{F}}{\\partial p} = \\frac{m (\\sigma_{y0}c - E)}{\\eta} \\left[ f(p, \\epsilon_{n+1}) \\right]^{m-1}\n$$\n因此，$\\Delta t$ 的充分局部条件为：\n$$\n\\Delta t  \\frac{\\eta}{m (\\sigma_{y0}c - E) \\left[ f(p_{n+1}, \\epsilon_{n+1}) \\right]^{m-1}}\n$$\n物理上，$\\frac{\\partial \\mathcal{F}}{\\partial p}$ 项代表了 ODE 演化相对于状态变量 $p$ 的“刚度”。随着软化过程的发展，$p$ 增加，导致 $f$ 增长，这反过来又（由于指数 $m-1 \\ge 1$）急剧增加了 $\\frac{\\partial \\mathcal{F}}{\\partial p}$。如果 $\\Delta t$ 太大，$\\Delta t \\frac{\\partial \\mathcal{F}}{\\partial p}$ 项可能超过 1。这导致不动点映射 $G$ 失去其收缩性，NR 残差 $R$ 失去单调性（$R'  0$）。基于负切线（刚度）的 NR 步长可能会超调解，导致振荡或发散。\n\n### 3. 自适应时间步长启发式方法\n\n当 NR 求解对于给定的时间步 $\\Delta t_{old}$ 失败时，通常表明违反了第 2 部分推导的条件。我们可以设计一种启发式方法，通过使用局部可用信息来估计关键项，从而计算出一个更小、更安全的时间步 $\\Delta t_{new}$。我们不知道解 $p_{n+1}$，因此我们使用步长开始时的状态 $(p_n, t_n)$ 和试验步结束时的应变 $\\epsilon_{n+1} = \\epsilon(t_n + \\Delta t_{old})$。\n\n该启发式方法如下：\n1. 估计 ODE 右端项的局部斜率：\n$$\nk_{\\text{local}} = \\frac{\\partial \\mathcal{F}}{\\partial p}(p_n, \\epsilon_{n+1}) = \\frac{m (\\sigma_{y0}c - E)}{\\eta} \\left[\\max(0, f(p_n, \\epsilon_{n+1}))\\right]^{m-1}\n$$\n2. 如果 $k_{\\text{local}} > 0$，则根据稳定性条件计算一个“安全”时间步，并包含一个安全因子 $\\alpha \\in (0,1)$，例如 $\\alpha=0.8$：\n$$\n\\Delta t_{\\text{safe}} = \\frac{\\alpha}{k_{\\text{local}}}\n$$\n3. 新的时间步应从旧的时间步缩减而来。一个稳健的公式将此估计与简单的二分法结合起来：\n$$\n\\Delta t_{\\text{new}} = \\min(0.5 \\cdot \\Delta t_{\\text{old}}, \\Delta t_{\\text{safe}})\n$$\n如果 $k_{\\text{local}} \\le 0$，则失败可能不是由这种特定的不稳定机制引起的，简单的二分法 $\\Delta t_{new} = 0.5 \\cdot \\Delta t_{old}$ 是一个合理的后备方案。\n\n这种启发式方法是合理的，因为它通过确保新的时间步遵守系统的局部特征时间尺度 $1/k_{\\text{local}}$，直接针对数值不稳定性的源头。\n\n### 4. 实现与数值测试\n\n以下部分展示了针对指定的后向欧拉-牛顿-拉夫逊格式的固定步长和自适应驱动程序的 Python 实现，以及四个要求测试的执行过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Model and Numerical Parameters ---\n# Model Parameters (dimensionless)\nE = 1.0\nSIGMA_Y0 = 1.0\nC = 2.0\nETA = 1.0\nM = 3.0\nT_FINAL = 1.0\nEPS_MAX = 1.5\n\n# Numerical Parameters for Solvers\nNR_TOL = 1e-10\nNR_MAX_ITER = 10\nNR_STALL_FACTOR = 0.5\nNR_STALL_WINDOW = 3\nADAPTIVE_SAFETY_FACTOR = 0.8\nMIN_DT = 1e-8\n\n\n# --- Constitutive and Model Functions ---\n\ndef epsilon(t: float) -> float:\n    \"\"\"Computes the prescribed total strain at a given time.\"\"\"\n    # Ensure time doesn't exceed the final time for epsilon calculation\n    t_clamped = min(t, T_FINAL)\n    return EPS_MAX * t_clamped / T_FINAL\n\ndef f_overstress(p: float, eps: float) -> float:\n    \"\"\"Computes the overstress function f(p, eps).\"\"\"\n    # Using simplified form from derivation: eps + p - 1\n    return eps + p - 1.0\n\ndef df_dp(p: float, eps: float) -> float:\n    \"\"\"Computes the partial derivative of f with respect to p.\"\"\"\n    # Using simplified form from derivation: 1.0\n    return 1.0\n\n\n# --- Core Numerical Solvers ---\n\ndef solve_step_be(p_n: float, t_n: float, dt: float) -> tuple[float, str]:\n    \"\"\"\n    Solves a single time step using Backward Euler and Newton-Raphson.\n\n    Args:\n        p_n: Value of p at the beginning of the step.\n        t_n: Time at the beginning of the step.\n        dt: Time step size.\n\n    Returns:\n        A tuple containing the new value of p and a status string \n        ('success', 'failure_stall', 'failure_singular', 'failure_max_iter').\n    \"\"\"\n    t_np1 = t_n + dt\n    eps_np1 = epsilon(t_np1)\n    \n    x_k = p_n  # Initial guess for p_{n+1}\n    res_hist = []\n\n    for k in range(NR_MAX_ITER):\n        f_val = f_overstress(x_k, eps_np1)\n        \n        if f_val = 0:  # Elastic case\n            residual = x_k - p_n\n            tangent = 1.0\n        else:  # Plastic case\n            f_pow_m = f_val**M\n            f_pow_m1 = f_val**(M - 1.0)\n            residual = x_k - p_n - (dt / ETA) * f_pow_m\n            tangent = 1.0 - (dt / ETA) * M * f_pow_m1 * df_dp(x_k, eps_np1)\n\n        abs_res = abs(residual)\n        res_hist.append(abs_res)\n        \n        if abs_res  NR_TOL:\n            return x_k, 'success'\n        \n        if k >= NR_STALL_WINDOW -1: # check history for stall, index from 0\n            if len(res_hist) > NR_STALL_WINDOW and res_hist[-1] >= NR_STALL_FACTOR * res_hist[-1 - NR_STALL_WINDOW]:\n                 return p_n, 'failure_stall'\n\n        if abs(tangent)  1e-12: # Avoid division by zero\n            return p_n, 'failure_singular'\n\n        x_k -= residual / tangent\n\n    return p_n, 'failure_max_iter'\n\n\ndef get_adaptive_dt(p_n: float, t_n: float, dt_old: float) -> float:\n    \"\"\"Computes a reduced time step using the derived heuristic.\"\"\"\n    eps_np1 = epsilon(t_n + dt_old)\n    f_est = f_overstress(p_n, eps_np1)\n    \n    if f_est = 0:\n        return 0.5 * dt_old\n\n    k_local = (M * df_dp(p_n, eps_np1) / ETA) * (f_est**(M - 1.0))\n    \n    if k_local = 1e-12: # If stiffness is negligible, just bisect\n        return 0.5 * dt_old\n    \n    dt_safe = ADAPTIVE_SAFETY_FACTOR / k_local\n    return min(0.5 * dt_old, dt_safe)\n\n\n# --- Driver Functions for Tests ---\n\ndef run_fixed_step_solver(dt: float) -> tuple[float, int]:\n    \"\"\"Runs the simulation with a fixed time step.\"\"\"\n    t = 0.0\n    p = 0.0\n    num_failures = 0\n    \n    while t  T_FINAL:\n        current_dt = min(dt, T_FINAL - t)\n        if current_dt  1e-12: break\n\n        p_new, status = solve_step_be(p, t, current_dt)\n        \n        if status != 'success':\n            num_failures += 1\n        \n        t += current_dt\n        p = p_new\n        \n    return p, num_failures\n\n\ndef run_adaptive_solver(dt_init: float) -> int:\n    \"\"\"Runs the simulation with adaptive time stepping.\"\"\"\n    t = 0.0\n    p = 0.0\n    dt = dt_init\n    num_cuts = 0\n\n    while t  T_FINAL:\n        current_dt_trial = min(dt, T_FINAL - t)\n\n        step_succeeded = False\n        while not step_succeeded:\n            if current_dt_trial  MIN_DT:\n                raise RuntimeError(\"Adaptive time step fell below minimum threshold.\")\n\n            p_new, status = solve_step_be(p, t, current_dt_trial)\n            \n            if status == 'success':\n                t += current_dt_trial\n                p = p_new\n                dt = current_dt_trial  # Use successful step for next trial\n                step_succeeded = True\n            else:\n                num_cuts += 1\n                dt_new = get_adaptive_dt(p, t, current_dt_trial)\n                current_dt_trial = dt_new\n                \n    return num_cuts\n\ndef solve():\n    \"\"\"\n    Main function to execute all tests and print the final results.\n    \"\"\"\n    # Test A: Accuracy check against a reference solution\n    p_ref, _ = run_fixed_step_solver(dt=1e-4)\n    p_test_a, _ = run_fixed_step_solver(dt=2e-3)\n    result_a = abs(p_test_a - p_ref)\n\n    # Test B: Robustness check with medium fixed step\n    _, failures_b = run_fixed_step_solver(dt=2e-2)\n    result_b = 1 if failures_b > 0 else 0\n\n    # Test C: Robustness check with large fixed step\n    _, failures_c = run_fixed_step_solver(dt=2e-1)\n    result_c = 1 if failures_c > 0 else 0\n    \n    # Test D: Effectiveness of adaptive stepping\n    # The stall detection logic in the original problem description is a bit ambiguous.\n    # The corrected version in `solve_step_be` is a robust implementation.\n    # We will use this corrected logic for the test.\n    # Note: `failure_stall` is very sensitive to implementation details. Let's adjust the logic slightly to be more robust.\n    # A simpler stall check: if the residual reduction is less than a factor in one step.\n    # Re-coding the stall check to be more aligned with the original problem statement.\n    def solve_step_be_for_test_D(p_n: float, t_n: float, dt: float) -> tuple[float, str]:\n        t_np1 = t_n + dt\n        eps_np1 = epsilon(t_np1)\n        x_k = p_n\n        res_hist = []\n        for k in range(NR_MAX_ITER):\n            f_val = f_overstress(x_k, eps_np1)\n            if f_val = 0:\n                residual, tangent = x_k - p_n, 1.0\n            else:\n                f_pow_m = f_val**M\n                f_pow_m1 = f_val**(M - 1.0)\n                residual = x_k - p_n - (dt / ETA) * f_pow_m\n                tangent = 1.0 - (dt / ETA) * M * f_pow_m1 * df_dp(x_k, eps_np1)\n            \n            abs_res = abs(residual)\n            if abs_res  NR_TOL: return x_k, 'success'\n            \n            res_hist.append(abs_res)\n            if k >= NR_STALL_WINDOW - 1: # Original prompt implies a window of 3 iterations\n                # Check if current residual is not much smaller than 3 iterations ago\n                if res_hist[-1] >= NR_STALL_FACTOR * res_hist[-NR_STALL_WINDOW]:\n                    return p_n, 'failure_stall'\n\n            if abs(tangent)  1e-12: return p_n, 'failure_singular'\n            x_k -= residual / tangent\n        return p_n, 'failure_max_iter'\n\n    # Overwrite the solver for adaptive run to use the specific stall logic\n    global solve_step_be\n    original_solver = solve_step_be\n    solve_step_be = solve_step_be_for_test_D\n\n    result_d = run_adaptive_solver(dt_init=2e-1)\n    \n    solve_step_be = original_solver # Restore solver\n\n    results = [result_a, result_b, result_c, result_d]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nif __name__ == \"__main__\":\n    # Temporarily modify the solver for Test D as the stall check logic is sensitive.\n    # The original provided code for problem 2 had some corrupted inequality signs.\n    # The corrected code here is robust, but for faithful reproduction of a potential\n    # specific test case, the logic for stall detection might need to be fine-tuned.\n    # The current implementation is a standard and robust way to handle it.\n    \n    # A cleaner way to run the test without global modification\n    \n    def solve_final():\n        p_ref, _ = run_fixed_step_solver(dt=1e-4)\n        p_test_a, _ = run_fixed_step_solver(dt=2e-3)\n        result_a = abs(p_test_a - p_ref)\n        _, failures_b = run_fixed_step_solver(dt=2e-2)\n        result_b = 1 if failures_b > 0 else 0\n        _, failures_c = run_fixed_step_solver(dt=2e-1)\n        result_c = 1 if failures_c > 0 else 0\n\n        # Dedicated adaptive run with specific stall logic\n        def run_adaptive_solver_specific(dt_init: float) -> int:\n            t = 0.0\n            p = 0.0\n            dt = dt_init\n            num_cuts = 0\n            while t  T_FINAL:\n                current_dt_trial = min(dt, T_FINAL - t)\n                step_succeeded = False\n                while not step_succeeded:\n                    if current_dt_trial  MIN_DT:\n                        raise RuntimeError(\"Adaptive time step fell below minimum threshold.\")\n                    \n                    # Using the more direct stall check for this test\n                    p_new, status = solve_step_be(p, t, current_dt_trial)\n\n                    if status == 'success':\n                        t += current_dt_trial\n                        p = p_new\n                        dt = current_dt_trial\n                        step_succeeded = True\n                    else:\n                        num_cuts += 1\n                        dt_new = get_adaptive_dt(p, t, current_dt_trial)\n                        current_dt_trial = dt_new\n            return num_cuts\n        \n        result_d = run_adaptive_solver_specific(dt_init=2e-1)\n        results = [result_a, result_b, result_c, result_d]\n        print(f\"[{','.join(map(str, results))}]\")\n    \n    solve_final()\n```", "id": "3525394"}]}