{"hands_on_practices": [{"introduction": "要掌握任何数值积分方法，我们首先必须理解其精度。本练习通过分析 Newmark-$\\beta$ 方法的局部截断误差，深入探讨其理论核心。通过假设一个精确的随时间多项式变化的解，您将推导出参数 $\\beta$ 和 $\\gamma$ 的选择如何决定该方法的精度，从而确定其二阶精度的阶条件，并找出使该方法对于线性变化的加速度能够得到精确解的特定参数。[@problem_id:3532505]", "problem": "在计算岩土力学中，考虑一个半离散土动力学模型的单自由度（DOF）分量，其运动学满足 $u^{\\prime}(t)=v(t)$ 和 $v^{\\prime}(t)=a(t)$。带有参数 $\\beta$ 和 $\\gamma$ 的 Newmark 时间积分族通过标准运动学关系，在步长为 $\\Delta t0$ 的均匀时间网格 $t_{n}$ 上更新位移、速度和加速度：\n$$\nu_{n+1}=u_{n}+\\Delta t\\,v_{n}+\\Delta t^{2}\\left(\\frac{1}{2}-\\beta\\right)a_{n}+\\Delta t^{2}\\beta\\,a_{n+1},\\qquad\nv_{n+1}=v_{n}+\\Delta t\\left((1-\\gamma)a_{n}+\\gamma\\,a_{n+1}\\right),\n$$\n其中 $u_{n}\\equiv u(t_{n})$，$v_{n}\\equiv v(t_{n})$，$a_{n}\\equiv a(t_{n})$。将位移更新所导出的算法加速度 $a_{n+1}^{\\text{alg}}$ 定义为通过代数方法对位移关系求解 $a_{n+1}$ 所得到的值：\n$$\na_{n+1}^{\\text{alg}}=\\frac{1}{\\beta\\,\\Delta t^{2}}\\left(u_{n+1}-u_{n}-\\Delta t\\,v_{n}\\right)-\\frac{\\frac{1}{2}-\\beta}{\\beta}\\,a_{n}.\n$$\n\n假设在一个步长内，关于 $t_{n}$ 的精确位移是时间上的一个四次多项式，\n$$\nu(t_{n}+\\tau)=u_{n}+v_{n}\\,\\tau+\\frac{1}{2}a_{n}\\,\\tau^{2}+\\frac{1}{6}j_{n}\\,\\tau^{3}+\\frac{1}{24}s_{n}\\,\\tau^{4},\n$$\n其中 $j_{n}\\equiv u^{(3)}(t_{n})$（急动度）和 $s_{n}\\equiv u^{(4)}(t_{n})$（跃度）在该时间步内为常数。令 $u_{n+1}^{\\text{exact}}=u(t_{n}+\\Delta t)$，$v_{n+1}^{\\text{exact}}=v(t_{n}+\\Delta t)$，以及 $a_{n+1}^{\\text{exact}}=a(t_{n}+\\Delta t)$。\n\n1. 仅使用运动学恒等式 $u^{\\prime}=v$ 和 $v^{\\prime}=a$，将 $u_{n+1}^{\\text{exact}}$、$v_{n+1}^{\\text{exact}}$ 和 $a_{n+1}^{\\text{exact}}$ 在 $t_{n}$ 处进行泰勒级数展开，直至决定局部截断误差的第一个非零项。\n2. 将这些展开式代入 Newmark 运动学更新公式，以 $\\Delta t$ 的渐近级数形式，获得单步局部误差 $E_{u}=u_{n+1}^{\\text{NM}}-u_{n+1}^{\\text{exact}}$、$E_{v}=v_{n+1}^{\\text{NM}}-v_{n+1}^{\\text{exact}}$ 和 $E_{a}=a_{n+1}^{\\text{alg}}-a_{n+1}^{\\text{exact}}$，每项保留其第一个非零项。\n3. 根据这些表达式，验证关联 $\\beta$ 和 $\\gamma$ 的阶条件，并确定唯一的参数对 $(\\beta,\\gamma)$，使得对于任何时间上的三次位移 $u(t)$（即当 $s_{n}=0$ 但 $j_{n}$ 可能非零时），Newmark 更新在一个步长内对 $u_{n+1}$、$v_{n+1}$ 和 $a_{n+1}$ 同时是精确的。\n\n请以 $\\mathrm{pmatrix}$ 格式的单个行向量形式提供最终答案 $(\\beta,\\gamma)$，无单位且不进行四舍五入。", "solution": "该问题陈述是关于常微分方程数值积分方法分析的一个有效练习，特别是 Newmark-$\\beta$ 方法在计算动力学中的应用。它具有科学依据，是适定且客观的。所有必要信息均已提供，任务也已明确定义。\n\n解题过程按题目要求分为三部分。\n\n### 第一部分：精确解的泰勒级数展开\n\n给定在时间步 $[t_n, t_{n+1}]$ 内的精确位移是关于时间增量 $\\tau = t - t_n$ 的四次多项式：\n$$u(t_{n}+\\tau)=u_{n}+v_{n}\\,\\tau+\\frac{1}{2}a_{n}\\,\\tau^{2}+\\frac{1}{6}j_{n}\\,\\tau^{3}+\\frac{1}{24}s_{n}\\,\\tau^{4}$$\n其中 $u_n=u(t_n)$，$v_n=u'(t_n)$，$a_n=u''(t_n)$，$j_n=u^{(3)}(t_n)$，$s_n=u^{(4)}(t_n)$。\n\n使用运动学恒等式 $v(t) = u'(t)$ 和 $a(t) = v'(t)$，我们将 $u(t_n+\\tau)$ 的表达式对 $\\tau$ 求导，以求得速度和加速度。\n\n速度为：\n$$v(t_{n}+\\tau) = \\frac{d}{d\\tau}u(t_{n}+\\tau) = v_{n}+a_{n}\\,\\tau+\\frac{1}{2}j_{n}\\,\\tau^{2}+\\frac{1}{6}s_{n}\\,\\tau^{3}$$\n\n加速度为：\n$$a(t_{n}+\\tau) = \\frac{d}{d\\tau}v(t_{n}+\\tau) = a_{n}+j_{n}\\,\\tau+\\frac{1}{2}s_{n}\\,\\tau^{2}$$\n\n为了找到时间步末端的精确值，我们令 $\\tau = \\Delta t$：\n$u_{n+1}^{\\text{exact}} = u(t_{n}+\\Delta t) = u_{n}+v_{n}\\,\\Delta t+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}$\n$v_{n+1}^{\\text{exact}} = v(t_{n}+\\Delta t) = v_{n}+a_{n}\\,\\Delta t+\\frac{1}{2}j_{n}\\,\\Delta t^{2}+\\frac{1}{6}s_{n}\\,\\Delta t^{3}$\n$a_{n+1}^{\\text{exact}} = a(t_{n}+\\Delta t) = a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}$\n\n### 第二部分：局部截断误差\n\n局部截断误差是在单步中产生的误差，假设在时间步开始时的所有值（$u_n$、$v_n$、$a_n$）都是精确的。为了计算 Newmark 更新的这个误差，我们将精确加速度 $a_{n+1}^{\\text{exact}}$ 代入格式的方程中。\n\n**位移误差 ($E_u$)**\nNewmark 位移更新公式为：\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\Delta t^{2}\\left(\\frac{1}{2}-\\beta\\right)a_{n}+\\Delta t^{2}\\beta\\,a_{n+1}$$\n将 $a_{n+1}^{\\text{exact}}$ 代替 $a_{n+1}$：\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\Delta t^{2}\\left(\\frac{1}{2}-\\beta\\right)a_{n}+\\Delta t^{2}\\beta\\left(a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}\\right)$$\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\left(\\frac{1}{2}-\\beta+\\beta\\right)a_{n}\\,\\Delta t^{2}+\\beta\\,j_{n}\\,\\Delta t^{3}+\\frac{1}{2}\\beta\\,s_{n}\\,\\Delta t^{4}$$\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\beta\\,j_{n}\\,\\Delta t^{3}+\\frac{1}{2}\\beta\\,s_{n}\\,\\Delta t^{4}$$\n局部误差 $E_u = u_{n+1}^{\\text{NM}} - u_{n+1}^{\\text{exact}}$ 为：\n$$E_{u} = \\left(u_{n}+\\Delta t\\,v_{n}+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\beta\\,j_{n}\\,\\Delta t^{3}+\\frac{1}{2}\\beta\\,s_{n}\\,\\Delta t^{4}\\right) - \\left(u_{n}+v_{n}\\,\\Delta t+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}\\right)$$\n$$E_{u} = \\left(\\beta - \\frac{1}{6}\\right)j_{n}\\,\\Delta t^{3} + \\left(\\frac{1}{2}\\beta - \\frac{1}{24}\\right)s_{n}\\,\\Delta t^{4}$$\n假设 $j_n \\neq 0$，第一个非零项为 $E_{u} \\approx \\left(\\beta - \\frac{1}{6}\\right)j_{n}\\,\\Delta t^{3}$。\n\n**速度误差 ($E_v$)**\nNewmark 速度更新公式为：\n$$v_{n+1}^{\\text{NM}}=v_{n}+\\Delta t\\left((1-\\gamma)a_{n}+\\gamma\\,a_{n+1}\\right)$$\n将 $a_{n+1}^{\\text{exact}}$ 代替 $a_{n+1}$：\n$$v_{n+1}^{\\text{NM}}=v_{n}+\\Delta t\\left((1-\\gamma)a_{n}+\\gamma\\left(a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}\\right)\\right)$$\n$$v_{n+1}^{\\text{NM}}=v_{n}+\\left(1-\\gamma+\\gamma\\right)a_{n}\\,\\Delta t+\\gamma\\,j_{n}\\,\\Delta t^{2}+\\frac{1}{2}\\gamma\\,s_{n}\\,\\Delta t^{3}$$\n$$v_{n+1}^{\\text{NM}}=v_{n}+a_{n}\\,\\Delta t+\\gamma\\,j_{n}\\,\\Delta t^{2}+\\frac{1}{2}\\gamma\\,s_{n}\\,\\Delta t^{3}$$\n局部误差 $E_v = v_{n+1}^{\\text{NM}} - v_{n+1}^{\\text{exact}}$ 为：\n$$E_{v} = \\left(v_{n}+a_{n}\\,\\Delta t+\\gamma\\,j_{n}\\,\\Delta t^{2}+\\frac{1}{2}\\gamma\\,s_{n}\\,\\Delta t^{3}\\right) - \\left(v_{n}+a_{n}\\,\\Delta t+\\frac{1}{2}j_{n}\\,\\Delta t^{2}+\\frac{1}{6}s_{n}\\,\\Delta t^{3}\\right)$$\n$$E_{v} = \\left(\\gamma - \\frac{1}{2}\\right)j_{n}\\,\\Delta t^{2} + \\left(\\frac{1}{2}\\gamma - \\frac{1}{6}\\right)s_{n}\\,\\Delta t^{3}$$\n假设 $j_n \\neq 0$，第一个非零项为 $E_{v} \\approx \\left(\\gamma - \\frac{1}{2}\\right)j_{n}\\,\\Delta t^{2}$。\n\n**加速度误差 ($E_a$)**\n算法加速度 $a_{n+1}^{\\text{alg}}$ 是通过将位移 $u_{n+1}$ 代入整理后的位移更新公式来定义的。为求其局部误差，我们代入精确位移 $u_{n+1}^{\\text{exact}}$：\n$$a_{n+1}^{\\text{alg}}=\\frac{1}{\\beta\\,\\Delta t^{2}}\\left(u_{n+1}^{\\text{exact}}-u_{n}-\\Delta t\\,v_{n}\\right)-\\frac{\\frac{1}{2}-\\beta}{\\beta}\\,a_{n}$$\n根据 $u_{n+1}^{\\text{exact}}$ 的展开式，我们有：\n$$u_{n+1}^{\\text{exact}}-u_{n}-\\Delta t\\,v_{n} = \\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}$$\n将此式代入 $a_{n+1}^{\\text{alg}}$ 的表达式中：\n$$a_{n+1}^{\\text{alg}}=\\frac{1}{\\beta\\,\\Delta t^{2}}\\left(\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}\\right) - \\left(\\frac{1}{2\\beta}-1\\right)a_n$$\n$$a_{n+1}^{\\text{alg}}=\\frac{a_{n}}{2\\beta}+\\frac{j_{n}}{6\\beta}\\Delta t+\\frac{s_{n}}{24\\beta}\\Delta t^{2} - \\frac{a_{n}}{2\\beta} + a_n$$\n$$a_{n+1}^{\\text{alg}}=a_{n} + \\frac{1}{6\\beta}j_{n}\\,\\Delta t + \\frac{1}{24\\beta}s_{n}\\,\\Delta t^{2}$$\n局部误差 $E_a = a_{n+1}^{\\text{alg}} - a_{n+1}^{\\text{exact}}$ 为：\n$$E_{a} = \\left(a_{n} + \\frac{1}{6\\beta}j_{n}\\,\\Delta t + \\frac{1}{24\\beta}s_{n}\\,\\Delta t^{2}\\right) - \\left(a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}\\right)$$\n$$E_{a} = \\left(\\frac{1}{6\\beta}-1\\right)j_{n}\\,\\Delta t + \\left(\\frac{1}{24\\beta}-\\frac{1}{2}\\right)s_{n}\\,\\Delta t^{2}$$\n假设 $j_n \\neq 0$，第一个非零项为 $E_{a} \\approx \\left(\\frac{1}{6\\beta}-1\\right)j_{n}\\,\\Delta t$。\n\n### 第三部分：三次位移精确性的阶条件\n\n题目要求该方法对于任何时间上的三次位移都是精确的。一个三次多项式 $u(t)$ 的四阶导数恒等于零，即 $u^{(4)}(t) = s(t) = 0$。在我们的记法中，这意味着 $s_n=0$。为了使方法“精确”，当 $s_n=0$ 时，局部截断误差 $E_u$、$E_v$ 和 $E_a$ 必须全部为零。\n\n在误差表达式中令 $s_n=0$ 可得：\n$$E_{u} = \\left(\\beta - \\frac{1}{6}\\right)j_{n}\\,\\Delta t^{3}$$\n$$E_{v} = \\left(\\gamma - \\frac{1}{2}\\right)j_{n}\\,\\Delta t^{2}$$\n$$E_{a} = \\left(\\frac{1}{6\\beta}-1\\right)j_{n}\\,\\Delta t$$\n\n为了使这些误差对于任何三次位移（即对于任何常数 $j_n \\neq 0$）都为零，每个表达式中 $j_n$ 的系数必须为零。\n\n1.  对于 $E_u=0$：\n    $$\\beta - \\frac{1}{6} = 0 \\implies \\beta = \\frac{1}{6}$$\n2.  对于 $E_v=0$：\n    $$\\gamma - \\frac{1}{2} = 0 \\implies \\gamma = \\frac{1}{2}$$\n3.  对于 $E_a=0$（假设 $\\beta \\neq 0$）：\n    $$\\frac{1}{6\\beta} - 1 = 0 \\implies 1 = 6\\beta \\implies \\beta = \\frac{1}{6}$$\n\n关于 $\\beta$ 的条件在位移和加速度误差分析中是一致的。为同时满足所有三个精确性条件，我们必须有 $\\beta = \\frac{1}{6}$ 和 $\\gamma = \\frac{1}{2}$。这对参数对应于“线性加速度法”，已知该方法对于加速度随时间线性变化的系统是精确的（这对于三次位移的情况是成立的）。\n\n因此，唯一的参数对 $(\\beta, \\gamma)$ 是 $\\left(\\frac{1}{6}, \\frac{1}{2}\\right)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{6}  \\frac{1}{2}\n\\end{pmatrix}\n}\n$$", "id": "3532505"}, {"introduction": "在掌握了理论之后，我们转向实践。实际工程系统通常具有许多自由度和复杂的材料分布。本编程练习旨在通过一个实际的有限元模拟，来动手演示理论稳定性限制的重要性。您将构建一个数值算例，通过激发系统的高频振动模式，直观地观察到当时间步长超过特定方法的稳定性极限时，计算结果如何发生“爆炸”，从而理解为保证计算稳定而选择合适时间步长的关键性。[@problem_id:3532530]", "problem": "考虑一个一维分层土柱的无阻尼轴向振动，该土柱被建模为一个由具有空间变化刚度的两节点线性杆单元组成的有限元链，形成一个刚-软-刚的三明治结构。其运动由半离散运动方程 $M \\ddot{u}(t) + K u(t) = 0$ 控制，其中 $M$ 是质量矩阵，$K$ 是刚度矩阵，$u(t)$ 是节点位移向量。该土柱底部节点为固定基底，顶部自由。您的任务是通过构建一个反例来论证 Newmark 线性加速度法的条件稳定性，在该反例中，当时间步长超过一个数值确定的稳定性阈值时，高频模态会发散。同时，探究使用一致质量矩阵与集中质量矩阵在不稳定性中所起的作用。\n\n您必须从第一性原理出发来构建模型和算法：\n\n1. 从牛顿第二定律以及运动学关系 $v(t) = \\frac{du}{dt}$ 和 $a(t) = \\frac{dv}{dt}$ 的定义出发，为由线性有限元离散化的杆的轴向振动写出半离散方程 $M \\ddot{u}(t) + K u(t) = 0$。使用两节点单元刚度 $k_e = \\frac{E A}{L_e}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$、一致单元质量 $m_e^{\\mathrm{cons}} = \\frac{\\rho A L_e}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix}$ 以及集中单元质量 $m_e^{\\mathrm{lump}} = \\frac{\\rho A L_e}{2}\\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$。\n\n2. 将总长度为 $L_{\\mathrm{tot}} = 12\\,\\mathrm{m}$ 的土柱离散为 $N_e = 30$ 个等长单元，单元长度为 $L_e = \\frac{L_{\\mathrm{tot}}}{N_e}\\,\\mathrm{m}$。横截面积为 $A = 1\\,\\mathrm{m}^2$。所有土层的质量密度均为 $\\rho = 2000\\,\\mathrm{kg/m^3}$。杨氏模量在底部刚性层 $z \\in [0\\,\\mathrm{m},4\\,\\mathrm{m}]$ 为 $E = 10\\times 10^9\\,\\mathrm{Pa}$，在中部软弱层 $z \\in (4\\,\\mathrm{m},8\\,\\mathrm{m}]$ 为 $E = 10\\times 10^6\\,\\mathrm{Pa}$，在顶部刚性层 $z \\in (8\\,\\mathrm{m},12\\,\\mathrm{m}]$ 为 $E = 10\\times 10^9\\,\\mathrm{Pa}$。在 $z=0$ 处施加固定基底（第一个节点位移为零），在 $z=12\\,\\mathrm{m}$ 处为自由顶部。\n\n3. 使用线性加速度参数 $\\beta = \\frac{1}{6}$ 和 $\\gamma = \\frac{1}{2}$ 实现隐式 Newmark-$\\beta$ 方法。从运动学定义推导出离散的预测-校正关系，并使用 $M \\, a_{n+1} + K \\, u_{n+1} = 0$（无外力）在新时刻强制施加动力平衡。设计并实现算法，在给定时间 $t_n$ 的 $(u_n, v_n, a_n)$ 的情况下，计算 $t_{n+1} = t_n + \\Delta t$ 时的 $(u_{n+1}, v_{n+1}, a_{n+1})$。\n\n4. 通过为无量纲状态向量 $\\begin{bmatrix}u_n \\\\ \\Delta t\\, v_n\\end{bmatrix}$ 推导一个二维放大映射来分析具有自然频率 $\\omega$ 的单自由度情形，该映射由给定 $\\beta$ 和 $\\gamma$ 下的无量纲步长 $h = \\omega \\Delta t$ 参数化。数值确定最大的 $h_{\\mathrm{lim}}$，使得放大矩阵的谱半径不超过 $1$；这定义了线性加速度 Newmark 方法的条件稳定性阈值。由此，为多自由度系统计算相应的临界时间步长 $\\Delta t_{\\mathrm{lim}} = \\frac{h_{\\mathrm{lim}}}{\\omega_{\\max}}$，其中 $\\omega_{\\max}$ 是从广义特征值问题 $K \\phi = \\omega^2 M \\phi$ 中获得的最大自然频率。此步骤必须对一致质量和集中质量模型分别进行，因为 $\\omega_{\\max}$ 取决于 $M$。\n\n5. 在 $t=0$ 时，使用所选质量模型的最高频率模态来初始化系统，并将其缩放至单位 $M$-范数：设置 $u_0 = \\phi_{\\max}/\\sqrt{\\phi_{\\max}^\\top M \\phi_{\\max}}$，$v_0 = 0$，并从动力平衡 $M a_0 + K u_0 = 0$ 确定 $a_0$。积分 $N_{\\mathrm{steps}} = 300$ 步。定义 $M$-范数振幅增长率 $R = \\max_{0\\le n \\le N_{\\mathrm{steps}}}\\frac{\\|u_n\\|_{M}}{\\|u_0\\|_{M}}$，其中 $\\|u\\|_{M} = \\sqrt{u^\\top M u}$。\n\n6. 构建一个测试套件，使用三个无量纲乘子 $c \\in \\{0.8, 1.0, 1.2\\}$ 为每种质量模型（一致质量和集中质量，分别计算）指定时间步长 $\\Delta t = c \\, \\Delta t_{\\mathrm{lim}}$。对于每个 $c$：\n   - 情况 A：一致质量矩阵。\n   - 情况 B：集中质量矩阵。\n   对于每种情况，如果 $R \\ge 10$，则声明为“发散”（布尔值 $true$），否则声明为“不发散”（布尔值 $false$）。\n\n7. 物理单位：所有长度以 $\\mathrm{m}$ 报告，密度以 $\\mathrm{kg/m^3}$ 报告，模量以 $\\mathrm{Pa}$ 报告，时间以 $\\mathrm{s}$ 报告。最终输出仅包含布尔值，因此输出值无需单位标注。\n\n8. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须包含三个条目，每个 $c$ 值对应一个，每个条目本身必须是一个双元素列表 $[b_{\\mathrm{cons}}, b_{\\mathrm{lump}}]$，分别包含一致质量和集中质量情况下的布尔值。例如，一个有效的输出格式是 $[[true,false],[false,false],[true,true]]$。\n\n您的程序必须实现所有必要的步骤，组装有限元模型，根据单自由度放大矩阵计算稳定性阈值，对指定情况下的多自由度系统运行 Newmark 积分，并按上述指定的确切格式输出结果。", "solution": "该问题要求通过构建一个计算反例来论证 Newmark-$\\beta$ 线性加速度法的条件稳定性。我们使用有限元法对一维分层土柱的轴向振动进行建模。通过用系统的最高频率模态激励系统，并观察在理论稳定性极限之下、之上和临界点处的时间步长下的行为来测试其稳定性。该分析将针对一致质量矩阵和集中质量矩阵两种形式进行。\n\n半离散化系统无阻尼自由振动的控制方程为：\n$$\nM \\ddot{u}(t) + K u(t) = 0\n$$\n其中 $M$ 是全局质量矩阵，$K$ 是全局刚度矩阵，$u(t)$ 是节点位移向量。$\\ddot{u}(t)$ 是节点加速度向量。\n\n首先，我们构建有限元模型。将总长度为 $L_{\\mathrm{tot}} = 12\\,\\mathrm{m}$ 的土柱离散为 $N_e = 30$ 个两节点线性杆单元，每个单元的长度为 $L_e = L_{\\mathrm{tot}} / N_e = 0.4\\,\\mathrm{m}$。这会产生 $N_n = N_e + 1 = 31$ 个节点。横截面积为 $A = 1\\,\\mathrm{m}^2$，整个柱体的质量密度为 $\\rho = 2000\\,\\mathrm{kg/m^3}$。杨氏模量 $E$ 随深度 $z$ 变化。对于每个单元，我们根据其位置确定其材料属性。如果一个单元的中点位于某一层边界内，则认为该单元属于该层。刚度分布如下：\n-   刚性层 ($E = 10 \\times 10^9\\,\\mathrm{Pa}$): $z \\in [0\\,\\mathrm{m}, 4\\,\\mathrm{m}]$, 对应于单元 $1$ 到 $10$。\n-   软弱层 ($E = 10 \\times 10^6\\,\\mathrm{Pa}$): $z \\in (4\\,\\mathrm{m}, 8\\,\\mathrm{m}]$, 对应于单元 $11$ 到 $20$。\n-   刚性层 ($E = 10 \\times 10^9\\,\\mathrm{Pa}$): $z \\in (8\\,\\mathrm{m}, 12\\,\\mathrm{m}]$, 对应于单元 $21$ 到 $30$。\n\n单元刚度矩阵 $k_e$ 由下式给出：\n$$\nk_e = \\frac{EA}{L_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n考虑两种不同的单元质量矩阵：一致质量矩阵 $m_e^{\\mathrm{cons}}$ 和集中（对角）质量矩阵 $m_e^{\\mathrm{lump}}$。\n$$\nm_e^{\\mathrm{cons}} = \\frac{\\rho A L_e}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix} \\quad \\text{和} \\quad m_e^{\\mathrm{lump}} = \\frac{\\rho A L_e}{2} \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}\n$$\n全局矩阵 $K$ 和 $M$（包括一致和集中两种情况）是通过对所有 $N_e = 30$ 个单元的贡献求和来组装的。系统在基底处（$z=0$）固定，这对应于将第一个节点的位移设置为零（$u_1=0$）。该边界条件通过从全局矩阵中移除第一行和第一列来施加，从而得到大小为 $30 \\times 30$ 的缩减矩阵。\n\n接下来，我们使用 Newmark-$\\beta$ 方法处理时间积分。线性加速度法的指定参数为 $\\beta = 1/6$ 和 $\\gamma = 1/2$。从时间步 $n$ 到 $n+1$ 的位移 $u$ 和速度 $v$ 的更新法则为：\n$$\nu_{n+1} = u_n + \\Delta t \\, v_n + (\\Delta t)^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) a_n + \\beta a_{n+1} \\right]\n$$\n$$\nv_{n+1} = v_n + \\Delta t \\left[ (1-\\gamma) a_n + \\gamma a_{n+1} \\right]\n$$\n为了求解未知加速度 $a_{n+1}$，我们在时间 $t_{n+1}$ 处施加运动方程：$M a_{n+1} + K u_{n+1} = 0$。将 $u_{n+1}$ 的表达式代入此方程，得到关于 $a_{n+1}$ 的线性系统：\n$$\n\\left( M + \\beta (\\Delta t)^2 K \\right) a_{n+1} = -K \\left[ u_n + \\Delta t \\, v_n + (\\Delta t)^2 \\left( \\frac{1}{2} - \\beta \\right) a_n \\right]\n$$\n在每个时间步求解该系统以得到 $a_{n+1}$，然后通过更新法则计算 $u_{n+1}$ 和 $v_{n+1}$。\n\n该方法的稳定性是有条件的。对于具有自然频率 $\\omega$ 的单自由度（SDOF）系统，其稳定性由放大矩阵的谱半径决定，该矩阵将状态向量从一个时间步映射到下一个。对于线性加速度法（$\\beta=1/6, \\gamma=1/2$），该方法在振幅衰减方面是无条件稳定的（它没有数值阻尼），但对于大的时间步长，谱半径可能超过 $1$，导致数值不稳定性。稳定性极限出现在无量纲时间步长 $h = \\omega \\Delta t$ 处。当 $h^2 \\le 12$ 时，放大矩阵的特征值保持在单位圆上。当 $h^2  12$ 时，一个特征值变为实数且其幅值超过 $1$，导致指数增长。因此，稳定性极限为 $h_{\\text{lim}} = \\sqrt{12}$。\n\n对于多自由度（MDOF）系统，稳定性由系统的最高自然频率 $\\omega_{\\max}$ 决定。临界时间步长由下式给出：\n$$\n\\Delta t_{\\mathrm{lim}} = \\frac{h_{\\mathrm{lim}}}{\\omega_{\\max}} = \\frac{\\sqrt{12}}{\\omega_{\\max}}\n$$\n$\\omega_{\\max}$ 通过求解广义特征值问题 $K \\phi = \\omega^2 M \\phi$ 得到。由于 $\\omega_{\\max}$ 取決于质量矩阵 $M$，我们必须为一致质量和集中质量形式分别计算 $\\Delta t_{\\mathrm{lim}}$。通常，与集中质量矩阵相比，一致质量矩阵会导致更高的 $\\omega_{\\max}$，因此临界时间步长 $\\Delta t_{\\mathrm{lim}}$ 更为严格（更小）。\n\n为了论证不稳定性，我们用其最高频率模态来初始化系统，在该模态下不稳定性最为显著。初始位移设置为相应的特征向量 $\\phi_{\\max}$，并缩放至单位 $M$-范数：$u_0 = \\phi_{\\max} / \\sqrt{\\phi_{\\max}^\\top M \\phi_{\\max}}$。初始速度为零，$v_0 = 0$。初始加速度由运动方程得到：$a_0 = -M^{-1}K u_0 = -\\omega_{\\max}^2 u_0$。然后使用时间步长 $\\Delta t = c \\cdot \\Delta t_{\\mathrm{lim}}$ 和乘子 $c \\in \\{0.8, 1.0, 1.2\\}$ 对系统进行 $N_{\\mathrm{steps}} = 300$ 步的积分。\n\n使用比率 $R = \\max_{0\\le n \\le N_{\\mathrm{steps}}}\\frac{\\|u_n\\|_{M}}{\\|u_0\\|_{M}}$ 来监控振幅增长。由于 $\\|u_0\\|_{M}=1$，这可简化为 $R = \\max_{0\\le n \\le N_{\\mathrm{steps}}}\\|u_n\\|_{M}$。如果 $R \\ge 10$，则声明为“发散”。对于 $c \\le 1.0$，方法是稳定的，我们预期 $R \\approx 1$。对于 $c  1.0$，方法不稳定，我们预期会发生指数增长，导致 $R \\ge 10$。以下程序实现了这整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the problem of demonstrating conditional stability of the Newmark-beta method\n    for a 1D layered soil column.\n    \"\"\"\n\n    # 1. Define physical and numerical parameters\n    L_TOT = 12.0  # m\n    N_E = 30\n    L_E = L_TOT / N_E  # m\n    A = 1.0  # m^2\n    RHO = 2000.0  # kg/m^3\n    E_STIFF = 10e9  # Pa\n    E_SOFT = 10e6  # Pa\n    N_NODES = N_E + 1\n    N_DOF = N_NODES - 1  # After applying fixed base BC\n\n    NEWMARK_BETA = 1/6\n    NEWMARK_GAMMA = 1/2\n    N_STEPS = 300\n    BLOWUP_RATIO = 10.0\n    C_MULTIPLIERS = [0.8, 1.0, 1.2]\n\n    # Stability limit for linear acceleration method (h_lim = omega * dt_lim)\n    H_LIM = np.sqrt(12.0)\n\n    # 2. Assemble FEM matrices\n    K_global = np.zeros((N_NODES, N_NODES))\n    M_cons_global = np.zeros((N_NODES, N_NODES))\n    M_lump_global = np.zeros((N_NODES, N_NODES))\n\n    # Element mass matrices (constant for all elements)\n    m_e_cons = (RHO * A * L_E / 6.0) * np.array([[2, 1], [1, 2]])\n    m_e_lump = (RHO * A * L_E / 2.0) * np.array([[1, 0], [0, 1]])\n\n    for i in range(N_E):\n        # Determine Young's modulus based on element midpoint\n        midpoint_z = (i + 0.5) * L_E\n        if 4.0  midpoint_z = 8.0:\n            E = E_SOFT\n        else:\n            E = E_STIFF\n\n        # Element stiffness matrix\n        k_e = (E * A / L_E) * np.array([[1, -1], [-1, 1]])\n\n        # Assemble into global matrices\n        nodes = np.array([i, i + 1])\n        K_global[np.ix_(nodes, nodes)] += k_e\n        M_cons_global[np.ix_(nodes, nodes)] += m_e_cons\n        M_lump_global[np.ix_(nodes, nodes)] += m_e_lump\n\n    # 3. Apply boundary condition (fixed base at z=0, node 0)\n    K = K_global[1:, 1:]\n    M_cons = M_cons_global[1:, 1:]\n    M_lump = M_lump_global[1:, 1:]\n\n    mass_matrices = {\n        'consistent': M_cons,\n        'lumped': M_lump\n    }\n\n    final_results = []\n\n    for c in C_MULTIPLIERS:\n        case_results = []\n        for mass_type in ['consistent', 'lumped']:\n            M = mass_matrices[mass_type]\n\n            # 4. Solve generalized eigenvalue problem for max frequency and mode\n            eigvals, eigvecs = eigh(K, M)\n            omega_sq_max = np.max(eigvals)\n            omega_max = np.sqrt(omega_sq_max)\n            phi_max = eigvecs[:, np.argmax(eigvals)]\n\n            # 5. Set time step and initial conditions\n            dt_lim = H_LIM / omega_max\n            dt = c * dt_lim\n\n            # ICs: a) Normalize highest mode to unit M-norm\n            m_norm_phi_max = np.sqrt(phi_max.T @ M @ phi_max)\n            u = phi_max / m_norm_phi_max\n            # ICs: b) Zero velocity, c) Eqm acceleration\n            v = np.zeros(N_DOF)\n            a = -omega_sq_max * u\n\n            # 6. Perform Newmark time integration\n            max_m_norm = 1.0  # Initial norm is 1.0\n\n            # Pre-compute effective stiffness matrix\n            K_eff = M + NEWMARK_BETA * dt**2 * K\n            K_eff_inv = np.linalg.inv(K_eff)\n\n            for _ in range(N_STEPS):\n                # Solve for new acceleration\n                f_eff = -K @ (u + dt * v + (0.5 - NEWMARK_BETA) * dt**2 * a)\n                a_new = K_eff_inv @ f_eff\n                \n                # Update displacement and velocity\n                u_new = u + dt * v + dt**2 * ((0.5 - NEWMARK_BETA) * a + NEWMARK_BETA * a_new)\n                v_new = v + dt * ((1.0 - NEWMARK_GAMMA) * a + NEWMARK_GAMMA * a_new)\n\n                u, v, a = u_new, v_new, a_new\n\n                # Calculate M-norm and update maximum\n                current_m_norm = np.sqrt(u.T @ M @ u)\n                if current_m_norm > max_m_norm:\n                    max_m_norm = current_m_norm\n\n            # 7. Check for blow-up and record result\n            is_blowup = max_m_norm >= BLOWUP_RATIO\n            case_results.append(is_blowup)\n        \n        final_results.append(case_results)\n\n    # 8. Format and print the final output\n    output_str = ','.join([f\"[{str(sub[0]).lower()},{str(sub[1]).lower()}]\" for sub in final_results])\n    print(f\"[{output_str}]\")\n\n\nsolve()\n\n```", "id": "3532530"}, {"introduction": "稳健的工程设计不仅需要单次模拟，还需要理解物理参数的不确定性如何影响结果。本项高级练习将简单的前向模拟提升至更复杂的分析层面，介绍了一种强大的梯度计算工具——直接微分法 (Direct Differentiation Method, DDM)。通过实现一个灵敏度递推算法，您将学会如何高效地计算质量、刚度、阻尼甚至数值方法参数的变化对动力响应的影响，这项技能是进行不确定性量化、设计优化和反演建模的基础。[@problem_id:3532506]", "problem": "一个受基底加速度激励的单自由度线性地质力学振子，其运动由牛顿第二定律决定\n$$\nM \\, \\ddot{u}(t) + C \\, \\dot{u}(t) + K \\, u(t) = f(t),\n$$\n其中 $M$ 是质量，$C$ 是粘性阻尼系数，$K$ 是刚度，$u(t)$ 是相对位移，$\\dot{u}(t)$ 是速度，$\\ddot{u}(t)$ 是加速度，$f(t)$ 是外力。对于一个单自由度基底激励系统，取\n$$\nf(t) = - M \\, a_g(t),\n$$\n其中 $a_g(t)$ 是给定的地面加速度。考虑使用参数为 $\\beta$ 和 $\\gamma$ 的隐式 Newmark-$\\beta$ 时间积分法，均匀时间步长为 $\\Delta t$，初始条件为 $u(0)=0$，$\\dot{u}(0)=0$。使用一致初始加速度 $\\ddot{u}(0) = \\big(f(0) - C \\, \\dot{u}(0) - K \\, u(0)\\big) / M$。\n\n基准物理参数为\n$$\nM_0 = 1000 \\,\\, \\text{kg}, \\quad K_0 = 10^7 \\,\\, \\text{N/m}, \\quad \\zeta_0 = 0.05,\n$$\n并定义基准阻尼系数为\n$$\nC_0 = 2 \\, \\zeta_0 \\, \\sqrt{K_0 \\, M_0}.\n$$\n通过三个无量纲标量 $a_m$、$a_c$ 和 $a_k$ 引入参数不确定性和设计缩放，使得\n$$\nM = a_m \\, M_0, \\quad C = a_c \\, C_0, \\quad K = a_k \\, K_0.\n$$\n地面加速度规定为\n$$\na_g(t) = 0.5 \\, g \\, \\sin(2\\pi f \\, t),\n$$\n其中 $g = 9.81 \\,\\, \\text{m/s}^2$ 且 $f = 5 \\,\\, \\text{Hz}$。使用均匀时间步长 $\\Delta t = 0.001 \\,\\, \\text{s}$ 和总时长 $T = 1.0 \\,\\, \\text{s}$。\n\n任务：\n1. 从隐式 Newmark-$\\beta$ 方法的基本定义和运动方程出发，推导出每个时间步的离散平衡更新以及计算 $u_{n+1}$、$\\dot{u}_{n+1}$ 和 $\\ddot{u}_{n+1}$ 所需的、基于 $u_n$、$\\dot{u}_n$ 和 $\\ddot{u}_n$ 的关联有效系统。\n2. 通过对全离散方程应用链式法则，推导出一阶灵敏度递推关系，用于在时间上传播位移响应相对于参数 $(\\beta, \\gamma, a_m, a_c, a_k)$ 的梯度。确保灵敏度初始条件与给定的初始条件和外力一致。\n3. 定义一个标量响应泛函为最终时刻的位移，\n$$\nJ(\\beta, \\gamma, a_m, a_c, a_k) = u_N,\n$$\n其中 $N = T / \\Delta t$ 是时间步数。推导出通过灵敏度递推计算梯度 $\\nabla J = \\left[\\frac{\\partial J}{\\partial \\beta}, \\frac{\\partial J}{\\partial \\gamma}, \\frac{\\partial J}{\\partial a_m}, \\frac{\\partial J}{\\partial a_c}, \\frac{\\partial J}{\\partial a_k}\\right]$ 所需的表达式。\n4. 假设参数 $(a_m, a_c, a_k)$ 的不确定性是独立的，并由已知的标准差 $(\\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k})$ 表征。使用一阶线性化，估计响应泛函的标准差，\n$$\n\\sigma_J \\approx \\sqrt{\\left(\\frac{\\partial J}{\\partial a_m}\\right)^2 \\sigma_{a_m}^2 + \\left(\\frac{\\partial J}{\\partial a_c}\\right)^2 \\sigma_{a_c}^2 + \\left(\\frac{\\partial J}{\\partial a_k}\\right)^2 \\sigma_{a_k}^2 }.\n$$\n\n实现一个完整的、可运行的程序，对下方的每个测试用例，计算并报告：\n- 最终位移 $J$（单位：米），\n- 梯度分量 $\\frac{\\partial J}{\\partial \\beta}$、$\\frac{\\partial J}{\\partial \\gamma}$、$\\frac{\\partial J}{\\partial a_m}$、$\\frac{\\partial J}{\\partial a_c}$、$\\frac{\\partial J}{\\partial a_k}$（由于参数是无量纲的，所有分量单位均为米），\n- 估计的标准差 $\\sigma_J$（单位：米）。\n\n所有位移和派生量必须以米为单位表示。如果在您的实现中出现角度，必须使用弧度。不要使用百分号；任何分数量必须以小数形式报告。\n\n测试套件（三个用例）：\n- 用例 A（平均加速度法与基准缩放）：$(\\beta, \\gamma, a_m, a_c, a_k, \\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k}) = \\left(0.25, 0.5, 1.0, 1.0, 1.0, 0.05, 0.05, 0.05\\right)$。\n- 用例 B（线性加速度法变体与减小的阻尼缩放）：$(\\beta, \\gamma, a_m, a_c, a_k, \\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k}) = \\left(\\frac{1}{6}, 0.5, 1.0, 0.2, 1.0, 0.1, 0.05, 0.05\\right)$。\n- 用例 C（非经典参数集与增加的刚度和质量缩放）：$(\\beta, \\gamma, a_m, a_c, a_k, \\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k}) = \\left(0.3, 0.6, 1.2, 1.0, 1.5, 0.02, 0.02, 0.02\\right)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个测试用例贡献一个包含七个浮点数的子列表，顺序如下：\n$$\n\\left[ J, \\, \\frac{\\partial J}{\\partial \\beta}, \\, \\frac{\\partial J}{\\partial \\gamma}, \\, \\frac{\\partial J}{\\partial a_m}, \\, \\frac{\\partial J}{\\partial a_c}, \\, \\frac{\\partial J}{\\partial a_k}, \\, \\sigma_J \\right].\n$$\n因此，总输出必须是：\n$$\n\\big[ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot] \\big].\n$$", "solution": "该问题要求对受基底激励的单自由度（SDOF）线性振子，推导并实现直接微分灵敏度分析。该系统采用隐式 Newmark-$\\beta$ 方法进行时间积分。最终目标是计算最终时刻的位移、其相对于系统和数值参数的梯度，以及响应标准差的一阶估计。\n\n控制运动方程为：\n$$\nM \\ddot{u}(t) + C \\dot{u}(t) + K u(t) = f(t)\n$$\n其中由基底加速度 $a_g(t)$ 引起的策动力项为 $f(t) = -M a_g(t)$。初始条件为 $u(0)=0$ 和 $\\dot{u}(0)=0$。一致初始加速度为 $\\ddot{u}(0) = (f(0) - C\\dot{u}(0) - K u(0))/M$。给定 $f(t) = -M \\cdot 0.5g \\sin(2\\pi f t)$，则 $f(0)=0$，这导致 $\\ddot{u}(0)=0$。因此，初始状态为 $(u_0, \\dot{u}_0, \\ddot{u}_0)=(0,0,0)$。\n\n系统参数由应用于基准值 $(M_0, C_0, K_0)$ 的缩放因子 $(a_m, a_c, a_k)$ 定义。\n$M = a_m M_0$, $C = a_c C_0$, $K = a_k K_0$。\n\n令 $\\mathbf{p} = (\\beta, \\gamma, a_m, a_c, a_k)$ 为灵敏度分析的参数向量。\n\n### 任务1：离散平衡更新 (Newmark-$\\beta$ 方法)\n\n隐式 Newmark-$\\beta$ 方法基于 $t_n$ 时刻的状态和 $t_{n+1}$ 时刻的加速度 $\\ddot{u}_{n+1}$，定义了时间步 $t_{n+1} = t_n + \\Delta t$ 的位移 $u_{n+1}$ 和速度 $\\dot{u}_{n+1}$：\n$$\nu_{n+1} = u_n + \\Delta t \\dot{u}_n + \\left(\\frac{1}{2} - \\beta\\right) \\Delta t^2 \\ddot{u}_n + \\beta \\Delta t^2 \\ddot{u}_{n+1} \\\\\n\\dot{u}_{n+1} = \\dot{u}_n + (1 - \\gamma) \\Delta t \\ddot{u}_n + \\gamma \\Delta t \\ddot{u}_{n+1}\n$$\n运动方程在时间 $t_{n+1}$ 必须成立：\n$$\nM \\ddot{u}_{n+1} + C \\dot{u}_{n+1} + K u_{n+1} = f_{n+1}\n$$\n为了求解第 $n+1$ 步的未知数，我们首先用未知位移 $u_{n+1}$ 和第 $n$ 步的已知量来表示 $\\ddot{u}_{n+1}$ 和 $\\dot{u}_{n+1}$。从第一个 Newmark 方程中，我们分离出 $\\ddot{u}_{n+1}$：\n$$\n\\ddot{u}_{n+1} = \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} \\dot{u}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{u}_n\n$$\n将此式代入速度更新方程，得到用 $u_{n+1}$ 表示的 $\\dot{u}_{n+1}$：\n$$\n\\dot{u}_{n+1} = \\frac{\\gamma}{\\beta \\Delta t} (u_{n+1} - u_n) + \\left(1 - \\frac{\\gamma}{\\beta}\\right) \\dot{u}_n + \\Delta t \\left(1 - \\frac{\\gamma}{2\\beta}\\right) \\ddot{u}_n\n$$\n现在，将 $\\ddot{u}_{n+1}$ 和 $\\dot{u}_{n+1}$ 的表达式代入运动方程，得到一个关于单个未知数 $u_{n+1}$ 的线性系统：\n$$\n\\left(K + \\frac{\\gamma}{\\beta \\Delta t} C + \\frac{1}{\\beta \\Delta t^2} M\\right) u_{n+1} = f_{n+1} + M\\left(\\dots\\right) + C\\left(\\dots\\right)\n$$\n这就是离散平衡更新，可以写成有效系统的形式：\n$$\n\\hat{K} u_{n+1} = \\hat{f}_{n+1}\n$$\n有效刚度 $\\hat{K}$ 为：\n$$\n\\hat{K} = K + \\frac{\\gamma}{\\beta \\Delta t} C + \\frac{1}{\\beta \\Delta t^2} M\n$$\n有效力 $\\hat{f}_{n+1}$ 聚合了 $t_{n+1}$ 时刻的外力和所有依赖于 $t_n$ 时刻状态的项：\n$$\n\\hat{f}_{n+1} = f_{n+1} + M \\left[ \\frac{1}{\\beta \\Delta t^2} u_n + \\frac{1}{\\beta \\Delta t} \\dot{u}_n + \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{u}_n \\right] + C \\left[ \\frac{\\gamma}{\\beta \\Delta t} u_n + \\left(\\frac{\\gamma}{\\beta} - 1\\right) \\dot{u}_n + \\Delta t \\left(\\frac{\\gamma}{2\\beta} - 1\\right) \\ddot{u}_n \\right]\n$$\n求解过程首先是求解 $u_{n+1} = \\hat{K}^{-1} \\hat{f}_{n+1}$，然后使用上面推导的关系更新 $\\ddot{u}_{n+1}$ 和 $\\dot{u}_{n+1}$。\n\n### 任务2：一阶灵敏度递推\n\n我们使用直接微分法（DDM）来求响应相对于泛参数 $p \\in \\mathbf{p}$ 的灵敏度。这涉及将离散方程组对 $p$ 求导。令 $(\\cdot)^{,p}$ 表示导数 $\\frac{\\partial (\\cdot)}{\\partial p}$。\n\n对有效系统 $\\hat{K} u_{n+1} = \\hat{f}_{n+1}$ 关于 $p$ 求导得到：\n$$\n\\hat{K}^{,p} u_{n+1} + \\hat{K} u_{n+1}^{,p} = \\hat{f}_{n+1}^{,p}\n$$\n整理以求解位移灵敏度 $u_{n+1}^{,p}$：\n$$\n\\hat{K} u_{n+1}^{,p} = \\hat{f}_{n+1}^{,p} - \\hat{K}^{,p} u_{n+1}\n$$\n与主分析中相同的有效刚度算子 $\\hat{K}$ 用于求解位移灵敏度。右侧是灵敏度问题的伪力，它依赖于主解 $(u_{n+1})$ 和上一步的灵敏度 $(u_n^{,p}, \\dot{u}_n^{,p}, \\ddot{u}_n^{,p})$。\n\n一旦计算出 $u_{n+1}^{,p}$，速度和加速度的灵敏度就通过对它们各自的更新公式求导来更新：\n$$\n\\ddot{u}_{n+1}^{,p} = \\frac{\\partial}{\\partial p} \\left[ \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} \\dot{u}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{u}_n \\right]\n$$\n$$\n\\dot{u}_{n+1}^{,p} = \\frac{\\partial}{\\partial p} \\left[ \\dot{u}_n + (1 - \\gamma) \\Delta t \\ddot{u}_n + \\gamma \\Delta t \\ddot{u}_{n+1} \\right]\n$$\n展开这些表达式可以得到明确的更新规则。例如，对于 $\\ddot{u}_{n+1}^{,p}$：\n$$\n\\ddot{u}_{n+1}^{,p} = \\frac{\\partial c_0}{\\partial p}(u_{n+1}-u_n) + c_0(u_{n+1}^{,p} - u_n^{,p}) - \\frac{\\partial c_2}{\\partial p}\\dot{u}_n - c_2\\dot{u}_{n}^{,p} - \\frac{\\partial c_3}{\\partial p}\\ddot{u}_n - c_3\\ddot{u}_{n}^{,p}\n$$\n其中 $c_0=\\frac{1}{\\beta\\Delta t^2}$，$c_2=\\frac{1}{\\beta\\Delta t}$，以及 $c_3=\\frac{1}{2\\beta}-1$。\n\n灵敏度的初始条件通过对主初始条件求导得到：\n$u_0 = 0 \\implies u_0^{,p} = 0$。\n$\\dot{u}_0 = 0 \\implies \\dot{u}_0^{,p} = 0$。\n$\\ddot{u}_0 = 0 \\implies \\ddot{u}_0^{,p} = 0$。\n灵敏度分析从零状态开始，并由每一步的伪力项驱动。\n\n总体算法如下：\n对于每个时间步 $n=0, 1, \\dots, N-1$：\n1. 求解主系统：计算 $\\hat{K}$ 和 $\\hat{f}_{n+1}$，求解 $u_{n+1}$，然后更新 $\\dot{u}_{n+1}$ 和 $\\ddot{u}_{n+1}$。\n2. 对于每个参数 $p \\in \\mathbf{p}$：\n    a. 计算灵敏度伪力 $F_{sens} = \\hat{f}_{n+1}^{,p} - \\hat{K}^{,p} u_{n+1}$。该力包括第 $n+1$ 步参数直接微分的项和从第 $n$ 步传播灵敏度的项。\n    b. 求解位移灵敏度：$u_{n+1}^{,p} = \\hat{K}^{-1} F_{sens}$。\n    c. 使用其微分后的更新公式更新速度和加速度灵敏度 $\\dot{u}_{n+1}^{,p}$ 和 $\\ddot{u}_{n+1}^{,p}$。\n\n### 任务3：响应泛函的梯度\n\n标量响应泛函是最终时刻的位移：\n$$\nJ(\\mathbf{p}) = u_N, \\quad \\text{其中 } N = T / \\Delta t\n$$\n该泛函的梯度 $\\nabla J$ 是一个向量，其分量是 $J$ 对 $\\mathbf{p}$ 中每个参数的偏导数：\n$$\n\\nabla J = \\left[ \\frac{\\partial J}{\\partial p_1}, \\frac{\\partial J}{\\partial p_2}, \\dots \\right] = \\left[ \\frac{\\partial u_N}{\\partial p_1}, \\frac{\\partial u_N}{\\partial p_2}, \\dots \\right]\n$$\n梯度的分量恰好是在最终时间步 $N$ 计算出的位移灵敏度 $u_N^{,p_i}$。灵敏度分析直接产生所需的梯度向量。\n$$\n\\nabla J = \\left[u_N^{,\\beta}, \\, u_N^{,\\gamma}, \\, u_N^{,a_m}, \\, u_N^{,a_c}, \\, u_N^{,a_k}\\right]\n$$\n\n### 任务4：不确定性传播\n\n给定缩放参数 $(a_m, a_c, a_k)$ 的不确定性是独立的，并由标准差 $(\\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k})$ 表征，我们可以使用关于参数均值的一阶泰勒级数展开来估计响应泛函的标准差 $\\sigma_J$。$J$ 的方差 $\\sigma_J^2$ 近似为：\n$$\n\\sigma_J^2 \\approx \\sum_{i} \\sum_{j} \\frac{\\partial J}{\\partial p_i} \\frac{\\partial J}{\\partial p_j} \\text{Cov}(p_i, p_j)\n$$\n由于假设参数 $a_m, a_c, a_k$ 是独立的，它们的协方差为零，即当 $i \\neq j$ 时 $\\text{Cov}(a_i, a_j) = 0$。方差简化为：\n$$\n\\sigma_J^2 \\approx \\left(\\frac{\\partial J}{\\partial a_m}\\right)^2 \\sigma_{a_m}^2 + \\left(\\frac{\\partial J}{\\partial a_c}\\right)^2 \\sigma_{a_c}^2 + \\left(\\frac{\\partial J}{\\partial a_k}\\right)^2 \\sigma_{a_k}^2\n$$\n响应的估计标准差是该方差的平方根：\n$$\n\\sigma_J \\approx \\sqrt{\\left(\\frac{\\partial J}{\\partial a_m}\\right)^2 \\sigma_{a_m}^2 + \\left(\\frac{\\partial J}{\\partial a_c}\\right)^2 \\sigma_{a_c}^2 + \\left(\\frac{\\partial J}{\\partial a_k}\\right)^2 \\sigma_{a_k}^2 }\n$$\n所需的偏导数是任务3中计算的梯度 $\\nabla J$ 的分量。", "answer": "```python\nimport numpy as np\n\ndef run_analysis(params):\n    \"\"\"\n    Performs the Newmark-beta time integration and sensitivity analysis\n    for a single-degree-of-freedom system.\n    \"\"\"\n    beta, gamma, a_m, a_c, a_k, sigma_am, sigma_ac, sigma_ak = params\n\n    # Baseline physical parameters\n    M0 = 1000.0  # kg\n    K0 = 1.0e7   # N/m\n    zeta0 = 0.05 # damping ratio\n    C0 = 2.0 * zeta0 * np.sqrt(K0 * M0)\n\n    # Scaled parameters\n    M = a_m * M0\n    C = a_c * C0\n    K = a_k * K0\n\n    # Ground motion parameters\n    g = 9.81  # m/s^2\n    f_exc = 5.0  # Hz\n    omega_exc = 2.0 * np.pi * f_exc\n\n    def ag(t):\n        return 0.5 * g * np.sin(omega_exc * t)\n\n    def force(t, M_val):\n        return -M_val * ag(t)\n\n    # Time integration parameters\n    dt = 0.001  # s\n    T_total = 1.0  # s\n    N_steps = int(T_total / dt)\n    t_space = np.linspace(0, T_total, N_steps + 1)\n\n    # State vectors (displacement, velocity, acceleration)\n    u = np.zeros(N_steps + 1)\n    u_dot = np.zeros(N_steps + 1)\n    u_ddot = np.zeros(N_steps + 1)\n    \n    # Initial conditions are all zero\n    # u[0], u_dot[0], u_ddot[0] are already 0.0\n\n    # Sensitivity state vectors\n    # Parameters for sensitivity: [beta, gamma, am, ac, ak]\n    param_keys = ['beta', 'gamma', 'am', 'ac', 'ak']\n    num_params = len(param_keys)\n    \n    # Derivatives of u, u_dot, u_ddot w.r.t. parameters\n    du_dp = np.zeros((N_steps + 1, num_params))\n    dudot_dp = np.zeros((N_steps + 1, num_params))\n    duddot_dp = np.zeros((N_steps + 1, num_params))\n\n    # Newmark constants and their derivatives\n    c0 = 1.0 / (beta * dt**2)\n    c1 = gamma / (beta * dt)\n    c2 = 1.0 / (beta * dt)\n    c3 = 1.0 / (2.0 * beta) - 1.0\n    c4 = gamma / beta - 1.0\n    c5 = dt * (gamma / (2.0 * beta) - 1.0)\n\n    dc_dp = {\n        'beta': [\n            -c0 / beta, # dc0/dbeta\n            -c1 / beta, # dc1/dbeta\n            -c2 / beta, # dc2/dbeta\n            -1.0 / (2.0 * beta**2), # dc3/dbeta\n            -gamma / beta**2, # dc4/dbeta\n            -dt * gamma / (2.0 * beta**2) # dc5/dbeta\n        ],\n        'gamma': [0, c2, 0, 0, 1.0 / beta, dt / (2.0 * beta)]\n    }\n\n    # Effective stiffness for the primary analysis\n    K_hat = K + c1 * C + c0 * M\n    inv_K_hat = 1.0 / K_hat\n\n    # Time stepping loop\n    for n in range(N_steps):\n        # --- Primary Analysis ---\n        f_next = force(t_space[n+1], M)\n        \n        A_n = c0 * u[n] + c2 * u_dot[n] + c3 * u_ddot[n]\n        B_n = c1 * u[n] + c4 * u_dot[n] + c5 * u_ddot[n]\n        \n        f_hat = f_next + M * A_n + C * B_n\n        \n        u[n+1] = inv_K_hat * f_hat\n        u_ddot[n+1] = c0 * (u[n+1] - u[n]) - c2 * u_dot[n] - c3 * u_ddot[n]\n        u_dot[n+1] = u_dot[n] + (1.0 - gamma) * dt * u_ddot[n] + gamma * dt * u_ddot[n+1]\n\n        # --- Sensitivity Analysis ---\n        for j, p_key in enumerate(param_keys):\n            # Derivatives of M, C, K, f w.r.t parameter p\n            dM_dp, dC_dp, dK_dp, df_dp = 0, 0, 0, 0\n            if p_key == 'am':\n                dM_dp = M0\n                df_dp = -M0 * ag(t_space[n+1])\n            elif p_key == 'ac':\n                dC_dp = C0\n            elif p_key == 'ak':\n                dK_dp = K0\n\n            # Derivatives of Newmark constants w.r.t. p\n            dc0_dp, dc1_dp, dc2_dp, dc3_dp, dc4_dp, dc5_dp = (0,)*6\n            if p_key in dc_dp:\n                dc0_dp, dc1_dp, dc2_dp, dc3_dp, dc4_dp, dc5_dp = dc_dp[p_key]\n                \n            # Derivative of effective stiffness\n            dKhat_dp = dK_dp + dc1_dp * C + c1 * dC_dp + dc0_dp * M + c0 * dM_dp\n\n            # Compute RHS for sensitivity equation: f_sens = df_hat/dp - dK_hat/dp * u_n+1\n            \n            # Terms propagating sensitivities from step n\n            propagated_A = c0 * du_dp[n, j] + c2 * dudot_dp[n, j] + c3 * duddot_dp[n, j]\n            propagated_B = c1 * du_dp[n, j] + c4 * dudot_dp[n, j] + c5 * duddot_dp[n, j]\n            \n            # Terms from direct differentiation\n            direct_A = dc0_dp * u[n] + dc2_dp * u_dot[n] + dc3_dp * u_ddot[n]\n            direct_B = dc1_dp * u[n] + dc4_dp * u_dot[n] + dc5_dp * u_ddot[n]\n            \n            dfhat_dp = (df_dp + dM_dp * A_n + M * (direct_A + propagated_A) +\n                        dC_dp * B_n + C * (direct_B + propagated_B))\n            \n            f_sens = dfhat_dp - dKhat_dp * u[n+1]\n            \n            # Solve for displacement sensitivity\n            du_dp[n+1, j] = inv_K_hat * f_sens\n            \n            # Update acceleration and velocity sensitivities\n            d_gamma_dp = 1.0 if p_key == 'gamma' else 0.0\n            \n            duddot_dp[n+1, j] = (dc0_dp * (u[n+1] - u[n]) + \n                                 c0 * (du_dp[n+1, j] - du_dp[n, j]) -\n                                 dc2_dp * u_dot[n] - c2 * dudot_dp[n, j] -\n                                 dc3_dp * u_ddot[n] - c3 * duddot_dp[n, j])\n            \n            dudot_dp[n+1, j] = (dudot_dp[n, j] - \n                                d_gamma_dp * dt * u_ddot[n] + (1.0 - gamma) * dt * duddot_dp[n, j] +\n                                d_gamma_dp * dt * u_ddot[n+1] + gamma * dt * duddot_dp[n+1, j])\n\n    # Final displacement\n    J = u[-1]\n    \n    # Gradient of J\n    grad_J = du_dp[-1, :] # [dJ/dbeta, dJ/dgamma, dJ/dam, dJ/dac, dJ/dak]\n    \n    # Standard deviation of J\n    dJ_dam = grad_J[2]\n    dJ_dac = grad_J[3]\n    dJ_dak = grad_J[4]\n    \n    sigma_J_sq = (dJ_dam**2 * sigma_am**2 + \n                  dJ_dac**2 * sigma_ac**2 + \n                  dJ_dak**2 * sigma_ak**2)\n    sigma_J = np.sqrt(sigma_J_sq)\n    \n    return [J, *grad_J, sigma_J]\n\ndef solve():\n    test_cases = [\n        (0.25, 0.5, 1.0, 1.0, 1.0, 0.05, 0.05, 0.05),\n        (1.0/6.0, 0.5, 1.0, 0.2, 1.0, 0.1, 0.05, 0.05),\n        (0.3, 0.6, 1.2, 1.0, 1.5, 0.02, 0.02, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = run_analysis(case)\n        results.append(f\"[{','.join(f'{x:.6e}' for x in case_results)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3532506"}]}