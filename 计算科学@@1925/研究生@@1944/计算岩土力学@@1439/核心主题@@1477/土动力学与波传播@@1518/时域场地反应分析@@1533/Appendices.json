{"hands_on_practices": [{"introduction": "时域场地响应分析始于高质量的输入地震动数据。原始记录通常包含低频噪声或“仪器漂移”，这会污染分析结果，特别是对于具有长自振周期的软土场地。本实践将指导您设计一个高通滤波器，您将学习如何在消除不必要的漂移与保留激发场地基本频率的长周期地震动分量之间取得平衡，这是数据预处理中的一项关键技能。[@problem_id:3559408]", "problem": "您的任务是为时域中的场地响应分析设计一个数字高通滤波器，用于预处理加速度时程。其目标是消除仪器漂移，同时不衰减对软弱场地至关重要的长周期分量。设计必须通过确保所选的截止频率保留场地的基本振型来证明其合理性。\n\n从与一维垂直传播剪切波模型相符的基本原理出发。在一个总厚度为$H$的垂直非均质土柱中，该土柱由$N$个水平层组成，各层厚度为$h_i$，剪切波速为$V_{s,i}$（其中$i \\in \\{1,\\dots,N\\}$），走时平均剪切波速为\n$$\nV_{s,\\mathrm{avg}} = \\frac{H}{\\sum_{i=1}^{N} \\frac{h_i}{V_{s,i}}}.\n$$\n使用四分之一波长近似法计算垂直剪切波共振的基本振型，场地的基频为\n$$\nf_0 = \\frac{V_{s,\\mathrm{avg}}}{4 H}.\n$$\n您必须设计一个阶数为$n$、采样频率为$f_s$的数字无限脉冲响应（IIR）巴特沃斯高通滤波器，其截止频率为$f_c$（单位为$\\mathrm{Hz}$）。设该滤波器的离散时间频率响应为$H(\\mathrm{e}^{\\mathrm{j}\\omega})$，其中$\\omega = 2\\pi f/f_s$。您的设计必须在两个特定频率上满足以下约束条件：\n- 通带保持：在场地基频处的幅值必须满足\n$$\n\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right| \\ge A_{\\mathrm{pass}},\n$$\n- 阻带漂移去除：在漂移频率$f_d$处的幅值必须满足\n$$\n\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right| \\le A_{\\mathrm{stop}}.\n$$\n为了优先保护长周期场地响应，选择$f_c$作为仍然满足$f_0$处通带保持约束的最大截止频率。然后评估此选定的$f_c$是否满足$f_d$处的漂移去除约束。如果漂移去除约束未被满足，则宣布该设计在此情况下不可行，但仍需报告为保护场地基本振型而选择的$f_c$。\n\n您的程序必须：\n- 根据分层剖面使用走时平均法计算$f_0$。\n- 设计一个阶数为$n$、采样频率为$f_s$的巴特沃斯高通滤波器。\n- 确定满足$f_0$处通带保持阈值$A_{\\mathrm{pass}}$的最大$f_c$。\n- 计算选定$f_c$下在$f_0$和$f_d$处的幅值$\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right|$和$\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right|$。\n- 为每个测试案例报告一个元组$[f_c, \\mathrm{feasible}, A_{f_0}, A_{f_d}]$，其中$f_c$以$\\mathrm{Hz}$为单位，$\\mathrm{feasible}$在满足漂移去除约束时为$1$，否则为$0$，$A_{f_0} = \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right|$，$A_{f_d} = \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right|$。\n\n所有最终数值输出必须以指定单位表示：频率以$\\mathrm{Hz}$为单位，四舍五入至三位小数。幅值$A_{f_0}$和$A_{f_d}$必须四舍五入至三位小数。可行性指示符必须是$\\{0,1\\}$中的整数。\n\n在所有案例中使用以下全局阈值：\n- $A_{\\mathrm{pass}} = 0.95$，\n- $A_{\\mathrm{stop}} = 0.10$。\n\n测试套件。您的程序必须运行以下三个测试案例，计算基频$f_0$，按所述设计滤波器，然后生成所需输出：\n- 案例1（软弱场地，两层）：\n  - 土层：$(h_1, V_{s,1}) = (30 \\ \\mathrm{m}, 150 \\ \\mathrm{m/s})$，$(h_2, V_{s,2}) = (20 \\ \\mathrm{m}, 250 \\ \\mathrm{m/s})$。\n  - 采样频率：$f_s = 100 \\ \\mathrm{Hz}$。\n  - 巴特沃斯阶数：$n = 4$。\n  - 漂移频率：$f_d = 0.02 \\ \\mathrm{Hz}$。\n- 案例2（软弱场地，单层）：\n  - 土层：$(h_1, V_{s,1}) = (80 \\ \\mathrm{m}, 160 \\ \\mathrm{m/s})$。\n  - 采样频率：$f_s = 50 \\ \\mathrm{Hz}$。\n  - 巴特沃斯阶数：$n = 2$。\n  - 漂移频率：$f_d = 0.05 \\ \\mathrm{Hz}$。\n- 案例3（极软弱场地，靠近漂移频带，两层）：\n  - 土层：$(h_1, V_{s,1}) = (70 \\ \\mathrm{m}, 120 \\ \\mathrm{m/s})$，$(h_2, V_{s,2}) = (30 \\ \\mathrm{m}, 180 \\ \\mathrm{m/s})$。\n  - 采样频率：$f_s = 40 \\ \\mathrm{Hz}$。\n  - 巴特沃斯阶数：$n = 4$。\n  - 漂移频率：$f_d = 0.20 \\ \\mathrm{Hz}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个案例结果的列表，每个案例的结果按$[f_c,\\mathrm{feasible},A_{f_0},A_{f_d}]$的顺序列出。外层列表必须按上述案例顺序包含三个内层列表。该行必须以逗号分隔的列表形式打印，并用方括号括起来，例如：\n\"[ [f_c^{(1)},\\mathrm{feasible}^{(1)},A_{f_0}^{(1)},A_{f_d}^{(1)} ], [f_c^{(2)},\\mathrm{feasible}^{(2)},A_{f_0}^{(2)},A_{f_d}^{(2)}], [f_c^{(3)},\\mathrm{feasible}^{(3)},A_{f_0}^{(3)},A_{f_d}^{(3)}] ]\"\n其中每个$f_c$以$\\mathrm{Hz}$为单位，四舍五入至三位小数，每个$A_{f_0}$和$A_{f_d}$四舍五入至三位小数，每个可行性指示符为整数$0$或$1$。", "solution": "在进行求解之前，需要对问题进行验证。\n\n### 步骤1：提取给定条件\n- **模型**：一维垂直传播剪切波模型，作用于总厚度为$H$的土柱，该土柱由$N$个厚度为$h_i$、剪切波速为$V_{s,i}$的土层组成。\n- **走时平均剪切波速**：$V_{s,\\mathrm{avg}} = \\frac{H}{\\sum_{i=1}^{N} \\frac{h_i}{V_{s,i}}}$。\n- **场地基频**：$f_0 = \\frac{V_{s,\\mathrm{avg}}}{4 H}$，使用四分之一波长近似法。\n- **滤波器**：阶数为$n$的数字无限脉冲响应（IIR）巴特沃斯高通滤波器。\n- **滤波器参数**：采样频率$f_s$，截止频率$f_c$。\n- **滤波器约束**：\n  - 通带保持：$\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right| \\ge A_{\\mathrm{pass}}$。\n  - 阻带漂移去除：$\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right| \\le A_{\\mathrm{stop}}$。\n- **设计目标**：选择满足通带保持约束的最大$f_c$值。然后，检查此$f_c$是否满足阻带漂移去除约束。\n- **全局阈值**：$A_{\\mathrm{pass}} = 0.95$，$A_{\\mathrm{stop}} = 0.10$。\n- **输出向量**：对每个案例，报告$[f_c, \\mathrm{feasible}, A_{f_0}, A_{f_d}]$，其中$\\mathrm{feasible}$在满足阻带约束时为$1$，否则为$0$。$A_{f_0}$和$A_{f_d}$分别是滤波器在$f_0$和$f_d$处的幅值。数值应四舍五入至三位小数。\n- **测试案例**：\n  - **案例1**：土层：$(h_1, V_{s,1}) = (30 \\ \\mathrm{m}, 150 \\ \\mathrm{m/s})$，$(h_2, V_{s,2}) = (20 \\ \\mathrm{m}, 250 \\ \\mathrm{m/s})$。$f_s = 100 \\ \\mathrm{Hz}$，$n = 4$，$f_d = 0.02 \\ \\mathrm{Hz}$。\n  - **案例2**：土层：$(h_1, V_{s,1}) = (80 \\ \\mathrm{m}, 160 \\ \\mathrm{m/s})$。$f_s = 50 \\ \\mathrm{Hz}$，$n = 2$，$f_d = 0.05 \\ \\mathrm{Hz}$。\n  - **案例3**：土层：$(h_1, V_{s,1}) = (70 \\ \\mathrm{m}, 120 \\ \\mathrm{m/s})$，$(h_2, V_{s,2}) = (30 \\ \\mathrm{m}, 180 \\ \\mathrm{m/s})$。$f_s = 40 \\ \\mathrm{Hz}$，$n = 4$，$f_d = 0.20 \\ \\mathrm{Hz}$。\n\n### 步骤2：使用提取的给定条件进行验证\n根据验证标准评估该问题：\n- **有科学依据**：该问题基于地震工程和数字信号处理领域的标准、既定原理。$V_{s,\\mathrm{avg}}$、$f_0$以及巴特沃斯滤波器的公式都是正确且广泛使用的。\n- **提法明确**：问题定义清晰。在某一约束条件下最大化$f_c$，然后检查另一约束条件，这是一个明确的数学过程。如下文所示，滤波器增益相对于$f_c$的单调性确保了唯一解的存在。\n- **客观性**：问题陈述使用了精确、量化的参数和要求，没有主观性语言。\n- **完整性**：为每个测试案例提供了所有必要的信息（土层属性、滤波器规格、评估标准）。\n- **一致性**：问题陈述中没有内部矛盾。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。它自成体系、科学合理且提法明确。将提供完整的解决方案。\n\n---\n\n### 解题推导\n解决方案包括四个主要步骤：计算场地基频、推导滤波器截止频率的表达式、评估滤波器性能，以及将此过程应用于指定的测试案例。\n\n**步骤A：场地基频（$f_0$）**\n土层剖面的基频$f_0$由四分之一波长近似法给出：\n$$ f_0 = \\frac{V_{s,\\mathrm{avg}}}{4 H} $$\n其中$H = \\sum_{i=1}^{N} h_i$是总厚度，$V_{s,\\mathrm{avg}}$是走时平均剪切波速。代入$V_{s,\\mathrm{avg}}$的定义：\n$$ f_0 = \\frac{1}{4 H} \\left( \\frac{H}{\\sum_{i=1}^{N} \\frac{h_i}{V_{s,i}}} \\right) = \\frac{1}{4 \\sum_{i=1}^{N} \\frac{h_i}{V_{s,i}}} $$\n该表达式允许直接从土层属性计算$f_0$。项$\\sum (h_i / V_{s,i})$代表剪切波从基岩到地表单程传播的总时间。\n\n**步骤B：数字巴特沃斯高通滤波器响应**\n$n$阶模拟高通巴特沃斯滤波器的幅度平方响应由下式给出：\n$$ |H_{HP}(j\\Omega)|^2 = \\frac{(\\Omega/\\Omega_c)^{2n}}{1 + (\\Omega/\\Omega_c)^{2n}} $$\n其中$\\Omega$是模拟频率，$\\Omega_c$是模拟截止频率。为了获得相应数字滤波器的响应，我们使用双线性变换，它将模拟频域映射到数字频域。频率根据关系$\\Omega = \\tan(\\omega/2)$进行 warping（频率扭曲），假设采样周期归一化的映射常数。这里，$\\omega = 2\\pi f / f_s$是归一化数字频率，其中$f$是频率（Hz），$f_s$是采样频率。\n\n因此，数字高通滤波器在频率$f$处的幅度平方响应为：\n$$ \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f / f_s}\\right)\\right|^2 = \\frac{\\left(\\frac{\\tan(\\pi f / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}}{1 + \\left(\\frac{\\tan(\\pi f / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}} $$\n其中$f_c$是数字截止频率。\n\n**步骤C：确定最大截止频率（$f_c$）**\n设计问题要求找到满足通带保持约束的最大截止频率$f_c$：\n$$ \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right| \\ge A_{\\mathrm{pass}} $$\n我们来分析滤波器在固定频率$f=f_0$处的幅值对截止频率$f_c$的依赖关系。随着$f_c$的增加，$\\tan(\\pi f_c/f_s)$也增加。这导致比率$\\frac{\\tan(\\pi f_0/f_s)}{\\tan(\\pi f_c/f_s)}$减小。由于函数$g(x) = \\sqrt{x^{2n}/(1+x^{2n})}$对于$x>0$是单调递增的，因此幅值$\\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right|$是$f_c$的单调*递减*函数。\n\n为了找到允许的最大$f_c$，我们将$f_0$处的幅值设置为恰好等于允许的最小值$A_{\\mathrm{pass}}$：\n$$ \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_0 / f_s}\\right)\\right| = A_{\\mathrm{pass}} $$\n两边平方并代入响应公式，得到：\n$$ A_{\\mathrm{pass}}^2 = \\frac{\\left(\\frac{\\tan(\\pi f_0 / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}}{1 + \\left(\\frac{\\tan(\\pi f_0 / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}} $$\n令$X = \\left(\\frac{\\tan(\\pi f_0 / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}$。解出$X$得到$X = \\frac{A_{\\mathrm{pass}}^2}{1 - A_{\\mathrm{pass}}^2}$。代回并求解$\\tan(\\pi f_c/f_s)$:\n$$ \\frac{\\tan(\\pi f_0 / f_s)}{\\tan(\\pi f_c / f_s)} = \\left(\\frac{A_{\\mathrm{pass}}^2}{1 - A_{\\mathrm{pass}}^2}\\right)^{\\frac{1}{2n}} $$\n$$ \\tan\\left(\\frac{\\pi f_c}{f_s}\\right) = \\tan\\left(\\frac{\\pi f_0}{f_s}\\right) \\left(\\frac{1 - A_{\\mathrm{pass}}^2}{A_{\\mathrm{pass}}^2}\\right)^{\\frac{1}{2n}} $$\n最后，我们可以解出$f_c$：\n$$ f_c = \\frac{f_s}{\\pi} \\arctan\\left[ \\tan\\left(\\frac{\\pi f_0}{f_s}\\right) \\left(\\frac{1 - A_{\\mathrm{pass}}^2}{A_{\\mathrm{pass}}^2}\\right)^{\\frac{1}{2n}} \\right] $$\n该表达式给出了在$f_0$处能以至少$A_{\\mathrm{pass}}$的幅值保留信号的最大截止频率。\n\n**步骤D：可行性评估**\n对于唯一确定的$f_c$，根据设计，场地基频处的幅值响应为$A_{f_0} = A_{\\mathrm{pass}}$。现在我们必须评估在漂移频率$f_d$处的阻带约束：\n$$ A_{f_d} = \\left|H\\left(\\mathrm{e}^{\\mathrm{j} 2\\pi f_d / f_s}\\right)\\right| = \\sqrt{\\frac{\\left(\\frac{\\tan(\\pi f_d / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}}{1 + \\left(\\frac{\\tan(\\pi f_d / f_s)}{\\tan(\\pi f_c / f_s)}\\right)^{2n}}} $$\n如果$A_{f_d} \\le A_{\\mathrm{stop}}$，则认为设计是可行的。如果此条件成立，可行性指示符设为$1$，否则设为$0$。每个案例所需的输出是元组$[f_c, \\mathrm{feasible}, A_{f_0}, A_{f_d}]$。请注意，由于浮点运算，计算出的$A_{f_0}$将非常接近但不一定完全等于$A_{\\mathrm{pass}}$。为了报告，我们可以将其赋值为设计值$A_{\\mathrm{pass}}$。\n\n至此，解决该问题的理论框架已经完成。现在将此程序应用于三个测试案例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the digital filter design problem for site response analysis.\n    \"\"\"\n    \n    # Global filter design thresholds\n    A_pass = 0.95\n    A_stop = 0.10\n\n    # Test cases from the problem statement\n    # Each case is a tuple: (layers, fs, n, fd)\n    # layers is a list of tuples (h_i, Vs_i)\n    test_cases = [\n        # Case 1\n        ([ (30, 150), (20, 250) ], 100, 4, 0.02),\n        # Case 2\n        ([ (80, 160) ], 50, 2, 0.05),\n        # Case 3\n        ([ (70, 120), (30, 180) ], 40, 4, 0.20),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        layers, fs, n, fd = case\n        \n        # Step A: Compute Site Fundamental Frequency (f0)\n        # f0 = 1 / (4 * sum(h_i / Vs_i))\n        travel_time_sum = sum(h / vs for h, vs in layers)\n        f0 = 1.0 / (4.0 * travel_time_sum)\n\n        # Step C: Determine the Maximum Cutoff Frequency (fc)\n        # This is derived from setting the gain at f0 to exactly A_pass.\n        # tan(pi*fc/fs) = tan(pi*f0/fs) * ( (1 - A_pass^2) / A_pass^2 )^(1/(2n))\n        \n        # The equation can be rearranged to avoid division by a small number in some contexts\n        # tan(pi*fc/fs) = tan(pi*f0/fs) / ( (A_pass^2) / (1 - A_pass^2) )^(1/(2n))\n        \n        term_A = (A_pass**2) / (1 - A_pass**2)\n        C = np.power(term_A, 1.0 / (2.0 * n))\n        \n        tan_f0 = np.tan(np.pi * f0 / fs)\n        tan_fc = tan_f0 / C\n        \n        fc = (fs / np.pi) * np.arctan(tan_fc)\n\n        # By design, the magnitude at f0 is A_pass\n        A_f0 = A_pass\n\n        # Step D: Feasibility Assessment\n        # Calculate the filter magnitude at the drift frequency fd\n        # |H|^2 = ratio^(2n) / (1 + ratio^(2n)), where ratio = tan(pi*fd/fs) / tan(pi*fc/fs)\n        \n        tan_fd = np.tan(np.pi * fd / fs)\n        \n        # Using the tan_fc value calculated earlier\n        ratio_fd = tan_fd / tan_fc\n        \n        ratio_fd_pow_2n = np.power(ratio_fd, 2.0 * n)\n        \n        A_fd_sq = ratio_fd_pow_2n / (1.0 + ratio_fd_pow_2n)\n        A_fd = np.sqrt(A_fd_sq)\n\n        # Check if the drift removal constraint is satisfied\n        feasible = 1 if A_fd = A_stop else 0\n\n        # Store the results with required rounding\n        results.append([\n            round(fc, 3),\n            feasible,\n            round(A_f0, 3),\n            round(A_fd, 3)\n        ])\n    \n    # Format the final output string as a list of lists\n    # e.g., \"[[fc1, feas1, A_f0_1, A_fd_1], [fc2, ...]]\"\n    result_strings = []\n    for res in results:\n        # Format numbers to ensure 3 decimal places are shown\n        f_c_str = f\"{res[0]:.3f}\"\n        a_f0_str = f\"{res[2]:.3f}\"\n        a_fd_str = f\"{res[3]:.3f}\"\n        result_strings.append(f\"[{f_c_str}, {res[1]}, {a_f0_str}, {a_fd_str}]\")\n\n    final_output = f\"[{', '.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3559408"}, {"introduction": "时域分析的准确性在很大程度上取决于用于表示土体频率相关刚度和阻尼的本构模型。广义麦克斯韦模型（或Prony级数）是捕捉这种线性粘弹性行为的有效方法。本练习涉及校准Prony级数的参数，以匹配实验室测试中得到的目标动力特性，您将构建并求解一个非负最小二乘问题，这是将实验数据转化为时域模拟可用模型的一项基本技术。[@problem_id:3559337]", "problem": "您的任务是为适用于时域场地反应分析的线性黏弹性土体行为构建一个广义麦克斯韦表示（也称为Prony级数）。从线性黏弹性原理出发，构建并实现一个程序，该程序能够校准松弛模量的参数，以匹配在频域中测量的目标动力学特性。松弛模量的形式为 $G(t) = G_{\\infty} + \\sum_{i=1}^{N} G_i e^{-t/\\tau_i}$，其中 $G_{\\infty}$ 和 $G_i$ 是以兆帕（MPa）为单位的模量，$\\tau_i$ 是以秒（s）为单位的松弛时间。目标以复剪切模量值作为频率的函数给出，程序必须根据一组给定的松弛时间 $\\{\\tau_i\\}_{i=1}^{N}$，确定非负系数 $G_{\\infty}$ 和 $\\{G_i\\}_{i=1}^{N}$。所有频率均以赫兹（Hz）为单位指定，因此角频率为 $\\omega = 2\\pi f$，其中 $f$ 的单位是赫兹，$\\omega$ 的单位是弧度/秒。\n\n您的程序必须基于以下基本原理进行设计：\n- 线性黏弹性的玻尔兹曼叠加原理：对于剪切应力 $\\sigma(t)$ 和剪切应变 $\\gamma(t)$，有 $\\sigma(t) = \\int_{0}^{t} G(t-s) \\, \\frac{d\\gamma(s)}{ds} \\, ds$。\n- 对于谐和应变 $\\gamma(t) = \\gamma_0 e^{i \\omega t}$，应力和应变通过复剪切模量 $G^*(\\omega)$ 相关联，使得 $\\sigma(t) = \\Re\\{G^*(\\omega)\\gamma_0 e^{i \\omega t}\\}$。\n- 复剪切模量通过傅里叶-拉普拉斯关系与松弛模量相联系，对于广义麦克斯韦模型，可得\n$$\nG^*(\\omega) = G_{\\infty} + \\sum_{i=1}^{N} G_i \\frac{i \\omega \\tau_i}{1 + i \\omega \\tau_i}。\n$$\n- 储能模量和耗散模量分别为 $G'(\\omega) = \\Re\\{G^*(\\omega)\\}$ 和 $G''(\\omega) = \\Im\\{G^*(\\omega)\\}$。出现在实部和虚部的系数为\n$$\n\\Re\\left\\{\\frac{i \\omega \\tau_i}{1 + i \\omega \\tau_i}\\right\\} = \\frac{\\omega^2 \\tau_i^2}{1 + \\omega^2 \\tau_i^2}, \\quad\n\\Im\\left\\{\\frac{i \\omega \\tau_i}{1 + i \\omega \\tau_i}\\right\\} = \\frac{\\omega \\tau_i}{1 + \\omega^2 \\tau_i^2}。\n$$\n\n您的任务是实现一个求解器，对于给定的一组频率 $\\{f_k\\}_{k=1}^{M}$、目标值 $\\{G'_k\\}_{k=1}^{M}$ 和 $\\{G''_k\\}_{k=1}^{M}$（其中 $G'_k$ 和 $G''_k$ 的单位为 MPa）以及给定的松弛时间 $\\{\\tau_i\\}_{i=1}^{N}$（单位为 s），通过在一个单一的线性、非负最小二乘问题中最小化储能和耗散方程的平方失配来计算非负参数 $G_{\\infty}$ 和 $\\{G_i\\}_{i=1}^{N}$。具体来说，构建超定实数系统 $A \\mathbf{x} \\approx \\mathbf{b}$，其中未知向量为 $\\mathbf{x} = [G_{\\infty}, G_1, \\dots, G_N]^{\\mathsf{T}}$，并受所有分量 $x_j \\ge 0$ 的约束。对于每个频率 $f_k$（其中 $\\omega_k = 2 \\pi f_k$）：\n- 储能模量对应的行是\n$$\n\\left[1, \\frac{\\omega_k^2 \\tau_1^2}{1 + \\omega_k^2 \\tau_1^2}, \\dots, \\frac{\\omega_k^2 \\tau_N^2}{1 + \\omega_k^2 \\tau_N^2}\\right] \\cdot \\mathbf{x} \\approx G'_k.\n$$\n- 耗散模量对应的行是\n$$\n\\left[0, \\frac{\\omega_k \\tau_1}{1 + \\omega_k^2 \\tau_1^2}, \\dots, \\frac{\\omega_k \\tau_N}{1 + \\omega_k^2 \\tau_N^2}\\right] \\cdot \\mathbf{x} \\approx G''_k.\n$$\n\n求解出 $\\mathbf{x}$ 后，计算每个频率下的模型复剪切模量\n$$\n\\widehat{G}^*_k = \\widehat{G}_{\\infty} + \\sum_{i=1}^{N} \\widehat{G}_i \\frac{i \\omega_k \\tau_i}{1 + i \\omega_k \\tau_i},\n$$\n并报告所有频率上的相对均方根误差\n$$\n\\varepsilon = \\sqrt{\\frac{\\sum_{k=1}^{M} \\left| \\widehat{G}^*_k - G^*_k \\right|^2}{\\sum_{k=1}^{M} \\left| G^*_k \\right|^2}},\n$$\n其中 $G^*_k = G'_k + i G''_k$，$\\left|\\cdot\\right|$ 表示复数模。\n\n内部使用的物理单位为：模量用兆帕（MPa），频率用赫兹（Hz），时间用秒（s）。输出误差 $\\varepsilon$ 是无量纲的。\n\n实现您的程序以求解以下测试套件。在每个测试中，“实验室导出”的目标值是根据已知参数无噪声合成的；您的求解器必须恢复这些参数，并为该测试案例计算相对均方根误差 $\\varepsilon$。\n\n- 测试 1（理想路径，多个分离的松弛时间）：\n    - 松弛时间：$\\tau = [\\,0.05,\\,0.5,\\,5.0\\,]$ s。\n    - 真实参数：$G_{\\infty} = 80$ MPa，$G = [\\,20,\\,30,\\,50\\,]$ MPa。\n    - 频率：$f = [\\,0.1,\\,0.5,\\,1.0,\\,5.0,\\,10.0\\,]$ Hz。\n\n- 测试 2（边界情况，纯弹性行为）：\n    - 松弛时间：$\\tau = [\\,0.1,\\,1.0,\\,10.0\\,]$ s。\n    - 真实参数：$G_{\\infty} = 120$ MPa，$G = [\\,0,\\,0,\\,0\\,]$ MPa。\n    - 频率：$f = [\\,0.1,\\,1.0,\\,10.0\\,]$ Hz。\n\n- 测试 3（边缘情况，松弛时间间隔紧密）：\n    - 松弛时间：$\\tau = [\\,0.5,\\,0.6,\\,5.0\\,]$ s。\n    - 真实参数：$G_{\\infty} = 60$ MPa，$G = [\\,15,\\,10,\\,25\\,]$ MPa。\n    - 频率：$f = [\\,0.1,\\,0.2,\\,0.5,\\,1.0,\\,2.0,\\,5.0,\\,10.0,\\,20.0\\,]$ Hz。\n\n您的程序应计算每个测试案例的相对均方根误差 $\\varepsilon$，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序为测试 1、2 和 3。例如，输出格式必须与 $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3]$ 完全一样，但没有空格。这三个条目必须是浮点数，分别代表每个测试的 $\\varepsilon$。", "solution": "该问题是有效的。它在科学上基于线性黏弹性原理，作为一个非负最小二乘参数识别问题是适定的，并且具有充分、一致和客观的细节说明。\n\n任务是校准线性黏弹性材料的广义麦克斯韦模型的参数。松弛模量 $G(t)$ 由一个Prony级数给出：\n$$\nG(t) = G_{\\infty} + \\sum_{i=1}^{N} G_i e^{-t/\\tau_i}\n$$\n其中 $G_{\\infty}$ 是长期或平衡剪切模量，$\\{G_i\\}_{i=1}^{N}$ 是麦克斯韦元件的强度，$\\{\\tau_i\\}_{i=1}^{N}$ 是相应的松弛时间。待定参数是 $G_{\\infty}$ 和 $\\{G_i\\}_{i=1}^{N}$，它们必须是非负的才具有物理意义。松弛时间 $\\{\\tau_i\\}_{i=1}^{N}$ 是预先给定的。\n\n对于时谐荷载，剪切应力 $\\sigma(t)$ 和剪切应变 $\\gamma(t)$ 之间的关系由复剪切模量 $G^*(\\omega)$ 描述。它通过傅里叶-拉普拉斯变换与松弛模量 $G(t)$ 相关。对于给定的Prony级数，复模量为：\n$$\nG^*(\\omega) = G_{\\infty} + \\sum_{i=1}^{N} G_i \\frac{i \\omega \\tau_i}{1 + i \\omega \\tau_i}\n$$\n其中 $\\omega = 2 \\pi f$ 是角频率，单位为弧度/秒，$f$ 是频率，单位为赫兹。\n\n复模量可以分解为其真实和虚部，分别称为储能模量 $G'(\\omega)$ 和耗散模量 $G''(\\omega)$：\n$$\nG^*(\\omega) = G'(\\omega) + i G''(\\omega)\n$$\n通过分离 $G^*(\\omega)$ 表达式的实部和虚部，我们得到：\n$$\nG'(\\omega) = \\Re\\{G^*(\\omega)\\} = G_{\\infty} + \\sum_{i=1}^{N} G_i \\frac{\\omega^2 \\tau_i^2}{1 + \\omega^2 \\tau_i^2}\n$$\n$$\nG''(\\omega) = \\Im\\{G^*(\\omega)\\} = \\sum_{i=1}^{N} G_i \\frac{\\omega \\tau_i}{1 + \\omega^2 \\tau_i^2}\n$$\n问题在于找到系数 $\\mathbf{x} = [G_{\\infty}, G_1, \\dots, G_N]^{\\mathsf{T}}$，以最佳拟合在一组 $M$ 个频率 $\\{f_k\\}_{k=1}^{M}$ 上提供的目标数据 $\\{G'_k\\}_{k=1}^{M}$ 和 $\\{G''_k\\}_{k=1}^{M}$。这些方程对于未知系数 $\\mathbf{x}$ 是线性的。我们可以将其构建为一个单一的超定线性系统 $A \\mathbf{x} \\approx \\mathbf{b}$。\n\n对于 $M$ 个频率中的每一个 $f_k$（其中 $\\omega_k = 2 \\pi f_k$），我们有两个线性方程，一个用于储能模量，另一个用于耗散模量。这样，对于 $N+1$ 个未知数，总共有 $2M$ 个方程。该系统可以通过堆叠这些方程来构建。矩阵 $A$ 的维度将是 $(2M) \\times (N+1)$，向量 $\\mathbf{b}$ 的长度将是 $2M$。\n\n对于给定的频率 $f_k$，矩阵 $A$ 中对应于储能模量 $G'_k$ 的行是：\n$$\nA_{k, \\cdot} = \\left[1, \\frac{\\omega_k^2 \\tau_1^2}{1 + \\omega_k^2 \\tau_1^2}, \\frac{\\omega_k^2 \\tau_2^2}{1 + \\omega_k^2 \\tau_2^2}, \\dots, \\frac{\\omega_k^2 \\tau_N^2}{1 + \\omega_k^2 \\tau_N^2}\\right]\n$$\n并且 $\\mathbf{b}$ 中的相应条目是 $b_k = G'_k$。\n\n矩阵 $A$ 中对应于耗散模量 $G''_k$ 的行（位于索引 $M+k$ 处）是：\n$$\nA_{M+k, \\cdot} = \\left[0, \\frac{\\omega_k \\tau_1}{1 + \\omega_k^2 \\tau_1^2}, \\frac{\\omega_k \\tau_2}{1 + \\omega_k^2 \\tau_2^2}, \\dots, \\frac{\\omega_k \\tau_N}{1 + \\omega_k^2 \\tau_N^2}\\right]\n$$\n并且 $\\mathbf{b}$ 中的相应条目是 $b_{M+k} = G''_k$。\n\n该问题通过找到向量 $\\hat{\\mathbf{x}}$ 来解决，该向量最小化欧几里得范数的平方 $\\| A \\mathbf{x} - \\mathbf{b} \\|_2^2$，并满足 $\\mathbf{x}$ 的所有分量均为非负（即 $x_j \\ge 0$）的约束。这是一个经典的非负最小二乘（NNLS）问题。\n\n每个测试案例的求解过程遵循以下步骤：\n1.  **合成目标数据：** 使用提供的“真实”参数（$G_{\\infty}$, $\\{G_i\\}$）和松弛时间 $\\{\\tau_i\\}$，在每个指定频率 $f_k$ 上生成无噪声的目标复剪切模量 $G^*_k = G'_k + i G''_k$。\n2.  **构建线性系统：** 如上所述构建矩阵 $A$ 和向量 $\\mathbf{b}$，使用合成的 $G'_k$ 和 $G''_k$ 作为目标。\n3.  **使用NNLS求解：** 使用标准的NNLS求解器（例如 `scipy.optimize.nnls`）来找到估计的参数向量 $\\hat{\\mathbf{x}} = [\\widehat{G}_{\\infty}, \\widehat{G}_1, \\dots, \\widehat{G}_N]^{\\mathsf{T}}$。\n4.  **评估模型拟合度：** 使用校准后的参数 $\\hat{\\mathbf{x}}$，计算每个频率下的模型复模量 $\\widehat{G}^*_k$。\n5.  **计算误差：** 使用以下公式计算模型值 $\\widehat{G}^*_k$ 与原始目标值 $G^*_k$ 之间的相对均方根误差 $\\varepsilon$：\n$$\n\\varepsilon = \\sqrt{\\frac{\\sum_{k=1}^{M} \\left| \\widehat{G}^*_k - G^*_k \\right|^2}{\\sum_{k=1}^{M} \\left| G^*_k \\right|^2}}\n$$\n由于目标数据是由与拟合模型形式相同的模型生成的，并且是无噪声的，因此预期误差 $\\varepsilon$ 应该非常接近于零，仅反映数值精度的限制。这可作为算法实现正确性的验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Calibrates a generalized Maxwell model to target complex shear modulus data\n    and computes the relative root-mean-square error for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"tau\": np.array([0.05, 0.5, 5.0]),  # s\n            \"G_inf_true\": 80.0,  # MPa\n            \"G_true\": np.array([20.0, 30.0, 50.0]),  # MPa\n            \"f\": np.array([0.1, 0.5, 1.0, 5.0, 10.0]),  # Hz\n        },\n        {\n            \"tau\": np.array([0.1, 1.0, 10.0]),  # s\n            \"G_inf_true\": 120.0,  # MPa\n            \"G_true\": np.array([0.0, 0.0, 0.0]),  # MPa\n            \"f\": np.array([0.1, 1.0, 10.0]),  # Hz\n        },\n        {\n            \"tau\": np.array([0.5, 0.6, 5.0]),  # s\n            \"G_inf_true\": 60.0,  # MPa\n            \"G_true\": np.array([15.0, 10.0, 25.0]),  # MPa\n            \"f\": np.array([0.1, 0.2, 0.5, 1.0, 2.0, 5.0, 10.0, 20.0]),  # Hz\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        tau = case[\"tau\"]\n        G_inf_true = case[\"G_inf_true\"]\n        G_true = case[\"G_true\"]\n        f = case[\"f\"]\n        \n        N = len(tau)\n        M = len(f)\n        omega = 2.0 * np.pi * f\n\n        # Step 1: Synthesize target data (_k denotes per-frequency)\n        G_star_k_target = np.zeros(M, dtype=complex)\n        for k in range(M):\n            w_k = omega[k]\n            # iωτ / (1 + iωτ)\n            complex_term = (1j * w_k * tau) / (1 + 1j * w_k * tau)\n            G_star_k_target[k] = G_inf_true + np.sum(G_true * complex_term)\n        \n        G_prime_k_target = G_star_k_target.real\n        G_double_prime_k_target = G_star_k_target.imag\n\n        # Step 2: Construct the linear system A*x = b for NNLS\n        A = np.zeros((2 * M, N + 1))\n        b = np.zeros(2 * M)\n\n        for k in range(M):\n            w_k = omega[k]\n            w_tau = w_k * tau\n            w_tau_sq = w_tau**2\n            \n            # Storage modulus row (G')\n            A[k, 0] = 1.0\n            A[k, 1:] = w_tau_sq / (1.0 + w_tau_sq)\n            b[k] = G_prime_k_target[k]\n\n            # Loss modulus row (G'')\n            A[M + k, 0] = 0.0\n            A[M + k, 1:] = w_tau / (1.0 + w_tau_sq)\n            b[M + k] = G_double_prime_k_target[k]\n\n        # Step 3: Solve the NNLS problem\n        x_hat, _ = nnls(A, b)\n        \n        G_inf_hat = x_hat[0]\n        G_hat = x_hat[1:]\n\n        # Step 4: Evaluate the model fit and compute modeled G*\n        G_star_k_model = np.zeros(M, dtype=complex)\n        for k in range(M):\n            w_k = omega[k]\n            complex_term = (1j * w_k * tau) / (1 + 1j * w_k * tau)\n            G_star_k_model[k] = G_inf_hat + np.sum(G_hat * complex_term)\n\n        # Step 5: Compute the relative root-mean-square error\n        numerator = np.sum(np.abs(G_star_k_model - G_star_k_target)**2)\n        denominator = np.sum(np.abs(G_star_k_target)**2)\n        \n        epsilon = 0.0\n        if denominator  0:\n            epsilon = np.sqrt(numerator / denominator)\n        \n        results.append(epsilon)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3559337"}, {"introduction": "在使用显式数值方法（如有限差分法）模拟强地震动引起的急剧波前传播时，可能会产生非物理振荡（吉布斯现象）。人工粘性是一种用于抑制这些振荡并确保解稳定的数值技术。在这个动手实践问题中，您将实现一个一维波传播模拟，并探索使用人工粘性所涉及的权衡，学习如何校准粘性参数以最小化数值噪声，同时确保土体的物理峰值响应不被过度阻尼，这是高等数值建模的一个关键方面。[@problem_id:3559403]", "problem": "要求您实现一个完整且可运行的程序，用于在时域显式有限差分法 (FDM) 场地响应分析中，为激波捕捉标定一个人工粘滞性参数。该程序必须使用线性动量守恒和类 Kelvin–Voigt 人工粘滞性模型，模拟一维垂直剪切波在均质土柱中的传播，然后选择能够最小化 Gibbs 振荡，同时满足峰值剪切应变衰减限制的最小人工粘滞性。\n\n从以下基本原理出发：\n- 一维空间反平面剪切的线性动量守恒：$\\rho \\, \\partial^2 u / \\partial t^2 = \\partial \\tau / \\partial z$，其中 $u(z,t)$ 是水平位移，$\\rho$ 是质量密度，$z$ 是垂直坐标，$t$ 是时间，$\\tau$ 是剪切应力。\n- 带有 Kelvin–Voigt 型人工粘滞性项的线性弹性本构关系：$\\tau = G \\, \\partial u / \\partial z + \\mu_a \\, \\partial (\\partial u / \\partial z) / \\partial t$，其中 $G$ 是剪切模量，$\\mu_a$ 是待标定的人工粘滞性系数。\n- 运动学定义：$\\gamma = \\partial u / \\partial z$ 是工程剪切应变，$v = \\partial u / \\partial t$ 是质点速度。\n\n模拟在厚度为 $H$ 的土层中垂直传播的剪切波，其表面 $z=0$ 为自由应力面，基底 $z=H$ 处有指定的水平运动。使用间距为 $\\Delta z$ 的均匀空间网格和时间步长为 $\\Delta t$ 的显式中心差分时间积分方案，该方案需满足一个物理上合理的稳定性约束。波速为 $c = \\sqrt{G/\\rho}$。顶部边界条件为零剪切牵引力 $\\tau(z=0,t)=0$。基底 $z=H$ 处的边界为指定位移 $u_\\text{base}(t)$，该位移通过对指定的梯形基底速度 $v_\\text{base}(t)$ 进行积分得到。\n\n基底速度时程：\n- 幅值 $V_0 = 0.5 \\, \\mathrm{m/s}$。\n- 开始时间 $t_0 = 0.05 \\, \\mathrm{s}$。\n- 线性上升时间 $t_r$（每个测试案例不同）。\n- 保持时间 $T_\\mathrm{hold} = 0.1 \\, \\mathrm{s}$。\n- 持续时间为 $t_r$ 的线性下降时间。\n\n设材料和几何参数为：\n- $\\rho = 1800 \\, \\mathrm{kg/m^3}$，\n- $G = 80 \\times 10^6 \\, \\mathrm{Pa}$，\n- $H = 30 \\, \\mathrm{m}$，\n- 总模拟时间 $T_\\mathrm{end} = 1.2 \\, \\mathrm{s}$。\n\n为自由表面剪切应变 $\\gamma(t)$ 定义一个定量振荡度量：\n- 设 $\\gamma_\\max = \\max_t |\\gamma(t)|$，并设 $t^\\star$ 为首次达到此最大值的时间。\n- 定义峰后振荡指数 $O = \\max_{t  t^\\star} |\\gamma(t)| / \\gamma_\\max$，约定若集合 $\\{tt^\\star\\}$ 为空，则 $O=0$。\n\n通过与 $\\mu_a = 0$ 的基准模拟进行比较，定义人工粘滞性 $\\mu_a$ 的容许性约束：\n- 设 $\\gamma_\\max^{(0)}$ 表示基准峰值。\n- 给定一个目标衰减分数 $\\delta \\in [0,1)$，如果一个候选值 $\\mu_a$ 满足 $\\max_t |\\gamma_{\\mu_a}(t)| \\ge (1 - \\delta) \\, \\gamma_\\max^{(0)}$，则该值是容许的。\n\n标定目标：\n- 在一个有限的候选集 $\\{\\mu_a^{(k)}\\}$（均匀分布于区间 $[0, \\mu_\\text{max}]$，其中 $\\mu_\\text{max} = 3 \\times 10^5 \\, \\mathrm{Pa \\cdot s}$，共 $25$ 个样本（含端点））中，选择在满足上述容许性约束的前提下，使 $O$ 最小化的 $\\mu_a$。如果 $O$ 值相同，则选择最小的 $\\mu_a$。\n\n数值离散化要求：\n- 对 $u_{tt}$ 使用显式中心差分法，对 $u_{zz}$ 和 $v_{zz}$ 使用二阶中心差分法。\n- 通过一个零梯度（镜像）条件来施加自由表面边界条件，该条件一致地强制 $\\tau(z=0,t)=0$。\n- 通过直接指定 $u(z=H,t) = u_\\text{base}(t)$ 来施加基底边界条件，其中 $u_\\text{base}(t)$ 是通过在离散时间网格上使用梯形法则对 $v_\\text{base}(t)$ 进行时间积分得到的。\n- 通过施加一个时间步长 $\\Delta t$ 来确保稳定性，该时间步长需满足从离散格式的量纲分析中推导出的波传播和粘滞性约束。请在解答中解释您的选择和推导过程。所有时间单位必须为秒；所有距离单位为米；刚度单位为帕斯卡；密度单位为 $\\mathrm{kg/m^3}$；粘滞性单位为 $\\mathrm{Pa \\cdot s}$。\n\n标定与测试协议：\n- 对于下方的每个测试案例，首先用 $\\mu_a=0$ 计算基准值 $\\gamma_\\max^{(0)}$，然后评估 $[0, \\mu_\\text{max}]$ 中的 $25$ 个候选值，并使用上述规则选择标定后的 $\\mu_a$。\n- 报告标定后的 $\\mu_a$ 值，单位为 $\\mathrm{Pa \\cdot s}$，四舍五入到最接近的 $1000 \\, \\mathrm{Pa \\cdot s}$。\n\n测试套件：\n- 案例 A: $\\delta = 0.15$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.01 \\, \\mathrm{s}$。\n- 案例 B: $\\delta = 0.05$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$。\n- 案例 C: $\\delta = 0.30$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$。\n- 案例 D: $\\delta = 0.15$, $\\Delta z = 1.0 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，内容是标定后的粘滞性系数。每个标定的 $\\mu_a$ 均以 $\\mathrm{Pa \\cdot s}$ 为单位，并四舍五入到最接近的 $1000 \\, \\mathrm{Pa \\cdot s}$。例如，格式必须严格为 $[\\mu_{A},\\mu_{B},\\mu_{C},\\mu_{D}]$，不含多余空格或文本，其中每个 $\\mu_{\\bullet}$ 是一个按规定四舍五入的数值，单位为 $\\mathrm{Pa \\cdot s}$。", "solution": "用户要求实现并执行一个程序，用于标定一维剪切波传播模拟中的人工粘滞性参数。该过程涉及验证问题陈述、推导数值方法，并根据指定标准实现标定算法。\n\n### 问题验证\n\n**步骤 1：提取的已知条件**\n- **控制方程**：\n  - 动量守恒：$\\rho \\, \\partial^2 u / \\partial t^2 = \\partial \\tau / \\partial z$\n  - 本构关系 (Kelvin-Voigt)：$\\tau = G \\, \\partial u / \\partial z + \\mu_a \\, \\partial (\\partial u / \\partial z) / \\partial t$\n- **定义**：$\\gamma = \\partial u / \\partial z$ (剪切应变)，$v = \\partial u / \\partial t$ (质点速度)。\n- **物理模型**：一维土层，厚度 $H = 30 \\, \\mathrm{m}$，密度 $\\rho = 1800 \\, \\mathrm{kg/m^3}$，剪切模量 $G = 80 \\times 10^6 \\, \\mathrm{Pa}$。\n- **边界条件**：地表应力自由 ($z=0, \\tau=0$)，基底为指定位移 $u_\\text{base}(t)$ ($z=H$)。\n- **输入运动**：梯形基底速度 $v_\\text{base}(t)$，幅值 $V_0 = 0.5 \\, \\mathrm{m/s}$，开始时间 $t_0 = 0.05 \\, \\mathrm{s}$，保持时间 $T_\\mathrm{hold} = 0.1 \\, \\mathrm{s}$，以及可变的上升/下降时间 $t_r$。\n- **模拟参数**：总时长 $T_\\mathrm{end} = 1.2 \\, \\mathrm{s}$，可变的网格间距 $\\Delta z$。\n- **标定目标**：最小化自由表面剪切应变的峰后振荡指数 $O = (\\max_{t  t^\\star} |\\gamma(t)|) / \\gamma_\\max$，其中 $t^\\star$ 是首次出现峰值 $|\\gamma(t)|=\\gamma_\\max$ 的时间。\n- **容许性约束**：若候选粘滞性 $\\mu_a$ 的峰值应变 $\\max_t |\\gamma_{\\mu_a}(t)|$ 至少为 $(1 - \\delta) \\, \\gamma_\\max^{(0)}$，则该值是容许的，其中 $\\gamma_\\max^{(0)}$ 是基准情况 $\\mu_a = 0$ 的峰值应变。$\\delta$ 是给定的衰减分数。\n- **候选粘滞性**：在 $[0, \\mu_\\text{max}]$ 区间内均匀分布的 $25$ 个样本，其中 $\\mu_\\text{max} = 3 \\times 10^5 \\, \\mathrm{Pa \\cdot s}$。\n- **数值方案**：时间上采用显式中心差分法，空间上采用二阶中心差分法，自由表面采用镜像条件，基底采用指定位移。\n- **测试案例**：\n    - A: $\\delta = 0.15$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.01 \\, \\mathrm{s}$。\n    - B: $\\delta = 0.05$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$。\n    - C: $\\delta = 0.30$, $\\Delta z = 0.5 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$。\n    - D: $\\delta = 0.15$, $\\Delta z = 1.0 \\, \\mathrm{m}$, $t_r = 0.005 \\, \\mathrm{s}$。\n- **输出**：标定的 $\\mu_a$ 值，单位为 $\\mathrm{Pa \\cdot s}$，四舍五入到最接近的 $1000$，格式为 $[\\mu_A,\\mu_B,\\mu_C,\\mu_D]$。\n\n**步骤 2：已知条件的验证**\n该问题具有科学依据，是适定且客观的。它描述了计算岩土力学中的一个标准问题（一维场地响应分析），基于基本物理原理（带阻尼的波动方程）。参数物理上现实，量纲上一致，并且足以定义唯一解。标定目标和约束条件已正式指定。不存在矛盾、歧义或不成立的前提。\n\n**步骤 3：结论**\n该问题是**有效**的。将提供完整解答。\n\n### 基于原理的解答设计\n\n该解答涉及使用有限差分法 (FDM) 对控制性偏微分方程 (PDE) 进行数值求解，然后实现指定的标定程序。\n\n**1. 用于数值分析的控制方程**\n结合动量守恒方程和本构方程，并假设材料属性 $\\rho$、$G$ 和 $\\mu_a$ 为常数，我们得到一维粘滞阻尼波动方程：\n$$\n\\rho \\frac{\\partial^2 u}{\\partial t^2} = G \\frac{\\partial^2 u}{\\partial z^2} + \\mu_a \\frac{\\partial^3 u}{\\partial t \\partial z^2}\n$$\n其中 $u(z,t)$ 是水平位移。\n\n**2. 有限差分法离散化**\n我们用均匀网格对域进行离散化：$z_j = j \\Delta z$，对于 $j \\in \\{0, 1, ..., N_z\\}$，其中 $N_z \\Delta z = H$；时间上：$t_n = n \\Delta t$。设 $u_j^n \\approx u(z_j, t_n)$。\n\nPDE 使用二阶中心差分法对空间导数进行离散，并使用显式中心差分法对二阶时间导数进行离散。混合导数项使用时间上的后向差分来处理，以维持显式格式：\n$$\n\\frac{u_j^{n+1} - 2u_j^n + u_j^{n-1}}{(\\Delta t)^2} = \\frac{G}{\\rho} \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta z)^2} \\right) + \\frac{\\mu_a}{\\rho \\Delta t} \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta z)^2} - \\frac{u_{j+1}^{n-1} - 2u_j^{n-1} + u_{j-1}^{n-1}}{(\\Delta z)^2} \\right)\n$$\n求解 $u_j^{n+1}$，得到内部节点（$j \\in \\{1, ..., N_z-1\\}$）的显式更新规则：\n$$\nu_j^{n+1} = 2u_j^n - u_j^{n-1} + \\left( \\frac{G (\\Delta t)^2}{\\rho (\\Delta z)^2} + \\frac{\\mu_a \\Delta t}{\\rho (\\Delta z)^2} \\right)(u_{j+1}^n - 2u_j^n + u_{j-1}^n) - \\frac{\\mu_a \\Delta t}{\\rho (\\Delta z)^2}(u_{j+1}^{n-1} - 2u_j^{n-1} + u_{j-1}^{n-1})\n$$\n\n**3. 边界条件**\n- **基底（$z=H$, $j=N_z$）：** 直接施加指定位移：$u_{N_z}^n = u_\\text{base}(t_n)$。函数 $u_\\text{base}(t)$ 是通过使用梯形法则对指定的速度脉冲 $v_\\text{base}(t)$ 进行数值积分得到的。\n- **自由表面（$z=0$, $j=0$）：** 使用“镜像”或“虚拟节点”方法施加零应力条件 $\\tau(0,t)=0$。在 $j=-1$ 处引入一个虚拟节点。通过在表面强制 $\\partial u/\\partial z = 0$ 和 $\\partial v/\\partial z = 0$ 来近似满足 $\\tau=0$ 的条件。使用中心差分法，这意味着对于所有时间步 $n$，$u_{-1}^n = u_1^n$。将此代入 $j=0$ 的通用更新规则，得到表面节点的特定更新方程：\n$$\nu_0^{n+1} = 2u_0^n - u_0^{n-1} + \\left( \\frac{G (\\Delta t)^2}{\\rho (\\Delta z)^2} + \\frac{\\mu_a \\Delta t}{\\rho (\\Delta z)^2} \\right)(2u_1^n - 2u_0^n) - \\frac{\\mu_a \\Delta t}{\\rho (\\Delta z)^2}(2u_1^{n-1} - 2u_0^{n-1})\n$$\n\n**4. 初始条件**\n系统初始处于静止状态，因此 $u(z,0) = 0$ 且 $v(z,0) = \\partial u/\\partial t |_{t=0} = 0$。这意味着对所有 $j$，$u_j^0 = 0$。中心差分格式需要 $t_0$ 和 $t_{-1}$ 处的值。条件 $v_j^0=0$ 用于确定 $u_j^{-1}$。近似 $v_j^0 \\approx (u_j^1 - u_j^{-1})/(2\\Delta t) = 0$ 得到 $u_j^1 = u_j^{-1}$。将通用更新规则应用于第一步（$n=0$）并代入 $u_j^0=0$ 和 $u_j^{-1}=u_j^1$ 可简化为，对于所有内部节点，$u_j^1 = 0$。因此，模拟以 $u_j^0=0$ 开始，并且 $u_j^1$ 在各处都为零，除了指定的基底运动，$u_{N_z}^1 = u_\\text{base}(\\Delta t)$。\n\n**5. 稳定性判据**\n对于显式格式，时间步长 $\\Delta t$ 必须足够小以确保数值稳定性。对 FDM 格式进行 von Neumann 稳定性分析，得出以下条件：\n$$\n\\left(\\frac{c \\Delta t}{\\Delta z}\\right)^2 + \\frac{2 \\mu_a \\Delta t}{\\rho(\\Delta z)^2} \\le 1\n$$\n其中 $c = \\sqrt{G/\\rho}$ 是弹性剪切波速。这是一个关于 $\\Delta t$ 的二次不等式。临界时间步长 $\\Delta t_\\text{crit}$ 是其正根。对于给定的 $\\Delta z$，随着 $\\mu_a$ 的增加，此判据变得更严格。为确保一个测试集中的所有模拟都是稳定的，并使用一致的时间步长进行公平比较，$\\Delta t$ 使用可能的最大粘滞性 $\\mu_a = \\mu_\\text{max}$ 计算，并应用 0.9 的安全系数。\n\n**6. 标定算法**\n程序为每个测试案例系统地找到最优的人工粘滞性 $\\mu_a$。\n- **表面剪切应变**：在每个时间步，使用二阶精度的单边有限差分公式计算自由表面的剪切应变 $\\gamma(0,t) = \\partial u/\\partial z|_{z=0}$：$\\gamma_0^n = (-3u_0^n + 4u_1^n - u_2^n)/(2\\Delta z)$。\n- **分析循环**：\n  1. 对于给定的测试案例（$\\delta$, $\\Delta z$, $t_r$），计算稳定的时间步长 $\\Delta t$。\n  2. 生成来自 $[0, \\mu_\\text{max}]$ 的候选粘滞性 $\\{\\mu_a^{(k)}\\}$。\n  3. 运行一个 $\\mu_a = 0$ 的基准模拟，以确定参考峰值应变 $\\gamma_\\max^{(0)}$。然后，容许性阈值为 $(1 - \\delta)\\gamma_\\max^{(0)}$。\n  4. 程序按升序遍历候选粘滞性 $\\mu_a^{(k)}$。\n  5. 对于每个 $\\mu_a^{(k)}$，运行一次模拟以获得其峰值应变 $\\gamma_\\max^{(\\mu_a)}$ 和振荡指数 $O$。\n  6. 如果 $\\gamma_\\max^{(\\mu_a)}$ 满足容许性阈值，则将其对应的 $O$ 与当前最小值进行比较。\n  7. 产生最小 $O$ 的第一个容许的 $\\mu_a^{(k)}$ 被选为最优值。通过按升序迭代并仅在严格改进（$O  O_\\text{min}$）时更新最优值，自动满足平局决胜规则（选择最小的 $\\mu_a$）。\n- **最终输出**：四个测试案例中每个案例的标定 $\\mu_a$ 值都将四舍五入到最接近的 $1000 \\, \\mathrm{Pa \\cdot s}$，并按指定格式输出。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef get_stable_dt(delta_z, rho, G, mu_a_max):\n    \"\"\"\n    Calculates the maximum stable time step based on the FDM scheme's\n    stability condition, considering both elastic and viscous terms.\n    A safety factor of 0.9 is applied.\n    \"\"\"\n    c = np.sqrt(G / rho)\n    a_term = c**2 / delta_z**2\n    b_term = 2 * mu_a_max / (rho * delta_z**2)\n    \n    # Solve a_term * dt^2 + b_term * dt - 1 = 0 for the positive root dt_crit\n    if a_term == 0: # Should not happen for physical parameters\n        return float('inf')\n    \n    discriminant = b_term**2 + 4 * a_term\n    dt_crit = (-b_term + np.sqrt(discriminant)) / (2 * a_term)\n    \n    return 0.9 * dt_crit\n\ndef generate_base_motion(dt, t_end, V0, t0, tr, Thold):\n    \"\"\"\n    Generates the trapezoidal base velocity pulse and integrates it\n    to get the prescribed base displacement time history.\n    \"\"\"\n    time_pts = np.arange(0, t_end + dt, dt)\n    v_base = np.zeros_like(time_pts)\n    \n    t1 = t0\n    t2 = t1 + tr\n    t3 = t2 + Thold\n    t4 = t3 + tr\n    \n    # Linear rise\n    mask1 = (time_pts = t1)  (time_pts  t2)\n    v_base[mask1] = V0 * (time_pts[mask1] - t1) / tr\n    \n    # Hold\n    mask2 = (time_pts = t2)  (time_pts  t3)\n    v_base[mask2] = V0\n    \n    # Linear fall\n    mask3 = (time_pts = t3)  (time_pts  t4)\n    v_base[mask3] = V0 * (1.0 - (time_pts[mask3] - t3) / tr)\n\n    # Integrate velocity using trapezoidal rule\n    u_base = cumulative_trapezoid(v_base, x=time_pts, initial=0.0)\n    \n    return time_pts, u_base\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single 1D site response simulation for a given set of parameters.\n    \"\"\"\n    mu_a, delta_z, tr, H, rho, G, t_end, V0, t0, Thold, mu_a_max = params\n\n    # Spatial and temporal discretization\n    Nz = int(H / delta_z)\n    dt = get_stable_dt(delta_z, rho, G, mu_a_max)\n    Nt = int(t_end / dt)\n    \n    time_pts, u_base = generate_base_motion(dt, t_end, V0, t0, tr, Thold)\n    \n    # FDM coefficients\n    dz_sq = delta_z**2\n    C1_factor = (G * dt**2 / (rho * dz_sq)) + (mu_a * dt / (rho * dz_sq))\n    C2_factor = - (mu_a * dt / (rho * dz_sq))\n    \n    # Displacement arrays for u^{n-1}, u^n, and u^{n+1}\n    u_prev = np.zeros(Nz + 1)\n    u_curr = np.zeros(Nz + 1)\n    u_next = np.zeros(Nz + 1)\n    \n    # Initial conditions: u(z,0)=0, du/dt(z,0)=0 implies u^0=0 and u^1=0 (for internal nodes)\n    # Apply base motion for the first full time step\n    u_curr[Nz] = u_base[1]\n    \n    gamma_surface_history = np.zeros(Nt + 1)\n    \n    # Main time-stepping loop from n=1 to Nt\n    for n in range(1, Nt):\n        # Vectorized update for interior nodes j=1,...,Nz-1\n        d2u_curr_interior = u_curr[2:Nz+1] - 2 * u_curr[1:Nz] + u_curr[0:Nz-1]\n        d2u_prev_interior = u_prev[2:Nz+1] - 2 * u_prev[1:Nz] + u_prev[0:Nz-1]\n        \n        u_next[1:Nz] = (2 * u_curr[1:Nz] - u_prev[1:Nz] + \n                        C1_factor * d2u_curr_interior + \n                        C2_factor * d2u_prev_interior)\n        \n        # Free surface boundary condition (j=0) using mirror node (u_{-1} = u_1)\n        d2u_curr_surf = 2 * u_curr[1] - 2 * u_curr[0]\n        d2u_prev_surf = 2 * u_prev[1] - 2 * u_prev[0]\n        u_next[0] = (2 * u_curr[0] - u_prev[0] + \n                     C1_factor * d2u_curr_surf + \n                     C2_factor * d2u_prev_surf)\n\n        # Base boundary condition (j=Nz)\n        u_next[Nz] = u_base[n + 1] if n + 1  len(u_base) else u_base[-1]\n        \n        # Calculate surface strain (gamma = du/dz at z=0) using 2nd-order one-sided difference\n        if Nz = 2:\n            gamma_surface = (-3 * u_next[0] + 4 * u_next[1] - u_next[2]) / (2 * delta_z)\n        else: # Fallback for very coarse meshes\n            gamma_surface = (u_next[1] - u_next[0]) / delta_z\n        gamma_surface_history[n] = gamma_surface\n        \n        # Advance time step\n        u_prev[:] = u_curr\n        u_curr[:] = u_next\n\n    # Post-process to calculate metrics\n    gamma_abs = np.abs(gamma_surface_history)\n    gamma_max = np.max(gamma_abs)\n    \n    if gamma_max  1e-12: # Effectively zero motion\n        return 0.0, 0.0\n    \n    t_star_idx = np.argmax(gamma_abs)\n    post_peak_slice = gamma_abs[t_star_idx + 1:]\n    \n    if post_peak_slice.size == 0:\n        oscillation_index = 0.0\n    else:\n        oscillation_index = np.max(post_peak_slice) / gamma_max\n        \n    return gamma_max, oscillation_index\n\ndef solve():\n    # Test case definitions: (delta, delta_z, t_r)\n    test_cases = [\n        (0.15, 0.5, 0.01),\n        (0.05, 0.5, 0.005),\n        (0.30, 0.5, 0.005),\n        (0.15, 1.0, 0.005),\n    ]\n\n    # Shared physical and simulation parameters\n    rho = 1800.0\n    G = 80e6\n    H = 30.0\n    t_end = 1.2\n    V0 = 0.5\n    t0 = 0.05\n    Thold = 0.1\n    mu_a_max = 3e5\n    num_mu_samples = 25\n    \n    calibrated_mus = []\n\n    for delta, delta_z, tr in test_cases:\n        mu_a_candidates = np.linspace(0, mu_a_max, num_mu_samples)\n        \n        # Run baseline simulation (mu_a = 0) to get reference peak strain\n        params_base = (0.0, delta_z, tr, H, rho, G, t_end, V0, t0, Thold, mu_a_max)\n        gamma_max_0, _ = run_simulation(params_base)\n        \n        admissibility_threshold = (1.0 - delta) * gamma_max_0\n        \n        best_mu_a = -1.0\n        min_oscillation = float('inf')\n        \n        # Iterate through viscosity candidates to find the optimal one\n        for mu_a in mu_a_candidates:\n            params = (mu_a, delta_z, tr, H, rho, G, t_end, V0, t0, Thold, mu_a_max)\n            gamma_max_mu, oscillation_index = run_simulation(params)\n            \n            # Check for admissibility\n            if gamma_max_mu = admissibility_threshold:\n                # If admissible, check if it has a lower oscillation index\n                if oscillation_index  min_oscillation:\n                    min_oscillation = oscillation_index\n                    best_mu_a = mu_a\n                # The tie-breaking rule (smallest mu_a) is automatically handled\n                # as we iterate through mu_a in increasing order.\n        \n        # Round result to the nearest 1000 Pa.s\n        if best_mu_a != -1.0:\n            calibrated_mus.append(int(round(best_mu_a / 1000) * 1000))\n        else: # Should not be reached if mu_a=0 is always admissible\n            calibrated_mus.append(0)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, calibrated_mus))}]\")\n\nsolve()\n```", "id": "3559403"}]}