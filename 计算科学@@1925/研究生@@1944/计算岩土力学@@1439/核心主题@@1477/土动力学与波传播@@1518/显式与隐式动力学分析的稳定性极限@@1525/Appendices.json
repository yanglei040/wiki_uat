{"hands_on_practices": [{"introduction": "在显式有限元分析中，尤其是在计算岩土力学领域，质量集中（mass lumping）是一种常用且强大的技术。本练习将深入探讨质量集中为何能提高计算效率的理论基础。你将通过分析该技术如何改变系统的数值频散特性，最终理解它是如何放宽（即增大）稳定时间步长限制的。[@problem_id:3562349]", "problem": "一根长度为 $L$ 的一维弹性杆，使用 $N$ 个尺寸为 $h = L/N$ 的均匀双节点线性单元，通过有限元法 (FEM) 进行建模。该杆的杨氏模量为 $E$，质量密度为 $\\rho$，横截面积为 $A$。通过在网格上施加周期性边界条件（即网格无限重复），该杆被理想化为一个无限周期晶格，使得半离散的运动方程具有以下形式\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{K}$ 是由标准线性杆单元组集而成的刚度矩阵，而 $\\mathbf{M}$ 既可以是组集的一致质量矩阵 $\\mathbf{M}_{\\mathrm{c}}$，也可以是集中（行和）质量矩阵 $\\mathbf{M}_{\\mathrm{l}}$。你需要分析质量集总对半离散系统的最大固有圆频率 $\\omega_{\\max}$ 的影响，并从第一性原理出发，推断其对显式中心差分法稳定性极限的影响。\n\n仅从第一性原理和适用于所述背景的核心定义出发，按以下步骤进行：对节点索引 $j \\in \\mathbb{Z}$ 使用 Bloch 波拟设 $u_j(t) = U(t)\\,\\mathrm{e}^{\\mathrm{i}k j h}$，来写出离散波数 $k \\in [0,\\pi/h]$ 的广义特征值问题。求出与 $\\mathbf{M}_{\\mathrm{c}}$ 和 $\\mathbf{M}_{\\mathrm{l}}$ 相关的色散关系 $\\omega(k)$，并确定在第一布里渊区上的相应 $\\omega_{\\max}$。然后，推导对于频率为 $\\omega$ 的单个无阻尼模态，显式中心差分格式的稳定性条件，并推断用 $\\mathbf{M}_{\\mathrm{l}}$ 替换 $\\mathbf{M}_{\\mathrm{c}}$ 会如何改变显式临界时间步长 $\\Delta t_{\\mathrm{cr}}$。\n\n哪个陈述是正确的？\n\nA. 用 $\\mathbf{M}_{\\mathrm{l}}$ 替换 $\\mathbf{M}_{\\mathrm{c}}$ 会使 $\\omega_{\\max}$ 严格增加 $\\sqrt{3}$ 倍，从而使 $\\Delta t_{\\mathrm{cr}}$ 减少相同的倍数。\n\nB. 在周期杆中，用 $\\mathbf{M}_{\\mathrm{l}}$ 替换 $\\mathbf{M}_{\\mathrm{c}}$ 会使 $\\omega_{\\max}$ 从 $\\sqrt{12}\\,c/h$ 严格减小到 $2\\,c/h$，从而使 $\\Delta t_{\\mathrm{cr}}$ 增加 $\\sqrt{3}$ 倍，其中 $c = \\sqrt{E/\\rho}$ 是弹性波速。\n\nC. 质量集总不改变 $\\omega_{\\max}$；但是，隐式 Newmark 方法会变得不稳定，除非 $\\Delta t \\le 2/\\omega_{\\max}$。\n\nD. 质量集总同时减小了 $\\omega_{\\max}$ 和临界时间步长，因为对角占优使得系统更“硬”。", "solution": "问题陈述是有效的，因为它涉及计算力学中一个标准的、适定的问题，并且在科学上是合理的。我们按照指示从第一性原理开始推导。\n\n一个长度为 $h$、杨氏模量为 $E$、密度为 $\\rho$、面积为 $A$ 的双节点线性弹性杆单元具有以下单元刚度矩阵和质量矩阵。刚度矩阵为：\n$$ \\mathbf{K}^e = \\frac{EA}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n一致质量矩阵是从单元形函数推导出来的，其表达式为：\n$$ \\mathbf{M}_{\\mathrm{c}}^e = \\frac{\\rho A h}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix} $$\n集中质量矩阵是通过将一致质量矩阵的行相加并将结果放在对角线上（行和集总）得到的，这等效于将单元质量 $\\rho A h$ 平均分配到其两个节点上：\n$$ \\mathbf{M}_{\\mathrm{l}}^e = \\frac{\\rho A h}{2} \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} $$\n\n对于由这类单元构成的无限周期晶格，通用节点 $j$ 的运动方程是由单元 $(j-1, j)$ 和单元 $(j, j+1)$ 的贡献组集而成。\n控制半离散方程为 $\\mathbf{M}\\,\\ddot{\\mathbf{u}} + \\mathbf{K}\\,\\mathbf{u} = \\mathbf{0}$。对于节点 $j$，这可以写成：\n$$ \\sum_l M_{jl} \\ddot{u}_l(t) + \\sum_l K_{jl} u_l(t) = 0 $$\n组集节点 $j$ 的刚度项：\n$$ (K u)_j = \\frac{EA}{h}(-u_{j-1} + 2u_j - u_{j+1}) $$\n使用一致质量矩阵 $\\mathbf{M}_{\\mathrm{c}}$ 组集节点 $j$ 的惯性项：\n$$ (M_c \\ddot{u})_j = \\frac{\\rho A h}{6}(\\ddot{u}_{j-1} + 4\\ddot{u}_j + \\ddot{u}_{j+1}) $$\n使用集中质量矩阵 $\\mathbf{M}_{\\mathrm{l}}$：\n$$ (M_l \\ddot{u})_j = (\\frac{\\rho A h}{2} + \\frac{\\rho A h}{2})\\ddot{u}_j = \\rho A h \\ddot{u}_j $$\n\n我们寻找形式为 $u_j(t) = U_0 \\mathrm{e}^{\\mathrm{i}(k j h - \\omega t)}$ 的平面波解（Bloch 波）。将此拟设代入节点 $j$ 的运动方程，并消去公因子 $U_0 \\mathrm{e}^{\\mathrm{i}(k j h - \\omega t)}$，即可得到色散关系 $\\omega(k)$。\n注意，$u_{j\\pm 1}(t) = u_j(t) \\mathrm{e}^{\\pm \\mathrm{i} k h}$ 且 $\\ddot{u}_j(t) = -\\omega^2 u_j(t)$。\n\n对于一致质量情况（$\\mathbf{M}_{\\mathrm{c}}$）：\n$$ -\\omega_{\\mathrm{c}}^2 \\frac{\\rho A h}{6}(\\mathrm{e}^{-\\mathrm{i}kh} + 4 + \\mathrm{e}^{\\mathrm{i}kh}) + \\frac{EA}{h}(-\\mathrm{e}^{-\\mathrm{i}kh} + 2 - \\mathrm{e}^{\\mathrm{i}kh}) = 0 $$\n使用 $\\mathrm{e}^{\\mathrm{i}\\theta} + \\mathrm{e}^{-\\mathrm{i}\\theta} = 2\\cos(\\theta)$，我们得到：\n$$ -\\omega_{\\mathrm{c}}^2 \\frac{\\rho A h}{6}(4 + 2\\cos(kh)) + \\frac{EA}{h}(2 - 2\\cos(kh)) = 0 $$\n$$ \\omega_{\\mathrm{c}}^2 \\frac{\\rho A h}{3}(2 + \\cos(kh)) = \\frac{2EA}{h}(1 - \\cos(kh)) $$\n求解 $\\omega_{\\mathrm{c}}^2$ 并使用连续介质弹性波速的定义 $c = \\sqrt{E/\\rho}$：\n$$ \\omega_{\\mathrm{c}}^2(k) = \\frac{6EA}{\\rho A h^2} \\frac{1 - \\cos(kh)}{2 + \\cos(kh)} = \\frac{6c^2}{h^2} \\frac{1 - \\cos(kh)}{2 + \\cos(kh)} $$\n最大频率 $\\omega_{\\max}$ 出现在第一布里渊区的边界，此处 $k = \\pi/h$。在此波数下，$kh=\\pi$ 且 $\\cos(kh)=-1$。\n$$ \\omega_{\\mathrm{c},\\max}^2 = \\frac{6c^2}{h^2} \\frac{1 - (-1)}{2 + (-1)} = \\frac{6c^2}{h^2} \\frac{2}{1} = \\frac{12c^2}{h^2} $$\n$$ \\omega_{\\mathrm{c},\\max} = \\sqrt{12} \\frac{c}{h} $$\n\n对于集中质量情况（$\\mathbf{M}_{\\mathrm{l}}$）：\n$$ -\\omega_{\\mathrm{l}}^2 (\\rho A h) + \\frac{EA}{h}(-\\mathrm{e}^{-\\mathrm{i}kh} + 2 - \\mathrm{e}^{\\mathrm{i}kh}) = 0 $$\n$$ -\\omega_{\\mathrm{l}}^2 \\rho A h + \\frac{2EA}{h}(1 - \\cos(kh)) = 0 $$\n$$ \\omega_{\\mathrm{l}}^2(k) = \\frac{2EA}{\\rho A h^2}(1 - \\cos(kh)) = \\frac{2c^2}{h^2}(1 - \\cos(kh)) $$\n同样，在 $k=\\pi/h$ 处进行计算：\n$$ \\omega_{\\mathrm{l},\\max}^2 = \\frac{2c^2}{h^2}(1 - (-1)) = \\frac{4c^2}{h^2} $$\n$$ \\omega_{\\mathrm{l},\\max} = 2 \\frac{c}{h} $$\n\n比较最大频率，我们发现用集中质量矩阵替换一致质量矩阵会降低半离散系统的最大固有频率。\n频率之比为 $\\omega_{\\mathrm{c},\\max} / \\omega_{\\mathrm{l},\\max} = (\\sqrt{12}c/h) / (2c/h) = \\sqrt{12}/2 = 2\\sqrt{3}/2 = \\sqrt{3}$。\n因此，质量集总将 $\\omega_{\\max}$ 减小了 $\\sqrt{3}$ 倍。\n\n接下来，我们分析显式中心差分格式的稳定性。对于单自由度振子 $\\ddot{u} + \\omega^2 u = 0$，该格式稳定的充要条件是 $\\omega \\Delta t \\le 2$。对于方程组，稳定性由最高频率模态 $\\omega_{\\max}$ 决定。因此，临界时间步长 $\\Delta t_{\\mathrm{cr}}$ 为：\n$$ \\Delta t_{\\mathrm{cr}} = \\frac{2}{\\omega_{\\max}} $$\n这是半离散化系统的 Courant-Friedrichs-Lewy (CFL) 条件。\n\n使用推导出的 $\\omega_{\\max}$ 值：\n对于一致质量： $\\Delta t_{\\mathrm{cr,c}} = \\frac{2}{\\omega_{\\mathrm{c},\\max}} = \\frac{2}{\\sqrt{12}c/h} = \\frac{2h}{2\\sqrt{3}c} = \\frac{h}{\\sqrt{3}c}$。\n对于集中质量： $\\Delta t_{\\mathrm{cr,l}} = \\frac{2}{\\omega_{\\mathrm{l},\\max}} = \\frac{2}{2c/h} = \\frac{h}{c}$。\n\n比较临界时间步长，我们发现在用 $\\mathbf{M}_{\\mathrm{l}}$ 替换 $\\mathbf{M}_{\\mathrm{c}}$ 时的变化：\n$$ \\frac{\\Delta t_{\\mathrm{cr,l}}}{\\Delta t_{\\mathrm{cr,c}}} = \\frac{h/c}{h/(\\sqrt{3}c)} = \\sqrt{3} $$\n因此，用集中质量矩阵替换一致质量矩阵会使临界时间步长增加 $\\sqrt{3}$ 倍。\n\n现在我们评估给出的选项：\n\nA. 用 $\\mathbf{M}_{\\mathrm{l}}$ 替换 $\\mathbf{M}_{\\mathrm{c}}$ 会使 $\\omega_{\\max}$ 严格增加 $\\sqrt{3}$ 倍，从而使 $\\Delta t_{\\mathrm{cr}}$ 减少相同的倍数。\n此陈述不正确。用 $\\mathbf{M}_{\\mathrm{l}}$ 替换 $\\mathbf{M}_{\\mathrm{c}}$ 会*减小* $\\omega_{\\max}$，因此会*增加* $\\Delta t_{\\mathrm{cr}}$。\n\nB. 在周期杆中，用 $\\mathbf{M}_{\\mathrm{l}}$ 替换 $\\mathbf{M}_{\\mathrm{c}}$ 会使 $\\omega_{\\max}$ 从 $\\sqrt{12}\\,c/h$ 严格减小到 $2\\,c/h$，从而使 $\\Delta t_{\\mathrm{cr}}$ 增加 $\\sqrt{3}$ 倍，其中 $c = \\sqrt{E/\\rho}$ 是弹性波速。\n此陈述准确地反映了我们所有的发现。最大频率从 $\\omega_{\\mathrm{c},\\max} = \\sqrt{12}c/h$ 减小到 $\\omega_{\\mathrm{l},\\max} = 2c/h$。这导致临界时间步长 $\\Delta t_{\\mathrm{cr}}$ 增加了 $\\sqrt{3}$ 倍。$c$ 的定义也是正确的。\n\nC. 质量集总不改变 $\\omega_{\\max}$；但是，隐式 Newmark 方法会变得不稳定，除非 $\\Delta t \\le 2/\\omega_{\\max}$。\n此陈述不正确。首先，质量集总改变了 $\\omega_{\\max}$。其次，稳定性条件 $\\Delta t \\le 2/\\omega_{\\max}$ 适用于显式中心差分格式，而不适用于像无条件稳定的 Newmark 平均加速度法这样的常用隐式方法。\n\nD. 质量集总同时减小了 $\\omega_{\\max}$ 和临界时间步长，因为对角占优使得系统更“硬”。\n此陈述不正确。虽然质量集总确实减小了 $\\omega_{\\max}$，但它*增加*了临界时间步长 $\\Delta t_{\\mathrm{cr}}$。其给出的理由也是有缺陷的；一个具有较低 $\\omega_{\\max}$ 的系统在谱上被认为是“更软”的，而不是“更硬”的，从而允许更大的时间步长。\n\n基于分析的最终结论：选项 B 是唯一正确的陈述。\n\n基于以上推导的最终答案：\n- 用 $\\mathbf{M}_{\\mathrm{l}}$ 替换 $\\mathbf{M}_{\\mathrm{c}}$ 会将 $\\omega_{\\max}$ 从 $\\sqrt{12}\\,c/h$ 变为 $2\\,c/h$。这是一个减小。\n- 这个变化使 $\\Delta t_{\\mathrm{cr}}$ 增加了 $\\sqrt{3}$ 倍。\n- 选项 B 正确地陈述了这些事实。\n\n最终验证：\n- $\\omega_{\\mathrm{c},\\max} = \\sqrt{12}\\,c/h$\n- $\\omega_{\\mathrm{l},\\max} = 2\\,c/h$\n- $\\omega_{\\mathrm{l},\\max}  \\omega_{\\mathrm{c},\\max}$ (减小)\n- $\\Delta t_{\\mathrm{cr,l}} / \\Delta t_{\\mathrm{cr,c}} = \\omega_{\\mathrm{c},\\max} / \\omega_{\\mathrm{l},\\max} = \\sqrt{3}$ (增加 $\\sqrt{3}$ 倍)\n分析和结论是可靠的。选项 B 正确。", "answer": "$$\\boxed{B}$$", "id": "3562349"}, {"introduction": "本练习旨在连接理论与高级计算实践，将稳定性概念应用于更真实的场景中。你将面临的挑战是开发一种自适应网格细化算法，该算法能够在提高精度（使用更密的网格）的需求与维持一个可行的全局时间步长的实际约束之间做出智能权衡。这个任务直接解决了在非均匀网格下处理 Courant-Friedrichs-Lewy (CFL) 条件的挑战。[@problem_id:3562397]", "problem": "您被要求为一维线性弹性动力学设计并实现一种考虑稳定性的网格加密策略，该策略是计算岩土力学的典型代表。它能够选择在何处加密网格，同时自适应地选择时间步长，以确保显式时间积分的稳定性，且不会导致全局时间步长崩溃。其基本依据包括牛顿第二定律、一维波传播模型以及用于显式时间积分的 Courant–Friedrichs–Lewy (CFL) 稳定性概念。在一个由索引 $i$ 标识单元的一维网格中，每个单元都有长度 $h_i$（单位：米）、波速 $c_i$（单位：米/秒）和一个无量纲的加密分数 $s_i$，该分数表示加密该单元的期望程度。对于全局时间步长 $\\Delta t$（单位：秒），局部 Courant 数定义为 $\\theta_i = c_i \\Delta t / h_i$。显式稳定性的条件是，对所有 $i$，$\\theta_i$ 存在一个上界，而该策略必须选择与此界限一致的最大 $\\Delta t$。为避免全局时间步长崩溃，您需要施加一个约束，该约束限制了最小局部时间尺度 $\\tau_i = h_i / c_i$ 相对于整个网格的中位时间尺度的下限。对一个单元的加密操作最多将其长度 $h_i$ 减半一次（每个单元只能分裂一次），每次被接受的加密都会消耗给定加密预算中的一个单位。算法要求如下：\n\n- 每个测试用例的输入：列表 $[h_i]$（米）、$[c_i]$（米/秒）、$[s_i]$（无量纲加密分数）、最大允许 Courant 数 $\\theta_{\\max}$（无量纲）、一个避免崩溃的比率阈值 $\\beta$（无量纲）以及一个整数加密预算 $B \\ge 0$。\n\n- 算法使用的定义：\n  - 局部时间尺度为 $\\tau_i = h_i / c_i$（秒）。\n  - 崩溃比率为 $r = \\min_i \\tau_i \\, / \\, \\operatorname{median}_i \\tau_i$（无量纲）。\n  - 加密单元 $i$ 会将 $h_i$ 替换为 $h_i/2$（每个单元最多一次）。\n  - 最大稳定显式时间步长是满足以下条件的最大 $\\Delta t$：对于所有 $i$，所选的 $\\Delta t$ 不违反每个单元关于 $\\theta_i$ 的显式稳定性界限；选择与该界限以及所有加密后的 $h_i$ 一致的最大 $\\Delta t$。\n\n- 贪婪加密策略：\n  - 按 $s_i$ 的降序对候选单元进行排序。\n  - 按此顺序迭代，如果一个单元尚未被加密且预算尚有剩余，则尝试性地加密该单元。\n  - 在尝试性加密后，使用更新后的 $h_i$ 重新计算 $r$，并且仅当得到的 $r$ 保持大于或等于 $\\beta$ 时才接受该加密；否则，拒绝此次加密。\n  - 继续此过程，直到预算耗尽或不存在更多可接受的加密。\n\n- 时间步长选择：\n  - 在加密阶段之后，选择一个以秒为单位的全局 $\\Delta t$，其值为满足对任何单元 $i$，每个单元的 Courant 数 $\\theta_i = c_i \\Delta t / h_i$ 都不超过 $\\theta_{\\max}$ 的最大值。\n  - 使用加密后的 $h_i$ 报告最终的崩溃比率 $r$。\n\n您的程序必须实现上述加密策略和时间步长选择，并将其应用于以下测试套件。在所有情况下，$\\Delta t$ 均以秒表示。$[h_i]$ 的值以米为单位，$[c_i]$ 的值以米/秒为单位。\n\n- 测试用例 A（正常路径）：\n  - $[h_i] = [\\, 1.0, \\, 1.0, \\, 1.0, \\, 1.0, \\, 1.0, \\, 1.0 \\,]$\n  - $[c_i] = [\\, 200.0, \\, 300.0, \\, 400.0, \\, 250.0, \\, 350.0, \\, 150.0 \\,]$\n  - $[s_i] = [\\, 0.1, \\, 0.9, \\, 0.8, \\, 0.2, \\, 0.7, \\, 0.3 \\,]$\n  - $\\theta_{\\max} = 0.9$\n  - $\\beta = 0.4$\n  - $B = 2$\n\n- 测试用例 B（边界情况：预算为零，不允许加密）：\n  - $[h_i] = [\\, 2.0, \\, 0.5, \\, 1.0, \\, 1.5 \\,]$\n  - $[c_i] = [\\, 300.0, \\, 600.0, \\, 200.0, \\, 400.0 \\,]$\n  - $[s_i] = [\\, 0.5, \\, 0.7, \\, 0.1, \\, 0.2 \\,]$\n  - $\\theta_{\\max} = 0.95$\n  - $\\beta = 0.5$\n  - $B = 0$\n\n- 测试用例 C（边缘情况：会导致时间步长崩溃的单元具有高分；严格的比率限制阻止了加密）：\n  - $[h_i] = [\\, 1.0, \\, 1.0, \\, 1.0, \\, 1.0, \\, 1.0 \\,]$\n  - $[c_i] = [\\, 500.0, \\, 100.0, \\, 100.0, \\, 100.0, \\, 100.0 \\,]$\n  - $[s_i] = [\\, 1.0, \\, 0.2, \\, 0.2, \\, 0.2, \\, 0.2 \\,]$\n  - $\\theta_{\\max} = 0.9$\n  - $\\beta = 0.3$\n  - $B = 1$\n\n- 测试用例 D（边缘情况：低波速导致局部时间尺度较大；多次加密被接受且未导致崩溃）：\n  - $[h_i] = [\\, 0.8, \\, 0.8, \\, 0.8, \\, 0.8 \\,]$\n  - $[c_i] = [\\, 100.0, \\, 110.0, \\, 90.0, \\, 95.0 \\,]$\n  - $[s_i] = [\\, 0.5, \\, 0.6, \\, 0.9, \\, 0.4 \\,]$\n  - $\\theta_{\\max} = 0.85$\n  - $\\beta = 0.5$\n  - $B = 3$\n\n对于每个测试用例，您的程序必须输出一个包含三个条目的列表：\n- 所选的 $\\Delta t$（单位：秒），四舍五入到六位小数。\n- 最终的崩溃比率 $r$，四舍五入到六位小数。\n- 已加密单元的数量（整数）。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身就是按上述顺序排列的列表。例如，总体格式为“[ [dt_A,r_A,nref_A], [dt_B,r_B,nref_B], [dt_C,r_C,nref_D] ]”，不含任何额外文本。", "solution": "该问题要求为一维线性弹性动力学设计并实现一种考虑稳定性的自适应网格加密策略。问题的核心在于，如何在特定区域（由加密分数指示）进行网格加密的期望与为显式时间积分方案保持数值稳定性的需求之间取得平衡，同时避免全局时间步长的急剧减小（即时间步长崩溃问题）。其主导的物理和数值原理是牛顿第二定律（它导出了一维波动方程）和 Courant–Friedrichs–Lewy (CFL) 条件，后者决定了双曲型偏微分方程显式数值格式的稳定性。\n\n该算法分两个主要阶段进行：一个受避免崩溃准则约束的贪婪网格加密阶段，随后是根据最终网格配置选择可能的最大稳定时间步长。\n\n首先，我们定义问题中提供和推导的关键量。网格由索引为 $i$ 的单元组成，每个单元具有给定的长度 $h_i$、取决于材料的波传播速度 $c_i$ 和一个无量纲的加密分数 $s_i$。\n\n每个单元的局部时间尺度 $\\tau_i$ 定义为波穿过该单元所需的时间：\n$$\n\\tau_i = \\frac{h_i}{c_i}\n$$\n这个量是基础性的，因为它代表了该单元内最快物理现象的特征时间。\n\n像本文所考虑的这种显式时间积分方案的稳定性是由 Courant 数 $\\theta_i$ 控制的。对于一个全局时间步长 $\\Delta t$，局部 Courant 数为：\n$$\n\\theta_i = \\frac{c_i \\Delta t}{h_i} = \\frac{\\Delta t}{\\tau_i}\n$$\n稳定性的 CFL 条件要求对网格中的所有单元，Courant 数都必须被一个特定值 $\\theta_{\\max}$ 所限制。也就是说，对所有 $i$ 都有 $\\theta_i \\le \\theta_{\\max}$。为了找到允许的最大全局时间步长 $\\Delta t$，我们必须对每个单元都满足这个条件：\n$$\n\\Delta t \\le \\theta_{\\max} \\cdot \\frac{h_i}{c_i} \\implies \\Delta t \\le \\theta_{\\max} \\cdot \\tau_i \\quad \\forall i\n$$\n这意味着全局时间步长受具有最小局部时间尺度的单元所限制：\n$$\n\\Delta t \\le \\min_i (\\theta_{\\max} \\cdot \\tau_i) = \\theta_{\\max} \\cdot \\min_i (\\tau_i)\n$$\n为了最大化计算效率，我们选择可能的最大稳定时间步长，即：\n$$\n\\Delta t = \\theta_{\\max} \\cdot \\min_i(\\tau_i)\n$$\n网格加密涉及减小单元的长度，通常是将其减半（$h_i \\to h_i/2$）。此操作也会将局部时间尺度减半（$\\tau_i \\to \\tau_i/2$），这可能导致整个网格的最小时间尺度急剧减小，从而导致全局时间步长 $\\Delta t$ 的崩溃。为了防止这种情况，该问题引入了一个基于崩溃比率 $r$ 的避免崩溃约束：\n$$\nr = \\frac{\\min_i \\tau_i}{\\operatorname{median}_i \\tau_i}\n$$\n该比率衡量了最小时间尺度相对于网格中位时间尺度的大小。一个非常小的 $r$ 值表明，一个或少数几个单元施加了比网格主体部分严格得多的时间步长约束。算法必须确保任何加密操作都不会导致该比率降至给定阈值 $\\beta$ 以下。\n\n网格加密策略被实现为一个贪婪算法：\n1.  **初始化**：我们从单元长度 $[h_i]$、波速 $[c_i]$ 和加密分数 $[s_i]$ 的初始数组开始，同时还有参数 $\\theta_{\\max}$、$\\beta$ 和加密预算 $B$。我们还将一个用于记录已加密单元的计数器 $n_{ref}$ 初始化为 0，并使用一个集合来跟踪已经加密的单元索引。\n\n2.  **候选排序**：按加密分数 $s_i$ 的降序来考虑对单元进行加密。这构成了算法的贪婪特性，即优先处理被认为最需要加密的单元。\n\n3.  **迭代加密**：算法遍历已排序的候选单元列表。对于每个候选单元 $j$：\n    a. 我们检查预算是否 $B > 0$ 并且单元 $j$ 尚未被加密。\n    b. 如果是，我们执行*尝试性加密*。创建一个网格单元长度的临时副本，其中 $h_j$ 被替换为 $h_j/2$。\n    c. 使用这个尝试性的网格，我们重新计算局部时间尺度数组 $[\\tau_i]$，然后计算预期的崩溃比率 $r_{new}$。\n    d. 仅当得到的崩溃比率满足约束 $r_{new} \\ge \\beta$ 时，这个尝试性加密才被*接受*。\n    e. 如果加密被接受，对 $h_j$ 的更改将永久生效，预算 $B$ 减 1，已加密单元计数 $n_{ref}$ 加 1，并将索引 $j$ 记录为已加密。\n    f. 如果加密被拒绝（因为 $r_{new}  \\beta$），单元长度 $h_j$ 将恢复到其先前的值，算法继续处理下一个候选单元。\n\n4.  **终止**：当预算 $B$ 耗尽或所有候选单元都已被考虑时，加密过程终止。\n\n5.  **最终计算**：加密阶段结束后，确定最终的单元长度集合 $[h_i]$。\n    a. 计算最终的局部时间尺度 $[\\tau_i = h_i/c_i]$。\n    b. 计算最终的稳定时间步长为 $\\Delta t = \\theta_{\\max} \\cdot \\min_i(\\tau_i)$。\n    c. 计算最终的崩溃比率为 $r = \\min_i(\\tau_i) / \\operatorname{median}_i(\\tau_i)$。\n    d. 记录成功的加密总数 $n_{ref}$。\n\n这个过程确保了加密被策略性地应用，在需要的地方提高网格分辨率，同时避免崩溃的约束确保了模拟的数值稳定性不会受到不当损害。每个测试用例的最终输出是计算出的 $\\Delta t$、最终的崩溃比率 $r$ 和已加密单元的总数 $n_{ref}$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a stability-aware mesh refinement strategy for 1D linear elastodynamics.\n    \"\"\"\n    \n    test_cases = [\n        # Test case A (happy path)\n        {\n            \"h\": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n            \"c\": [200.0, 300.0, 400.0, 250.0, 350.0, 150.0],\n            \"s\": [0.1, 0.9, 0.8, 0.2, 0.7, 0.3],\n            \"theta_max\": 0.9,\n            \"beta\": 0.4,\n            \"B\": 2,\n        },\n        # Test case B (boundary: zero budget)\n        {\n            \"h\": [2.0, 0.5, 1.0, 1.5],\n            \"c\": [300.0, 600.0, 200.0, 400.0],\n            \"s\": [0.5, 0.7, 0.1, 0.2],\n            \"theta_max\": 0.95,\n            \"beta\": 0.5,\n            \"B\": 0,\n        },\n        # Test case C (edge: aggressive score, strict ratio)\n        {\n            \"h\": [1.0, 1.0, 1.0, 1.0, 1.0],\n            \"c\": [500.0, 100.0, 100.0, 100.0, 100.0],\n            \"s\": [1.0, 0.2, 0.2, 0.2, 0.2],\n            \"theta_max\": 0.9,\n            \"beta\": 0.3,\n            \"B\": 1,\n        },\n        # Test case D (edge: multiple refinements accepted)\n        {\n            \"h\": [0.8, 0.8, 0.8, 0.8],\n            \"c\": [100.0, 110.0, 90.0, 95.0],\n            \"s\": [0.5, 0.6, 0.9, 0.4],\n            \"theta_max\": 0.85,\n            \"beta\": 0.5,\n            \"B\": 3,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        h_initial = np.array(case[\"h\"], dtype=float)\n        c = np.array(case[\"c\"], dtype=float)\n        s = np.array(case[\"s\"], dtype=float)\n        theta_max = case[\"theta_max\"]\n        beta = case[\"beta\"]\n        budget = case[\"B\"]\n        \n        h_current = np.copy(h_initial)\n        \n        # Create a list of candidates (index, score)\n        candidates = sorted(enumerate(s), key=lambda x: x[1], reverse=True)\n        \n        refined_indices = set()\n        refined_count = 0\n        \n        for idx, score in candidates:\n            if budget == 0:\n                break\n            \n            if idx not in refined_indices:\n                # Tentatively refine the cell\n                h_tentative = np.copy(h_current)\n                h_tentative[idx] /= 2.0\n                \n                # Recompute tau and the collapse ratio r\n                tau_tentative = h_tentative / c\n                min_tau = np.min(tau_tentative)\n                median_tau = np.median(tau_tentative)\n\n                if median_tau == 0:\n                    r_tentative = 0.0\n                else:\n                    r_tentative = min_tau / median_tau\n                \n                # Check if the refinement is acceptable\n                if r_tentative >= beta:\n                    # Accept the refinement\n                    h_current = h_tentative\n                    budget -= 1\n                    refined_count += 1\n                    refined_indices.add(idx)\n\n        # After refinement loop, perform final calculations\n        final_tau = h_current / c\n        min_final_tau = np.min(final_tau)\n        \n        # Calculate final delta_t\n        delta_t = theta_max * min_final_tau\n        \n        # Calculate final collapse ratio r\n        median_final_tau = np.median(final_tau)\n        if median_final_tau == 0:\n            final_r = 0.0\n        else:\n            final_r = min_final_tau / median_final_tau\n            \n        # Store results for this test case\n        results.append([delta_t, final_r, refined_count])\n\n    # Format the final output string\n    formatted_sublists = []\n    for dt, r, nref in results:\n        sublist_str = f\"[{dt:.6f},{r:.6f},{nref}]\"\n        formatted_sublists.append(sublist_str)\n    \n    final_output = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3562397"}]}