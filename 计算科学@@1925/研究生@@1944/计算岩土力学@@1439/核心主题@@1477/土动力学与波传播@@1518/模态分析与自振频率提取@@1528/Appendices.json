{"hands_on_practices": [{"introduction": "在进行复杂的数值模拟之前，理解模态分析的数学基础至关重要。本练习将引导你从第一性原理出发，推导模态坐标的表达式，这是将系统响应分解为其基本振动模式的基石。通过完成这一推导，你将加深对质量正交性和模态归一化等核心概念的理解，并掌握如何将物理位移投影到模态空间中。[@problem_id:3543998]", "problem": "考虑一个通过有限元法（FEM）离散化的线性弹性、均质土壤域的无阻尼、小应变自由振动。其半离散化的运动方程由以下二阶常微分方程给出\n$$\nM \\ddot{u}(t) + K u(t) = 0,\n$$\n其中 $M \\in \\mathbb{R}^{n \\times n}$ 是对称正定质量矩阵，$K \\in \\mathbb{R}^{n \\times n}$ 是对称正定刚度矩阵，$u(t) \\in \\mathbb{R}^{n}$ 是节点位移向量。相关的自由振动广义特征值问题为\n$$\nK \\psi_i = \\omega_i^{2} M \\psi_i,\n$$\n其特征值 $\\omega_i^{2}$ 为正实数，特征向量 $\\psi_i \\in \\mathbb{R}^{n}$ 为实向量，由数值特征求解器返回，并具有任意非零缩放。\n\n你需要将每个计算出的振型进行单位广义质量归一化，通过强制执行\n$$\n\\phi_i^{T} M \\phi_i = 1,\n$$\n其中 $\\phi_i = \\alpha_i \\psi_i$，$\\alpha_i \\neq 0$ 为某个标量。对于一个由质量归一化振型进行截断振型叠加表示的位移场，\n$$\nu(t) = \\sum_{j=1}^{m} \\phi_j \\, q_j(t),\n$$\n请从第一性原理出发，推导振型坐标 $q_i(t)$ 关于 $u(t)$、$M$ 和未归一化振型 $\\psi_i$ 的表达式。你的推导必须从运动方程和质量归一化的定义开始，不得引入任何未经证明的简化公式。\n\n请以单个封闭形式的解析表达式给出 $q_i(t)$ 关于 $u(t)$、$M$ 和 $\\psi_i$ 的最终答案。无需进行数值计算，也无需四舍五入。最终表达式中不要包含物理单位。", "solution": "该问题已经过验证，被认为是可靠、适定且客观的。它基于线性代数和计算力学的基本原理，特别是离散系统的振型分析。所有必要信息均已提供，目标明确。我们可以开始推导。\n\n我们的目标是推导振型坐标 $q_i(t)$ 关于位移向量 $u(t)$、质量矩阵 $M$ 和未归一化的特征向量（振型）$\\psi_i$ 的表达式。\n\n推导从给定的位移场振型展开式开始，该展开式将总位移表示为质量归一化振型 $\\phi_j$ 的线性组合：\n$$\nu(t) = \\sum_{j=1}^{m} \\phi_j \\, q_j(t)\n$$\n为了分离出特定的振型坐标 $q_i(t)$，我们将利用特征向量的正交性。广义特征值问题 $K \\psi_i = \\omega_i^2 M \\psi_i$ 的特征向量 $\\psi_i$ 相对于刚度矩阵 $K$ 和质量矩阵 $M$ 都是正交的。这里的关键是质量正交性（或 M-正交性）。对于任意两个对应不同特征值（$\\omega_i^2 \\neq \\omega_j^2$）的特征向量 $\\psi_i$ 和 $\\psi_j$，我们有：\n$$\n\\psi_i^T M \\psi_j = 0 \\quad (\\text{for } i \\neq j)\n$$\n这个性质直接源于特征值问题本身。给定 $K \\psi_i = \\omega_i^2 M \\psi_i$ 和 $K \\psi_j = \\omega_j^2 M \\psi_j$，我们将第一个方程左乘 $\\psi_j^T$ 得到 $\\psi_j^T K \\psi_i = \\omega_i^2 \\psi_j^T M \\psi_i$。对第二个方程取转置并利用 $K$ 和 $M$ 的对称性（$K=K^T, M=M^T$），我们得到 $\\psi_j^T K \\psi_i = \\omega_j^2 \\psi_j^T M \\psi_i$。令这两个表达式相等，得到 $(\\omega_i^2 - \\omega_j^2)\\psi_j^T M \\psi_i = 0$。由于 $\\omega_i^2 \\neq \\omega_j^2$，因此必然有 $\\psi_j^T M \\psi_i = 0$。对于存在重根特征值的情况，可以选择相应的特征向量构成一个 M-正交集。\n\n质量归一化的振型 $\\phi_i$ 通过一个缩放因子 $\\alpha_i$ 与未归一化的特征向量 $\\psi_i$ 相关联，即 $\\phi_i = \\alpha_i \\psi_i$。因此，M-正交性对于归一化振型也成立：当 $i \\neq j$ 时，$\\phi_i^T M \\phi_j = (\\alpha_i \\psi_i)^T M (\\alpha_j \\psi_j) = \\alpha_i \\alpha_j (\\psi_i^T M \\psi_j) = 0$。\n\n此外，问题要求振型被归一化为单位广义质量，该条件定义为：\n$$\n\\phi_i^T M \\phi_i = 1\n$$\n结合正交性和归一化条件，我们得到了归一化振型集合 $\\{\\phi_i\\}$ 的 M-正交归一性：\n$$\n\\phi_i^T M \\phi_j = \\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是克罗内克（Kronecker）δ函数，当 $i=j$ 时等于1，当 $i \\neq j$ 时等于0。\n\n现在我们可以利用这种 M-正交归一性来分离 $q_i(t)$。我们将 $u(t)$ 的振型展开方程两边同时左乘 $\\phi_i^T M$：\n$$\n\\phi_i^T M u(t) = \\phi_i^T M \\left( \\sum_{j=1}^{m} \\phi_j \\, q_j(t) \\right)\n$$\n利用矩阵乘法的分配律，我们将左乘项移入求和号内：\n$$\n\\phi_i^T M u(t) = \\sum_{j=1}^{m} (\\phi_i^T M \\phi_j) q_j(t)\n$$\n代入 M-正交归一性条件 $\\phi_i^T M \\phi_j = \\delta_{ij}$：\n$$\n\\phi_i^T M u(t) = \\sum_{j=1}^{m} \\delta_{ij} \\, q_j(t)\n$$\n右侧的求和坍缩了，因为克罗内克 δ 函数 $\\delta_{ij}$ 在所有项中都为零，除了索引 $j$ 等于 $i$ 的那一项。这只留下了一项：\n$$\n\\phi_i^T M u(t) = q_i(t)\n$$\n这提供了一个用归一化振型 $\\phi_i$ 表示的振型坐标 $q_i(t)$ 的表达式。然而，问题要求最终表达式用未归一化的特征向量 $\\psi_i$ 来表示。为了实现这一点，我们首先从归一化条件中确定缩放因子 $\\alpha_i$。\n$$\n\\phi_i^T M \\phi_i = 1\n$$\n代入 $\\phi_i = \\alpha_i \\psi_i$：\n$$\n(\\alpha_i \\psi_i)^T M (\\alpha_i \\psi_i) = 1\n$$\n由于 $\\alpha_i$ 是一个标量，我们可以将其提出：\n$$\n\\alpha_i^2 (\\psi_i^T M \\psi_i) = 1\n$$\n项 $\\psi_i^T M \\psi_i$ 是一个标量，代表未归一化振型 $i$ 的广义质量。由于 $M$ 是正定的，且 $\\psi_i$ 是非零向量，该项是一个正实数。求解 $\\alpha_i$（并按惯例取正根）得到：\n$$\n\\alpha_i = \\frac{1}{\\sqrt{\\psi_i^T M \\psi_i}}\n$$\n现在，将这个 $\\alpha_i$ 的表达式代回到关系式 $\\phi_i = \\alpha_i \\psi_i$ 中：\n$$\n\\phi_i = \\frac{\\psi_i}{\\sqrt{\\psi_i^T M \\psi_i}}\n$$\n最后，我们将这个 $\\phi_i$ 的表达式代入我们得到的 $q_i(t)$ 的结果中：\n$$\nq_i(t) = \\phi_i^T M u(t) = \\left( \\frac{\\psi_i}{\\sqrt{\\psi_i^T M \\psi_i}} \\right)^T M u(t)\n$$\n分母是一个标量，可以提出来。分子中的转置运算只作用于向量 $\\psi_i$：\n$$\nq_i(t) = \\frac{1}{\\sqrt{\\psi_i^T M \\psi_i}} \\psi_i^T M u(t)\n$$\n这可以写成一个单独的分数。分子 $\\psi_i^T M u(t)$ 是一个标量。这就是用指定量表示的振型坐标 $q_i(t)$ 的最终表达式。", "answer": "$$\n\\boxed{\\frac{\\psi_i^T M u(t)}{\\sqrt{\\psi_i^T M \\psi_i}}}\n$$", "id": "3543998"}, {"introduction": "在掌握了理论基础后，我们将进入计算实践的领域。本练习旨在探讨有限元方法中一个基础性选择——质量矩阵的构造方法（一致质量矩阵与集中质量矩阵）——如何系统性地影响计算出的自振频率。通过这个动手编程练习，你将亲身体验不同数值模型对模态分析结果准确性的影响，并理解其背后的物理和数学原理。[@problem_id:3543947]", "problem": "您的任务是开发一个完整的、可运行的程序，用于比较一维地震场地响应模型的一致质量矩阵与集总质量矩阵，并量化自振圆频率的系统性偏差以及对振型正交关系的符合程度。该物理系统是一个竖向离散的、小应变剪切梁模型，用于表示一个高度为 $H$ 的土柱，其侧向位移为 $u(z,t)$，剪切模量为 $G(z)$，质量密度为 $\\rho(z)$。其控制方程源自牛顿第二定律和线性弹性胡克定律，为 $\\rho(z)\\,\\partial^2 u/\\partial t^2=\\partial/\\partial z\\left(G(z)\\,\\partial u/\\partial z\\right)$，其中 $z\\in(0,H)$，并满足 $u(0,t)=0$ (固定基底) 和 $G(z)\\,\\partial u/\\partial z\\vert_{z=H}=0$ (自由地表) 的边界条件。使用有限元法，通过线性形函数和单位横截面积对域进行离散，以得到对称的全局刚度矩阵 $K$ 和全局质量矩阵 $M$。考虑两种质量矩阵形式：通过对每个单元上的动能进行精确积分得到的一致质量矩阵，以及通过将单元质量贡献对角化分配到节点上得到的集总质量矩阵。\n\n定义广义特征值问题 $K\\,\\phi=\\omega^2\\,M\\,\\phi$，其解可得到振型向量 $\\phi$ 和自振圆频率 $\\omega$ (单位为 $\\mathrm{rad/s}$)。对于每种质量矩阵形式，在给定的边界条件下，计算前三个自振圆频率及其对应的振型向量。将第 $i$ 个自振圆频率的分数偏差定义为 $\\beta_i=\\left(\\omega_i^{\\mathrm{lumped}}-\\omega_i^{\\mathrm{consistent}}\\right)/\\omega_i^{\\mathrm{consistent}}$，以小数形式表示。为评估正交性，缩放每个振型向量 $\\phi_i$ 以满足 $\\phi_i^T M\\,\\phi_i=1$，并计算矩阵 $S=\\Phi^T M\\,\\Phi$，其中 $\\Phi$ 是以缩放后的振型向量为列构成的矩阵。报告 $S$ 的最大绝对非对角元素，即 $m=\\max_{i\\neq j}\\left|S_{ij}\\right|$，作为偏离 $M$-正交性的度量。对一致质量和集总质量两种形式分别进行此评估。\n\n您的程序必须从第一性原理出发组装 $K$ 和 $M$，通过移除基底自由度来施加固定基底边界条件，求解广义对称特征值问题，按 $\\omega$ 升序对振型进行排序，并计算所需的度量指标。所有自振圆频率必须在内部以 $\\mathrm{rad/s}$ 为单位处理。分数偏差和正交性度量指标的输出是无单位的小数。\n\n使用以下参数集作为测试套件，沿 $z\\in[0,H]$ 划分等尺寸单元，横截面积为单位面积：\n\n- 测试用例 1 (均匀，理想情况): $H=30\\,\\mathrm{m}$，$G=80\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1800\\,\\mathrm{kg/m^3}$，$n=10$ 个单元。\n- 测试用例 2 (粗糙离散化边界): $H=30\\,\\mathrm{m}$，$G=80\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1800\\,\\mathrm{kg/m^3}$，$n=3$ 个单元。\n- 测试用例 3 (分层介质): $H=30\\,\\mathrm{m}$，顶层厚度 $10\\,\\mathrm{m}$，$G=40\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1700\\,\\mathrm{kg/m^3}$；底层厚度 $20\\,\\mathrm{m}$，$G=120\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1900\\,\\mathrm{kg/m^3}$，$n=30$ 个单元。\n- 测试用例 4 (精细离散化): $H=30\\,\\mathrm{m}$，$G=80\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1800\\,\\mathrm{kg/m^3}$，$n=200$ 个单元。\n\n对于每个测试用例，计算：\n- 列表 $[\\beta_1,\\beta_2,\\beta_3]$。\n- 一致质量形式的标量 $m_{\\mathrm{consistent}}$。\n- 集总质量形式的标量 $m_{\\mathrm{lumped}}$。\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是一个格式为 $[[\\beta_1,\\beta_2,\\beta_3],m_{\\mathrm{consistent}},m_{\\mathrm{lumped}}]$ 的列表。例如，输出格式必须严格类似于 $[[\\cdot,\\cdot,\\cdot],\\cdot,\\cdot]$，并将四个测试用例的结果聚合为单行上的一个方括号列表。", "solution": "该问题要求开发一个程序，用于比较一维土柱剪切梁模型中，由一致质量矩阵和集总质量矩阵两种形式推导出的振型特性。分析过程涉及有限元离散化、求解广义特征值问题以及计算用于比较的特定度量指标。\n\n**1. 控制方程与弱形式**\n\n物理系统是一个高度为 $H$ 的土柱，模型为剪切梁。其侧向位移 $u(z,t)$ 的控制偏微分方程如下：\n$$ \\rho(z)\\,\\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial}{\\partial z}\\left(G(z)\\,\\frac{\\partial u}{\\partial z}\\right) \\quad \\text{for } z \\in (0, H) $$\n其中 $\\rho(z)$ 是质量密度，$G(z)$ 是剪切模量，$z$ 是竖向坐标。边界条件为固定基底 $u(0,t)=0$ 和自由地表 $G(H)\\,\\frac{\\partial u}{\\partial z}\\vert_{z=H}=0$。\n\n假设谐波运动，我们使用分离变量法，$u(z,t) = \\phi(z)e^{i\\omega t}$，其中 $\\phi(z)$ 是振型函数，$\\omega$ 是自振圆频率。将其代入控制方程，得到关于振型函数的常微分方程：\n$$ \\frac{d}{dz}\\left(G(z)\\frac{d\\phi}{dz}\\right) + \\omega^2\\rho(z)\\phi(z) = 0 $$\n为了得到适用于有限元法的弱形式，我们将方程乘以一个测试函数 $v(z)$（其中 $v(0)=0$ 以满足本质边界条件），并在域 $[0, H]$ 上积分：\n$$ \\int_0^H v(z) \\left[ \\frac{d}{dz}\\left(G(z)\\frac{d\\phi}{dz}\\right) + \\omega^2\\rho(z)\\phi(z) \\right] dz = 0 $$\n对刚度项进行分部积分得到：\n$$ \\left[v(z)G(z)\\frac{d\\phi}{dz}\\right]_0^H - \\int_0^H G(z)\\frac{dv}{dz}\\frac{d\\phi}{dz}dz + \\omega^2\\int_0^H \\rho(z)v(z)\\phi(z)dz = 0 $$\n边界项消失，因为 $v(0)=0$ 且地表的自然边界条件为 $G(H)\\frac{d\\phi}{dz}\\vert_{z=H}=0$。这导出了特征值问题的弱形式：\n$$ \\int_0^H G(z)\\frac{dv}{dz}\\frac{d\\phi}{dz}dz = \\omega^2\\int_0^H \\rho(z)v(z)\\phi(z)dz $$\n\n**2. 有限元离散化**\n\n我们将域离散为 $n$ 个具有线性形函数的一维单元。对于一个长度为 $L_e$、节点为1和2的单元 $e$，位移场近似为 $u^e(z) = N_1(z)d_1^e + N_2(z)d_2^e = \\mathbf{N}(z)\\mathbf{d}^e$。对于单位横截面积 ($A=1$)，单元刚度矩阵 $k^e$ 和单元质量矩阵 $m^e$ 从弱形式推导如下：\n$$ k^e_{ij} = \\int_{L_e} G_e \\frac{dN_i}{dz}\\frac{dN_j}{dz} dz $$\n$$ m^e_{ij} = \\int_{L_e} \\rho_e N_i N_j dz $$\n假设单元内的属性 $G_e$ 和 $\\rho_e$ 为常数，对线性形函数进行积分可得到标准的单元矩阵。\n\n单元刚度矩阵为：\n$$ k^e = \\frac{G_e}{L_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n单元一致质量矩阵 $m_C^e$ 是通过对动能项进行精确积分得到的：\n$$ m_C^e = \\frac{\\rho_e L_e}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix} $$\n单元集总质量矩阵 $m_L^e$ 是通过将质量集中到节点上得到的，通常做法是将一致质量矩阵的各行求和，并将结果置于对角线上。这等效于将单元质量的一半分配给每个节点：\n$$ m_L^e = \\frac{\\rho_e L_e}{2} \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} $$\n\n**3. 全局系统与特征值问题**\n\n全局刚度矩阵 $K$ 和质量矩阵 $M_C$ (一致) 与 $M_L$ (集总) 是通过将所有 $n$ 个单元矩阵的贡献相加组装而成的。得到的方程组即为广义特征值问题：\n$$ K\\,\\phi = \\omega^2 M\\,\\phi $$\n该系统有 $n+1$ 个自由度 (节点 $0, 1, \\dots, n$)。固定基底边界条件 $u(0)=0$ 通过静态凝聚法施加，这等效于从全局矩阵 $K$ 和 $M$ 中移除第一行和第一列。这将问题简化为一个 $n \\times n$ 的系统。\n\n**4. 求解与后处理**\n\n这个简化的 $n \\times n$ 广义对称特征值问题，针对两种质量形式，使用数值特征求解器（例如 `scipy.linalg.eigh`）进行求解。求解得到 $n$ 个特征值 $\\lambda_i = \\omega_i^2$ 和对应的特征向量 $\\phi'_i$。自振圆频率为 $\\omega_i = \\sqrt{\\lambda_i}$。求解器返回按频率升序排列的振型。通过在前面添加一个零来代表固定基底的位移，恢复出大小为 $(n+1) \\times 1$ 的完整特征向量 $\\phi_i$。\n\n然后计算所需的度量指标：\n- **分数偏差**：前三个自振频率的系统性偏差计算如下：\n$$ \\beta_i = \\frac{\\omega_i^{\\mathrm{lumped}} - \\omega_i^{\\mathrm{consistent}}}{\\omega_i^{\\mathrm{consistent}}} \\quad \\text{for } i \\in \\{1, 2, 3\\} $$\n理论上已经证实，对于给定的网格，一致质量形式倾向于高估真实的连续体频率，而集总质量形式倾向于低估它们。因此，我们预期 $\\omega_i^{\\mathrm{lumped}}  \\omega_i^{\\mathrm{consistent}}$，这将导致 $\\beta_i$ 为负值。\n\n- **正交性检验**：对于每种质量形式（我们使用 $M$ 和 $\\phi_i$ 作为通用占位符），前三个振型向量被缩放以满足 $M$-正交归一性，即 $\\phi_i^T M \\phi_j = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 delta。用于广义问题的标准特征求解器通常返回的特征向量已经相对于简化后的质量矩阵进行了这种归一化。这种归一化可传递到整个系统。我们构建一个矩阵 $\\Phi = [\\phi_1, \\phi_2, \\phi_3]$，其列为前三个缩放后的振型向量。然后我们计算检验矩阵 $S = \\Phi^T M \\Phi$。理想情况下，$S$ 应该是一个 $3 \\times 3$ 的单位矩阵。度量指标 $m$ 量化了与完美正交性的数值偏差：\n$$ m = \\max_{i\\neq j}\\left|S_{ij}\\right| $$\n此计算分别针对一致质量 ($m_{\\mathrm{consistent}}$) 和集总质量 ($m_{\\mathrm{lumped}}$) 形式进行。\n\n程序实现了这整个过程，遍历所提供的测试用例，每个用例都有不同的离散化方案和材料属性（包括分层剖面）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: uniform, n=10\n        {'H': 30.0, 'n': 10, 'layers': [{'thickness': 30.0, 'G': 80e6, 'rho': 1800.0}]},\n        # Case 2: uniform, coarse n=3\n        {'H': 30.0, 'n': 3, 'layers': [{'thickness': 30.0, 'G': 80e6, 'rho': 1800.0}]},\n        # Case 3: layered, n=30\n        {'H': 30.0, 'n': 30, 'layers': [\n            {'thickness': 20.0, 'G': 120e6, 'rho': 1900.0},  # Bottom layer\n            {'thickness': 10.0, 'G': 40e6, 'rho': 1700.0}   # Top layer\n        ]},\n        # Case 4: uniform, fine n=200\n        {'H': 30.0, 'n': 200, 'layers': [{'thickness': 30.0, 'G': 80e6, 'rho': 1800.0}]}\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(run_analysis(case))\n\n    # Format the results for printing as specified.\n    # The output from each case is a list like [[b1, b2, b3], m_c, m_l]\n    # We need to format it into a string representation inside a larger list.\n    formatted_results = []\n    for res in results:\n        betas_str = f\"[{res[0][0]:.8f},{res[0][1]:.8f},{res[0][2]:.8f}]\"\n        m_c_str = f\"{res[1]:.8e}\"\n        m_l_str = f\"{res[2]:.8e}\"\n        formatted_results.append(f\"[{betas_str},{m_c_str},{m_l_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_analysis(params):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    \"\"\"\n    H = params['H']\n    n_elements = params['n']\n    layers = params['layers']\n    \n    # Create property functions G(z) and rho(z) from layer data\n    def get_properties(z):\n        current_depth = 0.0\n        for layer in layers:\n            if z = current_depth + layer['thickness'] + 1e-9:\n                return layer['G'], layer['rho']\n            current_depth += layer['thickness']\n        # Fallback for z=H which might fall on the boundary\n        return layers[-1]['G'], layers[-1]['rho']\n\n    # 1. Assemble matrices\n    K, M_C, M_L = assemble_matrices(H, n_elements, get_properties)\n    \n    # 2. Solve for consistent mass formulation\n    omegas_C, eigvecs_C = solve_eigenproblem(K, M_C)\n    \n    # 3. Solve for lumped mass formulation\n    omegas_L, eigvecs_L = solve_eigenproblem(K, M_L)\n    \n    # 4. Compute metrics\n    # Take first 3 modes for calculations\n    num_modes = 3\n\n    # Fractional bias\n    betas = (omegas_L[:num_modes] - omegas_C[:num_modes]) / omegas_C[:num_modes]\n    \n    # Orthogonality check for consistent mass\n    Phi_C = eigvecs_C[:, :num_modes]\n    S_C = Phi_C.T @ M_C @ Phi_C\n    np.fill_diagonal(S_C, 0.0)\n    m_consistent = np.max(np.abs(S_C))\n\n    # Orthogonality check for lumped mass\n    Phi_L = eigvecs_L[:, :num_modes]\n    S_L = Phi_L.T @ M_L @ Phi_L\n    np.fill_diagonal(S_L, 0.0)\n    m_lumped = np.max(np.abs(S_L))\n\n    return [betas.tolist(), m_consistent, m_lumped]\n\ndef assemble_matrices(H, n_elements, get_properties):\n    \"\"\"\n    Assembles global stiffness and mass matrices for a 1D shear beam.\n    \"\"\"\n    n_nodes = n_elements + 1\n    L_e = H / n_elements  # Element length\n    \n    K = np.zeros((n_nodes, n_nodes))\n    M_C = np.zeros((n_nodes, n_nodes))\n    M_L = np.zeros((n_nodes, n_nodes))\n    \n    # Cross-sectional area is 1\n    A = 1.0\n\n    for e in range(n_elements):\n        # Nodes connected by element e\n        i, j = e, e + 1\n        \n        # Get material properties at the element's midpoint\n        z_mid = (e + 0.5) * L_e\n        G_e, rho_e = get_properties(z_mid)\n        \n        # Element stiffness matrix\n        k_e = (G_e * A / L_e) * np.array([[1, -1], [-1, 1]])\n        \n        # Element consistent mass matrix\n        m_c_e = (rho_e * A * L_e / 6) * np.array([[2, 1], [1, 2]])\n        \n        # Element lumped mass matrix\n        m_l_e = (rho_e * A * L_e / 2) * np.array([[1, 0], [0, 1]])\n        \n        # Assemble into global matrices\n        K[i:j+1, i:j+1] += k_e\n        M_C[i:j+1, i:j+1] += m_c_e\n        M_L[i:j+1, i:j+1] += m_l_e\n        \n    return K, M_C, M_L\n\ndef solve_eigenproblem(K, M):\n    \"\"\"\n    Applies boundary conditions and solves the generalized eigenvalue problem.\n    \"\"\"\n    n_nodes = K.shape[0]\n    \n    # Apply fixed-base boundary condition u(0)=0 by removing the first DOF\n    K_reduced = K[1:, 1:]\n    M_reduced = M[1:, 1:]\n    \n    # Solve the generalized eigenvalue problem: K' * v = w * M' * v\n    # eigh returns eigenvalues in ascending order\n    eigvals, eigvecs_reduced = eigh(K_reduced, M_reduced)\n    \n    # Frequencies omega = sqrt(eigenvalues)\n    omegas = np.sqrt(eigvals)\n    \n    # Reconstruct full eigenvectors (size n_nodes) by prepending zero for the fixed base\n    n_modes = eigvecs_reduced.shape[1]\n    eigvecs_full = np.zeros((n_nodes, n_modes))\n    eigvecs_full[1:, :] = eigvecs_reduced\n    \n    return omegas, eigvecs_full\n\nsolve()\n```", "id": "3543947"}, {"introduction": "最后的这个练习将运用你所学的技能，解决岩土工程中的一个典型问题：分析层状土柱的动力响应。你将研究材料的非均质性如何改变结构的自振频率和振型，并学习使用“模态保证准则”（MAC）来定量比较复杂土层与简化均质模型的动力行为差异。这项练习将数值分析与物理直觉和工程判断紧密地联系在一起。[@problem_id:3543944]", "problem": "您的任务是推导、实现并验证一个计算程序，用于提取一个进行侧向剪切振动的垂直分层土柱的前三个自然频率和相应的振型。该土柱使用一维空间中的线性二节点单元，通过有限元法 (FEM) 进行建模。该土柱底部固定，顶部自由。您的推导和实现必须从基本原理和既定事实出发，而不是使用简化公式。\n\n从牛顿第二定律开始，该定律指出，合力等于质量乘以加速度。对于一个具有侧向位移场 $u(z,t)$ 的一维剪切变形柱，剪应力 $\\tau(z,t)$ 遵循 $\\tau(z,t) = G(z) \\, \\partial u / \\partial z$，其中 $G(z)$ 是剪切模量剖面。质量密度为 $\\rho(z)$，横截面积为 $A$ (假定为常数)。侧向线性动量基本平衡导出了一个控制方程，该方程通过材料属性 $G(z)$ 和 $\\rho(z)$ 将惯性、应力和变形联系起来。\n\n将总长度为 $L$ 的土柱离散化为 $N$ 个节点（以及 $N-1$ 个单元），节点间距均匀，并使用线性形函数和一致质量公式构建单元刚度和质量贡献。在考虑底部固定边界的情况下，组装总体刚度矩阵和总体质量矩阵。寻求谐波解并执行模态分析，以计算前三个自然频率（单位：赫兹）和相应的振型。相对于总体质量矩阵对振型进行归一化。\n\n为了分离分层如何影响模态特性，对于每个分层配置，还需构建一个具有相同总长度 $L$、相同节点数 $N$ 的均质参考柱，并满足以下两个等效条件：\n- 静力剪切刚度等效：均质剪切模量 $G_{\\mathrm{eq}}$ 必须满足 $L / (G_{\\mathrm{eq}} A) = \\sum_{i} \\ell_i / (G_i A)$，即 $G_{\\mathrm{eq}} = \\dfrac{L}{\\sum_i \\ell_i / G_i}$，其中 $\\ell_i$ 和 $G_i$ 分别是第 $i$ 层的厚度和剪切模量。\n- 质量等效：均质密度 $\\rho_{\\mathrm{eq}}$ 必须满足 $\\rho_{\\mathrm{eq}} = \\dfrac{1}{L} \\sum_i \\ell_i \\rho_i$，其中 $\\rho_i$ 是第 $i$ 层的密度。\n\n对于下面描述的每个测试用例，计算：\n1. 分层柱的前三个自然频率，单位为赫兹，四舍五入到小数点后四位。\n2. 其均质参考柱的前三个自然频率，单位为赫兹，四舍五入到小数点后四位。\n3. 使用模态置信准则 (MAC)，定量度量分层相对于均质参考柱如何改变前三个振型。将两个振型之间的 MAC 定义为从归一化向量计算出的一个在 $[0,1]$ 区间内的标量，并报告每个 MAC 值，四舍五入到小数点后四位。接近 1 的值表示振型非常相似；接近 0 的值表示差异很大。\n\n构建您的程序以解决由每个案例组装的总体矩阵产生的广义特征值问题。对振型使用质量归一化，对 MAC 计算使用欧几里得归一化。不允许外部输入；程序必须实现以下测试套件。\n\n参数值测试套件（所有长度单位为米，模量单位为帕斯卡，密度单位为千克/立方米）：\n- 案例1（均质基准，理想情况）：$L = 30$, $A = 10$, $N = 7$ 个节点，一个层，参数为 $(\\ell_1 = 30, G_1 = 80 \\times 10^6, \\rho_1 = 1800)$。\n- 案例2（双层对比）：$L = 30$, $A = 10$, $N = 7$ 个节点，两个层：底层 $(\\ell_1 = 20, G_1 = 120 \\times 10^6, \\rho_1 = 1900)$ 和顶层 $(\\ell_2 = 10, G_2 = 40 \\times 10^6, \\rho_2 = 1600)$。\n- 案例3（边界情况，薄软顶层）：$L = 30$, $A = 10$, $N = 7$ 个节点，两个层：底层 $(\\ell_1 = 29, G_1 = 100 \\times 10^6, \\rho_1 = 1800)$ 和顶层 $(\\ell_2 = 1, G_2 = 10 \\times 10^6, \\rho_2 = 1600)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个格式完全如下的嵌套列表：\n[[fL1,fL2,fL3],[fH1,fH2,fH3],[MAC1,MAC2,MAC3]]\n这里 [fL1,fL2,fL3] 是分层柱的前三个频率（赫兹），[fH1,fH2,fH3] 是均质参考柱的前三个频率（赫兹），而 [MAC1,MAC2,MAC3] 是前三对振型的 MAC 值。最终的聚合输出必须是：\n[[...case1...],[...case2...],[...case3...]]\n所有频率和 MAC 值都四舍五入到小数点后四位，并表示为十进制数（无百分号）。", "solution": "该问题要求推导并实现一个有限元法 (FEM) 程序，以确定一维剪切柱的自然频率和振型，并将分层柱与其均质等效柱进行比较。详细过程如下，从基本原理开始。\n\n### 步骤1：运动控制方程\n\n我们考虑一个总长度为 $L$、恒定横截面积为 $A$ 的垂直土柱，其剪切模量 $G(z)$ 和质量密度 $\\rho(z)$ 随空间变化，其中 $z$ 是从固定底座测量的垂直坐标。该柱发生侧向剪切变形，位移场由 $u(z,t)$ 给出。\n\n根据牛顿第二定律，作用在高度为 $dz$ 的微分单元上的合力必须等于其质量乘以加速度。惯性力为 $dF_{inertia} = (\\rho(z) A dz) \\frac{\\partial^2 u}{\\partial t^2}$。净剪力来自剪应力 $\\tau(z,t)$ 在单元高度上的变化：$dF_{shear} = (\\tau(z+dz) - \\tau(z))A \\approx \\frac{\\partial \\tau}{\\partial z} A dz$。将这些力相等以实现动态平衡，得到：\n$$ \\rho(z) A \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial \\tau}{\\partial z} A $$\n剪应力通过线性弹性本构律与剪应变 $\\gamma = \\frac{\\partial u}{\\partial z}$ 相关：$\\tau(z,t) = G(z) \\gamma(z,t) = G(z) \\frac{\\partial u}{\\partial z}$。将此代入平衡方程，得到剪切波传播的控制偏微分方程 (PDE)：\n$$ \\rho(z) \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial}{\\partial z} \\left( G(z) \\frac{\\partial u}{\\partial z} \\right) $$\n\n对于模态分析，我们寻求 $u(z, t) = \\phi(z) e^{i\\omega t}$ 形式的谐波解，其中 $\\phi(z)$ 是振型，$\\omega$ 是自然角频率。将此代入 PDE，得到不含时常微分方程：\n$$ -\\omega^2 \\rho(z) \\phi(z) = \\frac{d}{dz} \\left( G(z) \\frac{d\\phi}{dz} \\right) $$\n\n### 步骤2：弱形式与有限元公式\n\n我们使用伽辽金法求解此方程。我们将方程乘以一个试函数 $v(z)$ 并在域 $[0, L]$ 上积分：\n$$ \\int_{0}^{L} v(z) \\left[ \\frac{d}{dz} \\left( G(z) \\frac{d\\phi}{dz} \\right) + \\omega^2 \\rho(z) \\phi(z) \\right] dz = 0 $$\n对第一项应用分部积分法（以降低微分阶数）得到：\n$$ \\left[ v(z) G(z) \\frac{d\\phi}{dz} \\right]_0^L - \\int_{0}^{L} \\frac{dv}{dz} G(z) \\frac{d\\phi}{dz} dz + \\omega^2 \\int_{0}^{L} v(z) \\rho(z) \\phi(z) dz = 0 $$\n边界条件是底部固定 ($z=0$) 和顶部自由 ($z=L$) 。\n-   在固定底部，位移为零：$u(0,t)=0 \\implies \\phi(0)=0$。作为一个基本边界条件，试函数也必须为零：$v(0)=0$。\n-   在自由顶部，剪应力为零：$\\tau(L) = G(L) \\frac{d\\phi}{dz}\\big|_{z=L} = 0$。\n这些条件使得边界项 $\\left[ v G \\frac{d\\phi}{dz} \\right]_0^L$ 为零。得到的弱形式为：\n$$ \\int_{0}^{L} \\frac{dv}{dz} G(z) \\frac{d\\phi}{dz} dz = \\omega^2 \\int_{0}^{L} v(z) \\rho(z) \\phi(z) dz $$\n\n我们将域离散化为 $N-1$ 个线性二节点单元。在长度为 $h_e$ 的单元 $e$ 内，位移场 $\\phi_e(z')$ 使用线性形函数 $\\mathbf{N}(z') = [N_1(z'), N_2(z')]$ 和节点位移 $\\mathbf{d}_e = [\\phi_1, \\phi_2]^T$ 来近似：\n$\\phi_e(z') = \\mathbf{N}(z') \\mathbf{d}_e$，其中 $z'$ 是局部坐标 $z' \\in [0, h_e]$。\n形函数为 $N_1(z') = 1 - z'/h_e$ 和 $N_2(z') = z'/h_e$。应变近似为 $\\frac{d\\phi_e}{dz'} = \\mathbf{B} \\mathbf{d}_e$，其中 $\\mathbf{B} = \\frac{d\\mathbf{N}}{dz'} = [-1/h_e, 1/h_e]$。\n\n将这些近似代入单个单元的弱形式中（并对任意 $\\mathbf{c}$ 使用 $v_e = \\mathbf{N} \\mathbf{c}$），得到单元刚度矩阵 $\\mathbf{k}_e$ 和一致质量矩阵 $\\mathbf{m}_e$：\n$$ \\mathbf{k}_e = \\int_{V_e} \\mathbf{B}^T G_e \\mathbf{B} \\, dV = A \\int_0^{h_e} \\mathbf{B}^T G_e \\mathbf{B} \\, dz' = \\frac{G_e A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n$$ \\mathbf{m}_e = \\int_{V_e} \\mathbf{N}^T \\rho_e \\mathbf{N} \\, dV = A \\int_0^{h_e} \\mathbf{N}^T \\rho_e \\mathbf{N} \\, dz' = \\frac{\\rho_e A h_e}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix} $$\n其中 $G_e$ 和 $\\rho_e$ 是单元 $e$ 上的恒定剪切模量和密度。\n\n### 步骤3：组装与特征值问题求解\n\n单元矩阵被组装成大小为 $N \\times N$ 的总体矩阵 $\\mathbf{K}_{\\text{global}}$ 和 $\\mathbf{M}_{\\text{global}}$。通过从两个总体矩阵中移除第一行和第一列来施加底部固定条件 $\\phi(0) = 0$（对应于节点0）。这得到了对应于自由自由度的大小为 $(N-1) \\times (N-1)$ 的简化矩阵 $\\mathbf{K}$ 和 $\\mathbf{M}$。\n\n离散方程组成为广义特征值问题：\n$$ \\mathbf{K} \\mathbf{\\phi} = \\omega^2 \\mathbf{M} \\mathbf{\\phi} $$\n其中 $\\mathbf{\\phi}$ 是自由节点的节点位移向量（振型）。我们求解此问题以获得特征值 $\\lambda_i = \\omega_i^2$ 和相应的特征向量 $\\mathbf{\\phi}_i$。然后，以赫兹为单位的自然频率为 $f_i = \\omega_i / (2\\pi) = \\sqrt{\\lambda_i} / (2\\pi)$。\n\n问题要求振型是质量归一化的，意味着它们被缩放以满足 $\\mathbf{\\phi}_i^T \\mathbf{M} \\mathbf{\\phi}_i = 1$。这是像 `scipy.linalg.eigh` 这样的广义特征值求解器的标准输出。通过在前面添加一个零来表示固定底部位移，从而重建完整的振型。\n\n### 步骤4：均质参考柱\n\n对于每个分层配置，定义一个具有等效属性 $G_{\\text{eq}}$ 和 $\\rho_{\\text{eq}}$ 的参考均质柱，以保持总静刚度和总质量。\n-   **静力剪切刚度等效**：分层柱的总剪切柔度是各层柔度的总和。$K_{\\text{total}}^{-1} = \\sum_i (G_i A / \\ell_i)^{-1} = \\frac{1}{A} \\sum_i \\frac{\\ell_i}{G_i}$。对于等效柱，$K_{\\text{eq}}^{-1} = \\frac{L}{G_{\\text{eq}} A}$。将两者相等，得到等效剪切模量：\n$$ G_{\\mathrm{eq}} = \\frac{L}{\\sum_{i} \\ell_i / G_i} $$\n-   **质量等效**：分层柱的总质量为 $\\sum_i \\rho_i A \\ell_i$。对于等效柱，总质量为 $\\rho_{\\text{eq}} A L$。将两者相等，得到等效密度：\n$$ \\rho_{\\mathrm{eq}} = \\frac{1}{L} \\sum_i \\ell_i \\rho_i $$\n对此均质柱重复进行 FEM 分析，以获得其参考频率和振型。\n\n### 步骤5：模态置信准则 (MAC)\n\n模态置信准则 (MAC) 用于量化两个振型 $\\mathbf{\\phi}_A$（来自分层分析）和 $\\mathbf{\\phi}_B$（来自均质分析）之间的相似性。它是一个介于 0 和 1 之间的标量值，定义为：\n$$ \\text{MAC}(\\mathbf{\\phi}_A, \\mathbf{\\phi}_B) = \\frac{(\\mathbf{\\phi}_A^T \\mathbf{\\phi}_B)^2}{(\\mathbf{\\phi}_A^T \\mathbf{\\phi}_A)(\\mathbf{\\phi}_B^T \\mathbf{\\phi}_B)} $$\n值为 1 表示完全相关（振型相同），而接近 0 的值表示正交性（形状差异很大）。该计算在完整的振型向量（包括底部的零）上使用标准的欧几里得点积。\n\n对每个测试用例实施该程序，以计算所需的频率和 MAC 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Homogeneous baseline\n        {\n            \"L\": 30.0, \"A\": 10.0, \"N\": 7,\n            \"layers\": [(30.0, 80e6, 1800.0)]\n        },\n        # Case 2: Two-layer contrast\n        {\n            \"L\": 30.0, \"A\": 10.0, \"N\": 7,\n            \"layers\": [(20.0, 120e6, 1900.0), (10.0, 40e6, 1600.0)]\n        },\n        # Case 3: Thin soft cap\n        {\n            \"L\": 30.0, \"A\": 10.0, \"N\": 7,\n            \"layers\": [(29.0, 100e6, 1800.0), (1.0, 10e6, 1600.0)]\n        }\n    ]\n\n    all_results = []\n    \n    for params in test_cases:\n        L = params[\"L\"]\n        A = params[\"A\"]\n        N = params[\"N\"]\n        layers = params[\"layers\"]\n\n        # 1. Analyze layered column\n        freqs_L, modes_L = run_fem_analysis(L, A, N, layers)\n\n        # 2. Define and analyze equivalent homogeneous column\n        sum_li_over_Gi = sum(li / Gi for li, Gi, _ in layers)\n        G_eq = L / sum_li_over_Gi\n        \n        sum_li_rhoi = sum(li * rhoi for li, _, rhoi in layers)\n        rho_eq = sum_li_rhoi / L\n        \n        layers_H = [(L, G_eq, rho_eq)]\n        freqs_H, modes_H = run_fem_analysis(L, A, N, layers_H)\n\n        # 3. Compute MAC values\n        mac_values = compute_mac(modes_L, modes_H, 3)\n\n        # 4. Format results\n        case_result = [\n            [round(f, 4) for f in freqs_L[:3]],\n            [round(f, 4) for f in freqs_H[:3]],\n            [round(m, 4) for m in mac_values]\n        ]\n        all_results.append(case_result)\n\n    # Final print statement\n    print(f\"{all_results}\")\n\ndef get_properties_at_z(z, layers):\n    \"\"\"\n    Finds the material properties (G, rho) at a given depth z.\n    Layers are defined from the bottom (z=0) up.\n    \"\"\"\n    current_z = 0.0\n    for thickness, G, rho in layers:\n        # Use a small tolerance for floating point comparisons at boundaries\n        if z = current_z + thickness + 1e-9:\n            return G, rho\n        current_z += thickness\n    # Fallback for z at the very top edge due to float precision\n    return layers[-1][1], layers[-1][2]\n\ndef run_fem_analysis(L, A, N, layers):\n    \"\"\"\n    Performs FEM analysis for a 1D shear column.\n    Returns the first few natural frequencies and mass-normalized mode shapes.\n    \"\"\"\n    num_elements = N - 1\n    h = L / num_elements  # Element length\n\n    # Initialize global matrices\n    K_global = np.zeros((N, N))\n    M_global = np.zeros((N, N))\n    \n    node_coords = np.linspace(0, L, N)\n\n    for i in range(num_elements):\n        # Determine properties at element midpoint\n        z_mid = (node_coords[i] + node_coords[i+1]) / 2.0\n        G_e, rho_e = get_properties_at_z(z_mid, layers)\n\n        # Element stiffness matrix\n        k_e = (G_e * A / h) * np.array([[1, -1], [-1, 1]])\n\n        # Element consistent mass matrix\n        m_e = (rho_e * A * h / 6.0) * np.array([[2, 1], [1, 2]])\n\n        # Assemble into global matrices\n        nodes = slice(i, i + 2)\n        K_global[nodes, nodes] += k_e\n        M_global[nodes, nodes] += m_e\n        \n    # Apply boundary conditions (fixed base at node 0)\n    # The active DOFs are nodes 1 to N-1\n    K_reduced = K_global[1:, 1:]\n    M_reduced = M_global[1:, 1:]\n\n    # Solve the generalized eigenvalue problem K*phi = omega^2*M*phi\n    # eigh returns eigenvalues in ascending order and M-orthonormal eigenvectors\n    eigvals, eigvecs = eigh(K_reduced, M_reduced)\n\n    # Frequencies in Hertz (f = omega / 2*pi)\n    omegas = np.sqrt(np.maximum(0, eigvals)) # Ensure non-negative before sqrt\n    freqs = omegas / (2.0 * np.pi)\n\n    # Reconstruct full mode shapes (add 0 for fixed base)\n    num_modes = eigvecs.shape[1]\n    modes = []\n    for i in range(num_modes):\n        mode_reduced = eigvecs[:, i]\n        # Prepend the 0 for the fixed node\n        mode_full = np.insert(mode_reduced, 0, 0)\n        modes.append(mode_full)\n        \n    return freqs, modes\n\ndef compute_mac(modes_A, modes_B, num_modes):\n    \"\"\"\n    Computes the Modal Assurance Criterion for corresponding mode pairs.\n    \"\"\"\n    mac_values = []\n    for i in range(num_modes):\n        phi_A = modes_A[i]\n        phi_B = modes_B[i]\n        \n        numerator = (phi_A.T @ phi_B)**2\n        denominator = (phi_A.T @ phi_A) * (phi_B.T @ phi_B)\n        \n        mac = 0.0 if denominator == 0 else numerator / denominator\n        mac_values.append(mac)\n    return mac_values\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3543944"}]}