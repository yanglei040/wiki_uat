{"hands_on_practices": [{"introduction": "我们首先探讨在塑性积分中采用子步策略的根本原因。本练习使用一个简单的一维模型，以演示标准的单步显式更新如何无法捕捉在单个加载增量内发生的弹塑性转变，从而导致一种被称为“人为弹性间隙”的显著误差 [@problem_id:3566116]。通过精确计算这个间隙，您将对为何需要更精细的积分方案获得具体的理解。", "problem": "考虑一种具有线性各向同性弹性和线性各向同性硬化的岩土材料的小应变、率无关、一维弹塑性问题。柯西应力用 $\\sigma$ 表示，总应变用 $\\varepsilon$ 表示，塑性应变用 $\\varepsilon^{p}$ 表示，标量累积塑性应变用 $\\kappa$ 表示。弹性定律为 $\\sigma = E \\, (\\varepsilon - \\varepsilon^{p})$，其中 $E$ 是弹性模量。屈服函数取为 $f(\\sigma,\\kappa) = \\lvert \\sigma \\rvert - (\\sigma_{y0} + H \\kappa)$，其中 $\\sigma_{y0}$ 是初始屈服应力，$H \\ge 0$ 是线性各向同性硬化模量。假设 Kuhn-Tucker 条件成立：$f \\le 0$，$\\dot{\\gamma} \\ge 0$，$f \\, \\dot{\\gamma} = 0$，其中 $\\dot{\\gamma}$ 是塑性乘子，且 $\\dot{\\kappa} = \\lvert \\dot{\\varepsilon}^{p} \\rvert$。\n\n您必须在一个应变增量上对本构方程进行数值积分，该增量从一个已知的先前状态 $\\left( \\sigma_n, \\kappa_n \\right)$ 开始，并施加一个应变增量 $\\Delta \\varepsilon = \\varepsilon_{n+1} - \\varepsilon_n$。考虑两种时间积分策略：\n\n- 策略 $\\mathcal{U}$（不分割单步显式分类）：根据前一状态对整个增量进行分类。如果 $f(\\sigma_n,\\kappa_n) \\le 0$，则将整个步长视为弹性，即对整个增量设置 $\\Delta \\varepsilon^{p} = 0$。如果 $f(\\sigma_n,\\kappa_n) > 0$，则以同样的方式将整个步长视为塑性。此策略不检测严格发生在增量内部的进入或退出塑性区的转变。\n\n- 策略 $\\mathcal{S}$（带 $f=0$ 事件检测的子步法）：检测增量内部最早穿越屈服面的点，并在参数 $\\lambda^\\star \\in [0,1]$ 处分割增量，在该点 $f$ 等于 $0$。在区间 $\\lambda \\in [0,\\lambda^\\star]$ 上，以 $\\Delta \\varepsilon^{p} = 0$ 进行弹性积分；然后在 $\\lambda \\in (\\lambda^\\star,1]$ 上，当且仅当穿越后 $f > 0$ 时，进行塑性积分（与弹塑性本构律一致）。在单个增量内，弹性试探应力演化为 $\\sigma(\\lambda) = \\sigma_n + E \\, \\Delta \\varepsilon \\, \\lambda$，而 $\\kappa$ 保持为 $\\kappa_n$ 直到塑性激活。\n\n将一个增量的人为弹性间隙定义为增量子集的应变长度（以 $\\varepsilon$ 为单位），在该子集上真实响应是塑性的（由策略 $\\mathcal{S}$ 确定），但策略 $\\mathcal{U}$ 错误地保持响应为弹性；等效地，它是集合 $\\{ \\lambda \\in [0,1] \\mid f(\\sigma(\\lambda),\\kappa_n) > 0\\}$ 的度量（以 $\\varepsilon$ 为单位），当 $f(\\sigma_n,\\kappa_n) \\le 0$ 时，该集合未被 $\\mathcal{U}$ 检测到。因此，策略 $\\mathcal{S}$ 相对于 $\\mathcal{U}$ 实现的人为弹性间隙的减小量是 $\\mathcal{U}$ 下的间隙与 $\\mathcal{S}$ 下的间隙之差（后者根据定义为零）。\n\n从上述基本定义出发，不使用任何预先推导的塑性积分公式，通过求解满足 $f(\\sigma(\\lambda^\\star),\\kappa_n) = 0$ 的最小 $\\lambda^\\star \\in [0,1]$，推导增量内最早屈服面穿越的事件检测条件，其中 $\\sigma(\\lambda) = \\sigma_n + E \\, \\Delta \\varepsilon \\, \\lambda$。当 $f(\\sigma_n,\\kappa_n) \\le 0$ 且 $f(\\sigma_n + E \\, \\Delta \\varepsilon,\\kappa_n) > 0$ 时，用此计算以 $\\lambda$ 表示的塑性子区间长度为 $\\max(0,1 - \\lambda^\\star)$，否则将其设为零。$\\mathcal{U}$ 的人为弹性间隙即为塑性子区间长度乘以 $\\lvert \\Delta \\varepsilon \\rvert$；$\\mathcal{S}$ 的人为弹性间隙为零。每个测试用例所需的输出是人为弹性间隙的减小量，以应变单位（无量纲）表示，并作为一个浮点数。\n\n实现一个完整、可运行的程序，为每个测试用例计算并返回上述定义的间隙减小量。使用以下测试套件，其中每个测试用例是一个元组 $\\left( E, \\sigma_{y0}, H, \\sigma_n, \\kappa_n, \\Delta \\varepsilon \\right)$：\n\n- 测试 A（正常路径，在接近结束时进入塑性）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.015 \\right)$。\n- 测试 B（边界情况，在结束时恰好触及屈服）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.010 \\right)$。\n- 测试 C（在结束时处于深度塑性状态）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.030 \\right)$。\n- 测试 D（非零初始应力在弹性域内）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 50, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.010 \\right)$。\n- 测试 E（反向加载进入压缩状态）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = -0.025 \\right)$。\n- 测试 F（有硬化和先前塑性历史）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 1000, \\, \\sigma_n = 120, \\, \\kappa_n = 0.05, \\, \\Delta \\varepsilon = 0.050 \\right)$。\n- 测试 G（无穿越，全程保持弹性）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 1000, \\, \\sigma_n = 120, \\, \\kappa_n = 0.05, \\, \\Delta \\varepsilon = 0.002 \\right)$。\n- 测试 H（零增量边缘情况）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.000 \\right)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$\\left[ \\text{result}_1, \\text{result}_2, \\dots \\right]$）。每个结果必须是一个浮点数，代表以应变单位表示的人为弹性间隙的减小量，并按语言的默认字符串转换方式进行四舍五入。", "solution": "该问题要求推导并实现一个公式，用于计算从单步显式积分方案（策略 $\\mathcal{U}$）转为带事件检测的子步方案（策略 $\\mathcal{S}$）时，人为弹性间隙的减小量。根据定义，策略 $\\mathcal{S}$ 的人为弹性间隙为零。因此，所要求的减小量就是策略 $\\mathcal{U}$ 的人为弹性间隙。\n\n在策略 $\\mathcal{U}$ 下，只有当它错误地将应变增量的一部分（本应是塑性的）处理为弹性时，才会出现人为弹性间隙。这发生在特定的条件下：\n1.  增量开始时（时间 $t_n$）的状态必须是弹性的或位于屈服面上，即 $f(\\sigma_n, \\kappa_n) \\le 0$。如果状态已经是塑性的 ($f(\\sigma_n, \\kappa_n) > 0$)，策略 $\\mathcal{U}$ 会正确地将增量处理为塑性，不会产生人为的*弹性*间隙。\n2.  增量结束时（时间 $t_{n+1}$）的纯弹性试探状态必须位于屈服面之外。如果试探状态保持弹性，则整个增量确实是弹性的，策略 $\\mathcal{U}$ 的分类将是正确的。\n\n接下来的分析通过形式化这些条件并推导错误弹性段的大小来进行。\n\n首先，我们定义相关量。增量开始时的屈服应力是先前累积塑性应变 $\\kappa_n$ 的函数：\n$$\n\\sigma_{y,n} = \\sigma_{y0} + H \\kappa_n\n$$\n因此，应力的弹性域是区间 $[-\\sigma_{y,n}, \\sigma_{y,n}]$。如果 $|\\sigma_n| \\le \\sigma_{y,n}$，则初始状态是弹性的。\n\n在弹性试探步中，应力随参数 $\\lambda \\in [0, 1]$ 线性演化，该参数跨越应变增量 $\\Delta\\varepsilon$：\n$$\n\\sigma(\\lambda) = \\sigma_n + E \\Delta\\varepsilon \\lambda\n$$\n增量结束时的试探应力对应于 $\\lambda=1$：\n$$\n\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma(\\lambda=1) = \\sigma_n + E \\Delta\\varepsilon\n$$\n当且仅当 $|\\sigma_n| \\le \\sigma_{y,n}$ 且 $|\\sigma_{n+1}^{\\mathrm{trial}}| > \\sigma_{y,n}$ 时，存在人为弹性间隙。如果不满足这些条件，则间隙为零。\n\n假设满足产生间隙的条件，我们必须找到首次屈服点。这是应力路径 $\\sigma(\\lambda)$ 与屈服面相交的最小 $\\lambda^\\star \\in [0, 1]$ 值。屈服条件为 $f(\\sigma(\\lambda), \\kappa_n) = 0$，等效于 $|\\sigma(\\lambda)| = \\sigma_{y,n}$。代入 $\\sigma(\\lambda)$ 的表达式：\n$$\n|\\sigma_n + E \\Delta\\varepsilon \\lambda^\\star| = \\sigma_{y,n}\n$$\n这个绝对值方程产生两个关于 $\\lambda^\\star$ 的线性方程：\n1.  $\\sigma_n + E \\Delta\\varepsilon \\lambda^\\star = \\sigma_{y,n} \\quad \\implies \\quad \\lambda_1^\\star = \\frac{\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}$\n2.  $\\sigma_n + E \\Delta\\varepsilon \\lambda^\\star = -\\sigma_{y,n} \\quad \\implies \\quad \\lambda_2^\\star = \\frac{-\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}$\n\n我们需要 $\\lambda^\\star$ 的最小非负解。初始状态是弹性的，所以 $-\\sigma_{y,n} \\le \\sigma_n \\le \\sigma_{y,n}$。这意味着 $\\sigma_{y,n} - \\sigma_n \\ge 0$ 且 $-\\sigma_{y,n} - \\sigma_n \\le 0$。如果 $E \\Delta\\varepsilon > 0$，则 $\\lambda_1^\\star \\ge 0$ 且 $\\lambda_2^\\star \\le 0$。在前进的“时间” ($\\lambda > 0$) 中，唯一有效的穿越点是 $\\lambda_1^\\star$。如果 $E \\Delta\\varepsilon  0$，则 $\\lambda_1^\\star \\le 0$ 且 $\\lambda_2^\\star \\ge 0$。唯一有效的穿越点是 $\\lambda_2^\\star$。\n当 $\\Delta\\varepsilon = 0$ 时，$\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n$，所以 $|\\sigma_{n+1}^{\\mathrm{trial}}| \\le \\sigma_{y,n}$，间隙为零。因此我们之后假设 $\\Delta\\varepsilon \\neq 0$。\n\n$\\lambda^\\star$ 的值必须在 $[0,1]$ 区间内。由于在步长结束前发生屈服（$|\\sigma_{n+1}^{\\mathrm{trial}}|  \\sigma_{y,n}$），可以保证 $\\lambda^\\star \\in [0,1)$。\n\n增量在 $\\lambda \\in [0, \\lambda^\\star]$ 区间是弹性的，在 $\\lambda \\in (\\lambda^\\star, 1]$ 区间变为塑性。策略 $\\mathcal{U}$ 假设整个增量都是弹性的，因此在这第二个子区间上产生了误差。这个塑性子区间的长度用参数 $\\lambda$ 表示为：\n$$\nL_\\lambda = 1 - \\lambda^\\star\n$$\n问题将人为弹性间隙 $G$ 定义为该长度乘以应变增量的大小 $|\\Delta\\varepsilon|$：\n$$\nG = (1 - \\lambda^\\star) |\\Delta\\varepsilon|\n$$\n\n我们现在代入 $\\lambda^\\star$ 的表达式：\n\n情况1：拉伸屈服（$\\sigma_{n+1}^{\\mathrm{trial}}  \\sigma_{y,n}$）。这意味着 $E \\Delta\\varepsilon  0$，所以如果 $E0$，则 $|\\Delta\\varepsilon| = \\Delta\\varepsilon$。\n$$\n\\lambda^\\star = \\lambda_1^\\star = \\frac{\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\n$$\n$$\nG = \\left(1 - \\frac{\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\\right) \\Delta\\varepsilon = \\frac{E \\Delta\\varepsilon - (\\sigma_{y,n} - \\sigma_n)}{E \\Delta\\varepsilon} \\Delta\\varepsilon = \\frac{\\sigma_n + E \\Delta\\varepsilon - \\sigma_{y,n}}{E} = \\frac{\\sigma_{n+1}^{\\mathrm{trial}} - \\sigma_{y,n}}{E}\n$$\n\n情况2：压缩屈服（$\\sigma_{n+1}^{\\mathrm{trial}}  -\\sigma_{y,n}$）。这意味着 $E \\Delta\\varepsilon  0$，所以如果 $E0$，则 $|\\Delta\\varepsilon| = -\\Delta\\varepsilon$。\n$$\n\\lambda^\\star = \\lambda_2^\\star = \\frac{-\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\n$$\n$$\nG = \\left(1 - \\frac{-\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\\right) (-\\Delta\\varepsilon) = \\frac{E \\Delta\\varepsilon - (-\\sigma_{y,n} - \\sigma_n)}{E \\Delta\\varepsilon} (-\\Delta\\varepsilon) = -\\frac{\\sigma_n + E \\Delta\\varepsilon + \\sigma_{y,n}}{E} = \\frac{-(\\sigma_{n+1}^{\\mathrm{trial}} + \\sigma_{y,n})}{E}\n$$\n由于 $\\sigma_{n+1}^{\\mathrm{trial}}  -\\sigma_{y,n}$，分子为正。\n\n这两种情况可以用一个包含绝对值的紧凑公式统一表示：\n$$\nG = \\frac{|\\sigma_{n+1}^{\\mathrm{trial}}| - \\sigma_{y,n}}{E}\n$$\n这个公式优雅地表示了与试探应力“超出”屈服面部分相对应的应变。\n\n计算每个测试用例的人为弹性间隙减小量的最终算法如下：\n1. 读取参数 $(E, \\sigma_{y0}, H, \\sigma_n, \\kappa_n, \\Delta\\varepsilon)$。\n2. 计算当前状态的屈服应力：$\\sigma_{y,n} = \\sigma_{y0} + H \\kappa_n$。\n3. 检查初始状态是否是塑性的：如果 $|\\sigma_n|  \\sigma_{y,n}$，则间隙为 $0$。\n4. 如果初始状态是弹性的或在屈服面上，计算增量结束时的弹性试探应力：$\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n + E \\Delta\\varepsilon$。\n5. 检查试探应力状态是否保持弹性：如果 $|\\sigma_{n+1}^{\\mathrm{trial}}| \\le \\sigma_{y,n}$，则间隙为 $0$。\n6. 如果试探应力状态是塑性的（$|\\sigma_{n+1}^{\\mathrm{trial}}|  \\sigma_{y,n}$），使用推导出的公式计算间隙：$G = (|\\sigma_{n+1}^{\\mathrm{trial}}| - \\sigma_{y,n}) / E$。\n7. 该测试用例的结果为 $G$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the reduction in artificial elastic gap for a series of\n    elastoplasticity test cases.\n    \"\"\"\n    # Test cases are tuples of (E, sigma_y0, H, sigma_n, kappa_n, delta_eps)\n    test_cases = [\n        # Test A: happy path, enters plastic near the end\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.015),\n        # Test B: boundary, just touches yield at the end\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.010),\n        # Test C: deeply plastic at the end\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.030),\n        # Test D: nonzero initial stress within elastic domain\n        (10000.0, 100.0, 0.0, 50.0, 0.0, 0.010),\n        # Test E: reverse loading into compression\n        (10000.0, 100.0, 0.0, 0.0, 0.0, -0.025),\n        # Test F: with hardening and prior plastic history\n        (10000.0, 100.0, 1000.0, 120.0, 0.05, 0.050),\n        # Test G: no crossing, remains elastic throughout\n        (10000.0, 100.0, 1000.0, 120.0, 0.05, 0.002),\n        # Test H: zero increment edge case\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.000),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, sigma_y0, H, sigma_n, kappa_n, delta_eps = case\n\n        # 1. Calculate the yield stress for the current state n.\n        sigma_y_n = sigma_y0 + H * kappa_n\n\n        # 2. Check if the initial state is plastic. If so, strategy U is correct,\n        #    so the artificial elastic gap is zero.\n        if np.abs(sigma_n) > sigma_y_n:\n            gap = 0.0\n        else:\n            # 3. Calculate the elastic trial stress at the end of the increment.\n            sigma_trial_n_plus_1 = sigma_n + E * delta_eps\n\n            # 4. The artificial elastic gap exists only if the trial state is plastic.\n            #    The magnitude of the gap is the strain corresponding to the stress \"overshoot\".\n            #    f_trial represents the value of the yield function for the trial stress.\n            f_trial = np.abs(sigma_trial_n_plus_1) - sigma_y_n\n\n            if f_trial > 0:\n                gap = f_trial / E\n            else:\n                # If f_trial = 0, the entire step is elastic, so no gap.\n                gap = 0.0\n        \n        results.append(gap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3566116"}, {"introduction": "在理解了子步法的必要性之后，本实践将进入一个更真实的三维实现，使用的是岩土力学中的基石——Drucker-Prager模型。您将实现并比较两种截然不同的自适应准则来控制子步大小：一种基于塑性流动方向的变化，另一种基于屈服函数的残差大小 [@problem_id:3566154]。这种亲手实践的比较将突显在为复杂本构模型选择一个既稳健又高效的子步控制器时所涉及的实际权衡。", "problem": "您的任务是设计并实现两种自适应子步终止准则，用于在小应变条件下积分一个相关联的 Drucker–Prager 弹塑性模型。这两种准则分别是：塑性流动方向的平稳性和残余屈服函数的大小。您的程序必须使用每种准则模拟在单个给定的总应变增量下的应力更新，并报告接受的子步数量以及最终应力状态的差异。所有量纲中，应力必须以兆帕（MPa）为单位，应变为无量纲单位。\n\n请使用以下在计算岩土力学和小应变弹塑性力学中至关重要的背景和基本定义。\n\n1.  本构行为在屈服前为线弹性各向同性。对于小应变，应力增量由标准胡克定律给出\n    $$\n    \\Delta \\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\Delta \\boldsymbol{\\varepsilon},\n    $$\n    其中 $\\lambda$ 和 $\\mu$ 是拉梅常数，$\\boldsymbol{I}$ 是单位张量。拉梅常数与杨氏模量 $E$ 和泊松比 $\\nu$ 的关系为\n    $$\n    \\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}.\n    $$\n\n2.  带有各向同性硬化的相关联 Drucker–Prager 屈服函数为\n    $$\n    f(\\boldsymbol{\\sigma}, \\kappa) = \\alpha \\, I_1 + \\sqrt{J_2} - \\left(\\sigma_{y0} + H \\kappa \\right),\n    $$\n    其中 $I_1 = \\mathrm{tr}(\\boldsymbol{\\sigma})$，$J_2 = \\tfrac{1}{2} \\, \\mathrm{dev}(\\boldsymbol{\\sigma}) : \\mathrm{dev}(\\boldsymbol{\\sigma})$，$\\alpha$ 是给定的摩擦参数，$\\sigma_{y0}$ 是初始屈服应力，$H$ 是各向同性硬化模量，$\\kappa$ 是随着塑性流动累积的内硬化变量。对于相关联流动，塑性流动方向定义为屈服函数对应力的梯度，\n    $$\n    \\boldsymbol{m}(\\boldsymbol{\\sigma}) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\alpha \\boldsymbol{I} + \\frac{\\mathrm{dev}(\\boldsymbol{\\sigma})}{2 \\sqrt{J_2}},\n    $$\n    其归一化形式为\n    $$\n    \\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\frac{\\boldsymbol{m}(\\boldsymbol{\\sigma})}{\\|\\boldsymbol{m}(\\boldsymbol{\\sigma})\\|_F},\n    $$\n    其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。当 $J_2$ 足够小时，用一个小的正阈值来正则化 $\\sqrt{J_2}$，以避免除以零。\n\n3.  考虑子步框架，其中总应变增量 $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ 被划分为大小为 $\\Delta \\boldsymbol{\\varepsilon}_i = \\xi_i \\, \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ 的子步，其中 $0  \\xi_i \\leq 1$ 且 $\\sum_i \\xi_i = 1$。在每个子步内，采用塑性流动的恒定方向近似：在子步开始时冻结梯度 $\\boldsymbol{m}$。在子步 $i$ 中，$\\boldsymbol{m}_i = \\boldsymbol{m}(\\boldsymbol{\\sigma}_i)$ 固定，应力更新为\n    $$\n    \\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}_{i} + \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\Delta \\boldsymbol{\\varepsilon}_i - d\\lambda_i \\left[\\lambda \\, \\mathrm{tr}(\\boldsymbol{m}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\boldsymbol{m}_i\\right],\n    $$\n    其中 $d\\lambda_i \\geq 0$ 是该子步的塑性乘子增量，硬化更新为 $\\kappa_{i+1} = \\kappa_i + d\\lambda_i$。在子步 $i$ 的塑性加载中，一致性条件 $f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) = 0$ 定义了一个关于 $d\\lambda_i$ 的标量非线性方程；使用牛顿法求解。如果在子步结束时的试探弹性预测满足 $f \\leq 0$，则 $d\\lambda_i = 0$，该子步为纯弹性。\n\n4.  实现两种子步的接受准则：\n    -   流动方向的平稳性：当子步开始和结束时归一化流动方向的变化满足以下条件时，接受该子步\n        $$\n        \\left\\|\\boldsymbol{n}_{i+1} - \\boldsymbol{n}_{i} \\right\\|_F  \\varepsilon_n,\n        $$\n        其中 $\\varepsilon_n$ 是指定的容差。第一个子步无条件接受。如果条件不满足，减小子步大小（例如，将 $\\xi_i$ 减半）并从相同状态重试。\n    -   基于屈服残差：当子步结束时评估的屈服函数大小满足以下条件时，接受该子步\n        $$\n        f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\leq 0 \\quad \\text{or} \\quad \\left| f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\right|  \\varepsilon_f,\n        $$\n        其中 $\\varepsilon_f$ 是指定的容差。如果条件不满足，减小子步大小并重试。在塑性子步中，使用相同的牛顿法求解 $d\\lambda_i$。\n\n5.  在每次模拟中，从 $\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$ 和 $\\kappa_0 = 0$ 开始。使用兆帕单位的材料参数：$E$ 单位为 $\\mathrm{MPa}$，$\\nu$ 无量纲，$\\alpha$ 无量纲，$\\sigma_{y0}$ 单位为 $\\mathrm{MPa}$，$H$ 单位为 $\\mathrm{MPa}$。使用以下容差：平稳性准则的 $\\varepsilon_n = 10^{-3}$，屈服残差准则的 $\\varepsilon_f = 10^{-6} \\,\\mathrm{MPa}$。在每个塑性子步中，使用 $10^{-8} \\,\\mathrm{MPa}$ 的牛顿求解器容差来求解一致性方程，最大迭代次数为 $50$ 次，并根据需要使用步长阻尼。在子步自适应中，如果子步大小变得小于总增量的 $10^{-6}$ 的最小分数，则强制接受以避免无限循环。\n\n测试套件。对于每个案例，应变增量 $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ 是一个对称的 $3 \\times 3$ 张量（无量纲）。材料参数如各案例所列。所有计算和报告的应力必须以 $\\mathrm{MPa}$ 为单位。\n\n-   案例 A（一般偏量加载，预期塑性）：$E = 10000 \\,\\mathrm{MPa}$，$\\nu = 0.3$，$\\alpha = 0.2$，$\\sigma_{y0} = 50 \\,\\mathrm{MPa}$，$H = 200 \\,\\mathrm{MPa}$，以及\n    $$\n    \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n    0  0.01  0 \\\\\n    0.01  0  0 \\\\\n    0  0  0\n    \\end{bmatrix}.\n    $$\n\n-   案例 B（静水拉伸，预期塑性）：$E = 10000 \\,\\mathrm{MPa}$，$\\nu = 0.3$，$\\alpha = 0.2$，$\\sigma_{y0} = 50 \\,\\mathrm{MPa}$，$H = 200 \\,\\mathrm{MPa}$，以及\n    $$\n    \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n    0.004  0  0 \\\\\n    0  0.004  0 \\\\\n    0  0  0.004\n    \\end{bmatrix}.\n    $$\n\n-   案例 C（混合加载，大路径）：$E = 10000 \\,\\mathrm{MPa}$，$\\nu = 0.3$，$\\alpha = 0.2$，$\\sigma_{y0} = 50 \\,\\mathrm{MPa}$，$H = 200 \\,\\mathrm{MPa}$，以及\n    $$\n    \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n    0.006  0.004  0 \\\\\n    0.004  -0.002  0 \\\\\n    0  0  -0.001\n    \\end{bmatrix}.\n    $$\n\n-   案例 D（小剪切，预期弹性）：$E = 10000 \\,\\mathrm{MPa}$，$\\nu = 0.3$，$\\alpha = 0.2$，$\\sigma_{y0} = 50 \\,\\mathrm{MPa}$，$H = 200 \\,\\mathrm{MPa}$，以及\n    $$\n    \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n    0  0.0002  0 \\\\\n    0.0002  0  0 \\\\\n    0  0  0\n    \\end{bmatrix}.\n    $$\n\n所需输出。对于每个案例，运行两次完整的增量积分：一次使用平稳性准则，另一次使用屈服残差准则。记录：平稳性准则接受的子步数（$N_n$）、屈服残差准则接受的子步数（$N_f$），以及两个最终应力张量之差的弗罗贝尼乌斯范数（单位为 $\\mathrm{MPa}$），$\\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F$。您的程序应生成单行输出，包含案例 A-D 的 12 个值，顺序如下\n$$\n\\left[ N_n^{A}, N_f^{A}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{A}, N_n^{B}, N_f^{B}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{B}, N_n^{C}, N_f^{C}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{C}, N_n^{D}, N_f^{D}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{D} \\right],\n$$\n并严格按照以逗号分隔值的 Python 列表字面量格式打印。计数值必须是整数，范数必须是单位为 $\\mathrm{MPa}$ 的浮点数。", "solution": "该问题在科学上基于计算塑性力学理论，问题阐述清晰，提供了所有必要的参数和条件，并以客观、正式的语言表达。该问题要求实现并比较两种自适应子步策略，用于积分 Drucker-Prager 弹塑性材料的本构响应。我们将进行详细的求解。\n\n### 1. 理论框架\n\n该问题描述了一个在小应变假设下，结合了线弹性和 Drucker-Prager 塑性的材料模型。\n\n**弹性行为**：应力增量张量 $\\Delta\\boldsymbol{\\sigma}$ 和应变增量张量 $\\Delta\\boldsymbol{\\varepsilon}$ 之间的关系由标准各向同性线弹性定律（胡克定律）给出：\n$$\n\\Delta \\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\Delta \\boldsymbol{\\varepsilon}\n$$\n其中 $\\boldsymbol{I}$ 是二阶单位张量，$\\mathrm{tr}(\\cdot)$ 是迹算子。拉梅参数 $\\lambda$ 和 $\\mu$ 根据杨氏模量 $E$ 和泊松比 $\\nu$ 定义如下：\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\n这个结构意味着对于任意二阶张量 $\\boldsymbol{X}$，四阶弹性张量 $\\mathbf{C}$ 的作用为 $\\mathbf{C}:\\boldsymbol{X} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{X}) \\, \\boldsymbol{I} + 2 \\mu \\, \\boldsymbol{X}$。\n\n**塑性行为**：塑性屈服和流动由带各向同性硬化的相关联 Drucker-Prager 模型控制。\n屈服函数 $f$ 定义了弹性域的边界：\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = \\alpha \\, I_1 + \\sqrt{J_2} - \\left(\\sigma_{y0} + H \\kappa \\right)\n$$\n其中 $I_1 = \\mathrm{tr}(\\boldsymbol{\\sigma})$ 是应力张量的第一不变量，$J_2 = \\frac{1}{2} \\mathrm{dev}(\\boldsymbol{\\sigma}) : \\mathrm{dev}(\\boldsymbol{\\sigma})$ 是偏应力的第二不变量，$\\alpha$ 是材料摩擦参数，$\\sigma_{y0}$ 是初始屈服应力，$H$ 是硬化模量，$\\kappa$ 是累积塑性应变（内硬化变量）。\n\n对于相关联塑性，塑性流动方向 $\\boldsymbol{m}$ 由屈服函数对应力的梯度给出：\n$$\n\\boldsymbol{m}(\\boldsymbol{\\sigma}) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\alpha \\boldsymbol{I} + \\frac{\\mathrm{dev}(\\boldsymbol{\\sigma})}{2 \\sqrt{J_2}}\n$$\n为处理 $J_2 \\to 0$（即在静水压力轴上的状态）的情况，如果 $J_2$ 低于一个小的数值阈值，则将 $\\boldsymbol{m}$ 的偏量部分设为零，从而对包含 $\\sqrt{J_2}$ 的项进行正则化。归一化的流动方向为 $\\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\boldsymbol{m}(\\boldsymbol{\\sigma}) / \\|\\boldsymbol{m}(\\boldsymbol{\\sigma})\\|_F$，其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。\n\n### 2. 数值积分方案\n\n总应变增量 $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ 在单个载荷步中施加，该载荷步被划分为多个更小的子步。每个子步内的积分使用一种显式类型的、恒定方向的近似方法进行。\n\n**子步法**：总应变增量被划分为 $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\sum_i \\Delta\\boldsymbol{\\varepsilon}_i$，其中 $\\Delta\\boldsymbol{\\varepsilon}_i = \\xi_i \\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$，$\\xi_i$ 是子步 $i$ 的大小。状态 $(\\boldsymbol{\\sigma}_i, \\kappa_i)$ 被更新为 $(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1})$。\n\n**应力更新**：对于每个子步，首先计算一个试探弹性应力：\n$$\n\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1} = \\boldsymbol{\\sigma}_i + \\Delta\\boldsymbol{\\sigma}^{\\text{e}}_i = \\boldsymbol{\\sigma}_i + \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\Delta \\boldsymbol{\\varepsilon}_i\n$$\n如果 $f(\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}, \\kappa_i) \\leq 0$，则该子步是弹性的，$\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}$，$\\kappa_{i+1} = \\kappa_i$。\n\n如果 $f(\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}, \\kappa_i)  0$，则该子步是塑性的。需要进行塑性修正。恒定方向近似在子步开始时冻结流动方向 $\\boldsymbol{m}_i = \\boldsymbol{m}(\\boldsymbol{\\sigma}_i)$。最终应力由下式给出：\n$$\n\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}^{\\text{trial}}_{i+1} - d\\lambda_i \\left( \\mathbf{C} : \\boldsymbol{m}_i \\right)\n$$\n其中 $d\\lambda_i$ 是该子步的塑性乘子增量，而项 $\\mathbf{C} : \\boldsymbol{m}_i$ 是弹性张量与流动方向的缩并：\n$$\n\\mathbf{C} : \\boldsymbol{m}_i = \\lambda \\, \\mathrm{tr}(\\boldsymbol{m}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\boldsymbol{m}_i\n$$\n硬化变量更新为 $\\kappa_{i+1} = \\kappa_i + d\\lambda_i$。未知数 $d\\lambda_i$ 通过强制执行一致性条件 $f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) = 0$ 来求解。这构成了一个关于 $d\\lambda_i$ 的标量非线性方程，我们使用牛顿-拉夫逊方法求解。$d\\lambda_i$ 的迭代更新为：\n$$\nd\\lambda_i^{(k+1)} = d\\lambda_i^{(k)} - \\frac{g(d\\lambda_i^{(k)})}{g'(d\\lambda_i^{(k)})}\n$$\n其中 $g(d\\lambda_i) = f(\\boldsymbol{\\sigma}_{i+1}(d\\lambda_i), \\kappa_{i+1}(d\\lambda_i))$ 且 $g'(d\\lambda_i) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}\\Big|_{\\boldsymbol{\\sigma}_{i+1}} : \\frac{d\\boldsymbol{\\sigma}_{i+1}}{d(d\\lambda_i)} + \\frac{\\partial f}{\\partial \\kappa}\\frac{d\\kappa_{i+1}}{d(d\\lambda_i)} = -\\boldsymbol{m}(\\boldsymbol{\\sigma}_{i+1}) : (\\mathbf{C}:\\boldsymbol{m}_i) - H$。\n\n### 3. 自适应子步控制\n\n实现并比较了两种用于接受已完成子步的准则。如果一个子步被拒绝，其大小 $\\xi_i$ 将减半，并从状态 $(\\boldsymbol{\\sigma}_i, \\kappa_i)$ 重试计算。如果子步大小低于某个最小阈值（总增量的 $10^{-6}$），则强制接受该子步以防止无限循环。\n\n**1. 流动方向的平稳性**：如果塑性流动方向没有显著变化，则接受一个子步。这通过子步开始和结束时归一化流动方向之差的弗罗贝尼乌斯范数来衡量。\n$$\n\\left\\|\\boldsymbol{n}_{i+1} - \\boldsymbol{n}_{i} \\right\\|_F  \\varepsilon_n\n$$\n其中 $\\boldsymbol{n}_i = \\boldsymbol{n}(\\boldsymbol{\\sigma}_i)$，$\\boldsymbol{n}_{i+1} = \\boldsymbol{n}(\\boldsymbol{\\sigma}_{i+1})$，容差为 $\\varepsilon_n = 10^{-3}$。模拟的第一个子步无条件接受。\n\n**2. 基于屈服残差**：如果最终状态是弹性的，或者最终应力状态足够接近屈服面，则接受一个子步。\n$$\nf(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\leq 0 \\quad \\text{or} \\quad \\left| f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\right|  \\varepsilon_f\n$$\n容差为 $\\varepsilon_f = 10^{-6} \\, \\mathrm{MPa}$。\n\n### 4. 模拟执行\n\n对于每个测试案例，初始化问题中指定的材料和数值参数。模拟从零应力、零硬化状态（$\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$，$\\kappa_0=0$）开始。积分过程执行两次：一次使用平稳性准则，第二次使用屈服残差准则。记录每个案例接受的子步数（$N_n$, $N_f$）和最终应力张量之差的弗罗贝尼乌斯范数 $\\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F$。然后将所有案例的结果汇总到一个列表中作为最终输出。", "answer": "```python\nimport numpy as np\n\n# A small value for J2 regularization to prevent division by zero\nJ2_REG = 1e-20  # MPa^2\n\n# ---------- Tensor and Constitutive Utilities ----------\n\ndef dev(tensor):\n    \"\"\"Computes the deviatoric part of a 3x3 tensor.\"\"\"\n    return tensor - (1/3) * np.trace(tensor) * np.eye(3)\n\ndef lame_lambda(E, nu):\n    \"\"\"Calculates Lamé's first parameter.\"\"\"\n    return (E * nu) / ((1 + nu) * (1 - 2 * nu))\n\ndef lame_mu(E, nu):\n    \"\"\"Calculates Lamé's second parameter (shear modulus).\"\"\"\n    return E / (2 * (1 + nu))\n\ndef elastic_stress_inc(deps, lam, mu):\n    \"\"\"\n    Calculates the elastic stress increment using standard Hooke's Law.\n    Δσ = λ tr(Δε) I + 2μ Δε\n    \"\"\"\n    tr_deps = np.trace(deps)\n    # Corrected to use the full strain tensor, not just its deviatoric part.\n    return lam * tr_deps * np.eye(3) + 2 * mu * deps\n\ndef C_colon_tensor(tensor, lam, mu):\n    \"\"\"\n    Applies the standard isotropic elastic constitutive operator to a second-order tensor.\n    C:T = λ tr(T) I + 2μ T\n    \"\"\"\n    # Corrected to use the full tensor, not just its deviatoric part.\n    return lam * np.trace(tensor) * np.eye(3) + 2 * mu * tensor\n\n# ---------- Drucker-Prager Model Functions ----------\n\ndef get_invariants(sigma):\n    \"\"\"Computes stress invariants I1 and J2.\"\"\"\n    I1 = np.trace(sigma)\n    s = dev(sigma)\n    J2 = 0.5 * np.sum(s * s)\n    return I1, J2\n\ndef yield_function(sigma, kappa, alpha, sig_y0, H):\n    \"\"\"Computes the Drucker-Prager yield function value.\"\"\"\n    I1, J2 = get_invariants(sigma)\n    sqrt_J2 = np.sqrt(J2) if J2 > 0 else 0.0\n    return alpha * I1 + sqrt_J2 - (sig_y0 + H * kappa)\n\ndef flow_direction_m(sigma, alpha):\n    \"\"\"Computes the plastic flow direction m = ∂f/∂σ with regularization.\"\"\"\n    s = dev(sigma)\n    J2 = 0.5 * np.sum(s * s)\n    if J2  J2_REG:\n        # For states on/near hydrostatic axis, deviatoric part of flow is zero\n        dev_m_term = np.zeros((3, 3))\n    else:\n        dev_m_term = s / (2 * np.sqrt(J2))\n    return alpha * np.eye(3) + dev_m_term\n\ndef normalized_flow_direction_n(sigma, alpha):\n    \"\"\"Computes the normalized plastic flow direction n.\"\"\"\n    m = flow_direction_m(sigma, alpha)\n    norm_m = np.linalg.norm(m, 'fro')\n    if norm_m  1e-12: # Avoid division by zero if m is effectively zero\n        return np.zeros((3,3))\n    return m / norm_m\n\n# ---------- Newton Solver for Plastic Multiplier ----------\n\ndef solve_d_lambda(sigma_trial, kappa_i, m_i, params):\n    \"\"\"\n    Solves for the plastic multiplier increment d_lambda using Newton's method.\n    \"\"\"\n    lam, mu, alpha, sig_y0, H = params['lam'], params['mu'], params['alpha'], params['sig_y0'], params['H']\n    newton_tol = params['newton_tol']\n    max_iter = params['newton_max_iter']\n\n    C_m = C_colon_tensor(m_i, lam, mu)\n    d_lambda = 0.0\n\n    for _ in range(max_iter):\n        sigma_k = sigma_trial - d_lambda * C_m\n        kappa_k = kappa_i + d_lambda\n\n        # Calculate residual g(d_lambda)\n        g = yield_function(sigma_k, kappa_k, alpha, sig_y0, H)\n\n        if abs(g)  newton_tol:\n            return d_lambda if d_lambda > 0 else 0.0\n\n        # Calculate derivative g'(d_lambda)\n        m_k = flow_direction_m(sigma_k, alpha)\n        g_prime = -np.sum(m_k * C_m) - H\n\n        if abs(g_prime)  1e-12:\n            return d_lambda if d_lambda > 0 else 0.0\n\n        # Newton update with simple line search/damping\n        delta_d_lambda = -g / g_prime\n        damp = 1.0\n        for _ in range(5):\n            d_lambda_new = d_lambda + damp * delta_d_lambda\n            if d_lambda_new  0: # Multiplier must be non-negative\n                damp /= 2.0\n                continue\n            \n            sigma_new = sigma_trial - d_lambda_new * C_m\n            kappa_new = kappa_i + d_lambda_new\n            g_new = yield_function(sigma_new, kappa_new, alpha, sig_y0, H)\n            \n            if abs(g_new)  abs(g) * (1 - 1e-4 * damp): # Armijo-like condition\n                d_lambda = d_lambda_new\n                break\n            damp /= 2.0\n        else: # Damping failed, so no update this iteration\n            return d_lambda if d_lambda > 0 else 0.0\n\n    return d_lambda if d_lambda > 0 else 0.0\n\n# ---------- Main Substepping Algorithm ----------\n\ndef run_simulation(params, criterion):\n    \"\"\"\n    Runs a single simulation for a total strain increment with adaptive substepping.\n    \"\"\"\n    sigma = np.zeros((3, 3))\n    kappa = 0.0\n    \n    total_strain_inc = params['deps_tot']\n    lam, mu, alpha, sig_y0, H = params['lam'], params['mu'], params['alpha'], params['sig_y0'], params['H']\n    eps_n, eps_f, min_xi_frac = params['eps_n'], params['eps_f'], params['min_xi_frac']\n    \n    accumulated_xi = 0.0\n    substep_count = 0\n\n    while accumulated_xi  1.0 - 1e-9: # Loop until full strain increment is applied\n        xi = 1.0 - accumulated_xi\n        is_first_substep = (substep_count == 0)\n\n        while True: # Substep reduction loop\n            deps_substep = xi * total_strain_inc\n            sigma_trial = sigma + elastic_stress_inc(deps_substep, lam, mu)\n            f_trial = yield_function(sigma_trial, kappa, alpha, sig_y0, H)\n            \n            is_plastic_substep = f_trial > 0\n\n            if is_plastic_substep:\n                m_i = flow_direction_m(sigma, alpha)\n                d_lambda = solve_d_lambda(sigma_trial, kappa, m_i, params)\n                \n                if d_lambda > 0:\n                    C_m = C_colon_tensor(m_i, lam, mu)\n                    sigma_next = sigma_trial - d_lambda * C_m\n                    kappa_next = kappa + d_lambda\n                else: # Newton found no plastic strain, so step is effectively elastic\n                    sigma_next = sigma_trial\n                    kappa_next = kappa\n                    is_plastic_substep = False\n            else: # Elastic substep\n                sigma_next = sigma_trial\n                kappa_next = kappa\n\n            # Substep acceptance check\n            accepted = False\n            if criterion == 'stationarity':\n                if is_first_substep or not is_plastic_substep:\n                    accepted = True\n                else:\n                    n_i = normalized_flow_direction_n(sigma, alpha)\n                    n_next = normalized_flow_direction_n(sigma_next, alpha)\n                    norm_diff = np.linalg.norm(n_next - n_i, 'fro')\n                    if norm_diff  eps_n:\n                        accepted = True\n            elif criterion == 'yield_residual':\n                if not is_plastic_substep:\n                    accepted = True\n                else:\n                    f_end = yield_function(sigma_next, kappa_next, alpha, sig_y0, H)\n                    if abs(f_end)  eps_f:\n                        accepted = True\n            \n            if not accepted and xi  min_xi_frac:\n                accepted = True\n                \n            if accepted:\n                sigma = sigma_next\n                kappa = kappa_next\n                accumulated_xi += xi\n                substep_count += 1\n                break\n            else:\n                xi /= 2.0\n                \n    return sigma, substep_count\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases_spec = {\n        'A': {'deps_tot': np.array([[0.0, 0.01, 0.0], [0.01, 0.0, 0.0], [0.0, 0.0, 0.0]])},\n        'B': {'deps_tot': np.array([[0.004, 0.0, 0.0], [0.0, 0.004, 0.0], [0.0, 0.0, 0.004]])},\n        'C': {'deps_tot': np.array([[0.006, 0.004, 0.0], [0.004, -0.002, 0.0], [0.0, 0.0, -0.001]])},\n        'D': {'deps_tot': np.array([[0.0, 0.0002, 0.0], [0.0002, 0.0, 0.0], [0.0, 0.0, 0.0]])}\n    }\n    \n    base_material_params = {'E': 10000.0, 'nu': 0.3, 'alpha': 0.2, 'sig_y0': 50.0, 'H': 200.0}\n    common_numerical_params = {\n        'eps_n': 1e-3, 'eps_f': 1e-6, 'newton_tol': 1e-8,\n        'newton_max_iter': 50, 'min_xi_frac': 1e-6\n    }\n\n    results = []\n    case_order = ['A', 'B', 'C', 'D']\n\n    for case_id in case_order:\n        params = base_material_params.copy()\n        params.update(test_cases_spec[case_id])\n        params.update(common_numerical_params)\n        \n        params['lam'] = lame_lambda(params['E'], params['nu'])\n        params['mu'] = lame_mu(params['E'], params['nu'])\n\n        sigma_n, N_n = run_simulation(params, 'stationarity')\n        sigma_f, N_f = run_simulation(params, 'yield_residual')\n\n        stress_diff_norm = np.linalg.norm(sigma_n - sigma_f, 'fro')\n\n        results.extend([N_n, N_f, stress_diff_norm])\n        \n    print(f\"[{','.join(f'{v:.6f}' if isinstance(v, float) else str(v) for v in results)}]\")\n\nsolve()\n```", "id": "3566154"}, {"introduction": "最后，我们将视角从误差控制转向最优划分。这个高级练习挑战您设计一个子步方案，其目标不仅是“足够精确”，而且要与修正剑桥模型在预定应力路径上的塑性行为达到最优匹配 [@problem_id:3566113]。通过基于屈服面梯度大小来制定划分策略，您将探索一种更复杂的数值积分方法，该方法通过将计算精力集中在塑性流动最活跃的区域来最小化误差。", "problem": "考虑一种由 Modified Cam-Clay (MCC) 屈服函数描述的土壤，其小应变弹塑性积分采用相关联流动法则。令 Cauchy 应力张量表示为 $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{3 \\times 3}$，其中平均应力为 $p = \\tfrac{1}{3} I_1 = \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\sigma})$，偏应力第二不变量为 $J_2 = \\tfrac{1}{2} \\boldsymbol{s}:\\boldsymbol{s}$，这里 $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p \\boldsymbol{I}$，$\\boldsymbol{I}$ 是单位张量。定义不变量 $q = \\sqrt{3 J_2}$，并考虑 Modified Cam-Clay (MCC) 屈服函数 $f(p,q,p_c) = \\dfrac{q^2}{M^2} + p(p - p_c)$，其中 $M  0$ 是 $p$-$q$ 空间中临界状态线的斜率，$p_c  0$ 是先期固结压力。假设采用相关联流动法则，塑性势等于屈服函数，这意味着 $\\Delta \\boldsymbol{\\varepsilon}^p \\propto \\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma})$，塑性应变增量方向由 $\\dfrac{\\Delta \\boldsymbol{\\varepsilon}^p}{\\|\\Delta \\boldsymbol{\\varepsilon}^p\\|}$ 给出。\n\n您将研究一个由 $t \\in [0,1]$ 参数化的预设应力路径，该路径被约束以严格保持在屈服面上：\n- 平均应力为 $p(t) = p_c \\sin^2\\left(\\dfrac{\\pi t}{2}\\right)$。\n- 偏应力不变量为 $q(t) = M \\sqrt{-p(t) \\left(p(t) - p_c\\right)}$。\n- 偏应力方向旋转为 $\\boldsymbol{s}_{\\mathrm{dir}}(t) = \\cos\\left(\\theta(t)\\right) \\, \\boldsymbol{E}_1 + \\sin\\left(\\theta(t)\\right) \\, \\boldsymbol{E}_2$，其中 $\\boldsymbol{E}_1 = \\dfrac{1}{\\sqrt{3}} \\operatorname{diag}(2,-1,-1)$，$\\boldsymbol{E}_2$ 为对称剪切张量，其分量为 $(\\boldsymbol{E}_2)_{12} = (\\boldsymbol{E}_2)_{21} = 1$，其余分量为零。根据具体的测试案例选择 $\\theta(t)$。将偏应力构造为 $\\boldsymbol{s}(t) = \\sqrt{J_2(t)} \\, \\boldsymbol{s}_{\\mathrm{dir}}(t)$，其中 $J_2(t) = \\dfrac{q(t)^2}{3}$，全应力构造为 $\\boldsymbol{\\sigma}(t) = p(t) \\boldsymbol{I} + \\boldsymbol{s}(t)$。\n\n从不变量、MCC 屈服函数和相关联流动法则的核心定义出发，推导梯度 $\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))$ 及其沿该路径的 Frobenius 范数 $\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))\\right\\|_F$。然后，提出并实现一种参数 $t \\in [0,1]$ 的子步划分方案，该方案在以下意义上与最大梯度范数路径对齐：\n- 令 $w(t) = \\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))\\right\\|_F$ 为 $[0,1]$ 上的一个非负权重函数。\n- 给定固定子步数 $N$，定义子步边界 $0 = t_0  t_1  \\dots  t_N = 1$，使得每个子区间都承载相等的累积权重度量 $\\int_0^{t_k} w(\\tau) \\, d\\tau$，即对于 $k = 0,1,\\dots,N$，有 $\\int_0^{t_k} w(\\tau) \\, d\\tau = \\dfrac{k}{N} \\int_0^1 w(\\tau) \\, d\\tau$。\n\n对于每种划分（均匀划分和所提出的梯度范数对齐划分），通过中点求积法近似路径上的净塑性应变方向：\n- 在每个子区间 $[t_{k-1}, t_k]$上，在 $t_{k-1/2} = \\dfrac{t_{k-1} + t_k}{2}$ 处计算 $\\nabla_{\\boldsymbol{\\sigma}} f$，形成增量贡献 $\\boldsymbol{d}_k = \\nabla_{\\boldsymbol{\\sigma}} f\\left(\\boldsymbol{\\sigma}(t_{k-1/2})\\right) \\, \\Delta t_k$（其中 $\\Delta t_k = t_k - t_{k-1}$），然后求和 $\\boldsymbol{D} = \\sum_{k=1}^N \\boldsymbol{d}_k$。近似方向为 $\\widehat{\\boldsymbol{D}} = \\dfrac{\\boldsymbol{D}}{\\|\\boldsymbol{D}\\|_F}$，其中 $\\|\\cdot\\|_F$ 是 $\\mathbb{R}^{3 \\times 3}$ 上的 Frobenius 范数。\n- 使用一个将 $[0,1]$ 划分为 $N_{\\mathrm{ref}}$ 个均匀子区间的精细划分，并采用中点求积法（取 $N_{\\mathrm{ref}} = 5000$），计算一个高保真参考方向 $\\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}$。\n\n将近似 $\\widehat{\\boldsymbol{D}}$ 的方向误差定义为 $e = \\left\\|\\widehat{\\boldsymbol{D}} - \\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}\\right\\|_F$。\n\n测试套件：\n- 案例 1：$M = 1.2$，$p_c = 250$，$N = 12$，$\\theta(t) = \\dfrac{\\pi}{2} t$（偏应力方向旋转）。角度必须以弧度为单位。\n- 案例 2：$M = 1.2$，$p_c = 250$，$N = 4$，$\\theta(t) = \\dfrac{\\pi}{2} t$（更粗的步长）。角度必须以弧度为单位。\n- 案例 3：$M = 0.9$，$p_c = 250$，$N = 12$，$\\theta(t) = \\dfrac{\\pi}{4}$（恒定的偏应力方向）。角度必须以弧度为单位。\n\n对于每个案例，计算两个误差：均匀子步 $t_k = \\dfrac{k}{N}$ 对应的 $e_{\\mathrm{unif}}$，以及由相等累积权重定义的梯度范数对齐子步对应的 $e_{\\mathrm{grad}}$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，格式为 $[e_{\\mathrm{unif,1}}, e_{\\mathrm{grad,1}}, e_{\\mathrm{unif,2}}, e_{\\mathrm{grad,2}}, e_{\\mathrm{unif,3}}, e_{\\mathrm{grad,3}}]$，每个条目都是一个浮点数。输出中不需要物理单位；角度必须以弧度为单位。", "solution": "该问题要求比较两种数值积分方案，用于确定 Modified Cam-Clay (MCC) 材料在承受预设应力路径时产生的净塑性应变方向。第一种方案使用均匀子区间，而第二种方案采用一种具有物理动机的划分策略，该策略将子区间与屈服面梯度的量级对齐。任务的核心在于推导梯度、定义划分方案、执行数值积分，并根据高保真参考解量化每种方案的精度。\n\n解决方案主要分为四个步骤：\n1.  MCC 屈服函数梯度 $\\nabla_{\\boldsymbol{\\sigma}} f$ 的解析推导，该梯度与塑性应变增量方向成正比。\n2.  此梯度的 Frobenius 范数 $\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f\\right\\|_F$ 的解析推导，该范数作为自适应划分的权重函数 $w(t)$。\n3.  两种划分方案的说明：均匀划分和梯度范数对齐划分。后者通过确保每个子区间对总累积权重 $\\int w(t) dt$ 的贡献相等来构建。\n4.  数值求积（中点法则）的实现，用以对每种方案的积分塑性应变方向向量进行近似，并计算相对于参考解的近似误差。\n\n让我们从必要的推导开始。\n\n**1. 塑性流动方向向量的推导**\n\n塑性流动由相关联流动法则控制，这意味着塑性应变增量 $\\Delta\\boldsymbol{\\varepsilon}^p$ 垂直于屈服面 $f(\\boldsymbol{\\sigma}) = 0$。因此，塑性流动的方向由屈服函数对应力的梯度 $\\nabla_{\\boldsymbol{\\sigma}} f$ 给出。屈服函数为 $f(p,q,p_c) = \\dfrac{q^2}{M^2} + p(p - p_c)$。由于 $f$ 是用应力不变量 $p$ 和 $q$ 表示的，我们使用链式法则：\n$$\n\\nabla_{\\boldsymbol{\\sigma}} f = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\frac{\\partial f}{\\partial p} \\frac{\\partial p}{\\partial \\boldsymbol{\\sigma}} + \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}}\n$$\n$f$ 对不变量的偏导数为：\n$$\n\\frac{\\partial f}{\\partial p} = 2p - p_c \\quad \\text{和} \\quad \\frac{\\partial f}{\\partial q} = \\frac{2q}{M^2}\n$$\n不变量对应力张量 $\\boldsymbol{\\sigma}$ 的导数是连续介质力学中的标准结果。对于平均应力 $p = \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma}) = \\frac{1}{3}\\boldsymbol{I}:\\boldsymbol{\\sigma}$，我们有：\n$$\n\\frac{\\partial p}{\\partial \\boldsymbol{\\sigma}} = \\frac{1}{3}\\boldsymbol{I}\n$$\n对于偏应力不变量 $q = \\sqrt{3J_2}$，其中 $J_2 = \\frac{1}{2}\\boldsymbol{s}:\\boldsymbol{s}$ 且 $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p\\boldsymbol{I}$ 是偏应力，我们发现：\n$$\n\\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}} = \\frac{\\partial q}{\\partial J_2} \\frac{\\partial J_2}{\\partial \\boldsymbol{s}} : \\frac{\\partial \\boldsymbol{s}}{\\partial \\boldsymbol{\\sigma}} = \\left(\\frac{\\sqrt{3}}{2\\sqrt{J_2}}\\right) (\\boldsymbol{s}) : \\left(\\mathbb{I} - \\frac{1}{3}\\boldsymbol{I} \\otimes \\boldsymbol{I}\\right) = \\frac{3}{2q} \\boldsymbol{s}\n$$\n其中 $\\mathbb{I}$ 是四阶对称单位张量，我们利用了 $\\operatorname{tr}(\\boldsymbol{s}) = 0$。此结果在 $q \\neq 0$ 时有效。\n\n将这些分量代回链式法则表达式，得到梯度：\n$$\n\\nabla_{\\boldsymbol{\\sigma}} f = (2p - p_c)\\left(\\frac{1}{3}\\boldsymbol{I}\\right) + \\left(\\frac{2q}{M^2}\\right)\\left(\\frac{3}{2q}\\boldsymbol{s}\\right) = \\frac{2p - p_c}{3}\\boldsymbol{I} + \\frac{3}{M^2}\\boldsymbol{s}\n$$\n这个张量 $\\nabla_{\\boldsymbol{\\sigma}} f$ 表示在给定应力状态 $\\boldsymbol{\\sigma}$ 下塑性应变增量的方向。\n\n**2. 梯度范数（权重函数）的推导**\n\n所提出的子步策略使用梯度向量的大小（由其 Frobenius 范数量化）作为权重函数 $w(t) = \\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))\\right\\|_F$。该梯度是两个正交张量的和：一个与单位张量 $\\boldsymbol{I}$ 成比例的体积部分和一个与 $\\boldsymbol{s}$ 成比例的偏量部分。它们的正交性通过 Frobenius 内积得到证实：$\\boldsymbol{I}:\\boldsymbol{s} = \\operatorname{tr}(\\boldsymbol{s}) = 0$。\n因此，Frobenius 范数的平方是这两个部分范数平方的和：\n$$\n\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f\\right\\|_F^2 = \\left\\|\\frac{2p - p_c}{3}\\boldsymbol{I}\\right\\|_F^2 + \\left\\|\\frac{3}{M^2}\\boldsymbol{s}\\right\\|_F^2 = \\left(\\frac{2p - p_c}{3}\\right)^2 \\|\\boldsymbol{I}\\|_F^2 + \\left(\\frac{3}{M^2}\\right)^2 \\|\\boldsymbol{s}\\|_F^2\n$$\n基张量的范数为 $\\|\\boldsymbol{I}\\|_F^2 = 3$ 和 $\\|\\boldsymbol{s}\\|_F^2 = \\boldsymbol{s}:\\boldsymbol{s} = 2J_2 = \\frac{2}{3}q^2$。代入这些值得到：\n$$\n\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f\\right\\|_F^2 = \\frac{(2p - p_c)^2}{9} \\cdot 3 + \\frac{9}{M^4} \\cdot \\frac{2}{3}q^2 = \\frac{(2p - p_c)^2}{3} + \\frac{6q^2}{M^4}\n$$\n现在，我们通过代入预设的应力路径定义，将此范数表示为参数 $t$ 的函数：\n$p(t) = p_c \\sin^2\\left(\\frac{\\pi t}{2}\\right)$\n$q(t) = M \\sqrt{p(t)(p_c - p(t))} = M p_c \\sin\\left(\\frac{\\pi t}{2}\\right)\\cos\\left(\\frac{\\pi t}{2}\\right) = \\frac{M p_c}{2}\\sin(\\pi t)$\n范数表达式中的各项变为：\n$2p(t) - p_c = 2 p_c \\sin^2\\left(\\frac{\\pi t}{2}\\right) - p_c = -p_c\\left(1 - 2\\sin^2\\left(\\frac{\\pi t}{2}\\right)\\right) = -p_c \\cos(\\pi t)$\n$q(t)^2 = \\frac{M^2 p_c^2}{4}\\sin^2(\\pi t)$\n将这些代入范数方程，得到权重函数平方的最终表达式：\n$$\nw(t)^2 = \\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(t)\\right\\|_F^2 = \\frac{(-p_c \\cos(\\pi t))^2}{3} + \\frac{6}{M^4}\\left(\\frac{M^2 p_c^2}{4}\\sin^2(\\pi t)\\right) = \\frac{p_c^2 \\cos^2(\\pi t)}{3} + \\frac{3 p_c^2}{2M^2}\\sin^2(\\pi t)\n$$\n因此，权重函数为 $w(t) = p_c \\sqrt{\\frac{1}{3}\\cos^2(\\pi t) + \\frac{3}{2M^2}\\sin^2(\\pi t)}$。\n\n**3. 子步划分方案**\n\n给定 $N$ 个子步，我们定义一个划分 $0 = t_0  t_1  \\dots  t_N = 1$。\n\n- **均匀划分**：这是最简单的方案，其中每个子区间在参数 $t$ 中具有相等的宽度。节点由 $t_k = \\frac{k}{N}$ 给出，其中 $k = 0, 1, \\dots, N$。\n\n- **梯度范数对齐划分**：该方案旨在根据塑性流动的“活动性”（由 $w(t)$ 衡量）来分配数值计算量。选择划分节点 $t_k$，使得每个子区间 $[t_{k-1}, t_k]$ 包含相等量的总积分权重。设 $H(t) = \\int_0^t w(\\tau) d\\tau$ 为累积权重函数。条件是：\n$$\nH(t_k) = \\frac{k}{N} H(1) \\quad \\text{对于 } k = 1, \\dots, N\n$$\n由于 $H(t)$ 没有简单的闭式反导数，我们必须为每个 $t_k$ 进行数值求解。对于给定的 $k$，我们找到方程 $g(t) = H(t) - \\frac{k}{N}H(1) = 0$ 的根。这可以通过首先使用数值求积（例如 `scipy.integrate.quad`）计算总积分 $H(1) = \\int_0^1 w(\\tau) d\\tau$，然后使用求根算法（例如 `scipy.optimize.brentq`）在区间 $(t_{k-1}, 1]$ 中找到每个 $t_k$ 来实现。\n\n**4. 数值近似与误差度量**\n\n路径上的净塑性应变方向与积分 $\\int_0^1 \\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t)) dt$ 成比例。我们使用中点求积法则在给定划分 $\\{t_k\\}_{k=0}^N$ 上近似此积分（表示为张量 $\\boldsymbol{D}$）：\n$$\n\\boldsymbol{D} = \\sum_{k=1}^N \\nabla_{\\boldsymbol{\\sigma}} f\\left(\\boldsymbol{\\sigma}(t_{k-1/2})\\right) \\Delta t_k\n$$\n其中 $\\Delta t_k = t_k - t_{k-1}$ 且 $t_{k-1/2} = \\frac{t_{k-1} + t_k}{2}$。最终的近似方向是归一化张量 $\\widehat{\\boldsymbol{D}} = \\frac{\\boldsymbol{D}}{\\|\\boldsymbol{D}\\|_F}$。\n\n为评估精度，使用相同的中点法则但在一个非常精细的 $N_{\\mathrm{ref}} = 5000$ 个子区间的均匀划分上计算一个高保真参考方向 $\\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}$。然后，近似 $\\widehat{\\boldsymbol{D}}$ 的误差计算为差值的 Frobenius 范数：\n$$\ne = \\left\\|\\widehat{\\boldsymbol{D}} - \\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}\\right\\|_F\n$$\n此过程应用于每个测试案例的均匀划分和梯度范数对齐划分，分别得到误差 $e_{\\mathrm{unif}}$ 和 $e_{\\mathrm{grad}}$。预期结果是 $e_{\\mathrm{grad}}  e_{\\mathrm{unif}}$，这表明自适应方案的优越性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing substepping strategies for plasticity\n    integration with the Modified Cam-Clay model.\n    \"\"\"\n\n    # --- Constants and Basis Tensors ---\n    E1 = (1 / np.sqrt(3)) * np.diag([2.0, -1.0, -1.0])\n    E2 = np.array([[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    ID_TENSOR = np.eye(3)\n    N_REF = 5000\n\n    # --- Path-dependent Helper Functions ---\n    def p_func(t, pc):\n        \"\"\"Mean stress p as a function of t.\"\"\"\n        return pc * np.sin(0.5 * np.pi * t)**2\n\n    def q_func(t, M, pc):\n        \"\"\"Deviatoric invariant q as a function of t.\"\"\"\n        return (M * pc / 2.0) * np.sin(np.pi * t)\n\n    def theta_func(t, theta_type):\n        \"\"\"Deviatoric rotation angle theta as a function of t.\"\"\"\n        if theta_type == 'pi/2*t':\n            return 0.5 * np.pi * t\n        elif theta_type == 'pi/4':\n            # This is a constant function of t\n            return 0.25 * np.pi\n        else:\n            raise ValueError(f\"Unknown theta function type: {theta_type}\")\n\n    def get_stress_and_gradient(t, M, pc, theta_type):\n        \"\"\"\n        Computes stress tensor and gradient of yield function at a given t.\n        \"\"\"\n        p_val = p_func(t, pc)\n        q_val = q_func(t, M, pc)\n        \n        # Deviatoric stress s\n        theta_val = theta_func(t, theta_type)\n        s_dir_val = np.cos(theta_val) * E1 + np.sin(theta_val) * E2\n        s_val = (q_val / np.sqrt(3.0)) * s_dir_val\n        \n        # Gradient of yield function\n        grad_f = ((2.0 * p_val - pc) / 3.0) * ID_TENSOR + (3.0 / M**2) * s_val\n        \n        return grad_f\n\n    def w_func(t, M, pc):\n        \"\"\"\n        Weight function: Frobenius norm of the yield function gradient.\n        This is the analytical simplified form.\n        \"\"\"\n        if -1e-9  t  1e-9 or 1-1e-9  t  1+1e-9:\n             return pc / np.sqrt(3.0)\n\n        cos_pit = np.cos(np.pi * t)\n        sin_pit = np.sin(np.pi * t)\n        \n        term1 = cos_pit**2 / 3.0\n        term2 = (3.0 / (2.0 * M**2)) * sin_pit**2\n        \n        return pc * np.sqrt(term1 + term2)\n\n    def compute_D_hat(partition, M, pc, theta_type):\n        \"\"\"\n        Approximates the integrated plastic strain direction tensor using\n        midpoint quadrature over a given partition.\n        \"\"\"\n        D_sum = np.zeros((3, 3))\n        for k in range(1, len(partition)):\n            t_k_minus_1 = partition[k-1]\n            t_k = partition[k]\n            dt_k = t_k - t_k_minus_1\n            t_mid = 0.5 * (t_k_minus_1 + t_k)\n            \n            grad_mid = get_stress_and_gradient(t_mid, M, pc, theta_type)\n            D_sum += grad_mid * dt_k\n            \n        D_norm = np.linalg.norm(D_sum, 'fro')\n        if D_norm  1e-15:\n            # This case should not be reached with the given paths\n            return D_sum\n        return D_sum / D_norm\n\n    # --- Test Suite ---\n    test_cases = [\n        {'M': 1.2, 'pc': 250.0, 'N': 12, 'theta_type': 'pi/2*t'},\n        {'M': 1.2, 'pc': 250.0, 'N': 4,  'theta_type': 'pi/2*t'},\n        {'M': 0.9, 'pc': 250.0, 'N': 12, 'theta_type': 'pi/4'}\n    ]\n    \n    results = []\n    \n    for case_params in test_cases:\n        M = case_params['M']\n        pc = case_params['pc']\n        N = case_params['N']\n        theta_type = case_params['theta_type']\n\n        # 1. Compute Reference Solution\n        t_ref_partition = np.linspace(0.0, 1.0, N_REF + 1)\n        D_hat_ref = compute_D_hat(t_ref_partition, M, pc, theta_type)\n\n        # 2. Uniform Partition Calculation\n        t_unif_partition = np.linspace(0.0, 1.0, N + 1)\n        D_hat_unif = compute_D_hat(t_unif_partition, M, pc, theta_type)\n        error_unif = np.linalg.norm(D_hat_unif - D_hat_ref, 'fro')\n        results.append(error_unif)\n        \n        # 3. Gradient-Norm-Aligned Partition Calculation\n        integrand = lambda t: w_func(t, M, pc)\n        total_weight, _ = integrate.quad(integrand, 0, 1)\n\n        t_grad_partition = [0.0]\n        \n        def root_func(t, target_weight):\n            res, _ = integrate.quad(integrand, 0.0, t)\n            return res - target_weight\n        \n        for k in range(1, N):\n            target_weight_k = (k / N) * total_weight\n            # The root must be between the last point and 1\n            t_k = optimize.brentq(root_func, t_grad_partition[-1], 1.0, args=(target_weight_k,))\n            t_grad_partition.append(t_k)\n            \n        t_grad_partition.append(1.0)\n        t_grad_partition = np.array(t_grad_partition)\n\n        D_hat_grad = compute_D_hat(t_grad_partition, M, pc, theta_type)\n        error_grad = np.linalg.norm(D_hat_grad - D_hat_ref, 'fro')\n        results.append(error_grad)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3566113"}]}