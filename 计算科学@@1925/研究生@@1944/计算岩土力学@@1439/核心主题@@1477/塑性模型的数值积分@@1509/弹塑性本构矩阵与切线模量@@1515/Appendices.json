{"hands_on_practices": [{"introduction": "理论学习的最佳补充是实践。我们的第一个练习将通过一个简单的一维模型直观地展示弹塑性一致性切线模量的威力。通过对比使用一致性切线和仅使用弹性模量的牛顿求解器，您将亲眼见证前者如何确保二次收敛速度，从而深刻理解为何在非线性有限元分析中追求“一致性”是至关重要的。[@problem_id:3522215]", "problem": "考虑一个具有线性各向同性硬化的一维、小应变、率无关弹塑性材料。设总应变表示为 $\\varepsilon$，应力为 $\\sigma$，弹性模量为 $E$（单位为 $\\mathrm{Pa}$），初始屈服应力为 $\\sigma_{y0}$（单位为 $\\mathrm{Pa}$），塑性模量为 $H$（单位为 $\\mathrm{Pa}$）。假设在拉伸状态下单调加载，因此塑性流动方向为正。该材料遵循加法应变分解和标准小应变弹塑性理论，具有线性各向同性硬化、凸屈服函数、关联流动和 Karush-Kuhn-Tucker 条件。单个材料点承受给定的牵引力 $T$（单位为 $\\mathrm{Pa}$）；通过使用牛顿法求解标量方程 $R(\\varepsilon) = \\sigma(\\varepsilon) - T = 0$ 来强制实现材料点的平衡，以求得 $\\varepsilon$。\n\n仅从标准小应变弹塑性、带线性各向同性硬化的凸屈服函数、关联流动和一致性条件的基本定义出发，推导应用于标量平衡方程 $R(\\varepsilon)=0$ 的牛顿法实现二次收敛所需的算法弹塑性切线模量 $D^{ep}$。然后，设计并实现一个基准测试来比较：\n- 一个在迭代中使用算法 $D^{ep}$（即一致切线模量）作为雅可比 $d\\sigma/d\\varepsilon$ 的牛顿求解器，\n- 与一个基于弹性预测-塑性修正且不使用一致切线的牛顿求解器相比较，该求解器在整个迭代过程中（即使在屈服后）都使用弹性模量 $E$ 作为雅可比 $d\\sigma/d\\varepsilon$。\n\n你的程序必须：\n1. 基于带有线性各向同性硬化的标准返回映射概念，为所述材料点实现一个物理上可接受的应力-应变响应 $\\sigma(\\varepsilon)$，确保 $\\sigma(\\varepsilon)$ 在 $\\varepsilon$ 上是连续且分段可微的。\n2. 为标量方程 $R(\\varepsilon)=\\sigma(\\varepsilon)-T=0$ 实现两个牛顿求解器：\n   - 求解器 A：在塑性加载时使用算法弹塑性切线模量 $D^{ep}$ 作为雅可比 $d\\sigma/d\\varepsilon$，在弹性加载时使用弹性模量 $E$。\n   - 求解器 B：在所有迭代中仅使用弹性模量 $E$ 作为雅可比 $d\\sigma/d\\varepsilon$，即在塑性加载中不使用一致切线。\n3. 使用 $10^{0}$ $\\mathrm{Pa}$ 的固定残差容差，即当 $|R(\\varepsilon)| \\leq 10^{0}$ $\\mathrm{Pa}$ 时宣告收敛。使用最大牛顿迭代次数为 $1000$。\n4. 为每个测试用例计算并报告以下误差度量：\n   - 求解器 A 和求解器 B 达到收敛所需的牛顿迭代次数（每个都是整数）。\n   - 一个布尔值，指示求解器 A 和求解器 B 是否在迭代限制内达到了收敛。\n   - 绝对应变误差 $|\\varepsilon_{\\text{num}} - \\varepsilon_{\\text{exact}}|$（无量纲），其中 $\\varepsilon_{\\text{exact}}$ 是通过强制执行从第一性原理推导出的弹性或塑性状态条件而解析获得的精确闭式解。\n   - 求解器 A 和求解器 B 在终止时的最终残差 $|R(\\varepsilon)|$（单位为 $\\mathrm{Pa}$）。\n5. 使用以下测试套件，每个用例由 $(E,\\sigma_{y0},H,T)$ 定义，所有模量和牵引力的单位均为 $\\mathrm{Pa}$：\n   - 情况 1：$(200 \\times 10^9, 400 \\times 10^6, 10 \\times 10^9, 300 \\times 10^6)$，一个弹性情况。\n   - 情况 2：$(200 \\times 10^9, 400 \\times 10^6, 10 \\times 10^9, 400 \\times 10^6)$，在弹塑性边界上。\n   - 情况 3：$(200 \\times 10^9, 400 \\times 10^6, 10 \\times 10^9, 800 \\times 10^6)$，一个中等硬化的塑性情况。\n   - 情况 4：$(200 \\times 10^9, 400 \\times 10^6, 0.5 \\times 10^9, 800 \\times 10^6)$，一个弱硬化的塑性情况，强调了一致切线的必要性。\n   - 情况 5：$(200 \\times 10^9, 400 \\times 10^6, 100 \\times 10^9, 1200 \\times 10^6)$，一个强硬化的塑性情况，其行为接近弹性。\n6. 对所有测试用例使用初始猜测值 $\\varepsilon_0 = 0$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形如 $[\\text{itersA},\\text{itersB},\\text{convA},\\text{convB},\\text{errA},\\text{errB},\\text{resA},\\text{resB}]$ 的列表。因此，最终输出必须是五个此类列表的列表，每个测试用例一个，例如 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$。\n\n所有物理量均以指定单位作答：模量和应力以 $\\mathrm{Pa}$ 为单位，应变为无量纲。不涉及角度。所有布尔值必须是 Python 布尔值。所有浮点和整数输出必须是原始数值，不得四舍五入或带单位格式化。", "solution": "该问题经评估有效。这是一个在计算塑性力学领域内适定且有科学依据的问题，为获得唯一解提供了所有必要的数据和条件。\n\n### 1. 基本本构关系\n问题描述了一个具有线性各向同性硬化的一维、率无关弹塑性材料，在初始无应力状态下承受单调拉伸加载。其控制关系如下：\n\n- **应变分解**：总应变 $\\varepsilon$ 是弹性应变 $\\varepsilon^e$ 和塑性应变 $\\varepsilon^p$ 的和。\n  $$ \\varepsilon = \\varepsilon^e + \\varepsilon^p $$\n- **弹性定律**：应力 $\\sigma$ 通过胡克定律与弹性应变相关，弹性模量为 $E$。\n  $$ \\sigma = E \\varepsilon^e $$\n- **屈服条件**：当应力达到当前屈服强度 $\\sigma_y$ 时，塑性流动开始。对于单调拉伸（$\\sigma \\ge 0$），屈服函数 $f$ 为：\n  $$ f(\\sigma, \\alpha) = \\sigma - \\sigma_y(\\alpha) \\le 0 $$\n- **线性各向同性硬化**：屈服强度 $\\sigma_y$ 随等效塑性应变 $\\alpha$ 线性演化，从初始屈服应力 $\\sigma_{y0}$ 开始，塑性模量为 $H$。\n  $$ \\sigma_y(\\alpha) = \\sigma_{y0} + H\\alpha $$\n- **流动法则和塑性应变**：对于此一维拉伸情况，关联流动法则简化为塑性应变率等于塑性乘子率，即 $\\dot{\\varepsilon}^p = \\dot{\\gamma}$。此外，等效塑性应变率为 $\\dot{\\alpha} = |\\dot{\\varepsilon}^p| = \\dot{\\varepsilon}^p$（因为 $\\dot{\\varepsilon}^p \\ge 0$）。从初始状态随时间积分，我们发现累积塑性应变等于等效塑性应变，即 $\\varepsilon^p = \\alpha$。\n  因此，屈服条件可以写成 $\\varepsilon^p$ 的形式：\n  $$ f = \\sigma - (\\sigma_{y0} + H\\varepsilon^p) \\le 0 $$\n\n### 2. 应力-应变关系 $\\sigma(\\varepsilon)$ 的推导\n对于从 $\\varepsilon=0$ 开始的单调拉伸加载下的给定总应变 $\\varepsilon$，我们可以确定应力 $\\sigma$。初始屈服应变为 $\\varepsilon_y = \\sigma_{y0}/E$。\n\n- **弹性区域** ($\\varepsilon \\le \\varepsilon_y$)：不发生塑性变形（$\\varepsilon^p=0$）。总应变为纯弹性应变，$\\varepsilon = \\varepsilon^e$。\n  $$ \\sigma(\\varepsilon) = E\\varepsilon $$\n- **塑性区域** ($\\varepsilon  \\varepsilon_y$)：材料屈服。状态必须满足屈服条件，$\\sigma = \\sigma_y = \\sigma_{y0} + H\\varepsilon^p$。我们还有 $\\sigma = E\\varepsilon^e = E(\\varepsilon-\\varepsilon^p)$。令这两个 $\\sigma$ 的表达式相等：\n  $$ E(\\varepsilon - \\varepsilon^p) = \\sigma_{y0} + H\\varepsilon^p $$\n  求解塑性应变 $\\varepsilon^p$：\n  $$ E\\varepsilon - \\sigma_{y0} = (E+H)\\varepsilon^p \\implies \\varepsilon^p = \\frac{E\\varepsilon - \\sigma_{y0}}{E+H} $$\n  将此结果代回弹性定律，以求得以 $\\varepsilon$ 表示的 $\\sigma$：\n  $$ \\sigma(\\varepsilon) = E(\\varepsilon - \\varepsilon^p) = E\\left(\\varepsilon - \\frac{E\\varepsilon - \\sigma_{y0}}{E+H}\\right) = \\frac{E(E+H)\\varepsilon - E(E\\varepsilon - \\sigma_{y0})}{E+H} = \\frac{EH\\varepsilon + E\\sigma_{y0}}{E+H} $$\n单调拉伸下完整、连续且分段可微的应力-应变关系 $\\sigma(\\varepsilon)$ 是：\n$$\n\\sigma(\\varepsilon) = \\begin{cases}\n    E\\varepsilon  \\text{if } \\varepsilon \\le \\sigma_{y0}/E \\\\\n    \\frac{EH\\varepsilon + E\\sigma_{y0}}{E+H}  \\text{if } \\varepsilon  \\sigma_{y0}/E\n\\end{cases}\n$$\n\n### 3. 算法（一致）切线模量 $D^{ep}$ 的推导\n该问题要求使用牛顿法求解非线性平衡方程 $R(\\varepsilon) = \\sigma(\\varepsilon) - T = 0$。该方程的雅可比是 $R'(\\varepsilon) = d\\sigma/d\\varepsilon$。为了实现二次收敛，该雅可比必须是*一致切线模量*，即应力更新算法的精确导数。对于这种一维率无关的情况，这对应于上面推导的 $\\sigma(\\varepsilon)$ 函数的导数。\n\n- **弹性切线**：在弹性区域（$\\varepsilon \\le \\sigma_{y0}/E$）：\n  $$ D^e = \\frac{d}{d\\varepsilon}(E\\varepsilon) = E $$\n- **弹塑性切线**：在塑性区域（$\\varepsilon  \\sigma_{y0}/E$）：\n  $$ D^{ep} = \\frac{d}{d\\varepsilon}\\left(\\frac{EH\\varepsilon + E\\sigma_{y0}}{E+H}\\right) = \\frac{EH}{E+H} $$\n这个 $D^{ep}$ 就是塑性加载的算法切线模量。\n\n### 4. 牛顿法与求解器实现\n寻找满足 $R(\\varepsilon)=0$ 的 $\\varepsilon$ 的牛顿-拉夫逊迭代法是：\n$$ \\varepsilon_{k+1} = \\varepsilon_{k} - \\frac{R(\\varepsilon_k)}{J_k} $$\n其中 $\\varepsilon_k$ 是第 $k$ 次迭代时的应变，$R(\\varepsilon_k) = \\sigma(\\varepsilon_k) - T$ 是残差，$J_k$ 是雅可比。\n\n- **求解器 A（一致切线）**：使用真实雅可比，从而实现二次收敛。\n  $$ J_k = \\frac{d\\sigma}{d\\varepsilon}\\bigg|_{\\varepsilon_k} = \\begin{cases} E  \\text{if } \\varepsilon_k \\le \\sigma_{y0}/E \\\\ \\frac{EH}{E+H}  \\text{if } \\varepsilon_k  \\sigma_{y0}/E \\end{cases} $$\n- **求解器 B（弹性切线）**：在所有迭代中都使用弹性模量 $E$ 作为雅可比。\n  $$ J_k = E $$\n  当材料处于塑性状态时，这个雅可比是不正确的，收敛速度会降为线性。求解器 A 和 B 之间的性能差异在一致切线 $D^{ep}$ 与弹性切线 $E$ 相差悬殊时最为显著，这种情况发生在塑性模量 $H$ 值较低时。\n\n### 5. 精确解析解 $\\varepsilon_{\\text{exact}}$\n为了计算数值误差，我们推导满足 $\\sigma(\\varepsilon_{\\text{exact}}) = T$ 的精确解 $\\varepsilon_{\\text{exact}}$。\n\n- **如果 $T \\le \\sigma_{y0}$（弹性）**：\n  $$ E\\varepsilon_{\\text{exact}} = T \\implies \\varepsilon_{\\text{exact}} = \\frac{T}{E} $$\n- **如果 $T  \\sigma_{y0}$（塑性）**：\n  $$ \\frac{EH\\varepsilon_{\\text{exact}} + E\\sigma_{y0}}{E+H} = T \\implies EH\\varepsilon_{\\text{exact}} = T(E+H) - E\\sigma_{y0} $$\n  $$ \\varepsilon_{\\text{exact}} = \\frac{T(E+H) - E\\sigma_{y0}}{EH} = \\frac{T}{H} + \\frac{T}{E} - \\frac{\\sigma_{y0}}{H} $$\n  或者，使用应变分解 $\\varepsilon = \\varepsilon^e + \\varepsilon^p$：\n  $$ \\varepsilon^e = \\sigma/E = T/E $$\n  $$ \\sigma = T = \\sigma_{y0} + H\\varepsilon^p \\implies \\varepsilon^p = \\frac{T-\\sigma_{y0}}{H} $$\n  $$ \\varepsilon_{\\text{exact}} = \\varepsilon^e + \\varepsilon^p = \\frac{T}{E} + \\frac{T-\\sigma_{y0}}{H} $$\n  这两种塑性情况下的形式是相同的。这个解析解提供了用于比较数值结果的基准。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the strain in a 1D elastoplastic material under a given traction,\n    comparing a Newton solver using the consistent tangent modulus with one\n    using only the elastic modulus as the Jacobian.\n    \"\"\"\n    \n    # Define the test suite as specified in the problem statement.\n    # Each case is a tuple: (E, sigma_y0, H, T) in Pa.\n    test_cases = [\n        (200e9, 400e6, 10e9, 300e6),    # Case 1: Elastic\n        (200e9, 400e6, 10e9, 400e6),    # Case 2: At yield boundary\n        (200e9, 400e6, 10e9, 800e6),    # Case 3: Plastic, moderate hardening\n        (200e9, 400e6, 0.5e9, 800e6),   # Case 4: Plastic, weak hardening\n        (200e9, 400e6, 100e9, 1200e6),  # Case 5: Plastic, strong hardening\n    ]\n\n    results = []\n\n    for E, sigma_y0, H, T in test_cases:\n        \n        # 1. Calculate the exact analytical solution for strain.\n        if T = sigma_y0:\n            # Elastic case\n            epsilon_exact = T / E\n        else:\n            # Plastic case: epsilon = elastic_strain + plastic_strain\n            # elastic_strain = T / E\n            # plastic_strain = (T - sigma_y0) / H\n            epsilon_exact = T / E + (T - sigma_y0) / H\n\n        # 2. Define the Newton solver.\n        def newton_solver(use_consistent_tangent):\n            \"\"\"\n            Performs Newton-Raphson iterations to solve R(e) = sigma(e) - T = 0.\n            \n            Args:\n                use_consistent_tangent (bool): If True, uses the algorithmic tangent\n                                               modulus (Solver A). If False, uses the\n                                               elastic modulus (Solver B).\n            Returns:\n                A tuple containing the final strain, number of iterations,\n                convergence status, and final residual.\n            \"\"\"\n            epsilon = 0.0\n            max_iter = 1000\n            tolerance = 1.0  # Pa, as specified\n            \n            def get_stress_and_tangent(current_epsilon):\n                \"\"\"\n                Computes stress and consistent tangent for a given total strain,\n                assuming monotonic loading from a virgin state.\n                \"\"\"\n                epsilon_yield = sigma_y0 / E\n                \n                # Check if the state is elastic or plastic\n                if current_epsilon = epsilon_yield:\n                    sigma = E * current_epsilon\n                    tangent = E\n                else:\n                    sigma = (E * H * current_epsilon + E * sigma_y0) / (E + H)\n                    tangent = (E * H) / (E + H)\n                return sigma, tangent\n\n            for i in range(max_iter):\n                sigma, tangent_consistent = get_stress_and_tangent(epsilon)\n                residual = sigma - T\n                \n                if abs(residual) = tolerance:\n                    return epsilon, i + 1, True, abs(residual)\n                \n                jacobian = tangent_consistent if use_consistent_tangent else E\n                \n                # Prevent division by zero, although not expected in these test cases\n                if abs(jacobian)  1e-12:\n                    break\n                    \n                delta_epsilon = -residual / jacobian\n                epsilon += delta_epsilon\n            \n            # If the loop completes without converging\n            final_sigma, _ = get_stress_and_tangent(epsilon)\n            final_residual = abs(final_sigma - T)\n            return epsilon, max_iter, False, final_residual\n\n        # 3. Run both solvers and collect metrics.\n        \n        # Solver A (Consistent Tangent)\n        eps_A, iters_A, conv_A, res_A = newton_solver(use_consistent_tangent=True)\n        err_A = abs(eps_A - epsilon_exact)\n\n        # Solver B (Elastic Tangent)\n        eps_B, iters_B, conv_B, res_B = newton_solver(use_consistent_tangent=False)\n        err_B = abs(eps_B - epsilon_exact)\n\n        # 4. Store the results for the current test case.\n        case_result = [iters_A, iters_B, conv_A, conv_B, err_A, err_B, res_A, res_B]\n        results.append(case_result)\n\n    # 5. Format and print the final output string.\n    # Using repr() to get an unambiguous string representation of the list of lists,\n    # then removing spaces to create a compact output as per the problem's implicit format.\n    final_output_str = repr(results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "3522215"}, {"introduction": "在理解了一致性切线的重要性之后，下一个关键步骤是掌握其推导过程。本练习将指导您为标准的三维$J_2$（von Mises）弹塑性模型推导连续介质弹塑性切线张量。您将学习如何从本构关系出发，推导出四阶切线张量，并将其转换为有限元实现中常用的Voigt矩阵形式，同时确保能量守恒，这是连接理论与代码的关键一步。[@problem_id:3522229]", "problem": "在有限元 (FE) 实现中，使用了一种小应变、各向同性、关联流动的 von Mises（第二偏应力不变量，$J_{2}$）弹塑性材料，该材料具有线性各向同性硬化特性。其弹性响应由体积模量 $K$ 和剪切模量 $G$ 定义，因此对于任意对称应变张量 $\\boldsymbol{\\epsilon}$，弹性应力为 $\\boldsymbol{\\sigma}^{e} = \\mathbb{C}^{e} : \\boldsymbol{\\epsilon}$，其中四阶弹性刚度为 $\\mathbb{C}^{e} = K\\,\\mathbf{I} \\otimes \\mathbf{I} + 2 G\\,\\mathbb{I}^{s}$。此处 $\\mathbf{I}$ 是二阶单位张量，$\\mathbb{I}^{s}$ 是对称四阶单位张量。屈服函数为 $f(\\boldsymbol{\\sigma},\\alpha) = \\sigma_{\\mathrm{eq}} - \\sigma_{y0} - H \\alpha$，其中 $\\sigma_{\\mathrm{eq}} = \\sqrt{\\frac{3}{2}\\,\\boldsymbol{s}:\\boldsymbol{s}}$，$\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3}\\,\\mathrm{tr}(\\boldsymbol{\\sigma})\\,\\mathbf{I}$ 是偏应力，$\\sigma_{y0}$ 是初始屈服应力，$H$ 是塑性模量，$\\alpha$ 是累积塑性应变。流动法则是关联的，$\\dot{\\boldsymbol{\\epsilon}}^{p} = \\dot{\\lambda}\\,\\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$，硬化定律为 $\\dot{\\alpha} = \\dot{\\lambda}$。\n\n在 Newton 迭代中一个已收敛的材料点上，假设处于塑性状态 ($\\dot{\\lambda} \\ge 0$)，并用 $\\boldsymbol{n} = \\boldsymbol{s}/\\|\\boldsymbol{s}\\|$ 表示单位偏应力方向，用 $\\boldsymbol{m} = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\sqrt{\\frac{3}{2}}\\,\\boldsymbol{n}$ 表示塑性流动方向。连续介质弹塑性切线模量（四阶张量）定义为在率形式的本构方程 $\\dot{\\boldsymbol{\\sigma}} = \\mathbb{C}^{ep} : \\dot{\\boldsymbol{\\epsilon}}$ 中关联应力率和应变率的张量，从而保持内功率守恒，即 $\\dot{W} = \\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}}$。\n\n您的任务是，将连续介质弹塑性切线模量表示为适用于有限元实现的六分量 Voigt 形式，对应变类向量使用工程剪切约定，并确保与所选的材料时间率的能量一致性。具体而言：\n\n1. 定义应变和应力的能量一致性 Voigt 映射：\n   $$\\boldsymbol{\\epsilon}^{V} = \\begin{pmatrix}\\epsilon_{11} \\\\ \\epsilon_{22} \\\\ \\epsilon_{33} \\\\ 2\\,\\epsilon_{23} \\\\ 2\\,\\epsilon_{13} \\\\ 2\\,\\epsilon_{12}\\end{pmatrix}, \\qquad \\boldsymbol{\\sigma}^{V} = \\begin{pmatrix}\\sigma_{11} \\\\ \\sigma_{22} \\\\ \\sigma_{33} \\\\ \\sigma_{23} \\\\ \\sigma_{13} \\\\ \\sigma_{12}\\end{pmatrix},$$\n   并验证 $\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}} = (\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V}$。\n\n2. 从小应变运动学、各向同性弹性、关联流动法则以及 $J_{2}$ 模型的一致性条件出发，推导塑性状态下的四阶连续介质弹塑性切线模量，并证明其可以写为\n   $$\\mathbb{C}^{ep} = \\mathbb{C}^{e} - \\frac{4 G^{2}}{H + 3 G}\\,\\boldsymbol{m} \\otimes \\boldsymbol{m},$$\n   其中 $\\boldsymbol{m} = \\sqrt{\\frac{3}{2}}\\,\\boldsymbol{n}$。\n\n3. 使用能量一致性映射和工程剪切约定，给出 $6 \\times 6$ 的 Voigt 矩阵 $\\mathbf{C}^{ep, V}$，使得 $\\dot{\\boldsymbol{\\sigma}}^{V} = \\mathbf{C}^{ep, V}\\,\\dot{\\boldsymbol{\\epsilon}}^{V}$。将结果以闭合形式表示为弹性 Voigt 矩阵与一个由 $\\boldsymbol{m}$ 的应力类 Voigt 映射\n   $$\\boldsymbol{m}_{\\sigma}^{V} = \\begin{pmatrix}m_{11} \\\\ m_{22} \\\\ m_{33} \\\\ m_{23} \\\\ m_{13} \\\\ m_{12}\\end{pmatrix},$$\n   构造的秩一修正项之和，并确保该映射保持内功率守恒 $\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}} = (\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V}$。\n\n请将您的最终答案表示为关于 $K$、$G$、$H$ 及分量 $m_{ij}$ 的单一闭合形式解析表达式。无需进行数值计算。", "solution": "该问题是有效的，因为它代表了计算塑性力学领域中一个标准的、适定的推导。它具有科学依据，是客观的，并且包含了推导所要求的 $J_2$ 塑性模型的连续介质弹塑性切线模量所需的所有必要信息。\n\n推导将分三个阶段进行：首先，验证指定的 Voigt 映射的能量一致性；其次，推导四阶连续介质弹塑性切线张量 $\\mathbb{C}^{ep}$；最后，将该张量转换为其 $6 \\times 6$ 的 Voigt 矩阵表示 $\\mathbf{C}^{ep, V}$。\n\n**1. 能量一致性 Voigt 映射的验证**\n\n内功率，表示应力对应变率所做功的速率，由双点积 $\\dot{W} = \\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}}$ 给出。对于对称的应力 $\\boldsymbol{\\sigma}$ 和应变率 $\\dot{\\boldsymbol{\\epsilon}}$ 张量，其展开式为：\n$$\n\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}} = \\sum_{i=1}^{3} \\sum_{j=1}^{3} \\sigma_{ij} \\dot{\\epsilon}_{ij} = \\sigma_{11}\\dot{\\epsilon}_{11} + \\sigma_{22}\\dot{\\epsilon}_{22} + \\sigma_{33}\\dot{\\epsilon}_{33} + 2\\sigma_{12}\\dot{\\epsilon}_{12} + 2\\sigma_{13}\\dot{\\epsilon}_{13} + 2\\sigma_{23}\\dot{\\epsilon}_{23}\n$$\n问题将应力类和应变类 Voigt 向量定义为：\n$$\n\\boldsymbol{\\sigma}^{V} = \\begin{pmatrix}\\sigma_{11} \\\\ \\sigma_{22} \\\\ \\sigma_{33} \\\\ \\sigma_{23} \\\\ \\sigma_{13} \\\\ \\sigma_{12}\\end{pmatrix}, \\qquad \\dot{\\boldsymbol{\\epsilon}}^{V} = \\begin{pmatrix}\\dot{\\epsilon}_{11} \\\\ \\dot{\\epsilon}_{22} \\\\ \\dot{\\epsilon}_{33} \\\\ 2\\dot{\\epsilon}_{23} \\\\ 2\\dot{\\epsilon}_{13} \\\\ 2\\dot{\\epsilon}_{12}\\end{pmatrix}\n$$\n它们转置的点积为：\n$$\n(\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V} = \\begin{pmatrix}\\sigma_{11}  \\sigma_{22}  \\sigma_{33}  \\sigma_{23}  \\sigma_{13}  \\sigma_{12}\\end{pmatrix} \\begin{pmatrix}\\dot{\\epsilon}_{11} \\\\ \\dot{\\epsilon}_{22} \\\\ \\dot{\\epsilon}_{33} \\\\ 2\\dot{\\epsilon}_{23} \\\\ 2\\dot{\\epsilon}_{13} \\\\ 2\\dot{\\epsilon}_{12}\\end{pmatrix}\n$$\n$$\n(\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V} = \\sigma_{11}\\dot{\\epsilon}_{11} + \\sigma_{22}\\dot{\\epsilon}_{22} + \\sigma_{33}\\dot{\\epsilon}_{33} + \\sigma_{23}(2\\dot{\\epsilon}_{23}) + \\sigma_{13}(2\\dot{\\epsilon}_{13}) + \\sigma_{12}(2\\dot{\\epsilon}_{12})\n$$\n该表达式与基于张量的内功率相同。因此，条件 $\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}} = (\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V}$ 得以验证，确认了所选映射的能量一致性。这对于将本构张量正确转换为矩阵形式至关重要。\n\n**2. 四阶连续介质弹塑性切线张量的推导**\n\n我们将推导连续介质弹塑性切线模量，它是在率形式的本构方程中定义的。这与算法切线模量不同，后者是离散应力更新算法的精确线性化。连续介质模量的推导始于一致性条件 $\\dot{f}=0$。\n\n对于关联流动，$\\dot{f} = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} : \\dot{\\boldsymbol{\\sigma}} + \\frac{\\partial f}{\\partial \\alpha}\\dot{\\alpha} = 0$。\n使用给定的定义，$\\boldsymbol{m} = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$，$\\frac{\\partial f}{\\partial \\alpha} = -H$，以及 $\\dot{\\alpha}=\\dot{\\lambda}$，我们得到：\n$\\boldsymbol{m}:\\dot{\\boldsymbol{\\sigma}} - H\\dot{\\lambda} = 0 \\implies \\boldsymbol{m}:\\dot{\\boldsymbol{\\sigma}} = H\\dot{\\lambda}$。\n\n应力率由弹性定律给出：$\\dot{\\boldsymbol{\\sigma}} = \\mathbb{C}^e : \\dot{\\boldsymbol{\\epsilon}}^e = \\mathbb{C}^e : (\\dot{\\boldsymbol{\\epsilon}} - \\dot{\\boldsymbol{\\epsilon}}^p)$。\n将流动法则 $\\dot{\\boldsymbol{\\epsilon}}^p = \\dot{\\lambda}\\boldsymbol{m}$ 代入：\n$\\dot{\\boldsymbol{\\sigma}} = \\mathbb{C}^e : (\\dot{\\boldsymbol{\\epsilon}} - \\dot{\\lambda}\\boldsymbol{m})$。\n\n将此 $\\dot{\\boldsymbol{\\sigma}}$ 的表达式代入一致性条件 $\\boldsymbol{m}:\\dot{\\boldsymbol{\\sigma}} = H\\dot{\\lambda}$ 中：\n$\\boldsymbol{m}:[\\mathbb{C}^e : (\\dot{\\boldsymbol{\\epsilon}} - \\dot{\\lambda}\\boldsymbol{m})] = H\\dot{\\lambda}$\n$\\boldsymbol{m}:\\mathbb{C}^e:\\dot{\\boldsymbol{\\epsilon}} - \\dot{\\lambda}(\\boldsymbol{m}:\\mathbb{C}^e:\\boldsymbol{m}) = H\\dot{\\lambda}$\n求解塑性乘子率 $\\dot{\\lambda}$：\n$\\dot{\\lambda} = \\frac{\\boldsymbol{m}:\\mathbb{C}^e:\\dot{\\boldsymbol{\\epsilon}}}{H + \\boldsymbol{m}:\\mathbb{C}^e:\\boldsymbol{m}}$。\n\n现在将 $\\dot{\\lambda}$ 的表达式代回应力率方程：\n$\\dot{\\boldsymbol{\\sigma}} = \\mathbb{C}^e:\\dot{\\boldsymbol{\\epsilon}} - \\frac{\\boldsymbol{m}:\\mathbb{C}^e:\\dot{\\boldsymbol{\\epsilon}}}{H + \\boldsymbol{m}:\\mathbb{C}^e:\\boldsymbol{m}} (\\mathbb{C}^e:\\boldsymbol{m})$\n$\\dot{\\boldsymbol{\\sigma}} = \\left[ \\mathbb{C}^e - \\frac{(\\mathbb{C}^e:\\boldsymbol{m}) \\otimes (\\boldsymbol{m}:\\mathbb{C}^e)}{H + \\boldsymbol{m}:\\mathbb{C}^e:\\boldsymbol{m}} \\right] : \\dot{\\boldsymbol{\\epsilon}}$。\n因此，连续介质弹塑性切线模量为 $\\mathbb{C}^{ep} = \\mathbb{C}^e - \\frac{(\\mathbb{C}^e:\\boldsymbol{m}) \\otimes (\\boldsymbol{m}:\\mathbb{C}^e)}{H + \\boldsymbol{m}:\\mathbb{C}^e:\\boldsymbol{m}}$。\n\n对于各向同性弹性 $\\mathbb{C}^e = K \\mathbf{I} \\otimes \\mathbf{I} + 2G \\mathbb{I}^s_d$ 和偏量流动方向 $\\boldsymbol{m}$（即 $\\mathrm{tr}(\\boldsymbol{m})=0$），我们有：\n$\\mathbb{C}^e : \\boldsymbol{m} = (K \\mathbf{I} \\otimes \\mathbf{I} + 2G \\mathbb{I}^s_d) : \\boldsymbol{m} = K(\\mathrm{tr}(\\boldsymbol{m})\\mathbf{I}) + 2G\\,\\mathrm{dev}(\\boldsymbol{m}) = 2G\\boldsymbol{m}$。\n类似地，$\\boldsymbol{m}:\\mathbb{C}^e = 2G\\boldsymbol{m}$。\n分母中的项为 $\\boldsymbol{m}:\\mathbb{C}^e:\\boldsymbol{m} = \\boldsymbol{m}:(2G\\boldsymbol{m}) = 2G(\\boldsymbol{m}:\\boldsymbol{m})$。\n根据定义，$\\boldsymbol{m} = \\sqrt{\\frac{3}{2}}\\boldsymbol{n}$，其中 $\\boldsymbol{n}$ 是单位张量，所以 $\\boldsymbol{n}:\\boldsymbol{n}=1$。因此，$\\boldsymbol{m}:\\boldsymbol{m} = \\frac{3}{2}(\\boldsymbol{n}:\\boldsymbol{n}) = \\frac{3}{2}$。\n所以，$\\boldsymbol{m}:\\mathbb{C}^e:\\boldsymbol{m} = 2G(\\frac{3}{2}) = 3G$。\n将这些代入 $\\mathbb{C}^{ep}$ 的表达式中：\n$\\mathbb{C}^{ep} = \\mathbb{C}^e - \\frac{(2G\\boldsymbol{m}) \\otimes (2G\\boldsymbol{m})}{H + 3G} = \\mathbb{C}^e - \\frac{4G^2}{H+3G} \\boldsymbol{m}\\otimes\\boldsymbol{m}$。\n这得到了期望的结果：\n$$\n\\mathbb{C}^{ep} = \\mathbb{C}^{e} - \\frac{4 G^{2}}{H + 3 G}\\,\\boldsymbol{m} \\otimes \\boldsymbol{m}\n$$\n\n**3. Voigt 矩阵表示**\n\n我们现在将四阶张量 $\\mathbb{C}^{ep}$ 转换为其 $6 \\times 6$ 矩阵形式 $\\mathbf{C}^{ep, V}$。Voigt 记法中的本构关系是 $\\dot{\\boldsymbol{\\sigma}}^{V} = \\mathbf{C}^{ep, V} \\dot{\\boldsymbol{\\epsilon}}^{V}$。\n弹性部分 $\\mathbb{C}^e$ 映射为标准的各向同性弹性矩阵 $\\mathbf{C}_e^V$。当 $\\lambda = K-\\frac{2}{3}G$ 时，它为：\n$$\n\\mathbf{C}_{e}^{V} =\n\\begin{pmatrix}\nK+\\frac{4}{3}G  K-\\frac{2}{3}G  K-\\frac{2}{3}G  0  0  0 \\\\\nK-\\frac{2}{3}G  K+\\frac{4}{3}G  K-\\frac{2}{3}G  0  0  0 \\\\\nK-\\frac{2}{3}G  K-\\frac{2}{3}G  K+\\frac{4}{3}G  0  0  0 \\\\\n0  0  0  G  0  0 \\\\\n0  0  0  0  G  0 \\\\\n0  0  0  0  0  G\n\\end{pmatrix}\n$$\n塑性修正项是一个秩一张量积 $\\boldsymbol{m}\\otimes\\boldsymbol{m}$。对于形式为 $\\mathbb{C} = \\boldsymbol{a} \\otimes \\boldsymbol{b}$ 的四阶张量，其中 $\\boldsymbol{a}$ 和 $\\boldsymbol{b}$ 是对称二阶张量，其对应变张量 $\\boldsymbol{\\epsilon}$ 的作用是 $\\boldsymbol{\\sigma} = \\mathbb{C}:\\boldsymbol{\\epsilon} = (\\boldsymbol{b}:\\boldsymbol{\\epsilon})\\boldsymbol{a}$。\n使用能量一致性 Voigt 映射，标量积变为 $\\boldsymbol{b}:\\boldsymbol{\\epsilon} = (\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}}\\boldsymbol{\\epsilon}^{V}$，其中 $\\boldsymbol{b}_{\\sigma}^{V}$ 是 $\\boldsymbol{b}$ 的应力类向量形式。\n产生的应力为 $\\boldsymbol{\\sigma} = [(\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}}\\boldsymbol{\\epsilon}^{V}]\\boldsymbol{a}$。将 $\\boldsymbol{\\sigma}$ 转换为其应力类 Voigt 向量 $\\boldsymbol{\\sigma}^V$ 得到 $\\boldsymbol{\\sigma}^{V} = [(\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}}\\boldsymbol{\\epsilon}^{V}]\\boldsymbol{a}_{\\sigma}^{V}$。\n将其重新排列为矩阵-向量形式：$\\boldsymbol{\\sigma}^{V} = (\\boldsymbol{a}_{\\sigma}^{V}(\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}})\\boldsymbol{\\epsilon}^{V}$。因此，$\\boldsymbol{a}\\otimes\\boldsymbol{b}$ 的 Voigt 矩阵是外积 $\\boldsymbol{a}_{\\sigma}^{V}(\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}}$。\n\n对于塑性修正项，$\\boldsymbol{a}=\\boldsymbol{b}=\\boldsymbol{m}$。相应的 Voigt 矩阵为 $\\boldsymbol{m}_{\\sigma}^{V}(\\boldsymbol{m}_{\\sigma}^{V})^{\\mathsf{T}}$。\n向量 $\\boldsymbol{m}_{\\sigma}^{V}$ 给出为 $\\boldsymbol{m}_{\\sigma}^{V} = (m_{11}, m_{22}, m_{33}, m_{23}, m_{13}, m_{12})^{\\mathsf{T}}$。\n弹塑性切线的完整 Voigt 表示为：\n$\\mathbf{C}^{ep, V} = \\mathbf{C}_{e}^{V} - \\frac{4G^2}{H+3G} \\boldsymbol{m}_{\\sigma}^{V}(\\boldsymbol{m}_{\\sigma}^{V})^{\\mathsf{T}}$。\n这就是所要求的闭合形式表达式。展开此式可得到完整的 $6 \\times 6$ 矩阵。令 $\\gamma' = \\frac{4G^2}{H+3G}$。矩阵 $(\\boldsymbol{m}_{\\sigma}^{V}(\\boldsymbol{m}_{\\sigma}^{V})^{\\mathsf{T}})_{IJ} = m_I m_J$，其中 $m_I$ 是 $\\boldsymbol{m}_{\\sigma}^{V}$ 的分量。最终矩阵是弹性矩阵与由 $\\gamma'$ 缩放的此秩一修正矩阵的负值之和。", "answer": "$$\n\\boxed{\n\\mathbf{C}^{ep, V} =\n\\begin{pmatrix}\nK+\\frac{4}{3}G  K-\\frac{2}{3}G  K-\\frac{2}{3}G  0  0  0 \\\\\nK-\\frac{2}{3}G  K+\\frac{4}{3}G  K-\\frac{2}{3}G  0  0  0 \\\\\nK-\\frac{2}{3}G  K-\\frac{2}{3}G  K+\\frac{4}{3}G  0  0  0 \\\\\n0  0  0  G  0  0 \\\\\n0  0  0  0  G  0 \\\\\n0  0  0  0  0  G\n\\end{pmatrix}\n- \\frac{4G^2}{H+3G}\n\\begin{pmatrix}\nm_{11}^2  m_{11}m_{22}  m_{11}m_{33}  m_{11}m_{23}  m_{11}m_{13}  m_{11}m_{12} \\\\\nm_{22}m_{11}  m_{22}^2  m_{22}m_{33}  m_{22}m_{23}  m_{22}m_{13}  m_{22}m_{12} \\\\\nm_{33}m_{11}  m_{33}m_{22}  m_{33}^2  m_{33}m_{23}  m_{33}m_{13}  m_{33}m_{12} \\\\\nm_{23}m_{11}  m_{23}m_{22}  m_{23}m_{33}  m_{23}^2  m_{23}m_{13}  m_{23}m_{12} \\\\\nm_{13}m_{11}  m_{13}m_{22}  m_{13}m_{33}  m_{13}m_{23}  m_{13}^2  m_{13}m_{12} \\\\\nm_{12}m_{11}  m_{12}m_{22}  m_{12}m_{33}  m_{12}m_{23}  m_{12}m_{13}  m_{12}^2\n\\end{pmatrix}\n}\n$$", "id": "3522229"}, {"introduction": "从理论推导到最终的数值验证，本章的最后一个练习旨在巩固您对“一致性”概念的理解。您将通过编写一个返回映射算法来检验弹塑性切线模量的一个基本物理属性：塑性功耗的非负性。这个实践不仅能提升您的编程和算法实现能力，更能让您深刻体会到一致性切线是如何确保数值算法在增量步中与热力学原理保持一致的。[@problem_id:3522268]", "problem": "考虑小应变、率无关、各向同性的相关弹塑性，采用 von Mises (也称为 $J_2$) 屈服条件和线性各向同性硬化，这在计算岩土力学中有所应用。其基本理论基础包括应变加和分解、各向同性线弹性定律、von Mises 屈服函数以及相关流动法则：\n- 应变加和分解：$\\boldsymbol{\\epsilon} = \\boldsymbol{\\epsilon}^e + \\boldsymbol{\\epsilon}^p$。\n- 各向同性线弹性：$\\boldsymbol{\\sigma} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\epsilon}^e)\\,\\mathbf{I} + 2\\mu\\,\\boldsymbol{\\epsilon}^e$，其中 $\\lambda$ 和 $\\mu$ 是拉梅参数，$\\mathrm{tr}(\\cdot)$ 表示迹，$\\mathbf{I}$ 是单位张量。\n- 带线性各向同性硬化的 von Mises 屈服函数：$f = \\|\\mathbf{s}\\| - \\sqrt{\\dfrac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha\\right)$，其中 $\\mathbf{s} = \\mathrm{dev}(\\boldsymbol{\\sigma})$ 是偏应力，$\\sigma_{y0}$ 是初始屈服应力，$H$ 是硬化模量，$\\alpha$ 是累积塑性应变度量（等效塑性应变）。\n- 相关流动法则：$\\dot{\\boldsymbol{\\epsilon}}^p = \\dot{\\gamma}\\,\\mathbf{n}$，其中 $\\mathbf{n} = \\dfrac{\\mathbf{s}}{\\|\\mathbf{s}\\|}$，并在塑性加载激活时强制满足一致性条件。\n\n在从时间 $t_n$ 到 $t_{n+1}$ 的一个加载步中，应变增量为 $\\Delta\\boldsymbol{\\epsilon}$，其增量塑性功定义为 $W_p^{\\mathrm{inc}} = \\boldsymbol{\\sigma}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p$，单位为兆帕 (MPa)，其中冒号表示双点积，$\\Delta\\boldsymbol{\\epsilon}^p$ 是塑性应变增量张量。算法一致弹塑性切线模量 $\\mathbf{D}^{ep}$ 是应力更新映射对应变增量的导数，在关注的状态点进行评估。\n\n您的任务是编写一个程序，该程序：\n1. 为指定模型实现一个增量返回映射算法，从上面列出的基本理论出发（不要使用任何超出该基础可推导范围的预推导快捷公式）。\n2. 通过对应力更新精确算法的应变增量（以 Voigt 标记法表示）进行有限差分，在给定状态下数值构建算法一致切线模量 $\\mathbf{D}^{ep}$。使用 Voigt 顺序 $[\\epsilon_{xx}, \\epsilon_{yy}, \\epsilon_{zz}, \\gamma_{yz}, \\gamma_{xz}, \\gamma_{xy}]$，其中 $\\gamma_{ij}$ 是工程剪切应变，应力顺序为 $[\\sigma_{xx}, \\sigma_{yy}, \\sigma_{zz}, \\tau_{yz}, \\tau_{xz}, \\tau_{xy}]$。\n3. 使用 $\\mathbf{D}^{ep}$ 通过关系式 $\\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}} = \\Delta\\boldsymbol{\\epsilon} - \\mathbf{S}:\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}}$ 计算给定步骤的塑性应变增量的线性化预测，其中 $\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}} = \\mathbf{D}^{ep} : \\Delta\\boldsymbol{\\epsilon}$，$\\mathbf{S}$ 是弹性柔度，其张量形式为 $\\mathbf{S} = \\dfrac{1}{2\\mu}\\mathbf{P}_{\\mathrm{dev}} + \\dfrac{1}{9K}\\mathbf{I}_{\\mathrm{vol}}$，$\\mathbf{P}_{\\mathrm{dev}}$ 是偏量投影算子，$\\mathbf{I}_{\\mathrm{vol}}$ 是体积投影算子，$K$ 是体积模量。\n4. 用两种方式评估增量塑性功：\n   - 精确增量塑性功：$W_p^{\\mathrm{inc,exact}} = \\boldsymbol{\\sigma}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p$，由返回映射后的应力和精确塑性应变增量计算。\n   - 使用切线的线性化增量塑性功：$W_p^{\\mathrm{inc,lin}} = \\boldsymbol{\\sigma}_{n} : \\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}}$，由步前应力和使用 $\\mathbf{D}^{ep}$ 及 $\\mathbf{S}$ 推导出的线性化塑性应变增量计算。\n\n通过检查以下条件来验证增量能量耗散的算法一致性：\n- 线性化塑性功为非负值 $W_p^{\\mathrm{inc,lin}} \\ge 0$（线性化不会伪生塑性功）。\n- 线性化塑性功与精确塑性功一阶匹配，即 $\\left|W_p^{\\mathrm{inc,lin}} - W_p^{\\mathrm{inc,exact}}\\right| \\le \\varepsilon \\,\\max\\left(1, \\left|W_p^{\\mathrm{inc,exact}}\\right|\\right)$，对于给定的容差 $\\varepsilon$。\n\n在所有情况下使用的材料参数为：\n- 杨氏模量 $E = 10000$ MPa，泊松比 $\\nu = 0.3$。\n- 初始屈服应力 $\\sigma_{y0} = 50$ MPa，硬化模量 $H = 1000$ MPa。\n\n所有塑性功值在内部均以兆帕 (MPa) 表示。本问题不涉及角度。应变为无量纲。\n\n构建一个包含五个顺序增量步的测试套件，从零应力和零塑性应变开始，累积施加于同一点：\n- 步骤 1（纯体积，弹性）：$\\Delta\\boldsymbol{\\epsilon} = [1\\times 10^{-5},\\,1\\times 10^{-5},\\,1\\times 10^{-5},\\,0,\\,0,\\,0]$。\n- 步骤 2（纯剪切，塑性）：$\\Delta\\boldsymbol{\\epsilon} = [0,\\,0,\\,0,\\,0,\\,0,\\,0.01]$。\n- 步骤 3（反向剪切，可能因硬化而为弹性）：$\\Delta\\boldsymbol{\\epsilon} = [0,\\,0,\\,0,\\,-0,\\,0,\\,-0.005]$。\n- 步骤 4（来自全新状态快照的近屈服剪切；对于此步骤，在施加前重置为零应力和零塑性应变）：$\\Delta\\boldsymbol{\\epsilon} = [0,\\,0,\\,0,\\,0,\\,0,\\,\\gamma_y]$，其中 $\\gamma_y = \\dfrac{\\sigma_{y0}}{\\sqrt{3}\\,\\mu}$ 且 $\\mu = \\dfrac{E}{2(1+\\nu)}$。\n- 步骤 5（体积-偏量组合，塑性）：$\\Delta\\boldsymbol{\\epsilon} = [5\\times 10^{-4},\\,-2.5\\times 10^{-4},\\,-2.5\\times 10^{-4},\\,0,\\,0,\\,0.008]$。\n\n对于上述五个步骤，为每个步骤确定一个布尔结果，指示是否同时满足以下两个条件：\n- 非负的线性化塑性功。\n- 线性化塑性功与精确塑性功在容差 $\\varepsilon = 5\\times 10^{-3}$ 内一致。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[true,false,true,true,false]”）。布尔值必须为小写。程序必须是完全自包含的，并且不得要求用户输入。", "solution": "我们从分析小应变弹塑性开始。总应变可以加和分解为 $\\boldsymbol{\\epsilon} = \\boldsymbol{\\epsilon}^e + \\boldsymbol{\\epsilon}^p$。各向同性线弹性定律写作 $\\boldsymbol{\\sigma} = \\lambda\\,\\mathrm{tr}(\\boldsymbol{\\epsilon}^e)\\,\\mathbf{I} + 2\\mu\\,\\boldsymbol{\\epsilon}^e$，其中 $\\mathrm{dev}(\\cdot)$ 算子的作用是 $\\mathrm{dev}(\\mathbf{A}) = \\mathbf{A} - \\dfrac{1}{3}\\mathrm{tr}(\\mathbf{A})\\mathbf{I}$。剪切模量为 $\\mu = \\dfrac{E}{2(1+\\nu)}$，体积模量为 $K = \\dfrac{E}{3(1-2\\nu)}$。拉梅参数为 $\\lambda = K - \\dfrac{2}{3}\\mu$。\n\n带线性各向同性硬化的 von Mises 屈服函数为 $f = \\|\\mathbf{s}\\| - \\sqrt{\\dfrac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha\\right)$，其中 $\\mathbf{s} = \\mathrm{dev}(\\boldsymbol{\\sigma})$，$\\alpha$ 是等效塑性应变。相关流动法则规定 $\\dot{\\boldsymbol{\\epsilon}}^p = \\dot{\\gamma}\\,\\mathbf{n}$，其中 $\\mathbf{n} = \\dfrac{\\mathbf{s}}{\\|\\mathbf{s}\\|}$，硬化演化规律为 $\\dot{\\alpha} = \\sqrt{\\dfrac{2}{3}}\\dot{\\gamma}$。\n\n针对一个应变增量 $\\Delta\\boldsymbol{\\epsilon}$ 的增量返回映射算法过程如下。将加载步前状态记为 $(\\boldsymbol{\\sigma}_n, \\boldsymbol{\\epsilon}^p_n, \\alpha_n)$，加载步后状态记为 $(\\boldsymbol{\\sigma}_{n+1}, \\boldsymbol{\\epsilon}^p_{n+1}, \\alpha_{n+1})$。使用弹性刚度计算弹性预测值（试探应力增量），不考虑塑性应变增量：\n$$\n\\Delta\\boldsymbol{\\sigma}_{\\mathrm{trial}} = K\\,\\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon})\\,\\mathbf{I} + 2\\mu\\,\\mathrm{dev}(\\Delta\\boldsymbol{\\epsilon}),\n$$\n并构建试探应力 $\\boldsymbol{\\sigma}_{\\mathrm{trial}} = \\boldsymbol{\\sigma}_n + \\Delta\\boldsymbol{\\sigma}_{\\mathrm{trial}}$。提取其偏量部分 $\\mathbf{s}_{\\mathrm{trial}} = \\mathrm{dev}(\\boldsymbol{\\sigma}_{\\mathrm{trial}})$ 并计算试探状态下的屈服函数：\n$$\nf_{\\mathrm{trial}} = \\left\\|\\mathbf{s}_{\\mathrm{trial}}\\right\\| - \\sqrt{\\frac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha_n\\right).\n$$\n如果 $f_{\\mathrm{trial}} \\le 0$，则该步为弹性步，因此 $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{\\mathrm{trial}}$，$\\Delta\\boldsymbol{\\epsilon}^p = \\mathbf{0}$，且 $\\alpha_{n+1} = \\alpha_n$。如果 $f_{\\mathrm{trial}}  0$，则发生塑性变形，并应用标准的径向返回映射。定义单位偏量方向 $\\mathbf{n} = \\dfrac{\\mathbf{s}_{\\mathrm{trial}}}{\\|\\mathbf{s}_{\\mathrm{trial}}\\|}$，并通过强制步末满足屈服条件来求解塑性一致性增量 $\\Delta\\gamma$：\n$$\n\\left\\|\\mathbf{s}_{n+1}\\right\\| = \\sqrt{\\frac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha_{n+1}\\right).\n$$\n在径向返回下，$\\mathbf{s}_{n+1} = \\mathbf{s}_{\\mathrm{trial}} - 2\\mu\\,\\Delta\\gamma\\,\\mathbf{n}$ 且 $\\alpha_{n+1} = \\alpha_n + \\sqrt{\\dfrac{2}{3}}\\Delta\\gamma$。代入可得标量方程\n$$\n\\|\\mathbf{s}_{\\mathrm{trial}}\\| - 2\\mu\\,\\Delta\\gamma = \\sqrt{\\frac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha_n + H\\sqrt{\\frac{2}{3}}\\Delta\\gamma\\right),\n$$\n简化为\n$$\n\\Delta\\gamma = \\frac{ \\|\\mathbf{s}_{\\mathrm{trial}}\\| - \\sqrt{\\dfrac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha_n\\right)}{ 2\\mu + \\dfrac{2}{3}H }.\n$$\n塑性应变增量则为\n$$\n\\Delta\\boldsymbol{\\epsilon}^p = \\Delta\\gamma\\,\\mathbf{n},\n$$\n加载步后的应力为\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\mathbf{s}_{n+1} + p_{\\mathrm{trial}}\\,\\mathbf{I},\\quad p_{\\mathrm{trial}} = \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma}_{\\mathrm{trial}}).\n$$\n该步的精确增量塑性功为 $W_p^{\\mathrm{inc,exact}} = \\boldsymbol{\\sigma}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p$，单位为兆帕。\n\n接下来，我们讨论算法一致弹塑性切线模量。根据定义，$\\mathbf{D}^{ep}$ 是在关注状态点上应力更新映射的 Fréchet 导数，即 $\\Delta\\boldsymbol{\\sigma} \\approx \\mathbf{D}^{ep} : \\Delta\\boldsymbol{\\epsilon}$，对于足够小的 $\\Delta\\boldsymbol{\\epsilon}$ 成立，其中应力通过精确算法（当塑性流动激活时包括在内）进行更新。获取 $\\mathbf{D}^{ep}$ 的一个稳健方法是通过有限差分对更新映射进行数值微分：沿每个 Voigt 基方向对小量应变增量进行扰动，计算产生的应力增量，并由这些方向导数构建 $\\mathbf{D}^{ep}$ 的各列。\n\n给定 $\\mathbf{D}^{ep}$，我们通过应用弹性柔度算子来获得弹性应变增量的线性化预测。柔度的张量形式为\n$$\n\\mathbf{S} = \\frac{1}{2\\mu}\\mathbf{P}_{\\mathrm{dev}} + \\frac{1}{9K}\\mathbf{I}_{\\mathrm{vol}},\n$$\n其中 $\\mathbf{P}_{\\mathrm{dev}}$ 提取二阶张量的偏量部分，$\\mathbf{I}_{\\mathrm{vol}}$ 将一个标量（迹）映射到体积应变张量。对于一个应力增量 $\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}}$，弹性应变增量为\n$$\n\\Delta\\boldsymbol{\\epsilon}^e_{\\mathrm{lin}} = \\mathbf{S} : \\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}} = \\frac{1}{2\\mu}\\mathrm{dev}\\left(\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}}\\right) + \\frac{1}{9K}\\mathrm{tr}\\left(\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}}\\right)\\mathbf{I}.\n$$\n因此，线性化的塑性应变增量为\n$$\n\\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}} = \\Delta\\boldsymbol{\\epsilon} - \\Delta\\boldsymbol{\\epsilon}^e_{\\mathrm{lin}}.\n$$\n然后我们将线性化增量塑性功定义为\n$$\nW_p^{\\mathrm{inc,lin}} = \\boldsymbol{\\sigma}_n : \\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}},\n$$\n在一致切线线性化下，这是对 $W_p^{\\mathrm{inc,exact}}$ 的一阶精确近似。\n\n需要进行两个一致性检查：非负性和一阶吻合性。率无关相关塑性的 Clausius-Duhem 不等式意味着 $\\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\epsilon}}^p \\ge 0$，这在离散层面上推导出 $W_p^{\\mathrm{inc,lin}} \\ge 0$。一阶吻合性通过要求 $|W_p^{\\mathrm{inc,lin}} - W_p^{\\mathrm{inc,exact}}|$ 相对于 $W_p^{\\mathrm{inc,exact}}$ 的量级足够小来评估。\n\n算法设计：\n- 在 Voigt 标记法中表示应力和应变，在标量积中使用工程剪切分量以反映功的共轭关系。\n- 实现 Voigt 向量和 $3\\times 3$ 对称张量之间的转换，以一致地计算偏量部分和范数。\n- 对每个步骤实现返回映射算法，更新 $(\\boldsymbol{\\sigma}, \\boldsymbol{\\epsilon}^p, \\alpha)$ 并计算 $\\Delta\\boldsymbol{\\epsilon}^p$。\n- 通过对给定步骤的步前状态下的完整更新映射进行有限差分来构建 $\\mathbf{D}^{ep}$。\n- 计算 $\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}} = \\mathbf{D}^{ep} : \\Delta\\boldsymbol{\\epsilon}$，然后通过柔度算子计算 $\\Delta\\boldsymbol{\\epsilon}^e_{\\mathrm{lin}}$，最后计算 $\\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}}$。\n- 通过 Voigt 标量积计算 $W_p^{\\mathrm{inc,exact}}$ 和 $W_p^{\\mathrm{inc,lin}}$（单位为兆帕），并为每个步骤检查两个条件。\n- 对于第四步，在施加近屈服增量之前将状态重置为 $(\\boldsymbol{\\sigma}, \\boldsymbol{\\epsilon}^p, \\alpha) = (\\mathbf{0}, \\mathbf{0}, 0)$；这测试了屈服面上的边界情况。\n- 将五个步骤的布尔值聚合到一个列表中，并以指定格式打印。\n\n此设计符合基本定律和定义，通过从第一性原理推导返回映射关系和基于柔度的分解，避免了使用快捷公式。该测试套件涵盖了弹性、塑性、卸载、屈服边界和组合加载情况，确保了在不同情况下的算法一致性覆盖。输出是一个包含小写布尔值的单一列表，指示对于每个增量步，基于切线的线性化是否保持了非负的塑性功，并与精确塑性功在一阶上匹配。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Material parameters\nE = 10000.0  # MPa\nnu = 0.3\nsigma_y0 = 50.0  # MPa\nH = 1000.0  # MPa\n\n# Derived elastic moduli\nmu = E / (2.0 * (1.0 + nu))         # shear modulus\nK = E / (3.0 * (1.0 - 2.0 * nu))    # bulk modulus\nlam = K - 2.0 * mu / 3.0            # Lamé first parameter\n\n# Helpers: Voigt -> tensor and deviatoric operations\ndef voigt_strain_to_tensor(e):\n    # e = [exx, eyy, ezz, gyz, gxz, gxy] (engineering shear)\n    eps = np.zeros((3, 3))\n    eps[0, 0] = e[0]\n    eps[1, 1] = e[1]\n    eps[2, 2] = e[2]\n    eps[1, 2] = e[3] / 2.0\n    eps[2, 1] = e[3] / 2.0\n    eps[0, 2] = e[4] / 2.0\n    eps[2, 0] = e[4] / 2.0\n    eps[0, 1] = e[5] / 2.0\n    eps[1, 0] = e[5] / 2.0\n    return eps\n\ndef tensor_to_voigt_strain(eps):\n    return np.array([\n        eps[0, 0],\n        eps[1, 1],\n        eps[2, 2],\n        eps[1, 2] * 2.0,\n        eps[0, 2] * 2.0,\n        eps[0, 1] * 2.0\n    ])\n\ndef voigt_stress_to_tensor(s):\n    # s = [sxx, syy, szz, tyz, txz, txy]\n    sig = np.zeros((3, 3))\n    sig[0, 0] = s[0]\n    sig[1, 1] = s[1]\n    sig[2, 2] = s[2]\n    sig[1, 2] = s[3]\n    sig[2, 1] = s[3]\n    sig[0, 2] = s[4]\n    sig[2, 0] = s[4]\n    sig[0, 1] = s[5]\n    sig[1, 0] = s[5]\n    return sig\n\ndef tensor_to_voigt_stress(sig):\n    return np.array([\n        sig[0, 0],\n        sig[1, 1],\n        sig[2, 2],\n        sig[1, 2],\n        sig[0, 2],\n        sig[0, 1]\n    ])\n\ndef dev(tensor):\n    tr = np.trace(tensor)\n    return tensor - (tr / 3.0) * np.eye(3)\n\ndef tensor_norm(tensor):\n    return np.sqrt(np.sum(tensor * tensor))\n\n# Elastic trial stress increment mapping\ndef elastic_stress_increment(delta_eps_tensor):\n    # delta_sigma = K tr(delta_eps) I + 2 mu dev(delta_eps)\n    tr_eps = np.trace(delta_eps_tensor)\n    return K * tr_eps * np.eye(3) + 2.0 * mu * dev(delta_eps_tensor)\n\n# Compliance mapping: from stress increment tensor to elastic strain increment tensor\ndef elastic_compliance_map(delta_sigma_tensor):\n    # epsilon_e = (1/(2 mu)) dev(delta_sigma) + (1/(9 K)) tr(delta_sigma) I\n    tr_sig = np.trace(delta_sigma_tensor)\n    return (1.0 / (2.0 * mu)) * dev(delta_sigma_tensor) + (tr_sig / (9.0 * K)) * np.eye(3)\n\n# Return mapping for one step\ndef return_mapping_update(state, delta_eps_voigt):\n    # state: dict with 'sigma' (3x3 tensor), 'eps_p' (3x3 tensor), 'alpha' (float)\n    sigma_n = state['sigma']\n    alpha_n = state['alpha']\n\n    delta_eps_tensor = voigt_strain_to_tensor(delta_eps_voigt)\n    # Elastic predictor: trial stress\n    delta_sigma_trial = elastic_stress_increment(delta_eps_tensor)\n    sigma_trial = sigma_n + delta_sigma_trial\n\n    s_trial = dev(sigma_trial)\n    norm_s_trial = tensor_norm(s_trial)\n    f_trial = norm_s_trial - np.sqrt(2.0 / 3.0) * (sigma_y0 + H * alpha_n)\n\n    if f_trial = 0.0:\n        # Elastic step\n        sigma_np1 = sigma_trial\n        delta_eps_p_tensor = np.zeros((3, 3))\n        alpha_np1 = alpha_n\n    else:\n        # Plastic step: radial return\n        n_dir = s_trial / (norm_s_trial + 1e-32)\n        denom = 2.0 * mu + (2.0 / 3.0) * H\n        delta_gamma = f_trial / denom\n        s_np1 = s_trial - 2.0 * mu * delta_gamma * n_dir\n        p_trial = np.trace(sigma_trial) / 3.0\n        sigma_np1 = s_np1 + p_trial * np.eye(3)\n        delta_eps_p_tensor = delta_gamma * n_dir\n        alpha_np1 = alpha_n + np.sqrt(2.0 / 3.0) * delta_gamma\n\n    # Exact incremental plastic work: sigma_{n+1} : delta_eps_p\n    delta_eps_p_voigt = tensor_to_voigt_strain(delta_eps_p_tensor)\n    sigma_np1_voigt = tensor_to_voigt_stress(sigma_np1)\n    Wp_inc_exact = float(np.dot(sigma_np1_voigt, delta_eps_p_voigt))\n\n    # Update state\n    new_state = {\n        'sigma': sigma_np1,\n        'eps_p': state['eps_p'] + delta_eps_p_tensor,\n        'alpha': alpha_np1\n    }\n    return new_state, delta_eps_p_voigt, Wp_inc_exact\n\n# Numerical tangent D_ep at given state via finite difference\ndef numeric_tangent_dep(state, h=1e-8):\n    sigma_base = state['sigma']\n    Dep = np.zeros((6, 6))\n    for i in range(6):\n        delta_eps = np.zeros(6)\n        delta_eps[i] = h\n        # Apply small increment from the base state\n        base_copy = {\n            'sigma': sigma_base.copy(),\n            'eps_p': state['eps_p'].copy(),\n            'alpha': state['alpha']\n        }\n        new_state, _, _ = return_mapping_update(base_copy, delta_eps)\n        delta_sigma_tensor = new_state['sigma'] - sigma_base\n        delta_sigma_voigt = tensor_to_voigt_stress(delta_sigma_tensor)\n        Dep[:, i] = delta_sigma_voigt / h\n    return Dep\n\ndef solve():\n    # Tolerance for first-order agreement\n    tol = 5e-3\n    # Define the sequential test steps (cumulative), with the reset before step 4 as specified.\n    # Steps 1-3 are cumulative; before step 4, reset; step 5 continues from step 3 state (not from step 4 reset).\n    steps = [\n        np.array([1e-5, 1e-5, 1e-5, 0.0, 0.0, 0.0]),   # Step 1\n        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.01]),     # Step 2\n        np.array([0.0, 0.0, 0.0, -0.0, 0.0, -0.005]),  # Step 3\n    ]\n\n    # Initial state\n    state = {\n        'sigma': np.zeros((3, 3)),\n        'eps_p': np.zeros((3, 3)),\n        'alpha': 0.0\n    }\n\n    results = []\n\n    # Process steps 1-3 cumulatively\n    for delta_eps in steps:\n        # Build numeric tangent at pre-step state\n        Dep = numeric_tangent_dep(state, h=1e-8)\n        # Linearized stress increment\n        delta_sigma_lin_voigt = Dep @ delta_eps\n        delta_sigma_lin_tensor = voigt_stress_to_tensor(delta_sigma_lin_voigt)\n        # Linearized elastic strain increment via compliance\n        delta_eps_e_lin_tensor = elastic_compliance_map(delta_sigma_lin_tensor)\n        delta_eps_e_lin_voigt = tensor_to_voigt_strain(delta_eps_e_lin_tensor)\n        # Linearized plastic strain increment\n        delta_eps_p_lin_voigt = delta_eps - delta_eps_e_lin_voigt\n        # Linearized plastic work using pre-step stress\n        sigma_n_voigt = tensor_to_voigt_stress(state['sigma'])\n        Wp_inc_lin = float(np.dot(sigma_n_voigt, delta_eps_p_lin_voigt))\n        # Exact update and exact plastic work\n        new_state, delta_eps_p_exact_voigt, Wp_inc_exact = return_mapping_update(state, delta_eps)\n        # Consistency checks\n        nonneg = (Wp_inc_lin >= -1e-10)\n        err = abs(Wp_inc_lin - Wp_inc_exact)\n        scale = max(1.0, abs(Wp_inc_exact))\n        agree = (err = tol * scale)\n        results.append(nonneg and agree)\n        # Update cumulative state\n        state = new_state\n\n    # Step 4: reset to zero state before applying near-yield shear increment\n    state_reset = {\n        'sigma': np.zeros((3, 3)),\n        'eps_p': np.zeros((3, 3)),\n        'alpha': 0.0\n    }\n    gamma_y = sigma_y0 / (np.sqrt(3.0) * mu)\n    delta_eps4 = np.array([0.0, 0.0, 0.0, 0.0, 0.0, gamma_y])\n\n    Dep4 = numeric_tangent_dep(state_reset, h=1e-8)\n    delta_sigma_lin_voigt_4 = Dep4 @ delta_eps4\n    delta_sigma_lin_tensor_4 = voigt_stress_to_tensor(delta_sigma_lin_voigt_4)\n    delta_eps_e_lin_tensor_4 = elastic_compliance_map(delta_sigma_lin_tensor_4)\n    delta_eps_e_lin_voigt_4 = tensor_to_voigt_strain(delta_eps_e_lin_tensor_4)\n    delta_eps_p_lin_voigt_4 = delta_eps4 - delta_eps_e_lin_voigt_4\n    sigma_n_voigt_4 = tensor_to_voigt_stress(state_reset['sigma'])\n    Wp_inc_lin_4 = float(np.dot(sigma_n_voigt_4, delta_eps_p_lin_voigt_4))\n    new_state_4, delta_eps_p_exact_voigt_4, Wp_inc_exact_4 = return_mapping_update(state_reset, delta_eps4)\n    nonneg_4 = (Wp_inc_lin_4 >= -1e-10)\n    err_4 = abs(Wp_inc_lin_4 - Wp_inc_exact_4)\n    scale_4 = max(1.0, abs(Wp_inc_exact_4))\n    agree_4 = (err_4 = tol * scale_4)\n    results.append(nonneg_4 and agree_4)\n\n    # Step 5: continue from the state after step 3 (cumulative sequence), combined loading\n    delta_eps5 = np.array([5e-4, -2.5e-4, -2.5e-4, 0.0, 0.0, 0.008])\n    Dep5 = numeric_tangent_dep(state, h=1e-8)\n    delta_sigma_lin_voigt_5 = Dep5 @ delta_eps5\n    delta_sigma_lin_tensor_5 = voigt_stress_to_tensor(delta_sigma_lin_voigt_5)\n    delta_eps_e_lin_tensor_5 = elastic_compliance_map(delta_sigma_lin_tensor_5)\n    delta_eps_e_lin_voigt_5 = tensor_to_voigt_strain(delta_eps_e_lin_tensor_5)\n    delta_eps_p_lin_voigt_5 = delta_eps5 - delta_eps_e_lin_voigt_5\n    sigma_n_voigt_5 = tensor_to_voigt_stress(state['sigma'])\n    Wp_inc_lin_5 = float(np.dot(sigma_n_voigt_5, delta_eps_p_lin_voigt_5))\n    new_state_5, delta_eps_p_exact_voigt_5, Wp_inc_exact_5 = return_mapping_update(state, delta_eps5)\n    nonneg_5 = (Wp_inc_lin_5 >= -1e-10)\n    err_5 = abs(Wp_inc_lin_5 - Wp_inc_exact_5)\n    scale_5 = max(1.0, abs(Wp_inc_exact_5))\n    agree_5 = (err_5 = tol * scale_5)\n    results.append(nonneg_5 and agree_5)\n\n    # Final print statement in the exact required format (lowercase booleans)\n    print(f\"[{','.join(map(lambda x: 'true' if x else 'false', results))}]\")\n\nsolve()\n```", "id": "3522268"}]}