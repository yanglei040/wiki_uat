{"hands_on_practices": [{"introduction": "任何显式积分算法的第一步都是弹性预测步，这是至关重要的基础。本练习将从三维本构定律出发，推导在平面应变条件下的特定应力-应变映射关系。通过这个练习，你将巩固对线弹性理论及其在常见二维简化中应用的理解，为后续更复杂的弹塑性模型打下坚实的基础。[@problem_id:3523455]", "problem": "考虑一个在小应变和平面应变条件下的各向同性线性弹性岩土材料，其运动学约束强制平面外应变为零。在一个显式应力积分方案中，弹性预测步将给定的应变增量映射到一个试探柯西应力状态，此过程在任何塑性修正之前。从三维小应变各向同性线性弹性本构律出发，构建在平面应变条件下将平面内应变增量向量 $\\Delta\\varepsilon = (\\Delta\\varepsilon_{xx},\\,\\Delta\\varepsilon_{yy},\\,0,\\,\\Delta\\gamma_{xy})$ 映射到试探应力向量 $\\sigma^{tr} = (\\sigma^{tr}_{xx},\\,\\sigma^{tr}_{yy},\\,\\sigma^{tr}_{zz},\\,\\tau^{tr}_{xy})$ 的弹性预测映射。明确指出在弹性预测中，受约束的平面外应变如何影响 $\\sigma^{tr}_{zz}$。\n\n假设材料的杨氏模量 $E = 1200\\,\\text{MPa}$，泊松比 $\\nu = 0.30$。增量应变状态为\n$$\n\\Delta\\varepsilon_{xx} = 1.5\\times 10^{-3},\\quad \\Delta\\varepsilon_{yy} = -5.0\\times 10^{-4},\\quad \\Delta\\gamma_{xy} = 2.0\\times 10^{-3}.\n$$\n假设先前的应力状态为零，因此弹性预测试探应力等于应力增量。使用所构建的映射，计算 $\\sigma^{tr}_{xx}$、$\\sigma^{tr}_{yy}$、$\\sigma^{tr}_{zz}$ 和 $\\tau^{tr}_{xy}$ 的数值。将最终的应力分量以兆帕 (MPa) 为单位表示，并将每个值四舍五入到四位有效数字。", "solution": "该问题是有效的，因为它在科学上基于线性弹性理论，提法良好且数据充分，并且陈述客观。我们将开始求解。\n\n出发点是用于小应变的三维各向同性线性弹性本构律（胡克定律），它将柯西应力张量 $\\sigma_{ij}$ 与应变张量 $\\varepsilon_{ij}$ 联系起来：\n$$\n\\sigma_{ij} = \\lambda \\delta_{ij} \\varepsilon_{kk} + 2G \\varepsilon_{ij}\n$$\n此处，$\\delta_{ij}$ 是克罗内克δ符号，$\\varepsilon_{kk} = \\varepsilon_{xx} + \\varepsilon_{yy} + \\varepsilon_{zz}$ 是应变张量的迹（体积应变），$\\lambda$ 和 $G$ 是拉梅参数。它们通过以下关系与杨氏模量 $E$ 和泊松比 $\\nu$ 相关联：\n$$\nG = \\frac{E}{2(1+\\nu)} \\quad \\text{and} \\quad \\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}\n$$\n在显式积分方案中，弹性预测步假设对给定的应变增量 $\\Delta\\varepsilon$ 发生完全弹性响应，从而计算出试探应力增量 $\\Delta\\sigma^{tr}$。当先前的应力状态为零时，试探应力 $\\sigma^{tr}$ 等于应力增量 $\\Delta\\sigma$。本构律的增量形式为：\n$$\n\\Delta\\sigma_{ij} = \\lambda \\delta_{ij} \\Delta\\varepsilon_{kk} + 2G \\Delta\\varepsilon_{ij}\n$$\n问题指定了平面应变条件，该条件施加了运动学约束，即在平面外方向（$z$方向）上没有应变。这意味着 $\\Delta\\varepsilon_{zz} = 0$。此外，平面外剪应变为零，即 $\\Delta\\gamma_{xz} = 2\\Delta\\varepsilon_{xz} = 0$ 和 $\\Delta\\gamma_{yz} = 2\\Delta\\varepsilon_{yz} = 0$。\n\n应用这些约束后，增量体积应变变为 $\\Delta\\varepsilon_{kk} = \\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}$。我们现在可以写出试探应力增量的各个分量：\n对于平面内正应力：\n$$\n\\sigma^{tr}_{xx} = \\Delta\\sigma_{xx} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{xx} = (\\lambda + 2G)\\Delta\\varepsilon_{xx} + \\lambda\\Delta\\varepsilon_{yy}\n$$\n$$\n\\sigma^{tr}_{yy} = \\Delta\\sigma_{yy} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{yy} = \\lambda\\Delta\\varepsilon_{xx} + (\\lambda + 2G)\\Delta\\varepsilon_{yy}\n$$\n对于平面内剪应力（使用工程剪应变 $\\Delta\\gamma_{xy} = 2\\Delta\\varepsilon_{xy}$）：\n$$\n\\tau^{tr}_{xy} = \\Delta\\sigma_{xy} = 2G\\Delta\\varepsilon_{xy} = G\\Delta\\gamma_{xy}\n$$\n对于平面外正应力：\n$$\n\\sigma^{tr}_{zz} = \\Delta\\sigma_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy})\n$$\n由于相应的剪应变为零，平面外剪应力也为零：\n$$\n\\tau^{tr}_{xz} = 0, \\quad \\tau^{tr}_{yz} = 0\n$$\n这组方程构成了平面应变的弹性预测映射。\n\n方程 $\\sigma^{tr}_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy})$ 解释了受约束的平面外应变对 $\\sigma^{tr}_{zz}$ 的贡献。从物理上讲，平面内应变 $\\Delta\\varepsilon_{xx}$ 和 $\\Delta\\varepsilon_{yy}$ 会通过泊松效应引起一个平面外应变 $\\Delta\\varepsilon_{zz}'$。为了强制执行运动学约束 $\\Delta\\varepsilon_{zz} = 0$，必须产生一个正应力 $\\sigma_{zz}^{tr}$ 来抵消这种趋势。$\\sigma_{zz}^{tr}$ 的另一个等效表达式是 $\\sigma_{zz}^{tr} = \\nu(\\sigma_{xx}^{tr} + \\sigma_{yy}^{tr})$。这两个表达式的等价性是平面应变公式的一个标志，可以通过将 $\\sigma_{xx}^{tr}$ 和 $\\sigma_{yy}^{tr}$ 的表达式代入第二种形式，并使用 $\\lambda$ 和 $G$ 的定义来验证。\n\n现在，我们计算数值。给定的材料属性为 $E = 1200\\,\\text{MPa}$ 和 $\\nu = 0.30$。\n首先，计算拉梅参数：\n$$\nG = \\frac{1200\\,\\text{MPa}}{2(1+0.30)} = \\frac{1200}{2.6}\\,\\text{MPa} = \\frac{6000}{13}\\,\\text{MPa} \\approx 461.538\\,\\text{MPa}\n$$\n$$\n\\lambda = \\frac{1200\\,\\text{MPa} \\times 0.30}{(1+0.30)(1 - 2 \\times 0.30)} = \\frac{360}{1.3 \\times 0.4}\\,\\text{MPa} = \\frac{360}{0.52}\\,\\text{MPa} = \\frac{9000}{13}\\,\\text{MPa} \\approx 692.308\\,\\text{MPa}\n$$\n平面应变模量为：\n$$\n\\lambda + 2G = \\frac{9000}{13}\\,\\text{MPa} + 2\\left(\\frac{6000}{13}\\right)\\,\\text{MPa} = \\frac{21000}{13}\\,\\text{MPa} \\approx 1615.385\\,\\text{MPa}\n$$\n增量应变分量给定如下：\n$\\Delta\\varepsilon_{xx} = 1.5\\times 10^{-3}$\n$\\Delta\\varepsilon_{yy} = -5.0\\times 10^{-4} = -0.5\\times 10^{-3}$\n$\\Delta\\gamma_{xy} = 2.0\\times 10^{-3}$\n\n使用推导出的映射，我们计算试探应力分量：\n$$\n\\sigma^{tr}_{xx} = \\left(\\frac{21000}{13}\\right)(1.5 \\times 10^{-3}) + \\left(\\frac{9000}{13}\\right)(-0.5 \\times 10^{-3}) = \\frac{10^{-3}}{13}(31500 - 4500) = \\frac{27000}{13} \\times 10^{-3} = \\frac{27}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{xx} \\approx 2.076923\\,\\text{MPa}\n$$\n四舍五入到四位有效数字，得到 $\\sigma^{tr}_{xx} = 2.077\\,\\text{MPa}$。\n\n$$\n\\sigma^{tr}_{yy} = \\left(\\frac{9000}{13}\\right)(1.5 \\times 10^{-3}) + \\left(\\frac{21000}{13}\\right)(-0.5 \\times 10^{-3}) = \\frac{10^{-3}}{13}(13500 - 10500) = \\frac{3000}{13} \\times 10^{-3} = \\frac{3}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{yy} \\approx 0.230769\\,\\text{MPa}\n$$\n四舍五入到四位有效数字，得到 $\\sigma^{tr}_{yy} = 0.2308\\,\\text{MPa}$。\n\n$$\n\\sigma^{tr}_{zz} = \\left(\\frac{9000}{13}\\right)(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) = \\left(\\frac{9000}{13}\\right)(1.5 \\times 10^{-3} - 0.5 \\times 10^{-3}) = \\left(\\frac{9000}{13}\\right)(1.0 \\times 10^{-3}) = \\frac{9}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{zz} \\approx 0.692307\\,\\text{MPa}\n$$\n四舍五入到四位有效数字，得到 $\\sigma^{tr}_{zz} = 0.6923\\,\\text{MPa}$。\n\n$$\n\\tau^{tr}_{xy} = G\\Delta\\gamma_{xy} = \\left(\\frac{6000}{13}\\right)(2.0 \\times 10^{-3}) = \\frac{12000}{13} \\times 10^{-3} = \\frac{12}{13}\\,\\text{MPa}\n$$\n$$\n\\tau^{tr}_{xy} \\approx 0.923076\\,\\text{MPa}\n$$\n四舍五入到四位有效数字，得到 $\\tau^{tr}_{xy} = 0.9231\\,\\text{MPa}$。\n\n计算出的试探应力分量，四舍五入到四位有效数字后为：$\\sigma^{tr}_{xx} = 2.077\\,\\text{MPa}$、$\\sigma^{tr}_{yy} = 0.2308\\,\\text{MPa}$、$\\sigma^{tr}_{zz} = 0.6923\\,\\text{MPa}$ 和 $\\tau^{tr}_{xy} = 0.9231\\,\\text{MPa}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 2.077  0.2308  0.6923  0.9231 \\end{pmatrix}}\n$$", "id": "3523455"}, {"introduction": "在理解了显式方法的一个关键局限性之后，本练习将探讨一种提高其准确性和稳健性的强大技术：自适应子步长。你将实现一个算法，该算法能自动细化积分步长，以确保数值误差保持在预设的容差范围内。这个练习将引导你从发现问题过渡到主动设计解决方案，这是计算建模中的一项关键技能。[@problem_id:3523495]", "problem": "您的任务是为小应变条件下的 Drucker–Prager 弹塑性材料实现一个自适应显式应力积分算法。该算法必须使用弹性预测-显式塑性修正方法，并且必须自适应地细分总应变增量，直到试探屈服函数值落入一个指定的目标范围内，以保证显式修正的准确性。\n\n材料模型为线性各向同性弹性体，采用关联的 Drucker–Prager 屈服函数和线性各向同性硬化。所有量值必须在拉为正的符号约定下计算。应力为二阶对称张量，应变为二阶对称张量，且小应变假设成立。单位有明确要求：应力以千帕 (kPa) 表示，应变为无量纲。本问题不涉及角度单位。所有数值输出必须四舍五入到三位小数。\n\n您必须用于推导算法的基本原理和定义如下：\n- 小应变运动学：总应变增量分解为 $\\Delta\\varepsilon = \\Delta\\varepsilon^{e} + \\Delta\\varepsilon^{p}$，其中 $\\varepsilon$ 表示应变张量，上标 $e$ 和 $p$ 分别表示弹性和塑性部分。\n- 具有 Lamé 常数 $\\lambda$ 和 $\\mu$ 的线性各向同性弹性：弹性本构关系为 $\\sigma = \\mathbb{C} : \\varepsilon^{e}$，其中 $\\mathbb{C}$ 由 $\\mathbb{C} : A = \\lambda \\,\\mathrm{tr}(A)\\,\\mathbf{I} + 2\\mu\\,A$ 给出，适用于任何对称二阶张量 $A$。体积模量 $K$ 和剪切模量 $G$ 满足 $\\lambda = K - \\tfrac{2}{3}G$ 和 $\\mu = G$。\n- 二阶应力张量 $\\sigma$ 的应力不变量：第一不变量 $I_{1} = \\mathrm{tr}(\\sigma)$ 和第二偏应力不变量 $J_{2} = \\tfrac{1}{2} s : s$，其中 $s = \\sigma - \\tfrac{1}{3}I_{1}\\mathbf{I}$ 是偏应力张量，$:$ 表示双点积。\n- 具有线性各向同性硬化的 Drucker–Prager 屈服函数：$f(\\sigma,\\kappa) = \\alpha I_{1} + \\sqrt{J_{2}} - k(\\kappa)$，其中 $k(\\kappa) = k_0 + H \\kappa$，$\\alpha > 0$ 是材料参数，$k_0$ 是初始内聚力类参数，$H \\ge 0$ 是硬化模量，$\\kappa$ 是一个标量内变量。关联流动法则使用塑性势函数 $g(\\sigma,\\kappa) = f(\\sigma,\\kappa)$，因此 $\\Delta\\varepsilon^{p} = \\Delta\\lambda\\,\\partial g/\\partial \\sigma$，其中 $\\Delta\\lambda \\ge 0$ 是塑性乘子增量。\n- 弹性预测器为给定的应变子增量 $\\delta\\varepsilon$ 构建试探应力：$\\sigma^{tr} = \\sigma^{n} + \\mathbb{C} : \\delta\\varepsilon$，其中 $\\sigma^{n}$ 是子步开始时的应力。试探屈服函数为 $f^{tr} = f(\\sigma^{tr},\\kappa^{n})$。\n- 显式塑性修正器基于屈服函数的线性化，并在子步内冻结模量和流动方向。设 $n = \\partial f/\\partial \\sigma$，在子步开始时进行计算。则显式更新满足 $\\sigma^{n+1} = \\sigma^{tr} - \\left(\\mathbb{C} : n\\right)\\Delta\\lambda$，$\\kappa^{n+1} = \\kappa^{n} + \\Delta\\lambda$，塑性乘子增量由一阶一致性近似得到 $\\Delta\\lambda = \\dfrac{f^{tr}}{n : \\mathbb{C} : n + H}$。所有缩并都针对张量指数进行。在 $J_2 = 0$ 附近对 $\\sqrt{J_{2}}$ 的导数使用正则化处理，以避免除以零。\n\n算法要求：\n- 实现一个自适应子步策略，将总应变增量 $\\Delta\\varepsilon$ 划分为 $N$ 个相等的子步 $\\delta\\varepsilon = \\Delta\\varepsilon/N$，从 $N=1$ 开始，并根据需要将 $N$ 加倍。\n- 对每个子步，计算弹性预测应力 $\\sigma^{tr}$ 和试探屈服值 $f^{tr}$。如果 $f^{tr} \\le 0$，则接受该弹性步：对于该子步，设置 $\\sigma^{n+1} = \\sigma^{tr}$ 和 $\\kappa^{n+1} = \\kappa^{n}$。如果 $f^{tr} > 0$，则强制执行目标范围条件 $0 \\le f^{tr} \\le \\tau$（给定阈值 $\\tau > 0$）；如果在当前 $N$ 值下，任何子步的 $f^{tr} > \\tau$，则将 $N$ 增加一倍并从头重新开始子步序列。持续此过程，直到所有子步都满足条件。\n- 当 $f^{tr} > 0$ 且满足 $f^{tr} \\le \\tau$ 时，使用上述定义对该子步执行显式塑性修正。然后继续到下一个子步。\n- 当所有子步都处理完毕后，停止计算并返回最终应力以及所使用的子步数 $N$。使用一个最大上限 $N_{\\max}$ 来防止无限循环；如果达到该上限，则按原样返回当前结果。\n\n实现约定：\n- 使用拉为正的符号约定。应力必须以千帕 (kPa) 表示，四舍五入到三位小数。应变为无量纲。\n- 在内部将应力和应变表示为对称的 $3 \\times 3$ 张量。输入的总应变增量以 Voigt 形式指定为 $[\\Delta\\varepsilon_{11}, \\Delta\\varepsilon_{22}, \\Delta\\varepsilon_{33}, \\Delta\\gamma_{23}, \\Delta\\gamma_{13}, \\Delta\\gamma_{12}]$，其中 $\\Delta\\gamma_{ij} = 2 \\Delta\\varepsilon_{ij}$ 是工程剪切应变。在应用 $\\mathbb{C}$ 之前将其转换为张量形式，并在报告应力分量时转换回来。\n- 对于导数 $\\partial f/\\partial \\sigma$，使用 $n = \\alpha \\mathbf{I} + \\dfrac{s}{2\\sqrt{J_{2}}}$，并对一个小的 $\\epsilon > 0$ 使用正则化 $\\sqrt{J_{2}} \\leftarrow \\max(\\sqrt{J_{2}}, \\epsilon)$。\n\n测试套件：\n对于所有测试用例，初始应力张量为零，初始硬化变量为 $\\kappa^{0} = 0$。提供以下四个测试用例，每个用例指定为一组参数 $(K, G, \\alpha, H, k_{0}, \\Delta\\varepsilon, \\tau)$，其中 $K$ 和 $G$ 的单位为 kPa，$H$ 和 $k_{0}$ 的单位为 kPa，应变增量为无量纲，$\\tau$ 的单位为 kPa：\n1. $(20000, 10000, 0.12, 800, 100, [2\\times10^{-4}, 0, 0, 0, 0, 1\\times10^{-4}], 5)$\n2. $(20000, 10000, 0.12, 800, 100, [1\\times10^{-7}, 1\\times10^{-7}, 1\\times10^{-7}, 0, 0, 0], 5)$\n3. $(15000, 7000, 0.18, 500, 80, [0, 0, 0, 8\\times10^{-4}, 0, 0], 2)$\n4. $(25000, 12000, 0.10, 1200, 50, [4\\times10^{-4}, 4\\times10^{-4}, 4\\times10^{-4}, 0, 0, 0], 3)$\n\n您的程序必须为每个测试用例计算最终的应力分量（以 Voigt 顺序 $[\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\sigma_{23}, \\sigma_{13}, \\sigma_{12}]$ 表示，单位为 kPa，四舍五入到三位小数）以及所使用的子步数 $N$。最终输出格式必须是单行，包含一个 Python 风格的列表，其中有四个结果（每个测试用例一个），每个结果是一个包含七个值的列表：六个应力分量，后跟整数 $N$。例如： \"[[s11,s22,s33,s23,s13,s12,N], [...], [...], [...]]\"。", "solution": "用户提供了一个在计算岩土力学领域中定义明确的问题。该问题具有科学依据、内容完整且客观。任务是为遵循 Drucker-Prager 模型和线性各向同性硬化的弹塑性材料实现一个自适应显式应力积分方案。所提供的方程和算法结构是该领域的标准方法，且逻辑上一致。因此，该问题被认为是有效的。\n\n解决方案的开发过程是首先将所提供的张量方程形式化，然后按照规定构建自适应算法。所有数学实体均遵循强制性的 LaTeX 格式。\n\n### 1. 预备知识：张量和本构关系\n\n材料响应由线性各向同性弹性和 Drucker-Prager 屈服准则控制。\n\n- **弹性**：应力张量 $\\sigma$ 与弹性应变张量 $\\varepsilon^e$ 通过胡克定律相关联，$\\sigma = \\mathbb{C} : \\varepsilon^e$，其中 $\\mathbb{C}$ 是四阶弹性张量。对于各向同性材料，其表达式为：\n$$\n\\mathbb{C} : A = \\lambda \\,\\mathrm{tr}(A)\\,\\mathbf{I} + 2\\mu\\,A\n$$\n适用于任何对称二阶张量 $A$。Lamé 参数 $\\lambda$ 和 $\\mu$ 与体积模量 $K$ 和剪切模量 $G$ 的关系为 $\\lambda = K - \\frac{2}{3}G$ 和 $\\mu = G$。\n\n- **Voigt 标记法**：应变以 Voigt 向量形式 $\\Delta\\varepsilon_v = [\\Delta\\varepsilon_{11}, \\Delta\\varepsilon_{22}, \\Delta\\varepsilon_{33}, \\Delta\\gamma_{23}, \\Delta\\gamma_{13}, \\Delta\\gamma_{12}]$ 提供。必须将其转换为 $3 \\times 3$ 的对称张量形式 $\\Delta\\varepsilon$，并注意这里使用的是工程剪切应变，即对于 $i \\neq j$，$\\Delta\\gamma_{ij} = 2\\Delta\\varepsilon_{ij}$。\n$$\n\\Delta\\varepsilon =\n\\begin{pmatrix}\n\\Delta\\varepsilon_{11}  \\frac{1}{2}\\Delta\\gamma_{12}  \\frac{1}{2}\\Delta\\gamma_{13} \\\\\n\\frac{1}{2}\\Delta\\gamma_{12}  \\Delta\\varepsilon_{22}  \\frac{1}{2}\\Delta\\gamma_{23} \\\\\n\\frac{1}{2}\\Delta\\gamma_{13}  \\frac{1}{2}\\Delta\\gamma_{23}  \\Delta\\varepsilon_{33}\n\\end{pmatrix}\n$$\n最终计算出的应力张量 $\\sigma$ 在输出时会转换回 Voigt 形式 $[\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\sigma_{23}, \\sigma_{13}, \\sigma_{12}]$。\n\n- **Drucker-Prager 模型**：屈服函数 $f$ 定义了弹性域的边界：\n$$\nf(\\sigma, \\kappa) = \\alpha I_1 + \\sqrt{J_2} - k(\\kappa)\n$$\n其中 $I_1 = \\mathrm{tr}(\\sigma)$ 是应力第一不变量，$J_2 = \\frac{1}{2}s:s$ 是偏应力 $s = \\sigma - \\frac{1}{3}I_1\\mathbf{I}$ 的第二不变量，$\\alpha > 0$ 是一个材料参数。硬化是线性和各向同性的，由 $k(\\kappa) = k_0 + H\\kappa$ 定义，其中 $k_0$ 是初始内聚力类参数，$H \\ge 0$ 是硬化模量，$\\kappa$ 是内部硬化变量。$\\kappa$ 的演化由 $\\dot{\\kappa} = \\dot{\\lambda}$ 给出，其中 $\\dot{\\lambda}$ 是塑性乘子率。\n\n### 2. 自适应显式积分算法\n\n总应变增量 $\\Delta\\varepsilon_{total}$ 通过一系列子步施加。算法自适应地优化子步数 $N$，以确保显式塑性修正器的准确性。\n\n对于单个总应变增量的整体流程如下：\n1. 初始化应力 $\\sigma = \\sigma_0$ 和硬化变量 $\\kappa = \\kappa_0$。对于本问题，$\\sigma_0 = \\mathbf{0}$ 且 $\\kappa_0 = 0$。\n2. 从 $N=1$ 个子步开始。设置一个最大值 $N_{max}$（例如 $2048$）以防止无限循环。\n3. 进入一个循环，只要 $N \\le N_{max}$ 就继续：\n    a. 将状态重置为总增量开始时的状态：$\\sigma_{current} = \\sigma_0$，$\\kappa_{current} = \\kappa_0$。\n    b. 计算每个子步的应变增量：$\\delta\\varepsilon = \\Delta\\varepsilon_{total} / N$。\n    c. 设置一个标志 `restart_needed = false`。\n    d. 遍历每个子步，从 $i=1$ 到 $N$：\n        i.   使用当前状态 $(\\sigma_{current}, \\kappa_{current})$ 和应变增量 $\\delta\\varepsilon$ 执行一个积分步。该步骤（详见下文）返回更新后的状态 $(\\sigma_{new}, \\kappa_{new})$ 和一个状态（`'ok'` 或 `'failure'`）。\n        ii.  如果状态为 `'failure'`，则设置 `restart_needed = true` 并跳出内部子步循环。\n        iii. 如果状态为 `'ok'`，则为下一个子步更新状态：$\\sigma_{current} = \\sigma_{new}$，$\\kappa_{current} = \\kappa_{new}$。\n    e. 子步循环结束后，如果 `restart_needed` 为真，则将子步数加倍（$N \\leftarrow 2N$）并继续主循环的下一次迭代。\n    f. 如果子步循环成功完成，则积分完成。最终状态为 $(\\sigma_{current}, \\kappa_{current})$。跳出主循环。\n4. 报告最终的应力张量和子步数 $N$。\n\n### 3. 单个子步的积分\n\n对于每个子步，从状态 $(\\sigma^n, \\kappa^n)$ 开始，使用弹性预测-塑性修正方案。\n\n1.  **弹性预测**：通过假设整个子步应变增量 $\\delta\\varepsilon$ 都是弹性的，来计算一个试探应力 $\\sigma^{tr}$：\n    $$\n    \\sigma^{tr} = \\sigma^n + \\mathbb{C} : \\delta\\varepsilon = \\sigma^n + \\lambda\\,\\mathrm{tr}(\\delta\\varepsilon)\\mathbf{I} + 2\\mu\\,\\delta\\varepsilon\n    $$\n\n2.  **屈服检查**：在试探状态下评估屈服函数，使用子步开始时的硬化状态：\n    $$\n    f^{tr} = f(\\sigma^{tr}, \\kappa^n) = \\alpha I_1^{tr} + \\sqrt{J_2^{tr}} - (k_0 + H\\kappa^n)\n    $$\n    其中 $I_1^{tr} = \\mathrm{tr}(\\sigma^{tr})$，$J_2^{tr}$ 是 $\\sigma^{tr}$ 的第二偏应力不变量。\n\n3.  **状态更新逻辑**：\n    a. **弹性步**：如果 $f^{tr} \\le 0$，状态为弹性或位于屈服面上。接受试探状态：\n       $$\n       \\sigma^{n+1} = \\sigma^{tr} \\quad , \\quad \\kappa^{n+1} = \\kappa^n\n       $$\n       该子步成功。\n    b. **塑性步检查**：如果 $f^{tr} > 0$，则发生塑性变形。$f^{tr}$ 的大小是显式方案中误差的一个指标。\n       - 如果 $f^{tr} > \\tau$（其中 $\\tau$ 是指定的容差），则误差过大。子步尺寸过粗。子步计算失败，触发整个过程以更小的子步尺寸（更大的 $N$）重新启动。\n       - 如果 $0  f^{tr} \\le \\tau$，则误差可接受。继续进行塑性修正。\n\n4.  **显式塑性修正**：当 $0  f^{tr} \\le \\tau$ 时，状态被返回到屈服面上。\n    a. 塑性乘子增量 $\\Delta\\lambda$ 使用一阶近似计算：\n       $$\n       \\Delta\\lambda = \\frac{f^{tr}}{n^{tr} : \\mathbb{C} : n^{tr} + H}\n       $$\n       其中 $n^{tr} = \\frac{\\partial f}{\\partial \\sigma}\\big|_{\\sigma^{tr}}$ 是在试探应力处评估的流动方向。\n    b. 对于 Drucker-Prager 模型，$n^{tr} = \\alpha\\mathbf{I} + \\frac{s^{tr}}{2\\sqrt{J_2^{tr}}}$。只要 $J_2^{tr} \\neq 0$，分母项可简化为一个材料常数表达式：\n       $$\n       n^{tr}:\\mathbb{C}:n^{tr} + H = 9K\\alpha^2 + G + H\n       $$\n       为了处理 $J_2^{tr} \\to 0$ 时的顶点奇异性，使用了一个正则化表达式：$A = 9K\\alpha^2 + G \\frac{J_2^{tr}}{\\max(J_2^{tr}, \\epsilon^2)} + H$，其中 $\\epsilon$ 是一个小的容差。然后塑性乘子为 $\\Delta\\lambda = f^{tr}/A$。\n    c. 更新应力和硬化变量：\n       $$\n       \\sigma^{n+1} = \\sigma^{tr} - \\Delta\\lambda (\\mathbb{C}:n^{tr})\n       $$\n       $$\n       \\kappa^{n+1} = \\kappa^n + \\Delta\\lambda\n       $$\n       项 $\\mathbb{C}:n^{tr}$ 展开为 $\\mathbb{C}:n^{tr} = 3K\\alpha\\mathbf{I} + 2G n_{dev}^{tr}$，其中 $n_{dev}^{tr}$ 是 $n^{tr}$ 的偏量部分。在计算 $n_{dev}^{tr}$ 时，通过使用 $\\sqrt{J_2^{tr}} \\leftarrow \\max(\\sqrt{J_2^{tr}}, \\epsilon)$ 对 $\\sqrt{J_2}$ 的导数进行正则化，以避免除以零。然后该子步成功。\n\n以上是基于所提供原则的算法设计的详细描述。", "answer": "```python\nimport numpy as np\n\ndef voigt_to_tensor(v_strain):\n    \"\"\"Converts a 6x1 Voigt strain vector to a 3x3 strain tensor.\"\"\"\n    eps = np.zeros((3, 3))\n    eps[0, 0] = v_strain[0]\n    eps[1, 1] = v_strain[1]\n    eps[2, 2] = v_strain[2]\n    # Engineering shear strain to tensor shear strain conversion\n    eps[1, 2] = eps[2, 1] = v_strain[3] / 2.0\n    eps[0, 2] = eps[2, 0] = v_strain[4] / 2.0\n    eps[0, 1] = eps[1, 0] = v_strain[5] / 2.0\n    return eps\n\ndef tensor_to_voigt(t_stress):\n    \"\"\"Converts a 3x3 stress tensor to a 6x1 Voigt stress vector.\"\"\"\n    return np.array([\n        t_stress[0, 0],\n        t_stress[1, 1],\n        t_stress[2, 2],\n        t_stress[1, 2],\n        t_stress[0, 2],\n        t_stress[0, 1]\n    ])\n\ndef run_stress_integration(params):\n    \"\"\"\n    Performs adaptive explicit stress integration for a single test case.\n    \"\"\"\n    K, G, alpha, H, k0, delta_eps_voigt, tau = params\n    \n    delta_eps_total_tensor = voigt_to_tensor(delta_eps_voigt)\n    \n    # Lame parameters\n    lambda_lame = K - (2.0 / 3.0) * G\n    mu_lame = G\n\n    # Regularization epsilon\n    epsilon = 1e-12\n\n    # Adaptive substepping loop\n    N = 1\n    N_max = 2048\n    \n    while N = N_max:\n        # State variables at the start of the total increment\n        sigma_current = np.zeros((3, 3))\n        kappa_current = 0.0\n        \n        delta_eps_sub = delta_eps_total_tensor / N\n        \n        restart_needed = False\n        for _ in range(N):\n            # Elastic Predictor\n            tr_delta_eps_sub = np.trace(delta_eps_sub)\n            sigma_tr = sigma_current + lambda_lame * tr_delta_eps_sub * np.eye(3) + 2.0 * mu_lame * delta_eps_sub\n\n            # Yield Check\n            I1_tr = np.trace(sigma_tr)\n            s_tr = sigma_tr - (I1_tr / 3.0) * np.eye(3)\n            J2_tr = 0.5 * np.sum(s_tr * s_tr)\n            \n            # Avoid sqrt of negative J2 from machine precision errors\n            if J2_tr  0: J2_tr = 0\n            sqrt_J2_tr = np.sqrt(J2_tr)\n            \n            k_n = k0 + H * kappa_current\n            f_tr = alpha * I1_tr + sqrt_J2_tr - k_n\n\n            if f_tr = 0:\n                # Elastic step\n                sigma_current = sigma_tr\n                # kappa_current remains unchanged\n            else:\n                if f_tr > tau:\n                    restart_needed = True\n                    break\n                else:\n                    # Explicit Plastic Corrector\n                    denom_A = 9.0 * K * alpha**2 + G * J2_tr / max(J2_tr, epsilon**2) + H\n                    delta_lambda = f_tr / denom_A\n\n                    sqrt_J2_tr_reg = max(sqrt_J2_tr, epsilon)\n                    n_dev_tr = s_tr / (2.0 * sqrt_J2_tr_reg)\n\n                    correction_term = delta_lambda * (3.0 * K * alpha * np.eye(3) + 2.0 * G * n_dev_tr)\n                    \n                    sigma_current = sigma_tr - correction_term\n                    kappa_current = kappa_current + delta_lambda\n\n        if restart_needed:\n            N *= 2\n            continue\n        else:\n            # All substeps successful\n            final_sigma = sigma_current\n            break\n    \n    if N > N_max:\n        # Loop terminated due to N_max, return current result\n        final_sigma = sigma_current\n\n    final_stress_voigt = tensor_to_voigt(final_sigma)\n    rounded_stress = [round(s, 3) for s in final_stress_voigt]\n    \n    return rounded_stress + [N]\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the stress integration for each.\n    \"\"\"\n    test_cases = [\n        (20000, 10000, 0.12, 800, 100, np.array([2e-4, 0, 0, 0, 0, 1e-4]), 5),\n        (20000, 10000, 0.12, 800, 100, np.array([1e-7, 1e-7, 1e-7, 0, 0, 0]), 5),\n        (15000, 7000, 0.18, 500, 80, np.array([0, 0, 0, 8e-4, 0, 0]), 2),\n        (25000, 12000, 0.10, 1200, 50, np.array([4e-4, 4e-4, 4e-4, 0, 0, 0]), 3)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_stress_integration(case)\n        results.append(result)\n\n    print(f\"{results}\")\n\nsolve()\n```", "id": "3523495"}]}