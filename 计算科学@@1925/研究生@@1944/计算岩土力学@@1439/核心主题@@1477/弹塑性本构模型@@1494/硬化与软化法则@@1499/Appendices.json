{"hands_on_practices": [{"introduction": "在计算塑性力学中，实现本构模型是核心技能之一，而运动硬化模型是模拟循环加载行为（如土的循环剪切）的基础。本练习 [@problem_id:3529165] 将带您深入研究后向欧拉积分格式——这是计算塑性力学的“主力军”。您将推导塑性乘子增量的标量残差方程，以及至关重要的、确保全局牛顿-拉夫逊求解器二次收敛的一致算法切线，从而掌握在有限元代码中实现塑性模型的关键技术。", "problem": "考虑一个质点，在不排水条件下经历小应变简单剪切，该质点所在的土壤采用 von Mises (J2) 弹塑性模型进行建模，该模型包含 Armstrong–Frederick 型非线性随动硬化，并处于一个边界曲面框架内，其中随动硬化通过动态恢复达到饱和。不排水条件意味着体积应变增量为零，因此在加载过程中只有剪切响应会演化。目标是推导、实现并测试用于本构方程后向欧拉积分的一致性算法切线。\n\n基本理论基础包括以下经过充分检验的定义和法则：\n- 小应变叠加性：$d\\boldsymbol{\\varepsilon} = d\\boldsymbol{\\varepsilon}^{e} + d\\boldsymbol{\\varepsilon}^{p}$。\n- 偏量响应的线性各向同性弹性：$\\boldsymbol{s} = 2 G \\boldsymbol{\\varepsilon}^{e}_{\\text{dev}}$，其中 $G$ 是剪切模量。\n- 包含随动位移的 Von Mises (J2) 屈服函数：$f = \\sqrt{\\dfrac{3}{2}} \\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\| - \\sigma_{y}$，其中 $\\sigma_{y}$ 是当前屈服应力（在本问题中视为常数），$\\boldsymbol{s}$ 是偏应力张量，$\\boldsymbol{\\alpha}$ 是背应力张量。\n- 相关流动法则：$d\\boldsymbol{\\varepsilon}^{p}_{\\text{dev}} = d p \\, \\dfrac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = d p \\, \\sqrt{\\dfrac{3}{2}} \\, \\dfrac{\\boldsymbol{s} - \\boldsymbol{\\alpha}}{\\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\|}$，其中塑性乘子 $d p \\ge 0$。\n- Armstrong–Frederick 非线性随动硬化：$d\\boldsymbol{\\alpha} = c \\, d\\boldsymbol{\\varepsilon}^{p}_{\\text{dev}} - \\gamma \\, \\boldsymbol{\\alpha} \\, d p$，其中 $c$ 是随动硬化模量，$\\gamma$ 是控制饱和的动态恢复参数（这些参数均为常数）。\n- 此处的边界曲面解释是通过动态恢复项使 $\\boldsymbol{\\alpha}$ 饱和，从而限制了屈服面的平移。\n\n将响应限制在只有 $\\boldsymbol{12}$ 分量非零的简单剪切情况下，并假设所有量在该一维偏量子空间中保持共线。设工程剪切应变为 $\\gamma$，剪切应力为 $\\tau$，则 $\\tau = G \\gamma^{e}$，其中 $\\gamma^{e} = \\gamma - \\gamma^{p}$。设背应力分量为 $a = \\alpha_{12}$。在简单剪切中的 J2 等效范数给出 $\\sqrt{\\dfrac{3}{2}} \\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\| = \\sqrt{3} \\, \\left| \\tau - a \\right|$。\n\n在每个应变增量 $d \\gamma$ 处使用后向欧拉（隐式）校正：\n- 试探应力：$\\tau_{\\text{tr}} = \\tau_{\\text{prev}} + G \\, d \\gamma$。\n- 在简单剪切中，后向欧拉和相关流动法则下的塑性流动产生 $d \\gamma^{p} = \\sqrt{3} \\, d p \\, \\operatorname{sign}(\\tau - a)$（在增量结束时）。\n- 在简单剪切中，使用后向欧拉的 Armstrong–Frederick 更新：$a_{\\text{new}} = \\dfrac{a_{\\text{prev}} + c \\, \\sqrt{\\dfrac{3}{4}} \\, d p \\, \\operatorname{sign}(\\tau_{\\text{new}} - a_{\\text{new}})}{1 + \\gamma \\, d p}$。\n- 应力校正：$\\tau_{\\text{new}} = \\tau_{\\text{tr}} - G \\, \\sqrt{3} \\, d p \\, \\operatorname{sign}(\\tau_{\\text{new}} - a_{\\text{new}})$。\n- 一致性条件：$\\sqrt{3} \\, \\left| \\tau_{\\text{new}} - a_{\\text{new}} \\right| = \\sigma_{y}$。\n\n任务 1. 从上述基本理论基础出发，并使用一维简单剪切子空间中的后向欧拉离散化，推导一个关于塑性乘子增量 $d p$ 的标量非线性残差方程，该方程强制执行一致性条件，且仅用增量开始时的已知量（$\\tau_{\\text{prev}}$、$a_{\\text{prev}}$）、试探应力 $\\tau_{\\text{tr}}$ 和材料参数（$G$、$\\sigma_{y}$、$c$、$\\gamma$）表示。然后，通过计算残差相对于 $d p$ 的导数，推导 $d p$ 的牛顿法更新公式。\n\n任务 2. 从相同的后向欧拉积分出发，推导一致性算法剪切切线 $C_{\\text{alg}} = \\dfrac{d \\tau_{\\text{new}}}{d \\gamma}$，该切线在所选积分方案内将应力响应对应变增量进行线性化。用 $G$、$c$、$\\gamma$、$a_{\\text{prev}}$ 和增量收敛后的 $d p$ 表示 $C_{\\text{alg}}$。\n\n任务 3. 实现一个程序，为一系列应变增量执行以下操作：\n- 依次施加每个剪切应变增量 $d \\gamma$。\n- 在每个增量中，计算 $\\tau_{\\text{tr}}$，并使用试探屈服函数 $f_{\\text{tr}} = \\sqrt{3} \\, \\left| \\tau_{\\text{tr}} - a_{\\text{prev}} \\right| - \\sigma_{y}$ 检验弹性。如果 $f_{\\text{tr}} \\le 0$，则该步为弹性，无需牛顿迭代；设置 $d p = 0$，$\\tau_{\\text{new}} = \\tau_{\\text{tr}}$，$a_{\\text{new}} = a_{\\text{prev}}$，以及 $C_{\\text{alg}} = G$。\n- 如果 $f_{\\text{tr}}  0$，则使用牛顿法对推导出的残差方程求解 $d p$。使用从线性随动硬化情况（$\\gamma = 0$）推导出的数值上合理的初始猜测，将 $d p$ 限制在 $d p \\ge 0$，并对残差范数使用 $\\epsilon = 10^{-10}$ 的容差，最大迭代次数为 $50$ 次。更新 $\\tau_{\\text{new}}$、$a_{\\text{new}}$，并根据任务 2 计算 $C_{\\text{alg}}$。\n- 跟踪每个增量所需的牛顿迭代次数。\n\n您的程序应通过报告每个测试案例在所有增量中观察到的牛顿迭代最大次数（作为整数）来评估在严重不排水软化循环下的牛顿法收敛性。所有应力单位必须是千帕 (kPa)，应变为无量纲，不出现角度。最终输出中不要求任何物理量；仅需要迭代次数。\n\n测试套件。使用以下四个测试案例，每个案例由一个元组 $(G, \\sigma_{y}, c, \\gamma, \\text{increments})$ 定义，其中 $G$ 单位为 $\\text{kPa}$，$\\sigma_{y}$ 单位为 $\\text{kPa}$，$c$ 单位为 $\\text{kPa}$，$\\gamma$ 单位为 $\\text{(strain)}^{-1}$，应变增量为无量纲：\n- 案例 1（一般循环加载）：$(G = 50000, \\sigma_{y} = 100, c = 15000, \\gamma = 80, \\text{increments} = [0.002, 0.002, -0.004, 0.004, -0.004, 0.004])$。\n- 案例 2（由于强动态恢复导致的严重软化）：$(G = 30000, \\sigma_{y} = 60, c = 5000, \\gamma = 600, \\text{increments} = [0.004, -0.008, 0.008, -0.008, 0.008])$。\n- 案例 3（接近弹性状态且增量非常小）：$(G = 40000, \\sigma_{y} = 200, c = 10000, \\gamma = 50, \\text{increments} = [0.0005, -0.0005, 0.0005, -0.0005])$。\n- 案例 4（接近屈服的边界情况并伴随反向加载）：$(G = 35000, \\sigma_{y} = 80, c = 8000, \\gamma = 200, \\text{increments} = [0.0012, 0.0012, -0.0024])$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述案例顺序排列结果。例如，如果各增量上的最大牛顿迭代次数为 $n_{1}$、$n_{2}$、$n_{3}$ 和 $n_{4}$，您的程序必须精确输出：$[n_{1},n_{2},n_{3},n_{4}]$。", "solution": "用户提供的问题要求推导并实现一个用于一维简单剪切 von Mises 弹塑性模型的后向欧拉返回映射算法，该模型包含非线性 Armstrong–Frederick 随动硬化。解决方案分为三个部分，对应问题陈述中指定的任务。\n\n### 任务 1：残差方程和牛顿更新的推导\n\n目标是找到塑性乘子增量，记为 $dp$，以确保增量结束时的状态（“新”状态）满足屈服条件，也称为一致性条件。这通过构建一个残差方程 $R(dp) = 0$ 并通过数值方法（通常是牛顿法）求解来实现。\n\n设增量开始时的状态变量为剪切应力 $\\tau_{\\text{prev}}$ 和背应力 $a_{\\text{prev}}$。增量由总剪切应变增量 $d\\gamma$ 驱动。\n\n**1. 试探状态：**\n首先，假设整个应变增量 $d\\gamma$ 都是弹性的，计算一个弹性试探状态。\n试探应力 $\\tau_{\\text{tr}}$ 为：\n$$ \\tau_{\\text{tr}} = \\tau_{\\text{prev}} + G \\, d\\gamma $$\n在试探步骤中，背应力保持不变：$a_{\\text{tr}} = a_{\\text{prev}}$。\n\n**2. 屈服检查：**\n如果试探状态位于屈服面之外，则发生塑性。简单剪切中的屈服函数为 $f = \\sqrt{3} |\\tau - a| - \\sigma_y$。试探屈服函数为：\n$$ f_{\\text{tr}} = \\sqrt{3} |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\sigma_y $$\n如果 $f_{\\text{tr}} \\le 0$，则该步是弹性的。最终状态即为试探状态，且 $dp=0$。如果 $f_{\\text{tr}} > 0$，则需要进行塑性修正。\n\n**3. 塑性校正（返回映射）：**\n最终状态 $(\\tau_{\\text{new}}, a_{\\text{new}})$ 必须满足本构方程和一致性条件，所有这些都使用后向欧拉格式进行离散化。\n流动方向由相对应力的符号确定。我们假设此符号保持不变，并由试探状态给出：\n$$ S = \\operatorname{sign}(\\tau_{\\text{tr}} - a_{\\text{prev}}) $$\n使用提供的后向欧拉更新规则：\n$$ \\tau_{\\text{new}} = \\tau_{\\text{tr}} - G \\sqrt{3} \\, dp \\, S $$\n$$ a_{\\text{new}} = \\frac{a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp \\, S}{1 + \\gamma \\, dp} $$\n步骤结束时的一致性条件要求：\n$$ \\sqrt{3} |\\tau_{\\text{new}} - a_{\\text{new}}| = \\sigma_y $$\n假设符号 $S$ 保持不变，这变为：\n$$ \\tau_{\\text{new}} - a_{\\text{new}} = S \\frac{\\sigma_y}{\\sqrt{3}} $$\n现在，将 $\\tau_{\\text{new}}$ 和 $a_{\\text{new}}$ 的表达式代入一致性条件：\n$$ \\left( \\tau_{\\text{tr}} - G \\sqrt{3} \\, dp \\, S \\right) - \\left( \\frac{a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp \\, S}{1 + \\gamma \\, dp} \\right) = S \\frac{\\sigma_y}{\\sqrt{3}} $$\n为了形成残差方程，我们将所有项移到一边。让我们定义试探状态下的相对应力为 $\\xi_{\\text{tr}} = \\tau_{\\text{tr}} - a_{\\text{prev}}$。注意 $S = \\operatorname{sign}(\\xi_{\\text{tr}})$，因此 $S \\xi_{\\text{tr}} = |\\xi_{\\text{tr}}|$。\n方程两边乘以 $S$（因为 $S^2=1$）：\n$$ S\\tau_{\\text{tr}} - G \\sqrt{3} \\, dp - \\left( \\frac{S a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp}{1 + \\gamma \\, dp} \\right) = \\frac{\\sigma_y}{\\sqrt{3}} $$\n$$ S\\tau_{\\text{tr}} - S a_{\\text{prev}} - G \\sqrt{3} \\, dp - \\left( \\frac{S a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp}{1 + \\gamma \\, dp} \\right) + S a_{\\text{prev}} = \\frac{\\sigma_y}{\\sqrt{3}} $$\n$$ S(\\tau_{\\text{tr}} - a_{\\text{prev}}) - G \\sqrt{3} \\, dp - \\frac{S a_{\\text{prev}} (1+\\gamma dp) - S a_{\\text{prev}} + c (\\sqrt{3}/2) dp}{1+\\gamma dp} = \\frac{\\sigma_y}{\\sqrt{3}} $$\n这变得复杂了。让我们使用相对应力 $\\xi = \\tau - a$。\n一致性条件是 $\\xi_{\\text{new}} = S\\sigma_y/\\sqrt{3}$。让我们将 $\\xi_{\\text{new}}$ 表示为 $dp$ 的函数：\n$$ \\xi_{\\text{new}} = \\tau_{\\text{new}} - a_{\\text{new}} = (\\tau_{\\text{tr}} - G\\sqrt{3} S dp) - \\frac{a_{\\text{prev}} + c(\\sqrt{3}/2)S dp}{1+\\gamma dp} $$\n$$ \\xi_{\\text{new}} = \\tau_{\\text{tr}} - a_{\\text{prev}} + a_{\\text{prev}} - G\\sqrt{3}S dp - \\frac{a_{\\text{prev}} + c(\\sqrt{3}/2)S dp}{1+\\gamma dp} $$\n$$ \\xi_{\\text{new}} = \\xi_{\\text{tr}} - G\\sqrt{3}S dp + \\frac{a_{\\text{prev}}(1+\\gamma dp) - (a_{\\text{prev}} + c(\\sqrt{3}/2)S dp)}{1+\\gamma dp} $$\n$$ \\xi_{\\text{new}} = \\xi_{\\text{tr}} - G\\sqrt{3}S dp + \\frac{a_{\\text{prev}}\\gamma dp - c(\\sqrt{3}/2)S dp}{1+\\gamma dp} $$\n设 $\\xi_{\\text{new}} = S\\sigma_y/\\sqrt{3}$ 并乘以 $S$：\n$$ \\frac{\\sigma_y}{\\sqrt{3}} = S\\xi_{\\text{tr}} - G\\sqrt{3} dp + \\frac{S a_{\\text{prev}}\\gamma dp - c(\\sqrt{3}/2) dp}{1+\\gamma dp} $$\n$$ \\frac{\\sigma_y}{\\sqrt{3}} = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - G\\sqrt{3} dp - \\frac{(c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma) dp}{1+\\gamma dp} $$\n因此，残差方程 $R(dp) = 0$ 为：\n$$ R(dp) = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} - G\\sqrt{3} dp - \\frac{(c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma) dp}{1+\\gamma dp} = 0 $$\n注意 $f_{\\text{tr}}/\\sqrt{3} = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\sigma_y/\\sqrt{3}$。因此残差可以写为：\n$$ R(dp) = \\frac{f_{\\text{tr}}}{\\sqrt{3}} - \\left( G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{1+\\gamma dp} \\right) dp = 0 $$\n\n**4. 牛顿法更新公式：**\n为了使用牛顿法求解 $R(dp)=0$，我们需要 $R$ 相对于 $dp$ 的导数，记为 $R'(dp)$。\n令项 $K = c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma$。\n$$ R(dp) = \\frac{f_{\\text{tr}}}{\\sqrt{3}} - G\\sqrt{3} dp - K \\frac{dp}{1+\\gamma dp} $$\n$$ R'(dp) = \\frac{d R}{d(dp)} = -G\\sqrt{3} - K \\frac{d}{d(dp)}\\left( \\frac{dp}{1+\\gamma dp} \\right) $$\n使用商法则，$\\frac{d}{dx}(\\frac{u}{v}) = \\frac{u'v-uv'}{v^2}$：\n$$ \\frac{d}{d(dp)}\\left( \\frac{dp}{1+\\gamma dp} \\right) = \\frac{1(1+\\gamma dp) - dp(\\gamma)}{(1+\\gamma dp)^2} = \\frac{1}{(1+\\gamma dp)^2} $$\n所以，残差的导数为：\n$$ R'(dp) = -G\\sqrt{3} - \\frac{K}{(1+\\gamma dp)^2} = - \\left( G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2} \\right) $$\n在第 $k$ 次迭代中，对 $dp$ 的牛顿-拉弗森更新为：\n$$ dp_{k+1} = dp_k - \\frac{R(dp_k)}{R'(dp_k)} $$\n\n### 任务 2：一致性算法切线的推导\n\n一致性算法切线 $C_{\\text{alg}}$ 是更新后的应力 $\\tau_{\\text{new}}$ 相对于总应变增量 $d\\gamma$ 的导数。\n$$ C_{\\text{alg}} = \\frac{d\\tau_{\\text{new}}}{d(d\\gamma)} $$\n我们有 $\\tau_{\\text{new}} = \\tau_{\\text{prev}} + G d\\gamma - G\\sqrt{3}S\\,dp$。对 $d\\gamma$ 求导：\n$$ C_{\\text{alg}} = G - G\\sqrt{3}S \\frac{d(dp)}{d(d\\gamma)} $$\n在这里，$S = \\operatorname{sign}(\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}})$ 在试探步骤确定加载方向后，在增量内被视为常数。塑性乘子 $dp$ 是 $d\\gamma$ 的隐函数，通过残差方程 $R(dp, d\\gamma) = 0$ 建立关系。我们对 $R=0$ 使用隐式微分：\n$$ dR = \\frac{\\partial R}{\\partial(dp)} d(dp) + \\frac{\\partial R}{\\partial(d\\gamma)} d(d\\gamma) = 0 $$\n这给出 $\\frac{d(dp)}{d(d\\gamma)} = - \\left( \\frac{\\partial R}{\\partial(dp)} \\right)^{-1} \\frac{\\partial R}{\\partial(d\\gamma)}$。\n我们已经找到了 $\\frac{\\partial R}{\\partial(dp)} = R'(dp)$。现在我们求 $\\frac{\\partial R}{\\partial(d\\gamma)}$：\n$$ \\frac{\\partial R}{\\partial(d\\gamma)} = \\frac{\\partial}{\\partial(d\\gamma)}\\left( |\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} - \\dots \\right) = \\frac{\\partial}{\\partial(d\\gamma)}\\left( S(\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}}) \\right) = SG $$\n因此：\n$$ \\frac{d(dp)}{d(d\\gamma)} = - \\frac{SG}{R'(dp)} = \\frac{SG}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\n将此代回 $C_{\\text{alg}}$ 的表达式中：\n$$ C_{\\text{alg}} = G - G\\sqrt{3}S \\left( \\frac{SG}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} \\right) $$\n因为 $S^2=1$：\n$$ C_{\\text{alg}} = G - \\frac{G^2\\sqrt{3}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\n这可以重新整理成一个更紧凑的形式：\n$$ C_{\\text{alg}} = G \\left( 1 - \\frac{G\\sqrt{3}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} \\right) = G \\frac{\\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\n$$ C_{\\text{alg}} = \\frac{G (c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma)}{G\\sqrt{3}(1+\\gamma dp)^2 + c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma} $$\n这个 $C_{\\text{alg}}$ 的表达式使用了增量收敛后的 $dp$ 值。对于弹性步骤（$dp=0$），表达式必须简化为 $G$。在塑性情况下，$S$ 和 $a_{\\text{prev}}$ 是已知量，所以表达式是完全定义的。如果 $dp=0$，那么 $S$ 无关紧要，因为 dp 的导数的分子在概念上为零。弹性切线就是 $G$。\n\n### 任务 3：实现\n推导的方程在一个 Python 程序中实现。对于每个应变增量，主要逻辑遵循以下步骤：\n1.  计算试探应力 $\\tau_{\\text{tr}}$ 和试探屈服函数 $f_{\\text{tr}}$。\n2.  如果 $f_{\\text{tr}} \\le 0$，该步是弹性的。更新 $\\tau_{\\text{new}} = \\tau_{\\text{tr}}$，$a_{\\text{new}} = a_{\\text{prev}}$。牛顿迭代次数为 $0$。\n3.  如果 $f_{\\text{tr}} > 0$，该步是塑性的。\n    a.  确定符号 $S = \\operatorname{sign}(\\tau_{\\text{tr}} - a_{\\text{prev}})$。\n    b.  根据线性硬化情况（$\\gamma=0$）计算 $dp$ 的初始猜测：$dp_0 = f_{\\text{tr}} / (3G + 1.5c)$。\n    c.  启动牛顿-拉弗森循环，使用任务 1 中推導的残差 $R(dp)$ 及其导数 $R'(dp)$ 来求解 $R(dp) = 0$ 以获得 $dp$。\n    d.  在每次迭代中将 $dp$ 限制在 $dp \\ge 0$。\n    e.  当 $|R(dp)|$ 小于容差（$\\epsilon=10^{-10}$）或达到最大迭代次数（$50$）时停止。\n    f.  计算迭代次数。\n    g.  使用收敛的 $dp$ 更新 $\\tau_{\\text{new}}$ 和 $a_{\\text{new}}$。\n4.  跟踪每个测试案例在所有增量中的最大牛顿迭代次数。\n5.  报告最大迭代次数的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases defined as (G, sigma_y, c, gamma, increments)\n    # G in kPa, sigma_y in kPa, c in kPa, gamma dimensionless, increments dimensionless\n    test_cases = [\n        # Case 1: general cyclic loading\n        (50000.0, 100.0, 15000.0, 80.0, [0.002, 0.002, -0.004, 0.004, -0.004, 0.004]),\n        # Case 2: severe softening due to strong dynamic recovery\n        (30000.0, 60.0, 5000.0, 600.0, [0.004, -0.008, 0.008, -0.008, 0.008]),\n        # Case 3: near-elastic regime with very small increments\n        (40000.0, 200.0, 10000.0, 50.0, [0.0005, -0.0005, 0.0005, -0.0005]),\n        # Case 4: boundary case near yield with reversal\n        (35000.0, 80.0, 8000.0, 200.0, [0.0012, 0.0012, -0.0024]),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_iters = run_simulation(*params)\n        results.append(max_iters)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(G, sigma_y, c, gamma, increments):\n    \"\"\"\n    Performs the elastoplastic simulation for a single test case.\n\n    Args:\n        G (float): Shear modulus.\n        sigma_y (float): Yield stress.\n        c (float): Kinematic hardening modulus.\n        gamma (float): Dynamic recovery parameter.\n        increments (list of float): Sequence of shear strain increments.\n\n    Returns:\n        int: The maximum number of Newton iterations over all increments.\n    \"\"\"\n    tau_prev = 0.0\n    a_prev = 0.0\n    max_newton_iterations = 0\n    sqrt3 = np.sqrt(3.0)\n\n    for d_gamma in increments:\n        # --- ELASTIC PREDICTOR ---\n        tau_tr = tau_prev + G * d_gamma\n        xi_tr = tau_tr - a_prev\n\n        # Trial yield function\n        # A small tolerance is used for the elastic check to handle floating point inaccuracies\n        f_tr = sqrt3 * np.abs(xi_tr) - sigma_y\n\n        if f_tr = 1e-12:\n            # Elastic step\n            tau_new = tau_tr\n            a_new = a_prev\n            current_iterations = 0\n        else:\n            # --- PLASTIC CORRECTOR ---\n            S = np.sign(xi_tr)\n            \n            # Initial guess for dp from the linear hardening case (gamma = 0)\n            dp0_denom = 3.0 * G + 1.5 * c\n            dp = f_tr / dp0_denom if dp0_denom > 1e-12 else 0.0\n            \n            # Clamp initial guess to be non-negative\n            dp = max(0.0, dp)\n\n            # Newton-Raphson iteration for plastic multiplier dp\n            tol = 1e-10\n            max_iter_newton = 50\n            current_iterations = 0\n\n            for i in range(max_iter_newton):\n                current_iterations += 1\n                \n                # Pre-calculate hardening-recovery term for residual and derivative\n                K = c * sqrt3 / 2.0 - S * a_prev * gamma\n                \n                # Check for unstable denominator, though dp should be non-negative\n                denom = 1.0 + gamma * dp\n                if denom  1e-9: # Avoid division by zero/small number\n                    dp = 0.0 # Revert to a safe value\n                    denom = 1.0\n\n                # Residual function R(dp)\n                # R(dp) = f_tr/sqrt(3) - [G*sqrt(3) + K/(1+gamma*dp)]*dp\n                residual = f_tr / sqrt3 - sqrt3 * G * dp - K * dp / denom\n                \n                if np.abs(residual)  tol:\n                    break\n\n                # Derivative of the residual R'(dp)\n                residual_prime = -sqrt3 * G - K / (denom**2)\n\n                if np.abs(residual_prime)  1e-12:\n                    # Jacobian is singular, break to avoid division by zero\n                    # This may indicate convergence issues, but the algorithm will proceed with the last dp.\n                    break\n                \n                # Newton update\n                dp_update = -residual / residual_prime\n                dp += dp_update\n                \n                # Clamp dp to be non-negative. This handles cases of elastic unloading\n                # detected during the iterative correction.\n                dp = max(0.0, dp)\n            \n            # --- Update state variables ---\n            tau_new = tau_tr - G * sqrt3 * dp * S\n            a_new = (a_prev + c * sqrt3 / 2.0 * dp * S) / (1.0 + gamma * dp)\n\n        if current_iterations > max_newton_iterations:\n            max_newton_iterations = current_iterations\n        \n        # update for next increment\n        tau_prev = tau_new\n        a_prev = a_new\n        \n    return max_newton_iterations\n\n# Execute the simulation and print the results.\nsolve()\n```", "id": "3529165"}, {"introduction": "与硬化模型相比，包含应变软化的标准连续介质模型在数值模拟中会表现出病态的网格依赖性，导致结果缺乏物理意义。本练习 [@problem_id:3529154] 引入了断裂带模型，这是一种强大的正则化技术，它通过将本构定律与材料的断裂能 $G_f$ 联系起来，恢复了数值解的网格客观性。您将亲手标定一个软化本构，并验证总耗散能独立于单元尺寸，从而掌握在模拟材料局部化和失效时获得可靠结果的基本方法。", "problem": "给定一个带缺口试件的单轴拉伸模型，该模型由一个一维串联系统表示：一个弹性杆段与一个发生软化的裂纹带有限元串联。弹性段的杨氏模量为 $E$，横截面积为 $A$，长度为 $L_r = L_{\\text{tot}} - h$，其中 $L_{\\text{tot}}$ 是试件总长度，$h$ 是裂纹带的单元特征长度。裂纹带单元遵循关于等效塑性应变 $\\varepsilon_p$ 的软化定律 $\\sigma(\\varepsilon_p)$，相应的内聚力牵引-分离定律 $T(w)$ 通过 $w = h \\, \\varepsilon_p$ 和 $T(w) = \\sigma(\\varepsilon_p)$ 建立联系。抗拉强度为 $f_t$，目标I型断裂能为 $G_f$。\n\n基本原理：\n- 裂纹带能量等效性指出，每单位面积耗散的能量等于材料的断裂能。对于一个特征长度为 $h$ 的连续体单元，其要求是\n$$\n\\int_{0}^{\\varepsilon_{p,\\text{end}}} \\sigma(\\varepsilon_p) \\, d\\varepsilon_p = \\frac{G_f}{h}.\n$$\n- 裂纹带单元的牵引-分离定律 $T(w)$ 必须满足\n$$\n\\int_{0}^{w_{\\text{end}}} T(w) \\, dw = G_f,\n$$\n其中 $w = h \\, \\varepsilon_p$ 且 $T(w) = \\sigma(\\varepsilon_p)$。\n- 对于一个长度为 $L_r$ 的弹性段与一个内聚单元串联，在施加的末端位移 $\\Delta$ 作用下，平衡关系为\n$$\nF = A \\, T(w), \\quad \\Delta = \\frac{L_r}{E A} \\, F + w,\n$$\n弹性加载直至在 $\\Delta_y = \\frac{f_t L_r}{E}$ 和 $F_y = f_t A$ 时发生屈服。\n\n你的任务：\n1. 标定两种形式的软化定律 $\\sigma(\\varepsilon_p)$，以使裂纹带能量等效性成立：\n   - 线性软化：$\\sigma(\\varepsilon_p) = f_t \\, \\max\\!\\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}, 0\\right)$，对于 $0 \\le \\varepsilon_p \\le \\varepsilon_f$。\n   - 指数软化：$\\sigma(\\varepsilon_p) = f_t \\, \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right)$，对于 $0 \\le \\varepsilon_p  \\infty$。\n   从基本原理出发推导标定参数 $\\varepsilon_f$ 和 $\\varepsilon_c$，不使用简化公式。\n\n2. 使用已标定的 $T(w)$，通过比较每个测试用例中两种不同裂纹带单元尺寸 $h$ 下直至完全破坏所做的总外力功，来验证带缺口试件模型的网格客观性。总外力功应等于在整个断裂面上耗散的断裂能，即 $A \\, G_f$ 焦耳。通过组合直至 $\\Delta_y$ 的弹性加载和屈服后软化过程来计算总功。弹性段的卸载和内聚软化过程可能会表现出回弹（snap-back）现象；因此，你的计算必须对非单调的力-位移行为具有鲁棒性，且不得依赖于对 $\\Delta(w)$ 的反函数求解。\n\n3. 通过计算每个 $h$ 的 $\\int \\sigma(\\varepsilon_p) \\, d\\varepsilon_p$ 并将其与 $\\frac{G_f}{h}$ 进行比较，来数值验证标定结果。同时计算每个 $h$ 直至破坏的总外力功，并将其与 $A \\, G_f$ 进行比较。\n\n单位与数值要求：\n- 使用国际单位制 (SI)：$E$ 的单位是帕斯卡 (Pa)，$A$ 的单位是平方米 ($\\mathrm{m}^2$)，$L_{\\text{tot}}$、$L_r$ 和 $h$ 的单位是米 ($\\mathrm{m}$)，$f_t$ 的单位是帕斯卡 (Pa)，$G_f$ 的单位是焦耳/平方米 ($\\mathrm{J/m^2}$)，$w$ 的单位是米 ($\\mathrm{m}$)，$\\varepsilon_p$ 无量纲，$\\Delta$ 的单位是米 ($\\mathrm{m}$)，$F$ 的单位是牛顿 (N)，总外力功的单位是焦耳 (J)。\n- 报告差异时，应以小数形式（无单位）表示，而非使用百分号。例如，报告 $0.001$ 表示 $0.1\\%$ 的差异。\n- 你的程序应为每个测试用例计算四个相对误差中的最大值：两个来自软化定律面积检查（每个 $h$ 一个），两个来自网格客观性功检查（每个 $h$ 一个）。\n\n测试套件：\n- 测试用例1（线性软化，正常路径）：\n  - $E = 30 \\times 10^9$ Pa, $f_t = 3 \\times 10^6$ Pa, $G_f = 120$ $\\mathrm{J/m^2}$, $A = 5 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 1$ $\\mathrm{m}$, $h_1 = 0.02$ $\\mathrm{m}$, $h_2 = 0.10$ $\\mathrm{m}$。\n- 测试用例2（指数软化，正常路径）：\n  - $E = 30 \\times 10^9$ Pa, $f_t = 3 \\times 10^6$ Pa, $G_f = 120$ $\\mathrm{J/m^2}$, $A = 5 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 1$ $\\mathrm{m}$, $h_1 = 0.02$ $\\mathrm{m}$, $h_2 = 0.10$ $\\mathrm{m}$。\n- 测试用例3（线性软化，边界单元尺寸）：\n  - $E = 20 \\times 10^9$ Pa, $f_t = 2 \\times 10^6$ Pa, $G_f = 80$ $\\mathrm{J/m^2}$, $A = 1 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 0.2$ $\\mathrm{m}$, $h_1 = 0.001$ $\\mathrm{m}$, $h_2 = 0.05$ $\\mathrm{m}$。\n\n算法指导：\n- 对于线性软化，内聚定律为 $T(w) = f_t \\left(1 - \\frac{w}{w_f}\\right)$，其中 $0 \\le w \\le w_f$ 且 $w_f = h \\, \\varepsilon_f$。对于指数软化，内聚定律为 $T(w) = f_t \\exp\\!\\left(-\\frac{w}{w_c}\\right)$，其中 $w \\ge 0$ 且 $w_c = h \\, \\varepsilon_c$。\n- 将屈服前弹性功计算为 $W_{\\text{el}} = \\frac{1}{2} \\frac{F_y^2}{k_r}$，其中 $F_y = f_t A$ 且 $k_r = \\frac{E A}{L_r}$。\n- 通过以 $w$ 为参数，对 $F(w) \\, \\frac{d\\Delta}{dw}$ 在 $w$ 上积分来计算屈服后功，其中 $F(w) = A \\, T(w)$ 且 $\\frac{d\\Delta}{dw} = 1 + \\frac{L_r}{E} \\frac{dT}{dw}$。\n- 对于线性软化，在 $w \\in [0, w_f]$ 上积分。对于指数软化，在 $w \\in [0, w_{\\text{end}}]$ 上积分，其中 $w_{\\text{end}}$ 足够大（例如 $w_{\\text{end}} = 12 \\, w_c$），并验证尾部贡献可以忽略不计。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3]\"），每个结果是按上述方法计算的相应测试用例的最大相对误差。", "solution": "问题陈述是有效的。它在科学上基于计算断裂力学的原理，特别是裂纹带模型。所有参数、定义和约束都已提供，构成了一个良态且自洽的问题。数值对于像混凝土这样的准脆性材料是物理上现实的。任务定义清晰且在计算上是可行的。我们将继续提供完整的解决方案。\n\n该解决方案包括三个主要部分：首先，基于断裂能准则，对线性和指数软化定律的参数进行解析标定。其次，建立破坏所需的总外力功的公式，包括对网格客观性的解析证明。第三，描述用于验证这些发现的数值程序。\n\n### 1. 软化定律的标定\n\n标定的基本原理是裂纹带能量等效性，即单元内单位体积耗散的能量，在整个塑性应变历史上积分，必须等于由单元特征长度 $h$ 归一化的断裂能 $G_f$：\n$$\n\\int_{0}^{\\varepsilon_{p,\\text{end}}} \\sigma(\\varepsilon_p) \\, d\\varepsilon_p = \\frac{G_f}{h}\n$$\n此处，$\\sigma(\\varepsilon_p)$ 是作为等效塑性应变 $\\varepsilon_p$ 函数的软化应力。\n\n#### 1.1. 线性软化定律\n线性软化定律由下式给出：\n$$\n\\sigma(\\varepsilon_p) = f_t \\, \\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}\\right), \\quad \\text{for} \\quad 0 \\le \\varepsilon_p \\le \\varepsilon_f\n$$\n其中 $f_t$ 是抗拉强度，$\\varepsilon_f$ 是应力减小到零时的极限塑性应变。我们将其代入能量等效积分中：\n$$\n\\int_{0}^{\\varepsilon_f} f_t \\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}\\right) \\, d\\varepsilon_p = f_t \\left[\\varepsilon_p - \\frac{\\varepsilon_p^2}{2\\varepsilon_f}\\right]_{0}^{\\varepsilon_f} = f_t \\left(\\varepsilon_f - \\frac{\\varepsilon_f^2}{2\\varepsilon_f}\\right) = \\frac{1}{2} f_t \\varepsilon_f\n$$\n将其与所需的耗散能量密度相等：\n$$\n\\frac{1}{2} f_t \\varepsilon_f = \\frac{G_f}{h}\n$$\n求解标定参数 $\\varepsilon_f$ 可得：\n$$\n\\varepsilon_f = \\frac{2 G_f}{h f_t}\n$$\n\n#### 1.2. 指数软化定律\n指数软化定律由下式给出：\n$$\n\\sigma(\\varepsilon_p) = f_t \\, \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right), \\quad \\text{for} \\quad \\varepsilon_p \\ge 0\n$$\n其中 $\\varepsilon_c$ 是一个特征塑性应变。塑性应变理论上延伸至无穷大，因此 $\\varepsilon_{p,\\text{end}} = \\infty$。能量等效积分是：\n$$\n\\int_{0}^{\\infty} f_t \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right) \\, d\\varepsilon_p = f_t \\left[-\\varepsilon_c \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right)\\right]_{0}^{\\infty} = f_t \\left(0 - (-\\varepsilon_c)\\right) = f_t \\varepsilon_c\n$$\n将其与目标能量密度相等：\n$$\nf_t \\varepsilon_c = \\frac{G_f}{h}\n$$\n求解标定参数 $\\varepsilon_c$ 可得：\n$$\n\\varepsilon_c = \\frac{G_f}{h f_t}\n$$\n\n这种基于能量的标定的一个关键推论是，特征裂纹开度 $w = h \\varepsilon_p$ 变得与网格尺寸 $h$ 无关。对于线性软化，最终裂纹开度为 $w_f = h \\varepsilon_f = h \\frac{2G_f}{h f_t} = \\frac{2G_f}{f_t}$。对于指数软化，特征裂纹开度为 $w_c = h \\varepsilon_c = h \\frac{G_f}{h f_t} = \\frac{G_f}{f_t}$。这使得断裂能 $G_f$ 成为内聚裂纹的一个属性，独立于数值离散化 $h$。\n\n### 2. 网格客观性与总功计算\n\n网格客观性要求，导致结构破坏所耗散的总能量是一个恒定的材料属性，与网格尺寸 $h$ 无关。对于此单轴试件，总消耗能量必须等于断裂能 $G_f$ 乘以断裂面积 $A$，即 $A G_f$。我们通过计算从初始加载到完全破坏对系统所做的总外力功 $W_{\\text{total}}$ 来验证这一点。\n\n总功是在初始弹性加载阶段所做的功 $W_{\\text{el}}$ 和在屈服后软化阶段所做的功 $W_{\\text{post-yield}}$ 的总和。\n$$\nW_{\\text{total}} = W_{\\text{el}} + W_{\\text{post-yield}}\n$$\n\n#### 2.1. 弹性功 ($W_{\\text{el}}$)\n系统弹性加载，直到力达到屈服力 $F_y = f_t A$。在此阶段，裂纹开度 $w$ 为零，总位移 $\\Delta$ 完全由长度为 $L_r$ 的杆的弹性变形引起。\n$$\n\\Delta = \\frac{L_r}{E A} F\n$$\n在屈服点，位移为 $\\Delta_y = \\frac{L_r f_t}{E}$。所做的功是力-位移三角形的面积：\n$$\nW_{\\text{el}} = \\frac{1}{2} F_y \\Delta_y = \\frac{1}{2} (f_t A) \\left( \\frac{L_r f_t}{E} \\right) = \\frac{A L_r f_t^2}{2E}\n$$\n\n#### 2.2. 屈服后功 ($W_{\\text{post-yield}}$)\n屈服后，裂纹开度 $w$ 从0开始增加，而力 $F$ 根据软化定律减小。总位移由 $\\Delta(w) = \\frac{L_r}{EA}F(w) + w$ 给出。力为 $F(w) = A T(w)$，其中 $T(w) = \\sigma(w/h)$ 是内聚牵引力。外力功由积分 $\\int F d\\Delta$ 给出。为了处理可能的回弹（非单调的 $\\Delta$），我们用裂纹开度 $w$ 对积分进行参数化：\n$$\nd\\Delta = \\frac{d\\Delta}{dw} dw = \\left(1 + \\frac{L_r}{EA} \\frac{dF}{dw}\\right) dw = \\left(1 + \\frac{L_r}{E} \\frac{dT}{dw}\\right) dw\n$$\n屈服后功则为：\n$$\nW_{\\text{post-yield}} = \\int_{w=0}^{w=w_{\\text{end}}} F(w) \\, d\\Delta = \\int_{0}^{w_{\\text{end}}} A T(w) \\left(1 + \\frac{L_r}{E} \\frac{dT}{dw}\\right) dw\n$$\n$$\nW_{\\text{post-yield}} = A \\int_{0}^{w_{\\text{end}}} T(w) dw + \\frac{A L_r}{E} \\int_{0}^{w_{\\text{end}}} T(w) \\frac{dT}{dw} dw\n$$\n第一项 $A \\int T(w) dw$，根据定义是总断裂能 $A G_f$。第二个积分可以通过认识到 $T(w) dT = \\frac{1}{2} d(T^2)$ 来求解：\n$$\n\\int_{w=0}^{w=w_{\\text{end}}} T(w) \\frac{dT}{dw} dw = \\int_{T(0)}^{T(w_{\\text{end}})} T dT = \\frac{1}{2} [T^2]_{T=f_t}^{T=0} = -\\frac{1}{2} f_t^2\n$$\n这对于任何满足 $T(0)=f_t$ 和 $T(w_{\\text{end}})=0$ 的软化定律都成立。代回原式：\n$$\nW_{\\text{post-yield}} = A G_f + \\frac{A L_r}{E} \\left(-\\frac{1}{2} f_t^2\\right) = A G_f - \\frac{A L_r f_t^2}{2E}\n$$\n\n#### 2.3. 总功与网格客观性\n组合弹性和屈服后功的分量，可得到总功：\n$$\nW_{\\text{total}} = W_{\\text{el}} + W_{\\text{post-yield}} = \\left(\\frac{A L_r f_t^2}{2E}\\right) + \\left(A G_f - \\frac{A L_r f_t^2}{2E}\\right) = A G_f\n$$\n这个解析结果证明，使试件破坏所需的总外力功恰好是 $A G_f$，与单元尺寸 $h$（其包含在 $L_r = L_{\\text{tot}}-h$ 中）、弹性模量 $E$ 或能量标定的软化定律的具体形式无关。这证实了裂纹带模型的公式是网格客观的。\n\n### 3. 数值验证程序\n\n数值实现将验证解析结果。对于每个测试用例和每个 $h \\in \\{h_1, h_2\\}$ 值，将计算以下量。\n\n1.  **软化定律面积检查**：\n    - 计算标定参数（$\\varepsilon_f$ 或 $\\varepsilon_c$）。\n    - 使用 `scipy.integrate.quad` 对积分 $\\int \\sigma(\\varepsilon_p) d\\varepsilon_p$ 进行数值计算。对于指数情况，积分上限为 $\\varepsilon_{p,\\text{end}} = 12 \\varepsilon_c$。\n    - 将数值结果与理论目标值 $G_f/h$ 进行比较，并按 $| \\text{数值} - \\text{目标值} | / \\text{目标值}$ 计算相对误差。\n\n2.  **总功检查**：\n    - 使用解析公式计算弹性功 $W_{\\text{el}}$。\n    - 定义屈服后功的被积函数 $F(w)(d\\Delta/dw)$。\n    - 通过将此函数对 $w$ 从 $0$ 积分到 $w_{\\text{end}}$（线性情况为 $w_f$，指数情况为 $12w_c$）来计算 $W_{\\text{post-yield}}$。\n    - 计算总数值功 $W_{\\text{total,num}} = W_{\\text{el}} + W_{\\text{post-yield,num}}$。\n    - 将此结果与理论目标值 $A G_f$ 进行比较，并计算相对误差。\n\n最后，对于每个测试用例，报告四个计算出的相对误差（$h_1, h_2$ 的面积检查和 $h_1, h_2$ 的功检查）中的最大值。由于解析解的精确性，这些误差预计会非常小，仅由数值积分精度和浮点运算引起。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: linear softening, happy path\n        {\n            'type': 'linear',\n            'E': 30e9, 'ft': 3e6, 'Gf': 120.0, 'A': 5e-3, 'L_tot': 1.0, \n            'h_values': [0.02, 0.10]\n        },\n        # Test case 2: exponential softening, happy path\n        {\n            'type': 'exponential',\n            'E': 30e9, 'ft': 3e6, 'Gf': 120.0, 'A': 5e-3, 'L_tot': 1.0, \n            'h_values': [0.02, 0.10]\n        },\n        # Test case 3: linear softening, boundary element sizes\n        {\n            'type': 'linear',\n            'E': 20e9, 'ft': 2e6, 'Gf': 80.0, 'A': 1e-3, 'L_tot': 0.2, \n            'h_values': [0.001, 0.05]\n        }\n    ]\n\n    results = []\n\n    for case_params in test_cases:\n        case_errors = []\n        softening_type = case_params['type']\n        E = case_params['E']\n        ft = case_params['ft']\n        Gf = case_params['Gf']\n        A = case_params['A']\n        L_tot = case_params['L_tot']\n        h_values = case_params['h_values']\n\n        for h in h_values:\n            L_r = L_tot - h\n\n            # 1. Calibrate and perform area check\n            if softening_type == 'linear':\n                # Calibration\n                eps_f = (2 * Gf) / (h * ft)\n                w_f = h * eps_f\n\n                # Area check\n                sigma_func = lambda eps_p: ft * (1 - eps_p / eps_f)\n                area_num, _ = integrate.quad(sigma_func, 0, eps_f)\n                \n                # Post-yield work calculation\n                T_func = lambda w: ft * (1 - w / w_f)\n                dTdw_func = lambda w: -ft / w_f\n                w_end = w_f\n            \n            elif softening_type == 'exponential':\n                # Calibration\n                eps_c = Gf / (h * ft)\n                w_c = h * eps_c\n\n                # Area check (truncated)\n                eps_end_factor = 12.0\n                eps_end = eps_end_factor * eps_c\n                sigma_func = lambda eps_p: ft * np.exp(-eps_p / eps_c)\n                area_num, _ = integrate.quad(sigma_func, 0, eps_end)\n\n                # Post-yield work calculation\n                T_func = lambda w: ft * np.exp(-w / w_c)\n                dTdw_func = lambda w: (-ft / w_c) * np.exp(-w / w_c)\n                w_end = eps_end_factor * w_c\n\n            area_target = Gf / h\n            rel_err_area = abs(area_num - area_target) / area_target\n            case_errors.append(rel_err_area)\n            \n            # 2. Compute total work and perform check\n            # Elastic work\n            W_el = (A * L_r * ft**2) / (2 * E)\n\n            # Post-yield work integrand: F(w) * d(Delta)/dw\n            work_integrand = lambda w: (A * T_func(w)) * (1 + (L_r / E) * dTdw_func(w))\n            \n            # Integrate to get post-yield work\n            W_post_yield_num, _ = integrate.quad(work_integrand, 0, w_end)\n            \n            W_total_num = W_el + W_post_yield_num\n            \n            # Target total work\n            W_target = A * Gf\n            \n            rel_err_work = abs(W_total_num - W_target) / W_target\n            case_errors.append(rel_err_work)\n\n        results.append(max(case_errors))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3529154"}, {"introduction": "即便采用了如断裂带模型等正则化技术，软化本构仍对非线性求解器的收敛性构成严峻挑战，材料强度的快速退化要求对模拟的时间步长进行精细控制。本练习 [@problem_id:3529137] 要求您基于材料退化率推导出一个自动时间步长选择准则。其核心思想是限制单个增量步内屈服应力的变化幅度，从而确保数值求解过程的稳定性和准确性，这对于处理具有挑战性的非线性问题至关重要。", "problem": "在计算岩土力学中，考虑一个由偏应力第二不变量（J2）控制、具有各向同性软化的小应变关联塑性模型。令内部软化变量定义为单位体积的累积塑性功，记为 $\\kappa$，其演化律为 $d\\kappa/dt = \\dot{W}_p$，其中 $\\dot{W}_p$ 是单位体积的塑性功率。屈服应力是 $\\kappa$ 的函数，写作 $\\sigma_y = \\sigma_y(\\kappa)$，并经历软化过程，其局部特征由斜率 $h = d\\sigma_y/d\\kappa$ 描述，在软化区 $h  0$。假设在一个时间增量 $\\Delta t$ 内，塑性功率 $\\dot{W}_p$ 和软化斜率 $h$ 可被视为局部常数，并且应力更新的返回映射算法应通过限制每一步的屈服应力退化来保持良态。从塑性功的基本定义和软化律的泰勒展开出发，推导一个自动时间步长上限，以确保在一个时间步长内屈服应力的相对减小不超过一个预定分数 $\\theta \\in (0,1)$，即增量的大小满足条件 $|\\Delta \\sigma_y| \\le \\theta \\, \\sigma_y$。该界限必须用 $\\dot{W}_p$、$\\sigma_y$、 $h$ 和 $\\theta$ 来表示，并且必须与 $\\kappa$ 作为单位体积塑性功的定义相一致。提出第二个基于能量的上限，该上限通过将塑性功增量限制为特征软化功尺度的一个分数 $\\eta \\in (0,1)$ 来确定。然后将这两个界限与用户指定的最大步长 $\\Delta t_{\\text{user}}$ 结合成一个单一的选择规则，该规则在以下边界情况下是鲁棒的：纯弹性步（$\\dot{W}_p = 0$），非软化或硬化（$h \\ge 0$），以及趋近于零的 $\\sigma_y$。\n\n您的程序必须实现所推导的选择规则，并为下面测试套件中的每个测试用例返回所选的 $\\Delta t$。所有物理量必须采用国际单位制（SI）进行处理。最终选定的时间步长以秒为单位表示。不涉及角度。输出必须是浮点数。\n\n测试套件（每个用例是一个元组 $(\\sigma_y, \\dot{W}_p, h, \\theta, \\eta, \\Delta t_{\\text{user}})$，除无量纲的 $\\theta$ 和 $\\eta$ 外，所有单位均为国际单位制）：\n- 用例 1（一般软化，中等速率）：($200 \\times 10^6$, $5 \\times 10^8$, $-0.2$, $0.05$, $0.05$, $1.0$)。\n- 用例 2（纯弹性增量）：($150 \\times 10^6$, $0.0$, $-0.3$, $0.10$, $0.10$, $1.0$)。\n- 用例 3（近乎理想塑性，非常弱的软化）：($200 \\times 10^6$, $1 \\times 10^8$, $-1 \\times 10^{-6}$, $0.05$, $0.05$, $0.5$)。\n- 用例 4（强软化，高塑性功率）：($50 \\times 10^6$, $1 \\times 10^9$, $-0.5$, $0.10$, $0.10$, $0.5$)。\n- 用例 5（接近破坏，小屈服应力）：($1 \\times 10^5$, $1 \\times 10^8$, $-0.2$, $0.05$, $0.05$, $1.0$)。\n- 用例 6（非软化/硬化指示）：($100 \\times 10^6$, $1 \\times 10^7$, $+0.1$, $0.10$, $0.10$, $2.0$)。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果是对应于相应测试用例的所选 $\\Delta t$（以秒为单位），顺序与上面列出的相同。", "solution": "该问题被验证为具有科学依据、适定且客观。它提出了计算塑性力学中一个标准的、尽管非平凡的任务：为软化材料模型推导和实现一个时间步长控制算法。\n\n其目标是推导一个鲁棒的规则，用于在涉及各向同性软化的小应变关联 J2 塑性模型的数值模拟中选择时间步长 $\\Delta t$。该规则必须防止在单个步骤内发生过度的材料退化，并处理各种物理和数值边界情况。\n\n该模型由一个屈服应力 $\\sigma_y$ 定义，它是内部变量 $\\kappa$ 的函数。这个内部变量 $\\kappa$ 代表单位体积的累积塑性功，其演化由以下速率方程控制：\n$$ \\frac{d\\kappa}{dt} = \\dot{W}_p $$\n其中 $\\dot{W}_p$ 是单位体积的塑性功率。材料发生软化，意味着其屈服应力随着塑性变形而降低。这由软化模量 $h$ 来表征，定义为屈服应力相对于累积塑性功的斜率：\n$$ h = \\frac{d\\sigma_y}{d\\kappa} $$\n在软化区，$h  0$。问题假设对于给定的时间增量 $\\Delta t$，$\\dot{W}_p$ 和 $h$ 都可以被视为局部常数。\n\n推导过程分三部分进行：首先基于物理准则推导两个不同的时间步长界限，然后将它们组合成一个单一的鲁棒选择规则。\n\n首先，我们从单个步骤内屈服应力的相对减小必须受限这一约束推导出一个时间步长界限 $\\Delta t_1$。该条件给出如下：\n$$ |\\Delta \\sigma_y| \\le \\theta \\, \\sigma_y $$\n其中 $\\sigma_y$ 是该步骤开始时的屈服应力，$\\theta \\in (0,1)$ 是一个用户定义的容差。屈服应力的变化量 $\\Delta \\sigma_y$ 可以使用一阶泰勒展开来近似：\n$$ \\Delta \\sigma_y \\approx \\frac{d\\sigma_y}{d\\kappa} \\Delta \\kappa = h \\Delta \\kappa $$\n塑性功的增量 $\\Delta \\kappa$ 是通过在时间步长 $\\Delta t$ 内对其速率 $\\dot{W}_p$ 积分得到的。假设 $\\dot{W}_p$ 是常数，我们有：\n$$ \\Delta \\kappa \\approx \\dot{W}_p \\Delta t $$\n将此代入 $\\Delta \\sigma_y$ 的表达式中，得到：\n$$ \\Delta \\sigma_y \\approx h \\dot{W}_p \\Delta t $$\n要发生软化，必须有塑性变形（$\\dot{W}_p > 0$）和负的软化模量（$h  0$）。在这种情况下，$\\Delta \\sigma_y$ 是负的。对其大小的约束变为：\n$$ |h \\dot{W}_p \\Delta t| \\le \\theta \\, \\sigma_y $$\n由于 $\\dot{W}_p > 0$ 且 $h  0$，我们有 $|h| = -h$。该不等式为：\n$$ (-h) \\dot{W}_p \\Delta t \\le \\theta \\, \\sigma_y $$\n解出 $\\Delta t$ 得到第一个上限：\n$$ \\Delta t_1 = \\frac{\\theta \\, \\sigma_y}{(-h) \\dot{W}_p} $$\n这个界限只有在软化发生时（即 $h  0$ 且 $\\dot{W}_p > 0$）才有意义。如果这两个条件中任何一个不满足，这个约束就不适用。\n\n其次，我们提出并推导第二个基于能量的时间步长界限 $\\Delta t_2$。这个上限基于将塑性功增量 $\\Delta W_p = \\Delta \\kappa$ 限制为特征软化功尺度 $W_c$ 的一个分数 $\\eta \\in (0,1)$。对于 $W_c$ 的一个物理上有意义的选择是，在假设软化模量 $h$ 为常数的情况下，将当前屈服应力 $\\sigma_y$ 减小到零所需的单位体积塑性功的量。其计算如下：\n$$ W_c = -\\frac{\\sigma_y}{h} $$\n$W_c$ 的单位是帕斯卡，或焦耳每立方米，这与 $\\kappa$ 的定义是一致的。约束公式为：\n$$ \\Delta W_p \\le \\eta \\, W_c $$\n代入 $\\Delta W_p \\approx \\dot{W}_p \\Delta t$ 和 $W_c$ 的表达式：\n$$ \\dot{W}_p \\Delta t \\le \\eta \\left(-\\frac{\\sigma_y}{h}\\right) $$\n解出 $\\Delta t$ 得到第二个上限：\n$$ \\Delta t_2 = \\frac{\\eta \\, \\sigma_y}{(-h) \\dot{W}_p} $$\n这个界限的形式与 $\\Delta t_1$ 相似，并且也仅在 $h  0$ 和 $\\dot{W}_p > 0$ 时才起作用。\n\n最后，我们将这两个推导出的界限与用户指定的最大时间步长 $\\Delta t_{\\text{user}}$ 结合起来，形成一个单一、鲁棒的选择规则。选定的时间步长 $\\Delta t$ 必须是所有适用上限中的最小值。该规则还必须对边界情况具有鲁棒性。\n\n完整的选择规则如下：\n1. 检查非软化的先决条件。如果没有塑性功率（$\\dot{W}_p \\le 0$）或者材料没有软化（$h \\ge 0$），则基于退化的控制是不必要的。在这种情况下，时间步长仅受用户偏好的限制：\n$$ \\text{若 } \\dot{W}_p \\le 0 \\text{ 或 } h \\ge 0, \\text{ 则 } \\Delta t = \\Delta t_{\\text{user}}。$$\n这涵盖了纯弹性步、理想塑性（$h=0$）和硬化（$h>0$）。\n\n2. 如果软化正在发生（$\\dot{W}_p > 0$ 且 $h  0$），则计算两个推导出的界限。对完全退化材料（$\\sigma_y \\le 0$）的检查应产生为 $0$ 的时间步长以停止模拟，尽管所有测试用例都满足 $\\sigma_y > 0$：\n$$ \\Delta t_1 = \\frac{\\theta \\, \\sigma_y}{(-h) \\dot{W}_p} $$\n$$ \\Delta t_2 = \\frac{\\eta \\, \\sigma_y}{(-h) \\dot{W}_p} $$\n最终的时间步长是这两个界限和用户指定的最大值中最严格的一个：\n$$ \\Delta t = \\min(\\Delta t_1, \\Delta t_2, \\Delta t_{\\text{user}}) $$\n这个规则对于趋近于零的 $\\sigma_y$ 是鲁棒的，因为在这个极限下，$\\Delta t_1$ 和 $\\Delta t_2$ 都正确地趋近于 $0$，从而强制使用小的时间步长来精确捕捉材料破坏的最后阶段。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the appropriate time step based on a J2 plasticity model\n    with isotropic softening for a suite of test cases.\n    \"\"\"\n\n    # Test suite: (sigma_y, W_p_dot, h, theta, eta, dt_user)\n    # All values are in SI units, except for dimensionless theta and eta.\n    test_cases = [\n        # Case 1 (general softening, moderate rate)\n        (200e6, 5e8, -0.2, 0.05, 0.05, 1.0),\n        # Case 2 (purely elastic increment)\n        (150e6, 0.0, -0.3, 0.10, 0.10, 1.0),\n        # Case 3 (near-perfect plasticity, very weak softening)\n        (200e6, 1e8, -1e-6, 0.05, 0.05, 0.5),\n        # Case 4 (strong softening, high plastic work rate)\n        (50e6, 1e9, -0.5, 0.10, 0.10, 0.5),\n        # Case 5 (approaching failure, small yield stress)\n        (1e5, 1e8, -0.2, 0.05, 0.05, 1.0),\n        # Case 6 (non-softening/hardening indicator)\n        (100e6, 1e7, 0.1, 0.10, 0.10, 2.0),\n    ]\n\n    def compute_timestep(sigma_y, W_p_dot, h, theta, eta, dt_user):\n        \"\"\"\n        Computes the time step based on the derived selection rule.\n\n        Args:\n            sigma_y (float): Current yield stress (Pa).\n            W_p_dot (float): Plastic work rate per unit volume (Pa/s).\n            h (float): Softening modulus (dimensionless).\n            theta (float): Relative yield stress degradation tolerance (dimensionless).\n            eta (float): Relative plastic work increment tolerance (dimensionless).\n            dt_user (float): User-specified maximum time step (s).\n\n        Returns:\n            float: The selected time step (s).\n        \"\"\"\n        # Edge Case: If plastic work rate is zero or negative (elastic step)\n        # or if the material is not softening (h >= 0, i.e., hardening or perfect plasticity),\n        # the softening-based time step controls are not applicable.\n        # The only limit is the user-specified maximum time step.\n        if W_p_dot = 0 or h >= 0:\n            return dt_user\n\n        # Main Case: Softening is active (W_p_dot > 0 and h  0).\n        \n        # Edge Case: If yield stress is already zero or negative, the material\n        # has failed. The time step should be zero to halt further evolution.\n        if sigma_y = 0:\n            return 0.0\n        \n        # Calculate the denominator for the time step bounds.\n        # This is guaranteed to be positive since h  0 and W_p_dot > 0.\n        denominator = (-h) * W_p_dot\n        \n        # Calculate the first time step bound, dt1, based on limiting the\n        # relative change in yield stress.\n        dt1 = (theta * sigma_y) / denominator\n        \n        # Calculate the second time step bound, dt2, based on the\n        # energetic criterion.\n        dt2 = (eta * sigma_y) / denominator\n        \n        # The final selected time step is the minimum of the two calculated\n        # bounds and the user-specified maximum.\n        dt_selected = min(dt1, dt2, dt_user)\n        \n        return dt_selected\n\n    results = []\n    for case in test_cases:\n        result = compute_timestep(*case)\n        results.append(result)\n\n    # Format the final output string as a comma-separated list in brackets.\n    # The map(str, ...) is necessary to convert all float results to strings\n    # before joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3529137"}]}