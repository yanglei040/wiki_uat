{"hands_on_practices": [{"introduction": "本练习是掌握多维求积法的第一步，将引导您在一个标准正方形单元上对一个多项式函数进行积分。您将应用张量积高斯-勒让德法则，并通过将数值结果与精确的解析解进行比较，来亲手验证高斯求积的强大精确性。[@problem_id:3527331] 这项基础实践旨在巩固您对张量积法则核心思想的理解，并为处理更复杂的问题奠定坚实基础。", "problem": "在计算岩土力学中，当使用有限元法（FEM）组装矩阵时，经常需要计算参考单元上的体积分。考虑一个与双线性四边形单元相关联的参考正方形 $[-1,1]^2$。使用每个方向 $3$ 个点的张量积 Gauss–Legendre 求积法计算积分\n$$\nI = \\int_{-1}^{1}\\int_{-1}^{1} x^{3}\\,y^{5}\\,dx\\,dy\n$$\n然后，直接根据 Riemann 积分的定义计算该积分的解析值，并比较这两个值，以确定该求积法则对于此被积函数是否精确。将最终答案表示为一个不带单位的纯数。无需四舍五入。", "solution": "本题要求使用两种方法计算积分 $I = \\int_{-1}^{1}\\int_{-1}^{1} x^{3}\\,y^{5}\\,dx\\,dy$：第一种是 $3$ 点张量积 Gauss–Legendre 求积法，第二种是直接解析积分。然后需要比较这两个结果。\n\n首先，我们来解析地计算该积分。被积函数 $f(x,y) = x^3 y^5$ 是一个可分离函数，这意味着它可以写成一个关于 $x$ 的函数与一个关于 $y$ 的函数的乘积。因此，该二重积分可以表示为两个单积分的乘积：\n$$\nI = \\left( \\int_{-1}^{1} x^{3}\\,dx \\right) \\left( \\int_{-1}^{1} y^{5}\\,dy \\right)\n$$\n我们分别计算每个积分。第一个积分是：\n$$\n\\int_{-1}^{1} x^{3}\\,dx = \\left[ \\frac{x^{4}}{4} \\right]_{-1}^{1} = \\frac{(1)^{4}}{4} - \\frac{(-1)^{4}}{4} = \\frac{1}{4} - \\frac{1}{4} = 0\n$$\n另外，我们注意到被积函数 $p(x) = x^3$ 是一个奇函数，即 $p(-x) = (-x)^3 = -x^3 = -p(x)$。任何奇函数在对称区间（如 $[-1, 1]$）上的积分恒为零。\n\n类似地，对于第二个积分：\n$$\n\\int_{-1}^{1} y^{5}\\,dy = \\left[ \\frac{y^{6}}{6} \\right]_{-1}^{1} = \\frac{(1)^{6}}{6} - \\frac{(-1)^{6}}{6} = \\frac{1}{6} - \\frac{1}{6} = 0\n$$\n被积函数 $q(y) = y^5$ 也是一个奇函数，所以它在 $[-1, 1]$ 上的积分为零。\n\n因此，该积分的解析值为：\n$$\nI = 0 \\times 0 = 0\n$$\n\n接下来，我们使用 $3$ 点张量积 Gauss–Legendre 求积法来计算该积分。该积分的数值近似公式（我们记为 $I_{GQ}$）是：\n$$\nI_{GQ} = \\int_{-1}^{1}\\int_{-1}^{1} f(x,y)\\,dx\\,dy \\approx \\sum_{i=1}^{3} \\sum_{j=1}^{3} w_i w_j f(x_i, y_j)\n$$\n其中 $\\{x_i\\}$ 和 $\\{y_j\\}$ 是 Gauss 点，$\\{w_i\\}$ 和 $\\{w_j\\}$ 是 $3$ 点法则对应的权重。对于 Gauss-Legendre 求积法，求积点是 $n$ 次 Legendre 多项式的根，权重由这些根导出。当 $n=3$ 时，求积点和权重为：\n求积点 ($\\xi_k$): $\\xi_1 = -\\sqrt{\\frac{3}{5}}$, $\\xi_2 = 0$, $\\xi_3 = \\sqrt{\\frac{3}{5}}$\n权重 ($w_k$): $w_1 = \\frac{5}{9}$, $w_2 = \\frac{8}{9}$, $w_3 = \\frac{5}{9}$\n\n由于被积函数 $f(x,y) = x^3 y^5$ 是可分离的，这个二重求和也可以分离：\n$$\nI_{GQ} = \\left( \\sum_{i=1}^{3} w_i x_i^3 \\right) \\left( \\sum_{j=1}^{3} w_j y_j^5 \\right)\n$$\n我们来计算第一个求和：\n\\begin{align*} \\label{eq:1}\n\\sum_{i=1}^{3} w_i x_i^3 = w_1 x_1^3 + w_2 x_2^3 + w_3 x_3^3 \\\\\n= \\left(\\frac{5}{9}\\right) \\left(-\\sqrt{\\frac{3}{5}}\\right)^3 + \\left(\\frac{8}{9}\\right) (0)^3 + \\left(\\frac{5}{9}\\right) \\left(\\sqrt{\\frac{3}{5}}\\right)^3 \\\\\n= \\left(\\frac{5}{9}\\right) \\left(-\\frac{3}{5}\\sqrt{\\frac{3}{5}}\\right) + 0 + \\left(\\frac{5}{9}\\right) \\left(\\frac{3}{5}\\sqrt{\\frac{3}{5}}\\right) \\\\\n= -\\frac{3}{9}\\sqrt{\\frac{3}{5}} + \\frac{3}{9}\\sqrt{\\frac{3}{5}} \\\\\n= 0\n\\end{align*}\n现在，我们计算第二个求和：\n\\begin{align*} \\label{eq:2}\n\\sum_{j=1}^{3} w_j y_j^5 = w_1 y_1^5 + w_2 y_2^5 + w_3 y_3^5 \\\\\n= \\left(\\frac{5}{9}\\right) \\left(-\\sqrt{\\frac{3}{5}}\\right)^5 + \\left(\\frac{8}{9}\\right) (0)^5 + \\left(\\frac{5}{9}\\right) \\left(\\sqrt{\\frac{3}{5}}\\right)^5 \\\\\n= \\left(\\frac{5}{9}\\right) \\left(-\\left(\\frac{3}{5}\\right)^2\\sqrt{\\frac{3}{5}}\\right) + 0 + \\left(\\frac{5}{9}\\right) \\left(\\left(\\frac{3}{5}\\right)^2\\sqrt{\\frac{3}{5}}\\right) \\\\\n= \\left(\\frac{5}{9}\\right) \\left(-\\frac{9}{25}\\sqrt{\\frac{3}{5}}\\right) + \\left(\\frac{5}{9}\\right) \\left(\\frac{9}{25}\\sqrt{\\frac{3}{5}}\\right) \\\\\n= -\\frac{5}{25}\\sqrt{\\frac{3}{5}} + \\frac{5}{25}\\sqrt{\\frac{3}{5}} \\\\\n= 0\n\\end{align*}\n因此，通过 Gauss 求积法近似得到的积分值为：\n$$\nI_{GQ} = 0 \\times 0 = 0\n$$\n\n最后，我们比较这两个结果。解析值为 $I = 0$，通过 $3$ 点 Gauss-Legendre 求积法得到的值为 $I_{GQ} = 0$。这两个值是相同的。\n\n这表明该求积法则对于这个特定的被积函数是精确的。这与 Gauss-Legendre 求积法的理论是一致的。一个 $n$ 点法则对于次数最高为 $2n-1$ 的所有多项式都是精确的。对于本题，$n=3$，因此该法则对于次数最高为 $2(3)-1=5$ 的多项式是精确的。张量积法则对于任何形如 $x^i y^j$（其中 $i \\le 2n-1$ 且 $j \\le 2n-1$）的项的线性组合的多项式 $f(x,y)$ 都是精确的。我们的被积函数是 $f(x,y)=x^3y^5$。关于 $x$ 的次数是 $3$，关于 $y$ 的次数是 $5$。由于 $3 \\le 5$ 且 $5 \\le 5$，所以 $3$ 点法则对积分的 $x$ 和 $y$ 分量都是精确的，因此张量积法则对整个积分也是精确的。\n\n计算出的积分值为 $0$。", "answer": "$$\n\\boxed{0}\n$$", "id": "3527331"}, {"introduction": "在有限元法中，除了矩形或六面体单元外，我们还经常使用三角形和四面体单元，这需要非张量积的求积法则。本练习将指导您为四面体单元的求积法则编写一个计算验证程序，通过实现一个矩检验算法，确定给定法则能够精确积分的多项式的最高阶数。[@problem_id:3527352] 这项实践不仅能加深您对“精确阶数”这一核心概念的理解，还为您提供了验证和评估数值积分方案的关键技能。", "problem": "给定一个用于在参考四面体上对标量场进行积分的三维高斯型求积法则族。你的任务是实现一个程序，对于提供的测试套件中的每个求积法则，确定其最大的非负整数精度阶 $p$，使得该法则能够对多项式空间 $\\mathbb{P}_p$ 中的每个单项式积分到机器精度以内。你必须通过检查截至足够高阶的矩条件来完成此任务，并报告所有矩条件在机器精度内成立的最大 $p$ 值。\n\n基本依据。仅使用以下基本事实来推导出必要的精确参考矩和测试程序：\n- 参考四面体定义为 $\\Omega = \\{(x,y,z) \\in \\mathbb{R}^3 \\mid x \\ge 0, y \\ge 0, z \\ge 0, x + y + z \\le 1\\}$，其体积为 $|\\Omega| = \\int_{\\Omega} 1 \\, dV$。\n- 一个求积法则的精度阶 $p$ 是使得对于所有满足 $i,j,k \\in \\mathbb{N}_0$ 和 $i+j+k \\le p$ 的单项式 $m(x,y,z) = x^i y^j z^k$，积分 $\\int_{\\Omega} m(x,y,z) \\, dV$ 等于其求积近似值 $\\sum_{q=1}^{N_q} w_q \\, m(x_q,y_q,z_q)$ 的最大整数。\n- 对于非负整数 $n$，一维积分满足 $\\int_0^{a} t^n \\, dt = \\dfrac{a^{n+1}}{n+1}$，此式与 Fubini 定理以及 $\\Omega$ 的定义一起，足以推导出单项式矩 $\\int_{\\Omega} x^i y^j z^k \\, dV$ 的精确值。\n\n“达到机器精度”的定义。对于一个精确的目标矩 $M_{i,j,k}$ 及其求积近似值 $\\widehat{M}_{i,j,k}$，如果满足以下条件，则声明矩条件得到满足：\n$$\n\\left|\\widehat{M}_{i,j,k} - M_{i,j,k}\\right| \\le \\tau(|M_{i,j,k}|),\n$$\n其中容差函数为\n$$\n\\tau(|M|) = c \\, \\varepsilon_{\\mathrm{mach}} \\, \\max(1,|M|) + \\tau_0,\n$$\n其中 $c = 64$，$\\varepsilon_{\\mathrm{mach}}$ 等于你的编程环境提供的 IEEE 双精度算术的机器 epsilon，且 $\\tau_0 = 10^{-14}$。\n\n算法要求。\n1. 根据上述基本依据，为所有非负整数 $i,j,k$ 推导出 $M_{i,j,k} = \\int_{\\Omega} x^i y^j z^k \\, dV$ 的闭式表达式。\n2. 实现一个例程，该例程给定一个求积法则 $\\{(w_q, x_q, y_q, z_q)\\}_{q=1}^{N_q}$，检查总次数直到 $d_{\\max}$ 的所有单项式矩，其中 $d_{\\max}$ 至少为 $\\;10\\;$，并返回使得 $\\mathbb{P}_p$ 中所有单项式都满足容差要求的最大 $p \\le d_{\\max}$。\n3. 对参考四面体 $\\Omega$ 使用以下求积法则测试套件。每个法则都以求积点 $(x_q,y_q,z_q)$ 和相应权重 $w_q$ 的列表形式提供。所有坐标和权重都是无量纲的。\n   - 测试用例 A (单点质心法则，候选阶数 $\\;p=1\\;$)：\n     - 一个点位于 $(x,y,z) = (\\frac{1}{4}, \\frac{1}{4}, \\frac{1}{4})$，权重为 $w = \\frac{1}{6}$。\n   - 测试用例 B (对称四点法则，候选阶数 $\\;p=2\\;$)：\n     - 令 $a = \\;0.5854101966249685\\;$ 和 $b = \\;0.1381966011250105\\;$。使用四个点，这些点由重心坐标元组 $(\\lambda_1,\\lambda_2,\\lambda_3,\\lambda_4)$ 等于 $(a,b,b,b)$ 的排列组合获得，并通过 $(x,y,z) = (\\lambda_2,\\lambda_3,\\lambda_4)$ 映射到笛卡尔坐标，其中参考四面体的顶点位于 $(0,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$。由此产生四个笛卡尔点 $(a,b,b)$, $(b,a,b)$, $(b,b,a)$ 和 $(b,b,b)$，每个点的权重都相等，为 $w = \\frac{1}{24}$。\n   - 测试用例 C (偏离质心的单点法则，候选阶数 $\\;p=0\\;$)：\n     - 一个点位于 $(x,y,z) = (0.3, 0.2, 0.1)$，权重为 $w = \\frac{1}{6}$。\n\n边界情况与覆盖范围。测试套件包括一个预期对所有次数至多为 $\\;1\\;$ 的多项式精确的法则，一个对次数至多为 $\\;2\\;$ 的多项式精确的法则，以及一个仅对常数精确的法则。你的实现必须对浮点舍入具有鲁棒性，并根据所述的容差模型正确报告精度阶。\n\n最终输出格式。你的程序应产生单行输出，其中包含三个测试用例（A、B、C 顺序）的结果，形式为逗号分隔的列表并用方括号括起，例如 $[p_A,p_B,p_C]$，其中每个 $p_\\cdot$ 是一个整数。你的代码必须是完全自包含的，并且只产生这一行输出，不带任何附加文本。", "solution": "此问题已经过验证，并被确定为是合理的。它在科学上基于数值分析和微积分原理，问题定义明确，目标清晰，数据充分，并且其表述是客观的。所有有效问题的条件均已满足。\n\n任务是为一组给定的关于参考四面体 $\\Omega$ 的求积法则确定其精度阶 $p$。精度阶是最大的非负整数 $p$，使得该求积法则能以指定的机器精度容差内积分所有总次数 $i+j+k \\le p$ 的单项式 $x^i y^j z^k$。\n\n解决方案分为两个主要阶段进行开发：\n1.  推导在参考四面体上单项式矩精确值的闭式表达式。\n2.  实现一个数值程序，以针对这些精确值在递增的多项式次数下测试求积法则。\n\n**1. 精确单项式矩的推导**\n\n在参考四面体 $\\Omega$ 上，单项式 $m(x,y,z) = x^i y^j z^k$ 的精确矩由以下积分给出：\n$$\nM_{i,j,k} = \\int_{\\Omega} x^i y^j z^k \\, dV\n$$\n参考四面体定义为 $\\Omega = \\{(x,y,z) \\in \\mathbb{R}^3 \\mid x \\ge 0, y \\ge 0, z \\ge 0, x + y + z \\le 1\\}$。使用 Fubini 定理，这个体积积分可以表示为一个迭代积分：\n$$\nM_{i,j,k} = \\int_{x=0}^{1} x^i \\left( \\int_{y=0}^{1-x} y^j \\left( \\int_{z=0}^{1-x-y} z^k \\, dz \\right) \\, dy \\right) \\, dx\n$$\n我们从内到外计算这个积分。\n\n最内层关于 $z$ 的积分是：\n$$\n\\int_0^{1-x-y} z^k \\, dz = \\left[ \\frac{z^{k+1}}{k+1} \\right]_0^{1-x-y} = \\frac{(1-x-y)^{k+1}}{k+1}\n$$\n这是基于给定的基本积分 $\\int_0^a t^n \\, dt = \\frac{a^{n+1}}{n+1}$。\n\n接下来，我们将此结果代入中间层关于 $y$ 的积分：\n$$\n\\int_0^{1-x} y^j \\frac{(1-x-y)^{k+1}}{k+1} \\, dy = \\frac{1}{k+1} \\int_0^{1-x} y^j (1-x-y)^{k+1} \\, dy\n$$\n为了解这个积分，我们进行变量代换。令 $y = u(1-x)$，这意味着 $dy = (1-x) \\, du$。$u$ 的积分限从 $0$ 到 $1$。积分变为：\n\\begin{align*} \\label{eq:1} \\frac{1}{k+1} \\int_0^1 [u(1-x)]^j (1-x-u(1-x))^{k+1} (1-x) \\, du = \\frac{(1-x)^{j+k+2}}{k+1} \\int_0^1 u^j (1-u)^{k+1} \\, du\\end{align*}\n积分 $\\int_0^1 u^j (1-u)^{k+1} \\, du$ 是贝塔函数 $B(j+1, k+2)$。利用它与伽马函数（以及整数参数的阶乘）的关系 $B(a,b) = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)} = \\frac{(a-1)!(b-1)!}{(a+b-1)!}$，我们有：\n$$\n\\int_0^1 u^j (1-u)^{k+1} \\, du = B(j+1, k+2) = \\frac{j!(k+1)!}{(j+k+3)!}\n$$\n将其代回，中间积分的计算结果为：\n$$\n\\frac{(1-x)^{j+k+2}}{k+1} \\frac{j!(k+1)!}{(j+k+3)!} = (1-x)^{j+k+2} \\frac{j!k!}{(j+k+2)!}\n$$\n这个表达式在许多标准推导中存在一个印刷错误。正确地，$B(j+1, k+2) = \\frac{\\Gamma(j+1)\\Gamma(k+2)}{\\Gamma(j+1+k+2)} = \\frac{j!(k+1)!}{(j+k+3)!}$。让我使用一个已知的恒等式 $\\int_0^c y^m(c-y)^n dy = c^{m+n+1} \\frac{m!n!}{(m+n+1)!}$ 来重新评估。令 $c=1-x$, $m=j$, $n=k+1$，我们得到 $(1-x)^{j+k+2} \\frac{j!(k+1)!}{(j+k+3)!}$。\n因此中间积分的表达式为：$\\frac{1}{k+1} (1-x)^{j+k+2} \\frac{j!(k+1)!}{(j+k+3)!} = (1-x)^{j+k+2} \\frac{j!k!}{(j+k+3)!}$。这似乎不标准。\n\n让我们重新仔细推导。一个已知的关于在单位单纯形上积分的通用公式是 $\\int_{\\Omega_n} x_1^{a_1} \\dots x_n^{a_n} dV = \\frac{a_1! \\dots a_n!}{(n + \\sum a_i)!}$。对于我们的情况，$n=3$，所以：$M_{i,j,k} = \\frac{i! j! k!}{(i+j+k+3)!}$。让我们通过直接积分来验证这一点。\n1. 内层积分：$\\int_0^{1-x-y} z^k dz = \\frac{(1-x-y)^{k+1}}{k+1}$。正确。\n2. 中间积分：$\\int_0^{1-x} y^j \\frac{(1-x-y)^{k+1}}{k+1} dy$。令 $y = (1-x)u, dy=(1-x)du$。\n   $$ \\frac{1}{k+1} \\int_0^1 (u(1-x))^j (1-x-u(1-x))^{k+1} (1-x)du = \\frac{(1-x)^{j+k+2}}{k+1} \\int_0^1 u^j (1-u)^{k+1}du $$\n   该积分为 $B(j+1, k+2) = \\frac{j!(k+1)!}{(j+k+3)!}$。\n   中间部分为 $\\frac{(1-x)^{j+k+2}}{k+1} \\frac{j!(k+1)!}{(j+k+3)!} = (1-x)^{j+k+2} \\frac{j!k!}{(j+k+3)!}$。这似乎是一个常见陷阱。让我重新验证贝塔函数定义 $\\Gamma(z+1)=z!$ 和 $B(x,y) = \\frac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}$。\n   $B(j+1, k+2) = \\frac{\\Gamma(j+1)\\Gamma(k+2)}{\\Gamma(j+k+3)} = \\frac{j! (k+1)!}{(j+k+2)!}$。我分母的阶乘差了一。\n   所以中间积分是 $\\frac{(1-x)^{j+k+2}}{k+1} \\frac{j!(k+1)!}{(j+k+2)!} = (1-x)^{j+k+2} \\frac{j!k!}{(j+k+2)!}$。\n\n3. 外层积分：$\\int_0^1 x^i \\left((1-x)^{j+k+2} \\frac{j!k!}{(j+k+2)!}\\right) dx$。\n   $$ \\frac{j!k!}{(j+k+2)!} \\int_0^1 x^i (1-x)^{j+k+2} dx = \\frac{j!k!}{(j+k+2)!} B(i+1, j+k+3) $$\n   $$ = \\frac{j!k!}{(j+k+2)!} \\frac{i!(j+k+2)!}{(i+j+k+3)!} = \\frac{i!j!k!}{(i+j+k+3)!} $$\n推导得到证实。精确矩为 $M_{i,j,k} = \\frac{i!j!k!}{(i+j+k+3)!}$。\n\n作为检验，对于 $(i,j,k)=(0,0,0)$，$M_{0,0,0}=\\frac{1}{3!}=\\frac{1}{6}$，这是 $\\Omega$ 的体积。对于 $(i,j,k)=(1,0,0)$，$M_{1,0,0}=\\frac{1}{4!}=\\frac{1}{24}$。质心的 $x$ 坐标是 $\\bar{x} = M_{1,0,0}/M_{0,0,0} = (1/24)/(1/6) = 1/4$，这是正确的。\n\n**2. 确定精度阶的算法**\n\n精度阶 $p$ 是通过对连续递增的总多项式次数测试所有矩条件来确定的。设 $d_{\\max}=10$ 为要检查的最大次数，按要求。\n\n对于给定的由 $N_q$ 个点 $(x_q, y_q, z_q)$ 和权重 $w_q$ 组成的求积法则，算法如下：\n\n1.  初始化精度阶 $p_{found} = -1$。\n2.  从 $0$ 到 $d_{\\max}$ 遍历总多项式次数 $d$。\n3.  对于每个次数 $d$，遍历所有满足 $i+j+k=d$ 的非负整数组合 $(i,j,k)$。\n4.  对于每个单项式 $x^i y^j z^k$：\n    a. 计算精确矩 $M_{i,j,k} = \\frac{i!j!k!}{(i+j+k+3)!}$。\n    b. 计算求积近似值 $\\widehat{M}_{i,j,k} = \\sum_{q=1}^{N_q} w_q x_q^i y_q^j z_q^k$。\n    c. 定义容差 $\\tau(|M_{i,j,k}|) = c \\, \\varepsilon_{\\mathrm{mach}} \\, \\max(1, |M_{i,j,k}|) + \\tau_0$，其中常数 $c=64$，$\\varepsilon_{\\mathrm{mach}}$ 为双精度浮点数的机器 epsilon，$\\tau_0=10^{-14}$。\n    d. 检查绝对误差是否满足条件：$|\\widehat{M}_{i,j,k} - M_{i,j,k}| \\le \\tau(|M_{i,j,k}|)$。\n    e. 如果对于次数为 $d$ 的任何单项式，该条件不满足，则该法则对次数 $d$ 不精确。因此精度阶为 $d-1$。我们记录此结果并终止对当前法则的检查。\n5.  如果次数为 $d$ 的所有单项式都在容差范围内积分，则该法则至少对次数 $d$ 精确。我们更新 $p_{found} = d$ 并继续到下一个次数 $d+1$。\n6.  如果循环对所有 $d$ 直至 $d_{\\max}$ 都完成，则精度阶至少为 $d_{\\max}$，所以我们报告 $p_{found} = d_{\\max}$。\n\n此过程应用于所提供的三个测试用例中的每一个。对于测试用例 B，直接使用提供的浮点常数 $a$ 和 $b$。分析必须严格：如果计算出的误差超过容差，则测试失败，无论该法则在具有精确无理常数的情况下可能具有何种理论性质。该问题是对*给定*法则的测试。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the degree of exactness for 3D quadrature rules\n    on the reference tetrahedron.\n    \"\"\"\n\n    # Define the machine precision environment from the problem statement\n    c = 64.0\n    eps_mach = np.finfo(float).eps\n    tau0 = 1e-14\n\n    # Define the quadrature rules for the test suite\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"points\": [(1/4, 1/4, 1/4)],\n            \"weights\": [1/6],\n        },\n        {\n            \"name\": \"B\",\n            \"points\": [\n                (0.5854101966249685, 0.1381966011250105, 0.1381966011250105),\n                (0.1381966011250105, 0.5854101966249685, 0.1381966011250105),\n                (0.1381966011250105, 0.1381966011250105, 0.5854101966249685),\n                (0.1381966011250105, 0.1381966011250105, 0.1381966011250105)\n            ],\n            \"weights\": [1/24, 1/24, 1/24, 1/24],\n        },\n        {\n            \"name\": \"C\",\n            \"points\": [(0.3, 0.2, 0.1)],\n            \"weights\": [1/6],\n        },\n    ]\n\n    memo_factorial = {i: math.factorial(i) for i in range(20)}\n\n    def exact_moment(i, j, k):\n        \"\"\"\n        Calculates the exact moment M_ijk = integral(x^i * y^j * z^k) dV over the\n        reference tetrahedron using the closed-form formula.\n        \"\"\"\n        num = memo_factorial[i] * memo_factorial[j] * memo_factorial[k]\n        den = memo_factorial[i + j + k + 3]\n        return num / den\n\n    def get_degree_of_exactness(rule, d_max):\n        \"\"\"\n        Determines the degree of exactness for a single quadrature rule.\n        \"\"\"\n        points = rule[\"points\"]\n        weights = rule[\"weights\"]\n        \n        for p in range(d_max + 1):\n            # Generate all monomials of total degree p\n            for i in range(p + 1):\n                for j in range(p - i + 1):\n                    k = p - i - j\n\n                    # Calculate exact and approximate moments\n                    m_exact = exact_moment(i, j, k)\n                    \n                    m_approx = 0.0\n                    for q in range(len(points)):\n                        x, y, z = points[q]\n                        w = weights[q]\n                        # Use np.power for safe exponentiation with base 0\n                        m_approx += w * (np.power(x, i) * np.power(y, j) * np.power(z, k))\n\n                    # Check against tolerance\n                    tolerance = c * eps_mach * max(1.0, abs(m_exact)) + tau0\n                    error = abs(m_approx - m_exact)\n                    \n                    if error > tolerance:\n                        return p - 1  # Failed at degree p, so exactness is p-1\n        \n        return d_max # Passed all tests up to d_max\n\n    results = []\n    d_max = 10\n    for case in test_cases:\n        p_exact = get_degree_of_exactness(case, d_max)\n        results.append(p_exact)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3527352"}, {"introduction": "在计算岩土力学中，尤其是在断裂力学领域，我们经常遇到带有奇异性的积分，而标准求积法则对此无能为力。本练习介绍Duffy变换，这是一种强大的坐标映射技术，它能将顶点奇异点正则化，把一个棘手的积分转换成光滑且可分离的形式。[@problem_id:3527274] 这项高级练习展示了如何通过结合解析变换与数值求积来克服有限元法中的一个重大实践障碍，这是解决真实世界工程仿真的关键技能。", "problem": "考虑计算岩土力学中的平面裂纹尖端积分，其中一个类应力量在位于原点的裂纹尖端附近表现为 $r^{-1/2}$，其中 $r = \\sqrt{x^2 + y^2}$。设 $T$ 是 $\\mathbb{R}^2$ 中的一个三角形，其位于裂纹尖端的顶点为 $\\boldsymbol{v}_1 = (0,0)$，另外两个顶点为 $\\boldsymbol{v}_2 \\in \\mathbb{R}^2$ 和 $\\boldsymbol{v}_3 \\in \\mathbb{R}^2$。目标积分为\n$$\nI(T) = \\int_T r^{-1/2}\\, \\mathrm{d}x\\,\\mathrm{d}y.\n$$\n从积分的换元定理和高斯-勒让德求积的定义出发，实现用于三角形的Duffy变换，并用它沿每个参数方向使用名义阶为 $p$ 的张量积高斯-勒让德法则来近似 $I(T)$。对于相同的名义阶 $p$，在参考三角形上实现一个阶为 $p$ 的标准对称三角形求积法则，并将其仿射映射到物理三角形 $T$。\n\n您的推导和实现必须从以下基础开始：\n- 积分的换元法：对于一个光滑双射 $\\boldsymbol{\\phi}: \\Omega \\subset \\mathbb{R}^n \\to \\mathbb{R}^n$，有\n$$\n\\int_{\\boldsymbol{\\phi}(\\Omega)} f(\\boldsymbol{x})\\, \\mathrm{d}\\boldsymbol{x} = \\int_{\\Omega} f(\\boldsymbol{\\phi}(\\boldsymbol{u}))\\, \\left|\\det D\\boldsymbol{\\phi}(\\boldsymbol{u})\\right|\\, \\mathrm{d}\\boldsymbol{u}.\n$$\n- 高斯-勒让德求积：对于 $n$ 个点，$[-1,1]$ 上的高斯-勒让德法则对最高为 $2n-1$ 次的多项式是精确的，并通过仿射变量变换映射到 $[0,1]$。\n- 裂纹尖端在原点的三角形的Duffy变换：设 $(\\xi,\\eta)$ 是顶点为 $(0,0)$、$(1,0)$、$(0,1)$ 的参考直角三角形上的坐标。由 $(\\xi,\\eta)=(u,uv)$ 定义的Duffy映射 $(u,v) \\mapsto (\\xi,\\eta)$（其中 $u \\in [0,1]$ 且 $v \\in [0,1]$）的雅可比行列式为 $J_{D}(u,v) = u$。将其与从参考三角形到物理三角形 $T$ 的仿射映射 $\\boldsymbol{x}(\\xi,\\eta) = \\boldsymbol{v}_1 + \\xi\\,\\boldsymbol{v}_2 + \\eta\\,\\boldsymbol{v}_3$ 复合，得到的总雅可比行列式为 $\\left|\\det D\\boldsymbol{\\phi}(u,v)\\right| = \\left|\\det\\left[\\boldsymbol{v}_2\\,\\,\\boldsymbol{v}_3\\right]\\right|\\, u$。\n\n在这些映射下，$f(\\boldsymbol{x}) = r^{-1/2}$ 的变换后被积函数在 $u$ 和 $v$ 中是可分离的，该积分可以通过在 $u$ 和 $v$ 上使用名义阶为 $p$ 的张量积高斯-勒让德法则来计算。为评估精度，通过解析计算分离出的 $u$ 积分，并对得到的关于 $v$ 的一维积分使用高阶高斯-勒让德法则（在 $[0,1]$上）来计算参考值 $I_{\\mathrm{ref}}(T)$。\n\n对于顶点为 $(0,0)$、$(1,0)$、$(0,1)$ 的参考三角形上阶为 $p$ 的对称三角形求积，使用经典的阶为 $p=2$ 的正则：\n- 三个点的重心坐标分别为 $(\\frac{2}{3},\\frac{1}{6},\\frac{1}{6})$、$(\\frac{1}{6},\\frac{2}{3},\\frac{1}{6})$、$(\\frac{1}{6},\\frac{1}{6},\\frac{2}{3})$，\n- 在参考三角形上的权重相等，为 $w = \\frac{1}{6}$（权重之和为其面积 $A_{\\mathrm{ref}}=\\frac{1}{2}$）。\n将这些点仿射映射到 $T$，并按雅可比行列式的绝对值 $|\\det[\\boldsymbol{v}_2\\,\\,\\boldsymbol{v}_3]|$ 缩放权重。\n\n在单个程序中实现以下任务：\n1. 推导并实现基于Duffy的求积方法，以计算 $I(T)$，在两个参数方向上均使用名义阶为 $p=2$ 的高斯-勒让德求积（在 $[0,1]$ 上）。\n2. 如上所述，实现阶为 $p=2$ 的对称三角形求积法并计算 $I(T)$。\n3. 通过解析计算 $u$ 积分，并对 $v$ 积分使用含 $n_{\\mathrm{ref}} = 200$ 个点的高斯-勒让德法则（在 $[0,1]$ 上），计算高精度参考值 $I_{\\mathrm{ref}}(T)$。\n4. 对于下方的每个测试用例，输出基于Duffy的求积和对称三角形求积相对于 $I_{\\mathrm{ref}}(T)$ 的绝对误差。\n\n测试套件（每个用例通过其非原点顶点 $\\boldsymbol{v}_2=(x_2,y_2)$ 和 $\\boldsymbol{v}_3=(x_3,y_3)$ 定义一个三角形 $T$，并设置 $p=2$）：\n- 用例 1：$\\boldsymbol{v}_2=(1,0)$，$\\boldsymbol{v}_3=(0,1)$。\n- 用例 2：$\\boldsymbol{v}_2=(0.1,0)$，$\\boldsymbol{v}_3=(0,0.1)$。\n- 用例 3：$\\boldsymbol{v}_2=(0.01,0)$，$\\boldsymbol{v}_3=(0,0.01)$。\n- 用例 4：$\\boldsymbol{v}_2=(0.1,0)$，$\\boldsymbol{v}_3=(0,0.2)$。\n- 用例 5：$\\boldsymbol{v}_2=(0.1,0)$，$\\boldsymbol{v}_3=(0.05,0.1)$。\n\n所有量均为无量纲；无需物理单位。此问题不涉及角度。对于每个测试用例，计算一对绝对误差：\n$$\n\\left[\\, \\left|I_{\\mathrm{Duffy}}(T) - I_{\\mathrm{ref}}(T)\\right| \\,,\\, \\left|I_{\\mathrm{tri}}(T) - I_{\\mathrm{ref}}(T)\\right| \\,\\right].\n$$\n\n最终输出格式：您的程序应生成单行输出，其中包含结果，形式为这些对的逗号分隔列表，并用方括号括起来，每个数值条目以浮点数形式打印；例如，\n$$\n\\left[\\,[e_{11},e_{12}],[e_{21},e_{22}],\\ldots\\right].\n$$", "solution": "该问题要求计算一个奇异积分 $I(T) = \\int_T r^{-1/2}\\, \\mathrm{d}x\\,\\mathrm{d}y$，积分区域为一个顶点在原点的三角形 $T$，而奇点 $r^{-1/2}$ 正位于原点。我们需要比较两种数值方法的精度：一种是标准的对称求积法则，另一种是使用Duffy变换的专门方法。为了进行比较，我们将计算一个高精度的参考值。所有方法都将针对名义阶 $p=2$ 来实现。\n\n首先，我们为每种方法建立数学框架。\n\n### 1. Duffy变换求积\n\nDuffy变换是一种坐标变换，旨在正则化三角形顶点处的奇点。该变换是两个映射的复合。首先，Duffy映射 $\\boldsymbol{\\psi}_D: [0,1]^2 \\to \\hat{T}$ 将 $(u,v)$ 坐标系中的单位正方形映射到 $(\\xi,\\eta)$ 坐标系中顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$ 的参考直角三角形 $\\hat{T}$。该映射由 $(\\xi, \\eta) = (u, uv)$ 给出。其雅可比行列式为 $J_D(u,v) = u$。\n\n其次，仿射映射 $\\boldsymbol{\\psi}_A: \\hat{T} \\to T$ 将参考三角形 $\\hat{T}$ 映射到物理三角形 $T$。由于奇点处的顶点是 $\\boldsymbol{v}_1=(0,0)$，此映射为 $\\boldsymbol{x}(\\xi,\\eta) = \\xi \\boldsymbol{v}_2 + \\eta \\boldsymbol{v}_3$。此映射的雅可比矩阵为 $D\\boldsymbol{\\psi}_A = [\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]$，其行列式为 $\\det(D\\boldsymbol{\\psi}_A) = \\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]$。\n\n复合映射为 $\\boldsymbol{\\phi}(u,v) = \\boldsymbol{\\psi}_A(\\boldsymbol{\\psi}_D(u,v)) = u\\boldsymbol{v}_2 + uv\\boldsymbol{v}_3 = u(\\boldsymbol{v}_2 + v\\boldsymbol{v}_3)$。根据链式法则，总雅可比行列式的绝对值为 $|\\det D\\boldsymbol{\\phi}(u,v)| = |\\det(D\\boldsymbol{\\psi}_A)| |J_D(u,v)| = |\\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]| \\, u$，因为 $u \\in [0,1]$。\n\n被积函数 $f(\\boldsymbol{x}) = r^{-1/2}$ 变换如下。离原点的距离平方为 $r^2 = \\boldsymbol{x} \\cdot \\boldsymbol{x}$。\n$$\nr^2(u,v) = \\left(u(\\boldsymbol{v}_2 + v\\boldsymbol{v}_3)\\right) \\cdot \\left(u(\\boldsymbol{v}_2 + v\\boldsymbol{v}_3)\\right) = u^2 \\left( \\|\\boldsymbol{v}_2\\|^2 + 2v(\\boldsymbol{v}_2 \\cdot \\boldsymbol{v}_3) + v^2\\|\\boldsymbol{v}_3\\|^2 \\right)\n$$\n因此，变换后的被积函数为：\n$$\nf(\\boldsymbol{\\phi}(u,v)) = r^{-1/2} = \\left(r^2\\right)^{-1/4} = u^{-1/2} \\left( \\|\\boldsymbol{v}_2\\|^2 + 2v(\\boldsymbol{v}_2 \\cdot \\boldsymbol{v}_3) + v^2\\|\\boldsymbol{v}_3\\|^2 \\right)^{-1/4}\n$$\n在 $T$ 上的积分变成了在单位正方形 $[0,1]^2$ 上的积分：\n$$\nI(T) = \\int_0^1 \\int_0^1 f(\\boldsymbol{\\phi}(u,v)) |\\det D\\boldsymbol{\\phi}(u,v)| \\, \\mathrm{d}u \\, \\mathrm{d}v\n$$\n$$\nI(T) = \\int_0^1 \\int_0^1 \\left[ u^{-1/2} g(v) \\right] \\left[ |\\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]| \\, u \\right] \\, \\mathrm{d}u \\, \\mathrm{d}v\n$$\n其中 $g(v) = \\left( \\|\\boldsymbol{v}_2\\|^2 + 2v(\\boldsymbol{v}_2 \\cdot \\boldsymbol{v}_3) + v^2\\|\\boldsymbol{v}_3\\|^2 \\right)^{-1/4}$。\nDuffy变换的关键好处在此显现：雅可比项 $u$ 与被积函数中的奇异项 $u^{-1/2}$ 结合，产生了一个正则项 $u^{1/2}$。积分现在是可分离的且无奇点：\n$$\nI(T) = |\\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]| \\left( \\int_0^1 u^{1/2} \\, \\mathrm{d}u \\right) \\left( \\int_0^1 g(v) \\, \\mathrm{d}v \\right)\n$$\n为了计算 $I_{\\mathrm{Duffy}}(T)$，我们使用名义阶为 $p=2$ 的张量积高斯-勒让德法则来近似这个积分。这需要一个对最高为2次的多项式精确的法则。$n$ 点高斯-勒让德法则对 $2n-1$ 次多项式是精确的。对于 $2n-1 \\ge 2$，我们选择 $n=2$。设 $\\{z_i, w_i\\}_{i=1}^2$ 是映射到区间 $[0,1]$ 上的2点高斯-勒让德求积点和权重。近似值为：\n$$\nI_{\\mathrm{Duffy}}(T) \\approx \\sum_{i=1}^2 \\sum_{j=1}^2 w_i w_j \\left( |\\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]| \\, z_i^{1/2} \\, g(z_j) \\right)\n$$\n\n### 2. 标准对称三角形求积\n\n该方法使用从参考三角形 $\\hat{T}$（顶点为 $(0,0)$、$(1,0)$、$(0,1)$）到物理三角形 $T$ 的标准仿射映射。映射为 $\\boldsymbol{x}(\\xi,\\eta) = \\xi \\boldsymbol{v}_2 + \\eta \\boldsymbol{v}_3$，其雅可比行列式为 $\\det D\\boldsymbol{x} = \\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]$。积分变换为：\n$$\nI(T) = \\int_{\\hat{T}} f(\\boldsymbol{x}(\\xi,\\eta)) |\\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]| \\, \\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\n在 $\\hat{T}$ 上的积分使用指定的阶为 $p=2$ 的对称求积法则来近似。该法则的点在 $\\hat{T}$ 上以重心坐标 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 给出。对于参考顶点 $\\boldsymbol{c}_1=(0,0), \\boldsymbol{c}_2=(1,0), \\boldsymbol{c}_3=(0,1)$，重心坐标为 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 的点其笛卡尔坐标为 $(\\xi, \\eta) = (\\lambda_2, \\lambda_3)$。这些点是：\n\\begin{itemize}\n    \\item $\\boldsymbol{p}_1$: $(\\frac{2}{3}, \\frac{1}{6}, \\frac{1}{6}) \\implies (\\xi_1, \\eta_1) = (\\frac{1}{6}, \\frac{1}{6})$\n    \\item $\\boldsymbol{p}_2$: $(\\frac{1}{6}, \\frac{2}{3}, \\frac{1}{6}) \\implies (\\xi_2, \\eta_2) = (\\frac{2}{3}, \\frac{1}{6})$\n    \\item $\\boldsymbol{p}_3$: $(\\frac{1}{6}, \\frac{1}{6}, \\frac{2}{3}) \\implies (\\xi_3, \\eta_3) = (\\frac{1}{6}, \\frac{2}{3})$\n\\end{itemize}\n相应的权重为 $\\hat{w}_k = \\frac{1}{6}$（对于 $k=1,2,3$）。权重之和为 $3 \\times \\frac{1}{6} = \\frac{1}{2}$，即 $\\hat{T}$ 的面积。求积近似值为：\n$$\nI_{\\mathrm{tri}}(T) \\approx |\\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]| \\sum_{k=1}^3 \\hat{w}_k f(\\boldsymbol{x}(\\xi_k, \\eta_k))\n$$\n其中 $\\boldsymbol{x}_k = \\xi_k \\boldsymbol{v}_2 + \\eta_k \\boldsymbol{v}_3$。由于被积函数 $f(\\boldsymbol{x})=r^{-1/2}$ 在一个顶点处是奇异的并且不是多项式，预计这种标准法则的精度会较低。\n\n### 3. 高精度参考积分\n\n参考值 $I_{\\mathrm{ref}}(T)$ 是在Duffy变换后的可分离积分形式上构建的。关于 $u$ 的积分可以解析求解：\n$$\n\\int_0^1 u^{1/2} \\, \\mathrm{d}u = \\left[\\frac{2}{3}u^{3/2}\\right]_0^1 = \\frac{2}{3}\n$$\n这留下一个关于 $v$ 的一维积分：\n$$\nI(T) = \\frac{2}{3}|\\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]| \\int_0^1 g(v) \\, \\mathrm{d}v\n$$\n其中 $g(v)$ 是前面定义的光滑函数。为了计算 $I_{\\mathrm{ref}}(T)$，我们使用 $n_{\\mathrm{ref}}=200$ 个点和权重 $\\{z_j^{\\mathrm{ref}}, w_j^{\\mathrm{ref}}\\}_{j=1}^{200}$（在 $[0,1]$ 上）的高阶高斯-勒让德法则来近似剩余的积分 $\\int_0^1 g(v) \\, \\mathrm{d}v$。\n$$\nI_{\\mathrm{ref}}(T) = \\frac{2}{3}|\\det[\\boldsymbol{v}_2 \\,\\,\\boldsymbol{v}_3]| \\sum_{j=1}^{200} w_j^{\\mathrm{ref}} g(z_j^{\\mathrm{ref}})\n$$\n该值作为一个高精度的基准，我们用它来衡量 $I_{\\mathrm{Duffy}}(T)$ 和 $I_{\\mathrm{tri}}(T)$ 的绝对误差。\n\n最后一步是为每个给定的测试用例计算绝对误差 $|I_{\\mathrm{Duffy}}(T) - I_{\\mathrm{ref}}(T)|$ 和 $|I_{\\mathrm{tri}}(T) - I_{\\mathrm{ref}}(T)|$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the crack-tip integral problem by comparing Duffy transform quadrature\n    and standard triangle cubature against a high-accuracy reference solution.\n    \"\"\"\n\n    test_cases = [\n        ((1.0, 0.0), (0.0, 1.0)),    # Case 1\n        ((0.1, 0.0), (0.0, 0.1)),    # Case 2\n        ((0.01, 0.0), (0.0, 0.01)),   # Case 3\n        ((0.1, 0.0), (0.0, 0.2)),    # Case 4\n        ((0.1, 0.0), (0.05, 0.1))    # Case 5\n    ]\n\n    p_nominal = 2\n    # For a Gauss-Legendre rule of nominal degree p, we need 2n-1 >= p.\n    # For p=2, 2n-1 >= 2 => n=2 points are sufficient.\n    n_points_duffy = 2\n    n_points_ref = 200\n\n    def get_gl_rule_01(n_points):\n        \"\"\"Returns Gauss-Legendre points and weights for the interval [0, 1].\"\"\"\n        points_neg1_1, weights_neg1_1 = np.polynomial.legendre.leggauss(n_points)\n        points_0_1 = 0.5 * (points_neg1_1 + 1.0)\n        weights_0_1 = 0.5 * weights_neg1_1\n        return points_0_1, weights_0_1\n\n    # Gauss-Legendre rules\n    gl_points_duffy, gl_weights_duffy = get_gl_rule_01(n_points_duffy)\n    gl_points_ref, gl_weights_ref = get_gl_rule_01(n_points_ref)\n\n    # Standard symmetric triangle cubature rule (degree p=2) on reference triangle\n    # Points are given in barycentric coords; converted to Cartesian (xi, eta)\n    # for ref triangle with vertices (0,0), (1,0), (0,1).\n    # (lambda_1, lambda_2, lambda_3) -> (xi, eta) = (lambda_2, lambda_3)\n    tri_points_ref = np.array([\n        [1.0/6.0, 1.0/6.0],\n        [2.0/3.0, 1.0/6.0],\n        [1.0/6.0, 2.0/3.0]\n    ])\n    tri_weights_ref = np.array([1.0/6.0, 1.0/6.0, 1.0/6.0])\n\n    all_errors = []\n\n    for v2_coords, v3_coords in test_cases:\n        v2 = np.array(v2_coords)\n        v3 = np.array(v3_coords)\n\n        # --- Common Calculations ---\n        abs_det_J = np.abs(np.linalg.det([v2, v3]))\n        v2_dot_v2 = np.dot(v2, v2)\n        v3_dot_v3 = np.dot(v3, v3)\n        v2_dot_v3 = np.dot(v2, v3)\n\n        def g_v(v):\n            \"\"\"The v-dependent part of the Duffy-transformed integrand.\"\"\"\n            return (v2_dot_v2 + 2 * v * v2_dot_v3 + v**2 * v3_dot_v3)**(-0.25)\n        \n        # --- 1. High-Accuracy Reference Integral (I_ref) ---\n        # The u-integral is analytically 2/3.\n        # We use a high-order GL rule for the v-integral.\n        g_vals_ref = g_v(gl_points_ref)\n        integral_g_ref = np.sum(gl_weights_ref * g_vals_ref)\n        I_ref = (2.0/3.0) * abs_det_J * integral_g_ref\n\n        # --- 2. Duffy Transform Quadrature (I_Duffy) ---\n        # Tensor-product GL rule on [0,1]x[0,1] for the separable integral.\n        u_vals, v_vals = gl_points_duffy, gl_points_duffy\n        wu_vals, wv_vals = gl_weights_duffy, gl_weights_duffy\n        \n        # Integrand: abs_det_J * u^(1/2) * g(v)\n        # Using separability: (Integral of u part) * (Integral of v part)\n        integral_u_duffy = np.sum(wu_vals * u_vals**0.5)\n        integral_g_duffy = np.sum(wv_vals * g_v(v_vals))\n        \n        I_duffy = abs_det_J * integral_u_duffy * integral_g_duffy\n\n        # --- 3. Symmetric Triangle Cubature (I_tri) ---\n        # Map cubature points from reference to physical triangle\n        # x_k = xi_k * v2 + eta_k * v3\n        phys_points = tri_points_ref @ np.vstack([v2, v3])\n        \n        # Evaluate integrand f(x) = r^(-1/2) = (x . x)^(-1/4) at these points\n        r_sq = np.sum(phys_points**2, axis=1)\n        f_vals = r_sq**(-0.25)\n        \n        # I_tri = abs_det_J * sum(w_k * f(x_k))\n        I_tri = abs_det_J * np.sum(tri_weights_ref * f_vals)\n\n        # --- Calculate and store errors ---\n        error_duffy = np.abs(I_duffy - I_ref)\n        error_tri = np.abs(I_tri - I_ref)\n        all_errors.append([error_duffy, error_tri])\n\n    # --- Final Output ---\n    # Convert the list of lists into the required string format\n    result_str = \",\".join([f\"[{e1},{e2}]\" for e1, e2 in all_errors])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "3527274"}]}