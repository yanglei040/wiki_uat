{"hands_on_practices": [{"introduction": "掌握收敛标准的第一步是理解残余力的核心概念，即外部施加的力与结构内部响应力之间的不平衡。这个练习 [@problem_id:3511080] 提供了一个简单的线性系统的具体计算，帮助你牢固掌握残余力的定义和其欧几里得范数的计算方法。通过这个基本实践，你将为评估更复杂的非线性问题中的平衡状态奠定基础。", "problem": "考虑一个计算岩土力学中由有限元离散化产生的小应变、准静态、两自由度 (DOF) 离散系统。设节点位移向量为 $u \\in \\mathbb{R}^{2}$，其分量单位为米；节点外力向量为 $f_{\\mathrm{ext}} \\in \\mathbb{R}^{2}$，其分量单位为牛顿；节点内力向量为 $f_{\\mathrm{int}}(u) \\in \\mathbb{R}^{2}$。假设系统呈线性弹性行为，因此一致切线（刚度）矩阵 $K \\in \\mathbb{R}^{2 \\times 2}$ 是恒定、对称且正定的，并且 $f_{\\mathrm{int}}(u) = K u$，其中 $K$ 的矩阵元素单位为牛顿/米。在基于力的收敛准则中，与牛顿法相关的残差向量定义为 $r(u) = f_{\\mathrm{ext}} - f_{\\mathrm{int}}(u)$。基于力的绝对收敛准则要求欧几里得范数 $||r(u)||_{2}$ 小于或等于一个给定的绝对容差 $\\tau$（单位为牛顿），迭代才被视为收敛。\n\n给定\n$$\nf_{\\mathrm{ext}} = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}, \\quad\nK = \\begin{bmatrix} 100  20 \\\\ 20  50 \\end{bmatrix}, \\quad\nf_{\\mathrm{int}}(u) = K u, \\quad\nu = \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix},\n$$\n计算 $||r(u)||_{2}$ 并在绝对容差 $\\tau = 10^{-2}$ 下评估收敛性。以牛顿为单位表示残差范数。此外，报告一个二元指示符 $c$，定义为：如果 $||r(u)||_{2} \\le \\tau$，则 $c = 1$；否则 $c = 0$。以行矩阵的形式提供最终答案，该矩阵按顺序包含残差范数和二元指示符。", "solution": "首先对问题陈述进行严格的验证。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n问题提供了以下数据和定义：\n- 节点位移向量：$u \\in \\mathbb{R}^{2}$，其中 $u = \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix}$ (单位为米)。\n- 节点外力向量：$f_{\\mathrm{ext}} \\in \\mathbb{R}^{2}$，其中 $f_{\\mathrm{ext}} = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}$ (单位为牛顿)。\n- 节点内力向量：$f_{\\mathrm{int}}(u) \\in \\mathbb{R}^{2}$。\n- 刚度矩阵：$K \\in \\mathbb{R}^{2 \\times 2}$，其中 $K = \\begin{bmatrix} 100  20 \\\\ 20  50 \\end{bmatrix}$ (单位为牛顿/米)。\n- 本构关系：$f_{\\mathrm{int}}(u) = K u$。\n- 残差向量：$r(u) = f_{\\mathrm{ext}} - f_{\\mathrm{int}}(u)$。\n- 绝对收敛准则：$||r(u)||_{2} \\le \\tau$。\n- 绝对容差：$\\tau = 10^{-2}$ (单位为牛顿)。\n- 二元收敛指示符：如果 $||r(u)||_{2} \\le \\tau$，则 $c=1$；否则 $c=0$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于固体力学和数值分析的原理，特别是针对线性弹性系统的有限元法。内力、残余力和基于力的收敛准则的定义在计算力学中是标准的。\n- **适定性**：该问题是适定的。所有必要的数据（$f_{\\mathrm{ext}}$、$K$、$u$、$\\tau$）都已提供。定义清晰无歧义，可以导出一个唯一且可计算的解。单位是一致的：$[K][u] = (\\text{N}/\\text{m}) \\cdot \\text{m} = \\text{N}$，这与 $f_{\\mathrm{ext}}$ 和 $\\tau$ 的单位相匹配。刚度矩阵 $K$ 是对称的。其顺序主子式为 $\\det([100]) = 100 > 0$ 和 $\\det(K) = (100)(50) - (20)(20) = 5000 - 400 = 4600 > 0$，证实了其如题目所述是正定的。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有任何主观性或歧义。\n\n**步骤 3：结论与行动**\n该问题是有效的，因为它在科学上是合理的、适定的和客观的。将推导求解。\n\n**求解推导**\n\n主要目标是计算残差向量的欧几里得范数 $||r(u)||_{2}$，并随后确定二元收敛指示符 $c$ 的值。\n\n首先，我们使用给定的刚度矩阵 $K$ 和位移向量 $u$ 计算内力向量 $f_{\\mathrm{int}}(u)$。\n$$\nf_{\\mathrm{int}}(u) = K u = \\begin{bmatrix} 100  20 \\\\ 20  50 \\end{bmatrix} \\begin{bmatrix} 0.1 \\\\ -0.2 \\end{bmatrix}\n$$\n矩阵-向量乘法得出：\n$$\nf_{\\mathrm{int}}(u) = \\begin{bmatrix} (100)(0.1) + (20)(-0.2) \\\\ (20)(0.1) + (50)(-0.2) \\end{bmatrix} = \\begin{bmatrix} 10 - 4 \\\\ 2 - 10 \\end{bmatrix} = \\begin{bmatrix} 6 \\\\ -8 \\end{bmatrix}\n$$\n$f_{\\mathrm{int}}(u)$ 的单位是牛顿。\n\n接下来，我们计算残差向量 $r(u)$，即外力向量与内力向量之差。\n$$\nr(u) = f_{\\mathrm{ext}} - f_{\\mathrm{int}}(u) = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix} - \\begin{bmatrix} 6 \\\\ -8 \\end{bmatrix} = \\begin{bmatrix} 10 - 6 \\\\ -5 - (-8) \\end{bmatrix} = \\begin{bmatrix} 4 \\\\ 3 \\end{bmatrix}\n$$\n$r(u)$ 的单位是牛顿。\n\n现在，我们计算残差向量的欧几里得范数（或 $L_2$-范数）$||r(u)||_{2}$。对于向量 $v = \\begin{bmatrix} v_1 \\\\ v_2 \\end{bmatrix}$，其欧几里得范数为 $||v||_2 = \\sqrt{v_1^2 + v_2^2}$。\n$$\n||r(u)||_{2} = \\left|\\left|\\begin{bmatrix} 4 \\\\ 3 \\end{bmatrix}\\right|\\right|_{2} = \\sqrt{4^2 + 3^2} = \\sqrt{16 + 9} = \\sqrt{25} = 5\n$$\n残差范数为 $5$ N。\n\n最后，我们通过将计算出的残差范数与给定的绝对容差 $\\tau$ 进行比较来评估收敛性。收敛准则是 $||r(u)||_{2} \\le \\tau$。\n我们有 $||r(u)||_{2} = 5$ 和 $\\tau = 10^{-2} = 0.01$。不等式为：\n$$\n5 \\le 0.01\n$$\n此不等式不成立。因此，系统尚未收敛。\n\n二元指示符 $c$ 定义为：如果达到收敛，则 $c=1$；否则 $c=0$。由于条件未满足，该指示符的值为：\n$$\nc = 0\n$$\n问题要求最终答案是一个按顺序包含残差范数和二元指示符的行矩阵。所需的量为 $||r(u)||_{2} = 5$ 和 $c=0$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 5  0 \\end{pmatrix}}\n$$", "id": "3511080"}, {"introduction": "虽然存在多种收敛准则，但在所有情况下它们并非同等可靠，尤其是在处理岩土力学中常见的高刚度差异或接触等病态问题时。这个练习 [@problem_id:3511130] 构建了一个巧妙的反例，旨在揭示仅依赖位移增量判断收敛的潜在陷阱。通过计算你会发现，一个看似已经收敛的微小位移可能掩盖了巨大的力不平衡，这是每一个计算力学工程师都必须警惕的关键问题。", "problem": "考虑一个通过有限元法 (FEM) 离散化的准静态、小应变岩土力学模型。在一次迭代中的离散平衡由线性系统 $K u = f$ 描述，其中 $K$ 是对称正定的全局刚度矩阵，$u$ 是节点位移向量，$f$ 是外荷载向量。在牛顿-拉夫逊 (NR) 迭代中，残差力向量定义为 $r = f - K u$，更新量通过求解 $K \\Delta u = r$ 得到。收敛性通常通过位移增量范数 $\\|\\Delta u\\|$、残差力范数 $\\|r\\|$ 以及能量度量来评估。使用这些核心定义，构建一个具体的反例，以表明由于病态条件或不良缩放，小的 $\\|\\Delta u\\|$ 可以与大的 $\\|r\\|$ 共存。\n\n建立一个双自由度节点的模型，该节点代表一个刚性基础，通过罚函数法施加非侵入约束压在一个刚性边界上，同时带有一个代表周围土体的软侧向剪切弹簧。罚刚度导致了代数系统的严重病态。设全局刚度矩阵为\n$$\nK = \\begin{pmatrix}\n10^{12}  0 \\\\\n0  10^{3}\n\\end{pmatrix},\n$$\n当前迭代步的解 $u_{k}$ 为 $\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$，施加的外荷载为\n$$\nf = \\begin{pmatrix}\n10^{3} \\\\\n0\n\\end{pmatrix}.\n$$\n将 $u_{1}$ 解释为由罚函数法施加的法向接触自由度，将 $u_{2}$ 解释为具有实际土体刚度的侧向剪切自由度。\n\n使用上述基本定义，由 $K \\Delta u = r$（其中 $r = f - K u_{k}$）计算牛顿-拉夫逊更新量 $\\Delta u$，然后计算欧几里得向量范数 $\\|\\Delta u\\|_{2}$ 和 $\\|r\\|_{2}$，最后形成无量纲比值\n$$\n\\rho = \\frac{\\|r\\|_{2}}{\\|\\Delta u\\|_{2}}。\n$$\n将最终比值表示为一个纯数（无量纲），并将您的答案四舍五入到四位有效数字。此外，请根据计算出的量和 $K$ 的结构，解释为什么对于此系统，基于位移的收敛准则会误导性地指示收敛，而基于力的准则则不会。", "solution": "该问题陈述是计算力学和数值分析中的一个有效练习。它具有科学依据、适定且客观。它提出了一个在岩土工程接触问题的有限元法 (FEM) 分析中遇到的标准（尽管简化了）场景，其中罚函数法会导致病态刚度矩阵。计算和后续分析所需的所有数据都已提供，且不存在内部矛盾或歧义。因此，我们可以着手求解。\n\n问题要求我们分析一个双自由度系统的牛顿-拉夫逊迭代。位移增量 $\\Delta u$ 的控制方程由 $K \\Delta u = r$ 给出，其中 $K$ 是刚度矩阵，$r$ 是残差力向量。\n\n首先，我们已知必要的量：\n全局刚度矩阵为：\n$$\nK = \\begin{pmatrix}\n10^{12}  0 \\\\\n0  10^{3}\n\\end{pmatrix}\n$$\n外荷载向量为：\n$$\nf = \\begin{pmatrix}\n10^{3} \\\\\n0\n\\end{pmatrix}\n$$\n在当前迭代步 $k$ 的位移向量为：\n$$\nu_{k} = \\begin{pmatrix}\n0 \\\\\n0\n\\end{pmatrix}\n$$\n\n第一步是计算当前迭代步的残差力向量 $r$。残差定义为不平衡力，$r = f - f_{\\text{internal}}$，其中内力由 $f_{\\text{internal}} = K u_{k}$ 给出。\n$$\nr = f - K u_{k} = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 10^{12}  0 \\\\ 0  10^{3} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n$$\nr = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix}\n$$\n残差力向量为 $r = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix}$。\n\n接下来，我们使用牛顿-拉夫逊更新方程 $K \\Delta u = r$ 求解位移增量向量 $\\Delta u = \\begin{pmatrix} \\Delta u_1 \\\\ \\Delta u_2 \\end{pmatrix}$。\n$$\n\\begin{pmatrix} 10^{12}  0 \\\\ 0  10^{3} \\end{pmatrix} \\begin{pmatrix} \\Delta u_1 \\\\ \\Delta u_2 \\end{pmatrix} = \\begin{pmatrix} 10^{3} \\\\ 0 \\end{pmatrix}\n$$\n由于刚度矩阵 $K$ 是对角矩阵，该线性方程组是解耦的，可以逐分量求解：\n$$\n10^{12} \\Delta u_1 = 10^{3} \\implies \\Delta u_1 = \\frac{10^{3}}{10^{12}} = 10^{-9}\n$$\n$$\n10^{3} \\Delta u_2 = 0 \\implies \\Delta u_2 = 0\n$$\n因此，位移增量向量为：\n$$\n\\Delta u = \\begin{pmatrix}\n10^{-9} \\\\\n0\n\\end{pmatrix}\n$$\n\n现在，我们计算残差力向量的欧几里得范数（$\\ell_2$-范数）$\\|r\\|_{2}$ 和位移增量向量的欧几里得范数 $\\|\\Delta u\\|_{2}$。\n残差力向量的范数是：\n$$\n\\|r\\|_{2} = \\sqrt{(10^{3})^{2} + 0^{2}} = \\sqrt{10^{6}} = 10^{3}\n$$\n位移增量向量的范数是：\n$$\n\\|\\Delta u\\|_{2} = \\sqrt{(10^{-9})^{2} + 0^{2}} = \\sqrt{10^{-18}} = 10^{-9}\n$$\n\n最后，我们计算无量纲比值 $\\rho$：\n$$\n\\rho = \\frac{\\|r\\|_{2}}{\\|\\Delta u\\|_{2}} = \\frac{10^{3}}{10^{-9}} = 10^{12}\n$$\n问题要求将此值四舍五入到四位有效数字。我们将其用科学记数法表示为：\n$$\n\\rho = 1.000 \\times 10^{12}\n$$\n\n关于为什么基于位移的准则会产生误导的解释，是建立在我们刚刚计算出的结果以及刚度矩阵 $K$ 的结构之上的。\n位移增量的范数 $\\|\\Delta u\\|_{2} = 10^{-9}$ 是一个极小的值。如果一个典型的位移收敛容差是，例如，$\\epsilon_u = 10^{-6}$，那么准则 $\\|\\Delta u\\|_{2} \\le \\epsilon_u$ 将会满足，迭代求解器将终止并宣布收敛。\n\n然而，残差力的范数 $\\|r\\|_{2} = 10^{3}$ 是一个非常大的值。残差力代表了在当前迭代步平衡方程被违反的程度。一个大的残差范数表明系统远未达到平衡。一个基于力的收敛准则，例如 $\\|r\\|_{2} \\le \\epsilon_f$（其中 $\\epsilon_f$ 是一个小的力容差），会正确地识别出解尚未收敛。\n\n这种差异的根本原因是刚度矩阵 $K$ 的严重病态。一个对称矩阵的条件数是其最大特征值与最小特征值的比值。对于我们的对角矩阵 $K$，特征值就是对角线上的元素，即 $\\lambda_{1} = 10^{12}$ 和 $\\lambda_{2} = 10^{3}$。条件数为：\n$$\n\\text{cond}(K) = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}} = \\frac{10^{12}}{10^{3}} = 10^{9}\n$$\n大的条件数意味着该矩阵对扰动敏感，并且它以差异极大的缩放因子映射不同方向的向量。在此问题中，代表刚性罚接触的第一个自由度上的刚度 ($k_{11} = 10^{12}$) 比代表较软土体的第二个自由度上的刚度 ($k_{22} = 10^3$) 大 $9$ 个数量级。\n\n关系式 $r = K \\Delta u$ 表明，如果 $K$ 含有大的元素，一个小的位移增量 $\\Delta u$ 就可以对应一个大的残差力 $r$。具体来说，残差力完全集中在非常刚硬的第一个自由度上 ($r_1 = 10^3$)。为了平衡这个巨大的不平衡力，只需要一个大小为 $\\Delta u_1 = r_1/k_{11} = 10^3 / 10^{12} = 10^{-9}$ 的位移修正量。由于位移修正量如此微小，对 $\\|\\Delta u\\|_2$ 的检查会提供一个误导性的收敛信号。它将在一个非常刚硬的方向上的微小步长误认为是接近最终解。另一方面，基于力的准则直接度量了不平衡的程度，并且不会被病态刚度矩阵的缩放效应所欺骗。因此，在具有像本例这样高刚度对比的系统中，基于力或基于能量的收敛准则通常比纯粹基于位移的准则更为鲁棒和可靠。", "answer": "$$\n\\boxed{1.000 \\times 10^{12}}\n$$", "id": "3511130"}, {"introduction": "对收敛准则的真正考验在于它们在非线性模拟中的实际表现，尤其是在材料行为发生剧烈变化时，例如进入塑性阶段。这个最终的实践练习 [@problem_id:3511083] 要求你通过编程实现一个简化的弹塑性模型，并直接比较基于力、位移和能量的收敛准则。通过这个综合性任务，你将深入洞察不同准则在捕捉屈服等物理现象时的相对优势与不足，从而在未来的分析中做出更明智的选择。", "problem": "考虑一个在小应变下轴对称三轴压缩有限元（FE）模拟的一维替代模型，该模型旨在分离一个与压力无关、具有线性各向同性硬化的 von Mises ($J_2$) 塑性模型的偏量响应。尽管物理试验是具有恒定径向围压的三轴试验，但 $J_2$ 屈服条件仅取决于偏应力；因此，在这个替代模型中，围压是一个不直接进入屈服函数的背景场。唯一的全局未知量是轴向位移 $u$，它在长度为 $L$、横截面积为 $A$ 的试件中产生轴向应变 $\\varepsilon = u/L$。轴向内力为 $f_{\\text{int}} = A \\sigma$，其中 $\\sigma$ 是通过弹塑性本构更新计算出的轴向应力。轴向外力被规定为 $f_{\\text{ext}}(t)$，随离散的加载步分段线性增加。静力平衡要求 $f_{\\text{int}} = f_{\\text{ext}}$。\n\n材料在屈服前是杨氏模量为 $E$ 的线性弹性体，并遵循具有线性各向同性硬化的 $J_2$ 屈服条件，该条件由初始屈服应力 $\\sigma_{y0}$ 和硬化模量 $H$ 参数化。在单轴状态下，von Mises 等效应力等于 $|\\sigma|$，当发生塑性加载时，径向回归会在屈服面上产生一个修正应力。内变量是塑性应变 $\\varepsilon^p$ 和累积塑性应变 $\\alpha$，两者都初始化为零。每次试探应变下的回归映射更新强制要求 $|\\sigma| - (\\sigma_{y0} + H \\alpha) \\le 0$，在塑性加载时等号成立。塑性加载时的一致切线模量为 $E_t = E H / (E + H)$，弹性加载时为 $E_t = E$。\n\n平衡的全局残差为 $r_f(u) = f_{\\text{int}}(u) - f_{\\text{ext}}$，其在单自由度下的 Newton–Raphson (NR) 更新为 $\\Delta u = - r_f / K_t$，其中 $K_t = A E_t / L$ 是一致切线刚度。在当前迭代点 $\\Pi(u)$ 的总势能增量变化由一阶变分近似为 $\\Delta \\Pi \\approx r_f \\Delta u$。参考能量尺度是初始屈服时的弹性应变能，$E_{\\text{ref}} = (A L) \\, \\sigma_{y0}^2 / (2 E)$。\n\n实现一个执行以下任务的程序：\n\n1. 对于每个加载步 $n$，施加 $f_{\\text{ext}}^{(n)}$ 并使用 Newton–Raphson 方法和一致弹塑性切线求解平衡方程 $r_f(u^{(n)}) = 0$。使用前一个收敛状态 $(u^{(n-1)}, \\varepsilon^{p, (n-1)}, \\alpha^{(n-1)})$ 作为当前步骤的初始猜测。在每次 Newton–Raphson 迭代中：\n   - 计算应变 $\\varepsilon = u/L$，执行单轴弹塑性回归映射更新以获得 $(\\sigma, \\varepsilon^p, \\alpha, E_t)$，然后更新 $r_f = A \\sigma - f_{\\text{ext}}$ 和 $K_t = A E_t / L$。\n   - 通过 $\\Delta u = - r_f / K_t$ 更新位移。\n   - 定义能量增量 $\\Delta \\Pi = r_f \\Delta u$。\n   - 当满足以下任一收敛准则时，停止迭代：\n     - 力残差准则：$\\|r_f\\| / \\max(\\|f_{\\text{ext}}\\|, f_{\\text{ref}}) \\le \\epsilon_f$，其中 $f_{\\text{ref}} = A \\sigma_{y0}$。\n     - 位移增量准则：$\\|\\Delta u\\| / \\max(\\|u\\|, u_{\\text{ref}}) \\le \\epsilon_u$，其中 $u_{\\text{ref}} > 0$ 是一个小的正则化长度。\n     - 能量减量准则：$|\\Delta \\Pi| / E_{\\text{ref}} \\le \\epsilon_E$。\n   - 如果超过最大迭代次数仍未满足所选准则，则终止当前步骤并接受该步骤的最后一次迭代结果。\n\n2. 对于每个测试用例，使用能量减量准则和极严格的容差 $\\epsilon_E^{\\text{ref}}$ 求解相同的加载路径，以计算高精度参考解。从此参考解中，确定首次出现塑性的加载步，并存储该步骤的收敛位移和内变量。\n\n3. 对于任务1中的每个收敛准则，使用指定的容差求解相同的测试用例，并在参考解确定的第一个塑性加载步计算：\n   - 最后一次 Newton–Raphson 更新的能量范数，定义为 $|\\Delta \\Pi|$，并以此作为迭代接近屈服时势能驻点的程度的代理。较小的值表示更好地捕捉到接近屈服面的过程。\n   - 通过选择在该步骤中 Newton–Raphson 迭代次数最少的准则来打破平局。\n\n4. 对于每个测试用例，选择在第一个塑性加载步具有最小 $|\\Delta \\Pi|$ 的准则为“最佳”准则，并应用上述平局打破规则。将准则编码为整数：$0$ 代表力残差，$1$ 代表位移增量，$2$ 代表能量减量。\n\n在推导和实现中使用的基本原理：\n- 静态一维形式的线性动量守恒：$f_{\\text{int}} = f_{\\text{ext}}$。\n- 运动学：$\\varepsilon = u/L$ 和 $\\varepsilon^p$ 作为内变量。\n- 小应变下的线性弹性：屈服前 $\\sigma = E(\\varepsilon - \\varepsilon^p)$。\n- 具有线性各向同性硬化的 Von Mises ($J_2$) 屈服：$|\\sigma| - (\\sigma_{y0} + H \\alpha) \\le 0$。\n- Newton–Raphson 方法：$\\Delta u = -r_f / K_t$ 及一致切线。\n- 能量学：一阶势能减量 $\\Delta \\Pi \\approx r_f \\Delta u$。\n\n单位：\n- 使用国际单位制（SI）。长度单位为米（$\\mathrm{m}$），面积单位为平方米（$\\mathrm{m}^2$），力单位为牛顿（$\\mathrm{N}$），应力单位为帕斯卡（$\\mathrm{Pa}$），能量单位为焦耳（$\\mathrm{J}$）。\n- 最终输出表示为编码每个测试用例最佳准则的无量纲整数。\n\n测试套件和参数：\n- 三个测试用例，每个由 $(E, H, \\sigma_{y0}, A, L, f_{\\text{ext,max}}, N_{\\text{steps}}, \\epsilon_f, \\epsilon_u, \\epsilon_E, u_{\\text{ref}})$ 定义：\n  1. 用例 A（通用）：$(E = 1.0 \\times 10^8\\,\\mathrm{Pa}, H = 2.0 \\times 10^7\\,\\mathrm{Pa}, \\sigma_{y0} = 5.0 \\times 10^6\\,\\mathrm{Pa}, A = 1.0 \\times 10^{-2}\\,\\mathrm{m}^2, L = 1.0\\,\\mathrm{m}, f_{\\text{ext,max}} = 8.0 \\times 10^4\\,\\mathrm{N}, N_{\\text{steps}} = 12, \\epsilon_f = 1.0 \\times 10^{-6}, \\epsilon_u = 1.0 \\times 10^{-6}, \\epsilon_E = 1.0 \\times 10^{-12}, u_{\\text{ref}} = 1.0 \\times 10^{-12}\\,\\mathrm{m})$。\n  2. 用例 B（近乎理想塑性）：$(E = 1.0 \\times 10^8\\,\\mathrm{Pa}, H = 1.0 \\times 10^5\\,\\mathrm{Pa}, \\sigma_{y0} = 4.0 \\times 10^6\\,\\mathrm{Pa}, A = 1.0 \\times 10^{-2}\\,\\mathrm{m}^2, L = 1.0\\,\\mathrm{m}, f_{\\text{ext,max}} = 6.0 \\times 10^4\\,\\mathrm{N}, N_{\\text{steps}} = 12, \\epsilon_f = 1.0 \\times 10^{-6}, \\epsilon_u = 1.0 \\times 10^{-6}, \\epsilon_E = 1.0 \\times 10^{-12}, u_{\\text{ref}} = 1.0 \\times 10^{-12}\\,\\mathrm{m})$。\n  3. 用例 C（非常刚硬且强硬化）：$(E = 1.0 \\times 10^9\\,\\mathrm{Pa}, H = 5.0 \\times 10^8\\,\\mathrm{Pa}, \\sigma_{y0} = 6.0 \\times 10^6\\,\\mathrm{Pa}, A = 5.0 \\times 10^{-3}\\,\\mathrm{m}^2, L = 1.0\\,\\mathrm{m}, f_{\\text{ext,max}} = 5.0 \\times 10^4\\,\\mathrm{N}, N_{\\text{steps}} = 12, \\epsilon_f = 1.0 \\times 10^{-6}, \\epsilon_u = 1.0 \\times 10^{-6}, \\epsilon_E = 1.0 \\times 10^{-12}, u_{\\text{ref}} = 1.0 \\times 10^{-12}\\,\\mathrm{m})$。\n\n答案规格：\n- 你的程序应生成一行输出，其中包含一个由三个整数组成的列表 $[i_A, i_B, i_C]$，分别表示用例 A、B 和 C 的所选最佳准则，使用上述编码。\n- 输出格式必须完全符合方括号内逗号分隔的列表形式，例如 $[0,1,2]$。", "solution": "该计算任务是求解一个单自由度的轴对称三轴试验替代模型，该模型足以研究小应变下 von Mises ($J_2$) 塑性模型基于力、位移和能量的收敛准则。推导和算法设计从基本原理出发。\n\n一维静力平衡要求 $f_{\\text{int}} = f_{\\text{ext}}$。对于一个全局位移 $u$，轴向应变为 $\\varepsilon = u/L$。材料在屈服前是线性弹性的，因此试探应力为 $\\sigma_{\\text{tr}} = E (\\varepsilon - \\varepsilon^p)$。单轴状态下的 $J_2$ 屈服函数为 $f = |\\sigma| - (\\sigma_{y0} + H \\alpha)$，它描述了线性各向同性硬化。内变量是塑性应变 $\\varepsilon^p$ 和累积塑性应变 $\\alpha$，两者都初始化为零。\n\n回归映射算法源于强制执行相关联塑性的 Karush–Kuhn–Tucker 条件和正交性法则。对于一维 $J_2$ 塑性，当 $f(\\sigma_{\\text{tr}}, \\alpha) > 0$ 时，该算法简化为将 $\\sigma_{\\text{tr}}$ 投影回屈服面上：\n1. 计算 $\\sigma_{\\text{tr}} = E (\\varepsilon - \\varepsilon^p)$ 和屈服半径 $\\sigma_{\\text{y}}(\\alpha) = \\sigma_{y0} + H \\alpha$。\n2. 如果 $|\\sigma_{\\text{tr}}| \\le \\sigma_{\\text{y}}(\\alpha)$，则状态为弹性，$(\\sigma, \\varepsilon^p, \\alpha) = (\\sigma_{\\text{tr}}, \\varepsilon^p, \\alpha)$，切线模量为 $E_t = E$。\n3. 否则，发生塑性修正，塑性乘子增量为\n$$\n\\Delta \\gamma = \\frac{|\\sigma_{\\text{tr}}| - \\sigma_{\\text{y}}(\\alpha)}{E + H},\n$$\n应力更新至屈服面\n$$\n\\sigma = \\operatorname{sign}(\\sigma_{\\text{tr}}) \\, \\big(\\sigma_{y0} + H (\\alpha + |\\Delta \\gamma|)\\big),\n$$\n内变量更新为\n$$\n\\varepsilon^p \\leftarrow \\varepsilon^p + \\operatorname{sign}(\\sigma_{\\text{tr}}) \\, \\Delta \\gamma, \\quad \\alpha \\leftarrow \\alpha + |\\Delta \\gamma|,\n$$\n一致切线模量为\n$$\nE_t = \\frac{E H}{E + H}.\n$$\n这些表达式是通过在塑性加载和线性各向同性硬化中，强制执行 $\\sigma - \\sigma_{\\text{tr}} = - E \\Delta \\varepsilon^p$、硬化定律 $\\sigma_{y0} + H \\alpha$ 以及一致性条件 $f = 0$ 得出的。\n\n一维全局 Newton–Raphson 方法求解 $r_f(u) = f_{\\text{int}}(u) - f_{\\text{ext}} = 0$。使用一致切线刚度 $K_t = \\partial f_{\\text{int}} / \\partial u = A E_t / L$，更新公式为\n$$\n\\Delta u = - \\frac{r_f}{K_t}.\n$$\n势能泛函为 $\\Pi(u) = U(u) - f_{\\text{ext}} \\, u$，其中 $U$ 是储存的应变能。围绕当前迭代点 $u$ 的一阶变分给出\n$$\n\\Delta \\Pi \\approx \\frac{\\partial \\Pi}{\\partial u} \\, \\Delta u = r_f \\, \\Delta u.\n$$\n这个能量减量是基于能量的收敛准则的核心，因为 $\\Pi$ 的驻点对应于平衡状态。\n\n收敛准则定义如下：\n- 力残差准则通过物理上有意义的力尺度进行归一化，以避免除以零：\n$$\n\\frac{\\| r_f \\|}{\\max(\\| f_{\\text{ext}} \\|, f_{\\text{ref}})} \\le \\epsilon_f, \\quad f_{\\text{ref}} = A \\sigma_{y0}.\n$$\n- 位移增量准则通过位移尺度进行归一化，以避免除以零：\n$$\n\\frac{\\| \\Delta u \\|}{\\max(\\| u \\|, u_{\\text{ref}})} \\le \\epsilon_u, \\quad u_{\\text{ref}} > 0.\n$$\n- 能量减量准则通过初始屈服时的弹性应变能进行归一化：\n$$\n\\frac{|\\Delta \\Pi|}{E_{\\text{ref}}} \\le \\epsilon_E, \\quad E_{\\text{ref}} = \\frac{A L}{2} \\frac{\\sigma_{y0}^2}{E}.\n$$\n\n算法设计：\n1. 初始化 $(u, \\varepsilon^p, \\alpha) = (0, 0, 0)$ 并循环加载步 $n = 1, \\ldots, N_{\\text{steps}}$，其中 $f_{\\text{ext}}^{(n)} = (n/N_{\\text{steps}}) f_{\\text{ext,max}}$。\n2. 在每一步中，执行 Newton–Raphson 迭代：\n   - 计算 $\\varepsilon = u/L$，执行回归映射以获得 $(\\sigma, \\varepsilon^p, \\alpha, E_t)$，然后计算 $r_f = A \\sigma - f_{\\text{ext}}^{(n)}$ 和 $K_t = A E_t / L$。\n   - 更新 $\\Delta u = - r_f / K_t$ 和 $u \\leftarrow u + \\Delta u$，并存储 $\\Delta \\Pi = r_f \\Delta u$。\n   - 检查所选准则的收敛性；如果满足或达到最大迭代次数，则接受当前迭代结果。\n3. 使用能量准则和非常严格的容差 $\\epsilon_E^{\\text{ref}}$ 建立一个高精度参考解。在参考解中确定第一个塑性步（即回归映射首次执行塑性修正的步骤）。\n4. 对于具有指定容差的三个准则，重新计算解，并在参考解确定的第一个塑性步，评估该步最终 Newton–Raphson 更新的 $|\\Delta \\Pi|$。较小的 $|\\Delta \\Pi|$ 表示更接近 $\\Pi$ 的驻点，并且在接近屈服面时具有更高的保真度。使用该步中执行的迭代次数来打破平局。\n\n预期结果的科学推理：\n- 在屈服面附近，由于一致切线 $E_t$ 从 $E$ 过渡到 $E H /(E + H)$，内力-位移响应的斜率发生变化。能量减量 $|\\Delta \\Pi| = |r_f \\Delta u|$ 衡量势能的一阶变化，它综合了残差和更新量。这以一种物理上有意义、与加载路径无关的方式，捕捉了迭代向平衡态移动的程度。\n- 如果外力相对于内力尺度过小或过大，单独的力残差准则可能会产生误导；通过 $f_{\\text{ref}}$ 进行归一化可以缓解此问题，但不能完全解释屈服附近的刚度变化。\n- 位移准则在 $u=0$ 附近若无正则化则是病态的，并且可能对刚度变化不敏感，因为它衡量的是步长而不是能量上的接近程度。\n- 因此，能量减量准则因其功共轭的性质，通常能更好地反映屈服附近的收敛质量：它衡量的是残差和更新量的乘积，与最小化 $\\Pi$ 的目标一致。\n\n代码实现了这些原理，计算了每个准则在第一个塑性步的 $|\\Delta \\Pi|$，并为每个测试用例选择最佳准则，编码为整数 $0$、$1$ 或 $2$，分别对应力残差、位移增量或能量减量准则。最终输出将三个选择汇总为指定格式的单个列表 $[i_A, i_B, i_C]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef return_mapping_uniaxial(epsilon, ep_old, alpha_old, E, H, sigma_y0):\n    \"\"\"\n    Uniaxial J2 plasticity with linear isotropic hardening.\n    Radial return mapped to yield surface if trial stress exceeds yield.\n    Returns: sigma, ep_new, alpha_new, Et (consistent tangent)\n    \"\"\"\n    sigma_tr = E * (epsilon - ep_old)\n    yield_radius = sigma_y0 + H * alpha_old\n    if abs(sigma_tr) = yield_radius + 0.0:  # small tolerance not necessary here\n        # Elastic step\n        sigma = sigma_tr\n        ep_new = ep_old\n        alpha_new = alpha_old\n        Et = E\n    else:\n        # Plastic correction\n        dgamma = (abs(sigma_tr) - yield_radius) / (E + H)\n        sign = 1.0 if sigma_tr >= 0.0 else -1.0\n        ep_new = ep_old + sign * dgamma\n        alpha_new = alpha_old + abs(dgamma)\n        sigma = sign * (sigma_y0 + H * alpha_new)\n        Et = (E * H) / (E + H)\n    return sigma, ep_new, alpha_new, Et\n\ndef newton_solve_step(fext, u0, ep0, alpha0, E, H, sigma_y0, A, L,\n                      criterion, eps_f, eps_u, eps_E, u_ref, max_iter=100):\n    \"\"\"\n    Solve one load step with Newton-Raphson under a specified convergence criterion.\n    criterion: 'force', 'disp', or 'energy'\n    Returns converged (u, ep, alpha, sigma, iters, last_energy_increment)\n    \"\"\"\n    u = u0\n    ep = ep0\n    alpha = alpha0\n    last_energy_inc = None\n    iters = 0\n\n    # Reference scales\n    f_ref = A * sigma_y0\n    E_ref = (A * L) * (sigma_y0 ** 2) / (2.0 * E)\n\n    for k in range(max_iter):\n        # Current strain and material update\n        epsilon = u / L\n        sigma, ep_new, alpha_new, Et = return_mapping_uniaxial(epsilon, ep, alpha, E, H, sigma_y0)\n        # Internal force and tangent\n        fint = A * sigma\n        rf = fint - fext\n        Kt = A * Et / L\n\n        # Newton update\n        # Guard against zero tangent (shouldn't occur for H>=0 with E>0, but be safe)\n        if Kt == 0.0:\n            # If tangent is zero, cannot update; break\n            du = 0.0\n        else:\n            du = - rf / Kt\n\n        # Energy decrement approximation\n        dPi = rf * du\n        last_energy_inc = abs(dPi)\n\n        # Convergence checks\n        if criterion == 'force':\n            denom = max(abs(fext), f_ref)\n            conv = (abs(rf) / denom) = eps_f\n        elif criterion == 'disp':\n            denom = max(abs(u), u_ref)\n            conv = (abs(du) / denom) = eps_u\n        elif criterion == 'energy':\n            conv = (abs(dPi) / E_ref) = eps_E\n        else:\n            raise ValueError(\"Unknown criterion\")\n\n        # Update state\n        u = u + du\n        ep = ep_new\n        alpha = alpha_new\n        iters = k + 1\n\n        if conv:\n            # Recompute stress at updated u for reporting\n            epsilon = u / L\n            sigma, ep, alpha, Et = return_mapping_uniaxial(epsilon, ep, alpha, E, H, sigma_y0)\n            break\n\n    return u, ep, alpha, sigma, iters, last_energy_inc\n\ndef simulate_case(params, criterion, eps_f, eps_u, eps_E, u_ref, ref_energy_tol=None):\n    \"\"\"\n    Simulate full load path for a given case and criterion.\n    If ref_energy_tol is provided, a reference solution is computed with energy criterion and that tolerance.\n    Returns:\n      - results for chosen criterion across steps\n      - reference data (first plastic step index), computed with tight energy tolerance if ref_energy_tol is not None;\n        otherwise uses the chosen criterion's solution.\n    \"\"\"\n    E, H, sigma_y0, A, L, fext_max, n_steps = params\n    # Prepare load steps\n    fext_steps = [(i + 1) / n_steps * fext_max for i in range(n_steps)]\n\n    # First, compute reference (tight energy) to locate first plastic step\n    u_ref_sol = 0.0\n    ep_ref_sol = 0.0\n    alpha_ref_sol = 0.0\n    first_plastic_step = None\n    if ref_energy_tol is None:\n        # Use the chosen criterion itself to locate plasticity (less accurate)\n        ref_tol = eps_E\n    else:\n        ref_tol = ref_energy_tol\n\n    for i, fext in enumerate(fext_steps):\n        u_ref_sol, ep_ref_sol, alpha_ref_sol, sigma_ref, it_ref, dPi_ref = newton_solve_step(\n            fext, u_ref_sol, ep_ref_sol, alpha_ref_sol, E, H, sigma_y0, A, L,\n            'energy', eps_f, eps_u, ref_tol, u_ref, max_iter=200\n        )\n        # Plastic if the return mapping performed plastic correction:\n        # This can be inferred when |sigma_ref| equals current yield stress\n        yield_radius = sigma_y0 + H * alpha_ref_sol\n        if first_plastic_step is None and abs(abs(sigma_ref) - yield_radius) = 1e-9:\n            first_plastic_step = i\n\n    if first_plastic_step is None:\n        # If no plasticity occurred, set to last step\n        first_plastic_step = n_steps - 1\n\n    # Now simulate with the chosen criterion, capturing the energy-norm at the first plastic step\n    u_sol = 0.0\n    ep_sol = 0.0\n    alpha_sol = 0.0\n    energy_inc_at_first_plastic = None\n    iters_at_first_plastic = None\n\n    for i, fext in enumerate(fext_steps):\n        u_sol, ep_sol, alpha_sol, sigma_sol, iters, dPi = newton_solve_step(\n            fext, u_sol, ep_sol, alpha_sol, E, H, sigma_y0, A, L,\n            criterion, eps_f, eps_u, eps_E, u_ref, max_iter=200\n        )\n        if i == first_plastic_step:\n            energy_inc_at_first_plastic = dPi\n            iters_at_first_plastic = iters\n\n    return energy_inc_at_first_plastic, iters_at_first_plastic, first_plastic_step\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case: (E, H, sigma_y0, A, L, fext_max, n_steps, eps_f, eps_u, eps_E, u_ref)\n        (1.0e8, 2.0e7, 5.0e6, 1.0e-2, 1.0, 8.0e4, 12, 1.0e-6, 1.0e-6, 1.0e-12, 1.0e-12),\n        (1.0e8, 1.0e5, 4.0e6, 1.0e-2, 1.0, 6.0e4, 12, 1.0e-6, 1.0e-6, 1.0e-12, 1.0e-12),\n        (1.0e9, 5.0e8, 6.0e6, 5.0e-3, 1.0, 5.0e4, 12, 1.0e-6, 1.0e-6, 1.0e-12, 1.0e-12),\n    ]\n\n    # We will compute a high-accuracy reference using energy criterion with very tight tolerance\n    ref_energy_tol = 1.0e-14\n\n    results = []\n    for case in test_cases:\n        E, H, sigma_y0, A, L, fext_max, n_steps, eps_f, eps_u, eps_E, u_ref = case\n\n        params = (E, H, sigma_y0, A, L, fext_max, n_steps)\n\n        # Evaluate each criterion at the first plastic step determined by reference solution\n        energy_force, it_force, fp_idx = simulate_case(params, 'force', eps_f, eps_u, eps_E, u_ref,\n                                                       ref_energy_tol=ref_energy_tol)\n        energy_disp, it_disp, _ = simulate_case(params, 'disp', eps_f, eps_u, eps_E, u_ref,\n                                                ref_energy_tol=ref_energy_tol)\n        energy_energy, it_energy, _ = simulate_case(params, 'energy', eps_f, eps_u, eps_E, u_ref,\n                                                    ref_energy_tol=ref_energy_tol)\n\n        # Collect energies and iterations\n        energies = [energy_force, energy_disp, energy_energy]\n        iters = [it_force, it_disp, it_energy]\n\n        # Choose best criterion: smallest energy-norm |ΔΠ| at first plastic step; tie-breaker = fewer iterations\n        # Note: ensure robust handling of None (should not occur)\n        best_idx = 0\n        best_energy = energies[0]\n        best_iters = iters[0]\n        for idx in range(1, 3):\n            e = energies[idx]\n            it = iters[idx]\n            if e is None:\n                continue\n            if (e  best_energy) or (abs(e - best_energy) = 1e-20 and it  best_iters):\n                best_idx = idx\n                best_energy = e\n                best_iters = it\n\n        results.append(best_idx)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3511083"}]}