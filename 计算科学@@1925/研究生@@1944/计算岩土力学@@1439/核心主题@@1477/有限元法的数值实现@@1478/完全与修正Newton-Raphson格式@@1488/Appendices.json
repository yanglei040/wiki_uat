{"hands_on_practices": [{"introduction": "牛顿-拉夫森方法通过迭代求解一系列线性方程来解决非线性问题。该方法的关键在于在当前猜测解处对问题进行线性化，这涉及到残差（表示距离解的远近）和切线雅可比矩阵（表示残差如何随求解变量变化）。第一个练习 [@problem_id:3526509] 剥离了物理和离散化的复杂性，让您能够纯粹地专注于单次迭代的基本数学机制。掌握这一步是将该方法应用于实际工程问题的第一步。", "problem": "计算岩土力学中的一个两自由度非线性平衡问题由残差向量 $\\mathbf{r}(\\mathbf{u}) \\in \\mathbb{R}^{2}$ 来表征，其中 $\\mathbf{u} = \\begin{bmatrix} u_{1} \\\\ u_{2} \\end{bmatrix}$ 表示广义位移。平衡条件要求 $\\mathbf{r}(\\mathbf{u}) = \\mathbf{0}$，其中残差定义为\n$$\n\\mathbf{r}(\\mathbf{u}) = \\begin{bmatrix}\nu_{1}^{2} + u_{2} - 3 \\\\\n\\sin(u_{1}) + u_{2}^{3} - 1\n\\end{bmatrix}.\n$$\n在全牛顿-拉夫逊法中，切线矩阵（也称为一致雅可比矩阵或切线刚度）定义为 $ \\mathbf{K}_{t}(\\mathbf{u}) = -\\dfrac{\\partial \\mathbf{r}}{\\partial \\mathbf{u}}(\\mathbf{u})$，每次迭代求解线性化的平衡更新方程 $\\mathbf{K}_{t}(\\mathbf{u}^{(i)}) \\, \\Delta \\mathbf{u}^{(i)} = \\mathbf{r}(\\mathbf{u}^{(i)})$。相比之下，修正牛顿-拉夫逊法在迭代过程中保持切线矩阵不变，但仍更新残差，不过当从相同的初始猜测值开始时，两种方法在第一次迭代时是相同的。\n\n从初始猜测值 $\\mathbf{u}^{(0)} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ 开始，执行一次全牛顿-拉夫逊迭代：\n- 通过对 $\\mathbf{r}(\\mathbf{u})$ 进行线性化，显式地构建切线矩阵 $\\mathbf{K}_{t}(\\mathbf{u}^{(0)})$。\n- 在线性系统 $\\mathbf{K}_{t}(\\mathbf{u}^{(0)}) \\, \\Delta \\mathbf{u}^{(0)} = \\mathbf{r}(\\mathbf{u}^{(0)})$ 中求解增量 $\\Delta \\mathbf{u}^{(0)}$。\n\n使用标准数学函数，将最终答案表示为行向量 $\\Delta \\mathbf{u}^{(0)}$ 的单个解析表达式，不进行数值舍入，不带单位。", "solution": "该问题具有科学依据、良定、客观，并包含获得唯一解所需的所有信息。因此，该问题是有效的。我们通过应用一次全牛顿-拉夫逊迭代来求解。\n\n该问题定义了一个非线性方程组 $\\mathbf{r}(\\mathbf{u}) = \\mathbf{0}$，其中位移向量为 $\\mathbf{u} = \\begin{bmatrix} u_{1} \\\\ u_{2} \\end{bmatrix}$，残差向量为\n$$\n\\mathbf{r}(\\mathbf{u}) = \\begin{bmatrix} r_1(\\mathbf{u}) \\\\ r_2(\\mathbf{u}) \\end{bmatrix} = \\begin{bmatrix}\nu_{1}^{2} + u_{2} - 3 \\\\\n\\sin(u_{1}) + u_{2}^{3} - 1\n\\end{bmatrix}.\n$$\n全牛顿-拉夫逊法是求解 $\\mathbf{r}(\\mathbf{u})$ 根的迭代过程。每次迭代通过计算增量 $\\Delta \\mathbf{u}^{(i)}$ 来优化当前的猜测值 $\\mathbf{u}^{(i)}$，并按 $\\mathbf{u}^{(i+1)} = \\mathbf{u}^{(i)} + \\Delta \\mathbf{u}^{(i)}$ 更新解。增量通过求解线性系统得到\n$$\n\\mathbf{K}_{t}(\\mathbf{u}^{(i)}) \\, \\Delta \\mathbf{u}^{(i)} = -\\mathbf{r}(\\mathbf{u}^{(i)}),\n$$\n其中 $\\mathbf{K}_{t}(\\mathbf{u})$ 是残差向量 $\\mathbf{r}(\\mathbf{u})$ 的雅可比矩阵。\n\n我们被要求从初始猜测值 $\\mathbf{u}^{(0)} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ 开始执行一次迭代。\n\n首先，我们在初始猜测值 $\\mathbf{u}^{(0)}$ 处计算残差向量 $\\mathbf{r}$：\n$$\n\\mathbf{r}(\\mathbf{u}^{(0)}) = \\begin{bmatrix}\n(1)^{2} + (0) - 3 \\\\\n\\sin(1) + (0)^{3} - 1\n\\end{bmatrix} = \\begin{bmatrix}\n-2 \\\\\n\\sin(1) - 1\n\\end{bmatrix}.\n$$\n\n其次，我们通过对 $\\mathbf{r}(\\mathbf{u})$ 的分量求关于 $\\mathbf{u}$ 分量的偏导数来构建切线矩阵 $\\mathbf{K}_{t}(\\mathbf{u})$：\n$$\n\\mathbf{K}_{t}(\\mathbf{u}) = \\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{u}}(\\mathbf{u}) = \\begin{bmatrix}\n\\frac{\\partial r_1}{\\partial u_1}  \\frac{\\partial r_1}{\\partial u_2} \\\\\n\\frac{\\partial r_2}{\\partial u_1}  \\frac{\\partial r_2}{\\partial u_2}\n\\end{bmatrix}.\n$$\n各个偏导数为：\n$$\n\\frac{\\partial r_1}{\\partial u_1} = \\frac{\\partial}{\\partial u_1}(u_{1}^{2} + u_{2} - 3) = 2u_{1}\n$$\n$$\n\\frac{\\partial r_1}{\\partial u_2} = \\frac{\\partial}{\\partial u_2}(u_{1}^{2} + u_{2} - 3) = 1\n$$\n$$\n\\frac{\\partial r_2}{\\partial u_1} = \\frac{\\partial}{\\partial u_1}(\\sin(u_{1}) + u_{2}^{3} - 1) = \\cos(u_{1})\n$$\n$$\n\\frac{\\partial r_2}{\\partial u_2} = \\frac{\\partial}{\\partial u_2}(\\sin(u_{1}) + u_{2}^{3} - 1) = 3u_{2}^{2}\n$$\n因此，切线矩阵为：\n$$\n\\mathbf{K}_{t}(\\mathbf{u}) = \\begin{bmatrix}\n2u_{1}  1 \\\\\n\\cos(u_{1})  3u_{2}^{2}\n\\end{bmatrix}.\n$$\n\n第三，我们在初始猜测值 $\\mathbf{u}^{(0)} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ 处计算该切线矩阵：\n$$\n\\mathbf{K}_{t}(\\mathbf{u}^{(0)}) = \\begin{bmatrix}\n2(1)  1 \\\\\n\\cos(1)  3(0)^{2}\n\\end{bmatrix} = \\begin{bmatrix}\n2  1 \\\\\n\\cos(1)  0\n\\end{bmatrix}.\n$$\n该矩阵的行列式为 $\\det(\\mathbf{K}_{t}(\\mathbf{u}^{(0)})) = (2)(0) - (1)(\\cos(1)) = -\\cos(1)$。由于 $1$ 不是 $\\frac{\\pi}{2}$ 的奇数倍，所以 $\\cos(1) \\neq 0$，因此该矩阵是可逆的，增量存在唯一解。\n\n最后，我们求解线性系统以得到增量 $\\Delta \\mathbf{u}^{(0)} = \\begin{bmatrix} \\Delta u_{1}^{(0)} \\\\ \\Delta u_{2}^{(0)} \\end{bmatrix}$：\n$$\n\\mathbf{K}_{t}(\\mathbf{u}^{(0)}) \\, \\Delta \\mathbf{u}^{(0)} = -\\mathbf{r}(\\mathbf{u}^{(0)})\n$$\n$$\n\\begin{bmatrix}\n2  1 \\\\\n\\cos(1)  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\Delta u_{1}^{(0)} \\\\\n\\Delta u_{2}^{(0)}\n\\end{bmatrix}\n= -\\begin{bmatrix}\n-2 \\\\\n\\sin(1) - 1\n\\end{bmatrix}\n= \\begin{bmatrix}\n2 \\\\\n1 - \\sin(1)\n\\end{bmatrix}.\n$$\n该矩阵方程对应于以下二元线性方程组：\n$$\n\\begin{cases}\n2\\Delta u_{1}^{(0)} + \\Delta u_{2}^{(0)} = 2  (1) \\\\\n\\cos(1)\\Delta u_{1}^{(0)} = 1 - \\sin(1)  (2)\n\\end{cases}\n$$\n从方程 $(2)$，我们解出 $\\Delta u_{1}^{(0)}$：\n$$\n\\Delta u_{1}^{(0)} = \\frac{1 - \\sin(1)}{\\cos(1)} = \\frac{1}{\\cos(1)} - \\frac{\\sin(1)}{\\cos(1)} = \\sec(1) - \\tan(1).\n$$\n将此表达式代入方程 $(1)$，我们可以解出 $\\Delta u_{2}^{(0)}$：\n$$\n2(\\sec(1) - \\tan(1)) + \\Delta u_{2}^{(0)} = 2\n$$\n$$\n\\Delta u_{2}^{(0)} = 2 - 2(\\sec(1) - \\tan(1)) = 2(1 - \\sec(1) + \\tan(1)).\n$$\n最终的位移增量是向量 $\\Delta \\mathbf{u}^{(0)} = \\begin{bmatrix} \\sec(1) - \\tan(1) \\\\ 2(1 - \\sec(1) + \\tan(1)) \\end{bmatrix}$。题目要求答案为行向量。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\sec(1) - \\tan(1)  2(1 - \\sec(1) + \\tan(1)) \\end{pmatrix}}\n$$", "id": "3526509"}, {"introduction": "在学习了如何执行一次迭代之后，评估该方法的有效性至关重要。全牛顿-拉弗森方案的主要吸引力在于其快速的收敛性。收敛速度由一个“阶数”来表征，其中二次收敛（$p=2$）是健康的牛顿-拉弗森过程的标志。这个阶数可以直接从求解器产生的残差范数序列中估算出来。本练习 [@problem_id:3526519] 将带您从计算转向分析，为您提供一个诊断您自己数值模拟性能的工具，帮助您确认求解器是否按预期运行，或者在收敛较慢时识别潜在问题。", "problem": "一个排水三轴压缩增量通过一个服从压力相关屈服条件的弹塑性土的非线性有限元（FE）模型进行求解。离散静力平衡写为残差方程 $r(u) = f_{\\mathrm{int}}(u) - f_{\\mathrm{ext}} = 0$，其中 $u$ 是全局位移向量，$f_{\\mathrm{int}}(u)$ 是内力向量，$f_{\\mathrm{ext}}$ 是外力向量。考虑两种迭代方案：完全牛顿-拉夫逊法，其一致弹塑性切线在每次迭代中更新；以及修正牛顿-拉夫逊法，其切线矩阵在荷载步开始时冻结在其初始值。\n\n给定在某一固定荷载增量下，完全牛顿-拉夫逊迭代的残差欧几里得范数如下：\n$k=0: \\|r(u^{(0)})\\| = 1.0 \\times 10^{-1}$，\n$k=1: \\|r(u^{(1)})\\| = 1.0 \\times 10^{-2}$，\n$k=2: \\|r(u^{(2)})\\| = 1.0 \\times 10^{-4}$，\n$k=3: \\|r(u^{(3)})\\| = 1.0 \\times 10^{-8}$。\n\n从第一性原理出发，使用基于渐近模型 $\\|r(u^{(k+1)})\\| \\approx C \\|r(u^{(k)})\\|^{p}$（对于解附近的某个常数 $C>0$）的局部收敛阶 $p$ 的定义，以及残差在精确解附近的线性化，推导出一个可从连续三次迭代中计算观测阶 $p$ 的估计量。然后，使用上述完全牛顿-拉夫逊方案的数据，计算观测阶 $p$。\n\n将最终数值答案四舍五入到 $4$ 位有效数字。最终报告的值是无量纲的。在你的推理中，也请说明观测到的行为在局部收敛阶 $p$ 的意义上是与二次、超线性还是线性收敛相符，但最终答案只报告估计的 $p$ 值。", "solution": "问题要求推导局部收敛阶 $p$ 的可计算估计量，并使用完全牛顿-拉夫逊（FNR）方案给出的一组残差范数进行计算。\n\n收敛性分析通常用解向量的误差 $e^{(k)} = u^{(k)} - u^*$ 来表述，其中 $u^{(k)}$ 是第 $k$ 步的迭代值，$u^*$ 是满足 $r(u^*) = 0$ 的精确解。收敛阶 $p$ 由以下渐近关系定义：\n$$ \\|e^{(k+1)}\\| \\approx C_e \\|e^{(k)}\\|^p $$\n对于某个常数 $C_e > 0$ 且 $k \\to \\infty$。\n\n问题提供了残差向量的欧几里得范数 $\\|r(u^{(k)})\\|$ 的数据，并假设了类似的关系：\n$$ \\|r(u^{(k+1)})\\| \\approx C \\|r(u^{(k)})\\|^p $$\n为了证明该模型的合理性，我们将残差函数 $r(u)$ 在精确解 $u^*$ 附近进行线性化。使用一阶泰勒级数展开，我们得到：\n$$ r(u^{(k)}) = r(u^*) + \\left. \\frac{\\partial r}{\\partial u} \\right|_{u=u^*} (u^{(k)} - u^*) + O(\\|u^{(k)}-u^*\\|^2) $$\n在力学背景下，项 $\\frac{\\partial r}{\\partial u}$ 是 $-K_T(u)$。在解 $u^*$ 处，我们有 $r(u^*) = 0$。因此，对于一个足够接近 $u^*$ 的迭代值 $u^{(k)}$，我们可以写成：\n$$ r(u^{(k)}) \\approx -K_T(u^*) (u^{(k)} - u^*) = -K_T^* e^{(k)} $$\n假设解处的切线刚度矩阵 $K_T^*$ 是非奇异的，我们可以对两边取向量范数。这将残差的范数与误差的范数联系起来：\n$$ \\|r(u^{(k)})\\| \\approx \\|K_T^* e^{(k)}\\| \\le \\|K_T^*\\| \\|e^{(k)}\\| $$\n同样地，$\\|e^{(k)}\\| = \\|(K_T^*)^{-1} r(u^{(k)})\\| \\le \\|(K_T^*)^{-1}\\| \\|r(u^{(k)})\\|$。这证明了在解的邻域内，残差的范数与误差的范数成正比，即 $\\|r(u^{(k)})\\| \\propto \\|e^{(k)}\\|$。我们将其写为 $\\|r(u^{(k)})\\| \\approx C_r \\|e^{(k)}\\|$，其中 $C_r > 0$ 是某个常数。\n\n将这个关系代入误差向量的收敛阶定义中：\n$$ \\frac{\\|r(u^{(k+1)})\\|}{C_r} \\approx C_e \\left(\\frac{\\|r(u^{(k)})\\|}{C_r}\\right)^p $$\n$$ \\|r(u^{(k+1)})\\| \\approx (C_e C_r^{1-p}) \\|r(u^{(k)})\\|^p $$\n这证实了假设的模型 $\\|r(u^{(k+1)})\\| \\approx C \\|r(u^{(k)})\\|^p$，其中常数 $C$ 由 $C_e C_r^{1-p}$ 给出。这个从第一性原理出发的推导，使得使用残差范数序列来估计收敛阶是合理的。\n\n现在，我们推导 $p$ 的可计算估计量。令 $R_k = \\|r(u^{(k)})\\|$。根据该模型，我们得到关于连续迭代 $k$ 和 $k+1$ 的两个关系式：\n$$ R_{k+1} \\approx C R_k^p $$\n$$ R_k \\approx C R_{k-1}^p $$\n当迭代接近解时，这些关系式是有效的，因此渐近行为成立。为了消去未知常数 $C$，我们对两个方程取自然对数：\n$$ \\ln(R_{k+1}) \\approx \\ln(C) + p \\ln(R_k) $$\n$$ \\ln(R_k) \\approx \\ln(C) + p \\ln(R_{k-1}) $$\n第一个对数方程减去第二个，得到：\n$$ \\ln(R_{k+1}) - \\ln(R_k) \\approx p (\\ln(R_k) - \\ln(R_{k-1})) $$\n利用对数的性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$，我们可以写成：\n$$ \\ln\\left(\\frac{R_{k+1}}{R_k}\\right) \\approx p \\ln\\left(\\frac{R_k}{R_{k-1}}\\right) $$\n解出 $p$，我们得到从连续三次迭代 $(k-1, k, k+1)$ 计算观测收敛阶的估计量：\n$$ p \\approx \\frac{\\ln(R_{k+1} / R_k)}{\\ln(R_k / R_{k-1})} $$\n接下来，我们使用提供的完全牛顿-拉夫逊方案的数据来计算 $p$。给定的残差范数是：\n$R_0 = \\|r(u^{(0)})\\| = 1.0 \\times 10^{-1}$\n$R_1 = \\|r(u^{(1)})\\| = 1.0 \\times 10^{-2}$\n$R_2 = \\|r(u^{(2)})\\| = 1.0 \\times 10^{-4}$\n$R_3 = \\|r(u^{(3)})\\| = 1.0 \\times 10^{-8}$\n\n我们可以使用最新的三个可用迭代值（即 $k=1, 2, 3$）来计算 $p$ 的估计值。这对应于在我们推导的公式中令 $k=2$。\n$$ p \\approx \\frac{\\ln(R_3 / R_2)}{\\ln(R_2 / R_1)} $$\n首先，我们计算范数的比值：\n$$ \\frac{R_3}{R_2} = \\frac{1.0 \\times 10^{-8}}{1.0 \\times 10^{-4}} = 10^{-4} $$\n$$ \\frac{R_2}{R_1} = \\frac{1.0 \\times 10^{-4}}{1.0 \\times 10^{-2}} = 10^{-2} $$\n将这些值代入 $p$ 的估计量中：\n$$ p \\approx \\frac{\\ln(10^{-4})}{\\ln(10^{-2})} = \\frac{-4 \\ln(10)}{-2 \\ln(10)} = 2 $$\n计算得到的观测收敛阶恰好是 $p=2$。\n\n这个结果与牛顿-拉夫逊法的理论是一致的。收敛阶 $p=2$ 意味着二次收敛。对于一个非线性系统 $r(u)=0$，使用一致推导的切线矩阵 $K_T = -\\frac{\\partial r}{\\partial u}$ 的完全牛顿-拉夫逊法，在单根的邻域内预期会表现出二次收敛。所提供的弹塑性模型（一个高度非线性问题）的数据显示了这种理想行为，表明所选择的荷载增量和初始猜测值 $u^{(0)}$ 是合适的，能够落入吸引域内，并且一致切线得到了正确的实现。因此，该收敛行为被归类为二次收敛。\n\n最终答案必须报告为 $4$ 位有效数字。\n$$ p = 2.000 $$", "answer": "$$\n\\boxed{2.000}\n$$", "id": "3526519"}, {"introduction": "真实的岩土力学问题常常涉及材料软化，这可能导致应变局部化，并对数值求解器构成严峻挑战。在软化材料中，切线刚度矩阵可能变得非正定，导致材料失稳，并使标准的牛顿-拉弗森迭代失败。梯度增强模型等先进的连续介质理论可以对问题进行正则化，恢复其适定性，并使求解收敛。这个最终的、基于代码的练习 [@problem_id:3526589] 将您带到计算岩土力学的前沿。您将研究全牛顿法和修正牛顿法的一种常见失效模式，并利用正则化方法实施解决方案，从而更深刻地理解物理建模与数值稳定性之间的内在联系。", "problem": "考虑一个用于计算地质力学中应变局部化问题的一维替代模型，该模型由两个串联的子域（被视作轴向弹簧）组成，其长度分别为 $L_1$ 和 $L_2$，且 $L_1 + L_2 = L$。设 $u(x)$ 表示轴向位移，$\\varepsilon_i$ 表示子域 $i \\in \\{1,2\\}$ 中的均匀轴向应变。这两个子域在指定的端到端位移 $U$ 下串联连接，因此协调性要求 $L_1 \\varepsilon_1 + L_2 \\varepsilon_2 = U$，力平衡要求两个子域中的轴向应力相等。子域 2 是线性弹性的，其模量为 $E_2$，因此 $\\sigma_2(\\varepsilon_2) = E_2 \\varepsilon_2$。子域 1 是一种模拟易局部化带的软化材料。其应力-应变关系由一个分段多项式给出：\n- 对于 $\\varepsilon_1 \\le \\varepsilon_y$，$\\sigma_1(\\varepsilon_1) = E_1 \\varepsilon_1$。\n- 对于 $\\varepsilon_1 > \\varepsilon_y$，$\\sigma_1(\\varepsilon_1) = \\sigma_y + H_1 (\\varepsilon_1 - \\varepsilon_y) + H_3 (\\varepsilon_1 - \\varepsilon_y)^3$，其中 $\\sigma_y = E_1 \\varepsilon_y$，并且 $H_1  0$ 和 $H_3 \\ge 0$。\n\n设一维增量声学张量等同于标量算法切线模量 $A = \\partial \\sigma_1 / \\partial \\varepsilon_1$。在一维且无惯性的情况下，椭圆性的丧失由 $\\det A = A = 0$ 表示，不适定的增量响应由 $A \\le 0$ 表示。\n\n为使问题正则化，通过一个梯度项来增强子域 1 的局部本构律，该梯度项使用一个材料长度尺度来惩罚应变梯度。在子域 1 中，对于波数为 $k$ 的局部化模式的傅里叶表示，这通过切线中的一个附加稳定项来近似，即 $A_{\\text{reg}} = A + \\kappa k^2$，其中 $\\kappa$ 是梯度系数。在离散化的替代模型中，这通过一个附加项 $\\kappa k^2 \\varepsilon_1$ 进入子域 1 的平衡残差中。\n\n您需要为未知数 $\\varepsilon_1$ 和 $\\varepsilon_2$ 建立并求解包含两个方程的非线性系统：\n- 力平衡：$\\sigma_1(\\varepsilon_1) - \\sigma_2(\\varepsilon_2) + \\kappa k^2 \\varepsilon_1 = 0$，如果 $\\kappa = 0$，则不存在正则化项。\n- 协调性：$L_1 \\varepsilon_1 + L_2 \\varepsilon_2 - U = 0$。\n\n实现两种求解器：\n- 全牛顿-拉弗森法：在每次迭代中更新雅可比矩阵。\n- 修正牛顿-拉弗森法：在整个加载步中，将雅可比矩阵冻结在初始迭代步的值。\n\n在每次迭代中，更新 $\\boldsymbol{\\varepsilon}^{(m+1)} = \\boldsymbol{\\varepsilon}^{(m)} - \\mathbf{J}^{-1} \\mathbf{R}$，其中 $\\mathbf{R}$ 是残差向量，$\\mathbf{J}$ 是雅可比矩阵。对于正则化情况，子域 1 平衡方程的雅可比矩阵项除了材料切线模量 $A$ 之外，还包括稳定项 $+\\kappa k^2$。\n\n初始化必须使用弹性猜测 $\\varepsilon_1^{(0)} = \\varepsilon_2^{(0)} = U/L$，其中 $L = L_1 + L_2$。当残差向量的欧几里得范数小于容差 $\\tau = 10^{-10}$ 时，宣告收敛；如果在任何迭代中雅可比矩阵是奇异的，或迭代次数超过最大值 $M = 50$，则宣告发散。\n\n跟踪并报告在最后可用迭代步上子域 1 中非正则化和正则化形式的声学张量行列式，即 $\\det A = A$ 和 $\\det A_{\\text{reg}} = A + \\kappa k^2$。以兆帕 (MPa) 为单位报告这些值。说明每种求解器是否收敛。\n\n使用以下测试套件（每行表示一个测试用例）：\n- 用例 1（无正则化，进入软化区时雅可比矩阵奇异）：$E_1 = 20000$ MPa, $E_2 = 20000$ MPa, $\\varepsilon_y = 5.0 \\times 10^{-4}$, $H_1 = -\\dfrac{20000 \\times 0.1}{0.9} = -2222.222222222222$ MPa, $H_3 = 0$ MPa, $L_1 = 0.1$ m, $L_2 = 0.9$ m, $U = 0.004$ (无量纲), $\\kappa = 0$ MPa·m$^2$, $k = \\dfrac{\\pi}{L_1}$ rad/m。\n- 用例 2（相同软化但有正则化）：与用例 1 相同，除了 $\\kappa = 0.5$ MPa·m$^2$。\n- 用例 3（较温和的软化，无正则化）：$E_1 = 20000$ MPa, $E_2 = 20000$ MPa, $\\varepsilon_y = 5.0 \\times 10^{-4}$, $H_1 = -2000$ MPa, $H_3 = 0$ MPa, $L_1 = 0.1$ m, $L_2 = 0.9$ m, $U = 0.004$ (无量纲), $\\kappa = 0$ MPa·m$^2$, $k = \\dfrac{\\pi}{L_1}$ rad/m。\n\n角度单位必须是弧度，应变为无量纲，长度单位为米 (m)，刚度和声学张量行列式单位为兆帕 (MPa)，$\\kappa$ 的单位为 MPa·m$^2$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且其本身是一个包含以下六个条目的列表：\n- 全牛顿-拉弗森法是否收敛（布尔值），\n- 修正牛顿-拉弗森法是否收敛（布尔值），\n- 子域 1 的 $\\det A$，单位为 MPa（浮点数），\n- 子域 1 的 $\\det A_{\\text{reg}}$，单位为 MPa（浮点数），\n- 全牛顿-拉弗森法所用的迭代次数（整数），\n- 修正牛顿-拉弗森法所用的迭代次数（整数）。\n\n例如，您的输出必须具有 $[[b_1,b_2,a_1,a_2,n_1,n_2],[\\dots],[\\dots]]$ 的形式，其中布尔值、浮点数和整数替换占位符。", "solution": "该问题要求建立并实现两种牛顿-拉弗森方案（全牛顿法(FNR)和修正牛顿法(MNR)），以求解一个模拟一维双杆系统中应变局部化的非线性方程组。解决方案必须针对三个不同的测试用例进行验证，并且结果，包括收敛状态、迭代次数和最终声学张量行列式，必须以特定格式报告。\n\n该系统由两个串联的子域（弹簧）组成，长度分别为 $L_1$ 和 $L_2$，承受总伸长量 $U$。状态变量是每个子域中的应变 $\\varepsilon_1$ 和 $\\varepsilon_2$。控制方程源自力平衡和运动学协调性。\n\n设状态向量为 $\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_1 \\\\ \\varepsilon_2 \\end{pmatrix}$。问题是找到残差向量 $\\mathbf{R}(\\boldsymbol{\\varepsilon}) = \\mathbf{0}$ 的根，其中：\n$$ \\mathbf{R}(\\boldsymbol{\\varepsilon}) = \\begin{pmatrix} R_1(\\varepsilon_1, \\varepsilon_2) \\\\ R_2(\\varepsilon_1, \\varepsilon_2) \\end{pmatrix} = \\begin{pmatrix} \\sigma_1(\\varepsilon_1) + \\kappa k^2 \\varepsilon_1 - \\sigma_2(\\varepsilon_2) \\\\ L_1 \\varepsilon_1 + L_2 \\varepsilon_2 - U \\end{pmatrix} $$\n\n应力 $\\sigma_1$ 和 $\\sigma_2$ 的本构律如下：\n1.  **子域 2（线性弹性）：** $\\sigma_2(\\varepsilon_2) = E_2 \\varepsilon_2$。\n2.  **子域 1（软化）：** 一个依赖于屈服应变 $\\varepsilon_y$ 的分段定律。其中 $\\sigma_y = E_1 \\varepsilon_y$：\n$$ \\sigma_1(\\varepsilon_1) = \\begin{cases} E_1 \\varepsilon_1  \\text{if } \\varepsilon_1 \\le \\varepsilon_y \\\\ \\sigma_y + H_1 (\\varepsilon_1 - \\varepsilon_y) + H_3 (\\varepsilon_1 - \\varepsilon_y)^3  \\text{if } \\varepsilon_1 > \\varepsilon_y \\end{cases} $$\n平衡残差 $R_1$ 中的项 $\\kappa k^2 \\varepsilon_1$ 代表基于梯度的正则化，当系数 $\\kappa > 0$ 时生效。\n\n牛顿-拉弗森法通过迭代求解。从初始猜测 $\\boldsymbol{\\varepsilon}^{(0)}$ 开始，通过求解线性系统 $\\mathbf{J}(\\boldsymbol{\\varepsilon}^{(m)}) \\Delta \\boldsymbol{\\varepsilon}^{(m)} = -\\mathbf{R}(\\boldsymbol{\\varepsilon}^{(m)})$ 来找到后续的迭代值，以获得更新量 $\\Delta \\boldsymbol{\\varepsilon}^{(m)} = \\boldsymbol{\\varepsilon}^{(m+1)} - \\boldsymbol{\\varepsilon}^{(m)}$。这里，$\\mathbf{J}$ 是残差向量的雅可比矩阵。\n\n雅可比矩阵 $\\mathbf{J} = \\frac{\\partial \\mathbf{R}}{\\partial \\boldsymbol{\\varepsilon}}$ 是一个 $2 \\times 2$ 矩阵，其分量为：\n*   $J_{11} = \\frac{\\partial R_1}{\\partial \\varepsilon_1} = \\frac{\\partial \\sigma_1}{\\partial \\varepsilon_1} + \\kappa k^2 = A(\\varepsilon_1) + \\kappa k^2$\n*   $J_{12} = \\frac{\\partial R_1}{\\partial \\varepsilon_2} = -\\frac{\\partial \\sigma_2}{\\partial \\varepsilon_2} = -E_2$\n*   $J_{21} = \\frac{\\partial R_2}{\\partial \\varepsilon_1} = L_1$\n*   $J_{22} = \\frac{\\partial R_2}{\\partial \\varepsilon_2} = L_2$\n\n这里，$A(\\varepsilon_1) = \\frac{\\partial \\sigma_1}{\\partial \\varepsilon_1}$ 是子域 1 的算法切线模量，在这个一维问题中充当非正则化的声学张量行列式。其形式由应力-应变定律导出：\n$$ A(\\varepsilon_1) = \\begin{cases} E_1  \\text{if } \\varepsilon_1 \\le \\varepsilon_y \\\\ H_1 + 3 H_3 (\\varepsilon_1 - \\varepsilon_y)^2  \\text{if } \\varepsilon_1 > \\varepsilon_y \\end{cases} $$\n完整的雅可比矩阵是：\n$$ \\mathbf{J}(\\varepsilon_1) = \\begin{pmatrix} A(\\varepsilon_1) + \\kappa k^2  -E_2 \\\\ L_1  L_2 \\end{pmatrix} $$\n\n所要求的两种求解器通过它们处理雅可比矩阵的方式来区分：\n*   **全牛顿-拉弗森法 (FNR)：** 在每次迭代 $m$ 中重新计算雅可比矩阵 $\\mathbf{J}(\\varepsilon_1^{(m)})$。\n*   **修正牛顿-拉弗森法 (MNR)：** 仅使用初始猜测值计算一次雅可比矩阵 $\\mathbf{J}(\\varepsilon_1^{(0)})$，然后在所有后续迭代中“冻结”该矩阵。\n\n每个测试用例和求解器的算法如下：\n1.  初始化参数并计算派生常数 ($L=L_1+L_2$, $\\sigma_y=E_1\\varepsilon_y$, $k=\\pi/L_1$)。\n2.  设置应变向量的初始猜测值：$\\boldsymbol{\\varepsilon}^{(0)} = [U/L, U/L]^T$。\n3.  初始化迭代计数器 $m=0$。\n4.  对于 MNR，计算并存储初始雅可比矩阵 $\\mathbf{J}^{(0)} = \\mathbf{J}(\\varepsilon_1^{(0)})$。如果 $\\det(\\mathbf{J}^{(0)})$ 接近于零，则宣告发散。\n5.  开始迭代循环，如果迭代次数 $m$ 超过最大值 $M=50$，则终止。\n6.  在循环内部，计算残差向量 $\\mathbf{R}^{(m)} = \\mathbf{R}(\\boldsymbol{\\varepsilon}^{(m)})$。\n7.  通过测试欧几里得范数 $||\\mathbf{R}^{(m)}||_2$ 是否低于容差 $\\tau=10^{-10}$ 来检查收敛性。如果满足，则找到解。\n8.  对于 FNR，计算当前雅可比矩阵 $\\mathbf{J}^{(m)} = \\mathbf{J}(\\varepsilon_1^{(m)})$。如果 $\\det(\\mathbf{J}^{(m)})$ 接近于零，则宣告发散。\n9.  求解线性系统 $\\mathbf{J} \\Delta\\boldsymbol{\\varepsilon}^{(m)} = -\\mathbf{R}^{(m)}$ 以获得应变增量 $\\Delta\\boldsymbol{\\varepsilon}^{(m)}$。\n10. 更新应变向量：$\\boldsymbol{\\varepsilon}^{(m+1)} = \\boldsymbol{\\varepsilon}^{(m)} + \\Delta\\boldsymbol{\\varepsilon}^{(m)}$。\n11. 增加迭代计数器 $m$。\n12. 循环终止后（由于收敛或发散），报告收敛状态、最终迭代次数，以及在最后可用应变迭代值 $\\varepsilon_1$ 处的非正则化声学张量 $A(\\varepsilon_1)$ 和正则化声学张量 $A_{\\text{reg}} = A(\\varepsilon_1) + \\kappa k^2$ 的值。由于输出格式要求每个测试用例只报告一个 $A$ 和 $A_{\\text{reg}}$ 值，优先使用 FNR 求解器的结果。如果 FNR 未能收敛，则使用 MNR 求解器的结果。如果两者都失败，则使用 FNR 的最终状态进行报告。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a 1D strain localization problem using Full and Modified Newton-Raphson methods.\n    \"\"\"\n    \n    # Define solver parameters\n    TOL = 1e-10\n    MAX_ITER = 50\n    JAC_TOL = 1e-12\n\n    # Define test cases as a list of dictionaries for clarity\n    test_cases = [\n        {\n            # Case 1: No regularization, singular Jacobian at softening onset\n            \"E1\": 20000.0, \"E2\": 20000.0, \"eps_y\": 5.0e-4,\n            \"H1\": -20000.0 * 0.1 / 0.9, \"H3\": 0.0,\n            \"L1\": 0.1, \"L2\": 0.9, \"U\": 0.004,\n            \"kappa\": 0.0\n        },\n        {\n            # Case 2: Same as Case 1 but regularized, preventing singularity\n            \"E1\": 20000.0, \"E2\": 20000.0, \"eps_y\": 5.0e-4,\n            \"H1\": -20000.0 * 0.1 / 0.9, \"H3\": 0.0,\n            \"L1\": 0.1, \"L2\": 0.9, \"U\": 0.004,\n            \"kappa\": 0.5\n        },\n        {\n            # Case 3: Milder softening, non-singular Jacobian without regularization\n            \"E1\": 20000.0, \"E2\": 20000.0, \"eps_y\": 5.0e-4,\n            \"H1\": -2000.0, \"H3\": 0.0,\n            \"L1\": 0.1, \"L2\": 0.9, \"U\": 0.004,\n            \"kappa\": 0.0\n        }\n    ]\n\n    def run_newton_solver(params, solver_type):\n        \"\"\"\n        A unified Newton-Raphson solver for the 2x2 system.\n\n        Args:\n            params (dict): Dictionary of material and geometric parameters.\n            solver_type (str): 'full' for Full Newton-Raphson, 'modified' for Modified NR.\n\n        Returns:\n            tuple: (converged, num_iter, A_final, A_reg_final)\n        \"\"\"\n        # Unpack parameters\n        E1, E2 = params[\"E1\"], params[\"E2\"]\n        eps_y, H1, H3 = params[\"eps_y\"], params[\"H1\"], params[\"H3\"]\n        L1, L2, U, kappa = params[\"L1\"], params[\"L2\"], params[\"U\"], params[\"kappa\"]\n        \n        # Derived constants\n        L = L1 + L2\n        sigma_y = E1 * eps_y\n        k = np.pi / L1\n\n        def get_sigma1_and_A(eps1):\n            if eps1 = eps_y:\n                sigma1 = E1 * eps1\n                A = E1\n            else:\n                delta_eps = eps1 - eps_y\n                sigma1 = sigma_y + H1 * delta_eps + H3 * delta_eps**3\n                A = H1 + 3 * H3 * delta_eps**2\n            return sigma1, A\n\n        def get_residual(eps_vec):\n            eps1, eps2 = eps_vec\n            sigma1, _ = get_sigma1_and_A(eps1)\n            sigma2 = E2 * eps2\n            R1 = sigma1 - sigma2 + kappa * k**2 * eps1\n            R2 = L1 * eps1 + L2 * eps2 - U\n            return np.array([R1, R2])\n\n        def get_jacobian(eps1):\n            _, A = get_sigma1_and_A(eps1)\n            J00 = A + kappa * k**2\n            J01 = -E2\n            J10 = L1\n            J11 = L2\n            return np.array([[J00, J01], [J10, J11]])\n\n        # Initialization\n        eps = np.array([U / L, U / L])\n        num_iter = 0\n        converged = False\n        \n        # For Modified NR, compute Jacobian once\n        if solver_type == 'modified':\n            J = get_jacobian(eps[0])\n            if abs(np.linalg.det(J))  JAC_TOL:\n                # Divergence due to initial singular Jacobian\n                _, A_final = get_sigma1_and_A(eps[0])\n                A_reg_final = A_final + kappa * k**2\n                return False, 0, A_final, A_reg_final\n\n        # Iteration loop\n        while num_iter  MAX_ITER:\n            R = get_residual(eps)\n            if np.linalg.norm(R)  TOL:\n                converged = True\n                break\n            \n            # For Full NR, recompute Jacobian\n            if solver_type == 'full':\n                J = get_jacobian(eps[0])\n                if abs(np.linalg.det(J))  JAC_TOL:\n                    break  # Divergence due to singular Jacobian\n\n            # Solve for increment and update\n            try:\n                delta_eps = np.linalg.solve(J, -R)\n            except np.linalg.LinAlgError:\n                break # Divergence due to singular matrix from np.linalg.solve\n                \n            eps += delta_eps\n            num_iter += 1\n\n        # Report values at final available iterate\n        _, A_final = get_sigma1_and_A(eps[0])\n        A_reg_final = A_final + kappa * k**2\n\n        return converged, num_iter, A_final, A_reg_final\n\n    all_results = []\n    for case_params in test_cases:\n        fnr_conv, fnr_iter, fnr_A, fnr_A_reg = run_newton_solver(case_params, 'full')\n        mnr_conv, mnr_iter, mnr_A, mnr_A_reg = run_newton_solver(case_params, 'modified')\n\n        # Select the acoustic tensor values based on a convergence priority rule\n        if fnr_conv:\n            final_A = fnr_A\n            final_A_reg = fnr_A_reg\n        elif mnr_conv:\n            final_A = mnr_A\n            final_A_reg = mnr_A_reg\n        else: # Both diverged, use FNR's final state for consistency\n            final_A = fnr_A\n            final_A_reg = fnr_A_reg\n            \n        case_result = [\n            fnr_conv, mnr_conv, \n            float(final_A), float(final_A_reg),\n            int(fnr_iter), int(mnr_iter)\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string exactly as required\n    result_str_list = []\n    for res in all_results:\n        # Manually construct string to control boolean format and spacing\n        s = f\"[{str(res[0]).lower()},{str(res[1]).lower()},{res[2]},{res[3]},{res[4]},{res[5]}]\"\n        result_str_list.append(s)\n    \n    final_output = f\"[{','.join(result_str_list)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3526589"}]}