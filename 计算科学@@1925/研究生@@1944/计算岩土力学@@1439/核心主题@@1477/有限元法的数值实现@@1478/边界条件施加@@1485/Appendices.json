{"hands_on_practices": [{"introduction": "在有限元分析中，正确施加本质边界条件（如固定位移）至关重要。此练习将指导您在一个简单的一维弹性杆模型中，通过罚函数法这种经典而直观的弱形式方法来施加 Dirichlet 边界条件。通过亲手实现并分析罚参数对计算精度的影响，您将深刻理解该方法的原理与实际应用中的关键权衡 [@problem_id:3504185]。", "problem": "一根一维线性弹性杆占据区间 $[0,L]$，其横截面积 $A$ 和杨氏模量 $E$ 均为常数。未知的轴向位移场为 $u(x)$。对于无体力杆，其平衡强形式为 $ \\dfrac{d}{dx}\\left(EA \\dfrac{du}{dx}\\right)=0 $（$x\\in(0,L)$），在 $x=0$ 处指定狄利克雷边界条件 $u(0)=\\bar u$，在 $x=L$ 处指定诺伊曼边界条件 $EA\\,u'(L)=\\bar N$。从虚功原理 (PVW) 和使用线性形函数的基本有限元插值出发，推导其弱形式。该弱形式应通过罚函数法引入狄利克雷边界条件，并以其自然形式包含诺伊曼边界条件。请仔细论证罚参数随网格尺寸的缩放关系。\n\n实现一个程序，该程序在 $[0,L]$ 上的 $N$ 个线性单元组成的均匀网格上组装全局刚度矩阵和荷载向量，通过罚参数为 $\\beta$ 的罚项施加 $u(0)=\\bar u$，将 $x=L$ 处的牵引力作为自然边界项施加，并求解最终的线性系统以获得节点位移。对于罚参数，使用与网格相关的缩放 $\\beta=\\alpha\\,EA/h$，其中 $h=L/N$，$\\alpha>0$ 是一个无量纲调节参数。对于每个测试用例，计算以米为单位的绝对边界位移误差 $e_0=\\lvert u_h(0)-\\bar u\\rvert$，其中 $u_h(0)$ 是 $x=0$ 处的有限元近似解。\n\n使用以下在计算地质力学中常见的、物理和数值上均符合实际的参数：$E=50\\times 10^6$ 帕斯卡，$A=1.0$ 平方米，$L=10.0$ 米，$\\bar N=1.0\\times 10^5$ 牛顿，以及 $\\bar u=0.0$ 米。这些数值对应于一根承受中等轴向端部荷载的刚性地质材料杆。在这些边界条件下，其精确解析解为 $u(x)=\\dfrac{\\bar N}{EA}\\,x$，该解满足 $u(0)=0$ 和 $EA\\,u'(L)=\\bar N$。\n\n程序必须评估以下 $(\\alpha,N)$ 对的测试套件，以评估罚值大小和网格细化效应：\n- $(\\alpha,N)=\\left(10^{-2},5\\right)$,\n- $(\\alpha,N)=\\left(10^{-2},20\\right)$,\n- $(\\alpha,N)=\\left(10^{-2},80\\right)$,\n- $(\\alpha,N)=\\left(10^{0},5\\right)$,\n- $(\\alpha,N)=\\left(10^{0},20\\right)$,\n- $(\\alpha,N)=\\left(10^{0},80\\right)$,\n- $(\\alpha,N)=\\left(10^{2},5\\right)$,\n- $(\\alpha,N)=\\left(10^{2},20\\right)$,\n- $(\\alpha,N)=\\left(10^{2},80\\right)$.\n\n对于每个测试用例，计算并返回单个标量 $e_0$（以米为单位）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_9]$）。所有位移误差必须以米（m）为单位，作为浮点数出现在此单行输出上，并遵循测试套件指定的顺序。", "solution": "问题陈述完整、科学上合理且适定。它提出了一个一维计算固体力学中的标准问题，要求推导并实现有限元方法，以求解具有混合边界条件的线性弹性杆。所给的物理参数和数值方法均为标准方法，且适用于计算地质力学领域。因此，我们可以着手求解。\n\n求解从虚功原理 (PVW) 开始，该原理提供了平衡问题的基于积分的弱形式。对于一根无体力的一维杆，虚功原理指出，对于任何运动学上容许的虚位移场 $\\delta u(x)$，内虚功必须等于外虚功。\n\n内虚功是虚应变能密度在整个域上的积分：\n$$ \\delta W_{int} = \\int_{0}^{L} \\sigma(x) \\delta\\epsilon(x) A \\,dx $$\n此处，$\\sigma(x)$ 是轴向应力，$\\delta\\epsilon(x)$ 是虚轴向应变，$A$ 是恒定的横截面积。域为区间 $[0, L]$。\n\n外虚功是外力通过虚位移所做的功。在此问题中，唯一的外力是施加在 $x=L$ 处的点荷载 $\\bar N$。因此，外虚功为：\n$$ \\delta W_{ext} = \\bar N \\delta u(L) $$\n\n线性弹性的本构关系为 $\\sigma(x) = E \\epsilon(x)$，其中 $E$ 是杨氏模量。应变-位移运动学关系为 $\\epsilon(x) = \\dfrac{du}{dx}$。虚应变与虚位移的关系类似：$\\delta\\epsilon(x) = \\dfrac{d(\\delta u)}{dx}$。\n\n将这些关系代入虚功原理表达式（$\\delta W_{int} = \\delta W_{ext}$），得到平衡方程的弱形式：\n求 $u(x)$，使得 $u(0)=\\bar u$，并且对于所有容许的虚位移 $\\delta u(x)$（在经典的伽辽金公式中，$\\delta u(0) = 0$）：\n$$ \\int_{0}^{L} EA \\dfrac{du}{dx} \\dfrac{d(\\delta u)}{dx} \\,dx = \\bar N \\delta u(L) $$\n该方程是我们有限元公式的基础。诺伊曼边界条件 $EA u'(L) = \\bar N$ 作为右侧的一个功项被自然地包含在弱形式中，因此被称为自然边界条件。狄利克雷边界条件 $u(0)=\\bar u$ 是一个本质边界条件，必须单独施加。\n\n为数值求解此问题，我们采用有限元法。将域 $[0,L]$ 离散为 $N$ 个等长度 $h = L/N$ 的线性单元。总节点数为 $n_{nodes} = N+1$。在每个从全局坐标 $x_i$ 延伸到 $x_{i+1}$ 的单元 $e$ 内，位移场 $u^{(e)}(x)$ 通过线性形函数 $N_i(x)$ 和节点位移 $d_i$ 进行近似：\n$$ u^{(e)}(x) = N_i(x) d_i + N_{i+1}(x) d_{i+1} $$\n同样，虚位移近似为：\n$$ \\delta u^{(e)}(x) = N_i(x) \\delta d_i + N_{i+1}(x) \\delta d_{i+1} $$\n单元内的应变通过对位移近似求导得到：\n$$ \\dfrac{du^{(e)}}{dx} = \\dfrac{dN_i}{dx} d_i + \\dfrac{dN_{i+1}}{dx} d_{i+1} = \\dfrac{1}{h} \\begin{bmatrix} -1  1 \\end{bmatrix} \\begin{Bmatrix} d_i \\\\ d_{i+1} \\end{Bmatrix} = \\mathbf{B}^{(e)} \\mathbf{d}^{(e)} $$\n此处，$\\mathbf{B}^{(e)}$ 是单元的应变-位移矩阵。\n\n弱形式的积分计算为所有单元的总和。对于单个单元 $e$，其对内虚功的贡献为：\n$$ (\\delta\\mathbf{d}^{(e)})^T \\left( \\int_{x_i}^{x_{i+1}} (\\mathbf{B}^{(e)})^T EA \\mathbf{B}^{(e)} \\,dx \\right) \\mathbf{d}^{(e)} = (\\delta\\mathbf{d}^{(e)})^T \\mathbf{k}^{(e)} \\mathbf{d}^{(e)} $$\n项 $\\mathbf{k}^{(e)}$ 是单元刚度矩阵。由于 $\\mathbf{B}^{(e)}$、$E$ 和 $A$ 在单元内是常数，积分很简单：\n$$ \\mathbf{k}^{(e)} = \\int_{0}^{h} \\left(\\dfrac{EA}{h^2} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\\right) dx' = \\dfrac{EA}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n单元刚度矩阵被组装成一个全局的 $(N+1) \\times (N+1)$ 刚度矩阵 $\\mathbf{K}$。在施加边界条件之前，全局方程组为 $\\mathbf{K}\\mathbf{d} = \\mathbf{F}$，其中 $\\mathbf{d}$ 是全局节点位移向量，$\\mathbf{F}$ 是全局力向量。在 $x=L$（节点 $N$）处的自然边界条件为 $\\mathbf{F}$ 的第 $N$ 个分量贡献了 $\\bar N$。\n\n狄利克雷条件 $u(0)=\\bar u$（即 $d_0=\\bar u$）通过罚函数法施加。该方法通过增加一个罚项来修改系统的总势能 $\\Pi$：\n$$ \\Pi_{pen} = \\Pi + \\dfrac{1}{2} \\beta (u(0) - \\bar u)^2 = \\dfrac{1}{2} \\int_{0}^{L} EA \\left(\\dfrac{du}{dx}\\right)^2 dx - \\bar N u(L) + \\dfrac{1}{2} \\beta (u(0) - \\bar u)^2 $$\n其中 $\\beta \\gg 0$ 是罚参数。对 $\\Pi_{pen}$ 取变分并令其为零（$\\delta \\Pi_{pen}=0$），得到修正后的弱形式：\n$$ \\int_{0}^{L} EA \\dfrac{du}{dx} \\dfrac{d(\\delta u)}{dx} \\,dx + \\beta (u(0)-\\bar u)\\delta u(0) = \\bar N \\delta u(L) $$\n在离散系统中，此修正影响节点0的方程：\n$$ (\\mathbf{K}\\mathbf{d})_0 + \\beta (d_0 - \\bar u) = F_0 $$\n这是通过将 $\\beta$ 加到对角刚度项 $K_{0,0}$ 上，并将 $\\beta \\bar u$ 加到力项 $F_0$ 上来实现的。修正后的方程组 $\\mathbf{K}_{pen}\\mathbf{d} = \\mathbf{F}_{pen}$ 为：\n$$ K_{0,0} \\rightarrow K_{0,0} + \\beta $$\n$$ F_0 \\rightarrow F_0 + \\beta \\bar u $$\n问题指定了罚参数的缩放关系为 $\\beta = \\alpha \\dfrac{EA}{h}$。节点0的物理刚度主要由第一个单元贡献，$K_{0,0} = \\dfrac{EA}{h}$。修正后的刚度项变为 $K'_{0,0} = \\dfrac{EA}{h} + \\alpha \\dfrac{EA}{h} = (1+\\alpha)\\dfrac{EA}{h}$。这种缩放确保了罚刚度与物理刚度之比由无量纲参数 $\\alpha$ 给出。这使得罚的强度的选择与网格尺寸 $h$ 无关。为使该方法有效，$\\alpha$ 应足够大（例如 $\\alpha \\gg 1$）以精确施加约束，但又不能大到导致矩阵 $\\mathbf{K}_{pen}$ 出现数值病态。\n\n待实现的算法如下：\n1.  对于每个测试用例 $(\\alpha, N)$，定义网格参数：$h=L/N$ 和 $n_{nodes}=N+1$。\n2.  计算罚参数 $\\beta = \\alpha\\,EA/h$。\n3.  初始化大小为 $(N+1) \\times (N+1)$ 的全局刚度矩阵 $\\mathbf{K}$ 和大小为 $(N+1)$ 的全局力向量 $\\mathbf{F}$ 为零。\n4.  计算单元刚度矩阵 $\\mathbf{k}^{(e)} = \\dfrac{EA}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$。\n5.  通过遍历所有 $N$ 个单元并将其贡献添加到全局矩阵中来组装 $\\mathbf{K}$。\n6.  通过设置力向量的最后一个分量 $F_N = \\bar N$ 来施加自然边界条件。\n7.  通过修改系统的第一行/列来施加罚函数狄利克雷边界条件：$K_{0,0} \\leftarrow K_{0,0} + \\beta$ 和 $F_0 \\leftarrow F_0 + \\beta\\bar u$。\n8.  求解线性系统 $\\mathbf{K}\\mathbf{d} = \\mathbf{F}$ 以获得节点位移向量 $\\mathbf{d}$。\n9.  计算边界位移误差 $e_0 = |d_0 - \\bar u|$。由于 $\\bar u=0.0$，这简化为 $e_0 = |d_0|$。\n10. 存储结果并对所有测试用例重复此过程。\n\n让我们指定用于计算的参数：\n- 杨氏模量：$E = 50 \\times 10^6$ Pa\n- 横截面积：$A = 1.0$ m$^2$\n- 杆长：$L = 10.0$ m\n- 指定位移：$\\bar u = 0.0$ m\n- 指定力：$\\bar N = 1.0 \\times 10^5$ N\n- 测试套件：$(\\alpha, N)$ 对为 $\\left(10^{-2},5\\right)$、$\\left(10^{-2},20\\right)$、$\\left(10^{-2},80\\right)$、$\\left(10^{0},5\\right)$、$\\left(10^{0},20\\right)$、$\\left(10^{0},80\\right)$、$\\left(10^{2},5\\right)$、$\\left(10^{2},20\\right)$ 和 $\\left(10^{2},80\\right)$。\n计算将为误差 $e_0$ 产生九个值，这些值将以指定的格式报告。精确位移的解析解 $u(x) = \\dfrac{\\bar N}{EA}x$ 证实了 $u(0)=0$，因此 $u_h(0)$ 的任何非零值都是由罚函数法的近似误差引起的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No scipy needed, numpy.linalg.solve is sufficient.\n\ndef solve():\n    \"\"\"\n    Solves the 1D elastic bar problem using the Finite Element Method \n    with penalty imposition of Dirichlet boundary conditions.\n    \"\"\"\n\n    # Define physical and material parameters from the problem statement\n    E = 50.0e6  # Young's modulus in Pascals (Pa)\n    A = 1.0     # Cross-sectional area in square meters (m^2)\n    L = 10.0    # Length of the bar in meters (m)\n    N_bar = 1.0e5 # Applied axial force at x=L in Newtons (N)\n    u_bar = 0.0   # Prescribed displacement at x=0 in meters (m)\n\n    # Define the test suite of (alpha, N) pairs\n    test_cases = [\n        (1e-2, 5),\n        (1e-2, 20),\n        (1e-2, 80),\n        (1e0, 5),\n        (1e0, 20),\n        (1e0, 80),\n        (1e2, 5),\n        (1e2, 20),\n        (1e2, 80),\n    ]\n\n    results = []\n    for alpha, N in test_cases:\n        # 1. Preprocessing and Mesh Definition\n        h = L / N                  # Element length\n        num_nodes = N + 1          # Number of nodes\n        \n        # 2. Calculate Penalty Parameter\n        # As per the problem, beta = alpha * E * A / h\n        beta = alpha * E * A / h\n\n        # 3. Element Stiffness Matrix Calculation\n        # For a 1D linear bar element, k_e = (EA/h) * [[1, -1], [-1, 1]]\n        elem_stiffness = (E * A / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # 4. Assembly of Global Stiffness Matrix and Force Vector\n        # Initialize global matrix and vector with zeros\n        K = np.zeros((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # Assemble the stiffness matrix by looping through elements\n        for i in range(N):\n            # Global indices for the element connecting nodes i and i+1\n            g_indices = [i, i + 1]\n            # Add element stiffness contribution to the global matrix\n            K[np.ix_(g_indices, g_indices)] += elem_stiffness\n\n        # 5. Application of Boundary Conditions\n        # a) Natural Boundary Condition (Neumann)\n        # Add the point load N_bar to the last node's force component.\n        F[N] += N_bar\n\n        # b) Essential Boundary Condition (Dirichlet) via Penalty Method\n        # Modify the stiffness and force for the constrained DOF (node 0)\n        # K_00 = K_00 + beta\n        K[0, 0] += beta\n        # F_0 = F_0 + beta * u_bar\n        F[0] += beta * u_bar\n\n        # 6. Solve the Linear System\n        # Solve Kd = F for the nodal displacement vector d\n        d = np.linalg.solve(K, F)\n\n        # 7. Post-processing: Calculate Error\n        # The FEA displacement at x=0 is the first component of the solution vector.\n        u_h_at_0 = d[0]\n        # Calculate the absolute boundary displacement error.\n        e0 = abs(u_h_at_0 - u_bar)\n\n        results.append(e0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3504185"}, {"introduction": "除了位移约束，在岩土力学问题中，施加外力（如地表荷载或水压力）同样普遍，这对应于自然边界条件。本实践将引导您为一个二维平面应变单元组装 Neumann 边界载荷向量，并引入“补丁测试”（patch test）这一基本验证工具 [@problem_id:3504177]。通过比较集总式与一致性载荷向量的效果，您将学会如何验证有限元程序是否能准确再现基本的恒定应力状态。", "problem": "要求您从第一性原理出发，为平面应变线性弹性中的单个等参双线性四边形单元（记为 $\\text{Q4}$）边界上的均匀牵引力实现边界牵引（诺伊曼）载荷向量的组装，并比较所谓的一致与集总边界牵引向量在虚功原理意义上再现常应力斑块检验的能力。\n\n您的推导应仅基于以下基本且被广泛接受的事实：\n- 小应变线性弹性运动学和本构律：工程应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$ 通过 $\\varepsilon_{xx} = \\partial u / \\partial x$、$\\varepsilon_{yy} = \\partial v / \\partial y$ 和 $\\gamma_{xy} = \\partial u / \\partial y + \\partial v / \\partial x$ 与位移场 $\\boldsymbol{u} = [u, v]^{\\mathsf{T}}$ 相关联，而柯西应力向量 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^{\\mathsf{T}}$ 通过一个对称正定四阶张量与 $\\boldsymbol{\\varepsilon}$ 相关联（对于平面应变中的各向同性材料，这简化为使用 Lamé 参数的著名矩阵）。\n- 标准的伽辽金有限元法（Finite Element Method (FEM)），采用等参双线性四边形形函数，用于刚度积分的精确 $2 \\times 2$ 高斯求积，以及用于阶数至多为线性的直边线积分的精确 $2$ 点高斯求积。\n- 虚功原理：对于任何容许的虚位移场，内虚功与外虚功平衡，这在离散情况下意味着，对于一个产生常应力状态且可被精确表示的线性位移场，如果一致地计算诺伊曼载荷向量 $\\boldsymbol{f}_{\\mathrm{N}}$，则全局内部节点力向量 $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{K}\\boldsymbol{u}$ 应与其匹配。\n\n构建以下数值实验：\n- 考虑一个占据 $\\Omega = [0, L_x] \\times [0, L_y]$ 的单个矩形单元，其单位厚度 $t = 1$。使用平面应变各向同性线性弹性，杨氏模量为 $E$（单位：帕斯卡），泊松比为 $\\nu$（无量纲）。单元节点从左下角开始按逆时针顺序排列，单元的边是矩形的四个直边。\n- 选择一个目标常柯西应力向量 $\\boldsymbol{\\sigma}_0 = [\\sigma_{xx}^0, \\sigma_{yy}^0, \\sigma_{xy}^0]^{\\mathsf{T}}$（单位：帕斯卡），并通过对平面应变本构矩阵求逆来计算相应的常工程应变向量 $\\boldsymbol{\\varepsilon}_0$。根据 $\\boldsymbol{\\varepsilon}_0$，定义精确的线性位移场：\n  $\n  u(x,y) = \\varepsilon_{xx}^0 x + \\tfrac{1}{2}\\gamma_{xy}^0 y, \\quad\n  v(x,y) = \\tfrac{1}{2}\\gamma_{xy}^0 x + \\varepsilon_{yy}^0 y,\n  $\n  其刚体分量为零。通过在单元节点坐标处对 $\\boldsymbol{u}(x,y)$ 进行采样，评估节点位移向量 $\\boldsymbol{u}$。\n- 使用精确的 $2 \\times 2$ 高斯求积和标准的 $\\text{Q4}$ 应变-位移矩阵 $\\boldsymbol{B}(\\xi,\\eta)$ 组装单元刚度矩阵 $\\boldsymbol{K}_e$；然后组装全局刚度 $\\boldsymbol{K}$（此处，它与 $\\boldsymbol{K}_e$ 一致）。\n- 对于边界牵引场 $\\boldsymbol{t} = \\boldsymbol{\\sigma}_0 \\boldsymbol{n}$（其中 $\\boldsymbol{n}$ 是外法线单位向量），在整个边界 $\\partial\\Omega$ 上组装全局诺伊曼牵引载荷向量的两个版本：\n  1. 一致版本 $\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$，通过在每个直边上使用两点高斯求积，并利用限制在每条边上的单元形函数，对 $\\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t}$ 进行精确线积分计算。\n  2. 集总版本 $\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$，首先在每个边界边 $\\Gamma_e$ 上积分总边力 $\\int_{\\Gamma_e} \\boldsymbol{t}\\, \\mathrm{d}s$，然后将其平均分配给两个边节点（边上的每个节点精确地获得总边力的一半）。\n- 不求解任何平衡系统，评估内部力向量 $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{K}\\boldsymbol{u}$ 和残差：\n  $\n  \\boldsymbol{r}_{\\mathrm{cons}} = \\boldsymbol{K}\\boldsymbol{u} - \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}, \\quad\n  \\boldsymbol{r}_{\\mathrm{lump}} = \\boldsymbol{K}\\boldsymbol{u} - \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}.\n  $\n  报告相对欧几里得范数：\n  $\n  e_{\\mathrm{cons}} = \\dfrac{\\|\\boldsymbol{r}_{\\mathrm{cons}}\\|_2}{\\|\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}\\|_2}, \\quad\n  e_{\\mathrm{lump}} = \\dfrac{\\|\\boldsymbol{r}_{\\mathrm{lump}}\\|_2}{\\|\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}\\|_2}.\n  $\n  这些是无量纲数。接近机器精度的 $e_{\\mathrm{cons}}$ 值表示通过了常应力斑块检验，而 $e_{\\mathrm{lump}}$ 则量化了由集总引入的误差。\n\n为以下参数集的测试套件实现上述过程，所有测试均在平面应变和单位厚度下进行：\n- 测试 1：$E = 1000$，$\\nu = 0.25$，$L_x = 2.0$，$L_y = 1.0$，$\\boldsymbol{\\sigma}_0 = [5.0, 0.0, 0.0]^{\\mathsf{T}}$。\n- 测试 2：$E = 1000$，$\\nu = 0.25$，$L_x = 1.5$，$L_y = 0.8$，$\\boldsymbol{\\sigma}_0 = [0.0, 0.0, 4.0]^{\\mathsf{T}}$。\n- 测试 3：$E = 1000$，$\\nu = 0.25$，$L_x = 3.0$，$L_y = 0.5$，$\\boldsymbol{\\sigma}_0 = [2.0, -1.0, 3.0]^{\\mathsf{T}}$。\n\n所有模量单位为帕斯卡，所有长度单位为米。输出 $e_{\\mathrm{cons}}$ 和 $e_{\\mathrm{lump}}$ 是无量纲的，必须以十进制数报告。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，每个内部列表按顺序对应一个测试，格式为 $[e_{\\mathrm{cons}}, e_{\\mathrm{lump}}]$。例如，输出必须如下所示：\n$[[e_1^{\\mathrm{cons}}, e_1^{\\mathrm{lump}}],[e_2^{\\mathrm{cons}}, e_2^{\\mathrm{lump}}],[e_3^{\\mathrm{cons}}, e_3^{\\mathrm{lump}}]]$\n其中每个 $e$ 均以标准记数法表示的浮点小数给出。不应打印任何额外文本。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- **单元类型**：平面应变中的等参双线性四边形（$\\text{Q4}$）。\n- **单元几何**：一个占据 $\\Omega = [0, L_x] \\times [0, L_y]$ 的单个矩形单元，单位厚度 $t = 1$。\n- **节点顺序**：从左下角 $(0,0)$ 开始逆时针排列。\n- **材料模型**：各向同性线性弹性，杨氏模量为 $E$，泊松比为 $\\nu$。\n- **目标状态**：一个常柯西应力向量 $\\boldsymbol{\\sigma}_0 = [\\sigma_{xx}^0, \\sigma_{yy}^0, \\sigma_{xy}^0]^{\\mathsf{T}}$。\n- **精确位移场**：与 $\\boldsymbol{\\sigma}_0$ 对应的位移场（通过常应变 $\\boldsymbol{\\varepsilon}_0$）由 $u(x,y) = \\varepsilon_{xx}^0 x + \\tfrac{1}{2}\\gamma_{xy}^0 y$ 和 $v(x,y) = \\tfrac{1}{2}\\gamma_{xy}^0 x + \\varepsilon_{yy}^0 y$ 给出。\n- **节点位移**：向量 $\\boldsymbol{u}$ 是通过在四个单元节点处评估精确位移场得到的。\n- **刚度矩阵组装**：单元刚度矩阵 $\\boldsymbol{K}_e$ 使用精确的 $2 \\times 2$ 高斯求积进行组装。全局刚度 $\\boldsymbol{K}$ 与 $\\boldsymbol{K}_e$ 相同。\n- **边界牵引**：边界 $\\partial\\Omega$ 上的牵引力为 $\\boldsymbol{t} = \\boldsymbol{\\sigma}_0 \\boldsymbol{n}$，其中 $\\boldsymbol{n}$ 是外法线单位向量。\n- **一致载荷向量（$\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$）**：通过使用两点高斯求积在每条边上对 $\\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t}$ 进行积分来计算。\n- **集总载荷向量（$\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$）**：通过积分每条边上的总力并将其平均分配（50/50）给两个边节点来计算。\n- **残差**：$\\boldsymbol{r}_{\\mathrm{cons}} = \\boldsymbol{K}\\boldsymbol{u} - \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$ 和 $\\boldsymbol{r}_{\\mathrm{lump}} = \\boldsymbol{K}\\boldsymbol{u} - \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$。\n- **误差度量**：相对欧几里得范数 $e_{\\mathrm{cons}} = \\dfrac{\\|\\boldsymbol{r}_{\\mathrm{cons}}\\|_2}{\\|\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}\\|_2}$ 和 $e_{\\mathrm{lump}} = \\dfrac{\\|\\boldsymbol{r}_{\\mathrm{lump}}\\|_2}{\\|\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}\\|_2}$。\n- **测试用例**：\n    1. $E = 1000$ Pa, $\\nu = 0.25$, $L_x = 2.0$ m, $L_y = 1.0$ m, $\\boldsymbol{\\sigma}_0 = [5.0, 0.0, 0.0]^{\\mathsf{T}}$ Pa.\n    2. $E = 1000$ Pa, $\\nu = 0.25$, $L_x = 1.5$ m, $L_y = 0.8$ m, $\\boldsymbol{\\sigma}_0 = [0.0, 0.0, 4.0]^{\\mathsf{T}}$ Pa.\n    3. $E = 1000$ Pa, $\\nu = 0.25$, $L_x = 3.0$ m, $L_y = 0.5$ m, $\\boldsymbol{\\sigma}_0 = [2.0, -1.0, 3.0]^{\\mathsf{T}}$ Pa.\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题完全基于固体力学中有限元法（FEM）的基本原理。线性弹性、等参单元、高斯求积、虚功原理和斑块检验都是标准的、成熟的概念。所提供的方程是这些原理的正确表示。\n2.  **适定性**：该问题描述了一个确定性的数值实验。所有必需的输入和过程都已指定，从而为所要求的误差度量得出一个唯一的数值结果。\n3.  **客观性**：问题以精确、正式和无偏见的技术语言陈述。\n4.  **完整性与一致性**：所有必要的参数、边界条件和数值程序都已完全指定。设置中没有矛盾。\n5.  **现实性与可行性**：参数在物理上是合理的。数值程序是标准的，并且在计算上是可行的。\n\n### 步骤 3：结论与行动\n该问题有效。它构成了计算力学中的一个标准验证练习。将提供完整的解决方案。\n\n## 解答\n\n目标是在单个矩形双线性四边形（$\\text{Q4}$）单元上执行斑块检验，以比较一致和集总的诺伊曼载荷向量。斑块检验的核心是验证对于单元可以精确表示的位移场，内部生成的节点力与外部施加的节点力相平衡。\n\n### 理论基础\n虚功原理，在其离散的有限元形式中，指出为使系统处于平衡状态，内部节点力向量 $\\boldsymbol{f}_{\\mathrm{int}}$ 必须与外部节点力向量 $\\boldsymbol{f}_{\\mathrm{ext}}$ 相平衡。即 $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{f}_{\\mathrm{ext}}$。\n内部力由单元应力计算得出，即 $\\boldsymbol{f}_{\\mathrm{int}} = \\int_{\\Omega_e} \\boldsymbol{B}^{\\mathsf{T}}\\boldsymbol{\\sigma} \\, \\mathrm{d}V$，如果应力状态 $\\boldsymbol{\\sigma}$ 是由节点位移 $\\boldsymbol{u}$ 引起的，则这等价于 $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{K}\\boldsymbol{u}$。由边界牵引引起的外部力由 $\\boldsymbol{f}_{\\mathrm{N}} = \\int_{\\partial\\Omega_e} \\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t} \\, \\mathrm{d}S$ 给出。一个正确构建的单元必须满足 $\\boldsymbol{K}\\boldsymbol{u} = \\boldsymbol{f}_{\\mathrm{N}}$，此时 $\\boldsymbol{u}$ 对应于常应力状态，并且 $\\boldsymbol{f}_{\\mathrm{N}}$ 是一致计算的。\n\n此问题的一个关键方面是 $\\text{Q4}$ 单元再现目标状态的能力。对应于常应变（因此是常应力）的位移场 $u(x,y), v(x,y)$ 是关于 x 和 y 的线性函数。一个通用的双线性等参单元可以精确表示任何形式为 $f(x,y) = c_1 + c_2x + c_3y + c_4xy$ 的函数。目标位移场是纯线性的，是该单元可以表示的函数的一个子集。因此，一个矩形 $\\text{Q4}$ 单元可以精确插值对应于任何常应力状态的位移场。此外，对于矩形单元，单元的公式在整个单元域内正确地再现了常应变状态，而不仅仅是在节点上。\n\n比较的关键在于计算载荷向量 $\\boldsymbol{f}_{\\mathrm{N}}$ 的两种方法：\n\n1.  **一致载荷向量（$\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$）**：该向量直接从虚功原理导出，通过使用与位移插值相同的形函数进行力插值。积分 $\\int_{\\partial\\Omega} \\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t} \\, \\mathrm{d}S$ 沿每条边进行评估。对于直边和常牵引向量 $\\boldsymbol{t}$，使用 2 点高斯求积对线性形函数进行积分是精确的，其结果是将总边力在边的两个节点之间平均分配。\n\n2.  **集总载荷向量（$\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$）**：这是一种简化的、临时的（ad-hoc）方法。问题将其定义为取一条边上的总力 $\\boldsymbol{F}_{edge} = \\int_{\\Gamma_e} \\boldsymbol{t} \\, \\mathrm{d}S$，并将其一半分配给该边上的两个节点。\n\n对于直边、线性（$\\text{Q4}$）形函数和常牵引向量 $\\boldsymbol{t}$（本题即是此种情况，因为 $\\boldsymbol{\\sigma}_0$ 是常数且单元是矩形）的特定情况，一致载荷向量的计算得出的力分布与指定的集总方案完全相同，即 50/50 的分配。因此，我们预测 $\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}} = \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$，因此，误差 $e_{\\mathrm{cons}}$ 和 $e_{\\mathrm{lump}}$ 都应接近机器精度，表明两种方法在这些理想化条件下都通过了斑块检验。如果牵引力不是常数、边界是弯曲的或使用更高阶的单元，则会产生误差。\n\n### 算法实现步骤\n\n1.  **设置**：对于每个测试用例，定义材料属性（$E, \\nu$）、几何形状（$L_x, L_y$）和目标应力（$\\boldsymbol{\\sigma}_0$）。设置厚度 $t=1$。定义四个节点的物理坐标。\n\n2.  **本构矩阵**：计算 $3 \\times 3$ 的平面应变本构矩阵 $\\boldsymbol{D}$。\n    $$ \\boldsymbol{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  \\frac{1-2\\nu}{2} \\end{bmatrix} $$\n\n3.  **节点位移**：计算目标常应变向量 $\\boldsymbol{\\varepsilon}_0 = \\boldsymbol{D}^{-1}\\boldsymbol{\\sigma}_0$。使用 $\\boldsymbol{\\varepsilon}_0$ 通过在四个节点坐标处对精确的线性位移场进行采样，来找到节点位移向量 $\\boldsymbol{u}$。\n\n4.  **刚度矩阵（$\\boldsymbol{K}$）**：通过使用 $2 \\times 2$ 高斯求积在单元面积上对 $\\boldsymbol{B}^{\\mathsf{T}}\\boldsymbol{D}\\boldsymbol{B}$ 进行数值积分来组装 $8 \\times 8$ 的单元刚度矩阵。应变-位移矩阵 $\\boldsymbol{B}(\\xi, \\eta)$ 是父坐标 $(\\xi, \\eta)$ 的函数，并从形函数的空间导数导出。对于矩形单元，等参映射的雅可比行列式是常数，这简化了计算。\n    $$ \\boldsymbol{K}_e = \\int_{-1}^{1}\\int_{-1}^{1} \\boldsymbol{B}(\\xi,\\eta)^{\\mathsf{T}} \\boldsymbol{D} \\boldsymbol{B}(\\xi,\\eta) \\, t \\, \\det(\\boldsymbol{J}) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta $$\n\n5.  **内力**：计算内部节点力向量 $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{K}\\boldsymbol{u}$。\n\n6.  **载荷向量**：\n    *   **一致（$\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$）**：通过对来自四个边界边的贡献求和来组装。对于每条边，使用 2 点高斯求积线积分对 $\\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t}$ 进行积分。牵引力 $\\boldsymbol{t}$ 沿每条边都是恒定的。\n    *   **集总（$\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$）**：通过对每条边的贡献求和来组装。对于每条边，计算总力向量，并将其一半加到该边上两个节点的自由度上。\n\n7.  **误差计算**：计算残差 $\\boldsymbol{r}_{\\mathrm{cons}}$ 和 $\\boldsymbol{r}_{\\mathrm{lump}}$ 以及它们在问题中指定的相对范数 $e_{\\mathrm{cons}}$ 和 $e_{\\mathrm{lump}}$。\n\n以下 Python 程序为给定的测试套件实现了此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a patch test for a single Q4 element to compare consistent\n    and lumped Neumann boundary load vectors.\n    \"\"\"\n    test_cases = [\n        # (E, nu, Lx, Ly, sigma0)\n        (1000.0, 0.25, 2.0, 1.0, np.array([5.0, 0.0, 0.0])),\n        (1000.0, 0.25, 1.5, 0.8, np.array([0.0, 0.0, 4.0])),\n        (1000.0, 0.25, 3.0, 0.5, np.array([2.0, -1.0, 3.0])),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_patch_test(case)\n        results.append(result)\n\n    # Format the flot numbers in the output string representation\n    formatted_results = []\n    for res_pair in results:\n        formatted_pair = f'[{res_pair[0]:.17e}, {res_pair[1]:.17e}]'\n        formatted_results.append(formatted_pair)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_patch_test(test_case):\n    \"\"\"\n    Executes the patch test logic for a single parameter set.\n    \"\"\"\n    E, nu, Lx, Ly, sigma0 = test_case\n    t = 1.0  # Unit thickness\n\n    # 1. Material and Geometry Setup\n    node_coords = np.array([\n        [0.0, 0.0],\n        [Lx, 0.0],\n        [Lx, Ly],\n        [0.0, Ly]\n    ])\n\n    # 2. Constitutive Matrix (D) for Plane Strain\n    factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    D = factor * np.array([\n        [1.0 - nu, nu, 0.0],\n        [nu, 1.0 - nu, 0.0],\n        [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n    ])\n\n    # 3. Target Strain and Nodal Displacements\n    D_inv = np.linalg.inv(D)\n    eps0 = D_inv @ sigma0\n    eps_xx, eps_yy, gam_xy = eps0\n\n    u_nodes = np.zeros(8)\n    for i in range(4):\n        x, y = node_coords[i]\n        u_nodes[2 * i] = eps_xx * x + 0.5 * gam_xy * y\n        u_nodes[2 * i + 1] = 0.5 * gam_xy * x + eps_yy * y\n\n    # 4. Stiffness Matrix Assembly (K)\n    K = np.zeros((8, 8))\n    detJ = (Lx / 2.0) * (Ly / 2.0)\n    \n    gauss_points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    weights = [1.0, 1.0]\n    parent_coords = np.array([[-1., -1.], [1., -1.], [1., 1.], [-1., 1.]])\n\n    for i, xi in enumerate(gauss_points):\n        for j, eta in enumerate(gauss_points):\n            B = np.zeros((3, 8))\n            for n in range(4):\n                xi_n, eta_n = parent_coords[n]\n                dN_dxi = 0.25 * xi_n * (1.0 + eta_n * eta)\n                dN_deta = 0.25 * eta_n * (1.0 + xi_n * xi)\n                dN_dx = (2.0 / Lx) * dN_dxi\n                dN_dy = (2.0 / Ly) * dN_deta\n                \n                B[0, 2 * n] = dN_dx\n                B[1, 2 * n + 1] = dN_dy\n                B[2, 2 * n] = dN_dy\n                B[2, 2 * n + 1] = dN_dx\n            \n            K += B.T @ D @ B * detJ * weights[i] * weights[j] * t\n\n    # 5. Internal Force Vector\n    f_int = K @ u_nodes\n\n    # 6. Neumann Load Vector Assembly\n    f_cons = np.zeros(8)\n    f_lump = np.zeros(8)\n    sigma_mat = np.array([[sigma0[0], sigma0[2]], [sigma0[2], sigma0[1]]])\n    \n    edges = [\n        (0, 1, np.array([0.0, -1.0]), Lx), # Bottom\n        (1, 2, np.array([1.0, 0.0]), Ly),  # Right\n        (2, 3, np.array([0.0, 1.0]), Lx),  # Top\n        (3, 0, np.array([-1.0, 0.0]), Ly)  # Left\n    ]\n\n    for n1_idx, n2_idx, normal, length in edges:\n        traction = sigma_mat @ normal\n        total_force_edge = traction * length * t\n        \n        # Lumped vector\n        f_lump[2 * n1_idx: 2 * n1_idx + 2] += 0.5 * total_force_edge\n        f_lump[2 * n2_idx: 2 * n2_idx + 2] += 0.5 * total_force_edge\n\n        # Consistent vector (using 2-point Gauss quadrature on edge)\n        detJ_line = length / 2.0\n        for k, s in enumerate(gauss_points): # s is local coord on edge [-1, 1]\n            wk = weights[k]\n            N1_edge = 0.5 * (1.0 - s)\n            N2_edge = 0.5 * (1.0 + s)\n            \n            # Add contribution to node 1 of the edge\n            f_cons[2 * n1_idx: 2 * n1_idx + 2] += (N1_edge * traction) * detJ_line * wk * t\n            # Add contribution to node 2 of the edge\n            f_cons[2 * n2_idx: 2 * n2_idx + 2] += (N2_edge * traction) * detJ_line * wk * t\n            \n    # 7. Residual and Error Calculation\n    r_cons = f_int - f_cons\n    r_lump = f_int - f_lump\n\n    norm_f_cons = np.linalg.norm(f_cons)\n    \n    if norm_f_cons  1e-15:\n        e_cons = np.linalg.norm(r_cons)\n        e_lump = np.linalg.norm(r_lump)\n    else:\n        e_cons = np.linalg.norm(r_cons) / norm_f_cons\n        e_lump = np.linalg.norm(r_lump) / norm_f_cons\n\n    return [e_cons, e_lump]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3504177"}, {"introduction": "在掌握了基本的罚函数法后，本次高级实践将带您探索更广泛的弱形式边界条件施加技术。在一个瞬态固结问题中，您将实现并比较三种主流方法：罚函数法、拉格朗日乘子法和 Nitsche 方法 [@problem_id:3504268]。通过评估每种方法在满足质量守恒定律方面的表现，您将对它们各自的精度、稳定性和实现复杂度有更深入的认识，这对于在复杂工程模拟中选择最优策略至关重要。", "problem": "考虑刚性骨架极限下的一维小应变 Biot 固结，此时流体压力场由一个基于流体质量平衡和 Darcy 定律推导出的扩散型偏微分方程（PDE）控制。设空间域为 $x \\in [0,L]$，其中 $L$ 的单位为米。流体压力 $p(x,t)$ 的控制方程为\n$$\nS \\, \\frac{\\partial p}{\\partial t}(x,t) - \\frac{\\partial}{\\partial x}\\!\\left( K \\, \\frac{\\partial p}{\\partial x}(x,t) \\right) = 0,\n$$\n其中 $S$ 是储水率（单位为 $\\mathrm{Pa}^{-1}$），$K = k/\\mu$ 是水力扩散系数（渗透率除以动力黏度，单位为 $\\mathrm{m}^2/(\\mathrm{Pa}\\cdot\\mathrm{s})$）。初始条件为均匀压力 $p(x,0) = p_0$，其中 $p_0$ 的单位为帕斯卡。左边界 $x=0$ 为无流动边界（齐次 Neumann），右边界 $x=L$ 为排水边界（Dirichlet），即 $p(L,t)=0$。排水边界将通过以下三种弱施加策略之一来施加：罚函数法、Lagrange 乘子法和 Nitsche 方法。\n\n从将 PDE 乘以一个检验函数 $w(x)$ 并在域 $[0,L]$ 上积分得到的弱形式出发，\n$$\n\\int_0^L S \\, w \\, \\frac{\\partial p}{\\partial t} \\, dx + \\int_0^L K \\, \\frac{\\partial w}{\\partial x} \\, \\frac{\\partial p}{\\partial x} \\, dx - w(0) \\, q_N(0,t) - w(L) \\, q_N(L,t) = 0,\n$$\n其中 $q_N(x,t)$ 表示给定的法向通量，请使用有限元法（FEM）推导出一个半离散空间近似解。有限元法采用线性（双节点）单元、包含 $N_e$ 个单元和 $N_n=N_e+1$ 个节点的均匀网格，以及每个单元上的分段线性试探函数和检验函数。使用具有恒定时间步长 $\\Delta t$ 的后向欧拉时间积分方法，以在每个时间步获得一个全离散系统。通过以下每种方法施加排水边界条件 $p(L,t)=0$：\n\n1) 罚函数法：添加一个与 $(p(L,t) - p_D)$（其中 $p_D=0$）成比例的边界罚函数项，该项通过一个无量纲稳定化参数 $\\gamma_p$ 进行缩放，形式为 $\\gamma_p \\, K/h$，其中 $h$ 是与 $x=L$ 相邻的最后一个单元的尺寸。\n\n2) Lagrange 乘子法：通过使用 Lagrange 乘子，以一个约束方程来增广离散系统，从而施加约束 $p(L,t)=p_D$。可选择使用增广 Lagrange 正则化，在排水边界自由度的对角线上添加 $\\beta \\, K/h$ 项，其中 $\\beta$ 是一个无量纲稳定化参数（对于纯 Lagrange 乘子法，设 $\\beta=0$；对于增广变体，设 $\\beta0$）。\n\n3) Nitsche 方法：在排水边界上使用带有无量纲稳定化参数 $\\gamma_N$ 的对称 Nitsche 公式，添加一致性项\n$$\n- \\int_{\\Gamma_D} w \\, (n \\cdot K \\nabla p) \\, ds - \\int_{\\Gamma_D} (n \\cdot K \\nabla w) \\, (p - p_D) \\, ds\n$$\n和一个罚函数项\n$$\n\\int_{\\Gamma_D} \\gamma_N \\, \\frac{K}{h} \\, w \\, (p - p_D) \\, ds,\n$$\n其中 $n$ 是外法向单位向量，在一维情况下 $\\Gamma_D=\\{x=L\\}$。\n\n设物理参数为 $L = 1\\,\\mathrm{m}$，$S = 1.0\\times 10^{-9}\\,\\mathrm{Pa}^{-1}$，$K = 1.0\\times 10^{-6}\\,\\mathrm{m}^2/(\\mathrm{Pa}\\cdot\\mathrm{s})$，$p_0 = 1.0\\times 10^{5}\\,\\mathrm{Pa}$，并使用包含 $N_e = 40$ 个单元的均匀网格，因此 $h = L/N_e$。使用后向欧拉法，时间步长 $\\Delta t = 10\\,\\mathrm{s}$，最终时间 $T = 1000\\,\\mathrm{s}$（即 $N_t = T/\\Delta t$ 个时间步）。\n\n将在时间 $t$ 的单位横截面积上的总流体含量定义为\n$$\nM(t) = S \\int_0^L p(x,t)\\, dx,\n$$\n在有限元离散化中，这等于 $M(t) \\approx \\mathbf{1}^\\top \\mathbf{M}\\, \\mathbf{p}(t)$，其中 $\\mathbf{M}$ 是一致质量矩阵，$\\mathbf{p}(t)$ 是节点压力向量。根据 Darcy 定律，将排水边界处的流出通量定义为\n$$\nq_\\mathrm{out}(t) = - K \\, \\frac{\\partial p}{\\partial x}(L,t),\n$$\n并在每个时间步中通过最后一个单元上的梯度将其近似为\n$$\nq_\\mathrm{out}(t_n) \\approx K \\, \\frac{p_{N_n-2}(t_n) - p_{N_n-1}(t_n)}{h}.\n$$\n将在时间 $T$ 之前单位面积上累计排出的流体含量定义为\n$$\nQ(T) = \\sum_{n=1}^{N_t} q_\\mathrm{out}(t_n)\\, \\Delta t.\n$$\n根据全局质量守恒，在没有源项且 $x=0$ 处通量为零的情况下，守恒恒等式为\n$$\nM(T) - M(0) + Q(T) = 0.\n$$\n将质量守恒误差定义为\n$$\n\\Delta m = \\left| M(T) - M(0) + Q(T) \\right|,\n$$\n单位为米（单位横截面积的流体含量）。通过为一组稳定化参数计算 $\\Delta m$ 来实现并比较这三种边界施加策略。处理为 $p_D=0$。\n\n您的程序必须为以下每个测试用例求解离散系统：\n- 罚函数法，$\\gamma_p = 0.1$、$\\gamma_p = 10.0$ 和 $\\gamma_p = 1000.0$。\n- Nitsche 方法，$\\gamma_N = 1.0$、$\\gamma_N = 10.0$ 和 $\\gamma_N = 100.0$。\n- Lagrange 乘子法，增广参数 $\\beta = 0.0$（纯 Lagrange 乘子）和 $\\beta = 10.0$。\n\n对于每个测试用例，计算并返回以米为单位的 $\\Delta m$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[0.00123,0.00045, \\ldots ]$）。所有数值都必须以米为单位，并表示为以 10 为底的浮点十进制数。", "solution": "The user wants to solve a 1D consolidation problem and compare three different methods for weakly enforcing a Dirichlet boundary condition. I will first validate the problem statement.\n\n### Step 1: Extract Givens\n- **Governing PDE**: $S \\, \\frac{\\partial p}{\\partial t}(x,t) - \\frac{\\partial}{\\partial x}\\!\\left( K \\, \\frac{\\partial p}{\\partial x}(x,t) \\right) = 0$ for $x \\in [0,L]$.\n- **Parameters**: Storativity $S$, hydraulic diffusivity factor $K$.\n- **Initial Condition**: $p(x,0) = p_0$.\n- **Boundary Conditions**: Homogeneous Neumann at $x=0$ (no-flow), Dirichlet at $x=L$ ($p(L,t)=p_D=0$).\n- **Weak Form**: $\\int_0^L S \\, w \\, \\frac{\\partial p}{\\partial t} \\, dx + \\int_0^L K \\, \\frac{\\partial w}{\\partial x} \\, \\frac{\\partial p}{\\partial x} \\, dx - w(0) \\, q_N(0,t) - w(L) \\, q_N(L,t) = 0$.\n- **Discretization**: Linear two-node finite elements ($N_e$ elements, $N_n=N_e+1$ nodes), uniform mesh size $h=L/N_e$. Backward Euler time integration with step $\\Delta t$.\n- **Physical/Numerical Constants**: $L = 1\\,\\mathrm{m}$, $S = 1.0\\times 10^{-9}\\,\\mathrm{Pa}^{-1}$, $K = 1.0\\times 10^{-6}\\,\\mathrm{m}^2/(\\mathrm{Pa}\\cdot\\mathrm{s})$, $p_0 = 1.0\\times 10^{5}\\,\\mathrm{Pa}$, $N_e = 40$, $h = L/N_e$, $\\Delta t = 10\\,\\mathrm{s}$, $T = 1000\\,\\mathrm{s}$.\n- **Boundary Condition Enforcement Methods**:\n    1.  **Penalty**: Add penalty term $\\gamma_p \\, K/h \\, (p(L,t) - p_D)$.\n    2.  **Lagrange Multiplier**: Augment system with constraint $p(L,t)=p_D$ and optional regularization $\\beta \\, K/h$.\n    3.  **Symmetric Nitsche**: Add terms $- \\int_{\\Gamma_D} w \\, (n \\cdot K \\nabla p) \\, ds - \\int_{\\Gamma_D} (n \\cdot K \\nabla w) \\, (p - p_D) \\, ds + \\int_{\\Gamma_D} \\gamma_N \\, \\frac{K}{h} \\, w \\, (p - p_D) \\, ds$.\n- **Analysis Quantities**:\n    -   Total fluid content: $M(t) = S \\int_0^L p(x,t)\\, dx \\approx \\mathbf{1}^\\top \\mathbf{M}\\, \\mathbf{p}(t)$.\n    -   Outward flux: $q_\\mathrm{out}(t) = - K \\, \\frac{\\partial p}{\\partial x}(L,t) \\approx K \\, (p_{N_n-2}(t_n) - p_{N_n-1}(t_n))/h$.\n    -   Cumulative discharge: $Q(T) = \\sum_{n=1}^{N_t} q_\\mathrm{out}(t_n)\\, \\Delta t$.\n    -   Mass conservation error: $\\Delta m = \\left| M(T) - M(0) + Q(T) \\right|$.\n- **Test Cases**:\n    -   Penalty: $\\gamma_p \\in \\{0.1, 10.0, 1000.0\\}$.\n    -   Nitsche: $\\gamma_N \\in \\{1.0, 10.0, 100.0\\}$.\n    -   Lagrange Multiplier: $\\beta \\in \\{0.0, 10.0\\}$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem describes 1D fluid diffusion in a porous medium, a cornerstone of geomechanics and hydrology, based on mass conservation and Darcy's law. All models and methods are standard in computational mechanics. The setup is scientifically valid.\n2.  **Well-Posed**: The problem is a well-posed initial-boundary value problem for a parabolic PDE. The numerical formulation is standard and leads to a solvable system of linear equations at each time step.\n3.  **Objective**: All terms are defined with mathematical precision. No subjective language is used.\n4.  **Scientific or Factual Unsoundness**: None. The physics, mathematics, and numerical methods are correct.\n5.  **Non-Formalizable or Irrelevant**: The problem is highly formalizable and directly relevant to the specified topic.\n6.  **Incomplete or Contradictory Setup**: The problem is fully specified. The definition of the discrete total fluid content $M(t) \\approx \\mathbf{1}^\\top \\mathbf{M}\\, \\mathbf{p}(t)$ is correct because for a test function $w(x)=1 = \\sum_i N_i(x)$, the corresponding vector of nodal weights is $\\mathbf{w}=\\mathbf{1}$, and the integral $\\int S w p \\,dx$ becomes $\\mathbf{w}^\\top \\mathbf{M} \\mathbf{p} = \\mathbf{1}^\\top \\mathbf{M} \\mathbf{p}$. The flux approximation is a valid finite difference over the last element. All definitions are consistent.\n7.  **Unrealistic or Infeasible**: The physical parameters are plausible for materials like sand or silt. The numerical parameters define a numerically stable simulation (the backward-Euler scheme is unconditionally stable).\n8.  **Ill-Posed or Poorly Structured**: Not ill-posed. The structure is clear and logical.\n9.  **Pseudo-Profound, Trivial, or Tautological**: The problem is a substantive exercise in numerical analysis, comparing the practical performance of different established numerical techniques.\n10. **Outside Scientific Verifiability**: The results are numerically computable and verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution derivation.\n\nThe governing PDE for the fluid pressure $p(x,t)$ is a diffusion equation:\n$$S \\, \\frac{\\partial p}{\\partial t} - \\frac{\\partial}{\\partial x}\\!\\left( K \\, \\frac{\\partial p}{\\partial x} \\right) = 0$$\nWe begin by deriving the semi-discrete finite element approximation. Multiplying by a test function $w(x)$ and integrating over the domain $[0,L]$ yields the weak form. After integration by parts of the second term, we have:\n$$\\int_0^L S \\, w \\, \\frac{\\partial p}{\\partial t} \\, dx + \\int_0^L K \\, \\frac{\\partial w}{\\partial x} \\, \\frac{\\partial p}{\\partial x} \\, dx - \\left[ w K \\frac{\\partial p}{\\partial x} \\right]_0^L = 0$$\nThe boundary term can be written in terms of the Darcy flux $q(x,t) = -K \\frac{\\partial p}{\\partial x}(x,t)$. The weak form becomes:\n$$\\int_0^L S \\, w \\, \\frac{\\partial p}{\\partial t} \\, dx + \\int_0^L K \\, \\frac{\\partial w}{\\partial x} \\, \\frac{\\partial p}{\\partial x} \\, dx + w(L)q(L,t) - w(0)q(0,t) = 0$$\nThe no-flow condition at $x=0$ implies $q(0,t)=0$. The condition at $x=L$ will be handled by the various weak enforcement methods.\n\nWe discretize the spatial domain with $N_e$ linear finite elements of uniform size $h = L/N_e$, having $N_n = N_e+1$ nodes. We approximate the pressure field as $p(x,t) \\approx \\sum_{j=0}^{N_n-1} p_j(t) N_j(x)$, where $p_j(t)$ are the nodal pressure values and $N_j(x)$ are the piecewise linear basis functions. Using the Galerkin method, the test function $w(x)$ is chosen from the same basis, $w(x) = N_i(x)$. This leads to a system of ordinary differential equations:\n$$\\mathbf{M} \\frac{d\\mathbf{p}}{dt} + \\mathbf{K} \\mathbf{p} = \\mathbf{f}$$\nwhere $\\mathbf{p}$ is the vector of nodal pressures, and the matrices are assembled from element contributions:\n-   Consistent Mass Matrix: $\\mathbf{M}_{ij} = \\int_0^L S N_i(x) N_j(x) \\, dx$. For a linear element, $\\mathbf{M}^e = \\frac{S h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}$.\n-   Stiffness Matrix: $\\mathbf{K}_{ij} = \\int_0^L K N_i'(x) N_j'(x) \\, dx$. For a linear element, $\\mathbf{K}^e = \\frac{K}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$.\n-   Force Vector $\\mathbf{f}$: arises from boundary terms. For now, $f_i(t) = -w(L)q(L,t)|_{w=N_i}$, which is non-zero only for $i=N_n-1$.\n\nApplying the backward Euler scheme for time integration, $\\frac{d\\mathbf{p}}{dt} \\approx \\frac{\\mathbf{p}^{n+1} - \\mathbf{p}^n}{\\Delta t}$, we obtain a fully discrete system to be solved at each time step $n+1$:\n$$(\\mathbf{M} + \\Delta t \\mathbf{K}) \\mathbf{p}^{n+1} = \\mathbf{M} \\mathbf{p}^n + \\Delta t \\mathbf{f}^{n+1}$$\nwhere $\\mathbf{p}^{n+1}$ is the unknown pressure vector at time $t_{n+1}$. The boundary condition $p(L,t) = p_D=0$ is imposed on the node $i=N_n-1$.\n\n**1. Penalty Method**\nThe Dirichlet constraint is enforced approximately by adding a penalty term to the weak form, which can be interpreted as a Robin-type boundary condition where the flux is proportional to the constraint violation: $q(L,t) \\approx \\alpha (p(L,t) - p_D)$. The penalty parameter is given as $\\alpha = \\gamma_p K/h$. The force vector contribution is $f_{N_n-1}^{n+1} = -q(L,t_{n+1}) \\approx -\\alpha (p_{N_n-1}^{n+1} - p_D)$. With $p_D=0$, the system becomes:\n$$(\\mathbf{M} + \\Delta t \\mathbf{K}) \\mathbf{p}^{n+1} + \\Delta t \\alpha \\begin{pmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ 1 \\end{pmatrix} p_{N_n-1}^{n+1} = \\mathbf{M} \\mathbf{p}^n$$\nThis is equivalent to modifying the system matrix $\\mathbf{A} = \\mathbf{M} + \\Delta t \\mathbf{K}$ by adding a term to its last diagonal entry:\n$$A_{N_n-1, N_n-1} \\rightarrow A_{N_n-1, N_n-1} + \\Delta t \\, \\gamma_p \\frac{K}{h}$$\nThe right-hand side vector is $\\mathbf{b} = \\mathbf{M} \\mathbf{p}^n$. We solve $(\\mathbf{A}_{mod}) \\mathbf{p}^{n+1} = \\mathbf{b}$.\n\n**2. Lagrange Multiplier Method**\nThis method introduces a new unknown, the Lagrange multiplier $\\lambda$, which represents the reaction flux at the boundary, $\\lambda \\approx q(L,t)$. The system is augmented by the exact constraint equation $p_{N_n-1}^{n+1} = p_D = 0$. The force vector becomes $\\mathbf{f}^{n+1} = [0, \\dots, 0, -\\lambda^{n+1}]^\\top$. The full system at step $n+1$ combines the discretized PDE and the constraint:\n$$ \\begin{cases} (\\mathbf{M} + \\Delta t \\mathbf{K}) \\mathbf{p}^{n+1} + \\Delta t \\lambda^{n+1} \\mathbf{c} = \\mathbf{M} \\mathbf{p}^n \\\\ \\mathbf{c}^\\top \\mathbf{p}^{n+1} = p_D \\end{cases} $$\nwhere $\\mathbf{c}$ is a vector with $1$ at index $N_n-1$ and $0$ elsewhere. This forms an $(N_n+1) \\times (N_n+1)$ saddle-point system:\n$$ \\begin{pmatrix} \\mathbf{M} + \\Delta t \\mathbf{K}  \\Delta t \\, \\mathbf{c} \\\\ \\mathbf{c}^\\top  0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{p}^{n+1} \\\\ \\lambda^{n+1} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{M} \\mathbf{p}^n \\\\ p_D \\end{pmatrix} $$\nThe augmented variant adds a stabilization term $\\beta K/h$ to the diagonal entry of the primary degree of freedom, $p_{N_n-1}$. This modifies the $(N_n-1, N_n-1)$ entry of the top-left block of the system matrix:\n$$(\\mathbf{M} + \\Delta t \\mathbf{K})_{N_n-1, N_n-1} \\rightarrow (\\mathbf{M} + \\Delta t \\mathbf{K})_{N_n-1, N_n-1} + \\Delta t \\beta \\frac{K}{h}$$\nFor the pure Lagrange multiplier method, $\\beta=0$. Since $p_D=0$, the last entry of the right-hand side vector is $0$.\n\n**3. Nitsche’s Method**\nThe symmetric Nitsche method modifies the weak form by replacing the natural boundary term $w(L)q(L,t)$ with three terms that weakly enforce the Dirichlet condition. The final weak form is:\n$$\\int_0^L S w \\dot{p}\\,dx + \\int_0^L K w'p'\\,dx - [K p' w]_L - [K w'(p-p_D)]_L + [\\gamma_N \\frac{K}{h}w(p-p_D)]_L = 0$$\nThe three boundary terms contribute to the stiffness matrix $\\mathbf{K}$ and the load vector $\\mathbf{f}$. Discretizing these terms gives rise to modifications of the stiffness matrix entries corresponding to the boundary nodes ($N_n-2$ and $N_n-1$). The total contribution to be added to the standard stiffness matrix, for the sub-block corresponding to these two nodes, is:\n$$ \\mathbf{K}^N = \\frac{K}{h} \\begin{pmatrix} 0  1 \\\\ 1  \\gamma_N-2 \\end{pmatrix} $$\nThe total system stiffness matrix $\\mathbf{K}_{Nitsche}$ is $\\mathbf{K}_{std} + \\mathbf{K}^N$. This results in specific modifications. The standard stiffness matrix block for nodes $(N_n-2, N_n-1)$ is $\\frac{K}{h}\\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$. Adding $\\mathbf{K}^N$ modifies the coupling:\n$$ (\\mathbf{K}_{Nitsche})_{N_n-2, N_n-1} = (\\mathbf{K}_{Nitsche})_{N_n-1, N_n-2} = -K/h + K/h = 0 $$\n$$ (\\mathbf{K}_{Nitsche})_{N_n-1, N_n-1} = K/h + (\\gamma_N - 2)K/h = (\\gamma_N - 1)K/h $$\nThe terms involving $p_D$ contribute to the load vector, but since $p_D=0$, this contribution vanishes. The system to solve is $(\\mathbf{M} + \\Delta t \\mathbf{K}_{Nitsche})\\mathbf{p}^{n+1} = \\mathbf{M} \\mathbf{p}^n$.\n\n**Mass Conservation Error**\nThe mass conservation error $\\Delta m = | M(T) - M(0) + Q(T) |$ is computed to assess the accuracy of each method.\n-   The initial fluid content is $M(0) = S \\int_0^L p_0 \\, dx = S p_0 L$.\n-   The final fluid content is calculated from the final pressure vector $\\mathbf{p}(T)$: $M(T) \\approx \\mathbf{1}^\\top \\mathbf{M} \\mathbf{p}(T)$.\n-   The cumulative outflow $Q(T)$ is the sum of outflows at each time step, $Q(T) = \\sum_{n=1}^{N_t} q_\\mathrm{out}(t_n)\\, \\Delta t$, where the outflow flux is approximated from the solution as $q_\\mathrm{out}(t_n) \\approx K (p_{N_n-2}(t_n) - p_{N_n-1}(t_n))/h$.\n\nThe implementation will simulate the pressure evolution up to $T=1000\\,\\mathrm{s}$ for each of the $8$ test cases and compute the corresponding $\\Delta m$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D consolidation problem using FEM with different\n    weak boundary condition enforcement methods and calculates the\n    mass conservation error for each.\n    \"\"\"\n\n    # Physical and numerical parameters from the problem statement\n    L = 1.0  # m\n    S = 1.0e-9  # Pa^-1\n    K = 1.0e-6  # m^2/(Pa*s)\n    p0 = 1.0e5  # Pa\n    Ne = 40  # Number of elements\n    h = L / Ne  # Element size\n    Nn = Ne + 1  # Number of nodes\n    T = 1000.0  # s\n    dt = 10.0  # s\n    Nt = int(T / dt)  # Number of time steps\n    pD = 0.0 # Prescribed pressure at drained boundary\n\n    # Test cases from the problem statement\n    test_cases = [\n        ('penalty', 0.1),\n        ('penalty', 10.0),\n        ('penalty', 1000.0),\n        ('nitsche', 1.0),\n        ('nitsche', 10.0),\n        ('nitsche', 100.0),\n        ('lagrange', 0.0),\n        ('lagrange', 10.0),\n    ]\n\n    results = []\n\n    # Assemble global mass (M) and stiffness (K) matrices\n    M = np.zeros((Nn, Nn))\n    K_std = np.zeros((Nn, Nn))\n\n    # Element-level matrices\n    m_e = (S * h / 6.0) * np.array([[2.0, 1.0], [1.0, 2.0]])\n    k_e = (K / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n    for e in range(Ne):\n        # Global indices for the element's nodes\n        i, j = e, e + 1\n        # Add element contributions to global matrices\n        M[np.ix_([i, j], [i, j])] += m_e\n        K_std[np.ix_([i, j], [i, j])] += k_e\n\n    # Calculate initial mass M(0)\n    M0 = S * p0 * L\n\n    for method, param in test_cases:\n        p = np.full(Nn, p0) # Initial condition p(x,0) = p0\n        Q_T = 0.0 # Cumulative discharged fluid\n\n        for _ in range(Nt):\n            # Form the basic system Ax=b where A = M + dt*K and b = M*p_prev\n            # Make copies to avoid modifying the base matrices\n            K_eff = K_std.copy()\n            \n            # Right-hand side is the same for all methods\n            b_sys = M @ p\n            \n            if method == 'penalty':\n                gamma_p = param\n                A_sys = M + dt * K_eff\n                A_sys[Nn - 1, Nn - 1] += dt * gamma_p * K / h\n                p = np.linalg.solve(A_sys, b_sys)\n\n            elif method == 'nitsche':\n                gamma_N = param\n                # Modify the standard stiffness matrix for Nitsche's method\n                K_eff[Nn - 2, Nn - 1] = 0.0\n                K_eff[Nn - 1, Nn - 2] = 0.0\n                K_eff[Nn - 1, Nn - 1] = (gamma_N - 1.0) * K / h\n                A_sys = M + dt * K_eff\n                p = np.linalg.solve(A_sys, b_sys)\n\n            elif method == 'lagrange':\n                beta = param\n                A = M + dt * K_eff\n                # Add augmentation term if beta > 0\n                if beta > 0:\n                    A[Nn - 1, Nn - 1] += dt * beta * K / h\n                \n                # Assemble augmented system matrix\n                A_aug = np.zeros((Nn + 1, Nn + 1))\n                A_aug[:Nn, :Nn] = A\n                # Note on the sign convention for lambda:\n                # The PDE weak form is M p_dot + K p = f, where f_i = -integral(N_i * q_n).\n                # At the boundary, f_{Nn-1} = -q(L, t) = lambda.\n                # The discrete time equation is (M+dt*K)p^{n+1} = M p^n + dt*f^{n+1}.\n                # Rearranging: (M+dt*K)p^{n+1} - dt*lambda^{n+1}*c = M p^n.\n                # So the coefficient for lambda in the matrix equation should be -dt.\n                A_aug[Nn - 1, Nn] = -dt\n                A_aug[Nn, Nn - 1] = 1.0\n\n                # Assemble augmented RHS vector\n                b_aug = np.zeros(Nn + 1)\n                b_aug[:Nn] = b_sys\n                b_aug[Nn] = pD\n                \n                sol = np.linalg.solve(A_aug, b_aug)\n                p = sol[:Nn]\n            \n            # Calculate outflow flux for the current time step\n            q_out = K * (p[Nn - 2] - p[Nn - 1]) / h\n            # Accumulate total outflow\n            Q_T += q_out * dt\n        \n        # Calculate final mass M(T)\n        MT = np.ones(Nn) @ M @ p\n        \n        # Calculate mass conservation error\n        delta_m = abs(MT - M0 + Q_T)\n        results.append(delta_m)\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3504268"}]}