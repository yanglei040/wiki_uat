{"hands_on_practices": [{"introduction": "在计算岩土力学中，应用非局部模型的首要步骤是掌握其数值实现。本练习将引导您完成一个基础但至关重要的任务：将连续的非局部积分算子离散化。通过为一个一维杆件模型编写代码，您将学习如何将数学公式转化为可执行的算法，并验证其在不同应变场下的行为，为后续更复杂的应用奠定坚实的实践基础 [@problem_id:3546153]。", "problem": "考虑一个用于计算岩土力学中的一维连续介质模型，该模型通过非局部积分平均来正则化应变局部化。在应变软化材料中，纯粹的局部本构律可能导致不适定的边值问题，其中无穷小的扰动会在无限小的区域内产生无界的局部化。一种常见的解决方法是非局部积分正则化：将局部驱动变量（例如，等效应变）替换为在一个由核函数加权的有限邻域上的积分平均。从线性动量守恒和标准小应变运动学出发，通过引入进入软化律的非局部等效应变来增广本构律。非局部等效应变场 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ 定义为\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x) \\;=\\; \\dfrac{\\displaystyle \\int_{\\Omega} \\alpha\\!\\left(\\lVert x-\\xi\\rVert\\right)\\, \\varepsilon_{\\mathrm{eq}}(\\xi)\\, \\mathrm{d}\\xi}{\\displaystyle \\int_{\\Omega} \\alpha\\!\\left(\\lVert x-\\xi\\rVert\\right)\\, \\mathrm{d}\\xi},\n$$\n其中 $\\Omega$ 是域，$\\varepsilon_{\\mathrm{eq}}(\\xi)$ 是局部等效应变，$\\alpha(r)$ 是一个引入内禀长度尺度并用于正则化该问题的正衰减核函数。你将为一维杆实现此非局部算子的数值离散化。\n\n假设一根一维杆占据区间 $[0,L]$，长度为 $L$ 米。设该域被离散为 $N$ 个等距节点 $\\{x_i\\}_{i=1}^N$，间距为 $h = L/(N-1)$。设核函数为指数函数\n$$\n\\alpha(r) \\;=\\; \\exp\\!\\left(-\\dfrac{r}{\\ell}\\right),\n$$\n其中 $\\ell$ 是以米为单位的内禀长度尺度。使用复化梯形法则来近似积分，即，使用求积权重 $w_1 = w_N = h/2$ 以及 $w_i = h$（对于 $i=2,\\dots,N-1$）。在节点 $x_j$ 处的离散非局部平均值为\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) \\;\\approx\\; \\dfrac{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(x_i)\\, w_i}{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, w_i}.\n$$\n\n实现一个完整、可运行的程序，该程序：\n- 对于给定的 $L$（米）和 $N$，构建节点 $\\{x_i\\}$ 和梯形权重 $\\{w_i\\}$。\n- 对于给定的局部等效应变场 $\\varepsilon_{\\mathrm{eq}}(x)$ 和给定的内禀长度 $\\ell$（米），计算所有节点上的离散非局部平均值 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j)$。\n- 按规定使用指数核函数。\n- 为以下测试用例集生成结果。所有应变均为无量纲。所有长度和内禀长度 $\\ell$ 的单位均为米。\n\n测试用例A（均匀不变性）：\n- 参数：$L = 1$, $N = 101$, $\\ell = 0.05$。\n- 局部场：对于所有 $x \\in [0,1]$，$\\varepsilon_{\\mathrm{eq}}(x) = 0.01$。\n- 要求输出：最大绝对偏差 $\\max_j \\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) - 0.01 \\rvert$，作为浮点数。\n\n测试用例B（局部顶帽函数，中心值）：\n- 参数：$L = 1$, $N = 1001$, $\\ell = 0.1$。\n- 局部场：当 $x \\in [0.4, 0.6]$ 时 $\\varepsilon_{\\mathrm{eq}}(x) = 0.02$，否则 $\\varepsilon_{\\mathrm{eq}}(x) = 0$。\n- 要求输出：$x_c = 0.5$ 处的 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x_c)$ 值，作为浮点数。\n\n测试用例C（大内禀长度，趋近于均值）：\n- 参数：$L = 1$, $N = 1001$, $\\ell = 1.0$。\n- 局部场：与测试用例B相同。\n- 对于大 $\\ell$ 的理论均值：$\\varepsilon_{\\mathrm{mean}} = 0.02 \\times \\dfrac{0.6 - 0.4}{1} = 0.004$。\n- 要求输出：绝对差 $\\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(0.5) - 0.004 \\rvert$，作为浮点数。\n\n测试用例D（中心的近局部极限）：\n- 参数：$L = 1$, $N = 1001$, $\\ell = h = L/(N-1)$。\n- 局部场：与测试用例B相同。\n- 要求输出：绝对差 $\\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(0.5) - 0.02 \\rvert$，作为浮点数。\n\n测试用例E（梯度的边界效应）：\n- 参数：$L = 1$, $N = 201$, $\\ell = 0.1$。\n- 局部场：对于所有 $x \\in [0,1]$，$\\varepsilon_{\\mathrm{eq}}(x) = x/L$。\n- 要求输出：左边界处 $\\bar{\\varepsilon}_{\\mathrm{eq}}(0)$ 的值，作为浮点数。\n\n你的程序应生成单行输出，其中包含测试用例A到E的结果，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如，$[r_A,r_B,r_C,r_D,r_E]$）。打印的数字不附带单位，因为所有输出都是无量纲的。程序不得读取任何外部输入。\n\n实现必须在科学上保持一致且在数值上稳健。离散化必须遵循所述的梯形求积法，非局部平均必须使用带有内禀长度尺度的指数核函数。通过离散公式中的分母，仔细管理边界归一化，以避免在域边界附近产生人为偏差。", "solution": "该问题要求实现一种数值算法来计算非局部积分平均值，这是一种在计算岩土力学中用于正则化材料应变局部化数学模型的技术。解决方案将通过离散化控制积分方程并将其应用于一系列定义明确的测试用例来构建。\n\n连续一维非局部等效应变 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ 定义为局部等效应变场 $\\varepsilon_{\\mathrm{eq}}(\\xi)$ 在域 $\\Omega = [0, L]$ 上的加权平均：\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x) \\;=\\; \\dfrac{\\displaystyle \\int_{0}^{L} \\alpha\\!\\left(\\lvert x-\\xi\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(\\xi)\\, \\mathrm{d}\\xi}{\\displaystyle \\int_{0}^{L} \\alpha\\!\\left(\\lvert x-\\xi\\rvert\\right)\\, \\mathrm{d}\\xi}\n$$\n核函数 $\\alpha(r)$ 由指数衰减模型给出：\n$$\n\\alpha(r) \\;=\\; \\exp\\!\\left(-\\dfrac{r}{\\ell}\\right)\n$$\n其中 $r = \\lvert x-\\xi\\rvert$ 是距离，$\\ell$ 是特征内禀长度尺度。$\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ 定义中的分母确保权重和为一，这在积分被截断的域边界附近尤为重要。\n\n为了数值求解此问题，我们首先将域 $\\Omega = [0, L]$ 离散化为一组 $N$ 个等距节点 $\\{x_i\\}_{i=1}^N$。节点位于 $x_i = (i-1)h$（$i = 1, \\dots, N$），其中 $h = L/(N-1)$ 是恒定的网格间距。\n\n我们使用复化梯形法则来近似 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ 定义中的积分。函数 $f(\\xi)$ 在 $[0, L]$ 上的积分近似为：\n$$\n\\int_0^L f(\\xi) \\, \\mathrm{d}\\xi \\approx \\sum_{i=1}^N f(x_i) w_i\n$$\n梯形法则的求积权重 $\\{w_i\\}$ 为 $w_1 = w_N = h/2$，对于所有内部节点 $i=2, \\dots, N-1$，则为 $w_i = h$。\n\n将此数值求积法应用于特定节点 $x_j$ 的非局部平均公式，可得出离散近似：\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) \\;\\approx\\; \\dfrac{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(x_i)\\, w_i}{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, w_i}\n$$\n必须为每个节点 $j=1, \\dots, N$ 计算此表达式。\n\n为了计算效率，实现将被向量化。设 $\\mathbf{x}$ 为节点坐标的列向量，$\\mathbf{w}$ 为梯形权重的向量，$\\boldsymbol{\\varepsilon}_{\\mathrm{eq}}$ 为节点上局部应变值的向量。计算的核心涉及构建一个大小为 $N \\times N$ 的核矩阵 $\\mathbf{A}$，其中每个元素 $A_{ji}$ 由下式给出：\n$$\nA_{ji} = \\alpha(\\lvert x_j - x_i \\rvert) = \\exp\\left(-\\frac{\\lvert x_j - x_i \\rvert}{\\ell}\\right)\n$$\n然后，非局部等效应变向量 $\\bar{\\boldsymbol{\\varepsilon}}_{\\mathrm{eq}}$ 按以下方式计算：\n1.  定义节点向量 $\\mathbf{x} = [x_1, \\dots, x_N]^T$。\n2.  定义权重向量 $\\mathbf{w} = [w_1, \\dots, w_N]^T$。\n3.  在节点处评估局部应变场以得到 $\\boldsymbol{\\varepsilon}_{\\mathrm{eq}} = [\\varepsilon_{\\mathrm{eq}}(x_1), \\dots, \\varepsilon_{\\mathrm{eq}}(x_N)]^T$。\n4.  构建距离矩阵 $\\mathbf{D}$，其元素为 $D_{ji} = \\lvert x_j - x_i \\rvert$。\n5.  构建核矩阵 $\\mathbf{A} = \\exp(-\\mathbf{D}/\\ell)$。\n6.  计算分子向量 $\\mathbf{n} = \\mathbf{A} (\\boldsymbol{\\varepsilon}_{\\mathrm{eq}} \\odot \\mathbf{w})$，其中 $\\odot$ 表示逐元素（Hadamard）积。这对应于每个 $j$ 的分子中的求和。\n7.  计算分母向量 $\\mathbf{d} = \\mathbf{A} \\mathbf{w}$。这对应于每个 $j$ 的分母中的求和。\n8.  最终结果通过逐元素除法获得：$\\bar{\\boldsymbol{\\varepsilon}}_{\\mathrm{eq}} = \\mathbf{n} \\oslash \\mathbf{d}$。\n\n将此过程应用于每个指定的测试用例。\n-   **测试用例A** 验证了非局部算子应保持常数场不变的基本性质。与常数值的偏差应在机器精度量级。\n-   **测试用例B** 演示了非局部算子的主要功能：平滑一个尖锐的不连续性（一个顶帽函数）。由于与周围的零应变区域进行了平均，帽中心的数值将小于局部峰值。\n-   **测试用例C** 检验了当内禀长度 $\\ell$ 相对于域大小 $L$ 很大时的极限情况。在此极限下，指数核函数 $\\alpha(r)$ 在整个域上变得几乎恒定，非局部平均值应收敛到局部场的简单空间平均值，计算公式为 $\\varepsilon_{\\mathrm{mean}} = \\frac{1}{L}\\int_0^L \\varepsilon_{\\mathrm{eq}}(x) \\mathrm{d}x$。\n-   **测试用例D** 检验了相反的极限情况，即内禀长度 $\\ell$ 很小，与网格间距 $h$ 处于同一量级。此时核函数变得非常尖锐，近似于一个狄拉克δ函数，非局部值应收敛到局部值。\n-   **测试用例E** 旨在探究边界效应。对于边界附近的一个点 $x_j$（例如 $x_1=0$），积分被截断。对于像线性梯度 $\\varepsilon_{\\mathrm{eq}}(x) = x/L$ 这样的非常数场，这种截断将导致非局部平均值与局部值显著不同。特别是在 $x=0$ 处，平均值仅包含来自 $\\xi \\ge 0$ 的贡献，即使局部应变为 $\\varepsilon_{\\mathrm{eq}}(0)=0$，也会导致一个正值。\n\n该算法使用 NumPy 库在一个 Python 脚本中实现，以进行高效的数组操作，遵循了上文概述的向量化策略。每个测试用例都按顺序执行，结果被收集并按规定格式化。", "answer": "```python\nimport numpy as np\n\ndef compute_nonlocal_average(L, N, ell, local_eps_func):\n    \"\"\"\n    Computes the discrete nonlocal average for a 1D bar.\n\n    Args:\n        L (float): Length of the bar.\n        N (int): Number of discretization nodes.\n        ell (float): Internal length scale.\n        local_eps_func (callable): A function that takes a numpy array of node\n                                   positions `x` and returns the local strain field.\n\n    Returns:\n        tuple: A tuple containing:\n            - x_nodes (np.ndarray): The positions of the domain nodes.\n            - eps_nonlocal (np.ndarray): The computed nonlocal equivalent strain at each node.\n    \"\"\"\n    # 1. Discretize the domain and define grid spacing\n    x_nodes = np.linspace(0, L, N)\n    if N > 1:\n        h = L / (N - 1)\n    else:\n        h = 0.0 # Handle case N=1\n\n    # 2. Define trapezoidal integration weights\n    w_weights = np.full(N, h)\n    if N > 1:\n        w_weights[0] = h / 2.0\n        w_weights[-1] = h / 2.0\n\n    # 3. Evaluate the local strain field at the nodes\n    eps_local = local_eps_func(x_nodes)\n\n    # 4. Construct the kernel matrix from distances\n    # Use broadcasting to create the distance matrix |x_j - x_i| for all j, i\n    dist_matrix = np.abs(x_nodes[:, np.newaxis] - x_nodes)\n    alpha_matrix = np.exp(-dist_matrix / ell)\n\n    # 5. Compute the nonlocal average using vectorized operations\n    # Numerator: sum_i(alpha_ji * eps_i * w_i) for each j\n    numerator = alpha_matrix @ (eps_local * w_weights)\n    \n    # Denominator: sum_i(alpha_ji * w_i) for each j\n    denominator = alpha_matrix @ w_weights\n\n    # Element-wise division to get the nonlocal strain at each node\n    # Add a small epsilon to the denominator to prevent division by zero in pathological cases,\n    # though not strictly necessary for an exponential kernel over a non-zero domain.\n    eps_nonlocal = numerator / (denominator + 1e-18)\n    \n    return x_nodes, eps_nonlocal\n\ndef solve():\n    \"\"\"\n    Runs all test cases and prints the results in the required format.\n    \"\"\"\n    results = []\n\n    # Test Case A: Uniform invariance\n    L_A, N_A, ell_A = 1.0, 101, 0.05\n    local_eps_A = lambda x: np.full_like(x, 0.01)\n    _, eps_nonlocal_A = compute_nonlocal_average(L_A, N_A, ell_A, local_eps_A)\n    result_A = np.max(np.abs(eps_nonlocal_A - 0.01))\n    results.append(result_A)\n\n    # Test Case B: Localized top-hat, center value\n    L_B, N_B, ell_B = 1.0, 1001, 0.1\n    # Use a small tolerance for floating point comparisons at boundaries\n    local_eps_B = lambda x: 0.02 * ((x >= 0.4 - 1e-9) * (x = 0.6 + 1e-9))\n    x_nodes_B, eps_nonlocal_B = compute_nonlocal_average(L_B, N_B, ell_B, local_eps_B)\n    center_index_B = (N_B - 1) // 2 # N is odd, index corresponds to x=0.5\n    result_B = eps_nonlocal_B[center_index_B]\n    results.append(result_B)\n\n    # Test Case C: Large internal length, approach to mean\n    L_C, N_C, ell_C = 1.0, 1001, 1.0\n    local_eps_C = local_eps_B  # Same local field as B\n    x_nodes_C, eps_nonlocal_C = compute_nonlocal_average(L_C, N_C, ell_C, local_eps_C)\n    center_index_C = (N_C - 1) // 2\n    theoretical_mean = 0.004\n    result_C = np.abs(eps_nonlocal_C[center_index_C] - theoretical_mean)\n    results.append(result_C)\n\n    # Test Case D: Near-local limit at center\n    L_D, N_D = 1.0, 1001\n    h_D = L_D / (N_D - 1)\n    ell_D = h_D\n    local_eps_D = local_eps_B  # Same local field as B\n    x_nodes_D, eps_nonlocal_D = compute_nonlocal_average(L_D, N_D, ell_D, local_eps_D)\n    center_index_D = (N_D - 1) // 2\n    local_center_value_D = 0.02\n    result_D = np.abs(eps_nonlocal_D[center_index_D] - local_center_value_D)\n    results.append(result_D)\n\n    # Test Case E: Boundary effect for a gradient\n    L_E, N_E, ell_E = 1.0, 201, 0.1\n    local_eps_E = lambda x: x / L_E\n    x_nodes_E, eps_nonlocal_E = compute_nonlocal_average(L_E, N_E, ell_E, local_eps_E)\n    result_E = eps_nonlocal_E[0]  # Value at the left boundary, x=0\n    results.append(result_E)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "3546153"}, {"introduction": "任何数值方法的可靠性都取决于其收敛性，即随着网格加密，数值解应逼近真实解。在掌握了非局部算子的基本实现后，评估其精度和收敛特性便成为下一个关键步骤。本练习旨在通过与一个高度加密的参考解进行比较，来量化离散化误差，从而让您深入理解网格密度如何影响计算结果的准确性，这是计算分析中一项基本且必要的技能 [@problem_id:3546150]。", "problem": "考虑一个占据区间 $\\Omega = [0,L]$ 的一维杆，其中 $L  0$ 的单位为米。设等效应变场是一个局部化的、非均匀的确定性函数 $\\varepsilon(\\xi)$，对于 $\\xi \\in \\Omega$ 定义为\n$$\n\\varepsilon(\\xi) = \\varepsilon_0 \\exp\\!\\left(-\\frac{|\\xi - x_0|}{\\beta}\\right),\n$$\n其中 $\\varepsilon_0  0$ 是无量纲的峰值应变，$x_0 \\in (0,L)$ 是应变带中心的坐标（单位为米），$\\beta  0$ 是局部化宽度（单位为米）。为了在计算岩土力学（Computational Geomechanics）中对应变局部化进行正则化，在点 $x \\in \\Omega$ 处的非局部积分平均值 $\\bar{\\varepsilon}(x)$ 被定义为截断的、重新归一化的卷积\n$$\n\\bar{\\varepsilon}(x) = \\frac{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,\\varepsilon(\\xi)\\,d\\xi}{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,d\\xi},\n$$\n其中 $\\alpha(x,\\xi)$ 是一个非负权重函数（核函数），分母在截断的域上强制执行精确的归一化。使用特征长度为 $\\ell  0$ 的高斯核函数，\n$$\n\\alpha(x,\\xi) = \\exp\\!\\left(-\\frac{(x-\\xi)^2}{2\\ell^2}\\right),\n$$\n其中 $\\ell$ 的单位为米。应变 $\\varepsilon(\\xi)$ 是无量纲的，因此 $\\bar{\\varepsilon}(x)$ 也是无量纲的。\n\n您的任务是研究离散非局部算子在网格细化下的收敛性，该算子基于包含 $N$ 个相等单元（$N \\in \\mathbb{N}$）的一维网格，通过均匀黎曼和（uniform Riemann sums）来近似上述积分。具体来说，在一个网格间距为 $h = L/N$、单元中心为 $\\xi_i = (i+\\tfrac{1}{2})h$（$i = 0,1,\\dots,N-1$）的网格上定义离散近似：\n$$\n\\bar{\\varepsilon}_N(x) = \\frac{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)\\,h}{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,h}.\n$$\n将上述公式视为应用于分子和分母的复合中点法则。对于同一评估点 $x$ 的参考（基准）值，使用相同的离散公式和由 $N_{\\mathrm{ref}}$ 个单元组成的非常精细的网格来计算 $\\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)$。定义绝对离散误差\n$$\ne_N(x) = \\big|\\bar{\\varepsilon}_N(x) - \\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)\\big|.\n$$\n\n从非局部平均和数值积分（黎曼和）的核心定义出发，实现一个程序，该程序对下面的每个测试用例，使用指定的参数计算绝对误差 $e_N(x)$。所有应变都是无量纲的，因此 $e_N(x)$ 必须报告为无量纲的十进制数。\n\n对所有测试用例使用以下固定参数：\n- $L = 1.0$ 米，\n- $\\varepsilon_0 = 0.02$，\n- $x_0 = 0.5$ 米，\n- $\\beta = 0.01$ 米，\n- $N_{\\mathrm{ref}} = 100000$。\n\n该测试套件包含以下六个案例，每个案例以元组 $(\\ell, N, x)$ 的形式给出，其中 $\\ell$ 的单位为米，$N$ 是单元的整数数量，$x$ 的单位为米：\n1. $(0.05, 20, 0.5)$ 中等核函数与粗糙网格的内部求值，\n2. $(0.05, 40, 0.5)$ 中等核函数与精细网格的内部求值，\n3. $(0.05, 20, 0.02)$ 近边界求值以测试重新归一化，\n4. $(0.005, 20, 0.5)$ 网格分辨率不足的小特征长度，\n5. $(0.005, 400, 0.5)$ 通过细化得到良好解析的小特征长度，\n6. $(0.05, 40, 0.8)$ 远离局部化中心的求值。\n\n您的程序必须：\n- 按照所述实现非局部平均，对具有 $N$ 个单元的粗糙网格和具有 $N_{\\mathrm{ref}}$ 个单元的参考网格，均在均匀分区上使用复合中点法则，\n- 为每个测试用例计算 $e_N(x)$，\n- 生成单行输出，其中包含六个结果，按上述测试用例的顺序以逗号分隔的列表形式，并用方括号括起来。每个结果必须是十进制数（浮点数）。例如，一个有效的输出格式类似于 $[r_1,r_2,r_3,r_4,r_5,r_6]$。\n\n不涉及角度。最终的数值输出中不出现物理单位，因为应变是无量纲的，误差 $e_N(x)$ 也是无量纲的。数值必须按规定计算，不得进行额外缩放。最终输出行必须与要求的确切格式相匹配。", "solution": "该问题定义明确且科学上合理，要求实现并评估一种用于计算力学中应变局部化问题的数值方法。我将继续提供解决方案。\n\n该问题要求计算非局部积分算子的数值近似的离散误差。该算子用于计算岩土力学中，对表现出应变局部化（即变形集中在狭窄带内的现象）的解进行正则化。非局部公式将一个点上的局部量（应变）替换为该量在有限邻域内的加权平均值，这在数学上对应于一个卷积积分。\n\n首先，我们定义基本量。一维局部等效应变场 $\\varepsilon(\\xi)$ 由下式给出\n$$\n\\varepsilon(\\xi) = \\varepsilon_0 \\exp\\!\\left(-\\frac{|\\xi - x_0|}{\\beta}\\right)\n$$\n对于域 $\\Omega = [0, L]$ 中的 $\\xi$。此处，$\\varepsilon_0 = 0.02$ 是无量纲峰值应变，$x_0 = 0.5$ 米是局部化带的中心，$\\beta = 0.01$ 米是该带的特征宽度。域长度为 $L=1.0$ 米。\n\n在点 $x \\in \\Omega$ 处的非局部平均应变 $\\bar{\\varepsilon}(x)$ 通过重新归一化的卷积定义：\n$$\n\\bar{\\varepsilon}(x) = \\frac{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,\\varepsilon(\\xi)\\,d\\xi}{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,d\\xi}\n$$\n权重函数 $\\alpha(x,\\xi)$ 是一个特征长度为 $\\ell$ 的高斯核函数：\n$$\n\\alpha(x,\\xi) = \\exp\\!\\left(-\\frac{(x-\\xi)^2}{2\\ell^2}\\right)\n$$\n表达式 $\\bar{\\varepsilon}(x)$ 中的分母是一个归一化因子。它确保了尽管积分被截断到有限域 $[0, L]$ 上，平均特性仍然得以保持。当求值点 $x$ 靠近边界时，这一点尤其重要，因为高斯核函数支撑的很大一部分可能位于域外。\n\n问题要求我们使用复合中点法则来近似这些积分。对于一个包含 $N$ 个均匀单元的网格，域 $[0, L]$ 被划分为 $N$ 个子区间，每个子区间的宽度为 $h = L/N$。第 $i$ 个单元（对于 $i=0, \\dots, N-1$）的中点是 $\\xi_i = (i+\\frac{1}{2})h$。一个通用函数 $f(\\xi)$ 的积分则近似为：\n$$\n\\int_0^L f(\\xi) d\\xi \\approx \\sum_{i=0}^{N-1} f(\\xi_i) h\n$$\n将此数值积分法则应用于 $\\bar{\\varepsilon}(x)$ 表达式的分子和分母，得到离散非局部平均值 $\\bar{\\varepsilon}_N(x)$：\n$$\n\\bar{\\varepsilon}_N(x) = \\frac{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)\\,h}{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,h}\n$$\n网格间距 $h$ 是分子和分母求和中的一个常数因子，因此可以消去。这将离散公式简化为在单元中心处求值的应变值的加权平均：\n$$\n\\bar{\\varepsilon}_N(x) = \\frac{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)}{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)}\n$$\n任务的核心是基于此公式实现一个函数。该函数将以网格大小 $N$ 和物理参数 $(\\ell, x)$ 作为输入，并返回 $\\bar{\\varepsilon}_N(x)$ 的值。\n\n为了量化此近似的精度，我们定义绝对离散误差 $e_N(x)$。由于 $\\bar{\\varepsilon}(x)$ 的解析解不易获得，我们采用一种常见的数值分析技术：与一个高度精细化的数值解进行比较。我们使用相同的离散公式，但用一个非常大的单元数 $N_{\\mathrm{ref}} = 100000$ 来计算一个参考值 $\\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)$。该值被假定为真实连续结果的一个精确近似。然后，误差定义为：\n$$\ne_N(x) = \\big|\\bar{\\varepsilon}_N(x) - \\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)\\big|\n$$\n解决每个测试用例 $(\\ell, N, x)$ 的算法如下：\n1.  定义一个函数 `calculate_nonlocal_average`，该函数实现 $\\bar{\\varepsilon}_N(x)$ 的公式。此函数将：\n    a. 计算网格间距 $h = L/N$。\n    b. 生成一个包含 $N$ 个单元中点 $\\xi_i$ 的数组。\n    c. 对数组中所有的点计算 $\\varepsilon(\\xi_i)$ 和 $\\alpha(x, \\xi_i)$。\n    d. 计算分子和 $\\sum \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)$ 和分母和 $\\sum \\alpha(x,\\xi_i)$。\n    e. 返回这两个和的比率。\n2.  对于每个给定的测试用例 $(\\ell, N, x)$：\n    a. 使用指定的 $N$ 调用 `calculate_nonlocal_average` 以计算 $\\bar{\\varepsilon}_N(x)$。\n    b. 使用 $N_{\\mathrm{ref}}$ 调用 `calculate_nonlocal_average` 以计算参考值 $\\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)$。\n    c. 计算绝对误差 $e_N(x)$。\n3.  将所有测试用例的误差收集到一个列表中。\n4.  根据指定的输出格式格式化并打印误差列表。对所提供的所有六个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_nonlocal_average(N, L, x, epsilon_0, x_0, beta, ell):\n    \"\"\"\n    Computes the discrete nonlocal average strain using the composite midpoint rule.\n\n    Args:\n        N (int): Number of elements in the mesh.\n        L (float): Length of the 1D bar.\n        x (float): Evaluation point for the nonlocal average.\n        epsilon_0 (float): Peak strain.\n        x_0 (float): Center of the strain localization band.\n        beta (float): Width of the strain localization band.\n        ell (float): Characteristic length of the Gaussian kernel.\n\n    Returns:\n        float: The calculated discrete nonlocal average strain.\n    \"\"\"\n    # 1. Generate the mesh\n    # Mesh spacing\n    h = L / N\n    # Element centers (midpoints)\n    xi_points = (np.arange(N) + 0.5) * h\n\n    # 2. Evaluate the strain field and the weight function at the mesh points\n    # Local strain field values\n    epsilon_vals = epsilon_0 * np.exp(-np.abs(xi_points - x_0) / beta)\n    \n    # Weight function values\n    alpha_vals = np.exp(-(x - xi_points)**2 / (2 * ell**2))\n\n    # 3. Compute the sums for the numerator and denominator\n    # The term 'h' from the Riemann sum cancels out.\n    numerator = np.sum(alpha_vals * epsilon_vals)\n    denominator = np.sum(alpha_vals)\n\n    # 4. Compute the nonlocal average\n    # The denominator should not be zero for a non-zero domain and Gaussian kernel.\n    # A check is included for numerical robustness.\n    if denominator == 0.0:\n        return 0.0\n\n    return numerator / denominator\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and compute the discretization errors.\n    \"\"\"\n    # Define the fixed parameters from the problem statement.\n    L = 1.0\n    epsilon_0 = 0.02\n    x_0 = 0.5\n    beta = 0.01\n    N_ref = 100000\n\n    # Define the test cases as tuples of (ell, N, x).\n    test_cases = [\n        (0.05, 20, 0.5),    # 1. Interior evaluation, moderate kernel, coarse mesh\n        (0.05, 40, 0.5),    # 2. Interior evaluation, moderate kernel, refined mesh\n        (0.05, 20, 0.02),   # 3. Near-boundary evaluation\n        (0.005, 20, 0.5),   # 4. Small kernel, poorly resolved\n        (0.005, 400, 0.5),  # 5. Small kernel, well resolved\n        (0.05, 40, 0.8),    # 6. Evaluation away from localization center\n    ]\n\n    results = []\n    for ell, N, x in test_cases:\n        # Calculate the approximate value with N elements\n        eps_bar_N = calculate_nonlocal_average(N, L, x, epsilon_0, x_0, beta, ell)\n        \n        # Calculate the reference value with N_ref elements\n        eps_bar_N_ref = calculate_nonlocal_average(N_ref, L, x, epsilon_0, x_0, beta, ell)\n        \n        # Compute the absolute discretization error\n        error = np.abs(eps_bar_N - eps_bar_N_ref)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3546150"}, {"introduction": "掌握了非局部模型的实现与验证后，我们便可以将其应用于解决岩土力学中的核心问题——预测应变局部化。本练习将非局部积分模型置于线性稳定性分析的框架内，用以预测剪切带的物理宽度。通过将其预测结果与另一种正则化方法（梯度损伤模型）以及设定的“观测”数据进行对比，本练习不仅展示了非局部理论的实际应用价值，也揭示了模型选择在模拟物理现象时的重要性 [@problem_id:3546155]。", "problem": "考虑一个沿空间坐标 $x \\in \\mathbb{R}$ 的平面应变直接剪切试验的一维表示，其中剪切应变场用 $\\gamma(x)$ 表示。使用一个标量损伤型本构模型，其中应力响应随着由非局部等效剪应变 $\\bar{\\gamma}(x)$ 控制的负切线（软化）斜率 $H  0$ 而软化，而未损伤的剪切模量为 $G0$。考虑了两种正则化方法：积分非局部模型和梯度损伤模型。目标是，在给定的材料和加载参数下，确定哪种正则化方法能更准确地再现观测到的剪切带宽度，同时控制单位面积的断裂能、内禀长度和软化斜率。\n\n基本原理和定义：\n- 在积分非局部模型中，非局部等效剪应变由归一化卷积定义\n$$\n\\bar{\\gamma}(x) = \\int_{-\\infty}^{\\infty} w_n(|x-y|)\\,\\gamma(y)\\,\\mathrm{d}y,\n$$\n其中归一化高斯权重函数为\n$$\nw_n(r) = \\frac{\\exp\\!\\left[-(r/l)^2\\right]}{\\int_{-\\infty}^{\\infty}\\exp\\!\\left[-(s/l)^2\\right]\\mathrm{d}s} = \\frac{1}{\\sqrt{\\pi}\\,l}\\,\\exp\\!\\left[-(r/l)^2\\right],\n$$\n且 $l0$ 是内禀长度尺度。$w_n(r)$ 的傅里叶变换为\n$$\n\\widehat{w_n}(k) = \\int_{-\\infty}^{\\infty} w_n(r)\\,e^{-i k r}\\,\\mathrm{d}r = \\exp\\!\\left[-\\left(\\frac{k\\,l}{2}\\right)^2\\right],\n$$\n其中 $k \\ge 0$ 是谐波扰动 $\\delta\\gamma(x)=A\\,e^{i k x}$ 的波数。\n\n- 在梯度损伤模型中，亥姆霍兹型非局部性在傅里叶空间中由以下关系给出\n$$\n\\widehat{\\bar{\\gamma}}(k) = \\frac{\\widehat{\\gamma}(k)}{1 + l^2 k^2},\n$$\n这是微分算子 $(1 - l^2 \\partial_{xx})^{-1}$ 在无穷远处梯度消失的条件下应用于 $\\gamma(x)$ 的傅里叶符号。\n\n局部化的线性稳定性分析：\n- 考虑对均匀基态施加一个无穷小谐波扰动 $\\delta\\gamma(x)=A e^{i k x}$。软化过程中的有效增量剪切模量取决于对 $\\delta\\gamma$ 的非局部滤波：\n    - 对于积分非局部模型，滤波后的扰动为 $\\delta\\bar{\\gamma} = \\widehat{w_n}(k)\\,\\delta\\gamma$，得到有效切线模量\n    $$\n    G_{\\text{eff,int}}(k) = G + H\\,\\widehat{w_n}(k).\n    $$\n    - 对于梯度损伤模型，滤波后的扰动为 $\\delta\\bar{\\gamma} = \\delta\\gamma/(1+l^2 k^2)$，得到有效切线模量\n    $$\n    G_{\\text{eff,grad}}(k) = G + \\frac{H}{1 + l^2 k^2}.\n    $$\n- 当有效切线模量对于某个 $k \\ge 0$ 首次达到零时，即为局部化（椭圆性丧失）的开始。\n    - 积分非局部模型：求解 $G + H \\exp\\!\\left[-(k l/2)^2\\right] = 0$ 以得到 $k$，当满足 $|H| \\ge G$ 时，可得\n    $$\n    \\exp\\!\\left[-\\left(\\frac{k\\,l}{2}\\right)^2\\right] = \\frac{G}{|H|} \\quad \\Rightarrow \\quad k_{\\text{int}} = \\frac{2}{l}\\,\\sqrt{-\\ln\\!\\left(\\frac{G}{|H|}\\right)}.\n    $$\n    如果 $|H|  G$，则不存在满足此方程的实值波数 $k$，因此不会发生局部化。\n    - 梯度损伤模型：求解 $G + H / (1 + l^2 k^2) = 0$ 以得到 $k$，当满足 $|H| \\ge G$ 时，可得\n    $$\n    1 + l^2 k^2 = \\frac{|H|}{G} \\quad \\Rightarrow \\quad k_{\\text{grad}} = \\frac{1}{l}\\,\\sqrt{\\frac{|H|}{G} - 1}.\n    $$\n- 由此产生的局部化或剪切带的特征宽度 $w$（单位为米）与波数的倒数成正比，定义为 $w = \\pi/k$。\n\n任务：\n为每个测试用例确定积分非局部模型（返回0）或梯度损伤模型（返回1）是否能更好地再现观测数据。如果两个模型都无法预测一个有限的、非零的剪切带宽度，则返回-1。\n\n决策标准：\n选择使组合误差指标 $E = e_w + e_g$ 最小化的模型，其中：\n1. 相对宽度误差：$e_w = |(w_{\\text{model}} / w_{\\text{obs}}) - 1|$。\n2. 相对断裂能误差：$e_g = |(G_{f,\\text{pred}} / G_f) - 1|$。\n   - 预测的断裂能 $G_{f,\\text{pred}} = g_{\\text{loc}} \\cdot w_{\\text{model}}$。\n   - 每单位体积的局部能量耗散 $g_{\\text{loc}} = (1/2) \\tau_p^2 / |H|$，其中 $\\tau_p$ 是峰值剪切强度。\n\n测试用例（参数按 $(G, H, l, \\tau_p, G_f, w_{\\text{obs}})$ 的顺序给出，单位分别为Pa, Pa, m, Pa, J/m$^2$, m）：\n1. $(1.0 \\times 10^{10}, -2.0 \\times 10^{10}, 0.01, 5.0 \\times 10^7, 5000, 0.025)$\n2. $(1.0 \\times 10^{10}, -1.0 \\times 10^{10}, 0.02, 6.0 \\times 10^7, 4000, 0.03)$\n3. $(1.5 \\times 10^{10}, -7.5 \\times 10^9, 0.015, 4.0 \\times 10^7, 3000, 0.02)$\n4. $(1.0 \\times 10^{10}, -5.0 \\times 10^{10}, 0.005, 8.0 \\times 10^7, 8000, 0.01)$\n5. $(1.0 \\times 10^{10}, -3.0 \\times 10^{10}, 0.002, 7.0 \\times 10^7, 6000, 0.006)$\n6. $(1.0 \\times 10^{10}, -2.0 \\times 10^{10}, 0.01, 5.0 \\times 10^7, 1200, 0.0189)$\n\n您的程序必须实现从基本原理出发的计算，处理所有六个案例，并生成一个单行输出，其中包含一个用方括号括起来的、由逗号分隔的结果列表（例如，`[r_1,r_2,r_3,r_4,r_5,r_6]`）。", "solution": "用户提供的问题被评估为有效。它在科学上基于连续介质损伤力学和应变局部化的原理，特别是使用了非局部正则化技术。所有定义、模型和参数都已提供，使得问题自成体系且适定。该任务是基于清晰的数学标准，对两种标准模型进行的客观、定量的比较。所提供的物理参数对于地质力学应用是符合实际的。\n\n解决方案是通过对每个测试案例实施指定的计算来推进的。对于参数为 $(G, H, l, \\tau_p, G_f, w_{\\text{obs}})$ 的单个测试案例，其总体步骤如下：\n\n1.  **检查局部化**：第一步是评估局部化开始的条件，即 $|H| \\ge G$。参数 $G$ 和 $H$ 分别是弹性剪切模量和软化模量。\n    *   如果 $|H|  G$，则两种模型都不会发生应变局部化。特征波数 $k$ 不是实数，因此剪切带宽度 $w$ 未定义。在实现中，这表示为非数值（$NaN$）。\n    *   如果 $|H| = G$，这是分岔阈值。分析得出两个模型的特征波数均为 $k=0$，对应于无穷大的剪切带宽度，$w = \\infty$。\n    *   如果 $|H|  G$，则会发生具有有限非零波数 $k  0$ 的局部化，从而产生有限的剪切带宽度 $w$。\n\n2.  **计算预测的剪切带宽度**：如果预测到具有有限宽度的局部化（$|H|  G$），则计算积分非局部模型（$w_{\\text{int}}$）和梯度损伤模型（$w_{\\text{grad}}$）的剪切带宽度。\n    *   积分模型的波数由下式给出\n        $$\n        k_{\\text{int}} = \\frac{2}{l}\\,\\sqrt{-\\ln\\!\\left(\\frac{G}{|H|}\\right)}\n        $$\n        相应的宽度为 $w_{\\text{int}} = \\pi/k_{\\text{int}}$。\n    *   梯度模型的波数由下式给出\n        $$\n        k_{\\text{grad}} = \\frac{1}{l}\\,\\sqrt{\\frac{|H|}{G}-1}\n        $$\n        相应的宽度为 $w_{\\text{grad}} = \\pi/k_{\\text{grad}}$。\n\n3.  **评估模型性能**：对于每个得出有限正宽度的模型，计算两个误差指标：相对宽度误差（$e_w$）和相对断裂能误差（$e_g$）。\n    *   相对宽度误差衡量预测宽度 $w_{\\text{model}}$ 与观测宽度 $w_{\\text{obs}}$ 的偏差：\n        $$\n        e_w = \\left| \\frac{w_{\\text{model}}}{w_{\\text{obs}}} - 1 \\right|\n        $$\n    *   断裂能误差将模型预测的断裂能 $G_{f,\\text{pred}}$ 与观测到的断裂能 $G_f$ 进行比较。预测的断裂能是通过将单位体积耗散的局部能量 $g_{\\text{loc}}$ 在带宽度 $w_{\\text{model}}$ 上积分计算得出的：\n        $$\n        G_{f,\\text{pred}} = g_{\\text{loc}} \\cdot w_{\\text{model}} = \\left(\\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|}\\right) w_{\\text{model}}\n        $$\n        相对误差则为：\n        $$\n        e_g = \\left| \\frac{G_{f,\\text{pred}}}{G_f} - 1 \\right|\n        $$\n    *   一个组合误差指标 $E$ 定义为这两个误差之和：\n        $$\n        E = e_w + e_g\n        $$\n\n4.  **应用决策规则**：根据每个测试案例计算的宽度和误差做出最终决策。\n    *   如果两个模型都预测宽度未定义（$NaN$）或无穷大，则结果为 $-1$。\n    *   如果只有一个模型预测出有限的正宽度，则选择该模型。结果为 $0$ 表示积分模型，为 $1$ 表示梯度模型。\n    *   如果两个模型都预测出有限的正宽度，则选择组合误差 $E$ 较小的模型。返回值同样是积分模型为 $0$，梯度模型为 $1$。\n\n将此过程应用于所提供的六个测试案例中的每一个，并将结果汇编成一个最终列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(G, H, l, tau_p, G_f, w_obs):\n    \"\"\"\n    Solves a single test case for the nonlocal regularization problem.\n\n    Args:\n        G (float): Shear modulus (Pa).\n        H (float): Softening slope (Pa).\n        l (float): Internal length (m).\n        tau_p (float): Peak shear strength (Pa).\n        G_f (float): Observed fracture energy (J/m^2).\n        w_obs (float): Observed shear band width (m).\n\n    Returns:\n        int: -1 for no unique finite solution, 0 for integral model, 1 for gradient model.\n    \"\"\"\n    abs_H = np.abs(H)\n\n    # Initialize widths to NaN (Not a Number)\n    w_int = np.nan\n    w_grad = np.nan\n\n    # Check localization condition: |H| must be >= G\n    if abs_H  G:\n        # No localization predicted by either model\n        w_int = np.nan\n        w_grad = np.nan\n    elif abs_H == G:\n        # Bifurcation threshold, infinite wavelength/width\n        w_int = np.inf\n        w_grad = np.inf\n    else: # abs_H > G, finite width localization\n        # Integral model\n        ratio_int = G / abs_H\n        k_int = (2 / l) * np.sqrt(-np.log(ratio_int))\n        if k_int > 0:\n            w_int = np.pi / k_int\n        else: # Should not happen if abs_H > G\n            w_int = np.inf\n\n        # Gradient model\n        ratio_grad = abs_H / G\n        k_grad = (1 / l) * np.sqrt(ratio_grad - 1)\n        if k_grad > 0:\n            w_grad = np.pi / k_grad\n        else: # Should not happen if abs_H > G\n            w_grad = np.inf\n\n    # Check validity of predicted widths\n    is_int_valid = np.isfinite(w_int) and w_int > 0\n    is_grad_valid = np.isfinite(w_grad) and w_grad > 0\n\n    # Apply decision rules\n    if not is_int_valid and not is_grad_valid:\n        return -1\n    elif is_int_valid and not is_grad_valid:\n        return 0\n    elif not is_int_valid and is_grad_valid:\n        return 1\n    else: # Both are valid, compare combined error E\n        # Local energy dissipation per unit volume\n        g_loc = 0.5 * (tau_p**2) / abs_H\n\n        # Errors for integral model\n        G_f_pred_int = g_loc * w_int\n        e_w_int = np.abs(w_int / w_obs - 1)\n        e_g_int = np.abs(G_f_pred_int / G_f - 1)\n        E_int = e_w_int + e_g_int\n\n        # Errors for gradient model\n        G_f_pred_grad = g_loc * w_grad\n        e_w_grad = np.abs(w_grad / w_obs - 1)\n        e_g_grad = np.abs(G_f_pred_grad / G_f - 1)\n        E_grad = e_w_grad + e_g_grad\n        \n        return 0 if E_int = E_grad else 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (G, H, l, tau_p, G_f, w_obs)\n    test_cases = [\n        (1.0e10, -2.0e10, 0.01, 5.0e7, 5000, 0.025),\n        (1.0e10, -1.0e10, 0.02, 6.0e7, 4000, 0.03),\n        (1.5e10, -7.5e9, 0.015, 4.0e7, 3000, 0.02),\n        (1.0e10, -5.0e10, 0.005, 8.0e7, 8000, 0.01),\n        (1.0e10, -3.0e10, 0.002, 7.0e7, 6000, 0.006),\n        (1.0e10, -2.0e10, 0.01, 5.0e7, 1200, 0.0189),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3546155"}]}