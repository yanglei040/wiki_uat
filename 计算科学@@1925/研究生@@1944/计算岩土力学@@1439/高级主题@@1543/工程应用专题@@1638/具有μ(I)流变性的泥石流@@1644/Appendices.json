{"hands_on_practices": [{"introduction": "在掌握了基本计算之后，本练习将 `μ(I)` 模型应用于一个经典的岩土力学问题：判断斜坡上流动的启动条件。通过分析重力驱动力与材料基底阻力（包括黏聚力）之间的平衡，您将评估稳定流动在物理上是否可能。这项练习突显了该模型如何用于预测斜坡稳定性及泥石流启动等真实世界的现象。[@problem_id:3516235]", "problem": "考虑一个厚度均匀的密实饱和颗粒碎屑层，沿一个与水平面成 $\\theta$ 角的刚性斜面下滑。假设流动处于稳定、均匀的状态，因此顺坡方向的 Cauchy 动量平衡简化为重力体力分量与底部剪切阻力之间的局部平衡。设底部剪切应力分解为一个附加的粘聚（速率无关）贡献 $\\tau_{c}$ 和一个由依赖于惯性数 $I$ 的摩擦系数 $\\mu(I)$ 控制的摩擦贡献，其中 $I$ 是惯性数。法向应力为平均岩石静压力 $P$。假设 $\\mu(I)$ 是关于 $I$ 的非递减函数，且 $\\mu(0)=\\mu_{s}$，其中 $\\mu_{s}$ 是静摩擦系数。\n\n从第一性原理出发，推导在斜坡上稳定均匀流得以存在的条件。如果稳定流是容许的，说明如何计算与重力所施加的应力比相一致的惯性数 $I$。使用以下数据：\n- $\\tau_{c}=1$ $\\mathrm{kPa}$，\n- $P=10$ $\\mathrm{kPa}$，\n- $\\mu_{s}=0.4$，\n- $\\theta=15^{\\circ}$。\n\n将最终的惯性数 $I$ 表示为一个纯数。如果对于给定数据，稳定流不容许存在，则报告答案为 $I=0$。无需四舍五入。", "solution": "问题要求推导在斜面上稳定均匀的泥石流得以存在的条件，并计算相应的惯性数 $I$。分析从动量平衡的第一性原理开始。\n\n对于沿倾角为 $\\theta$ 的斜面发生的稳定均匀流动，顺坡方向的动量平衡简化为重力驱动应力 $\\tau_d$ 与底部阻力应力 $\\tau_b$ 之间的平衡。\n\n让我们考虑碎屑层的一个控制体，其底部面积为单位一，并贯穿整个层厚 $H$。设 $\\rho$ 为饱和颗粒材料的容重， $g$ 为重力加速度。该体积材料的重量为 $\\rho g H$。此重量平行于斜面（顺坡）的分量为 $(\\rho g H)\\sin(\\theta)$。由于该力作用于单位底面积上，驱动剪切应力为：\n$$ \\tau_d = \\rho g H \\sin(\\theta) $$\n垂直于斜面方向的重量分量为 $(\\rho g H)\\cos(\\theta)$。该力由底部的法向应力所支撑，问题中给出该法向应力为平均岩石静压力 $P$。因此：\n$$ P = \\rho g H \\cos(\\theta) $$\n将 $\\tau_d$ 的表达式除以 $P$ 的表达式，我们可以用正压力和斜坡角度来表示驱动应力：\n$$ \\frac{\\tau_d}{P} = \\frac{\\rho g H \\sin(\\theta)}{\\rho g H \\cos(\\theta)} = \\tan(\\theta) $$\n因此，由重力施加的驱动剪切应力为：\n$$ \\tau_d = P \\tan(\\theta) $$\n\n问题指出，底部剪切阻力 $\\tau_b$ 由一个粘聚（速率无关）部分 $\\tau_c$ 和一个依赖于惯性数 $I$ 的摩擦部分组成。摩擦部分由摩擦系数 $\\mu(I)$ 和正压力 $P$ 的乘积给出。因此，总的底部阻力为：\n$$ \\tau_b = \\tau_c + \\mu(I) P $$\n\n为了使稳定均匀流存在，驱动应力必须与阻力应力完全平衡：\n$$ \\tau_d = \\tau_b $$\n代入上面推导出的表达式：\n$$ P \\tan(\\theta) = \\tau_c + \\mu(I) P $$\n这个方程定义了摩擦系数 $\\mu(I)$ 为维持稳定流动所必须取的值。我们可以求解这个所需的摩擦系数，称之为 $\\mu_{req}$：\n$$ \\mu(I) P = P \\tan(\\theta) - \\tau_c $$\n$$ \\mu_{req} = \\mu(I) = \\tan(\\theta) - \\frac{\\tau_c}{P} $$\n\n这个方程显示了如何确定平衡所需的摩擦系数。然后可以通过对函数 $\\mu(I)$ 求逆来找到惯性数 $I$，即 $I = \\mu^{-1}(\\mu_{req})$。然而，为了使解在物理上是容许的，这个所需的摩擦系数 $\\mu_{req}$ 必须是材料能够实际产生的值。\n\n问题指明了函数 $\\mu(I)$ 的关键性质：对于 $I \\ge 0$，它是 $I$ 的一个非递减函数，并且其在 $I=0$ 处的值（静态情况）是静摩擦系数 $\\mu_s$。即 $\\mu(0) = \\mu_s$。由于 $\\mu(I)$ 是非递减的，其最小可能值为 $\\mu_s$。\n因此，只有当所需的摩擦系数 $\\mu_{req}$ 大于或等于最小可能摩擦系数 $\\mu_s$ 时，稳定流动才可能发生。稳定流容许的条件是：\n$$ \\mu_{req} \\ge \\mu_s $$\n代入 $\\mu_{req}$ 的表达式：\n$$ \\tan(\\theta) - \\frac{\\tau_c}{P} \\ge \\mu_s $$\n这个不等式代表了稳定流得以存在的基本条件。如果满足该条件，则可以存在一个 $I \\ge 0$ 的流动状态。如果不满足，则驱动应力不足以克服材料的最小阻力，材料将保持静止。\n\n我们现在使用提供的数据来检验这个条件：\n- $\\tau_c = 1 \\text{ kPa}$\n- $P = 10 \\text{ kPa}$\n- $\\mu_s = 0.4$\n- $\\theta = 15^{\\circ}$\n\n首先，我们计算所需的摩擦系数 $\\mu_{req}$：\n$$ \\mu_{req} = \\tan(15^{\\circ}) - \\frac{1 \\text{ kPa}}{10 \\text{ kPa}} = \\tan(15^{\\circ}) - 0.1 $$\n$\\tan(15^{\\circ})$ 的精确值可以使用正切的差角公式 $\\tan(A-B) = \\frac{\\tan(A)-\\tan(B)}{1+\\tan(A)\\tan(B)}$ 来求得：\n$$ \\tan(15^{\\circ}) = \\tan(45^{\\circ} - 30^{\\circ}) = \\frac{\\tan(45^{\\circ}) - \\tan(30^{\\circ})}{1+\\tan(45^{\\circ})\\tan(30^{\\circ})} = \\frac{1 - \\frac{1}{\\sqrt{3}}}{1 + (1)\\left(\\frac{1}{\\sqrt{3}}\\right)} = \\frac{\\sqrt{3}-1}{\\sqrt{3}+1} $$\n通过对分母进行有理化，我们得到：\n$$ \\tan(15^{\\circ}) = \\frac{(\\sqrt{3}-1)(\\sqrt{3}-1)}{(\\sqrt{3}+1)(\\sqrt{3}-1)} = \\frac{3 - 2\\sqrt{3} + 1}{3-1} = \\frac{4 - 2\\sqrt{3}}{2} = 2 - \\sqrt{3} $$\n所以，所需的摩擦系数是：\n$$ \\mu_{req} = (2 - \\sqrt{3}) - 0.1 $$\n\n接下来，我们检查容许性条件 $\\mu_{req} \\ge \\mu_s$：\n$$ (2 - \\sqrt{3}) - 0.1 \\ge 0.4 $$\n$$ 2 - \\sqrt{3} \\ge 0.5 $$\n$$ 1.5 \\ge \\sqrt{3} $$\n为了不使用近似值来检查这个不等式，我们可以对两边进行平方，因为两边都是正数：\n$$ (1.5)^2 \\ge (\\sqrt{3})^2 $$\n$$ 2.25 \\ge 3 $$\n这个不等式是错误的。\n\n由于 $\\mu_{req}  \\mu_s$，所需的摩擦系数小于材料能发挥的最小可能摩擦系数（即静态摩擦系数）。这意味着总驱动应力 $\\tau_d = P\\tan(\\theta)$ 小于材料能提供的最小阻力，即零剪切速率下的静态阻力 $\\tau_{b,static} = \\tau_c + \\mu_s P$。\n$$ \\tau_d = 10 \\text{ kPa} \\times \\tan(15^{\\circ}) = 10(2-\\sqrt{3}) \\approx 2.68 \\text{ kPa} $$\n$$ \\tau_{b,static} = 1 \\text{ kPa} + 0.4 \\times 10 \\text{ kPa} = 1 \\text{ kPa} + 4 \\text{ kPa} = 5 \\text{ kPa} $$\n显然，$\\tau_d  \\tau_{b,static}$。重力驱动力不足以克服材料在静止时的摩擦和粘聚阻力。\n\n因此，在给定条件下，稳定均匀流是不容许存在的。碎屑层将保持静止。对于静止的材料，速度梯度为零，因此剪切速率也为零。惯性数 $I$ 被定义为无量纲的剪切速率，所以对于一个静止体，$I=0$。问题说明，如果稳定流不容许存在，则报告 $I=0$。", "answer": "$$\\boxed{0}$$", "id": "3516235"}, {"introduction": "最后的练习旨在弥合理论模型与实验数据之间的鸿沟，这对任何计算科学家而言都是一项至关重要的技能。在这个综合性练习中，您将首先从第一性原理出发，推导深度平均流速的解析模型。接着，您将利用该模型，将 `μ(I)` 定律的流变参数与合成的实验数据进行拟合，这一过程涉及数值优化和不确定性量化。[@problem_id:3516253]", "problem": "您的任务是构建并解决一个参数估计问题，该问题针对固定平面斜坡上的稳态、均匀、稠密的泥石流，使用具有惯性数依赖性的颗粒摩擦定律，通常称为 $\\mu(I)$ 流变模型。目标是根据三个不同坡度角下深度平均速度随流深变化的合成测量数据，来估计摩擦定律的参数，并通过置信区间量化不确定性。所有物理量和变量都必须严格处理，并以标准国际单位制表示。\n\n假设一个单相、稠密、不可压缩的颗粒与流体混合物沿倾角为 $\\theta$（单位为度）的斜坡向下流动。考虑一个笛卡尔坐标系，其中 $z$ 轴垂直于底床，$z=0$ 位于底床处，$z=h$ 位于自由表面处。重力加速度为 $g$，单位为 $\\mathrm{m/s^2}$。混合物（整体）密度为 $\\rho_m$，单位为 $\\mathrm{kg/m^3}$，颗粒密度为 $\\rho_s$，单位为 $\\mathrm{kg/m^3}$。特征粒径为 $d$，单位为 $\\mathrm{m}$。令 $u(z)$ 表示流向速度剖面，$\\overline{u}$ 表示深度平均速度，其定义为\n$$\n\\overline{u} = \\frac{1}{h} \\int_0^h u(z) \\, dz,\n$$\n其中 $\\overline{u}$ 的单位为 $\\mathrm{m/s}$，流深 $h$ 的单位为 $\\mathrm{m}$。\n\n使用以下经过充分检验的基本原理：\n- 牛顿第二定律应用于稳态、均匀、充分发展的流动，意味着重力驱动与内应力之间达到平衡。层内的局部剪切应力 $\\tau(z)$ 和法向应力 $p(z)$ 满足\n$$\n\\tau(z) = \\rho_m g (h - z) \\sin\\theta_r, \\quad p(z) = \\rho_m g (h - z) \\cos\\theta_r,\n$$\n其中 $\\theta_r$ 是以弧度为单位的坡度角，且 $\\tan\\theta_r = \\tau(z)/p(z)$ 与 $z$ 无关。\n- 具有惯性数依赖性的颗粒摩擦定律为\n$$\n\\mu(I) = \\mu_s + \\frac{\\mu_2 - \\mu_s}{1 + I_0/I},\n$$\n其中 $\\mu_s$ 是准静态摩擦系数，$\\mu_2$ 是高剪切摩擦系数，$I_0$ 是一个特征惯性数尺度，$I$ 是惯性数，定义为\n$$\nI = \\frac{d \\, \\dot{\\gamma}}{\\sqrt{p/\\rho_s}},\n$$\n其中 $\\dot{\\gamma}$ 是剪切率（单位为 $\\mathrm{s^{-1}}$）。所有符号都必须使用适当的单位进行处理。\n\n假设底床为无滑移边界，且流动足够稠密，使得上述关系在整个深度上都成立。基于这些基本原理，推导出一个与摩擦定律约束 $\\mu(I) = \\tan\\theta_r$ 及惯性数定义相一致的深度平均速度模型 $\\overline{u}(h,\\theta)$。您的推导必须从上述原理出发，不得假定任何简化公式。\n\n给定三个坡度角 $\\theta = 18^\\circ, 22^\\circ, 26^\\circ$ 以及从单一全局参数集 $(\\mu_s, \\mu_2, I_0)$ 生成并添加了测量噪声的合成数据。您的程序必须使用生成的合成数据，通过非线性最小二乘法来估计 $(\\mu_s, \\mu_2, I_0)$，并利用在解处由雅可比矩阵推导出的渐近正态近似来报告近似的95%置信区间。角度在输入规范中必须以度为单位处理，并在内部转换为弧度进行三角函数计算。所有速度必须以 $\\mathrm{m/s}$ 表示，所有深度必须以 $\\mathrm{m}$ 表示。\n\n用于数据生成的物理常数和真实参数值：\n- $g = 9.81 \\, \\mathrm{m/s^2}$,\n- $\\rho_m = 2000 \\, \\mathrm{kg/m^3}$,\n- $\\rho_s = 2650 \\, \\mathrm{kg/m^3}$,\n- $d = 0.02 \\, \\mathrm{m}$,\n- $\\mu_s^{\\mathrm{true}} = 0.30$,\n- $\\mu_2^{\\mathrm{true}} = 0.70$,\n- $I_0^{\\mathrm{true}} = 0.40$.\n\n合成数据生成协议：\n- 对于每个测试用例，针对每个角度 $\\theta \\in \\{18^\\circ, 22^\\circ, 26^\\circ\\}$ 和测试用例深度集中的每个指定深度 $h$，使用推导出的模型和真实参数 $(\\mu_s^{\\mathrm{true}},\\mu_2^{\\mathrm{true}},I_0^{\\mathrm{true}})$ 及上述常数计算无噪声的深度平均速度 $\\overline{u}(h,\\theta)$。\n- 向每个速度样本添加独立的、零均值的高斯噪声 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$，以形成测量数据 $\\overline{u}_{\\mathrm{meas}}(h,\\theta) = \\overline{u}(h,\\theta) + \\varepsilon$。\n- 使用指定的随机种子初始化伪随机数生成器，以使噪声可复现。\n\n您的程序必须对每个测试用例，使用非线性最小二乘法，同时对所有三个角度的整个数据集进行三个未知参数 $(\\mu_s,\\mu_2,I_0)$ 的拟合。拟合需使用物理上合理的边界，保持 $(\\mu_s,\\mu_2,I_0)$ 为正，并确保 $\\mu_2 > \\tan(26^\\circ)$ 以维持模型对于给定角度的一致性。然后使用协方差矩阵近似公式计算每个参数的近似95%置信区间\n$$\n\\mathrm{Cov}(\\hat{\\boldsymbol{\\theta}}) \\approx s^2 \\left(\\mathbf{J}^\\top \\mathbf{J}\\right)^{-1},\n$$\n其中 $\\hat{\\boldsymbol{\\theta}} = (\\hat{\\mu}_s,\\hat{\\mu}_2,\\hat{I}_0)$ 是参数估计值，$\\mathbf{J}$ 是在 $\\hat{\\boldsymbol{\\theta}}$ 处评估的残差关于参数的雅可比矩阵，而 $s^2 = \\mathrm{RSS}/(N-p)$ 是残差方差估计，其中 $\\mathrm{RSS}$ 是残差平方和，$N$ 是观测数量，$p=3$ 是参数数量。使用正态分位数1.96来构建对称置信区间。\n\n测试套件规范（三个案例，改变噪声水平和深度集；角度始终为 $\\theta = 18^\\circ, 22^\\circ, 26^\\circ$）：\n1. 案例A（理想路径）：随机种子 $42$，噪声标准差 $\\sigma = 0.03 \\, \\mathrm{m/s}$，深度 $h \\in \\{0.15, 0.25, 0.35, 0.50, 0.70\\} \\, \\mathrm{m}$。\n2. 案例B（低噪声边界）：随机种子 $7$，噪声标准差 $\\sigma = 0.00 \\, \\mathrm{m/s}$，深度 $h \\in \\{0.12, 0.20, 0.30, 0.45, 0.60\\} \\, \\mathrm{m}$。\n3. 案例C（高噪声边缘）：随机种子 $123$，噪声标准差 $\\sigma = 0.06 \\, \\mathrm{m/s}$，深度 $h \\in \\{0.20, 0.30, 0.40, 0.60, 0.90, 1.20\\} \\, \\mathrm{m}$。\n\n算法要求与输出规范：\n- 实现模型推导以获得作为 $(\\mu_s,\\mu_2,I_0)$ 和给定常数函数的 $\\overline{u}(h,\\theta)$。对每个测试用例，使用此模型按协议生成合成数据。\n- 对每个测试用例，通过非线性最小二乘法对所有角度和深度进行 $(\\mu_s,\\mu_2,I_0)$ 的拟合，同时遵守强制 $\\mu_s > 0$，$I_0 > 0$ 和 $\\mu_2 > \\tan(26^\\circ)$ 的边界条件。\n- 根据解的雅可比矩阵和残差方差，计算每个参数的近似95%置信区间。如果 $\\mathbf{J}^\\top \\mathbf{J}$ 是病态或不可逆的，则使用 Moore–Penrose 伪逆。\n- 最终输出格式：您的程序应生成单行输出，包含一个由方括号括起来的、包含27个数字的扁平化逗号分隔列表。对于按顺序排列的三个测试用例（案例A，案例B，案例C），依次附加以下9个值：\n  1. $\\hat{\\mu}_s$,\n  2. $\\hat{\\mu}_2$,\n  3. $\\hat{I}_0$,\n  4. $\\mu_s$ 的95%置信区间下界，\n  5. $\\mu_s$ 的95%置信区间上界，\n  6. $\\mu_2$ 的95%置信区间下界，\n  7. $\\mu_2$ 的95%置信区间上界，\n  8. $I_0$ 的95%置信区间下界，\n  9. $I_0$ 的95%置信区间上界。\n- 数值表示：所有报告的数字均表示为四舍五入到六位小数的浮点数。角度必须以度为单位解释；速度必须以 $\\mathrm{m/s}$ 为单位；深度必须以 $\\mathrm{m}$ 为单位。\n\n您的程序必须是完全自包含的，使用上述确切的常数和种子生成合成数据，执行所要求的估计和不确定性量化，并最终以指定的确切单行格式打印所有三个测试用例的结果。", "solution": "该问题被认为是有效的，因为它具有科学依据、是良定的、客观的，并为计算地质力学中的一个标准参数估计任务提供了一套完整且一致的指令。我们现在开始求解，这包括两个主要阶段：首先，深度平均速度模型的解析推导；其次，数据生成、参数拟合和不确定性分析流程的数值实现。\n\n### 深度平均速度 $\\overline{u}$ 的模型推导\n\n目标是推导出深度平均速度 $\\overline{u}$ 作为流深 $h$、坡度角 $\\theta$ 和流变参数 $(\\mu_s, \\mu_2, I_0)$ 的函数表达式。我们从所提供的第一性原理出发。\n\n**1. 应力与摩擦平衡**\n\n对于稳态均匀流动，重力驱动力与内摩擦力相平衡。距离底床深度为 $z$ 处的局部剪切应力 $\\tau(z)$ 和法向应力 $p(z)$ 由下式给出：\n$$\n\\tau(z) = \\rho_m g (h - z) \\sin\\theta_r\n$$\n$$\np(z) = \\rho_m g (h - z) \\cos\\theta_r\n$$\n其中 $\\theta_r$ 是以弧度为单位的坡度角。这些应力之比定义了平衡所需的宏观摩擦系数：\n$$\n\\mu = \\frac{\\tau(z)}{p(z)} = \\frac{\\rho_m g (h - z) \\sin\\theta_r}{\\rho_m g (h - z) \\cos\\theta_r} = \\tan\\theta_r\n$$\n关键的是，对于给定的坡度，这个所需的摩擦系数 $\\tan\\theta_r$ 在整个流深范围内是恒定的。\n\n**2. 将摩擦与惯性数关联**\n\n材料的本构行为由 $\\mu(I)$ 流变模型描述，它将动员摩擦系数与惯性数 $I$ 联系起来：\n$$\n\\mu(I) = \\mu_s + \\frac{\\mu_2 - \\mu_s}{1 + I_0/I}\n$$\n在稳态均匀流中，动员摩擦必须等于所需摩擦，因此 $\\mu(I) = \\tan\\theta_r$。这使我们能够求解出作为坡度角和流变参数函数的惯性数 $I$。\n$$\n\\tan\\theta_r = \\mu_s + \\frac{\\mu_2 - \\mu_s}{1 + I_0/I}\n$$\n重新整理方程以求解 $I$：\n$$\n\\tan\\theta_r - \\mu_s = \\frac{\\mu_2 - \\mu_s}{1 + I_0/I}\n$$\n$$\n1 + \\frac{I_0}{I} = \\frac{\\mu_2 - \\mu_s}{\\tan\\theta_r - \\mu_s}\n$$\n$$\n\\frac{I_0}{I} = \\frac{\\mu_2 - \\mu_s}{\\tan\\theta_r - \\mu_s} - 1 = \\frac{(\\mu_2 - \\mu_s) - (\\tan\\theta_r - \\mu_s)}{\\tan\\theta_r - \\mu_s} = \\frac{\\mu_2 - \\tan\\theta_r}{\\tan\\theta_r - \\mu_s}\n$$\n对于给定的坡度，这得出了惯性数 $I$ 的一个恒定值：\n$$\nI = I_0 \\frac{\\tan\\theta_r - \\mu_s}{\\mu_2 - \\tan\\theta_r}\n$$\n该表达式仅在 $\\mu_s  \\tan\\theta_r  \\mu_2$ 时有效，这确保了惯性数为正，从而处于流动状态。给定的坡度角（$18^\\circ, 22^\\circ, 26^\\circ$）和真实参数满足此条件。\n\n**3. 推导速度剖面 $u(z)$**\n\n惯性数 $I$ 在微观上也可以用局部剪切率 $\\dot{\\gamma}$ 和局部围压 $p(z)$ 来定义：\n$$\nI = \\frac{d \\, \\dot{\\gamma}}{\\sqrt{p(z)/\\rho_s}}\n$$\n假设为简单剪切，剪切率为 $\\dot{\\gamma} = |du/dz|$。对于下坡流动，$u(z) \\ge 0$，我们可以写作 $\\dot{\\gamma} = du/dz$。现在，通过重新整理 $I$ 的定义，我们可以表达速度梯度 $du/dz$：\n$$\n\\frac{du}{dz} = \\frac{I}{d} \\sqrt{\\frac{p(z)}{\\rho_s}}\n$$\n代入 $p(z)$ 的表达式：\n$$\n\\frac{du}{dz} = \\frac{I}{d} \\sqrt{\\frac{\\rho_m g (h-z) \\cos\\theta_r}{\\rho_s}} = \\left( \\frac{I}{d} \\sqrt{\\frac{\\rho_m g \\cos\\theta_r}{\\rho_s}} \\right) (h-z)^{1/2}\n$$\n对于给定的坡度，括号中的项是常数。我们用常数 $C(\\theta_r)$ 来表示它：\n$$\nC(\\theta_r) = \\frac{I}{d} \\sqrt{\\frac{\\rho_m g \\cos\\theta_r}{\\rho_s}} = \\left( \\frac{I_0}{d} \\frac{\\tan\\theta_r - \\mu_s}{\\mu_2 - \\tan\\theta_r} \\right) \\sqrt{\\frac{\\rho_m g \\cos\\theta_r}{\\rho_s}}\n$$\n因此，我们得到了速度剖面的微分方程：\n$$\n\\frac{du}{dz} = C(\\theta_r) (h-z)^{1/2}\n$$\n我们对该方程关于 $z$ 进行积分，从底床（$z=0$）到流动内的任意高度 $z$，并应用无滑移边界条件 $u(0)=0$：\n$$\nu(z) = \\int_0^z \\frac{du}{dz'} dz' = \\int_0^z C(\\theta_r) (h-z')^{1/2} dz'\n$$\n$$\nu(z) = C(\\theta_r) \\left[ -\\frac{2}{3}(h-z')^{3/2} \\right]_0^z = C(\\theta_r) \\left( -\\frac{2}{3}(h-z)^{3/2} - \\left(-\\frac{2}{3}(h-0)^{3/2}\\right) \\right)\n$$\n这给出了速度剖面：\n$$\nu(z) = \\frac{2}{3} C(\\theta_r) \\left( h^{3/2} - (h-z)^{3/2} \\right)\n$$\n\n**4. 推导深度平均速度 $\\overline{u}$**\n\n最后，我们通过在流深 $h$ 上对 $u(z)$ 进行积分并除以 $h$ 来计算深度平均速度 $\\overline{u}$：\n$$\n\\overline{u} = \\frac{1}{h} \\int_0^h u(z) dz = \\frac{1}{h} \\int_0^h \\frac{2}{3} C(\\theta_r) \\left( h^{3/2} - (h-z)^{3/2} \\right) dz\n$$\n$$\n\\overline{u} = \\frac{2 C(\\theta_r)}{3h} \\left[ \\int_0^h h^{3/2} dz - \\int_0^h (h-z)^{3/2} dz \\right]\n$$\n积分的计算结果为：\n$$\n\\int_0^h h^{3/2} dz = h^{3/2} [z]_0^h = h^{5/2}\n$$\n$$\n\\int_0^h (h-z)^{3/2} dz = \\left[ -\\frac{2}{5}(h-z)^{5/2} \\right]_0^h = 0 - \\left( -\\frac{2}{5}h^{5/2} \\right) = \\frac{2}{5}h^{5/2}\n$$\n将这些结果代回：\n$$\n\\overline{u} = \\frac{2 C(\\theta_r)}{3h} \\left[ h^{5/2} - \\frac{2}{5}h^{5/2} \\right] = \\frac{2 C(\\theta_r)}{3h} \\left[ \\frac{3}{5}h^{5/2} \\right] = \\frac{2}{5} C(\\theta_r) h^{3/2}\n$$\n代入 $C(\\theta_r)$ 的表达式，我们得到深度平均速度的最终模型：\n$$\n\\overline{u}(h, \\theta; \\mu_s, \\mu_2, I_0) = \\frac{2}{5} h^{3/2} \\left( \\frac{I_0}{d} \\frac{\\tan\\theta_r - \\mu_s}{\\mu_2 - \\tan\\theta_r} \\right) \\sqrt{\\frac{\\rho_m g \\cos\\theta_r}{\\rho_s}}\n$$\n该方程是生成合成数据和进行非线性最小二乘拟合程序的核心模型。\n\n### 数值实现策略\n\n对于每个测试用例，程序将按以下步骤进行：\n1.  **数据生成**：使用推导出的模型和真实参数 $(\\mu_s^{\\mathrm{true}}, \\mu_2^{\\mathrm{true}}, I_0^{\\mathrm{true}})$，为每个坡度角 $\\theta$ 和流深 $h$ 的组合计算无噪声速度 $\\overline{u}$。根据指定的标准差 $\\sigma$ 和随机种子添加高斯噪声，以创建合成测量数据集。\n2.  **参数估计**：采用 `scipy.optimize.least_squares` 来找到参数矢量 $\\hat{\\boldsymbol{\\theta}} = (\\hat{\\mu}_s, \\hat{\\mu}_2, \\hat{I}_0)$，该矢量使模型预测与合成数据之间的残差平方和最小化。优化将受到指定边界的约束：$\\mu_s > 0$，$I_0 > 0$ 和 $\\mu_2 > \\tan(26^\\circ)$。\n3.  **不确定性量化**：使用（由优化器返回的）残差关于参数的雅可比矩阵，通过公式 $\\mathrm{Cov}(\\hat{\\boldsymbol{\\theta}}) \\approx s^2 (\\mathbf{J}^\\top \\mathbf{J})^{-1}$ 计算近似协方差矩阵 $\\mathrm{Cov}(\\hat{\\boldsymbol{\\theta}})$。项 $(\\mathbf{J}^\\top \\mathbf{J})^{-1}$ 使用 Moore-Penrose 伪逆计算，以确保数值稳定性。残差方差 $s^2$ 从残差平方和（RSS）估计。\n4.  **置信区间**：从协方差矩阵的对角线元素，计算每个参数估计的标准误差。然后构造95%置信区间为 $\\hat{\\theta_i} \\pm 1.96 \\times \\mathrm{se}(\\hat{\\theta_i})$。\n5.  **输出格式化**：按规定整理并格式化所有三个测试用例的所有结果，形成单行字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Main function to execute the parameter estimation problem for debris flow rheology.\n    It generates synthetic data for three test cases, fits the mu(I) model parameters,\n    calculates confidence intervals, and prints the formatted results.\n    \"\"\"\n\n    # Physical constants and true parameter values for data generation\n    g = 9.81  # m/s^2\n    rho_m = 2000.0  # kg/m^3\n    rho_s = 2650.0  # kg/m^3\n    d = 0.02  # m\n    \n    true_params = {\n        \"mu_s\": 0.30,\n        \"mu_2\": 0.70,\n        \"I_0\": 0.40\n    }\n\n    # Test suite specification\n    angles_deg = np.array([18.0, 22.0, 26.0])\n    \n    test_cases = [\n        {\"seed\": 42, \"sigma\": 0.03, \"depths\": np.array([0.15, 0.25, 0.35, 0.50, 0.70])},\n        {\"seed\": 7, \"sigma\": 0.00, \"depths\": np.array([0.12, 0.20, 0.30, 0.45, 0.60])},\n        {\"seed\": 123, \"sigma\": 0.06, \"depths\": np.array([0.20, 0.30, 0.40, 0.60, 0.90, 1.20])},\n    ]\n\n    def u_bar_model(h, theta_deg, params, consts):\n        \"\"\"\n        Calculates the depth-averaged velocity based on the derived model.\n        \n        Args:\n            h (float or np.ndarray): Flow depth(s) in meters.\n            theta_deg (float or np.ndarray): Slope angle(s) in degrees.\n            params (tuple): A tuple of rheological parameters (mu_s, mu_2, I_0).\n            consts (dict): A dictionary of physical constants (g, d, rho_m, rho_s).\n        \n        Returns:\n            float or np.ndarray: Predicted depth-averaged velocity(s) in m/s.\n        \"\"\"\n        mu_s, mu_2, I_0 = params\n        g, d, rho_m, rho_s = consts['g'], consts['d'], consts['rho_m'], consts['rho_s']\n\n        theta_r = np.deg2rad(theta_deg)\n        tan_theta = np.tan(theta_r)\n        cos_theta = np.cos(theta_r)\n        \n        # Check for physical validity of parameters for the given angles\n        if np.any(tan_theta = mu_s) or np.any(tan_theta >= mu_2):\n            # Return a large value to be penalized by the optimizer if out of valid range\n            return np.full_like(h, 1e9)\n\n        term1 = (2.0 / 5.0) * (I_0 / d)\n        term2 = np.sqrt((rho_m * g * cos_theta) / rho_s)\n        term3 = (tan_theta - mu_s) / (mu_2 - tan_theta)\n        \n        u_bar = term1 * term2 * term3 * h**(1.5)\n        return u_bar\n\n    def residual_func(params, x_data, y_data, consts):\n        \"\"\"Residuals for the least_squares optimizer.\"\"\"\n        h_vals, theta_vals = x_data\n        model_predictions = u_bar_model(h_vals, theta_vals, params, consts)\n        return model_predictions - y_data\n\n    # Store all results in a flat list\n    all_results = []\n    \n    # Process each test case\n    for case in test_cases:\n        # --- 1. Generate Synthetic Data ---\n        rng = np.random.default_rng(case[\"seed\"])\n        \n        h_data, theta_data, u_meas_data = [], [], []\n        \n        for theta in angles_deg:\n            for h in case[\"depths\"]:\n                params_true_tuple = (true_params[\"mu_s\"], true_params[\"mu_2\"], true_params[\"I_0\"])\n                constants_dict = {'g': g, 'd': d, 'rho_m': rho_m, 'rho_s': rho_s}\n                \n                u_true = u_bar_model(h, theta, params_true_tuple, constants_dict)\n                noise = rng.normal(0, case[\"sigma\"])\n                u_meas = u_true + noise\n                \n                h_data.append(h)\n                theta_data.append(theta)\n                u_meas_data.append(u_meas)\n\n        h_data = np.array(h_data)\n        theta_data = np.array(theta_data)\n        y_data = np.array(u_meas_data)\n        x_data = (h_data, theta_data)\n\n        # --- 2. Parameter Estimation ---\n        # Bounds: [mu_s > 0, mu_2 > tan(26 deg), I_0 > 0]\n        # Added a small epsilon to mu_2 lower bound for strict inequality\n        lower_bounds = [0, np.tan(np.deg2rad(angles_deg.max())) + 1e-9, 0]\n        upper_bounds = [np.inf, np.inf, np.inf]\n        bounds = (lower_bounds, upper_bounds)\n        \n        # Initial guess for parameters (mu_s, mu_2, I_0)\n        p0 = [0.2, 0.6, 0.3]\n\n        res = least_squares(\n            residual_func,\n            p0,\n            args=(x_data, y_data, constants_dict),\n            bounds=bounds,\n            method='trf'\n        )\n        popt = res.x\n        hat_mu_s, hat_mu_2, hat_I_0 = popt\n\n        # --- 3. Uncertainty Quantification ---\n        J = res.jac\n        rss = 2 * res.cost # least_squares returns 0.5 * sum of squares\n        N = len(y_data)\n        p = len(popt)\n        \n        # Residual variance\n        if N > p:\n            s2 = rss / (N - p)\n        else: # Should not happen in this problem\n            s2 = np.nan \n\n        # Covariance matrix calculation\n        try:\n            # Use Moore-Penrose pseudoinverse as required\n            JtJ_inv = np.linalg.pinv(J.T @ J)\n            pcov = s2 * JtJ_inv\n            # Handle noise-free case where s2 can be ~0\n            if np.allclose(pcov, 0):\n                se = np.zeros_like(popt)\n            else:\n                se = np.sqrt(np.diag(pcov))\n        except (np.linalg.LinAlgError, ValueError):\n            se = np.array([np.inf] * p)\n\n        # --- 4. Confidence Intervals ---\n        z_score = 1.96  # For 95% confidence\n        conf_int_lower = popt - z_score * se\n        conf_int_upper = popt + z_score * se\n        \n        # --- 5. Store and Format Results ---\n        case_results = [\n            hat_mu_s, hat_mu_2, hat_I_0,\n            conf_int_lower[0], conf_int_upper[0],\n            conf_int_lower[1], conf_int_upper[1],\n            conf_int_lower[2], conf_int_upper[2],\n        ]\n        all_results.extend(case_results)\n\n    # Final formatting of the output string\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3516253"}]}