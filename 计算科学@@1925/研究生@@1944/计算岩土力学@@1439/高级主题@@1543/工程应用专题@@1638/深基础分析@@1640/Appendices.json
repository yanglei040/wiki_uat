{"hands_on_practices": [{"introduction": "这个基础练习旨在将端承桩的沉降分解为两个主要部分进行分析：桩身自身的弹性压缩和桩端下方土体的变形。通过将结构力学（杆件理论）和土力学（弹性半空间解）的经典解相结合，我们能够从第一性原理出发构建一个复合模型。这个“分而治之”的分析方法是工程分析中的一个经典且强大的工具，有助于我们验证更复杂的数值模型并建立对核心物理机制的直观理解。[@problem_id:3499728]", "problem": "一根细长的圆柱桩被竖直打入一个占据半无限半空间的均质、各向同性、线弹性土体中。桩承受轴向压缩荷载，桩身侧摩阻力被忽略，以分离出桩端响应效应。桩被建模为轴力沿其长度不变的一维弹性杆。土体被建模为经典弹性半空间。桩端为平面圆形，其与土体的接触被建模为无摩擦，这与弹性半空间上的刚性圆形压头模型一致。\n\n从线性弹性和固体力学的基本定律和核心定义出发，推导计算给定轴向荷载下桩顶沉降所需的控制关系式。对桩使用一维轴向杆理论，对桩端-土体接触使用弹性半空间理论。不得使用任何未经基本原理证明的简化公式或预推导表达式。\n\n你的任务是编写一个完整、可运行的程序，在给定一组参数的情况下，计算以米为单位的桩顶沉降。杆的伸长量必须根据胡克定律和轴向平衡从基本原理计算。桩端压缩量必须根据刚性圆形压头的弹性半空间解计算。总桩顶沉降是杆的伸长量和桩端压缩量之和。必须一致地使用以下定义和物理量：\n\n- 桩轴向荷载 $P$，单位为牛顿。\n- 桩长 $L$，单位为米。\n- 桩横截面积 $A$，单位为平方米。\n- 桩杨氏模量 $E_\\mathrm{p}$，单位为帕斯卡。\n- 土体杨氏模量 $E_\\mathrm{s}$，单位为帕斯卡。\n- 土体泊松比 $\\nu_\\mathrm{s}$ (无量纲)。\n- 桩端半径 $a$，单位为米。\n- 土体剪切模量 $G_\\mathrm{s}$ 定义为 $G_\\mathrm{s} = \\dfrac{E_\\mathrm{s}}{2\\left(1+\\nu_\\mathrm{s}\\right)}$。\n\n你的程序必须为每个测试案例计算以下量：\n1. 轴向杆伸长量 $\\,\\delta_\\mathrm{bar}\\,$，单位为米。\n2. 基于桩端荷载下弹性半空间响应的桩端压缩量 $\\,\\delta_\\mathrm{tip}\\,$，单位为米。\n3. 总桩顶沉降 $\\,s\\,$，单位为米，定义为 $\\,s = \\delta_\\mathrm{bar} + \\delta_\\mathrm{tip}\\,$.\n\n将所有沉降表示为以米为单位的浮点数。\n\n测试套件：\n使用以下参数集，每个元组按 $\\left(P, L, A, E_\\mathrm{p}, a, E_\\mathrm{s}, \\nu_\\mathrm{s}\\right)$ 的顺序排列，单位和定义如上所述。\n\n- 案例1 (一般情况): $\\left(2.0\\times10^6,\\; 12.0,\\; 0.25,\\; 3.0\\times10^{10},\\; 0.40,\\; 1.0\\times10^8,\\; 0.30\\right)$。\n- 案例2 (刚性桩): $\\left(2.0\\times10^6,\\; 12.0,\\; 0.25,\\; 2.0\\times10^{11},\\; 0.40,\\; 1.0\\times10^8,\\; 0.30\\right)$。\n- 案例3 (大桩端半径和较硬土体): $\\left(3.0\\times10^6,\\; 20.0,\\; 0.25,\\; 3.0\\times10^{10},\\; 0.75,\\; 1.5\\times10^8,\\; 0.35\\right)$。\n- 案例4 (近乎不可压缩的土体): $\\left(2.0\\times10^6,\\; 12.0,\\; 0.25,\\; 3.0\\times10^{10},\\; 0.40,\\; 1.0\\times10^9,\\; 0.49\\right)$。\n- 案例5 (长桩): $\\left(2.0\\times10^6,\\; 80.0,\\; 0.25,\\; 3.0\\times10^{10},\\; 0.40,\\; 1.0\\times10^8,\\; 0.30\\right)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含上述测试案例的总桩顶沉降（以米为单位），格式为方括号内以逗号分隔的列表。例如： \"[$s_1,s_2,s_3,s_4,s_5$]\"。每个沉降值都必须以米为单位表示。不应打印任何其他文本。", "solution": "该问题要求计算竖向受荷桩的总沉降 $s$。总沉降是两种不同物理现象的总和：桩本身的弹性压缩量 $\\delta_{\\mathrm{bar}}$ 和桩端下方土体的沉降量 $\\delta_{\\mathrm{tip}}$。问题指定了一个简化模型，其中忽略了桩身的侧摩阻力，这意味着施加在桩顶的全部轴向荷载 $P$ 都被传递到桩端。因此，该系统可以分解为两个子问题，并使用固体力学的基本原理独立分析。总沉降表示为：\n$$ s = \\delta_{\\mathrm{bar}} + \\delta_{\\mathrm{tip}} $$\n\n首先，我们推导桩身弹性压缩量 $\\delta_{\\mathrm{bar}}$ 的表达式。\n桩被建模为长度为 $L$、横截面积恒为 $A$、杨氏模量为 $E_{\\mathrm{p}}$ 的一维弹性杆。根据问题陈述和静力平衡原理，轴力沿桩长是恒定的。这是忽略侧摩阻力的直接结果。因此，任何横截面上的内部轴力都等于施加的荷载 $P$。\n\n轴向应力 $\\sigma$ 定义为单位面积上的力。由于内力是均匀的，应力也沿桩身均匀分布：\n$$ \\sigma = \\frac{P}{A} $$\n轴向应变 $\\epsilon$ 定义为单位长度的变形。对于单轴加载下的线弹性材料，胡克定律指出应力与应变成正比：\n$$ \\sigma = E_{\\mathrm{p}} \\epsilon $$\n其中 $E_{\\mathrm{p}}$ 是桩材料的杨氏模量。通过结合这两个基本方程，我们求解桩中的应变：\n$$ \\epsilon = \\frac{\\sigma}{E_{\\mathrm{p}}} = \\frac{P}{A E_{\\mathrm{p}}} $$\n应变表示位移沿桩轴的局部变化率。桩的总压缩量 $\\delta_{\\mathrm{bar}}$ 通过将应变在桩的全长 $L$ 上积分得到：\n$$ \\delta_{\\mathrm{bar}} = \\int_{0}^{L} \\epsilon \\, dz $$\n由于材料是均质的，且横截面和力是恒定的，应变 $\\epsilon$ 也是恒定的。因此积分简化为：\n$$ \\delta_{\\mathrm{bar}} = \\epsilon L $$\n代入 $\\epsilon$ 的表达式，我们得到桩身压缩的最终公式：\n$$ \\delta_{\\mathrm{bar}} = \\frac{P L}{A E_{\\mathrm{p}}} $$\n\n接下来，我们推导桩端处土体沉降 $\\delta_{\\mathrm{tip}}$ 的表达式。\n问题陈述土体是均质、各向同性、线弹性的半空间。桩端被建模为半径为 $a$ 的刚性、平面、圆形压头，将荷载 $P$ 施加于土体表面。接触被视为无摩擦。弹性半空间上刚性圆形压头的沉降是弹性理论中的一个经典解，源自点荷载的 Boussinesq 解。虽然从弹性力学控制微分方程（Navier-Cauchy 方程）进行的完整推导非常复杂，但其既定结果是针对此特定边值问题的基本原理。压头下方的均匀竖向位移（沉降）$\\delta_{\\mathrm{tip}}$ 由以下公认的公式给出：\n$$ \\delta_{\\mathrm{tip}} = \\frac{P (1 - \\nu_{\\mathrm{s}}^2)}{2 a E_{\\mathrm{s}}} $$\n其中 $P$ 是由桩端传递的总荷载， $a$ 是圆形桩端的半径， $E_{\\mathrm{s}}$ 和 $\\nu_{\\mathrm{s}}$ 分别是弹性半空间（土体）的杨氏模量和泊松比。问题还提供了土体剪切模量的定义 $G_{\\mathrm{s}} = \\dfrac{E_{\\mathrm{s}}}{2\\left(1+\\nu_\\mathrm{s}\\right)}$，这允许使用另一种表达式。通过将 $E_{\\mathrm{s}} = 2 G_{\\mathrm{s}} (1+\\nu_{\\mathrm{s}})$ 代入沉降公式，我们可以验证其等价性：\n$$ \\delta_{\\mathrm{tip}} = \\frac{P (1 - \\nu_{\\mathrm{s}})(1 + \\nu_{\\mathrm{s}})}{2 a \\cdot 2G_{\\mathrm{s}}(1+\\nu_{\\mathrm{s}})} = \\frac{P(1-\\nu_{\\mathrm{s}})}{4 a G_{\\mathrm{s}}} $$\n在计算中，使用 $E_{\\mathrm{s}}$ 和 $\\nu_{\\mathrm{s}}$ 的公式更直接，因为这些是测试套件中提供的参数。\n\n最后，总桩顶沉降 $s$ 是桩的结构压缩和桩端处土体变形的线性叠加：\n$$ s = \\delta_{\\mathrm{bar}} + \\delta_{\\mathrm{tip}} = \\frac{P L}{A E_{\\mathrm{p}}} + \\frac{P (1 - \\nu_{\\mathrm{s}}^2)}{2 a E_{\\mathrm{s}}} $$\n该方程综合了模型的两个部分，并将被用于计算每个给定测试案例的总沉降。所有参数均以一致的国际单位制（SI）单位提供，确保最终的沉降 $s$ 以米为单位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total settlement of an axially loaded pile based on a composite model.\n\n    The total settlement is the sum of the pile's elastic compression and the tip \n    settlement on an elastic half-space.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is ordered as (P, L, A, E_p, a, E_s, nu_s) with SI units.\n    # P: Pile axial load (N)\n    # L: Pile length (m)\n    # A: Pile cross-sectional area (m^2)\n    # E_p: Pile Young's modulus (Pa)\n    # a: Pile tip radius (m)\n    # E_s: Soil Young's modulus (Pa)\n    # nu_s: Soil Poisson's ratio (dimensionless)\n    test_cases = [\n        (2.0e6, 12.0, 0.25, 3.0e10, 0.40, 1.0e8, 0.30),\n        (2.0e6, 12.0, 0.25, 2.0e11, 0.40, 1.0e8, 0.30),\n        (3.0e6, 20.0, 0.25, 3.0e10, 0.75, 1.5e8, 0.35),\n        (2.0e6, 12.0, 0.25, 3.0e10, 0.40, 1.0e9, 0.49),\n        (2.0e6, 80.0, 0.25, 3.0e10, 0.40, 1.0e8, 0.30)\n    ]\n\n    results = []\n    for case in test_cases:\n        P, L, A, E_p, a, E_s, nu_s = case\n        \n        # 1. Compute axial bar elongation (compression)\n        # Formula: delta_bar = (P * L) / (A * E_p)\n        delta_bar = (P * L) / (A * E_p)\n        \n        # 2. Compute tip compression (settlement)\n        # Formula: delta_tip = (P * (1 - nu_s^2)) / (2 * a * E_s)\n        delta_tip = (P * (1 - nu_s**2)) / (2 * a * E_s)\n        \n        # 3. Compute total pile head settlement\n        # Formula: s = delta_bar + delta_tip\n        total_settlement = delta_bar + delta_tip\n        \n        results.append(total_settlement)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of floating-point numbers in a string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3499728"}, {"introduction": "在掌握了单桩的基本行为后，下一步自然是将其扩展到完整的桩筏基础系统。本练习将介绍基于刚度矩阵的分析方法，这是有限元法的理论基石。通过学习如何将基础各组成部分（筏板和桩群）的刚度进行组合，来求解整个系统的荷载-沉降响应和内力分布，你将深入理解桩-土-结构相互作用的本质。[@problem_id:3499751]", "problem": "一个刚性桩筏基础被理想化为一个单竖向自由度系统，其中刚性筏板与一组嵌入弹性地基中的竖向桩头弹簧并联。筏板底部的地基由一个连续的、线性弹性的反力来表示，其特征是分布式的地基反力模量。桩群由一个对称的相互作用刚度矩阵表示，该矩阵捕捉了单个桩的轴向桩头刚度以及通过周围土体在桩头之间的弹性相互作用。假设小应变、线性弹性和准静态条件。筏板的抗弯刚度足够大，其竖向位移在空间上是均匀的。\n\n从以下基本依据出发：(i) 线性动量平衡（静力平衡），即反力之和等于施加的荷载；(ii) 刚性筏板的运动协调性，即所有桩头和筏板经历相同的竖向位移；以及 (iii) 弹簧的线性弹性本构关系，推导出一个计算程序，用于确定均匀沉降以及筏-土接触面与桩群之间的荷载分布。\n\n使用的建模定义：\n- 筏-土接触面被建模为分布式的线性弹簧，单位面积的地基反力模量为 $k_s$，单位为 $\\mathrm{MN/m^3}$。对于一个面积为 $A$（单位为 $\\mathrm{m^2}$）的筏板，等效的筏-土竖向刚度为 $K_r = k_s \\times 10^6 \\times A$，单位为 $\\mathrm{N/m}$。\n- 由 $n$ 个桩组成的桩群由一个对称的相互作用刚度矩阵 $K_p \\in \\mathbb{R}^{n \\times n}$ 建模，单位为 $\\mathrm{GN/m}$；通过乘以 $10^9$ 将每个条目转换为 $\\mathrm{N/m}$。对角线项代表单个桩的桩头轴向刚度，非对角线项代表成对的相互作用项。\n- 总施加竖向荷载为 $Q$，单位为 $\\mathrm{kN}$；通过乘以 $10^3$ 转换为 $\\mathrm{N}$。\n- 每个桩 $i$ 的容许承载力为 $C_i$，单位为 $\\mathrm{kN}$。\n\n您的程序必须：\n- 仅使用平衡和协调性条件来获得均匀沉降 $u$（单位为m）、筏板反力 $Q_r$（单位为N）和桩荷载向量 $\\mathbf{q}$（单位为N）的表达式。\n- 为每个测试用例转换并报告以下内容：沉降（单位为mm），四舍五入到三位小数；筏板荷载份额（单位为kN），四舍五入到两位小数；桩荷载列表（单位为kN），四舍五入到两位小数；以及一个布尔值，指示所有桩是否满足 $q_i \\le C_i$（两者使用相同单位，kN）。如果没有桩，则将桩荷载列表视为空列表，布尔值视为真。\n- 使用指定的转换确保内部单位一致性。\n\n角度单位不适用。以指定单位表示所有要求的物理量。\n\n测试套件（每个用例都是独立的）。对于每个用例，输入以 $(Q,\\;A,\\;k_s,\\;K_p,\\;\\{C_i\\})$ 的形式提供，单位如上所述：\n- 用例1（正常路径，中等相互作用，四根桩）：\n  - $Q = 60000$\n  - $A = 400$\n  - $k_s = 30$\n  - $K_p$ (单位 $\\mathrm{GN/m}$):\n    - $4 \\times 4$ 矩阵，对角线项为 $0.8$，非对角线项为 $0.16$\n  - 承载力 $\\{C_i\\}$ (单位 $\\mathrm{kN}$): $\\{6000, 6000, 6000, 6000\\}$\n- 用例2（边界情况，无桩）：\n  - $Q = 20000$\n  - $A = 300$\n  - $k_s = 15$\n  - $K_p$：空（无桩）\n  - 承载力：空\n- 用例3（非均质桩群且桩承担份额大）：\n  - $Q = 50000$\n  - $A = 200$\n  - $k_s = 5$\n  - $K_p$ (单位 $\\mathrm{GN/m}$):\n    - $\n      \\begin{bmatrix}\n      1.5  0.25  0.15 \\\\\n      0.25  1.2  0.20 \\\\\n      0.15  0.20  0.9\n      \\end{bmatrix}\n      $\n  - 承载力 $\\{C_i\\}$ (单位 $\\mathrm{kN}$): $\\{17000, 14000, 9500\\}$\n- 用例4（强相互作用，两根桩）：\n  - $Q = 10000$\n  - $A = 250$\n  - $k_s = 10$\n  - $K_p$ (单位 $\\mathrm{GN/m}$):\n    - $\n      \\begin{bmatrix}\n      0.6  0.54 \\\\\n      0.54  0.6\n      \\end{bmatrix}\n      $\n  - 承载力 $\\{C_i\\}$ (单位 $\\mathrm{kN}$): $\\{2500, 2500\\}$\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是 $[u_{\\mathrm{mm}},\\;Q_{r,\\mathrm{kN}},\\;[q_{1,\\mathrm{kN}},\\dots,q_{n,\\mathrm{kN}}],\\;\\text{safe}]$ 形式的列表，其中 $u_{\\mathrm{mm}}$ 是沉降（单位为mm），$Q_{r,\\mathrm{kN}}$ 是筏板荷载（单位为kN），内部列表包含桩荷载（单位为kN），$\\text{safe}$ 是布尔型安全性指标。例如，整体输出必须看起来像 $[[\\cdot,\\cdot,[\\cdot],\\cdot],[\\cdot,\\cdot,[\\cdot],\\cdot],\\dots]$，不含附加文本。", "solution": "经评估，用户提供的问题是**有效的**。它在科学上是合理的、适定的、客观的，并包含唯一解所需的所有必要信息。该问题是计算岩土力学中的一个标准练习，特别是桩筏基础的线性弹性分析。我们现在将进行解的形式化推导，然后实现一个计算程序。\n\n推导基于指定的三个基本原则：(i) 静力平衡，(ii) 运动协调性，以及 (iii) 线性弹性本构关系。在推导过程中，所有量均以国际单位制基本单位（牛顿、米）表示。\n\n设 $u$ 为刚性筏板的均匀竖向沉降，单位为米[$\\mathrm{m}$]。\n设 $Q$ 为总施加竖向荷载，单位为牛顿[$\\mathrm{N}$]。\n设 $A$ 为筏板平面面积，单位为平方米[$\\mathrm{m}^2$]。\n设 $k_s$ 为地基反力模量，单位为帕斯卡每米[$\\mathrm{N/m^3}$]。\n设 $K_r$ 为筏-土接触面的等效竖向刚度，单位为牛顿每米[$\\mathrm{N/m}$]。\n设 $n$ 为桩的数量。对于 $n0$，设 $K_p \\in \\mathbb{R}^{n \\times n}$ 为桩群相互作用刚度矩阵，单位为牛顿每米[$\\mathrm{N/m}$]。\n\n问题是要求解沉降 $u$、由筏-土接触面承担的荷载 $Q_r$ 以及桩的荷载向量 $\\mathbf{q} = [q_1, q_2, \\dots, q_n]^T$。\n\n**1. 运动协调性**\n问题陈述，筏板是刚性的，并发生均匀的竖向位移 $u$。由于桩与筏板相连，所有桩头必须经历相同的沉降。设 $\\mathbf{u}_p$ 为桩头位移向量。\n则，\n$$ \\mathbf{u}_p = \\begin{bmatrix} u \\\\ u \\\\ \\vdots \\\\ u \\end{bmatrix} = u \\cdot \\mathbf{1} $$\n其中 $\\mathbf{1}$ 是一个大小为 $n$ 的列向量，所有元素都等于1。\n\n**2. 本构关系**\n系统组件被建模为线性弹性弹簧。\n- **筏-土接触面**：筏板下方土体的反作用力 $Q_r$ 与沉降 $u$ 成正比。\n  根据问题定义，等效的筏-土刚度为 $K_r = k_s \\cdot A$。本构定律是：\n  $$ Q_r = K_r \\cdot u $$\n\n- **桩群**：桩头力向量 $\\mathbf{q}$ 通过桩群刚度矩阵 $K_p$ 与桩头位移向量 $\\mathbf{u}_p$ 相关联。\n  $$ \\mathbf{q} = K_p \\mathbf{u}_p $$\n  将协调性条件 $\\mathbf{u}_p = u \\cdot \\mathbf{1}$ 代入此关系式：\n  $$ \\mathbf{q} = K_p (u \\cdot \\mathbf{1}) = u (K_p \\mathbf{1}) $$\n  这个方程给出了每个桩 $i$ 上的荷载 $q_i$ 作为未知沉降 $u$ 的函数。项 $K_p \\mathbf{1}$ 是一个向量，其第 $i$ 个元素是 $K_p$ 第 $i$ 行中所有刚度系数的总和，即 $\\sum_{j=1}^{n} K_{p,ij}$。\n\n整个桩群承担的总荷载 $Q_p$ 是各个桩荷载的总和：\n$$ Q_p = \\sum_{i=1}^{n} q_i = \\mathbf{1}^T \\mathbf{q} $$\n代入 $\\mathbf{q}$ 的表达式：\n$$ Q_p = \\mathbf{1}^T (u K_p \\mathbf{1}) = u (\\mathbf{1}^T K_p \\mathbf{1}) $$\n标量 $K_{p,group} = \\mathbf{1}^T K_p \\mathbf{1} = \\sum_{i=1}^{n} \\sum_{j=1}^{n} K_{p,ij}$ 表示在均匀位移作用下桩群的整体刚度。它通过对矩阵 $K_p$ 的所有元素求和来计算。因此，桩群总荷载为：\n$$ Q_p = K_{p,group} \\cdot u $$\n如果没有桩（$n=0$），则 $K_{p,group}=0$ 且 $Q_p=0$。\n\n**3. 静力平衡**\n为使桩筏系统处于静力平衡状态，总施加荷载 $Q$ 必须与地基的所有向上反力之和相平衡。这些反力是筏-土接触力 $Q_r$ 和桩群总力 $Q_p$。\n$$ Q = Q_r + Q_p $$\n将 $Q_r$ 和 $Q_p$ 的本构关系代入平衡方程：\n$$ Q = (K_r \\cdot u) + (K_{p,group} \\cdot u) $$\n提取沉降 $u$：\n$$ Q = (K_r + K_{p,group}) \\cdot u $$\n这是单自由度系统的控制方程。项 $K_{total} = K_r + K_{p,group}$ 是桩筏基础的总刚度。\n\n**4. 计算算法**\n基于以上推导，计算步骤如下：\n\n- **步骤1：单位转换和刚度计算。**\n  - 将所有输入参数转换为国际单位制基本单位（N, m）。\n    - $Q\\;[\\mathrm{N}] = Q\\;[\\mathrm{kN}] \\times 10^3$\n    - $k_s\\;[\\mathrm{N/m^3}] = k_s\\;[\\mathrm{MN/m^3}] \\times 10^6$\n    - $K_p\\;[\\mathrm{N/m}] = K_p\\;[\\mathrm{GN/m}] \\times 10^9$\n  - 计算筏板刚度：$K_r = k_s \\cdot A$。\n  - 计算桩群刚度：如果 $n  0$，$K_{p,group} = \\sum_{i,j} K_{p,ij}$。如果 $n=0$，$K_{p,group} = 0$。\n  - 计算系统总刚度：$K_{total} = K_r + K_{p,group}$。\n\n- **步骤2：求解沉降。**\n  - 均匀沉降 $u$ 从控制平衡方程计算得出：\n    $$ u = \\frac{Q}{K_{total}} $$\n\n- **步骤3：确定荷载分布。**\n  - 筏-土接触荷载：$Q_r = K_r \\cdot u$。\n  - 桩荷载：如果 $n  0$，桩荷载向量 $\\mathbf{q}$ 计算为 $\\mathbf{q} = u (K_p \\mathbf{1})$。如果 $n=0$，桩荷载向量为空。\n\n- **步骤4：进行安全性检查。**\n  - 对于每个桩 $i$，将其计算出的荷载 $q_i$ 与其容许承载力 $C_i$进行比较。注意，为进行有效比较，两者必须使用相同的单位（例如，kN）。\n  - 如果所有桩都满足 $q_i \\le C_i$，则地基被认为是‘安全的’。对于没有桩的基础，此条件无意义地成立（即视为真）。\n\n- **步骤5：格式化输出。**\n  - 将计算出的沉降 $u$ 转换为毫米（$u \\times 1000$），筏板荷载 $Q_r$ 转换为千牛（$Q_r / 1000$），桩荷载 $q_i$ 转换为千牛（$q_i / 1000$）。\n  - 将数值四舍五入到指定的小数位数。\n  - 将结果组合成所需的列表格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    \n    # Test suite definition\n    test_cases = [\n        # Case 1: (Q, A, k_s, K_p, {C_i})\n        (60000, 400, 30, \n         [[0.8, 0.16, 0.16, 0.16], \n          [0.16, 0.8, 0.16, 0.16], \n          [0.16, 0.16, 0.8, 0.16], \n          [0.16, 0.16, 0.16, 0.8]], \n         [6000, 6000, 6000, 6000]),\n        # Case 2: No piles\n        (20000, 300, 15, [], []),\n        # Case 3: Heterogeneous group\n        (50000, 200, 5, \n         [[1.5, 0.25, 0.15], \n          [0.25, 1.2, 0.20], \n          [0.15, 0.20, 0.9]], \n         [17000, 14000, 9500]),\n        # Case 4: High interaction\n        (10000, 250, 10, \n         [[0.6, 0.54], \n          [0.54, 0.6]], \n         [2500, 2500])\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists is the desired format.\n    print(f\"{results}\".replace(\"'\", \"\").replace(\" \", \"\"))\n\ndef calculate_case(Q_kN, A_m2, ks_MN_m3, Kp_GN_m, C_kN):\n    \"\"\"\n    Calculates settlement and load distribution for a single piled raft case.\n\n    Args:\n        Q_kN (float): Total applied load in kN.\n        A_m2 (float): Raft plan area in m^2.\n        ks_MN_m3 (float): Subgrade modulus in MN/m^3.\n        Kp_GN_m (list of lists): Pile group stiffness matrix in GN/m.\n        C_kN (list of float): Pile capacities in kN.\n\n    Returns:\n        list: [settlement_mm, raft_load_kN, pile_loads_kN_list, is_safe_boolean]\n    \"\"\"\n    # Unit conversions to base SI units (N, m)\n    Q_N = Q_kN * 1e3\n    ks_N_m3 = ks_MN_m3 * 1e6\n\n    # Step 1: Calculate Stiffnesses\n    # Raft-soil contact stiffness\n    Kr_N_m = ks_N_m3 * A_m2\n\n    # Pile group stiffness\n    if not Kp_GN_m:\n        n_piles = 0\n        Kp_group_N_m = 0.0\n        Kp_N_m = np.array([])\n    else:\n        Kp_GN_m_np = np.array(Kp_GN_m)\n        n_piles = Kp_GN_m_np.shape[0]\n        Kp_N_m = Kp_GN_m_np * 1e9\n        # Equivalent group stiffness is the sum of all elements in the matrix\n        Kp_group_N_m = np.sum(Kp_N_m)\n    \n    # Total system stiffness\n    K_total_N_m = Kr_N_m + Kp_group_N_m\n\n    # Step 2: Calculate Settlement\n    # Safeguard against non-positive stiffness, though physically not expected\n    if K_total_N_m == 0:\n        return [0.0, 0.0, [], False]\n\n    u_m = Q_N / K_total_N_m\n    u_mm = u_m * 1e3\n\n    # Step 3: Determine Load Distribution\n    # Raft-soil contact load\n    Qr_N = Kr_N_m * u_m\n    Qr_kN = Qr_N / 1e3\n\n    # Pile loads\n    q_kN_list = []\n    is_safe = True\n    if n_piles > 0:\n        # q = u * (K_p * 1), where K_p*1 is a vector of row sums\n        row_sums_N_m = np.sum(Kp_N_m, axis=1)\n        q_N_vector = u_m * row_sums_N_m\n        q_kN_vector = q_N_vector / 1e3\n        \n        q_kN_list = [round(q, 2) for q in q_kN_vector]\n        \n        # Step 4: Perform Safety Check\n        C_kN_np = np.array(C_kN)\n        # Using a small tolerance for floating point comparisons\n        is_safe = np.all(q_kN_vector = C_kN_np + 1e-9)\n    else: # n_piles == 0\n        is_safe = True\n        q_kN_list = []\n\n    # Step 5: Format Output\n    u_mm_rounded = round(u_mm, 3)\n    Qr_kN_rounded = round(Qr_kN, 2)\n    \n    return [u_mm_rounded, Qr_kN_rounded, q_kN_list, bool(is_safe)]\n\n\nsolve()\n```", "id": "3499751"}, {"introduction": "这项高级实践将带你深入现代计算岩土力学的核心。你将不再使用预先定义好的模型，而是从零开始为桩-土接触面实现一个完整的非线性本构模型。掌握这一过程，特别是“返回映射”算法和“一致切线刚度矩阵”的推导与编程实现，对于开发或深入使用高级非线性数值模拟软件至关重要。[@problem_id:3499747]", "problem": "您的任务是为一个二维界面模型实现本构积分和一致切线算子，该模型代表了桩与周围土壤之间的相互作用。界面运动学通过桩表面与相邻土壤之间的位移跳跃向量 $\\boldsymbol{w} = [w_n, w_t]^T$ 进行理想化，该向量分解为法向分量 $w_n$ 和切向分量 $w_t$。相应的牵引力向量为 $\\boldsymbol{t} = [t_n, t_t]^T$，其中 $t_n$ 为法向牵引力（压缩为正），$t_t$ 为切向牵引力。在法向和切向方向上使用罚函数正则化，其弹性刚度分别为 $k_n^e$ 和 $k_t^e$，并在压缩条件下使用带有粘聚力参数 $c$ 的 Coulomb 摩擦。张开（受拉）接触不承受牵引力。\n\n从以下基本原理和定义开始：\n- 界面在法向强制执行单边接触，在切向强制执行 Coulomb 摩擦。这通过一个法向牵引力 $t_n$ 来建模，该牵引力抵抗互穿并在受拉时消失；以及一个切向牵引力 $t_t$，在受压时受摩擦边界限制。\n- 弹性试探状态遵循罚弹性理论：$t_n^{\\text{trial}} = -k_n^e w_n$ 和 $t_t^{\\text{trial}} = k_t^e w_t$。\n- 接触张开规则：对于 $w_n \\ge 0$（张开，受拉），界面不承受任何牵引力，即 $t_n = 0$ 和 $t_t = 0$。\n- 接触压缩规则：对于 $w_n  0$，法向牵引力是压缩性的，由 $t_n = -k_n^e w_n  0$ 给出。\n- 压缩下的带粘聚力的摩擦极限：当 $w_n  0$ 时，容许的切向牵引力受限于 $|t_t| \\le \\mu t_n + c$，其中 $\\mu$ 是摩擦系数，$c$ 是粘聚力。如果 $|t_t^{\\text{trial}}| \\le \\mu t_n + c$，则切向响应为弹性粘滞；如果 $|t_t^{\\text{trial}}|  \\mu t_n + c$，则发生滑动，更新后的切向牵引力为 $t_t = \\operatorname{sign}(t_t^{\\text{trial}})\\,(\\mu t_n + c)$。\n\n您的程序必须：\n1. 实现本构积分，通过应用所述的弹性预测、接触张开规则和压缩下的摩擦返回映射，将给定的位移跳跃 $\\boldsymbol{w}$ 映射到界面牵引力 $\\boldsymbol{t}$。\n2. 计算一致算法切线矩阵 $\\boldsymbol{K} = \\partial \\boldsymbol{t} / \\partial \\boldsymbol{w}$，这是一个 $2 \\times 2$ 矩阵，其分量为 $K_{nn} = \\partial t_n / \\partial w_n$，$K_{nt} = \\partial t_n / \\partial w_t$，$K_{tn} = \\partial t_t / \\partial w_n$ 和 $K_{tt} = \\partial t_t / \\partial w_t$，这些分量从相同的本构模型导出。在张开（$w_n \\ge 0$）情况下，设置 $\\boldsymbol{K} = \\boldsymbol{0}$。在压缩（$w_n  0$）情况下，对于弹性粘滞，设置 $K_{nn} = -k_n^e$，$K_{tt} = k_t^e$，$K_{nt} = K_{tn} = 0$。对于滑动，设置 $K_{nn} = -k_n^e$，$K_{tt} = 0$，$K_{nt} = 0$，$K_{tn} = \\operatorname{sign}(w_t)\\,\\mu\\,(-k_n^e)$。\n\n物理单位和输出要求：\n- 刚度 $k_n^e$ 和 $k_t^e$ 的单位为 $\\text{Pa}/\\text{m}$。\n- 摩擦系数 $\\mu$ 是无量纲的，粘聚力 $c$ 的单位是 $\\text{Pa}$。\n- 位移跳跃 $w_n$ 和 $w_t$ 的单位是 $\\text{m}$。\n- 以 $\\text{Pa}$ 为单位表示 $t_n$ 和 $t_t$，以 $\\text{Pa}/\\text{m}$ 为单位表示切线矩阵的条目。\n\n您的程序应处理以下参数集和位移跳跃的测试套件，其中材料参数固定为 $k_n^e = 10^9\\,\\text{Pa}/\\text{m}$，$k_t^e = 5 \\times 10^8\\,\\text{Pa}/\\text{m}$，$\\mu = 0.4$，以及 $c = 5 \\times 10^4\\,\\text{Pa}$：\n- 测试用例 1 (压缩，粘滞): $w_n = -1\\times 10^{-4}\\,\\text{m}$, $w_t = 1\\times 10^{-4}\\,\\text{m}$。\n- 测试用例 2 (压缩，滑动): $w_n = -1\\times 10^{-4}\\,\\text{m}$, $w_t = 3\\times 10^{-4}\\,\\text{m}$。\n- 测试用例 3 (张开，无牵引力): $w_n = +1\\times 10^{-4}\\,\\text{m}$, $w_t = 2\\times 10^{-4}\\,\\text{m}$。\n- 测试用例 4 (压缩，负切向跳跃滑动): $w_n = -2\\times 10^{-4}\\,\\text{m}$, $w_t = -1\\times 10^{-3}\\,\\text{m}$。\n- 测试用例 5 (摩擦极限边界情况，视为粘滞): $w_n = -1\\times 10^{-4}\\,\\text{m}$, $w_t = 1.8\\times 10^{-4}\\,\\text{m}$。\n\n对于每个测试用例，计算列表 $[t_n, t_t, K_{nn}, K_{nt}, K_{tn}, K_{tt}]$（使用指定单位）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且本身是使用 Python 列表表示法的 $[t_n, t_t, K_{nn}, K_{nt}, K_{tn}, K_{tt}]$ 形式的列表。所有数值输出必须是浮点数。", "solution": "该问题要求为一个二维桩-土界面模型实现一个本构积分算法。该算法必须针对给定的位移跳跃向量 $\\boldsymbol{w} = [w_n, w_t]^T$ 计算界面牵引力向量 $\\boldsymbol{t} = [t_n, t_t]^T$ 和相应的一致算法切线矩阵 $\\boldsymbol{K} = \\partial \\boldsymbol{t} / \\partial \\boldsymbol{w}$。该模型在法向包含单边接触，在切向包含带粘聚力的 Coulomb 摩擦。\n\n该算法通过分析基于法向位移跳跃 $w_n$ 的接触状态来执行。其逻辑分为两个主要情况：接触张开 ($w_n \\ge 0$) 和接触压缩 ($w_n  0$)。\n\n**情况 1：接触张开 ($w_n \\ge 0$)**\n\n根据指定的张开规则，处于受拉状态 ($w_n  0$) 或法向位移为零 ($w_n = 0$) 的界面不能承受任何牵引力。\n\n- **牵引力更新**：法向和切向牵引力均为零。\n$$\nt_n = 0\n$$\n$$\nt_t = 0\n$$\n- **一致切线更新**：由于在此整个区域内牵引力是恒定的（为零），它们相对于位移跳跃的导数为零。一致切线矩阵是零矩阵。\n$$\n\\boldsymbol{K} = \\frac{\\partial \\boldsymbol{t}}{\\partial \\boldsymbol{w}} = \\begin{pmatrix} 0  0 \\\\ 0  0 \\end{pmatrix}\n$$\n\n**情况 2：接触压缩 ($w_n  0$)**\n\n当界面处于压缩状态时，会激活一个更复杂的弹塑性框架。该过程遵循标准的预测-校正方案。\n\n**步骤 2.1：弹性预测（试探状态）**\n\n首先，我们假设纯弹性响应来计算试探状态。\n- **法向牵引力**：法向牵引力是压缩性的，由罚刚度 $k_n^e$ 决定。压缩为正的符号约定以及互穿为负的 $w_n$ 导致：\n$$\nt_n = -k_n^e w_n\n$$\n请注意，由于 $w_n  0$ 且 $k_n^e  0$，法向牵引力 $t_n$ 为正，这与压缩的定义一致。该关系在压缩下的粘滞和滑动状态下均成立。\n\n- **试探切向牵引力**：试探切向牵引力使用切向罚刚度 $k_t^e$ 进行弹性计算：\n$$\nt_t^{\\text{trial}} = k_t^e w_t\n$$\n\n**步骤 2.2：摩擦屈服检查**\n\n必须根据摩擦准则检查试探切向牵引力。切向牵引力的最大容许量值由带粘聚力的 Coulomb 摩擦定律定义，该定律取决于当前的法向牵引力 $t_n$：\n$$\n\\Phi_{\\text{limit}} = \\mu t_n + c\n$$\n保持在弹性（粘滞）区域的条件是：\n$$\n|t_t^{\\text{trial}}| \\le \\Phi_{\\text{limit}}\n$$\n如果此不等式不成立，则发生塑性滑移（滑动）。\n\n**步骤 2.3：状态确定与更新**\n\n根据屈服检查，确定最终的牵引力和一致切线。\n\n**子情况 2.3.a：弹性粘滞 ($|t_t^{\\text{trial}}| \\le \\Phi_{\\text{limit}}$)**\n\n试探状态是容许的。响应是弹性的。\n\n- **牵引力更新**：最终的切向牵引力等于其试探值。\n$$\nt_t = t_t^{\\text{trial}} = k_t^e w_t\n$$\n- **一致切线更新**：通过对弹性本构关系 $t_n = -k_n^e w_n$ 和 $t_t = k_t^e w_t$ 求导来推导切线矩阵。响应是解耦的。\n$$\nK_{nn} = \\frac{\\partial t_n}{\\partial w_n} = -k_n^e\n$$\n$$\nK_{nt} = \\frac{\\partial t_n}{\\partial w_t} = 0\n$$\n$$\nK_{tn} = \\frac{\\partial t_t}{\\partial w_n} = 0\n$$\n$$\nK_{tt} = \\frac{\\partial t_t}{\\partial w_t} = k_t^e\n$$\n切线矩阵是对角的：$\\boldsymbol{K}^{\\text{stick}} = \\begin{pmatrix} -k_n^e  0 \\\\ 0  k_t^e \\end{pmatrix}$。\n\n**子情况 2.3.b：滑动 ($|t_t^{\\text{trial}}|  \\Phi_{\\text{limit}}$)**\n\n试探状态是不可容许的。应用塑性校正（或称返回映射）来强制满足屈服条件。\n\n- **牵引力更新**：将切向牵引力返回到屈服面上，同时保持试探步的方向。\n$$\nt_t = \\operatorname{sign}(t_t^{\\text{trial}}) \\Phi_{\\text{limit}} = \\operatorname{sign}(k_t^e w_t) (\\mu t_n + c)\n$$\n由于 $k_t^e  0$，这可简化为：\n$$\nt_t = \\operatorname{sign}(w_t) (\\mu (-k_n^e w_n) + c)\n$$\n- **一致切线更新**：切线矩阵从滑动状态的活动本构关系中推导得出。出现一个非零的非对角项 $K_{tn}$，表示存在耦合。\n$$\nK_{nn} = \\frac{\\partial t_n}{\\partial w_n} = -k_n^e\n$$\n$$\nK_{nt} = \\frac{\\partial t_n}{\\partial w_t} = 0\n$$\n$$\nK_{tn} = \\frac{\\partial t_t}{\\partial w_n} = \\frac{\\partial}{\\partial w_n} \\left[ \\operatorname{sign}(w_t) (\\mu (-k_n^e w_n) + c) \\right] = \\operatorname{sign}(w_t) \\mu (-k_n^e)\n$$\n$$\nK_{tt} = \\frac{\\partial t_t}{\\partial w_t} = \\frac{\\partial}{\\partial w_t} \\left[ \\operatorname{sign}(w_t) (\\mu (-k_n^e w_n) + c) \\right] = 0\n$$\n对于 $w_t \\ne 0$，$\\operatorname{sign}(w_t)$ 的导数为零。切线矩阵是非对称的：$\\boldsymbol{K}^{\\text{slide}} = \\begin{pmatrix} -k_n^e  0 \\\\ \\operatorname{sign}(w_t) \\mu (-k_n^e)  0 \\end{pmatrix}$。\n\n该实现将把此逻辑应用于每个测试用例，使用所提供的材料参数，为每个用例计算列表 $[t_n, t_t, K_{nn}, K_{nt}, K_{tn}, K_{tt}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_interface_response(wn: float, wt: float, kn_e: float, kt_e: float, mu: float, c: float) -> list[float]:\n    \"\"\"\n    Computes the interface traction and consistent tangent matrix for a given displacement jump.\n\n    Args:\n        wn: Normal displacement jump (m).\n        wt: Tangential displacement jump (m).\n        kn_e: Normal elastic stiffness (Pa/m).\n        kt_e: Tangential elastic stiffness (Pa/m).\n        mu: Friction coefficient (dimensionless).\n        c: Cohesion (Pa).\n\n    Returns:\n        A list containing [tn, tt, Knn, Knt, Ktn, Ktt].\n    \"\"\"\n    tn, tt = 0.0, 0.0\n    Knn, Knt, Ktn, Ktt = 0.0, 0.0, 0.0, 0.0\n\n    # Case 1: Contact Opening (wn >= 0)\n    if wn >= 0:\n        # Tractions and tangent matrix are zero.\n        # Initial values are already correct.\n        pass\n    # Case 2: Contact Compression (wn  0)\n    else:\n        # Normal traction (always elastic in compression)\n        tn = -kn_e * wn\n\n        # Trial tangential traction (elastic predictor)\n        tt_trial = kt_e * wt\n\n        # Frictional limit\n        phi_limit = mu * tn + c\n\n        # Check for sticking vs. sliding\n        if abs(tt_trial) = phi_limit:\n            # Sub-case 2.3.a: Elastic-Sticking\n            tt = tt_trial\n            Knn = -kn_e\n            Ktt = kt_e\n            # Knt and Ktn remain 0.0\n        else:\n            # Sub-case 2.3.b: Sliding (return mapping)\n            sign_wt = np.sign(wt)\n            tt = sign_wt * phi_limit\n            \n            Knn = -kn_e\n            Ktn = sign_wt * mu * (-kn_e)\n            # Knt and Ktt remain 0.0\n\n    return [tn, tt, Knn, Knt, Ktn, Ktt]\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Fixed material parameters\n    kn_e = 1e9    # Pa/m\n    kt_e = 5e8    # Pa/m\n    mu = 0.4      # dimensionless\n    c = 5e4       # Pa\n\n    # Test suite: list of tuples (wn, wt) in meters\n    test_cases = [\n        # Test case 1 (compression, sticking)\n        (-1e-4, 1e-4),\n        # Test case 2 (compression, sliding)\n        (-1e-4, 3e-4),\n        # Test case 3 (opening, no traction)\n        (1e-4, 2e-4),\n        # Test case 4 (compression, sliding with negative tangential jump)\n        (-2e-4, -1e-3),\n        # Test case 5 (boundary case at friction limit, treat as sticking)\n        (-1e-4, 1.8e-4),\n    ]\n\n    all_results = []\n    for wn, wt in test_cases:\n        result_vector = calculate_interface_response(wn, wt, kn_e, kt_e, mu, c)\n        # Convert the list to its string representation for the final output format\n        all_results.append(str(result_vector))\n\n    # The final print must be a single line containing a list of lists.\n    # Joining the string representations of each list achieves this.\n    print(f\"[{','.join(all_results)}]\")\n\n\nsolve()\n```", "id": "3499747"}]}