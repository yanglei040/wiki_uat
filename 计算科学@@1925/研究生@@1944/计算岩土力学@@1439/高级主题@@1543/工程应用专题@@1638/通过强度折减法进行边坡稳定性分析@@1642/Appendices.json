{"hands_on_practices": [{"introduction": "强度折减法不仅仅是一个数值程序，它的核心在于对材料强度参数的系统性削弱。本练习将引导你深入该方法的基础，通过推导折减后的等效摩擦角与折减系数之间的精确解析关系。理解这种非线性关系对于正确解读强度折减分析的结果至关重要，特别是对于区分直接折减角度与折减其正切值之间的微妙差异。", "problem": "考虑一个采用有限元法 (FEM) 中的强度折减法 (SSR) 进行分析的均质、各向同性边坡。土体遵循 Mohr–Coulomb 破坏准则，其有效黏聚力为 $c'$，有效摩擦角为 $\\phi'$。因此，在有效正应力为 $\\sigma_n'$ 的平面上，其发挥的抗剪强度由 $\\tau = c' + \\sigma_n' \\tan\\phi'$ 给出。在 SSR 方法中，强度参数通过一个试算安全系数 $F_s > 1$ 进行系统性折减，直到在数值模型中检测到整体破坏。标准的 SSR 折减方式适用于 $c' \\mapsto c_r' = c'/F_s$ 和 $\\tan\\phi' \\mapsto \\tan\\phi_r' = \\tan\\phi'/F_s$。\n\n从上述 Mohr–Coulomb 破坏条件和 SSR 折减方式出发，推导出一个单一的折减后摩擦角 $\\phi_r$，使得折减后的应力-强度关系可以写成与原始形式相同的函数形式，即 $\\tau_r = c_r' + \\sigma_n' \\tan\\phi_r$。将 $\\phi_r$ 明确地表示为以 $\\phi'$ 和 $F_s$ 为变量的闭式解析表达式，并指明角度单位为弧度。\n\n然后，利用正切和反正切函数的基本原理性质，分析在以下两种情况下 $\\phi_r$ 如何依赖于 $F_s$：\n- 小角度 $0 < \\phi' \\ll 1$ (以弧度计)，以及\n- 中到大角度，例如 $\\phi'$ 在 $0.5 \\lesssim \\phi' \\lesssim \\pi/3$ 范围内。\n\n在你的分析中，通过适当的级数展开和单调性论证，来证明 $\\phi_r$ 对 $F_s$ 的极限行为和敏感性。除了已述的 Mohr–Coulomb 准则和 SSR 折减方式外，不要假设或引用任何预先推导的强度折减公式。提供最终答案，即所要求的以弧度为单位的 $\\phi_r$ 的闭式解析表达式。无需四舍五入。", "solution": "该问题要求在强度折减法 (SSR) 的背景下推导折减后的摩擦角，并分析其性质。此问题具有科学依据，提法得当且客观，因此被认为是有效的。\n\n分析始于土体抗剪强度 $\\tau$ 的 Mohr–Coulomb 破坏准则。有效抗剪强度由黏聚力分量和摩擦分量之和给出。对于一个给定有效正应力为 $\\sigma_n'$ 的平面，其抗剪强度为：\n$$\n\\tau = c' + \\sigma_n' \\tan\\phi'\n$$\n此处，$c'$ 是有效黏聚力，$\\phi'$ 是有效内摩擦角。\n\n强度折减法 (SSR) 旨在寻找一个安全系数（记为 $F_s$），当将其应用于土体的强度参数时，能使土体达到极限平衡状态（即破坏状态）。问题指定了适用于 Mohr–Coulomb 参数的标准 SSR 折减方式：黏聚力 $c'$ 和摩擦角的正切值 $\\tan\\phi'$ 同时被系数 $F_s$ 折减。\n\n设折减后的强度参数记为 $c_r'$ 和 $\\phi_r$。根据题目陈述，新的、折减后的黏聚力为：\n$$\nc_r' = \\frac{c'}{F_s}\n$$\n题目指出，折减同样适用于摩擦角的正切值。这意味着新的、折减后摩擦角的正切值 $\\tan\\phi_r$ 是通过对原始摩擦角的正切值进行折减来定义的：\n$$\n\\tan\\phi_r = \\frac{\\tan\\phi'}{F_s}\n$$\n由此得到的折减后抗剪强度 $\\tau_r$，代表了破坏点上发挥的抗剪强度，其表达式与原始准则的函数形式相同，但使用了折减后的参数：\n$$\n\\tau_r = c_r' + \\sigma_n' \\tan\\phi_r\n$$\n问题要求一个以原始摩擦角 $\\phi'$ 和安全系数 $F_s$ 表示的折减后摩擦角 $\\phi_r$ 的闭式解析表达式。根据摩擦分量的折减定义，我们可以直接解出 $\\phi_r$。由于 $\\phi_r$ 是这样一个角，其正切值为 $\\frac{\\tan\\phi'}{F_s}$，我们可以使用反正切函数来表示 $\\phi_r$。假设角度 $\\phi'$ 和 $\\phi_r$ 都在主值范围 $(-\\pi/2, \\pi/2)$ 内（这是摩擦角的物理要求），我们有：\n$$\n\\phi_r = \\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right)\n$$\n这就是所要求的以弧度表示的折减后摩擦角的闭式表达式。\n\n接下来，我们针对 $\\phi'$ 的两种不同情况，分析 $\\phi_r$ 对 $F_s$ 的依赖关系。\n\n情况1：小角度 ($0 < \\phi' \\ll 1$ 弧度)\n\n对于小角度 $x$，$\\tan(x)$ 和 $\\arctan(x)$ 的麦克劳林级数展开为：\n$$\n\\tan(x) = x + \\frac{x^3}{3} + O(x^5)\n$$\n$$\n\\arctan(y) = y - \\frac{y^3}{3} + O(y^5)\n$$\n已知 $\\phi'$ 很小，我们可以近似 $\\tan\\phi'$：\n$$\n\\tan\\phi' \\approx \\phi'\n$$\n在我们关于 $\\phi_r$ 的表达式中，反正切函数的自变量变为 $\\frac{\\tan\\phi'}{F_s} \\approx \\frac{\\phi'}{F_s}$。由于 $F_s > 1$，该自变量也很小。因此，折减后的角度 $\\phi_r$ 也很小，这使得我们可以对反正切函数使用小角度近似：\n$$\n\\phi_r = \\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right) \\approx \\frac{\\tan\\phi'}{F_s} \\approx \\frac{\\phi'}{F_s}\n$$\n这表明，对于小摩擦角，折减后的角度 $\\phi_r$ 近似等于原始角度 $\\phi'$ 除以安全系数 $F_s$。该关系近似是线性的。\n\n为了更严谨，让我们将 $\\phi_r$ 的表达式按 $\\phi'$ 的幂次展开。令 $x = \\phi'$。\n$$\n\\frac{\\tan(x)}{F_s} = \\frac{x + x^3/3 + O(x^5)}{F_s} = \\frac{x}{F_s} + \\frac{x^3}{3F_s} + O(x^5)\n$$\n现在，我们将此式代入 $\\arctan(y)$ 的级数展开式，其中 $y = \\frac{\\tan(x)}{F_s}$：\n$$\n\\phi_r = \\left(\\frac{x}{F_s} + \\frac{x^3}{3F_s}\\right) - \\frac{1}{3}\\left(\\frac{x}{F_s}\\right)^3 + O(x^5)\n$$\n$$\n\\phi_r = \\frac{x}{F_s} + \\left(\\frac{1}{3F_s} - \\frac{1}{3F_s^3}\\right)x^3 + O(x^5)\n$$\n将 $x = \\phi'$ 代回，得到：\n$$\n\\phi_r = \\frac{\\phi'}{F_s} + \\frac{F_s^2 - 1}{3F_s^3}(\\phi')^3 + O((\\phi')^5)\n$$\n由于 $F_s > 1$，$(\\phi')^3$ 项的系数 $\\frac{F_s^2 - 1}{3F_s^3}$ 为正。这严谨地证明了 $\\phi_r$ 略大于线性近似值 $\\phi'/F_s$。这意味着，与假设直接折减角度 $\\phi' \\mapsto \\phi'/F_s$ 相比，对 $\\tan\\phi'$ 进行标准 SSR 折减导致摩擦角本身的折减程度较小。\n\n情况2：中到大角度 ($0.5 \\lesssim \\phi' \\lesssim \\pi/3$)\n\n在这个范围内，小角度近似不再有效，关系式 $\\phi_r = \\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right)$ 表现出高度非线性。为分析 $\\phi_r$ 对 $F_s$ 的敏感性，我们考察其偏导数 $\\frac{\\partial\\phi_r}{\\partial F_s}$。使用微分链式法则，其中 $u = \\frac{\\tan\\phi'}{F_s}$：\n$$\n\\frac{\\partial\\phi_r}{\\partial F_s} = \\frac{\\partial}{\\partial F_s} \\arctan(u) = \\frac{1}{1+u^2} \\frac{\\partial u}{\\partial F_s}\n$$\n$u$ 对 $F_s$ 的导数为：\n$$\n\\frac{\\partial u}{\\partial F_s} = \\tan\\phi' \\left(-\\frac{1}{F_s^2}\\right) = -\\frac{\\tan\\phi'}{F_s^2}\n$$\n将此代回，我们得到：\n$$\n\\frac{\\partial\\phi_r}{\\partial F_s} = \\frac{1}{1 + \\left(\\frac{\\tan\\phi'}{F_s}\\right)^2} \\left(-\\frac{\\tan\\phi'}{F_s^2}\\right) = -\\frac{\\tan\\phi'}{F_s^2 + (\\tan\\phi')^2}\n$$\n由于 $\\phi' \\in (0, \\pi/2)$，$\\tan\\phi' > 0$。因为 $F_s > 1$，分母始终为正。因此，$\\frac{\\partial\\phi_r}{\\partial F_s} < 0$，这证实了 $\\phi_r$ 是 $F_s$ 的单调递减函数。这在物理上是直观的：更大的安全系数要求更大的强度折减，从而导致更小的折减后摩擦角。\n\n折减的非线性可以通过证明不等式 $\\phi_r > \\phi'/F_s$ 对所有 $\\phi' \\in (0, \\pi/2)$ 和 $F_s > 1$ 成立来进一步说明。我们定义变量 $x$ 的两个函数：$f(x) = \\arctan\\left(\\frac{\\tan x}{F_s}\\right)$ 和 $g(x) = \\frac{x}{F_s}$。我们注意到 $f(0) = g(0) = 0$。现在我们比较它们的导数：\n$$\ng'(x) = \\frac{1}{F_s}\n$$\n$$\nf'(x) = \\frac{d}{dx}\\arctan\\left(\\frac{\\tan x}{F_s}\\right) = \\frac{1}{1+\\left(\\frac{\\tan x}{F_s}\\right)^2} \\cdot \\frac{\\sec^2 x}{F_s} = \\frac{F_s \\sec^2 x}{F_s^2 + \\tan^2 x}\n$$\n我们要检验是否 $f'(x) > g'(x)$：\n$$\n\\frac{F_s \\sec^2 x}{F_s^2 + \\tan^2 x} > \\frac{1}{F_s}\n$$\n$$\nF_s^2 \\sec^2 x > F_s^2 + \\tan^2 x\n$$\n使用恒等式 $\\sec^2 x = 1 + \\tan^2 x$：\n$$\nF_s^2 (1 + \\tan^2 x) > F_s^2 + \\tan^2 x\n$$\n$$\nF_s^2 + F_s^2 \\tan^2 x > F_s^2 + \\tan^2 x\n$$\n$$\n(F_s^2 - 1) \\tan^2 x > 0\n$$\n由于 $F_s > 1$，则 $F_s^2 - 1 > 0$。对于 $x \\in (0, \\pi/2)$，$\\tan^2 x > 0$。因此，该不等式成立。因为 $f(0) = g(0)$ 并且当 $x > 0$ 时 $f'(x) > g'(x)$，根据中值定理可知，对于所有 $x > 0$，$f(x) > g(x)$。代入 $x = \\phi'$，我们确切地证明了：\n$$\n\\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right) > \\frac{\\phi'}{F_s}\n$$\n这个不等式证实了标准的 SSR 折减方法比直接折减角度 $\\phi'$ 本身要不那么保守（即，得到一个更高的折减后摩擦角）。与线性的偏差 $\\phi_r - \\phi'/F_s$ 随着 $\\phi'$ 从小角度范围移动到中到大角度范围而增加。这种非线性行为是 Mohr–Coulomb 准则和标准 SSR 折减程序的内在属性。", "answer": "$$\\boxed{\\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right)}$$", "id": "3560645"}, {"introduction": "在理论基础之上，下一个关键步骤是掌握寻找临界强度折减系数的计算工作流程。本练习模拟了有限元软件中强度折减求解器的核心算法，要求你实现一个包含自适应步长控制和区间套索的迭代搜索过程。通过为一个简化的无限边坡模型编写代码，你将亲身体验如何从数值上精确地确定边坡的失稳点。", "problem": "设计并实现一个完整的、可运行的程序，该程序在采用自适应步长控制和对破坏乘数进行严格区间限定的强度折减法（SRM）分析中，为多个指定的边坡配置计算触发破坏的临界强度折减系数 $F_s^\\star$。分析必须基于以下基本原理。\n\n基本原理：\n- 力平衡要求内部发挥的剪切牵引力与外部驱动剪切需求相平衡。\n- 以有效应力表示的 Mohr–Coulomb 剪切强度为 $ \\tau_\\mathrm{s} = c' + \\sigma_n' \\tan \\phi'$, 其中 $c'$ 是有效黏聚力，$\\phi'$ 是有效内摩擦角。\n- 在强度折减法中，强度参数通过安全系数 $F_s$ 进行折减，即 $c'_r = c'/F_s$ 和 $\\tan \\phi'_r = \\tan \\phi'/F_s$。\n- 对于深度为 $z$ 的干性无限边坡，在平行于坡面的平面上，驱动剪应力和法向应力分别为 $ \\tau_\\mathrm{d}(z) = \\gamma z \\sin\\beta \\cos\\beta$ 和 $ \\sigma_n(z) = \\gamma z \\cos^2 \\beta$，其中 $\\gamma$ 是单位重量，$\\beta$ 是坡角。此处，取 $z = H$（特征深度等于边坡高度 $H$）。角度必须以度为单位提供，并在计算时转换为弧度。\n- 当找不到满足折减后强度容许条件的非线性平衡解时，即表示发生破坏。换言之，当平衡所需的发挥剪切牵引力超过折减后的强度时，即为破坏。\n\n你必须将该计算问题用纯数学术语表述如下。\n\n1) 针对每个试算 $F_s$ 的非线性平衡问题：\n- 在一个代表性界面上引入一个标量滑移位移 $w \\ge 0$，该界面具有单位面积的弹性刚度 $k_t$，并服从带有 Mohr–Coulomb 屈服上限的弹塑性本构律：\n  - 弹性试算牵引力：$t_\\mathrm{trial} = k_t w$。\n  - 折减后的屈服强度：$t_\\mathrm{y}(F_s) = c'/F_s + \\sigma_n \\tan\\phi'/F_s$。\n  - 容许牵引力：$t(w;F_s) = \\min\\{t_\\mathrm{trial}, t_\\mathrm{y}(F_s)\\}$。\n- 平衡残差为 $r(w;F_s) = t(w;F_s) - \\tau_\\mathrm{d}$，其中 $\\tau_\\mathrm{d} = \\gamma H \\sin\\beta \\cos\\beta$ 且 $\\sigma_n = \\gamma H \\cos^2 \\beta$。\n- 对于给定的 $F_s$，求解关于 $w \\ge 0$ 的非线性方程 $r(w;F_s)=0$。如果没有 $w$ 满足 $r(w;F_s)=0$（即，如果 $\\tau_\\mathrm{d} > t_\\mathrm{y}(F_s)$），则宣告该 $F_s$ 发生“破坏”。计算中角度必须解释为弧度。应力单位必须统一使用 $\\mathrm{kPa}$ 进行计算，其中 $\\gamma$ 的单位是 $\\mathrm{kN/m^3}$，$H$ 的单位是 $\\mathrm{m}$，因此 $\\gamma H$ 的单位是 $\\mathrm{kPa}$。\n\n2) 外部算法：自适应步长控制和 $F_s^\\star$ 的区间限定：\n- 从 $F_s = 1$ 开始。\n- 基于带符号的稳定裕度 $g(F_s) = t_\\mathrm{y}(F_s) - \\tau_\\mathrm{d}$，使用自适应步长 $\\Delta F_s$ 迭代地增加 $F_s$：\n  - 如果 $g(F_s) \\ge 0$，系统在该 $F_s$ 下是稳定的；以一个正步长增加 $F_s$。当 $g(F_s)$ 远大于零时，增大 $\\Delta F_s$；当 $g(F_s)$ 接近零时，减小 $\\Delta F_s$，并受限于为保证数值稳健性而设定的上下限。\n  - 如果 $g(F_s) < 0$，系统在该 $F_s$ 下是不稳定的；你已经对破坏乘数进行了区间限定。将最后一个稳定的 $F_s$ 记录为下界，将当前不稳定的 $F_s$ 记录为上界。\n- 如果 $F_s = 1$ 时的初始配置已经不稳定，则自适应地减小 $F_s$（例如，通过折半），直到达到稳定以获得一个下界，从而从下方对 $F_s^\\star$ 进行区间限定。\n- 一旦确定了满足 $g(F_s^\\mathrm{L}) \\ge 0$ 和 $g(F_s^\\mathrm{U}) < 0$ 的区间 $[F_s^\\mathrm{L}, F_s^\\mathrm{U}]$，就通过对 $g(F_s)$ 应用二分法来精确求解 $F_s^\\star$，直到满足容差标准。对 $F_s$ 使用 $10^{-8}$ 的收敛容差。\n- 最终报告的 $F_s^\\star$ 是使非线性平衡失效的最小 $F_s$（即强度折减的破坏乘数），也就是通过区间限定和二分法找到的 $g(F_s) = 0$ 的根。\n\n3) 数值要求：\n- 输入中的所有角度都以度为单位，并且必须在计算时转换为弧度。\n- 使用 $k_t = 10^3\\,\\mathrm{kPa}$ 作为单位面积的界面弹性刚度。该参数确保了平衡求解器中有一个定义明确的弹性预测量；最终的 $F_s^\\star$ 必不依赖于 $k_t$，因为破坏指标由容许性条件决定。\n- 实现带有安全措施的稳健自适应步长控制：强制 $\\Delta F_s \\in [10^{-2}, 2]$ 并设置最大外部迭代次数为 $10^4$ 以保证终止。\n\n测试套件：\n为以下四种情况提供 $F_s^\\star$。使用的单位为：$H$ (m)，$\\gamma$ (kN/m³)，$c'$ (kPa)，角度 (度)。将最终答案报告为无量纲的浮点数。程序必须按顺序计算所有四种情况，并将最终结果打印在单行上，格式为方括号内以逗号分隔的列表，每个值都精确到小数点后六位。\n\n- 情况 A（一般稳定情况）：\n  - $\\gamma = 20\\,\\mathrm{kN/m^3}$,\n  - $H = 10\\,\\mathrm{m}$,\n  - $\\beta = 30^\\circ$,\n  - $c' = 5\\,\\mathrm{kPa}$,\n  - $\\phi' = 30^\\circ$.\n- 情况 B（$F_s=1$ 时初始不稳定）：\n  - $\\gamma = 18\\,\\mathrm{kN/m^3}$,\n  - $H = 12\\,\\mathrm{m}$,\n  - $\\beta = 35^\\circ$,\n  - $c' = 0\\,\\mathrm{kPa}$,\n  - $\\phi' = 28^\\circ$.\n- 情况 C（稳定且具有较大的破坏乘数）：\n  - $\\gamma = 18\\,\\mathrm{kN/m^3}$,\n  - $H = 5\\,\\mathrm{m}$,\n  - $\\beta = 25^\\circ$,\n  - $c' = 2\\,\\mathrm{kPa}$,\n  - $\\phi' = 35^\\circ$.\n- 情况 D（边界情况）：\n  - $\\gamma = 21\\,\\mathrm{kN/m^3}$,\n  - $H = 8\\,\\mathrm{m}$,\n  - $\\beta = 26^\\circ$,\n  - $c' = 0\\,\\mathrm{kPa}$,\n  - $\\phi' = 26^\\circ$.\n\n最终输出格式：\n你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[x_1,x_2,x_3,x_4]$），每个 $x_i$ 都精确到小数点后六位。每个输出项是对应情况计算出的 $F_s^\\star$，并且是无量纲的。不得打印任何其他文本。", "solution": "该问题被评估为有效。它在科学上基于土力学原理，问题提法适定，并为数值求解提供了一套完整且一致的要求。问题要求设计并实现一个算法，用以寻找几种无限边坡配置下的临界强度折减系数 $F_s^\\star$。尽管该问题可以解析求解，但核心任务是实现指定的数值方案，该方案涉及自适应搜索和二分法，这在计算工程中是一项常见而实用的任务。\n\n求解过程如下：首先，建立控制物理和数学方程。其次，详细阐述用于定位临界安全系数的指定数值算法。最后，在 Python 程序中实现此算法以解决给定的测试用例。\n\n**1. 理论公式**\n\n本文分析一个无限长、干性的黏-摩阻边坡的稳定性。基本输入参数是土的单位重量 $\\gamma$、边坡高度 $H$（应力评估点的高度）、坡角 $\\beta$、有效黏聚力 $c'$ 和有效内摩擦角 $\\phi'$。\n\n对于位于与坡面平行的潜在破坏面上、深度为 $H$ 的一点，其驱动剪应力 $\\tau_\\mathrm{d}$ 和法向应力 $\\sigma_n$ 由下式给出：\n$$\n\\tau_\\mathrm{d} = \\gamma H \\sin\\beta \\cos\\beta\n$$\n$$\n\\sigma_n = \\gamma H \\cos^2\\beta\n$$\n问题指定了干性边坡，因此有效法向应力 $\\sigma_n'$ 等于总法向应力 $\\sigma_n$。土体的可用剪切强度由 Mohr-Coulomb 破坏准则描述：\n$$\n\\tau_s = c' + \\sigma_n \\tan\\phi'\n$$\n强度折减法（SRM）涉及寻找一个安全系数, $F_s$，通过将强度参数除以此系数，可使边坡达到极限平衡状态。折减后的强度参数 $c'_r$ 和 $\\phi'_r$ 为：\n$$\nc'_r = \\frac{c'}{F_s}\n$$\n$$\n\\tan\\phi'_r = \\frac{\\tan\\phi'}{F_s}\n$$\n因此，折减后的剪切强度，记为 $t_y(F_s)$，为：\n$$\nt_y(F_s) = \\frac{c'}{F_s} + \\sigma_n \\frac{\\tan\\phi'}{F_s} = \\frac{c' + \\sigma_n \\tan\\phi'}{F_s}\n$$\n问题引入了一个虚拟的弹塑性界面模型来形式化平衡条件。然而，破坏条件简化为驱动剪应力超过可用折减强度的时刻。仅当 $\\tau_\\mathrm{d} \\le t_y(F_s)$ 时，平衡状态才可能存在。临界状态（或破坏）发生在使平衡无法维持的最小 $F_s$ 值（记为 $F_s^\\star$）处。这对应于极限平衡条件 $\\tau_\\mathrm{d} = t_y(F_s^\\star)$。\n\n为了便于数值搜索，我们定义一个稳定裕度函数 $g(F_s)$：\n$$\ng(F_s) = t_y(F_s) - \\tau_\\mathrm{d} = \\frac{c' + \\sigma_n \\tan\\phi'}{F_s} - \\tau_\\mathrm{d}\n$$\n- 如果 $g(F_s) > 0$，对于给定的 $F_s$，边坡是稳定的。\n- 如果 $g(F_s) < 0$，对于给定的 $F_s$，边坡是不稳定的。\n- 如果 $g(F_s) = 0$，边坡处于极限平衡状态。\n\n因此，问题简化为求解方程 $g(F_s) = 0$ 的根。求解 $F_s$ 可得安全系数的解析解：\n$$\nF_s^\\star = \\frac{c' + \\sigma_n \\tan\\phi'}{\\tau_\\mathrm{d}} = \\frac{c' + \\gamma H \\cos^2\\beta \\tan\\phi'}{\\gamma H \\sin\\beta \\cos\\beta} = \\frac{c'}{\\gamma H \\sin\\beta \\cos\\beta} + \\frac{\\tan\\phi'}{\\tan\\beta}\n$$\n尽管存在这个可用于验证的解析公式，但问题要求实现一个特定的数值算法来找到 $F_s^\\star$。\n\n**2. 算法设计**\n\n任务的核心是实现一个求解 $g(F_s)=0$ 的寻根算法，该算法遵循规定的三阶段过程：自适应区间搜索、二分法精化和最终报告。所有角度都必须从度转换为弧度以进行三角函数计算。\n\n**阶段 1：区间搜索**\n目标是找到一个下界 $F_s^\\mathrm{L}$ 和一个上界 $F_s^\\mathrm{U}$，使得 $g(F_s^\\mathrm{L}) \\ge 0$ 且 $g(F_s^\\mathrm{U}) < 0$。搜索从 $F_s=1$ 开始。\n\n- **情况 1：初始稳定边坡 ($g(1) \\ge 0$)**\n  初始值 $F_s=1$ 作为下界，$F_s^\\mathrm{L} = 1$。我们必须通过迭代增加 $F_s$ 来搜索上界。\n  采用自适应步长规则。步长 $\\Delta F_s$ 应随着 $g(F_s)$ 接近零而减小。一个基于归一化稳定裕度的合适规则是：\n  $$\n  \\Delta F_s = \\alpha \\cdot F_s \\cdot \\frac{g(F_s)}{\\tau_\\mathrm{d}}\n  $$\n  其中 $\\alpha$ 是一个阻尼因子（例如，$\\alpha=0.5$）。为确保稳健性和进展，该步长被限制在指定的范围 $[\\Delta F_{s, \\min}, \\Delta F_{s, \\max}]$ 内，即 $[10^{-2}, 2]$。迭代过程为 $F_{s, i+1} = F_{s, i} + \\Delta F_s$，直到 $g(F_{s, i+1}) < 0$。此时，$F_s^\\mathrm{U} = F_{s, i+1}$，区间即告建立。\n\n- **情况 2：初始不稳定边坡 ($g(1) < 0$)**\n  初始值 $F_s=1$ 作为上界，$F_s^\\mathrm{U} = 1$。我们必须通过迭代减小 $F_s$ 来搜索下界。如建议所述，一种简单而稳健的方法是重复将 $F_s$ 折半，即 $F_{s, i+1} = F_{s, i} / 2$，直到 $g(F_{s, i+1}) \\ge 0$。此时，$F_s^\\mathrm{L} = F_{s, i+1}$，区间即告建立。\n\n在此阶段，使用最大迭代次数（$10^4$）作为防止无限循环的保障措施。\n\n**阶段 2：二分法精化**\n一旦找到区间 $[F_s^\\mathrm{L}, F_s^\\mathrm{U}]$，就应用二分法以高精度精化根 $F_s^\\star$。算法如下：\n1. 计算中点：$F_s^\\mathrm{mid} = (F_s^\\mathrm{L} + F_s^\\mathrm{U}) / 2$。\n2. 评估中点处的稳定裕度 $g(F_s^\\mathrm{mid})$。\n3. 更新区间：\n   - 如果 $g(F_s^\\mathrm{mid}) \\ge 0$，根在区间的上半部分，因此设 $F_s^\\mathrm{L} = F_s^\\mathrm{mid}$。\n   - 如果 $g(F_s^\\mathrm{mid}) < 0$，根在区间的下半部分，因此设 $F_s^\\mathrm{U} = F_s^\\mathrm{mid}$。\n4. 重复步骤 1-3，直到区间宽度 $(F_s^\\mathrm{U} - F_s^\\mathrm{L})$ 小于指定的容差 $10^{-8}$。\n\n**阶段 3：最终结果**\n临界安全系数 $F_s^\\star$ 的最终估计值取为最终区间的中点 $(F_s^\\mathrm{L} + F_s^\\mathrm{U}) / 2$。然后根据输出要求对此值进行格式化。\n\n这个综合算法确保了能根据问题的具体要求，稳健而准确地确定 $F_s^\\star$。", "answer": "```python\nimport numpy as np\n\ndef compute_fs_star(gamma, H, beta_deg, c_prime, phi_prime_deg):\n    \"\"\"\n    Computes the critical strength reduction factor (Fs_star) for an infinite slope.\n\n    The function implements a numerical scheme involving an adaptive search to\n    bracket the solution, followed by bisection to refine it to a high tolerance.\n\n    Args:\n        gamma (float): Unit weight of the soil (kN/m^3).\n        H (float): Characteristic depth/height (m).\n        beta_deg (float): Slope angle (degrees).\n        c_prime (float): Effective cohesion (kPa).\n        phi_prime_deg (float): Effective internal friction angle (degrees).\n\n    Returns:\n        float: The computed critical strength reduction factor, Fs_star.\n    \"\"\"\n    # Numerical parameters and tolerances from the problem statement\n    TOL = 1e-8\n    MAX_ITER_OUTER = 10000\n    MIN_DFs = 0.01\n    MAX_DFs = 2.0\n    # k_t is not needed for the simplified failure condition g(Fs)=0\n\n    # Convert angles from degrees to radians for computation\n    beta_rad = np.deg2rad(beta_deg)\n    phi_rad = np.deg2rad(phi_prime_deg)\n\n    # Calculate driving shear stress (tau_d) and normal stress (sigma_n)\n    tau_d = gamma * H * np.sin(beta_rad) * np.cos(beta_rad)\n    sigma_n = gamma * H * np.cos(beta_rad)**2\n    \n    # Handle the edge case where tau_d is zero or negative (e.g., beta >= 90 deg)\n    # The analytical Fs would be infinite. The numerical search might fail.\n    # For this problem's context, tau_d will be positive.\n    if tau_d = 0:\n        return np.inf # Practically stable for any Fs\n\n    # Define the stability margin function g(Fs)\n    # g(Fs) = t_y(Fs) - tau_d\n    strength_term = c_prime + sigma_n * np.tan(phi_rad)\n    \n    # If the strength term is zero or negative, the slope is unconditionally unstable\n    if strength_term = 0:\n        return 0.0\n        \n    g = lambda Fs: strength_term / Fs - tau_d\n\n    # --- Phase 1: Bracketing Search ---\n    fs_lower = None\n    fs_upper = None\n    \n    fs_current = 1.0\n    margin = g(fs_current)\n\n    if margin >= 0:  # Initially stable case (g(1) >= 0)\n        fs_lower = fs_current\n        # Search for an upper bound by increasing Fs\n        for _ in range(MAX_ITER_OUTER):\n            # Adaptive step size calculation\n            # Proportional to the normalized margin, damped by a factor 0.5\n            # This makes the step larger when far from failure, smaller when close\n            if tau_d > 0:\n                delta_fs_calc = 0.5 * fs_current * (g(fs_current) / tau_d)\n            else: # Should not happen with valid inputs\n                delta_fs_calc = MIN_DFs\n            \n            delta_fs = np.clip(delta_fs_calc, MIN_DFs, MAX_DFs)\n            \n            fs_next = fs_current + delta_fs\n            margin_next = g(fs_next)\n\n            if margin_next  0:\n                fs_upper = fs_next\n                break\n            else:\n                fs_current = fs_next\n        else: # Loop finished without finding an upper bound\n            raise RuntimeError(\"Bracketing failed: could not find an upper bound.\")\n\n    else:  # Initially unstable case (g(1)  0)\n        fs_upper = fs_current\n        # Search for a lower bound by decreasing Fs (halving)\n        for _ in range(MAX_ITER_OUTER):\n            fs_next = fs_current / 2.0\n            margin_next = g(fs_next)\n            \n            if margin_next >= 0:\n                fs_lower = fs_next\n                break\n            else:\n                fs_current = fs_next\n        else: # Loop finished without finding a lower bound\n             raise RuntimeError(\"Bracketing failed: could not find a lower bound.\")\n\n    if fs_lower is None or fs_upper is None:\n        raise RuntimeError(\"Bracketing failed unexpectedly.\")\n\n    # --- Phase 2: Bisection Refinement ---\n    while (fs_upper - fs_lower) > TOL:\n        fs_mid = (fs_lower + fs_upper) / 2.0\n        if fs_mid == fs_lower or fs_mid == fs_upper: # Reached precision limit\n            break\n        \n        margin_mid = g(fs_mid)\n\n        if margin_mid >= 0:\n            fs_lower = fs_mid\n        else:\n            fs_upper = fs_mid\n            \n    # --- Phase 3: Final Result ---\n    fs_star = (fs_lower + fs_upper) / 2.0\n    return fs_star\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases as defined in the problem statement\n    test_cases = [\n        # Case A (general stable case)\n        {'gamma': 20.0, 'H': 10.0, 'beta_deg': 30.0, 'c_prime': 5.0, 'phi_prime_deg': 30.0},\n        # Case B (initially unstable at Fs=1)\n        {'gamma': 18.0, 'H': 12.0, 'beta_deg': 35.0, 'c_prime': 0.0, 'phi_prime_deg': 28.0},\n        # Case C (stable with larger collapse multiplier)\n        {'gamma': 18.0, 'H': 5.0, 'beta_deg': 25.0, 'c_prime': 2.0, 'phi_prime_deg': 35.0},\n        # Case D (boundary case)\n        {'gamma': 21.0, 'H': 8.0, 'beta_deg': 26.0, 'c_prime': 0.0, 'phi_prime_deg': 26.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        fs_star = compute_fs_star(**case)\n        results.append(fs_star)\n\n    # Format the final output according to the specified format\n    # Comma-separated list, in brackets, with each value rounded to 6 decimal places.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3560694"}, {"introduction": "实际的岩土工程分析往往涉及在不同本构模型之间进行选择。本高级练习探讨了这种选择对强度折减分析结果的实际影响，特别是比较了具有角点和洛德角（Lode angle）依赖性的Mohr-Coulomb模型与更简单的Drucker-Prager模型。通过编程实现两种模型的拟合与比较，你将量化因本构模型简化而导致的强度折减系数预测误差，从而更深刻地理解模型选择的重要性。", "problem": "您必须编写一个完整且可运行的程序，比较当Drucker–Prager (DP)模型通过三轴压缩和三轴拉伸子午线拟合Mohr–Coulomb (MC)模型时，两个模型预测的强度折减系数(SRF)。该过程必须基于有效的力学和计算岩土力学原理。程序必须实现以下内容，使用指定的物理单位和角度单位，并必须以指定的最终格式返回所要求的数值输出。\n\n推导的基本依据如下。设$p$表示平均应力，$q$表示由$q = \\sqrt{3 J_2}$定义的第二偏应力不变量，两者均采用压为正的符号约定。对于具有粘聚力$c$和摩擦角$\\phi$的Mohr–Coulomb (MC)模型，其在$p$–$q$空间中的三轴压缩(TXC)和三轴拉伸(TXE)子午线是公认的，并由以下线性关系给出：\n$$\nq_{\\mathrm{MC,TXC}}(p;c,\\phi) = M_c(\\phi)\\, p + K_c(c,\\phi),\n\\quad\nq_{\\mathrm{MC,TXE}}(p;c,\\phi) = M_e(\\phi)\\, p + K_e(c,\\phi),\n$$\n其中\n$$\nM_c(\\phi) = \\frac{6 \\sin\\phi}{3 - \\sin\\phi}, \\quad K_c(c,\\phi) = \\frac{6 c \\cos\\phi}{3 - \\sin\\phi},\n$$\n$$\nM_e(\\phi) = \\frac{6 \\sin\\phi}{3 + \\sin\\phi}, \\quad K_e(c,\\phi) = \\frac{6 c \\cos\\phi}{3 + \\sin\\phi}.\n$$\n这些子午线代表了MC模型在极端Lode角（Lode角定义为$\\theta$）下的$p$–$q$屈服轨迹，分别对应于轴对称三轴压缩($\\theta = -\\pi/6$)和轴对称三轴拉伸($\\theta = +\\pi/6$)。Lode角量化了第三不变量和主应力排序的影响；MC模型表现出Lode角依赖性，而DP模型则不。\n\nDrucker–Prager (DP)模型在$p$–$q$平面上定义了一条单一的线性子午线，\n$$\nq_{\\mathrm{DP}}(p;\\,c,\\phi) = M_{\\mathrm{DP}}(c,\\phi)\\, p + K_{\\mathrm{DP}}(c,\\phi),\n$$\n该子午线与Lode角无关。为了使DP模型与MC模型具有可比性，您必须通过在指定的平均应力区间内最小化子午线偏差的平方和，将DP子午线拟合到MC的TXC和TXE子午线上。具体来说，对于一个拟合区间$p \\in [0, P_{\\mathrm{fit}}]$，定义一个由两条MC子午线上的点组成的聚合数据集，\n$$\n\\{(p_i, q_{\\mathrm{MC,TXC}}(p_i;c,\\phi))\\}_{i=1}^{N} \\cup \\{(p_i, q_{\\mathrm{MC,TXE}}(p_i;c,\\phi))\\}_{i=1}^{N},\n$$\n其中$p_i$在$[0, P_{\\mathrm{fit}}]$上均匀分布，然后确定单一的线性DP子午线$q = M_{\\mathrm{DP}}\\, p + K_{\\mathrm{DP}}$，使其在整个组合数据集上的总残差平方和最小。这是一个标准的线性回归问题；最优的$M_{\\mathrm{DP}}$和$K_{\\mathrm{DP}}$是拟合聚合数据点的最小二乘线的斜率和截距。\n\n在通过强度折减法(SRM)进行边坡稳定性的强度折减分析中，强度折减系数(SRF) $S$被用于折减MC剪切强度参数，如下所示：\n$$\nc_R(S) = \\frac{c}{S}, \\quad \\tan\\phi_R(S) = \\frac{\\tan\\phi}{S}, \\quad \\phi_R(S) = \\arctan\\!\\left(\\frac{\\tan\\phi}{S}\\right).\n$$\n折减后，MC子午线变为\n$$\nq_{\\mathrm{MC,TXC}}(p;c_R,\\phi_R) = M_c(\\phi_R)\\, p + K_c(c_R,\\phi_R), \\quad\nq_{\\mathrm{MC,TXE}}(p;c_R,\\phi_R) = M_e(\\phi_R)\\, p + K_e(c_R,\\phi_R),\n$$\n而用于比较的DP子午线则根据相同的最小二乘程序在$[0, P_{\\mathrm{fit}}]$上对折减后的参数重新进行拟合，得到\n$$\nq_{\\mathrm{DP}}(p;c_R,\\phi_R) = M_{\\mathrm{DP}}(c_R,\\phi_R)\\, p + K_{\\mathrm{DP}}(c_R,\\phi_R).\n$$\n\n给定在指定平均应力$p$和Lode角$\\theta$下所要求的偏应力水平$q_d$，MC模型预测的SRF（表示为$S_{\\mathrm{MC}}$）是以下方程的解：\n$$\nq_{\\mathrm{MC}}(p;\\, c_R(S_{\\mathrm{MC}}), \\phi_R(S_{\\mathrm{MC}}), \\theta) = q_d,\n$$\n其中$q_{\\mathrm{MC}}(p;\\cdot,\\cdot,\\theta)$是根据测试用例选择的在$\\theta = -\\pi/6$ (TXC)或$\\theta = +\\pi/6$ (TXE)下的相应MC子午线。类似地，DP模型预测的SRF（表示为$S_{\\mathrm{DP}}$）是以下方程的解：\n$$\nq_{\\mathrm{DP}}(p;\\, c_R(S_{\\mathrm{DP}}), \\phi_R(S_{\\mathrm{DP}})) = q_d.\n$$\n您必须计算由Lode角效应引起的相对SRF误差\n$$\nE = \\frac{S_{\\mathrm{DP}}}{S_{\\mathrm{MC}}} - 1.\n$$\n\n角度单位规定：所有输入和内部计算中的角度必须以度为单位，除非在计算三角函数时需要转换为弧度。物理单位规定：所有应力（$p$，$q$，$c$）必须以千帕(kPa)为单位处理。您的程序必须为每个测试用例生成一个浮点数$E$。\n\n为确保科学真实性和可测试性，请使用以下测试套件，并假设应力不变量采用压为正的约定：\n\n- 测试用例1（正常路径，三轴压缩）：\n  - $c = 20$ kPa,\n  - $\\phi = 35$ 度,\n  - $p = 150$ kPa,\n  - $\\theta = -30$ 度 (三轴压缩),\n  - $q_d = 220$ kPa,\n  - $P_{\\mathrm{fit}} = 150$ kPa.\n\n- 测试用例2（正常路径，三轴拉伸）：\n  - $c = 20$ kPa,\n  - $\\phi = 35$ 度,\n  - $p = 150$ kPa,\n  - $\\theta = +30$ 度 (三轴拉伸),\n  - $q_d = 160$ kPa,\n  - $P_{\\mathrm{fit}} = 150$ kPa.\n\n- 测试用例3（较低强度，粘聚力-摩擦力混合，三轴压缩）：\n  - $c = 5$ kPa,\n  - $\\phi = 20$ 度,\n  - $p = 50$ kPa,\n  - $\\theta = -30$ 度,\n  - $q_d = 40$ kPa,\n  - $P_{\\mathrm{fit}} = 50$ kPa.\n\n- 测试用例4（边界情况，零粘聚力，高摩擦力，三轴拉伸）：\n  - $c = 0$ kPa,\n  - $\\phi = 45$ 度,\n  - $p = 100$ kPa,\n  - $\\theta = +30$ 度,\n  - $q_d = 90$ kPa,\n  - $P_{\\mathrm{fit}} = 100$ kPa.\n\n对于每个测试用例，您必须：\n- 使用最小二乘法，在$p \\in [0, P_{\\mathrm{fit}}]$上，将DP子午线拟合到组合的MC TXC和MC TXE子午线上，参数为由未知SRF $S$决定的折减后参数。\n- 使用确保单调区间和收敛的数值求根程序，分别求解$S_{\\mathrm{MC}}$和$S_{\\mathrm{DP}}$。\n- 计算相对SRF误差$E = S_{\\mathrm{DP}}/S_{\\mathrm{MC}} - 1$。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含以上四个测试用例的结果，形式为方括号内以逗号分隔的列表，顺序为$[E_1,E_2,E_3,E_4]$。例如，输出必须是$[x_1,x_2,x_3,x_4]$的形式，其中每个$x_i$都是一个浮点数。不得打印任何额外文本。", "solution": "该问题已经过验证，并被认为是**有效的**。它在科学上基于连续介质力学和计算岩土力学的原理，特别是关于Mohr-Coulomb (MC)和Drucker–Prager (DP)屈服准则。该问题定义明确、客观，并为获得唯一解提供了所有必要的数据和定义。\n\n解决方案通过以下步骤实现：\n\n1.  **Mohr-Coulomb (MC) 子午线**: 问题在$p$-$q$应力不变量空间中定义了MC屈服条件，其中$p$是平均应力，$q$是偏应力度量$q=\\sqrt{3J_2}$。轴对称三轴压缩（TXC，Lode角$\\theta = -30^\\circ$）和三轴拉伸（TXE，Lode角$\\theta = +30^\\circ$）的屈服轨迹由下式给出：\n    $$\n    q_{\\mathrm{MC,TXC}}(p;c,\\phi) = M_c(\\phi)\\, p + K_c(c,\\phi)\n    $$\n    $$\n    q_{\\mathrm{MC,TXE}}(p;c,\\phi) = M_e(\\phi)\\, p + K_e(c,\\phi)\n    $$\n    这些参数是材料粘聚力$c$和内摩擦角$\\phi$的函数：\n    $$\n    M_c(\\phi) = \\frac{6 \\sin\\phi}{3 - \\sin\\phi}, \\quad K_c(c,\\phi) = \\frac{6 c \\cos\\phi}{3 - \\sin\\phi}\n    $$\n    $$\n    M_e(\\phi) = \\frac{6 \\sin\\phi}{3 + \\sin\\phi}, \\quad K_e(c,\\phi) = \\frac{6 c \\cos\\phi}{3 + \\sin\\phi}\n    $$\n    所有输入的角度$\\phi$都以度为单位，并在进行三角函数计算时转换为弧度。\n\n2.  **Drucker-Prager (DP) 子午线拟合**: DP模型是一个与Lode角无关的（圆锥形）屈服面，在$p$-$q$平面上表示为一条直线：\n    $$\n    q_{\\mathrm{DP}}(p;\\,M_{\\mathrm{DP}},K_{\\mathrm{DP}}) = M_{\\mathrm{DP}}\\, p + K_{\\mathrm{DP}}\n    $$\n    为了将DP与MC关联起来，其参数$M_{\\mathrm{DP}}$和$K_{\\mathrm{DP}}$通过在平均应力区间$p \\in [0, P_{\\mathrm{fit}}]$上对两个MC子午线进行最小二乘拟合来确定。目标是最小化残差平方和的积分：\n    $$\n    J(M_{\\mathrm{DP}}, K_{\\mathrm{DP}}) = \\int_{0}^{P_{\\mathrm{fit}}} \\left[ (q_{\\mathrm{DP}} - q_{\\mathrm{MC,TXC}})^2 + (q_{\\mathrm{DP}} - q_{\\mathrm{MC,TXE}})^2 \\right] dp\n    $$\n    通过设置偏导数为零（$\\frac{\\partial J}{\\partial M_{\\mathrm{DP}}} = 0$和$\\frac{\\partial J}{\\partial K_{\\mathrm{DP}}} = 0$）来最小化$J$关于$M_{\\mathrm{DP}}$和$K_{\\mathrm{DP}}$的函数，可以得到一个关于最优参数的线性方程组。该方程组的解非常简洁：\n    $$\n    M_{\\mathrm{DP}} = \\frac{M_c(\\phi) + M_e(\\phi)}{2}\n    $$\n    $$\n    K_{\\mathrm{DP}} = \\frac{K_c(c,\\phi) + K_e(c,\\phi)}{2}\n    $$\n    这个结果表明，最佳拟合的DP子午线是MC压缩和拉伸子午线的平均值。至关重要的是，最优参数$M_{\\mathrm{DP}}$和$K_{\\mathrm{DP}}$与拟合区间的端点$P_{\\mathrm{fit}}$无关，因此在这个特定公式中，$P_{\\mathrm{fit}}$是一个上下文参数，而不是计算参数。\n\n3.  **强度折减法 (SRM)**: SRM的核心是通过一个强度折减系数$S$逐步折减材料的剪切强度参数：\n    $$\n    c_R(S) = \\frac{c}{S}, \\quad \\phi_R(S) = \\arctan\\left(\\frac{\\tan\\phi}{S}\\right)\n    $$\n    对于给定的应力状态$(p, q_d, \\theta)$，预测的SRF是使折减强度后的屈服面恰好通过该应力点时的$S$值。\n\n4.  **求解SRF**: 我们必须通过求解两个独立的非线性方程来找到SRF值$S_{\\mathrm{MC}}$和$S_{\\mathrm{DP}}$。\n    -   对于MC模型，根据Lode角$\\theta$选择特定的子午线（TXC或TXE）。求解$S_{\\mathrm{MC}}$的方程是：\n        $$\n        f_{\\mathrm{MC}}(S) = q_{\\mathrm{MC}}(p; c_R(S), \\phi_R(S), \\theta) - q_d = 0\n        $$\n    -   对于拟合的DP模型，求解$S_{\\mathrm{DP}}$的方程是：\n        $$\n        f_{\\mathrm{DP}}(S) = q_{\\mathrm{DP}}(p; c_R(S), \\phi_R(S)) - q_d = 0\n        $$\n        其中参数$M_{\\mathrm{DP}}$和$K_{\\mathrm{DP}}$本身是折减后强度参数$c_R(S)$和$\\phi_R(S)$的函数。\n\n5.  **数值求解与误差计算**: 函数$f_{\\mathrm{MC}}(S)$和$f_{\\mathrm{DP}}(S)$对于$S0$是单调递减的。这一性质保证了根的唯一性，并允许使用稳健的数值求根算法。我们采用Brent方法（`scipy.optimize.brentq`），该方法需要一个包含根的区间。一个合适的区间$[a, b]$是使得$f(a)$和$f(b)$异号的区间。鉴于其单调性，对于标准的岩土工程问题，一个宽泛的区间如$[0.1, 20]$足以找到解。在解出$S_{\\mathrm{MC}}$和$S_{\\mathrm{DP}}$后，相对误差$E$计算如下：\n    $$\n    E = \\frac{S_{\\mathrm{DP}}}{S_{\\mathrm{MC}}} - 1\n    $$\n这个误差量化了当一个依赖Lode角的模型(MC)被一个以这种方式拟合的不依赖Lode角的模型(DP)近似时，在预测安全系数方面的差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Implements the full validation and solution logic as required.\n    \"\"\"\n\n    # --- Physics / Constitutive Model Functions ---\n    def get_mc_meridian_params(c, phi_deg):\n        \"\"\"\n        Calculates the parameters for Mohr-Coulomb triaxial compression (TXC)\n        and triaxial extension (TXE) meridians in p-q space.\n\n        Args:\n            c (float): Cohesion in kPa.\n            phi_deg (float): Friction angle in degrees.\n\n        Returns:\n            tuple: A tuple (M_c, K_c, M_e, K_e) of meridian parameters.\n        \"\"\"\n        phi_rad = np.deg2rad(phi_deg)\n        sin_phi = np.sin(phi_rad)\n        cos_phi = np.cos(phi_rad)\n        \n        den_c = 3.0 - sin_phi\n        den_e = 3.0 + sin_phi\n        \n        # Avoid division by zero if phi is exactly 90 degrees\n        if np.isclose(den_c, 0):\n            den_c = 1e-12\n        \n        # TXC parameters\n        M_c = (6.0 * sin_phi) / den_c\n        K_c = (6.0 * c * cos_phi) / den_c\n        \n        # TXE parameters\n        M_e = (6.0 * sin_phi) / den_e\n        K_e = (6.0 * c * cos_phi) / den_e\n        \n        return M_c, K_c, M_e, K_e\n\n    # --- Core SRF Functions ---\n    def get_reduced_strength(c, phi_deg, S):\n        \"\"\"\n        Applies the Strength Reduction Factor (SRF) S to the strength parameters.\n        \n        Args:\n            c (float): Original cohesion.\n            phi_deg (float): Original friction angle in degrees.\n            S (float): Strength Reduction Factor.\n\n        Returns:\n            tuple: A tuple (c_R, phi_R_deg) of reduced strength parameters.\n        \"\"\"\n        if S = 0:\n            return np.inf, 90.0\n        \n        c_R = c / S\n        \n        if np.isclose(phi_deg, 0.0):\n            phi_R_deg = 0.0\n        else:\n            tan_phi = np.tan(np.deg2rad(phi_deg))\n            phi_R_deg = np.rad2deg(np.arctan(tan_phi / S))\n            \n        return c_R, phi_R_deg\n\n    def calculate_srf_error(c, phi_deg, p, q_d, theta_deg):\n        \"\"\"\n        Solves for S_mc and S_dp, then computes the relative error E.\n        The P_fit parameter is noted to be redundant for the calculation itself.\n        \"\"\"\n        \n        # Objective function for Mohr-Coulomb SRF.\n        # This is the residual: q_yield(S) - q_d\n        def f_mc(S):\n            c_R, phi_R_deg = get_reduced_strength(c, phi_deg, S)\n            M_c, K_c, M_e, K_e = get_mc_meridian_params(c_R, phi_R_deg)\n            \n            if theta_deg  0:  # Triaxial Compression\n                q_yield = M_c * p + K_c\n            else:  # Triaxial Extension\n                q_yield = M_e * p + K_e\n            \n            return q_yield - q_d\n            \n        # Objective function for Drucker-Prager SRF.\n        def f_dp(S):\n            c_R, phi_R_deg = get_reduced_strength(c, phi_deg, S)\n            M_c, K_c, M_e, K_e = get_mc_meridian_params(c_R, phi_R_deg)\n            \n            # DP parameters are the average of MC TXC and TXE parameters\n            M_dp = (M_c + M_e) / 2.0\n            K_dp = (K_c + K_e) / 2.0\n            \n            q_yield = M_dp * p + K_dp\n            \n            return q_yield - q_d\n\n        # A robust bracket for the root-finding algorithm.\n        # f(S) is monotonic, so a root is guaranteed if a solution exists.\n        s_min, s_max = 0.1, 50.0\n\n        try:\n             s_mc = brentq(f_mc, s_min, s_max, xtol=1e-9, rtol=1e-9)\n             s_dp = brentq(f_dp, s_min, s_max, xtol=1e-9, rtol=1e-9)\n        except ValueError:\n            # This would occur if the root is not bracketed, indicating an\n            # issue with the problem spec (e.g., q_d outside physical limits).\n            # For the given test cases, this should not happen.\n            return np.nan\n\n        error = s_dp / s_mc - 1.0\n        return error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (c [kPa], phi [deg], p [kPa], theta [deg], q_d [kPa], P_fit [kPa])\n        (20.0, 35.0, 150.0, -30.0, 220.0, 150.0),\n        (20.0, 35.0, 150.0, 30.0, 160.0, 150.0),\n        (5.0, 20.0, 50.0, -30.0, 40.0, 50.0),\n        (0.0, 45.0, 100.0, 30.0, 90.0, 100.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        c, phi, p, theta, q_d, _ = case # P_fit is unused in the calculation\n        result = calculate_srf_error(c, phi, p, q_d, theta)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3560689"}]}