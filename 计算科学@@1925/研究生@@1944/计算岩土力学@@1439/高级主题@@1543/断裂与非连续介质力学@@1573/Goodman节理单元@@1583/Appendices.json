{"hands_on_practices": [{"introduction": "在将本构模型用于实际仿真之前，我们必须首先根据已知的解析解来验证其实现的正确性。本练习将指导您完成一个针对Goodman节理单元剪切行为的基础“斑块测试”(patch test)。您将实现一个包含库仑摩擦($\\mu$)的弹塑性本构模型，并验证您的代码能否在弹性与塑性两种情况下都正确计算剪切牵引力($t_s$)。[@problem_id:3528461]", "problem": "在一个刚性块沿一个平面岩石节理滑动的场景中，该节理通过有限元法 (FEM) 中的 Goodman 节理单元进行建模。Goodman 节理单元是一个零厚度界面，在弹性范围内，其传递的面力与节理两侧的相对位移成正比。该节理具有法向和剪切刚度，分别表示为 $k_n$ 和 $k_s$。该刚性块受到约束，仅沿节理发生切向滑动，并且法向应力保持在预设值 $\\sigma_n$ 不变。滑动行为遵循剪切方向的弹性完美塑性行为，并采用库仑摩擦模型，其特征为摩擦系数 $\\mu$ 和黏聚力 $c$。自由度 (DOF) 被限制在剪切方向，且假定节理在弹性范围内是平面的、均质的且完全粘合的。\n\n根据界面上的面力平衡和 Goodman 节理单元的线性弹性弹簧定律的定义，弹性范围内的面力-位移关系按分量定义为\n$$\nt_n = k_n \\,\\delta_n, \\quad t_s = k_s \\,\\delta_s,\n$$\n其中 $t_n$ 是法向面力，$t_s$ 是剪切面力，$\\delta_n$ 是相对法向位移，$\\delta_s$ 是沿节理的相对剪切位移。在存在剪切库仑摩擦的情况下，弹性范围受限于屈服边界\n$$\n|t_s| \\le \\tau_{\\max}, \\quad \\tau_{\\max} = c + \\mu \\,\\sigma_n,\n$$\n其中 $c$ 是黏聚力，单位为帕斯卡，$\\mu$ 是无量纲摩擦系数。当 $|k_s \\,\\delta_s| > \\tau_{\\max}$ 时，节理发生剪切屈服，面力在库仑极限处达到饱和，其符号与滑动方向一致：\n$$\nt_s = \\operatorname{sign}(\\delta_s) \\,\\tau_{\\max}.\n$$\n\n构建一个斑块测试，其中一个刚性块在恒定的 $\\sigma_n$ 下沿节理滑动，并验证计算出的剪切面力 $t_s$ 在弹性范围内（包括等式仍然成立的屈服开始点）等于解析解 $t_s = k_s \\,\\delta_s$。计算模型应实现以下 Goodman 节理单元的剪切本构法则：\n$$\nt_s(\\delta_s;\\sigma_n,k_s,\\mu,c) = \\operatorname{sign}(\\delta_s)\\,\\min\\!\\left(k_s\\,|\\delta_s|,\\;c+\\mu\\,\\sigma_n\\right).\n$$\n\n您的任务是编写一个程序，对每个测试用例，使用上述本构法则计算 $t_s$，并在状态处于弹性范围内时，返回一个布尔值，指示 $t_s$ 是否在指定的数值容差内等于解析弹性表达式 $k_s\\,\\delta_s$；否则返回一个指示不等的布尔值。比较应使用 $10^{-12}$ 的相对容差和 $10^{-9}$ 帕斯卡的绝对容差。所有物理量必须使用以下单位：位移单位为米 (m)，刚度单位为帕斯卡/米 (Pa/m)，面力和应力单位为帕斯卡 (Pa)，摩擦系数为无量纲单位。\n\n实现以下参数测试套件 $(\\sigma_n, k_s, \\mu, c, \\delta_s)$，单位如上所述：\n\n- 情况1 (严格弹性，正向滑动): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,10^{-4})$。\n- 情况2 (屈服开始，等式成立): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,1.2\\times10^{-4})$。\n- 情况3 (屈服后，正向滑动): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,3\\times10^{-4})$。\n- 情况4 (严格弹性，零法向应力，黏性节理): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (0,\\,10^9,\\,0.5,\\,5\\times10^4,\\,10^{-5})$。\n- 情况5 (屈服后，零法向应力，黏性节理): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (0,\\,10^9,\\,0.5,\\,5\\times10^4,\\,10^{-3})$。\n- 情况6 (退化刚度，弹性产生的剪切阻力为零): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (2\\times10^6,\\,0,\\,0.5,\\,0,\\,1)$。\n- 情况7 (严格弹性，负向滑动): $(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,-10^{-4})$。\n\n对于每种情况，使用本构法则计算 $t_s$，计算解析弹性表达式 $k_s\\,\\delta_s$，使用准则 $|k_s\\,\\delta_s| \\le c + \\mu\\,\\sigma_n$ (允许相等情况视为弹性) 判断状态是否为弹性，并返回一个布尔值：\n- 如果状态是弹性的，并且 $t_s$ 在指定容差内等于 $k_s \\,\\delta_s$，则返回 true。\n- 否则返回 false。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，[result_1,result_2,...]）。每个情况的输出必须是布尔值。不需要用户输入，也不应使用外部文件。最终答案必须用 Python 语言实现，并且必须是一个完整、可运行的程序。", "solution": "该问题在科学上和数学上都是合理的、适定的，并为唯一解提供了所有必要信息。Goodman 节理单元、库仑摩擦和弹性完美塑性本构模型的概念是计算岩土力学的基础。该问题构成了对本构律数值实现的标准验证测试，通常称为斑块测试。所有参数和测试用例都已明确定义。因此，该问题是有效的。\n\n解决方案要求实现一个给定的节理剪切面力 $t_s$ 的本构法则，并在特定条件下根据解析弹性解测试其行为。关键步骤是确定节理的状态（弹性或塑性），然后相应地计算面力。\n\n首先，我们分析所提供的本构关系：\n$$\nt_s(\\delta_s;\\sigma_n,k_s,\\mu,c) = \\operatorname{sign}(\\delta_s)\\,\\min\\!\\left(k_s\\,|\\delta_s|,\\;c+\\mu\\,\\sigma_n\\right)\n$$\n该方程描述了基于库仑摩擦屈服准则的弹性完美塑性材料响应。让我们来剖析这个表达式。\n\n节理能够承受的最大剪切面力，或称剪切强度 $\\tau_{\\max}$，由库仑破坏准则定义：\n$$\n\\tau_{\\max} = c + \\mu\\,\\sigma_n\n$$\n其中 $c$ 是黏聚力，$\\mu$ 是摩擦系数，$\\sigma_n$ 是恒定的法向应力。由于在许多岩土力学约定中，压应力被定义为正值，并且该块体很可能在挤压节理，我们将假定 $\\sigma_n \\ge 0$。\n\n项 $k_s\\,\\delta_s$ 代表节理的纯弹性响应，其中 $k_s$ 是剪切刚度，$\\delta_s$ 是相对剪切位移。这是“试探”弹性剪切面力。该试探面力的大小为 $|k_s\\,\\delta_s|$。由于剪切刚度 $k_s$ 是一个非负物理属性 ($k_s \\ge 0$)，这可以写成 $k_s\\,|\\delta_s|$。\n\n节理的状态是通过比较试探弹性面力的大小与剪切强度来确定的：\n1.  **弹性状态**：如果 $k_s\\,|\\delta_s| \\le \\tau_{\\max}$，节理表现为弹性行为。剪切面力不足以引起滑动。在这种情况下，本构法则中的 `min` 函数求值为 $k_s\\,|\\delta_s|$：\n    $$\n    t_s = \\operatorname{sign}(\\delta_s) \\cdot (k_s\\,|\\delta_s|)\n    $$\n    由于 $\\operatorname{sign}(\\delta_s)\\,|\\delta_s| = \\delta_s$，这可以简化为：\n    $$\n    t_s = k_s\\,\\delta_s\n    $$\n    这证实了在弹性范围内，计算出的面力等于解析弹性表达式。这也适用于屈服开始点，此时 $k_s\\,|\\delta_s| = \\tau_{\\max}$。\n\n2.  **塑性 (屈服) 状态**：如果 $k_s\\,|\\delta_s| > \\tau_{\\max}$，节理发生屈服并经历塑性滑移。剪切面力受节理强度的限制。在这种情况下，`min` 函数求值为 $\\tau_{\\max}$：\n    $$\n    t_s = \\operatorname{sign}(\\delta_s)\\,\\tau_{\\max}\n    $$\n    剪切面力在可能的最大值处饱和，其符号由相对位移 $\\delta_s$ 的方向决定。\n\n该问题要求对每组参数进行特定的布尔测试。当且仅当满足两个条件时，测试必须返回 `True`：\n1.  状态是弹性的，由准则 $|k_s\\,\\delta_s| \\le c + \\mu\\,\\sigma_n$ 定义。注意，使用绝对值是为了正确处理负的剪切位移 $\\delta_s$。\n2.  使用完整本构法则计算的剪切面力 $t_s$ 在数值上等于解析弹性表达式 $k_s\\,\\delta_s$。此比较必须使用 $10^{-12}$ 的相对容差和 $10^{-9}$ 的绝对容差。\n\n每个测试用例的算法如下：\n1.  给定输入参数 $(\\sigma_n, k_s, \\mu, c, \\delta_s)$。\n2.  计算剪切强度：$\\tau_{\\max} = c + \\mu\\,\\sigma_n$。\n3.  计算解析弹性面力：$t_{s, \\text{elastic}} = k_s\\,\\delta_s$。\n4.  检查弹性条件：评估布尔表达式 `is_elastic` = ($|t_{s, \\text{elastic}}| \\le \\tau_{\\max}$)。\n5.  使用完整的本构模型计算剪切面力：$t_{s, \\text{computed}} = \\operatorname{sign}(\\delta_s)\\,\\min(|t_{s, \\text{elastic}}|, \\tau_{\\max})$。\n6.  检查数值相等性：通过将 $t_{s, \\text{computed}}$ 和 $t_{s, \\text{elastic}}$ 与指定的容差进行比较，评估布尔表达式 `are_equal`。\n7.  测试用例的最终结果是这两个布尔值的逻辑与：`result = is_elastic AND are_equal`。\n\n此过程将应用于七个测试用例中的每一个，以生成最终的布尔结果列表。例如，在情况3中：$(\\sigma_n, k_s, \\mu, c, \\delta_s) = (10^6,\\,5\\times10^9,\\,0.6,\\,0,\\,3\\times10^{-4})$，我们有：\n-   $\\tau_{\\max} = 0 + 0.6 \\times 10^6 = 6 \\times 10^5$ Pa.\n-   $t_{s, \\text{elastic}} = (5\\times10^9) \\times (3\\times10^{-4}) = 1.5 \\times 10^6$ Pa.\n-   弹性检查：$|1.5 \\times 10^6| \\le 6 \\times 10^5$ 为 `False`。\n-   此情况的最终结果是 `False`，因为第一个条件未满足。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Goodman joint element patch test problem for a series of cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma_n, k_s, mu, c, delta_s)\n    # sigma_n: Normal stress in Pa\n    # k_s: Shear stiffness in Pa/m\n    # mu: Friction coefficient (dimensionless)\n    # c: Cohesion in Pa\n    # delta_s: Relative shear displacement in m\n    test_cases = [\n        # Case 1 (strictly elastic, positive sliding)\n        (1e6, 5e9, 0.6, 0, 1e-4),\n        # Case 2 (onset of yield, equality holds)\n        (1e6, 5e9, 0.6, 0, 1.2e-4),\n        # Case 3 (post-yield, positive sliding)\n        (1e6, 5e9, 0.6, 0, 3e-4),\n        # Case 4 (strictly elastic, zero normal stress, cohesive joint)\n        (0, 1e9, 0.5, 5e4, 1e-5),\n        # Case 5 (post-yield, zero normal stress, cohesive joint)\n        (0, 1e9, 0.5, 5e4, 1e-3),\n        # Case 6 (degenerate stiffness, zero shear resistance from elasticity)\n        (2e6, 0, 0.5, 0, 1),\n        # Case 7 (strictly elastic, negative sliding)\n        (1e6, 5e9, 0.6, 0, -1e-4),\n    ]\n\n    results = []\n    # Define numerical tolerances for equality check\n    rtol = 1e-12\n    atol = 1e-9\n\n    for case in test_cases:\n        sigma_n, k_s, mu, c, delta_s = case\n\n        # Calculate shear strength (yield limit) based on Coulomb friction\n        tau_max = c + mu * sigma_n\n\n        # Calculate the analytical elastic shear traction\n        ts_elastic = k_s * delta_s\n\n        # Determine if the state is elastic based on the yield criterion.\n        # The problem statement specifies that equality (onset of yield)\n        # is considered an elastic state for this test.\n        is_elastic = np.abs(ts_elastic) <= tau_max\n\n        # Calculate the shear traction using the full elastic-perfectly plastic constitutive rule.\n        # t_s = sign(delta_s) * min(k_s * |delta_s|, tau_max)\n        # This is equivalent to sign(delta_s) * min(|ts_elastic|, tau_max)\n        # We must handle the case delta_s = 0, where np.sign(0) = 0.\n        ts_magnitude = min(np.abs(ts_elastic), tau_max)\n        ts_computed = np.sign(delta_s) * ts_magnitude\n        \n        # Check if the computed traction equals the analytical elastic expression\n        # within the specified tolerance. This is the second part of the patch test condition.\n        are_equal = np.isclose(ts_computed, ts_elastic, rtol=rtol, atol=atol)\n\n        # The final result is True only if the state is elastic AND the computed traction\n        # matches the elastic one. Otherwise, it is False.\n        result = is_elastic and are_equal\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert boolean values to lowercase 'true' or 'false' for direct printing.\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3528461"}, {"introduction": "实现本构律只是第一步；为成功的模拟选择合适的模型参数至关重要。罚刚度 $k_n$ 和 $k_s$ 并非随意的物理常数，而是必须精心选择以平衡精度和稳定性的数值参数。本练习将探讨如何推导并应用这些刚度参数的取值界限，以确保您的模型在通过斑块测试的同时，不会产生寄生模式或矩阵病态等数值问题。[@problem_id:3528504]", "problem": "考虑两个在平面应变状态下的相同、均匀、各向同性、线弹性矩形块，它们完美对齐，并通过Goodman节理单元沿一条笔直的零厚度界面连接。设矩形块的杨氏模量为$E$（单位为$\\mathrm{Pa}$），泊松比为$\\nu$（无量纲）。设界面由线性的牵引力-分离法则建模，其法向刚度为$k_n$，剪切刚度为$k_s$，两者均按单位面积定义，因此跨界面的牵引力分量满足$t_n = k_n \\,\\llbracket u \\rrbracket_n$和$t_s = k_s \\,\\llbracket u \\rrbracket_s$，其中$\\llbracket u \\rrbracket_n$和$\\llbracket u \\rrbracket_s$分别是法向和切向的相对位移跳跃，单位为$\\mathrm{m}$，$t_n$和$t_s$是牵引力，单位为$\\mathrm{Pa}$。因此，刚度参数$k_n$和$k_s$的单位为$\\mathrm{Pa}/\\mathrm{m}$。设界面附近体单元的特征尺寸为$h$（单位为$\\mathrm{m}$）。剪切模量为$G = \\dfrac{E}{2(1+\\nu)}$（单位为$\\mathrm{Pa}$）。\n\n对于粘合界面，规范的斑块测试要求，在连接体中引起均匀应变场的边界条件下，有限元离散化必须能重现精确的线性位移场，且界面上没有位移跳跃。在这种情况下，寄生模式是指即使在均匀远场载荷下也会出现的、局限于界面的伪位移跳跃或振荡。为通过斑块测试并避免此类模式，界面刚度必须相对于体刚度和网格尺寸进行缩放。\n\n从线弹性原理和能量一致性出发，推导$k_n$和$k_s$的约束条件，这些条件需足以通过斑块测试且不产生寄生模式。这些约束必须表示为关于$E$、$G$和$h$的下界和上界：\n- 一个矫顽性下界，用于在均匀应变下抑制位移跳跃，由用户选择的无量纲常数$\\beta_{\\min} > 0$参数化。\n- 一个条件数上界，用于避免病态条件和闭锁，由用户选择的全局刚度矩阵最大允许条件数$\\kappa_{\\max} > 1$参数化。\n\n您必须以包含$k_n$、$k_s$、$E$、$G$、$h$、$\\beta_{\\min}$和$\\kappa_{\\max}$的显式不等式形式呈现这些约束，并设计一个算法，在给定$(E,\\nu,h,\\beta_{\\min},\\kappa_{\\max},k_n,k_s)$的情况下，判断是否在没有寄生模式的情况下通过了斑块测试。该判断必须是一个布尔值。\n\n在您的推导中，所有物理量必须使用一致的国际单位制（SI）表示。具体来说，$E$和$G$的单位必须是$\\mathrm{Pa}$，$h$的单位是$\\mathrm{m}$，$k_n$和$k_s$的单位是$\\mathrm{Pa}/\\mathrm{m}$。本问题不涉及角度。没有百分比；任何分数要求都必须表示为小数。\n\n定义以下精心选择的参数集测试套件，旨在探究约束的不同方面：\n- 测试用例1（理想情况）：$E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$，$\\nu = 0.25$， $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$，$\\beta_{\\min} = 1.0$，$\\kappa_{\\max} = 200.0$， $k_n = 1.0\\times 10^{12}\\ \\mathrm{Pa}/\\mathrm{m}$， $k_s = 5.0\\times 10^{11}\\ \\mathrm{Pa}/\\mathrm{m}$。\n- 测试用例2（法向惩罚不足）：$E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$，$\\nu = 0.25$， $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$，$\\beta_{\\min} = 1.0$，$\\kappa_{\\max} = 200.0$， $k_n = 1.0\\times 10^{10}\\ \\mathrm{Pa}/\\mathrm{m}$， $k_s = 5.0\\times 10^{11}\\ \\mathrm{Pa}/\\mathrm{m}$。\n- 测试用例3（剪切惩罚不足）：$E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$，$\\nu = 0.25$， $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$，$\\beta_{\\min} = 1.0$，$\\kappa_{\\max} = 200.0$， $k_n = 1.0\\times 10^{12}\\ \\mathrm{Pa}/\\mathrm{m}$， $k_s = 1.0\\times 10^{9}\\ \\mathrm{Pa}/\\mathrm{m}$。\n- 测试用例4（过度惩罚导致病态条件）：$E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$，$\\nu = 0.25$， $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$，$\\beta_{\\min} = 1.0$，$\\kappa_{\\max} = 100.0$， $k_n = 3.0\\times 10^{13}\\ \\mathrm{Pa}/\\mathrm{m}$， $k_s = 3.0\\times 10^{13}\\ \\mathrm{Pa}/\\mathrm{m}$。\n- 测试用例5（位于下界的边界情况）：$E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$，$\\nu = 0.25$， $h = 2.5\\times 10^{-1}\\ \\mathrm{m}$，$\\beta_{\\min} = 1.0$，$\\kappa_{\\max} = 500.0$， $k_n = \\dfrac{E}{h}\\ \\mathrm{Pa}/\\mathrm{m}$， $k_s = \\dfrac{E}{2(1+\\nu)h}\\ \\mathrm{Pa}/\\mathrm{m}$。\n\n您的程序必须实现所推导的约束，并为每个测试用例输出一个布尔值，指示$k_n$和$k_s$是否同时满足约束。最终输出格式必须是单行，包含一个用方括号括起来的逗号分隔列表，例如$[result_1,result_2,result_3,result_4,result_5]$，其中每个$result_i$为`True`或`False`。", "solution": "所提出的问题是计算力学领域的一个有效练习，具体涉及有限元方法背景下界面单元罚参数的选择。所提供的参数和背景在科学上是合理的、适定的，并且没有歧义。因此，我们可以着手推导所需的约束条件。\n\n目标是为线性Goodman节理单元的法向刚度$k_n$和剪切刚度$k_s$建立必要和充分条件，以确保成功通过斑块测试，同时不产生诸如寄生模式或矩阵病态条件等数值问题。这些条件将表现为$k_n$和$k_s$的下界和上界。\n\n**1. 为保证矫顽性和准确性的下界**\n\n斑块测试要求，在精确解中会产生均匀应变场的边界条件下，有限元模型必须能够精确重现该场。对于由界面粘合的两个物体的组合体，这意味着位移场必须是线性的，并且在界面上是连续的，从而导致位移跳跃为零，即$\\llbracket u \\rrbracket_n = 0$和$\\llbracket u \\rrbracket_s = 0$。\n\n界面模型$t_n = k_n \\llbracket u \\rrbracket_n$和$t_s = k_s \\llbracket u \\rrbracket_s$是一种罚函数公式。罚参数$k_n$和$k_s$必须足够大，以便在可接受的公差内强制执行零跳跃约束。如果它们太小，界面会变得过于柔顺，导致伪性的、非物理的位移跳跃，这构成了斑块测试的失败。\n\n为了推导一个定量的下界，我们将界面的柔度与相邻体材料的柔度进行比较。考虑与界面相邻的、特征厚度为$h$的一层体材料。该层抵抗变形的有效刚度与其弹性模量成正比，与其厚度成反比。\n对于垂直于界面的变形，相关的体刚度与法向弹性模量成正比，其中杨氏模量$E$是规范的选择，得出量级为$E/h$的有效材料刚度。对于平行于界面的剪切变形，相关的模量是剪切模量$G$，得出量级为$G/h$的有效材料刚度。\n\n为确保界面比相邻的体材料显著更硬，以防止其产生可观的变形，界面刚度必须远大于相邻材料层的有效刚度。我们引入一个无量纲的用户定义参数$\\beta_{\\min} > 0$来量化这一要求。该参数充当安全系数，确保界面对总变形的贡献可以忽略不计。这导致了以下为保证准确性的下界约束：\n\n$$k_n \\ge \\beta_{\\min} \\frac{E}{h}$$\n$$k_s \\ge \\beta_{\\min} \\frac{G}{h}$$\n\n满足这些不等式可确保罚函数足以抑制均匀应变场下的寄生位移跳跃，从而通过斑块测试。\n\n**2. 为保证数值条件数的上界**\n\n虽然为了保证准确性，界面刚度$k_n$和$k_s$必须很大，但过大的值会导致全局有限元刚度矩阵$\\mathbf{K}$的病态条件。矩阵的条件数$\\kappa(\\mathbf{K})$定义为其最大特征值与最小特征值之比，它决定了求解过程的数值稳定性和舍入误差的传播。非常大的条件数可能导致不准确或不稳定的解。\n\n全局刚度矩阵是通过组合体单元和界面单元的贡献而形成的。体单元刚度矩阵项的量级与材料的弹性模量$E$和$G$相当。界面单元的刚度贡献（其量纲为单位面积单位长度的刚度）与$k_n$和$k_s$乘以一个特征长度（在此情况下为单元尺寸$h$）成正比。因此，界面向全局刚度矩阵贡献了量级为$k_n h$和$k_s h$的项。\n\n条件数$\\kappa(\\mathbf{K})$可以近似为系统中存在的最大刚度项与最小刚度项之比。最大的刚度项是由罚函数引入的，即量级为$\\max(k_n h, k_s h)$。最小的（非零）刚度与体材料最柔顺的变形模式相关，这通常是剪切变形，由剪切模量$G$控制。\n\n为维持一个良态系统，审慎的做法是比较同类刚度贡献。界面的法向刚度$k_n$对矩阵中对应法向位移的项有贡献，应与由$E$控制的体材料对此类位移的固有刚度进行比较。类似地，界面剪切刚度$k_s$应与体的剪切刚度$G$进行比较。刚度矩阵项的比率近似为$(k_n h)/E$和$(k_s h)/G$。\n\n为防止病态条件，我们必须将这些比率限制在不大于用户指定的最大允许条件数$\\kappa_{\\max} > 1$。这产生了以下上界约束：\n\n$$\\frac{k_n h}{E} \\le \\kappa_{\\max} \\implies k_n \\le \\kappa_{\\max} \\frac{E}{h}$$\n$$\\frac{k_s h}{G} \\le \\kappa_{\\max} \\implies k_s \\le \\kappa_{\\max} \\frac{G}{h}$$\n\n这些约束防止界面刚度相对于体刚度变得过大，从而导致全局矩阵在数值上难以处理。\n\n**3. 约束总结与算法**\n\n结合下界和上界，我们得到界面刚度参数通过斑块测试且不产生寄生模式或病态条件的完整约束集：\n\n$$ \\beta_{\\min} \\frac{E}{h} \\le k_n \\le \\kappa_{\\max} \\frac{E}{h} $$\n$$ \\beta_{\\min} \\frac{G}{h} \\le k_s \\le \\kappa_{\\max} \\frac{G}{h} $$\n\n其中$G = \\dfrac{E}{2(1+\\nu)}$。用于验证给定参数集$(E, \\nu, h, \\beta_{\\min}, \\kappa_{\\max}, k_n, k_s)$的算法是这两个不等式的直接实现。当且仅当两个条件同时满足时，斑块测试才被认为通过。因此，判定结果是以下逻辑表达式的结果：\n\n$$ \\left( \\beta_{\\min} \\frac{E}{h} \\le k_n \\le \\kappa_{\\max} \\frac{E}{h} \\right) \\land \\left( \\beta_{\\min} \\frac{G}{h} \\le k_s \\le \\kappa_{\\max} \\frac{G}{h} \\right) $$\n\n这为在有限元模拟中选择和验证界面刚度参数提供了一种完整而系统的方法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies constraints for Goodman joint element stiffnesses\n    to determine if they pass the patch test without numerical issues.\n    \"\"\"\n    \n    # Test cases are defined as tuples:\n    # (E, nu, h, beta_min, kappa_max, kn, ks)\n    # For case 5, kn and ks are set to None to indicate they should be\n    # calculated based on the boundary condition definitions.\n    test_cases = [\n        # Test case 1 (happy path)\n        (3.0e10, 0.25, 0.25, 1.0, 200.0, 1.0e12, 5.0e11),\n        # Test case 2 (under-penalized normal)\n        (3.0e10, 0.25, 0.25, 1.0, 200.0, 1.0e10, 5.0e11),\n        # Test case 3 (under-penalized shear)\n        (3.0e10, 0.25, 0.25, 1.0, 200.0, 1.0e12, 1.0e9),\n        # Test case 4 (over-penalized causing ill-conditioning)\n        (3.0e10, 0.25, 0.25, 1.0, 100.0, 3.0e13, 3.0e13),\n        # Test case 5 (boundary case at lower bounds)\n        (3.0e10, 0.25, 0.25, 1.0, 500.0, None, None),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        E, nu, h, beta_min, kappa_max, kn_val, ks_val = case\n        \n        # Calculate shear modulus G\n        G = E / (2.0 * (1.0 + nu))\n        \n        # Calculate kn and ks for the boundary case (Test Case 5)\n        kn = kn_val if kn_val is not None else E / h\n        ks = ks_val if ks_val is not None else G / h\n\n        # Lower bound constraints for coercivity and accuracy\n        kn_min = beta_min * E / h\n        ks_min = beta_min * G / h\n        \n        # Upper bound constraints for numerical conditioning\n        kn_max = kappa_max * E / h\n        ks_max = kappa_max * G / h\n        \n        # Check if both normal and shear stiffnesses are within their bounds\n        is_kn_valid = (kn >= kn_min) and (kn <= kn_max)\n        is_ks_valid = (ks >= ks_min) and (ks <= ks_max)\n        \n        # The overall test passes only if both conditions are met\n        is_valid = is_kn_valid and is_ks_valid\n        \n        results.append(is_valid)\n\n    # Format the output as a single line: a list of boolean values\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\nsolve()\n```", "id": "3528504"}, {"introduction": "为了将摩擦等复杂行为集成到先进的隐式有限元求解器中，我们需要的不仅仅是牵引力-位移关系。为了保证牛顿-拉夫森(Newton-Raphson)等方法能够稳健且快速地收敛，精确计算内力残差的导数——即一致切线刚度矩阵(consistent tangent matrix)——至关重要。这个高级练习要求您为带摩擦的Goodman节理单元推导并实现残差和一致切线刚度，并观察其在粘滞(sticking)和滑移(sliding)接触状态下的不同形式。[@problem_id:3528471]", "problem": "考虑一个二维 Goodman 节理单元，该单元连接了跨越一个潜在不连续面的两个连续介质有限元网格。该节理单元通过法向和剪切方向的线性弹性界面弹簧进行建模，并耦合了率无关的库仑摩擦定律。设节理处的位移跳跃矢量为 $u = [u_n, u_s]^\\top$，其中 $u_n$ 是相对法向位移（张开为正），$u_s$ 是相对剪切位移。牵引力矢量为 $t = [\\sigma_n, \\tau]^\\top$，其中 $\\sigma_n$ 是法向牵引力（压缩为正），$\\tau$ 是剪切牵引力。其力学行为由以下物理上标准的要素表征：\n\n1. 压缩和粘滞状态下的线性界面弹簧：\n   - 法向牵引力在压缩时呈线性关系，刚度为 $k_n$，在张开时消失：$\\sigma_n$ 取决于 $u_n$，且当 $u_n \\ge 0$ 时为零。\n   - 剪切牵引力在粘滞时呈线性关系，刚度为 $k_s$：$\\tau$ 取决于 $u_s$，在粘滞状态下与 $u_n$ 没有直接耦合。\n\n2. 法向的单边接触：\n   - 单元承受压缩而不承受拉伸，这与不可穿透条件一致：仅当 $u_n < 0$ 时接触有效。\n\n3. 剪切的库仑摩擦定律：\n   - 当接触有效时（$u_n < 0$），摩擦边界为 $|\\tau| \\le \\mu\\,\\sigma_n$，其中 $\\mu$ 是摩擦系数，$\\sigma_n$ 是压缩法向牵引力。\n   - 假设为单调剪切加载，但算法必须能正确检测和处理粘滞与滑动。\n\n在牛顿-拉夫森（NR）迭代下，为确保二次收敛，需要使用一致切线，其定义为残差对位移跳跃的精确导数。您的任务是为具有上述行为的 Goodman 节理单元推导、实现并评估残余牵引力矢量 $r(u) = t(u)$ 和一致切线矩阵 $K(u) = \\partial t / \\partial u$。仅使用以下基本定律和原理：\n\n- 关于界面单元牵引力与位移跳跃关系的虚功原理。\n- 在粘滞和压缩状态下，法向和剪切方向的线性弹性弹簧行为。\n- 带有返回映射更新以强制执行摩擦约束的率无关库仑摩擦定律。\n- 法向的单边接触（无拉力）。\n\n单位和约定：\n\n- 使用毫米（mm）作为 $u_n$ 和 $u_s$ 的单位。\n- 使用兆帕（MPa）作为 $\\sigma_n$ 和 $\\tau$ 的单位。\n- 使用 MPa/mm 作为 $k_n$ 和 $k_s$ 的单位。\n- $\\mu$ 为无量纲。\n- 最终的残差分量必须以 MPa 表示，切线矩阵条目必须以 MPa/mm 表示。所有数值输出均需四舍五入至六位小数。\n\n算法要求：\n\n- 基于零外部牵引力构建残差，使得 $r(u) = t(u)$。\n- 当接触有效且试探剪切牵引力的大小超过摩擦边界时，为剪切牵引力实现返回映射更新，以强制执行库仑摩擦定律。\n- 为粘滞、滑动和张开接触三种状态分段计算一致切线矩阵 $K(u)$，确保在每种状态下它都是 $t$ 对 $u$ 的精确导数。\n\n测试套件：\n\n使用以下参数值和位移跳跃：\n\n- 材料和界面参数：\n  - $k_n = 10000$ MPa/mm\n  - $k_s = 5000$ MPa/mm\n  - $\\mu = 0.6$\n\n- 测试用例，每个用例以 (mm) 为单位给出 $(u_n, u_s)$：\n  1. $(-0.001, 0.0005)$: 有效压缩，预期为粘滞状态。\n  2. $(-0.001, 0.002)$: 有效压缩，预期为正向剪切滑动。\n  3. $(+0.0002, 0.005)$: 张开（无接触），两种牵引力应均为零。\n  4. $(-0.001, 0.0012)$: 处于压缩下的摩擦边界上，预期为正向剪切滑动。\n  5. $(-0.002, -0.004)$: 有效压缩，预期为负向剪切滑动。\n\n对每个测试用例，计算：\n\n- 残余牵引力矢量分量 $[\\sigma_n, \\tau]$（单位：MPa）。\n- 一致切线矩阵的条目 $\\left[K_{11}, K_{12}, K_{21}, K_{22}\\right]$（单位：MPa/mm），其中 $K_{ij} = \\partial t_i / \\partial u_j$ 且 $t_1 = \\sigma_n$，$t_2 = \\tau$，$u_1 = u_n$，$u_2 = u_s$。\n- 一个定义为整数的滑动指示器：如果发生滑动则为 $1$，否则为 $0$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例对应一个包含七个值的子列表 $[\\sigma_n, \\tau, K_{11}, K_{12}, K_{21}, K_{22}, \\mathrm{sliding}]$。所有浮点数值必须四舍五入到六位小数，并使用上述指定单位，例如：\n\"[[...],[...],[...],[...],[...]]\"。", "solution": "该问题要求推导并实现一个二维 Goodman 节理单元的本构关系。这涉及到确定牵引力矢量 $t(u)$ 和一致切线矩阵 $K(u)$ 作为相对位移跳跃矢量 $u = [u_n, u_s]^\\top$ 的函数。该单元的行为由线性弹性、单边接触以及率无关的库仑摩擦定律共同决定。给定的符号约定是：$u_n > 0$ 表示张开，$\\sigma_n > 0$ 表示压缩。\n\n推导过程分为三个独立的力学状态：张开接触、粘滞接触和滑动接触。\n\n**1. 张开接触状态 ($u_n \\ge 0$)**\n\n当法向位移跳跃 $u_n$ 为非负时，节理被视为张开。在此状态下，表面不接触，没有牵引力可以通过界面传递。\n\n*   **牵引力矢量 ($t$)**：法向和剪切牵引力均为零。\n    $$\n    t(u) = \\begin{bmatrix} \\sigma_n \\\\ \\tau \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n    $$\n\n*   **一致切线矩阵 ($K$)**：切线矩阵是牵引力矢量对位移跳跃矢量的导数。由于在此状态下牵引力是常数（零），所有导数分量都为零。\n    $$\n    K(u) = \\frac{\\partial t}{\\partial u} = \\begin{bmatrix} \\frac{\\partial \\sigma_n}{\\partial u_n} & \\frac{\\partial \\sigma_n}{\\partial u_s} \\\\ \\frac{\\partial \\tau}{\\partial u_n} & \\frac{\\partial \\tau}{\\partial u_s} \\end{bmatrix} = \\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\end{bmatrix}\n    $$\n\n**2. 接触状态 ($u_n < 0$)**\n\n当 $u_n < 0$ 时，表面处于接触状态，允许法向和剪切牵引力的传递。其响应采用标准的弹性预测、塑性修正（返回映射）方案来确定。\n\n*   **法向响应**：法向牵引力 $\\sigma_n$ 与压缩法向位移成线性比例关系。根据符号约定，该关系为：\n    $$\n    \\sigma_n = -k_n u_n\n    $$\n    这确保了对于压缩位移（$u_n < 0$），会产生一个压缩牵引力（$\\sigma_n > 0$）。该关系与剪切行为无关。\n\n*   **剪切响应（返回映射）**：\n    1.  **弹性预测（试探状态）**：首先，我们假设剪切响应是纯弹性的（粘滞）。试探剪切牵引力 $\\tau^{\\text{trial}}$ 计算如下：\n        $$\n        \\tau^{\\text{trial}} = k_s u_s\n        $$\n    2.  **屈服条件检查**：库仑摩擦准则定义了容许剪切牵引力的极限，从而建立了屈服函数 $\\Phi$。如果试探剪切牵引力的大小超过了与法向压力成正比的摩擦能力，就会发生滑动。摩擦能力为 $\\tau_{\\text{crit}} = \\mu \\sigma_n$。屈服函数为：\n        $$\n        \\Phi(u) = |\\tau^{\\text{trial}}| - \\mu \\sigma_n = |k_s u_s| - \\mu(-k_n u_n) = |k_s u_s| + \\mu k_n u_n\n        $$\n        根据测试用例 4 的问题描述，滑动的条件取为 $\\Phi \\ge 0$，这对应于 $|\\tau^{\\text{trial}}| \\ge \\mu \\sigma_n$。\n\n**2.1. 粘滞接触子状态 ($u_n < 0$ 且 $|\\tau^{\\text{trial}}| < \\mu \\sigma_n$)**\n\n如果试探剪切牵引力在摩擦锥内，则弹性假设成立。\n\n*   **牵引力矢量 ($t$)**：最终的牵引力即为弹性计算所得的值。\n    $$\n    t(u) = \\begin{bmatrix} \\sigma_n \\\\ \\tau \\end{bmatrix} = \\begin{bmatrix} -k_n u_n \\\\ k_s u_s \\end{bmatrix}\n    $$\n\n*   **一致切线矩阵 ($K$)**：通过对牵引力矢量求导获得切线矩阵。\n    $$\n    K^{\\text{stick}} = \\frac{\\partial t}{\\partial u} = \\begin{bmatrix} \\frac{\\partial(-k_n u_n)}{\\partial u_n} & \\frac{\\partial(-k_n u_n)}{\\partial u_s} \\\\ \\frac{\\partial(k_s u_s)}{\\partial u_n} & \\frac{\\partial(k_s u_s)}{\\partial u_s} \\end{bmatrix} = \\begin{bmatrix} -k_n & 0 \\\\ 0 & k_s \\end{bmatrix}\n    $$\n    在此状态下，切线矩阵是对角的且为常数。$K_{11}$ 中的负号是 $\\sigma_n$ 和 $u_n$ 符号约定的直接结果。\n\n**2.2. 滑动接触子状态 ($u_n < 0$ 且 $|\\tau^{\\text{trial}}| \\ge \\mu \\sigma_n$)**\n\n如果试探剪切牵引力违反了摩擦准则，则应用塑性修正（返回映射）。剪切牵引力被缩回到摩擦锥的边界上。\n\n*   **牵引力矢量 ($t$)**：法向牵引力不受影响。剪切牵引力被缩回至摩擦极限，同时保持其方向。\n    $$\n    \\tau = (\\mu \\sigma_n) \\cdot \\text{sign}(\\tau^{\\text{trial}}) = (\\mu (-k_n u_n)) \\cdot \\text{sign}(k_s u_s) = -\\mu k_n u_n \\cdot \\text{sign}(u_s)\n    $$\n    完整的牵引力矢量为：\n    $$\n    t(u) = \\begin{bmatrix} \\sigma_n \\\\ \\tau \\end{bmatrix} = \\begin{bmatrix} -k_n u_n \\\\ -\\mu k_n u_n \\cdot \\text{sign}(u_s) \\end{bmatrix}\n    $$\n\n*   **一致切线矩阵 ($K$)**：切线矩阵是此更新后牵引力矢量的导数。对于 $u_s \\neq 0$，$\\text{sign}(u_s)$ 项的导数为零。滑动条件意味着 $\\tau^{\\text{trial}} \\neq 0$，因此 $u_s \\neq 0$。\n    $$\n    K^{\\text{slide}} = \\frac{\\partial t}{\\partial u} = \\begin{bmatrix} \\frac{\\partial(-k_n u_n)}{\\partial u_n} & \\frac{\\partial(-k_n u_n)}{\\partial u_s} \\\\ \\frac{\\partial(-\\mu k_n u_n \\cdot \\text{sign}(u_s))}{\\partial u_n} & \\frac{\\partial(-\\mu k_n u_n \\cdot \\text{sign}(u_s))}{\\partial u_s} \\end{bmatrix}\n    $$\n    $$\n    K^{\\text{slide}} = \\begin{bmatrix} -k_n & 0 \\\\ -\\mu k_n \\cdot \\text{sign}(u_s) & 0 \\end{bmatrix}\n    $$\n    该矩阵是非对称的（$K_{21} \\neq K_{12}$），这是像库仑摩擦这类非关联塑性模型一致切线的一个关键特征。非对角项 $K_{21}$ 代表了一种耦合效应，即法向位移 $u_n$ 的变化通过改变法向应力进而改变摩擦极限，从而直接改变剪切牵引力 $\\tau$。\n\n**算法摘要**\n对于给定的位移跳跃 $u = [u_n, u_s]^\\top$ 和参数 $k_n, k_s, \\mu$：\n1.  如果 $u_n \\ge 0$：设置 $\\sigma_n=0$，$\\tau=0$，$K=[[0,0],[0,0]]$，且 sliding=0。\n2.  如果 $u_n < 0$：\n    a. 计算 $\\sigma_n = -k_n u_n$。\n    b. 计算 $\\tau^{\\text{trial}} = k_s u_s$。\n    c. 计算 $\\tau_{\\text{crit}} = \\mu \\sigma_n$。\n    d. 如果 $|\\tau^{\\text{trial}}| \\ge \\tau_{\\text{crit}}$ (滑动)：\n        i. $\\tau = \\tau_{\\text{crit}} \\cdot \\text{sign}(u_s)$。\n        ii. $K_{11} = -k_n$，$K_{12}=0$，$K_{21} = -\\mu k_n \\cdot \\text{sign}(u_s)$，$K_{22}=0$。\n        iii. sliding=1。\n    e. 否则 (粘滞)：\n        i. $\\tau = \\tau^{\\text{trial}}$。\n        ii. $K_{11} = -k_n$，$K_{12}=0$，$K_{21}=0$，$K_{22}=k_s$。\n        iii. sliding=0。\n此算法为具体实现提供了基础。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the residual traction and consistent tangent matrix for a Goodman joint element\n    under various displacement jumps, based on a Coulomb friction model.\n    \"\"\"\n    # Material and interface parameters\n    k_n = 10000.0  # Normal stiffness in MPa/mm\n    k_s = 5000.0   # Shear stiffness in MPa/mm\n    mu = 0.6       # Friction coefficient (dimensionless)\n\n    # Test cases defined as (u_n, u_s) tuples in mm\n    test_cases = [\n        (-0.001, 0.0005),  # Active compression, sticking\n        (-0.001, 0.002),   # Active compression, sliding (+)\n        (0.0002, 0.005),   # Opening, no contact\n        (-0.001, 0.0012),  # Active compression, on friction boundary (sliding)\n        (-0.002, -0.004),  # Active compression, sliding (-)\n    ]\n\n    results = []\n\n    for u_n, u_s in test_cases:\n        # Initialize outputs for the open-contact case\n        sigma_n, tau = 0.0, 0.0\n        K11, K12, K21, K22 = 0.0, 0.0, 0.0, 0.0\n        sliding_indicator = 0\n\n        # Regime 1: Open Contact (u_n >= 0)\n        # In this case, tractions and stiffnesses are zero, so initial values are correct.\n\n        # Regime 2: Active Contact (u_n < 0)\n        if u_n < 0:\n            # Normal traction (positive in compression)\n            sigma_n = -k_n * u_n\n\n            # Elastic predictor step: compute trial shear traction\n            tau_trial = k_s * u_s\n\n            # Friction capacity (critical shear traction)\n            tau_crit = mu * sigma_n\n\n            # Check yield condition to determine sticking or sliding\n            # Based on the problem statement's expectation for case 4,\n            # the boundary |tau_trial| == tau_crit is treated as sliding.\n            if np.abs(tau_trial) >= tau_crit:\n                # Sliding state\n                sliding_indicator = 1\n                \n                # Return-mapping: project shear traction onto the yield surface\n                # Ensure sign of tau matches sign of shear displacement u_s\n                tau = tau_crit * np.sign(u_s)\n                \n                # Consistent tangent matrix for the sliding regime\n                K11 = -k_n\n                K12 = 0.0\n                K21 = -mu * k_n * np.sign(u_s)\n                K22 = 0.0\n            else:\n                # Sticking state\n                sliding_indicator = 0\n                \n                # Shear traction is the elastic trial value\n                tau = tau_trial\n                \n                # Consistent tangent matrix for the sticking regime\n                K11 = -k_n\n                K12 = 0.0\n                K21 = 0.0\n                K22 = k_s\n        \n        # Format the results for the current test case, rounding to 6 decimal places.\n        case_result = [\n            round(sigma_n, 6),\n            round(tau, 6),\n            round(K11, 6),\n            round(K12, 6),\n            round(K21, 6),\n            round(K22, 6),\n            sliding_indicator\n        ]\n        \n        # Convert list to string format '[v1,v2,...]' without spaces\n        results.append(str(case_result).replace(\" \", \"\"))\n\n    # Print the final output as a single-line string\n    # in the format \"[[...],[...],...]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3528471"}]}