{"hands_on_practices": [{"introduction": "本节的第一个实践将引导你进入接触力学的基础应用。我们将分析一个简单的一维弹性杆与刚性挡块接触的经典问题 [@problem_id:3558634]。这个练习为你提供了一个动手实践的机会，让你能够实现并比较两种用于施加接触约束的核心技术：直观的罚函数法和数学上更为精巧的Nitsche方法。通过将你的数值结果与已知的解析解进行比较，你将掌握执行收敛性分析的关键技能，以验证你的代码实现并理解这些方法的精度。", "problem": "考虑在区间 $[0,L]$ 上的一根一维、静态、线弹性杆，其杨氏模量为 $E$，横截面积为 $A$，单位长度上承受均匀体力 $f_0$。未知位移场为沿杆轴向的 $u(x)$，单位为米。左端 $x=0$ 处为固定端，因此 $u(0)=0$。右端 $x=L$ 处与一个刚性挡块发生单边无摩擦接触，该挡块位于间隙 $g$ 处，单位为米。控制平衡方程为一维线性动量平衡 $-(E A u')' = f_0$ 在 $(0,L)$ 上成立，同时在 $x=L$ 处满足 Signorini-Fichera 接触条件，\n$$\nu(L) - g \\le 0,\\quad t(L) \\le 0,\\quad t(L)\\,\\big(u(L) - g\\big) = 0,\n$$\n其中 $t(L)$ 表示在 $x=L$ 处的法向牵引力（压缩取为非正值）。\n\n您的任务是：\n- 推导出一个与 $-(E A u')' = f_0$、$u(0)=0$ 以及 Signorini-Fichera 边界条件一致的解析分段解 $u(x)$。\n- 在有限元法 (FEM) 框架内，使用均匀网格上的连续分段线性基函数，构建并实现两种计算近似方法：\n  1. 一种罚函数法，通过在弱形式中增加一个依赖于罚参数 $\\alpha0$ 的边界罚项来施加单边接触约束。\n  2. 一种用于单边接触的对称 Nitsche 型稳定化方法，它使用一个由局部网格尺寸在 $x=L$ 处缩放的稳定化参数 $\\gamma0$，在激活集上弱施加边界约束。\n- 对于每种方法，计算近似位移场 $u_h(x)$ 以及在 $[0,L]$ 上以 $L^2$ 范数测量的位移误差，即 $\\lVert u - u_h \\rVert_{L^2(0,L)}$，单位为米，使用对次数最高为二的多项式精确的高斯求积。\n- 假设存在幂律关系 $\\lVert u - u_h \\rVert_{L^2} \\approx C h^p$（其中 $C0$ 为某个常数），将观测到的收敛率 $p$ 估计为 $\\log(\\lVert u - u_h \\rVert_{L^2})$ 对 $\\log(h)$ 进行线性回归得到的斜率，其中 $h=L/N$ 是均匀网格尺寸，$N$ 为单元数量。\n\n实现一个完整的程序，该程序：\n- 使用分段线性元和体力 $f_0$ 组装一维杆的标准刚度矩阵。\n- 强施加 $x=0$ 处的本质边界条件。\n- 通过首先计算无约束解并评估 $x=L$ 处的间隙条件来判断接触是激活还是非激活；如果激活，则仅在激活集上应用所选方法的边界项；如果非激活，则保持右边界为自然边界。\n- 在每个网格上通过单元高斯求积计算 $L^2$ 误差。\n- 对每个测试用例，在多个网格尺寸下评估误差，并返回罚函数法和 Nitsche 方法的基于回归的收敛率 $p$。\n\n使用以下构成测试套件的科学上合理的参数值：\n- 所有测试的材料和几何参数：$L=1.0\\,\\mathrm{m}$，$E=30\\times 10^9\\,\\mathrm{Pa}$，$A=0.01\\,\\mathrm{m}^2$，均匀体力 $f_0=1.0\\times 10^5\\,\\mathrm{N/m}$。\n- 每个测试的网格尺寸：$N\\in\\{10,20,40\\}$（因此 $h=L/N$）。\n- 测试用例 1（非激活接触，理想情况）：$g=2.0\\times 10^{-4}\\,\\mathrm{m}$，罚参数 $\\alpha=1.0\\times 10^9$，Nitsche 稳定化参数 $\\gamma=10.0$。\n- 测试用例 2（激活接触，中等间隙）：$g=1.0\\times 10^{-4}\\,\\mathrm{m}$，罚参数 $\\alpha=1.0\\times 10^7$，Nitsche 稳定化参数 $\\gamma=10.0$。\n- 测试用例 3（激活接触，边界处有刚性挡块）：$g=0.0\\,\\mathrm{m}$，罚参数 $\\alpha=1.0\\times 10^6$，Nitsche 稳定化参数 $\\gamma=10.0$。\n\n您的程序应生成单行输出，其中包含六个收敛率，格式为逗号分隔的列表并用方括号括起，顺序为 $[p_{\\text{pen},1},p_{\\text{nit},1},p_{\\text{pen},2},p_{\\text{nit},2},p_{\\text{pen},3},p_{\\text{nit},3}]$，其中 $p_{\\text{pen},k}$ 和 $p_{\\text{nit},k}$ 分别对应于测试用例 $k$ 的罚函数法和 Nitsche 方法。收敛率 $p$ 是无量纲的浮点数。\n\n不允许用户输入；程序必须按原样运行，并为指定的测试套件精确计算这些量。", "solution": "用户希望求解一维弹性杆的单边接触问题，并分析两种不同有限元法 (FEM) 公式（罚函数法和对称 Nitsche 方法）的收敛性。\n\n### 步骤 1：解析解\n\n位移 $u(x)$ 的控制常微分方程 (ODE) 是 $-(E A u'(x))' = f_0$，其中 $E$、$A$ 和 $f_0$ 是常数。对 $x$ 积分两次，得到通解：\n$$\nu(x) = -\\frac{f_0}{2EA} x^2 + C_1 x + C_2\n$$\n积分常数 $C_1$ 和 $C_2$ 由边界条件确定。左端是固定的，$u(0)=0$，这意味着 $C_2=0$。\n$$\nu(x) = -\\frac{f_0}{2EA} x^2 + C_1 x\n$$\n右端 $x=L$ 处受 Signorini-Fichera 条件约束：\n1.  $u(L) - g \\le 0$ (不可穿透)\n2.  $t(L) \\le 0$ (压缩或零牵引力)，其中 $t(L) = E A u'(L)/A = Eu'(L)$\n3.  $t(L)(u(L) - g) = 0$ (互补性)\n\n接触有两种可能的状态。\n\n**情况 1：非激活接触（间隙保持打开）**\n当杆在 $x=L$ 处为自由边界条件下不接触挡块时，发生此状态。自由边界意味着零牵引力，$t(L)=0$。\n$t(L) = E u'(L) = E \\left(-\\frac{f_0 L}{EA} + C_1\\right) = -\\frac{f_0 L}{A} + E C_1 = 0 \\implies C_1 = \\frac{f_0 L}{EA}$。\n位移场为 $u_{\\text{free}}(x) = \\frac{f_0}{EA} (Lx - \\frac{x^2}{2})$。\n端部位移为 $u_{\\text{free}}(L) = \\frac{f_0 L^2}{2EA}$。\n此解若满足 Signorini 条件则有效。$t(L)=0 \\le 0$ 已满足。互补性条件已满足。不可穿透条件 $u(L) \\le g$ 要求 $\\frac{f_0 L^2}{2EA} \\le g$。\n\n**情况 2：激活接触（间隙闭合）**\n如果自由端位移将超过间隙，即 $\\frac{f_0 L^2}{2EA}  g$，则发生此状态。在这种情况下，不可穿透条件变为约束条件：$u(L)=g$。\n用此条件求 $C_1$：\n$u(L) = g = -\\frac{f_0 L^2}{2EA} + C_1 L \\implies C_1 = \\frac{g}{L} + \\frac{f_0 L}{2EA}$。\n位移场为 $u(x) = \\left(\\frac{g}{L} + \\frac{f_0 L}{2EA}\\right)x - \\frac{f_0 x^2}{2EA}$。\n此解若满足 $t(L) \\le 0$ 则有效。\n$t(L) = E u'(L) = E \\left( \\frac{g}{L} + \\frac{f_0 L}{2EA} - \\frac{f_0 L}{EA} \\right) = \\frac{Eg}{L} - \\frac{f_0 L}{2A}$。\n条件 $t(L) \\le 0$ 等价于 $\\frac{Eg}{L} \\le \\frac{f_0 L}{2A}$，简化为 $g \\le \\frac{f_0 L^2}{2EA}$，这证实了接触激活的条件。由于 $u(L)-g=0$，互补性条件得到满足。\n\n令 $u_{\\text{max}} = \\frac{f_0 L^2}{2EA}$。完整的解析解为：\n$$\nu(x) =\n\\begin{cases}\n    \\frac{f_0}{2EA}(2Lx - x^2)   \\text{若 } g \\ge u_{\\text{max}} \\quad (\\text{非激活}) \\\\\n    \\frac{g}{L}x + \\frac{f_0}{2EA}(Lx - x^2)   \\text{若 } g  u_{\\text{max}} \\quad (\\text{激活})\n\\end{cases}\n$$\n\n### 步骤 2：有限元弱形式\n\n起点是平衡方程的弱形式。对于满足 $v(0)=0$ 的测试函数 $v$：\n$$\n\\int_0^L EA u' v' dx = \\int_0^L f_0 v dx + T(L) v(L)\n$$\n其中 $T(L) = A t(L)$ 是接触处的反作用力。在尺寸为 $h=L/N$ 的均匀网格上使用分段线性元进行离散化，我们得到一个代数方程组 $K\\mathbf{u} = \\mathbf{F}$。我们采用激活集策略：首先，在 $T(L)=0$（自然边界条件）下求解，得到 $u_h^{\\text{free}}$。如果 $u_h^{\\text{free}}(L)  g$，我们重新求解带接触约束的系统。\n\n**罚函数法（激活接触）**\n单边约束通过向总势能中添加一个罚能量项 $\\frac{1}{2}\\alpha(u(L)-g)^2$ 来近似，其中 $\\alpha \\gg 0$ 是一个罚参数。该项的变分向弱形式中添加了 $\\alpha (u(L)-g) v(L)$。这仅修改了有限元系统的最后一个方程（对应于 $x=L$ 处的节点 $N$）。刚度矩阵项 $K_{NN}$ 和力向量项 $F_N$ 被修改为：\n$$\nK_{NN} \\to K_{NN} + \\alpha, \\quad F_N \\to F_N + \\alpha g\n$$\n\n**对称 Nitsche 方法（激活接触）**\n该方法弱施加狄利克雷型条件 $u(L)=g$，而无需大的罚参数。它通过添加项来修改弱形式，以一致且稳定的方式施加约束。对称公式为：\n寻找 $u_h \\in V_h$ 使得对于所有 $v_h \\in V_h$：\n$$\na_h(u_h, v_h) = \\ell_h(v_h)\n$$\n其中\n$$\na_h(u, v) = \\int_0^L EA u'v' dx - (EA u'(L))v(L) - (EA v'(L))u(L) + \\frac{\\gamma EA}{h} u(L)v(L)\n$$\n$$\n\\ell_h(v) = \\int_0^L f_0 v dx - (EA v'(L))g + \\frac{\\gamma EA}{h} gv(L)\n$$\n这里，$\\gamma0$ 是一个无量纲稳定化参数。对于分段线性元，$u_h'(L)$ 和 $v_h'(L)$ 是最后一个单元 $[x_{N-1}, L]$ 上的常数导数。这些修改影响了有限元系统矩阵的最后两行和两列。在 $N \\times N$ 系统中（对于自由度 $u_1, ..., u_N$）产生的修改项为：\n$$\nK_{N-1, N} \\to 0, \\quad K_{N, N-1} \\to 0\n$$\n$$\nK_{N, N} \\to (\\gamma-1)\\frac{EA}{h}\n$$\n$$\nF_{N-1} \\to F_{N-1} + \\frac{EAg}{h}, \\quad F_{N} \\to F_{N} + (\\gamma-1)\\frac{EAg}{h}\n$$\n\n### 步骤 3：数值实现与收敛性分析\n\n程序为给定的测试用例实现了这些步骤。\n1.  **组装**：组装固定-自由杆的标准 $N \\times N$ 刚度矩阵和力向量。\n2.  **激活集**：计算无约束解以确定接触是否激活。\n3.  **求解**：如果接触非激活，则使用无约束解。如果激活，则将罚函数法或 Nitsche 方法的相应修改应用于矩阵和向量，然后再次求解系统。\n4.  **误差计算**：通过对使用两点高斯求积计算的单元贡献求和，来计算 $L^2$ 误差 $\\lVert u - u_h \\rVert_{L^2}$。\n5.  **收敛率**：为 $N=10, 20, 40$ 的网格计算误差。在误差对网格尺寸 $h$ 的对数-对数图上执行线性回归。该线的斜率给出观测到的收敛率 $p$。对所有三个测试用例的两种方法重复此过程。\n\n对于线性元，两种方法在 $L^2$ 范数下测量的预期收敛率均为 $p=2$，因为精确解是分段光滑的。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve():\n    \"\"\"\n    Solves a 1D unilateral contact problem for an elastic bar using FEM,\n    comparing penalty and Nitsche methods for convergence analysis.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    L = 1.0       # m\n    E = 30.0e9    # Pa\n    A = 0.01      # m^2\n    f0 = 1.0e5    # N/m\n    EA = E * A\n\n    # --- Test Cases ---\n    test_cases = [\n        {'g': 2.0e-4, 'alpha': 1.0e9, 'gamma': 10.0, 'id': '1 (inactive)'},\n        {'g': 1.0e-4, 'alpha': 1.0e7, 'gamma': 10.0, 'id': '2 (active)'},\n        {'g': 0.0,    'alpha': 1.0e6, 'gamma': 10.0, 'id': '3 (active)'},\n    ]\n    \n    mesh_Ns = [10, 20, 40]\n    all_rates = []\n\n    # --- Gaussian Quadrature (2-point) ---\n    gauss_points = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n    gauss_weights = np.array([1.0, 1.0])\n\n    # --- Analytical Solution ---\n    u_max_free = f0 * L**2 / (2 * EA)\n\n    def get_analytic_solution(g_val):\n        if g_val >= u_max_free: # Inactive contact\n            def u_exact(x):\n                return (f0 / (2 * EA)) * (2 * L * x - x**2)\n        else: # Active contact\n            def u_exact(x):\n                return (g_val / L) * x + (f0 / (2 * EA)) * (L * x - x**2)\n        return u_exact\n\n    for case in test_cases:\n        g = case['g']\n        alpha = case['alpha']\n        gamma = case['gamma']\n        \n        u_exact_func = get_analytic_solution(g)\n\n        for method in ['penalty', 'nitsche']:\n            h_values = []\n            l2_errors = []\n\n            for N in mesh_Ns:\n                h = L / N\n                nodes = np.linspace(0, L, N + 1)\n                \n                # Assemble system for unknown DOFs u_1, ..., u_N (size N x N)\n                K_unconstrained = np.zeros((N, N))\n                F_unconstrained = np.zeros(N)\n\n                # Stiffness matrix with natural BC at x=L\n                diag0 = np.full(N, 2 * EA / h)\n                diag1 = np.full(N - 1, -EA / h)\n                K_unconstrained += np.diag(diag0) + np.diag(diag1, k=1) + np.diag(diag1, k=-1)\n                K_unconstrained[N - 1, N - 1] = EA / h\n                \n                # Force vector\n                F_unconstrained[:] = f0 * h\n                F_unconstrained[N-1] = f0 * h / 2.0\n\n                # --- Active Set Strategy ---\n                u_free = solve_linear_system(K_unconstrained, F_unconstrained)\n                u_N_free = u_free[-1]\n                is_active = (u_N_free > g)\n\n                K, F = K_unconstrained.copy(), F_unconstrained.copy()\n                if is_active:\n                    if method == 'penalty':\n                        K[N-1, N-1] += alpha\n                        F[N-1] += alpha * g\n                    elif method == 'nitsche':\n                        # The modifications implement the derived symmetric Nitsche form\n                        F[N-2] += EA * g / h\n                        F[N-1] += (gamma - 1) * EA * g / h\n                        \n                        K[N-2, N-1] = 0.0\n                        K[N-1, N-2] = 0.0\n                        K[N-1, N-1] = (gamma-1) * EA / h\n\n                u_h_dofs = solve_linear_system(K, F)\n                # Full solution vector including the fixed DoF u_0 = 0\n                u_h_full = np.concatenate(([0.0], u_h_dofs))\n\n                # --- Error Calculation (L2 norm) ---\n                total_error_sq = 0.0\n                for i in range(N):\n                    elem_nodes = nodes[i:i+2]\n                    elem_dofs = u_h_full[i:i+2]\n                    \n                    x_gauss = elem_nodes[0] + (h / 2.0) * (1.0 + gauss_points)\n                    u_exact_vals = u_exact_func(x_gauss)\n                    \n                    shape_func_vals_at_gauss = 0.5 * np.array([1.0 - gauss_points, 1.0 + gauss_points])\n                    u_h_vals = elem_dofs @ shape_func_vals_at_gauss\n                    \n                    integrand = (u_exact_vals - u_h_vals)**2\n                    elem_error_sq = (h / 2.0) * np.sum(gauss_weights * integrand)\n                    total_error_sq += elem_error_sq\n                \n                l2_error = np.sqrt(total_error_sq)\n                h_values.append(h)\n                l2_errors.append(l2_error)\n            \n            # --- Convergence Rate Calculation ---\n            log_h = np.log(h_values)\n            log_err = np.log(l2_errors)\n            p, _ = np.polyfit(log_h, log_err, 1)\n            all_rates.append(p)\n\n    print(f\"[{','.join(f'{rate:.10f}' for rate in all_rates)}]\")\n\nsolve()\n```", "id": "3558634"}, {"introduction": "在探索了基础的接触算法之后，我们现在转向现代接触模拟器中使用的更强大技术。本实践通过使用Fischer-Burmeister互补函数，将具有内在非光滑性的Signorini-Fichera条件重新表述为一个方程组，从而正面解决其数学难题 [@problem_id:3558641]。你将为半光滑牛顿法推导其残差和广义雅可比矩阵，深入理解这些强大求解器背后的数学机制，以及它们如何稳健地处理接触现象中典型的“开-关”切换行为。", "problem": "考虑一个在计算岩土力学框架下建模的弹性节点与刚性障碍物之间的单自由度、无摩擦、单边接触问题。令 $u \\in \\mathbb{R}$ 表示沿朝向障碍物的内法线方向测量的节点位移，令 $k \\in \\mathbb{R}_{0}$ 表示支座的线性弹性刚度。令 $f \\in \\mathbb{R}$ 表示沿正方向施加的外荷载，令 $\\lambda \\in \\mathbb{R}_{\\ge 0}$ 表示作用在节点上的法向接触压力（拉格朗日乘子）。令法向间隙函数为 $g(u) = c - u$，其中 $c \\in \\mathbb{R}$ 是初始间隙（当障碍物最初未接触节点时为正值）。Signorini-Fichera 接触条件将单边不可入性和接触压力非负性表示为 $g(u) \\ge 0$，$\\lambda \\ge 0$ 和 $g(u)\\,\\lambda = 0$。\n\n从以下基本出发点开始：\n- 准静态单自由度弹性系统的线性动量平衡：$k\\,u + \\lambda = f$。\n- Signorini-Fichera 互补条件：$g(u) \\ge 0$, $\\lambda \\ge 0$, and $g(u)\\,\\lambda = 0$。\n- 由 $\\phi(a,b) = \\sqrt{a^2 + b^2} - a - b$ 定义的 Fischer–Burmeister (FB) 函数 $\\phi:\\mathbb{R}\\times\\mathbb{R}\\to\\mathbb{R}$。\n\n您的任务是：\n1. 推导法向互补条件的半光滑重构，通过将 $0 \\le g(u) \\perp \\lambda \\ge 0$ 替换为单个方程 $\\phi(g(u),\\lambda) = 0$。将其与平衡方程结合，定义一个适用于牛顿类方法的残差映射 $R:\\mathbb{R}^2 \\to \\mathbb{R}^2$。不要先验地假设 FB 函数在原点的任何可微性；相反，应使用半光滑分析概念来论证您的残差及其广义导数。\n2. 通过计算 FB 函数在点 $(a,b) \\ne (0,0)$ 处的偏导数，并在 $(a,b) = (0,0)$ 处选择 Clarke 次微分的一个一致元素，推导一个适用于半光滑牛顿步的广义雅可比矩阵。\n3. 实现一个阻尼半光滑牛顿类求解器，在给定 $(k,c,f)$ 和初始猜测值 $(u_0,\\lambda_0)$ 的情况下，计算系统 $R(u,\\lambda) = 0$ 的近似解 $(u^\\star,\\lambda^\\star)$，当残差的欧几里得范数小于 $10^{-10}$ 或达到最大迭代次数 $50$ 次后终止。使用一个简单的基于残差范数的回溯线搜索来促进全局收敛。\n4. 对于下面的每个测试用例，使用 $(u_0,\\lambda_0) = (0,0)$ 运行求解器，并报告每个用例的三个无量纲数：$u^\\star$, $\\lambda^\\star$ 以及最终残差的欧几里得范数 $\\lVert R(u^\\star,\\lambda^\\star) \\rVert_2$。此问题中的所有量都是无量纲的；将所有输出报告为无量纲数。\n\n使用以下测试套件，其选择旨在覆盖一个典型情况、一个主动接触情况、退化非光滑点和一个边界情况：\n- 测试用例 1 (预计无接触): $k = 1000$, $c = 0.15$, $f = 100$。\n- 测试用例 2 (预计有主动接触): $k = 1000$, $c = 0.05$, $f = 400$。\n- 测试用例 3 (在原点退化): $k = 1000$, $c = 0$, $f = 0$。\n- 测试用例 4 (边界情况 $f = k\\,c$): $k = 800$, $c = 0.2$, $f = 160$。\n\n您的程序必须：\n- 基于上述基本原理和指定的半光滑重构，从第一性原理实现残差 $R(u,\\lambda)$。\n- 在 $(a,b) = (0,0)$ 处使用有原则的选择来实现一个一致的广义雅可比矩阵。\n- 应用带有回溯线搜索的阻尼半光滑牛顿法，该方法将步长以 $1/2$ 的因子缩减，直到观察到残差范数的充分下降或达到 $2^{-20}$ 的最小步长。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的浮点数列表，顺序为 $[u_1^\\star,\\lambda_1^\\star,\\lVert R_1\\rVert_2, u_2^\\star,\\lambda_2^\\star,\\lVert R_2\\rVert_2, u_3^\\star,\\lambda_3^\\star,\\lVert R_3\\rVert_2, u_4^\\star,\\lambda_4^\\star,\\lVert R_4\\rVert_2]$，其中下标表示测试用例的索引。\n- 每个浮点数打印小数点后恰好 $10$ 位。", "solution": "该问题要求为一个单自由度单边接触问题建立并实现一个半光滑牛顿法。该过程涉及基于 Fischer-Burmeister 重构接触条件来推导残差函数，计算相应的广义雅可比矩阵，并实现一个阻尼牛顿类求解器。\n\n### 步骤 1：半光滑重构与残差映射\n\n该力学系统由一组方程和不等式控制。节点的平衡由线性动量平衡描述：\n$$k\\,u + \\lambda = f$$\n其中 $k \\in \\mathbb{R}_{0}$ 是刚度，$u \\in \\mathbb{R}$ 是位移，$\\lambda \\in \\mathbb{R}_{\\ge 0}$ 是接触压力（一个拉格朗日乘子），$f \\in \\mathbb{R}$ 是外荷载。\n\n接触本身由 Signorini-Fichera 条件描述，这些条件强制了不可入性 ($g(u) \\ge 0$)、非拉伸接触压力 ($\\lambda \\ge 0$) 以及压力仅在间隙闭合时存在的性质 ($g(u)\\,\\lambda=0$)。将间隙函数定义为 $g(u) = c - u$（其中 $c$ 是初始间隙），这些条件可以简洁地表示为一个互补问题：\n$$0 \\le (c - u) \\perp \\lambda \\ge 0$$\n\n为数值求解该系统，我们使用 Fischer-Burmeister (FB) 函数 $\\phi: \\mathbb{R}\\times\\mathbb{R} \\to \\mathbb{R}$ 将非光滑的互补条件替换为一个等价的、不可微的单一方程，该函数定义为：\n$$\\phi(a,b) = \\sqrt{a^2 + b^2} - a - b$$\n性质 $\\phi(a,b) = 0$ 等价于互补条件 $0 \\le a \\perp b \\ge 0$。通过设置 $a = g(u) = c-u$ 和 $b = \\lambda$，我们将接触定律重构成一个单一方程：\n$$\\phi(c-u, \\lambda) = \\sqrt{(c-u)^2 + \\lambda^2} - (c-u) - \\lambda = 0$$\n\n将其与平衡方程结合，我们得到一个关于两个未知数 $(u, \\lambda)$ 的两个非线性方程组。我们定义一个残差映射 $R: \\mathbb{R}^2 \\to \\mathbb{R}^2$，使得解 $(u^\\star, \\lambda^\\star)$ 满足 $R(u^\\star, \\lambda^\\star) = 0$：\n$$R(u, \\lambda) = \\begin{pmatrix} R_1(u, \\lambda) \\\\ R_2(u, \\lambda) \\end{pmatrix} = \\begin{pmatrix} k\\,u + \\lambda - f \\\\ \\sqrt{(c-u)^2 + \\lambda^2} - c + u - \\lambda \\end{pmatrix}$$\n函数 $R(u, \\lambda)$ 处处连续，但在 $(c-u, \\lambda) = (0,0)$ 的点由于平方根项而不可微。然而，该函数是半光滑的，这允许使用一种广义牛顿法，该方法可以局部超线性收敛。\n\n### 步骤 2：广义雅可比矩阵的推导\n\n求解 $R(x)=0$ 的半光滑牛顿法遵循迭代 $x_{k+1} = x_k - V_k^{-1} R(x_k)$，其中 $x=(u, \\lambda)$，$V_k$ 是 $R$ 在 $x_k$ 处的广义雅可比矩阵的一个元素（例如，Clarke 次微分 $\\partial_C R(x_k)$）。\n\n雅可比矩阵 $J_R$ 由 $R$ 各分量的偏导数组成：\n$$J_R(u, \\lambda) = \\begin{pmatrix} \\frac{\\partial R_1}{\\partial u}  \\frac{\\partial R_1}{\\partial \\lambda} \\\\ \\frac{\\partial R_2}{\\partial u}  \\frac{\\partial R_2}{\\partial \\lambda} \\end{pmatrix}$$\n\n第一个分量 $R_1(u, \\lambda) = k\\,u + \\lambda - f$ 的导数很简单：\n$$\\frac{\\partial R_1}{\\partial u} = k, \\quad \\frac{\\partial R_1}{\\partial \\lambda} = 1$$\n\n对于第二个分量 $R_2(u, \\lambda) = \\phi(c-u, \\lambda)$，我们使用链式法则。对于任意点 $(c-u, \\lambda) \\ne (0,0)$，$\\phi(a,b)$ 的偏导数为：\n$$\\frac{\\partial \\phi}{\\partial a} = \\frac{a}{\\sqrt{a^2+b^2}} - 1, \\quad \\frac{\\partial \\phi}{\\partial b} = \\frac{b}{\\sqrt{a^2+b^2}} - 1$$\n应用链式法则，其中 $a=c-u$ 且 $b=\\lambda$：\n$$\\frac{\\partial R_2}{\\partial u} = \\frac{\\partial \\phi}{\\partial a}\\frac{\\partial a}{\\partial u} = -\\frac{\\partial \\phi}{\\partial a} = 1 - \\frac{c-u}{\\sqrt{(c-u)^2+\\lambda^2}}$$\n$$\\frac{\\partial R_2}{\\partial \\lambda} = \\frac{\\partial \\phi}{\\partial b}\\frac{\\partial b}{\\partial \\lambda} = \\frac{\\partial \\phi}{\\partial b} = \\frac{\\lambda}{\\sqrt{(c-u)^2+\\lambda^2}} - 1$$\n令 $N = \\sqrt{(c-u)^2+\\lambda^2}$，则非奇异情况（$N  0$）的雅可比矩阵为：\n$$J_R(u, \\lambda) = \\begin{pmatrix} k  1 \\\\ 1 - \\frac{c-u}{N}  \\frac{\\lambda}{N} - 1 \\end{pmatrix} \\quad (\\text{对于 } (c-u, \\lambda) \\ne (0,0))$$\n\n在奇异点 $(c-u, \\lambda) = (0,0)$，函数不可微。我们必须从广义雅可比矩阵中选择一个元素。对于可行域 ($a \\ge 0, b \\ge 0$)，在 $(0,0)$ 处的 Clarke 次微分 $\\partial_C \\phi(a,b)$ 是梯度极限点集合的凸包，即 $\\{(\\cos\\theta-1, \\sin\\theta-1) | \\theta \\in [0, \\pi/2]\\}$。从此凸集中选择任意元素都构成了半光滑牛顿法的有效选择。我们从 Bouligand (或 B-) 次微分中选择一个有原则的元素，它对应于沿某路径趋近奇异点时雅可比矩阵的极限。沿着“主动接触”路径（$(u_k, \\lambda_k) \\to (c, 0)$，其中 $u_k=c$ 且 $\\lambda_k \\to 0^+$）取极限，得到：\n$$\\lim_{\\lambda \\to 0^+} \\nabla_x R_2(c, \\lambda) = \\lim_{\\lambda \\to 0^+} \\left(1 - \\frac{0}{\\lambda}, \\frac{\\lambda}{|\\lambda|}-1 \\right) = (1, 0)$$\n这导致在奇异点 $(u,\\lambda)=(c,0)$ 处广义雅可比矩阵的以下选择：\n$$V(c, 0) = \\begin{pmatrix} k  1 \\\\ 1  0 \\end{pmatrix}$$\n当 $k0$ 时，该矩阵可逆，确保了牛顿步是良定义的。\n\n### 步骤 3：算法设计：阻尼半光滑牛顿法\n\n求解器实现了一个阻尼半光滑牛顿-拉夫逊算法来找到 $R(u,\\lambda)=0$ 的根。令 $x_k = (u_k, \\lambda_k)^T$ 为第 $k$ 次迭代的未知量向量。\n\n算法按以下步骤进行，对于 $k=0, 1, 2, \\ldots$：\n1.  **初始化**: 从初始猜测值 $x_0 = (u_0, \\lambda_0) = (0,0)$ 开始。\n2.  **终止检查**: 计算残差 $R_k = R(x_k)$。如果其欧几里得范数 $\\lVert R_k \\rVert_2$ 小于容差 $\\epsilon = 10^{-10}$，或者达到最大迭代次数（$50$ 次），算法终止。\n3.  **牛顿步计算**：\n    a.  使用上面推导的表达式组装广义雅可比矩阵 $V_k = V(x_k)$。使用一个小的数值容差来区分奇异情况和常规情况。\n    b.  求解线性系统 $V_k \\Delta x_k = -R_k$ 以获得搜索方向 $\\Delta x_k = (\\Delta u_k, \\Delta \\lambda_k)^T$。\n4.  **线搜索**: 为促进全局收敛，使用回溯线搜索来找到一个合适的步长 $\\alpha_k \\in (0, 1]$。\n    a.  从完整步长 $\\alpha = 1$ 开始。\n    b.  计算试验点 $x_{trial} = x_k + \\alpha \\Delta x_k$。\n    c.  评估试验点处的残差范数 $\\lVert R(x_{trial}) \\rVert_2$。\n    d.  如果 $\\lVert R(x_{trial}) \\rVert_2  \\lVert R_k \\rVert_2$，则接受该步长 ($\\alpha_k = \\alpha$)。\n    e.  否则，减小步长 ($\\alpha \\leftarrow \\alpha/2$) 并重复检查。此过程持续进行，直到观察到充分下降或步长低于最小阈值 $\\alpha_{min} = 2^{-20}$。\n5.  **更新**: 更新解：$x_{k+1} = x_k + \\alpha_k \\Delta x_k$。\n最终输出包括收敛的解 $(u^\\star, \\lambda^\\star)$ 和最终的残差范数 $\\lVert R(u^\\star, \\lambda^\\star) \\rVert_2$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the series of contact problems and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        (1000.0, 0.15, 100.0),  # Case 1: No contact expected\n        (1000.0, 0.05, 400.0),  # Case 2: Active contact expected\n        (1000.0, 0.0, 0.0),     # Case 3: Degenerate at the origin\n        (800.0, 0.2, 160.0),   # Case 4: Boundary case f = k*c\n    ]\n\n    results = []\n    for k, c, f in test_cases:\n        u_star, lambda_star, final_residual_norm = run_solver(k, c, f)\n        results.extend([u_star, lambda_star, final_residual_norm])\n\n    # Format the final output string\n    formatted_results = [f\"{val:.10f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef run_solver(k, c, f, u0=0.0, lam0=0.0, max_iter=50, tol=1e-10, min_alpha=2**-20):\n    \"\"\"\n    Implements a damped semismooth Newton solver for the unilateral contact problem.\n\n    Args:\n        k (float): Stiffness coefficient.\n        c (float): Initial clearance.\n        f (float): Applied external load.\n        u0 (float): Initial guess for displacement.\n        lam0 (float): Initial guess for contact pressure.\n        max_iter (int): Maximum number of iterations.\n        tol (float): Convergence tolerance for the residual norm.\n        min_alpha (float): Minimum step size for the line search.\n\n    Returns:\n        tuple: A tuple containing the final displacement (u), contact pressure (lam),\n               and the Euclidean norm of the final residual.\n    \"\"\"\n    u, lam = u0, lam0\n    \n    # Small tolerance for checking singularity in Jacobian\n    jac_tol = 1e-12\n\n    for _ in range(max_iter):\n        # 1. Compute Residual R(u, lam)\n        gap = c - u\n        \n        # Fischer-Burmeister part of the residual, as defined in the problem\n        norm_val = np.sqrt(gap**2 + lam**2)\n        r1 = k * u + lam - f\n        r2 = norm_val - gap - lam\n        \n        R_vec = np.array([r1, r2])\n        res_norm = np.linalg.norm(R_vec)\n\n        # 2. Check for convergence\n        if res_norm  tol:\n            break\n\n        # 3. Compute Generalized Jacobian J(u, lam)\n        J = np.zeros((2, 2))\n        J[0, 0] = k\n        J[0, 1] = 1.0\n\n        if norm_val > jac_tol:\n            # Regular case (not at the non-differentiable point)\n            J[1, 0] = 1.0 - gap / norm_val\n            J[1, 1] = lam / norm_val - 1.0\n        else:\n            # Singular case: (c-u, lam) = (0,0). Use an element from the B-subdifferential.\n            # This choice corresponds to the limit from the active contact side.\n            J[1, 0] = 1.0\n            J[1, 1] = 0.0\n\n        # 4. Solve the linear system J * delta_x = -R for the Newton step\n        try:\n            delta_x = np.linalg.solve(J, -R_vec)\n        except np.linalg.LinAlgError:\n            # Jacobian is singular, can't proceed with this step\n            break\n\n        # 5. Backtracking Line Search\n        alpha = 1.0\n        while alpha > min_alpha:\n            u_new = u + alpha * delta_x[0]\n            lam_new = lam + alpha * delta_x[1]\n            \n            # Evaluate residual at the new trial point\n            gap_new = c - u_new\n            norm_val_new = np.sqrt(gap_new**2 + lam_new**2)\n            r1_new = k * u_new + lam_new - f\n            r2_new = norm_val_new - gap_new - lam_new\n            \n            res_norm_new = np.linalg.norm([r1_new, r2_new])\n            \n            # Check for sufficient decrease\n            if res_norm_new  res_norm:\n                break\n            \n            # Reduce step size\n            alpha /= 2.0\n        \n        if alpha = min_alpha and res_norm_new >= res_norm:\n             # Line search failed to find a better point, stop iterating\n             break\n\n        # 6. Update solution\n        u = u + alpha * delta_x[0]\n        lam = lam + alpha * delta_x[1]\n\n    # Evaluate final residual at the returned point\n    final_gap = c - u\n    final_norm_val = np.sqrt(final_gap**2 + lam**2)\n    final_r1 = k * u + lam - f\n    final_r2 = final_norm_val - final_gap - lam\n    final_res_norm = np.linalg.norm([final_r1, final_r2])\n\n    return u, lam, final_res_norm\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3558641"}, {"introduction": "最后的这项实践将基础接触力学原理应用于一个真实而复杂的岩土地球力学场景：一个具有方向依赖性摩擦的岩石节理。我们不再局限于简单的各向同性摩擦，而是对各向异性进行建模，其中剪切强度取决于滑移方向——这是天然裂隙的一个常见特征 [@problem_id:3558632]。这个练习展示了抽象的Signorini-Fichera框架如何作为基础，用以构建能够捕捉各向异性强度和剪切引起的剪胀等复杂行为的本构模型，从而连接理论与实际工程分析，并包括了从实验数据中标定模型参数的过程。", "problem": "考虑一个承受单边接触和摩擦滑动的平面岩石节理。法向接触遵循 Signorini-Fichera 条件：法向间隙 $g_n$ 和法向接触压力 $p_n$ 满足 $g_n \\ge 0$、$p_n \\ge 0$ 以及 $g_n \\, p_n = 0$。由于节理粗糙度，切向（剪切）行为是各向异性的。假设在给定的法向压应力 $\\sigma_n$（以 $\\mathrm{MPa}$ 为单位）下，容许的切向牵引力矢量 $\\boldsymbol{t}_t = \\tau \\, \\boldsymbol{s}$（其中 $\\tau \\ge 0$ 是剪切幅值，$\\boldsymbol{s} = [\\cos \\varphi, \\sin \\varphi]^\\top$ 是实验室坐标系中角度为 $\\varphi$（单位为度）的单位滑移方向）在材料坐标系中受到一个凸椭圆摩擦不等式的约束。在主粗糙度方向上，摩擦系数为 $\\mu_1$ 和 $\\mu_2$（无量纲），且材料坐标系相对于实验室坐标系旋转了一个角度 $\\theta_0$（单位为度）。容许集为椭圆\n$$\\left(\\frac{t_1}{\\mu_1 \\, \\sigma_n}\\right)^2 + \\left(\\frac{t_2}{\\mu_2 \\, \\sigma_n}\\right)^2 \\le 1,$$\n的内部，其中 $[t_1, t_2]^\\top$ 是 $\\boldsymbol{t}_t$ 在材料坐标系中的分量。Signorini-Fichera 摩擦互补性由各向异性屈服函数 $F(\\boldsymbol{t}_t, \\sigma_n) \\le 0$ 的 Kuhn-Tucker 条件、滑移的拉格朗日乘子 $\\lambda_s \\ge 0$ 以及 $\\lambda_s \\, F = 0$ 强制执行。\n\n基于上述基本原理，推导在已知 $\\sigma_n$ 下沿给定实验室剪切方向 $\\varphi$ 的剪切强度包络线，并证明最大容许剪切幅值 $\\,\\tau_{\\max}(\\varphi, \\sigma_n)\\,$ 可以通过将方向 $\\boldsymbol{s}$ 变换到材料坐标系并评估该椭圆，用 $\\mu_1$、$\\mu_2$ 和 $\\theta_0$ 表示出来。然后，通过最小化一组给定的直剪试验中测得的峰值剪应力与推导出的 $\\tau_{\\max}$ 之间的残差平方和，来标定各向异性摩擦参数 $(\\mu_1, \\mu_2, \\theta_0)$。标定后，通过两种方式验证接触模型：通过检查相对于已标定椭圆的容许性和互补性，将给定的试验状态分类为粘滞或滑动；并使用非关联流动法则预测剪胀角，其中剪胀取决于法向应力和各向异性。\n\n下面输入数据中的所有角度均以度为单位。所有应力均以 $\\mathrm{MPa}$ 为单位。您的程序必须遵守以下任务和测试套件。您计算的任何角度都必须在最终输出中以度表示，并按指定要求四舍五入。\n\n任务A：根据直剪数据进行参数标定：\n- 从上述基于互补性的接触模型和椭圆各向异性摩擦定律出发。基于材料坐标系中椭圆的几何形状和 $\\theta_0$ 的旋转，推导 $\\tau_{\\max}(\\varphi, \\sigma_n)$ 的表达式。\n- 使用非线性最小二乘法，根据以下在恒定法向应力下测得的峰值剪应力来标定 $(\\mu_1, \\mu_2, \\theta_0)$。使用约定：单位滑移方向在实验室坐标系中为 $\\boldsymbol{s} = [\\cos \\varphi, \\sin \\varphi]^\\top$，材料坐标系通过旋转 $\\theta_0$ 得到。\n\n标定数据集 A（每个元组为 $(\\varphi, \\sigma_n, \\tau_{\\text{meas}})$）：\n- $(0, 2, 2.000000)$, $(0, 5, 5.000000)$, $(0, 10, 10.000000)$\n- $(45, 2, 1.264911)$, $(45, 5, 3.162278)$, $(45, 10, 6.324555)$\n- $(90, 2, 1.000000)$, $(90, 5, 2.500000)$, $(90, 10, 5.000000)$\n\n报告标定后的 $\\mu_1$ 和 $\\mu_2$（无量纲），保留三位小数，以及 $\\theta_0$（以度为单位），保留两位小数。\n\n任务B：通过 Signorini-Fichera 不等式进行粘滞与滑动分类：\n- 对于以下每个试验状态，使用数据集 A 的标定参数来确定该状态是滑动（布尔值 true）还是粘滞（布尔值 false）。使用带有各向异性椭圆的 Signorini-Fichera 容许性条件；如果试验剪切幅值 $\\tau_{\\text{trial}}$ 违反了容许集或恰好位于其边界上，则声明为“滑动”；如果它严格位于容许集内部，则声明为“粘滞”。\n\n分类测试状态（每个元组为 $(\\varphi, \\sigma_n, \\tau_{\\text{trial}})$）：\n- $(45, 5, 3.500000)$\n- $(90, 5, 2.200000)$\n- $(0, 2, 2.000000)$\n\n按此顺序输出三个布尔值。\n\n任务C：在不同法向应力下的剪胀预测：\n- 假设一个非关联流动，其中塑性法向滑移增量 $d\\delta_n$ 和塑性切向滑移增量 $d\\delta_t$ 满足 $d\\delta_n/d\\delta_t = \\tan \\psi$，其中剪胀角 $\\psi$ 取决于各向异性和法向应力，如下式所示：\n$$ \\tan \\psi(\\varphi, \\sigma_n) = \\gamma \\, \\mu_{\\mathrm{eff}}(\\varphi) \\, \\frac{\\sigma_{\\mathrm{ref}}}{\\sigma_{\\mathrm{ref}} + \\sigma_n}, $$\n其中 $\\gamma$ 是一个无量纲常数，$\\sigma_{\\mathrm{ref}}  0$ 单位为 $\\mathrm{MPa}$，$\\mu_{\\mathrm{eff}}(\\varphi)$ 是您从椭圆和旋转中推导出的方向有效摩擦系数。使用 $\\gamma = 1.2$ 和 $\\sigma_{\\mathrm{ref}} = 5.0$。\n- 使用数据集 A 的标定参数，计算以下情况的 $\\psi$（以度为单位），并将每个结果保留两位小数：\n    - $(\\varphi, \\sigma_n) = (0, 2)$\n    - $(\\varphi, \\sigma_n) = (45, 5)$\n    - $(\\varphi, \\sigma_n) = (90, 10)$\n\n任务D：近各向同性边缘情况：\n- 使用相同的最小二乘法程序，根据以下近各向同性的数据集 B 标定 $(\\mu_1, \\mu_2, \\theta_0)$。报告定义为 $\\mu_{\\max}/\\mu_{\\min}$ 的各向异性比率，保留三位小数。\n\n标定数据集 B（每个元组为 $(\\varphi, \\sigma_n, \\tau_{\\text{meas}})$）：\n- $(0, 3, 2.400000)$, $(0, 6, 4.800000)$\n- $(45, 3, 2.371137)$, $(45, 6, 4.742274)$\n- $(90, 3, 2.340000)$, $(90, 6, 4.680000)$\n\n任务E：法向互补性检查：\n- 对于下面的每一对 $(g_n, p_n)$，在数值上合理的容差范围内验证 Signorini-Fichera 法向接触条件 $g_n \\ge 0$、$p_n \\ge 0$ 和 $g_n \\, p_n = 0$；输出一个布尔值，当且仅当这三个条件都成立时为 true。使用的容差为：如果一个乘积的绝对值小于 $10^{-9}$，则认为其为零。\n\n法向测试对 $(g_n, p_n)$（单位：$g_n$ 为 $\\mathrm{m}$，$p_n$ 为 $\\mathrm{MPa}$）：\n- $(0, 5)$\n- $(0.001, 0)$\n- $(0.001, 2)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表必须按顺序包含：\n    - $\\mu_1$（数据集 A，保留三位小数），\n    - $\\mu_2$（数据集 A，保留三位小数），\n    - $\\theta_0$ 以度为单位（数据集 A，保留两位小数），\n    - 任务 B 的三个布尔值（按给定顺序），\n    - 任务 C 的三个剪胀角（以度为单位），每个保留两位小数，\n    - 数据集 B 的各向异性比率 $\\mu_{\\max}/\\mu_{\\min}$（保留三位小数），\n    - 任务 E 的三个布尔值（按给定顺序）。\n- 角度必须以度为单位。应力必须按规定在内部以 $\\mathrm{MPa}$ 处理。最终输出必须打印为单行，例如：$[\\mu_1,\\mu_2,\\theta_0,\\text{bool}_1,\\text{bool}_2,\\text{bool}_3,\\psi_1,\\psi_2,\\psi_3,\\text{ratio},\\text{bool}_4,\\text{bool}_5,\\text{bool}_6]$。", "solution": "该问题要求分析平面岩石节理上的各向异性摩擦接触，该接触受法向接触的 Signorini-Fichera 条件和切向滑移的椭圆屈服准则控制。分析涉及多个任务：推导剪切强度表达式、根据实验数据标定模型参数、对接触状态进行分类，以及预测剪胀等附带现象。\n\n该问题的理论基础在于连续介质力学，特别是在接触力学和塑性理论领域。法向接触由互补性条件 $g_n \\ge 0$、$p_n \\ge 0$ 和 $g_n p_n = 0$ 描述，其中 $g_n$ 是法向间隙，$p_n$ 是法向接触压力。这些是经典的 Signorini-Fichera 条件，适用于不可穿透、无粘附的界面。切向行为使用各向异性摩擦定律建模，这是塑性理论中的一个概念，其中屈服面（在应力空间中）不是各向同性的。\n\n分析工作的核心是推导在实验室坐标系中沿给定方向的剪切强度 $\\tau_{\\max}$。这需要进行坐标变换。实验室坐标系是实验的参考坐标系，其中滑移方向由角度 $\\varphi$ 定义。材料坐标系与节理表面粗糙度的主方向对齐，相对于实验室坐标系旋转了角度 $\\theta_0$。\n\n在实验室坐标系中分量为 $[v_x, v_y]^\\top$ 的牵引力矢量 $\\boldsymbol{v}$，在材料坐标系中的分量 $[v_1, v_2]^\\top$ 由以下旋转给出：\n$$\n\\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix} = \\mathbf{R}(-\\theta_0) \\begin{pmatrix} v_x \\\\ v_y \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta_0  \\sin\\theta_0 \\\\ -\\sin\\theta_0  \\cos\\theta_0 \\end{pmatrix} \\begin{pmatrix} v_x \\\\ v_y \\end{pmatrix}\n$$\n实验室坐标系中的剪切牵引力矢量为 $\\boldsymbol{t}_t = [\\tau \\cos\\varphi, \\tau \\sin\\varphi]^\\top$。应用该变换，其在材料坐标系中的分量为：\n$$\nt_1 = \\tau (\\cos\\varphi \\cos\\theta_0 + \\sin\\varphi \\sin\\theta_0) = \\tau \\cos(\\varphi - \\theta_0)\n$$\n$$\nt_2 = \\tau (-\\cos\\varphi \\sin\\theta_0 + \\sin\\varphi \\cos\\theta_0) = \\tau \\sin(\\varphi - \\theta_0)\n$$\n切向牵引力的容许集由材料坐标系中的椭圆不等式定义：\n$$\nF(\\boldsymbol{t}_t, \\sigma_n) = \\left(\\frac{t_1}{\\mu_1 \\sigma_n}\\right)^2 + \\left(\\frac{t_2}{\\mu_2 \\sigma_n}\\right)^2 - 1 \\le 0\n$$\n其中 $\\mu_1$ 和 $\\mu_2$ 是主摩擦系数，$\\sigma_n$ 是施加的法向应力。当屈服函数 $F=0$ 时发生滑动。通过代入 $t_1$ 和 $t_2$ 的表达式并设置 $\\tau = \\tau_{\\max}$，我们得到剪切强度的条件：\n$$\n\\left(\\frac{\\tau_{\\max} \\cos(\\varphi - \\theta_0)}{\\mu_1 \\sigma_n}\\right)^2 + \\left(\\frac{\\tau_{\\max} \\sin(\\varphi - \\theta_0)}{\\mu_2 \\sigma_n}\\right)^2 = 1\n$$\n求解 $\\tau_{\\max}$ 可得到剪切强度包络线的表达式：\n$$\n\\tau_{\\max}(\\varphi, \\sigma_n) = \\sigma_n \\left[ \\frac{\\cos^2(\\varphi - \\theta_0)}{\\mu_1^2} + \\frac{\\sin^2(\\varphi - \\theta_0)}{\\mu_2^2} \\right]^{-1/2}\n$$\n方向有效摩擦系数则为 $\\mu_{\\text{eff}}(\\varphi) = \\tau_{\\max}(\\varphi, \\sigma_n) / \\sigma_n$。\n\n在此基础上，按以下步骤执行任务：\n\n**任务A：参数标定。** 通过最小化测量的剪切强度 $\\tau_{\\text{meas}}$ 与模型预测值 $\\tau_{\\max}$ 之间的残差平方和（SSR），来标定参数 $(\\mu_1, \\mu_2, \\theta_0)$。\n$$\n\\text{SSR}(\\mu_1, \\mu_2, \\theta_0) = \\sum_{i} \\left( \\tau_{\\text{meas}, i} - \\tau_{\\max}(\\varphi_i, \\sigma_{n,i}; \\mu_1, \\mu_2, \\theta_0) \\right)^2\n$$\n这是一个非线性最小二乘问题，将针对给定的数据集 A 进行数值求解。\n\n**任务B：粘滞与滑动分类。** 使用任务 A 中标定的参数，为每个试验状态计算剪切强度 $\\tau_{\\max}$。如果试验剪应力 $\\tau_{\\text{trial}}$ 大于或等于强度，即 $\\tau_{\\text{trial}} \\ge \\tau_{\\max}$，则状态分类为“滑动”；如果严格小于强度，即 $\\tau_{\\text{trial}}  \\tau_{\\max}$，则分类为“粘滞”。\n\n**任务C：剪胀预测。** 使用给定的非关联流动法则计算剪胀角 $\\psi$。首先，使用标定参数计算有效摩擦系数 $\\mu_{\\text{eff}}(\\varphi)$。然后，应用以下公式：\n$$\n\\tan \\psi(\\varphi, \\sigma_n) = \\gamma \\, \\mu_{\\mathrm{eff}}(\\varphi) \\, \\frac{\\sigma_{\\mathrm{ref}}}{\\sigma_{\\mathrm{ref}} + \\sigma_n}\n$$\n角度 $\\psi$ 通过对此值取反正切获得。\n\n**任务D：近各向同性边缘情况。** 对数据集 B 重复任务 A 的标定过程。然后，根据得到的标定主摩擦系数 $\\mu_{1,B}$ 和 $\\mu_{2,B}$，计算各向异性比率，即 $\\mu_{\\max}/\\mu_{\\min} = \\max(\\mu_{1,B}, \\mu_{2,B}) / \\min(\\mu_{1,B}, \\mu_{2,B})$。\n\n**任务E：法向互补性检查。** 每一对法向间隙 $g_n$ 和法向压力 $p_n$ 都将根据三个 Signorini-Fichera 条件进行评估：$g_n \\ge 0$，$p_n \\ge 0$，以及互补性乘积 $|g_n \\cdot p_n|  10^{-9}$。布尔值 true 表示所有三个条件都得到满足。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves a multi-part problem in computational geomechanics involving\n    anisotropic friction, contact mechanics, and parameter calibration.\n    \"\"\"\n\n    # --- Model Functions ---\n\n    def get_tau_max(params, phi_deg, sigma_n):\n        \"\"\"Calculates the maximum admissible shear stress (shear strength).\"\"\"\n        mu1, mu2, theta0_deg = params\n        phi_rad = np.deg2rad(phi_deg)\n        theta0_rad = np.deg2rad(theta0_deg)\n\n        term1 = (np.cos(phi_rad - theta0_rad) / mu1)**2\n        term2 = (np.sin(phi_rad - theta0_rad) / mu2)**2\n        if term1 + term2  1e-12: # Avoid division by zero if mu1/mu2 are huge\n            return 0.0\n        \n        mu_eff = 1.0 / np.sqrt(term1 + term2)\n        return sigma_n * mu_eff\n\n    def ssr_objective(params, data):\n        \"\"\"Sum of Squared Residuals objective function for optimization.\"\"\"\n        mu1, mu2, theta0_deg = params\n        if mu1 = 0 or mu2 = 0:\n            return np.inf  # Enforce positive friction coefficients\n        \n        residuals = []\n        for phi_deg, sigma_n, tau_meas in data:\n            tau_pred = get_tau_max(params, phi_deg, sigma_n)\n            residuals.append((tau_pred - tau_meas)**2)\n        return np.sum(residuals)\n\n    # --- Task A: Parameter calibration from direct-shear data ---\n\n    calibration_data_A = [\n        (0, 2, 2.000000), (0, 5, 5.000000), (0, 10, 10.000000),\n        (45, 2, 1.264911), (45, 5, 3.162278), (45, 10, 6.324555),\n        (90, 2, 1.000000), (90, 5, 2.500000), (90, 10, 5.000000)\n    ]\n    \n    initial_guess_A = [1.0, 0.5, 0.0]\n    bounds_A = [(1e-6, None), (1e-6, None), (-90, 90)]\n    \n    result_A = minimize(\n        ssr_objective,\n        initial_guess_A,\n        args=(calibration_data_A,),\n        method='L-BFGS-B',\n        bounds=bounds_A\n    )\n    \n    mu1_A, mu2_A, theta0_A = result_A.x\n    # Ensure mu1 is the larger coefficient for consistency\n    if mu1_A  mu2_A:\n        mu1_A, mu2_A = mu2_A, mu1_A\n        theta0_A = (theta0_A + 90) % 180 - 90\n    calibrated_params_A = [mu1_A, mu2_A, theta0_A]\n\n    # --- Task B: Stick-versus-sliding classification ---\n\n    classification_states = [\n        (45, 5, 3.500000),\n        (90, 5, 2.200000),\n        (0, 2, 2.000000)\n    ]\n    \n    classif_results = []\n    # Use a small tolerance for floating point comparison\n    slip_tol = 1e-9\n    for phi_deg, sigma_n, tau_trial in classification_states:\n        tau_lim = get_tau_max(calibrated_params_A, phi_deg, sigma_n)\n        is_sliding = tau_trial >= tau_lim - slip_tol\n        classif_results.append(is_sliding)\n\n    # --- Task C: Dilation prediction ---\n    \n    def get_dilation_angle(params, phi_deg, sigma_n, gamma, sigma_ref):\n        \"\"\"Computes the dilation angle psi in degrees.\"\"\"\n        if sigma_n = 0:\n            return 0.0\n        \n        tau_lim = get_tau_max(params, phi_deg, sigma_n)\n        mu_eff = tau_lim / sigma_n\n        \n        tan_psi = gamma * mu_eff * (sigma_ref / (sigma_ref + sigma_n))\n        psi_rad = np.arctan(tan_psi)\n        return np.rad2deg(psi_rad)\n\n    dilation_cases = [\n        (0, 2),\n        (45, 5),\n        (90, 10)\n    ]\n    gamma = 1.2\n    sigma_ref = 5.0\n    \n    dilation_results = []\n    for phi_deg, sigma_n in dilation_cases:\n        psi = get_dilation_angle(calibrated_params_A, phi_deg, sigma_n, gamma, sigma_ref)\n        dilation_results.append(psi)\n\n    # --- Task D: Near-isotropy edge case ---\n\n    calibration_data_B = [\n        (0, 3, 2.400000), (0, 6, 4.800000),\n        (45, 3, 2.371137), (45, 6, 4.742274),\n        (90, 3, 2.340000), (90, 6, 4.680000)\n    ]\n    \n    initial_guess_B = [0.8, 0.78, 0.0]\n    bounds_B = [(1e-6, None), (1e-6, None), (-90, 90)]\n\n    result_B = minimize(\n        ssr_objective,\n        initial_guess_B,\n        args=(calibration_data_B,),\n        method='L-BFGS-B',\n        bounds=bounds_B\n    )\n    \n    mu1_B, mu2_B, _ = result_B.x\n    anisotropy_ratio = max(mu1_B, mu2_B) / min(mu1_B, mu2_B)\n\n    # --- Task E: Normal complementarity checks ---\n\n    normal_test_pairs = [\n        (0, 5),\n        (0.001, 0),\n        (0.001, 2)\n    ]\n    \n    complementarity_results = []\n    tolerance = 1e-9\n    for g_n, p_n in normal_test_pairs:\n        cond1 = g_n >= -tolerance\n        cond2 = p_n >= -tolerance\n        cond3 = abs(g_n * p_n)  tolerance\n        holds = cond1 and cond2 and cond3\n        complementarity_results.append(holds)\n\n    # --- Final Output Formatting ---\n    \n    # Python's bool string is 'True' or 'False', convert to lowercase as per convention\n    output_list = [\n        f\"{mu1_A:.3f}\",\n        f\"{mu2_A:.3f}\",\n        f\"{theta0_A:.2f}\",\n        str(classif_results[0]).lower(),\n        str(classif_results[1]).lower(),\n        str(classif_results[2]).lower(),\n        f\"{dilation_results[0]:.2f}\",\n        f\"{dilation_results[1]:.2f}\",\n        f\"{dilation_results[2]:.2f}\",\n        f\"{anisotropy_ratio:.3f}\",\n        str(complementarity_results[0]).lower(),\n        str(complementarity_results[1]).lower(),\n        str(complementarity_results[2]).lower()\n    ]\n    \n    print(f\"[{','.join(output_list)}]\")\n\nsolve()\n```", "id": "3558632"}]}