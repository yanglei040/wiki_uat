{"hands_on_practices": [{"introduction": "在进行任何力学计算之前，我们必须首先解决接触检测这一几何问题。这项练习挑战你为“节点-分段”(Node-to-Segment)方法实现一个稳健的决策逻辑[@problem_id:3509961]，以确保从属节点能够唯一且正确地映射到主分段上，即使是在邻近拐角的模糊情况下。掌握这一几何基础，是构建任何可靠的接触模拟代码的关键第一步。", "problem": "给定一个二维折线界面，由一个有序的顶点列表以及连续顶点之间对应的直线段定义。在计算地质力学中，使用节点到线段离散化进行接触检测时，一个节点通过正交投影精确地映射到折线的一个线段上。您的任务是实现一个鲁棒且确定性的决策逻辑，对于任意节点位置，该逻辑能选择投影所在的线段，并在拐角处一致地解决平局问题。\n\n从基本几何定义开始。设折线顶点为 $v_0,\\dots,v_m \\in \\mathbb{R}^2$，其中线段 $S_i$ 连接 $v_i$ 和 $v_{i+1}$，对于 $i \\in \\{0,\\dots,m-1\\}$。对于一个节点 $x \\in \\mathbb{R}^2$ 和一个线段 $S_i$，记线段向量为 $e_i = v_{i+1} - v_i$，单位切向量为 $t_i = e_i / \\|e_i\\|$，左手法向单位向量为 $n_i = R(t_i)$，其中 $R$ 在平面内将向量旋转 $+90^\\circ$，因此 $R[(a,b)] = (-b,a)$。对于包含 $S_i$ 的无限直线， $x$ 在该直线上的正交投影可以写为 $p_i = v_i + \\tau_i e_i$，其中投影参数为 $\\tau_i = \\frac{(x - v_i) \\cdot e_i}{\\|e_i\\|^2}$， $x$ 到该直线的欧几里得距离为 $d_i = \\|x - p_i\\|$。如果 $\\tau_i \\in [0,1]$，则 $x$ 到线段 $S_i$ 的最近点为 $p_i$，否则为最近的端点。\n\n使用这些基本定义和一个数值公差 $\\varepsilon = 10^{-12}$ 来比较实数，实现以下线段选择逻辑：\n\n1. 内部投影优先：在所有满足 $\\tau_i \\in (0,1)$ 的线段中，选择使 $d_i$ 最小化的线段。如果在公差范围内出现平局，则通过选择使朝向度量 $s_i = n_i \\cdot r_i$ 最大化的线段来打破平局，其中如果 $\\|x - p_i\\| > \\varepsilon$，则 $r_i = \\frac{x - p_i}{\\|x - p_i\\|}$，否则 $r_i = (0,0)$。如果仍然存在平局，选择使 $t_i \\cdot r_i$ 最大化的线段，如果平局依然存在，则选择最小的线段索引。\n\n2. 当不存在内部投影时的拐角平局解决：如果没有 $\\tau_i \\in (0,1)$，确定离 $x$ 最近的顶点 $v_k$。令 $\\mathcal{A}(k)$ 为共享顶点 $v_k$ 的相邻线段集合。如果 $|\\mathcal{A}(k)| = 1$，选择那个唯一的相邻线段。如果 $|\\mathcal{A}(k)| = 2$，令 $u_j$ 为线段 $S_j$ 的单位切向量，其方向从 $v_k$ 沿线段内部向外，即 $u_j = \\frac{v_{\\text{other}} - v_k}{\\|v_{\\text{other}} - v_k\\|}$，其中 $v_{\\text{other}}$ 是 $S_j$ 不等于 $v_k$ 的端点，并定义 $n_j = R(u_j)$。如果 $\\|x - v_k\\| > \\varepsilon$，令 $r = \\frac{x - v_k}{\\|x - v_k\\|}$，否则 $r = (0,0)$。选择使 $s_j = n_j \\cdot r$ 最大化的线段。如果在公差范围内出现平局，选择使 $u_j \\cdot r$ 最大化的线段。如果节点恰好位于顶点上，即 $\\|x - v_k\\| \\le \\varepsilon$，则在相邻线段中选择最小的索引以确保确定性。\n\n3. 回退策略：如果内部投影和拐角邻近逻辑都不适用（对于有效的折线和节点，这不应发生），则选择使 $d_i$ 最小化的线段，并像步骤1中那样打破平局。\n\n使用以下固定的折线和测试套件。该折线有 $m = 4$ 个线段和顶点\n$v_0 = (0,0)$， $v_1 = (2,0)$， $v_2 = (2,1)$， $v_3 = (2,3)$， $v_4 = (0,3)$。\n有序线段为 $S_0 = [v_0,v_1]$，$S_1 = [v_1,v_2]$，$S_2 = [v_2,v_3]$，$S_3 = [v_3,v_4]$。\n\n对以下节点评估线段选择（每个节点以 $\\mathbb{R}^2$ 中的 $(x_1,x_2)$ 形式给出）：\n- 测试 1：$(1.0,-0.2)$。\n- 测试 2：$(2.0,-0.5)$。\n- 测试 3：$(3.0,3.4)$。\n- 测试 4：$(2.0,1.0)$。\n- 测试 5：$(1.0,3.1)$。\n- 测试 6：$(-0.2,0.1)$。\n- 测试 7：$(1.5,0.5)$。\n\n您的程序应使用上述逻辑为每个测试节点计算所选线段的索引 $i \\in \\{0,1,2,3\\}$，并生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。所有计算都是纯几何的；不需要物理单位，角度通过无弧度形式的向量点积隐式处理。", "solution": "用户提供的问题基于指定标准是**有效**的。它在科学上以欧几里得几何为基础，是一个良态问题，具有一组确保唯一解的确定性规则，并且在形式上是完备的。该问题要求实现一个用于节点到线段映射的特定分层算法，这是计算力学中的一个相关任务。\n\n解决方案需要直接且细致地实现所规定的几何逻辑。问题的核心是开发一个函数，给定一个节点 $x \\in \\mathbb{R}^2$ 的坐标和一个由有序顶点集 $\\{v_0, v_1, \\dots, v_m\\}$ 定义的折线，该函数根据一个三层决策过程选择单个线段 $S_i = [v_i, v_{i+1}]$。\n\n首先，对于折线的每个线段 $S_i$，我们必须计算一组相对于节点 $x$ 的几何量。这些量源自基本的向量代数。线段由其起始顶点 $v_i$ 和结束顶点 $v_{i+1}$ 定义。线段向量为 $e_i = v_{i+1} - v_i$。线段的长度平方为 $\\|e_i\\|^2 = e_i \\cdot e_i$。一个关键参数是归一化投影参数 $\\tau_i$，它决定了 $x$ 在包含 $S_i$ 的无限直线上的正交投影的位置。其计算公式为：\n$$\n\\tau_i = \\frac{(x - v_i) \\cdot e_i}{\\|e_i\\|^2}\n$$\n这个参数 $\\tau_i$ 表明，当且仅当 $\\tau_i \\in [0,1]$ 时，投影点 $p_i = v_i + \\tau_i e_i$ 位于线段 $S_i$ 上。\n节点 $x$ 到该直线的正交距离为 $d_i = \\|x - p_i\\|$。\n用于打破平局的其他所需量包括：单位切向量 $t_i = e_i / \\|e_i\\|$，左手法向单位向量 $n_i = R(t_i)$（其中 $R[(a,b)] = (-b,a)$），以及一个从投影点指向节点的归一化方向向量，定义为：如果 $d_i > \\varepsilon$，则 $r_i = (x-p_i)/d_i$，否则 $r_i=(0,0)$，其中 $\\varepsilon=10^{-12}$ 是指定的数值公差。这些向量用于计算打破平局的度量 $s_i = n_i \\cdot r_i$ 和 $t_i \\cdot r_i$。\n\n所实现的算法遵循规定的分层逻辑：\n\n1.  **内部投影优先：** 主要选择标准是基于识别那些节点的正交投影严格落在其内部的线段。这对应于条件 $\\tau_i \\in (0,1)$。为了处理浮点运算，该条件实现为 $\\tau_i > \\varepsilon$ 和 $1 - \\tau_i > \\varepsilon$。如果一个或多个线段满足此条件，则通过字典序比较从此候选集中选择一个唯一的线段。候选线段首先按最小化正交距离 $d_i$ 排序，然后按最大化“朝向度量” $s_i$ 排序，再按最大化切向对齐度量 $t_i \\cdot r_i$ 排序，最后按最小的线段索引 $i$ 排序。这种多级排序确保了确定性的结果。一种计算上高效的实现方法是通过多键稳定排序，或等效地，使用一个键元组 `(d_i, -s_i, -t_i \\cdot r_i, i)` 进行单遍排序。\n\n2.  **拐角平局解决：** 如果没有线段具有内部投影（即第一步中的候选集为空），则逻辑进入拐角解决规则。此规则假定节点在几何上最接近折线的某个顶点。第一步是通过最小化所有顶点 $v_j$ 的欧几里得距离 $\\|x - v_j\\|$ 来确定离节点 $x$ 最近的顶点 $v_k$。\n    然后考虑与 $v_k$ 相邻的线段。折线结构决定了端点顶点（如 $v_0$ 或 $v_m$）有一个相邻线段，而内部顶点 $v_k$（对于 $0  k  m$）有两个相邻线段（$S_{k-1}$ 和 $S_k$）。\n    - 如果只有一个线段与 $v_k$ 相邻，则明确选择该线段。\n    - 如果有两个相邻线段，则需要一个打破平局的程序。一个特殊情况是当节点 $x$ 恰好位于顶点 $v_k$ 上时（即 $\\|x-v_k\\| \\le \\varepsilon$）。在这种情况下，通过选择索引较小的相邻线段来实现确定性。\n    - 如果节点靠近但不位于顶点上，选择将基于哪个线段更直接地“面向”节点。对于每个相邻线段 $S_j$，定义一个从拐角 $v_k$ 指向线段内部的单位切向量 $u_j$。相关的法向量为 $n_j=R(u_j)$。计算一个相对位置向量 $r = (x-v_k)/\\|x-v_k\\|$。选择使点积 $s_j = n_j \\cdot r$ 最大化的线段。如果这导致平局（即值在 $\\varepsilon$ 范围内彼此接近），则使用第二个平局打破规则：选择使点积 $u_j \\cdot r$ 最大化的线段。为确保鲁棒性，还实现了一个基于线段索引的最终平局打破规则，尽管对于不同的线段，在此级别上出现平局在几何上是不太可能的。\n\n3.  **回退机制：** 问题陈述表明，前两条规则应足以解决有效折线和节点的任何情况。然而，为了程序的完备性，包含了一个回退机制。如果拐角解决逻辑未能产生选择，算法将恢复为对所有线段的全局搜索，将与第一条规则相同的选择标准（最小化 $d_i$ 等）应用于所有线段，而不仅仅是那些具有内部投影的线段。这确保了总能选择一个线段。\n\n最终的实现将此逻辑封装在一个 Python 函数中。它使用 `numpy` 库进行高效、简洁的向量运算。该函数处理每个测试节点，为所有四个线段计算所需的几何数据，并应用有序规则来确定所选线段的索引。然后，所有测试用例的结果被汇总并格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the node-to-segment mapping problem.\n    It defines the polyline and test nodes, then computes the selected\n    segment for each node using the specified hierarchical logic.\n    \"\"\"\n    \n    # Define the polyline vertices and test cases from the problem statement.\n    vertices = np.array([\n        [0.0, 0.0],  # v0\n        [2.0, 0.0],  # v1\n        [2.0, 1.0],  # v2\n        [2.0, 3.0],  # v3\n        [0.0, 3.0],  # v4\n    ])\n    \n    # Segments are defined by indices of the vertices array\n    segments = [(0, 1), (1, 2), (2, 3), (3, 4)]\n    \n    test_nodes = [\n        (1.0, -0.2),\n        (2.0, -0.5),\n        (3.0, 3.4),\n        (2.0, 1.0),\n        (1.0, 3.1),\n        (-0.2, 0.1),\n        (1.5, 0.5),\n    ]\n\n    epsilon = 1e-12\n\n    def rotate_90(v):\n        \"\"\"Rotates a 2D vector by +90 degrees.\"\"\"\n        return np.array([-v[1], v[0]])\n\n    def select_segment(node, vertices, segments, epsilon):\n        \"\"\"\n        Implements the specified hierarchical logic to select a segment for a given node.\n        \"\"\"\n        \n        # 1. Pre-computation for all segments\n        segment_data = []\n        for i, (v_start_idx, v_end_idx) in enumerate(segments):\n            v_i = vertices[v_start_idx]\n            v_i_plus_1 = vertices[v_end_idx]\n            \n            e_i = v_i_plus_1 - v_i\n            e_len_sq = np.dot(e_i, e_i)\n            \n            if e_len_sq  epsilon**2: # Segment has zero length\n                tau_i = 0.0\n                p_i = v_i\n                t_i = np.array([0.0, 0.0])\n            else:\n                tau_i = np.dot(node - v_i, e_i) / e_len_sq\n                p_i = v_i + tau_i * e_i\n                t_i = e_i / np.sqrt(e_len_sq)\n\n            n_i = rotate_90(t_i)\n            x_minus_pi = node - p_i\n            d_i = np.linalg.norm(x_minus_pi)\n            \n            if d_i  epsilon:\n                r_i = x_minus_pi / d_i\n            else:\n                r_i = np.array([0.0, 0.0])\n                \n            s_i = np.dot(n_i, r_i)\n            t_dot_r_i = np.dot(t_i, r_i)\n            \n            segment_data.append({\n                'index': i, 'tau': tau_i, 'd': d_i, 's': s_i, 't_dot_r': t_dot_r_i,\n            })\n\n        # 2. Rule 1: Interior projection preference\n        interior_candidates = [\n            d for d in segment_data \n            if (d['tau']  epsilon) and (1.0 - d['tau']  epsilon)\n        ]\n        \n        if interior_candidates:\n            # Sort by d_i (asc), s_i (desc), t_dot_r_i (desc), index (asc)\n            # Python's sort is stable, so we can sort by keys in reverse order of precedence.\n            interior_candidates.sort(key=lambda d: d['index'])\n            interior_candidates.sort(key=lambda d: d['t_dot_r'], reverse=True)\n            interior_candidates.sort(key=lambda d: d['s'], reverse=True)\n            interior_candidates.sort(key=lambda d: d['d'])\n            return interior_candidates[0]['index']\n\n        # 3. Rule 2: Corner tie resolution\n        dists_to_vertices = [np.linalg.norm(node - v) for v in vertices]\n        k = np.argmin(dists_to_vertices)\n        \n        adj_indices = []\n        if k  0:\n            adj_indices.append(k - 1)\n        if k  len(vertices) - 1:\n            adj_indices.append(k)\n        \n        if not adj_indices:\n             # Fallback, should not happen for this problem\n             pass\n        elif len(adj_indices) == 1:\n            return adj_indices[0]\n        else: # len == 2\n            v_k = vertices[k]\n            if np.linalg.norm(node - v_k) = epsilon:\n                return min(adj_indices)\n            else:\n                r = (node - v_k) / np.linalg.norm(node - v_k)\n                corner_candidates = []\n                for seg_idx in adj_indices:\n                    v_start_idx, v_end_idx = segments[seg_idx]\n                    \n                    if v_start_idx == k:\n                        v_other = vertices[v_end_idx]\n                        u_vec = v_other - v_k\n                    else:\n                        v_other = vertices[v_start_idx]\n                        u_vec = v_other - v_k\n                    \n                    u_j = u_vec / np.linalg.norm(u_vec)\n                    n_j = rotate_90(u_j)\n                    \n                    s_j = np.dot(n_j, r)\n                    u_dot_r = np.dot(u_j, r)\n                    \n                    corner_candidates.append({\n                        'index': seg_idx, 's': s_j, 'u_dot_r': u_dot_r\n                    })\n\n                # Perform comparison with tolerance\n                cand1, cand2 = corner_candidates[0], corner_candidates[1]\n                \n                s_diff = cand1['s'] - cand2['s']\n                if s_diff  epsilon:\n                    return cand1['index']\n                if -s_diff  epsilon:\n                    return cand2['index']\n                \n                # Tie in s_j, check u_dot_r\n                u_dot_r_diff = cand1['u_dot_r'] - cand2['u_dot_r']\n                if u_dot_r_diff  epsilon:\n                    return cand1['index']\n                if -u_dot_r_diff  epsilon:\n                    return cand2['index']\n\n                # Final tie-break with index\n                return min(cand1['index'], cand2['index'])\n\n        # 4. Fallback: should not be reached but included for robustness\n        segment_data.sort(key=lambda d: d['index'])\n        segment_data.sort(key=lambda d: d['t_dot_r'], reverse=True)\n        segment_data.sort(key=lambda d: d['s'], reverse=True)\n        segment_data.sort(key=lambda d: d['d'])\n        return segment_data[0]['index']\n\n    results = []\n    for node_coords in test_nodes:\n        node_np = np.array(node_coords, dtype=float)\n        selected_index = select_segment(node_np, vertices, segments, epsilon)\n        results.append(selected_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3509961"}, {"introduction": "一旦确定了接触对，下一步就是将不可穿透的物理约束转化为可用于有限元求解器的数学形式。本练习将引导您从虚功原理出发，使用罚函数法推导单个接触对的离散残差向量[@problem_id:3510014]。这是一个基础性练习，它将连续介质力学理论与计算机求解的离散代数方程联系起来。", "problem": "在计算岩土力学的背景下，考虑一个二维小应变运动学中的无摩擦单边接触相互作用，该作用发生在一个从节点和一个由两个节点组成的直主面段之间。主面段的端节点标记为 $m_{1}$ 和 $m_{2}$，其参考位置为 $\\boldsymbol{X}_{m_{1}}$ 和 $\\boldsymbol{X}_{m_{2}}$，当前位移为 $\\boldsymbol{u}_{m_{1}}$ 和 $\\boldsymbol{u}_{m_{2}}$。从节点 $s$ 的参考位置为 $\\boldsymbol{X}_{s}$，当前位移为 $\\boldsymbol{u}_{s}$。设主面段由局部坐标 $\\xi \\in [-1,1]$ 参数化，其标准线性形函数为 $N_{1}(\\xi) = \\frac{1-\\xi}{2}$ 和 $N_{2}(\\xi) = \\frac{1+\\xi}{2}$。假设主面段上最近投影点的外法向单位向量是常向量 $\\boldsymbol{n} = (n_{x}, n_{y})^{\\mathsf{T}}$，并且最近点投影坐标 $\\xi$ 严格位于开区间 $(-1,1)$ 内，且在当前残差计算期间保持固定。\n\n从虚功原理和法向接触间隙的二次罚函数势的定义出发，推导与此单个节点-分段接触对相关的离散残差贡献。使用由运动学定义的法向间隙\n$$\ng_{n} = \\boldsymbol{n}^{\\mathsf{T}}\\left[\\left(\\boldsymbol{X}_{s} + \\boldsymbol{u}_{s}\\right) - \\sum_{a=1}^{2} N_{a}(\\xi)\\left(\\boldsymbol{X}_{m_{a}} + \\boldsymbol{u}_{m_{a}}\\right)\\right],\n$$\n和一个标量罚刚度 $k_{p}  0$。在构建此残差时，忽略 $\\xi$ 和 $\\boldsymbol{n}$ 对节点自由度的依赖性。\n\n- 清楚地指出从此接触对接收非零贡献的节点自由度，并采用以下自由度排序\n$$\n\\left[u_{s,x},\\, u_{s,y},\\, u_{m_{1},x},\\, u_{m_{1},y},\\, u_{m_{2},x},\\, u_{m_{2},y}\\right]^{\\mathsf{T}}.\n$$\n- 将您的最终结果表示为离散残差贡献 $\\boldsymbol{R}_{c}$ 的单个向量值解析表达式，该表达式用 $k_{p}$、$g_{n}$、$n_{x}$、$n_{y}$、$N_{1}(\\xi)$ 和 $N_{2}(\\xi)$ 以及上述排序表示。您可以将 $g_{n}$ 保留为符号形式，或者代入其对参考位置和位移的显式依赖关系。\n\n您的最终答案必须是单个闭式解析表达式。不包含单位。无需进行数值舍入。", "solution": "推导始于罚函数法中接触问题的虚功原理。对于无摩擦法向接触罚函数，引入一个罚函数势来惩罚通过法向间隙发生的穿透。从节点处的标准二次罚函数势为\n$$\n\\Pi_{c} = \\frac{1}{2}\\,k_{p}\\,g_{n}^{2},\n$$\n其中 $k_{p}  0$ 是罚刚度，$g_{n}$ 是法向间隙。相应的接触虚功是该势能的一次变分，即\n$$\n\\delta \\Pi_{c} = k_{p}\\,g_{n}\\,\\delta g_{n}.\n$$\n在小应变、小位移的设定下，固定最近点参数 $\\xi$ 和单位法向量 $\\boldsymbol{n}$，法向间隙由运动学定义为\n$$\ng_{n} = \\boldsymbol{n}^{\\mathsf{T}}\\left[\\left(\\boldsymbol{X}_{s} + \\boldsymbol{u}_{s}\\right) - \\sum_{a=1}^{2} N_{a}(\\xi)\\left(\\boldsymbol{X}_{m_{a}} + \\boldsymbol{u}_{m_{a}}\\right)\\right].\n$$\n忽略 $\\xi$ 和 $\\boldsymbol{n}$ 的变分，间隙的变分由线性关系可得：\n$$\n\\delta g_{n} = \\boldsymbol{n}^{\\mathsf{T}}\\left[\\delta \\boldsymbol{u}_{s} - \\sum_{a=1}^{2} N_{a}(\\xi)\\,\\delta \\boldsymbol{u}_{m_{a}}\\right]\n= \\boldsymbol{n}^{\\mathsf{T}}\\delta \\boldsymbol{u}_{s} - N_{1}(\\xi)\\,\\boldsymbol{n}^{\\mathsf{T}}\\delta \\boldsymbol{u}_{m_{1}} - N_{2}(\\xi)\\,\\boldsymbol{n}^{\\mathsf{T}}\\delta \\boldsymbol{u}_{m_{2}}.\n$$\n代入虚功表达式得到\n$$\n\\delta \\Pi_{c} = k_{p}\\,g_{n}\\left(\\boldsymbol{n}^{\\mathsf{T}}\\delta \\boldsymbol{u}_{s} - N_{1}(\\xi)\\,\\boldsymbol{n}^{\\mathsf{T}}\\delta \\boldsymbol{u}_{m_{1}} - N_{2}(\\xi)\\,\\boldsymbol{n}^{\\mathsf{T}}\\delta \\boldsymbol{u}_{m_{2}}\\right).\n$$\n根据与自由度相关的离散残差向量 $\\boldsymbol{R}_{c}$ 的定义，有 $\\delta \\Pi_{c} = \\boldsymbol{R}_{c}^{\\mathsf{T}}\\,\\delta \\boldsymbol{u}$，其中采用所定排序的虚拟节点位移向量为\n$$\n\\delta \\boldsymbol{u} =\n\\begin{bmatrix}\n\\delta u_{s,x} \\\\ \\delta u_{s,y} \\\\ \\delta u_{m_{1},x} \\\\ \\delta u_{m_{1},y} \\\\ \\delta u_{m_{2},x} \\\\ \\delta u_{m_{2},y}\n\\end{bmatrix}.\n$$\n注意到 $\\boldsymbol{n}^{\\mathsf{T}}\\delta \\boldsymbol{u}_{\\bullet} = n_{x}\\,\\delta u_{\\bullet,x} + n_{y}\\,\\delta u_{\\bullet,y}$，可以直接读出残差向量的分量：\n- 从节点接收的贡献为 $k_{p} g_{n}\\,\\boldsymbol{n}$，即在其 $x$ 和 $y$ 位置上的项为 $k_{p} g_{n} n_{x}$ 和 $k_{p} g_{n} n_{y}$。\n- 主节点 $m_{1}$ 接收相反的贡献，并由 $N_{1}(\\xi)$ 加权，即其贡献项为 $-k_{p} g_{n} N_{1}(\\xi) n_{x}$ 和 $-k_{p} g_{n} N_{1}(\\xi) n_{y}$。\n- 主节点 $m_{2}$ 接收相反的贡献，并由 $N_{2}(\\xi)$ 加权，即其贡献项为 $-k_{p} g_{n} N_{2}(\\xi) n_{x}$ 和 $-k_{p} g_{n} N_{2}(\\xi) n_{y}$。\n\n将这些项按照指定的自由度排序 $[u_{s,x},\\, u_{s,y},\\, u_{m_{1},x},\\, u_{m_{1},y},\\, u_{m_{2},x},\\, u_{m_{2},y}]^{\\mathsf{T}}$ 汇总，得到\n$$\n\\boldsymbol{R}_{c} = k_{p}\\,g_{n}\\,\n\\begin{bmatrix}\nn_{x} \\\\\nn_{y} \\\\\n-\\,N_{1}(\\xi)\\,n_{x} \\\\\n-\\,N_{1}(\\xi)\\,n_{y} \\\\\n-\\,N_{2}(\\xi)\\,n_{x} \\\\\n-\\,N_{2}(\\xi)\\,n_{y}\n\\end{bmatrix}.\n$$\n为完整起见，可以将 $g_{n}$ 显式地用参考位置和位移表示为\n$$\ng_{n} = \\boldsymbol{n}^{\\mathsf{T}}\\left[\\left(\\boldsymbol{X}_{s} - N_{1}(\\xi)\\,\\boldsymbol{X}_{m_{1}} - N_{2}(\\xi)\\,\\boldsymbol{X}_{m_{2}}\\right) + \\left(\\boldsymbol{u}_{s} - N_{1}(\\xi)\\,\\boldsymbol{u}_{m_{1}} - N_{2}(\\xi)\\,\\boldsymbol{u}_{m_{2}}\\right)\\right].\n$$\n\n所涉及的自由度恰好是从节点和两个主面段端节点的平动分量，即按所述顺序排列的 $u_{s,x}$、$u_{s,y}$、$u_{m_{1},x}$、$u_{m_{1},y}$、$u_{m_{2},x}$ 和 $u_{m_{2},y}$。在所述假设下，没有其他自由度从此单个节点-分段接触对中获得贡献。", "answer": "$$\\boxed{k_{p}\\,g_{n}\\,\\begin{bmatrix}\nn_{x} \\\\\nn_{y} \\\\\n-\\,N_{1}(\\xi)\\,n_{x} \\\\\n-\\,N_{1}(\\xi)\\,n_{y} \\\\\n-\\,N_{2}(\\xi)\\,n_{x} \\\\\n-\\,N_{2}(\\xi)\\,n_{y}\n\\end{bmatrix}}$$", "id": "3510014"}, {"introduction": "一个正确实现的算法应该能够精确地再现基本的物理状态，这一原则通过“斑块测试”(patch tests)进行验证。这项练习要求您构建一个数值斑块测试[@problem_id:3509964]，以比较“节点-分段”(NTS)和“分段-分段”(STS)方法在非匹配网格上的性能。通过检验它们在刚体运动下保持零间隙和再现恒定牵引场的能力，您将对这些广泛使用的接触离散化方法的一致性和准确性有更深刻的理解。", "problem": "考虑两个弹性连续体之间沿直线段 $\\Gamma = [0,L] \\subset \\mathbb{R}$（位于 $y=0$ 处）的一个二维、小应变、无摩擦接触界面。令 $\\mathbf{n} = (0,1)$ 表示界面的单位法向量。我们考虑精确运动学，其中两个物体都经历一个均匀的刚体位移场 $\\mathbf{u}(\\mathbf{x}) = \\mathbf{u}_0$，其中 $\\mathbf{u}_0 \\in \\mathbb{R}^2$ 沿 $\\Gamma$ 为常数。两个潜在接触面的初始构型沿 $\\Gamma$ 重合，且没有初始间隙。\n\n作为基础使用的基本定义和定律：\n- 法向间隙定义为 $g_n = \\mathbf{n} \\cdot (\\mathbf{x}_s - \\mathbf{x}_m)$，其中 $\\mathbf{x}_s$ 和 $\\mathbf{x}_m$ 分别表示从面和主面上的当前位置。\n- 无摩擦法向接触牵引力为 $t_n$，在拉格朗日乘子约束中，$t_n$ 在弱形式下等于拉格朗日乘子 $\\lambda_n$，即 $t_n = \\lambda_n$。\n- 在两个物体以相同的 $\\mathbf{u}_0$ 进行均匀刚体运动的情况下，精确运动学意味着在 $\\Gamma$ 上处处有 $g_n = 0$。\n- 作用-反作用原理要求，在适当的（强或弱）意义上，跨越 $\\Gamma$ 传递的牵引力场是平衡的，并与拉格朗日乘子场一致。\n\n我们比较计算岩土力学中使用的两种标准接触离散化方法：\n1. 点对面（NTS）：基于将从节点投影到主段上，并通过从节点求积（节点集中）和主面上使用线性段及线性形函数来组装接触贡献的离散约束方法。\n2. 段对段（STS）砂浆法：基于通过求解沿 $\\Gamma$ 的一致一维质量矩阵问题，将拉格朗日乘子场投影到主迹空间上的弱约束方法。\n\n在接下来的计算 patch test 中，您将：\n- 通过为每种方法计算间隙一致性度量来验证刚体运动下的几何一致性。对于 NTS，在从节点处进行评估；对于 STS，在主段上的标准高斯点处进行评估。\n- 通过沿 $\\Gamma$ 指定一个恒定的拉格朗日乘子场 $\\lambda_n(x) = p_0$（恒定压缩），为每种方法重建相应的主面牵引力场，并测量其相对于精确恒定场 $t_n(x) = p_0$ 的 $L^2$ 误差，来验证牵引力平衡。NTS 的重建必须通过将从节点力通过最近点投影处的局部线性形函数分配给主节点，并按节点贡献长度进行归一化来完成；STS 的重建必须通过在主网格上求解一致一维质量矩阵系统以获得节点牵引力系数，然后在每个主段上进行线性插值来获得。\n\n精确的计算定义：\n- 令主网格节点为 $0 = x^m_0  x^m_1  \\dots  x^m_{N_m} = L$，定义 $N_m$ 个线性段。令从网格节点为 $0 = x^s_0  x^s_1  \\dots  x^s_{N_s} = L$，定义 $N_s$ 个线性段。所有坐标都位于 $\\Gamma$ 上。\n- 网格中一维节点 $x_i$ 的贡献长度定义为相邻段长度之和的一半（在端点处只有一个相邻段）。\n- 在恒定乘子 $p_0$ 下的 NTS 牵引力组装过程是：为每个从节点分配一个标量节点力 $f^s_i = p_0 \\, w^s_i$，其中 $w^s_i$ 是其贡献长度。然后，每个 $f^s_i$ 通过在 $x^s_i$ 到该主段的投影处求值的线性形函数，分配到包含 $x^s_i$ 的唯一主段的两个相邻主节点上，从而得到累积的主节点力向量。重建的主节点牵引力是每个节点上的累积主节点力除以其主贡献长度。然后通过相邻主节点值之间的线性插值获得每个主段上的连续牵引力场。\n- STS 牵引力重建是通过在主网格上组装并求解一致的一维质量矩阵系统 $M \\mathbf{c} = \\mathbf{b}$ 来获得的，其中 $M_{ab} = \\int_{\\Gamma} N_a N_b \\, \\mathrm{d}x$，$N_a$ 是主节点基函数，而 $b_a = \\int_{\\Gamma} N_a \\, p_0 \\, \\mathrm{d}x$。解 $\\mathbf{c}$ 是主节点牵引力值，通过在每个主段上进行线性插值来定义一个连续的牵引力场。\n- $L^2$ 牵引力误差计算为 $\\left( \\int_{\\Gamma} (t_n(x) - p_0)^2 \\, \\mathrm{d}x \\right)^{1/2}$，其中 $t_n(x)$ 是重建的连续主面牵引力。在每个主段上使用标准的两点高斯求积来近似该积分。\n- 每种方法的间隙一致性度量是在精确运动学 $\\mathbf{u} = \\mathbf{u}_0$（相同地应用于两个物体）下，在其评估点（NTS 为从节点，STS 为主段上的两点高斯点）上的最大法向绝对间隙。\n\n所有量均为无量纲。\n\n测试套件。对于以下每种情况，令 $L = 1$ 并按顺序计算四个标量：\n- $G_{\\mathrm{NTS}}$：NTS 评估点的最大绝对法向间隙。\n- $E_{\\mathrm{NTS}}$：NTS 的 $L^2$ 牵引力误差。\n- $G_{\\mathrm{STS}}$：STS 评估点的最大绝对法向间隙。\n- $E_{\\mathrm{STS}}$：STS 的 $L^2$ 牵引力误差。\n\n使用：\n1. 情况 1 (非匹配，非均匀):\n   - 主节点: $[0.0, 0.25, 0.55, 0.8, 1.0]$\n   - 从节点: $[0.0, 0.2, 0.6, 0.9, 1.0]$\n   - $p_0 = 3.0$\n   - $\\mathbf{u}_0 = (0.01,-0.02)$\n2. 情况 2 (极端不匹配，主网格粗糙):\n   - 主节点: $[0.0, 1.0]$\n   - 从节点: $[0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]$\n   - $p_0 = 1.5$\n   - $\\mathbf{u}_0 = (0.0, 0.0)$\n3. 情况 3 (匹配，均匀):\n   - 主节点: $[0.0, 0.25, 0.5, 0.75, 1.0]$\n   - 从节点: $[0.0, 0.25, 0.5, 0.75, 1.0]$\n   - $p_0 = 2.2$\n   - $\\mathbf{u}_0 = (0.003, 0.004)$\n4. 情况 4 (高度非均匀，不匹配):\n   - 主节点: $[0.0, 0.05, 0.9, 1.0]$\n   - 从节点: $[0.0, 0.4, 0.41, 0.8, 1.0]$\n   - $p_0 = 5.0$\n   - $\\mathbf{u}_0 = (-0.02, 0.01)$\n\n您的程序必须精确实现上述定义，并生成单行输出，其中包含一个由 16 个浮点数组成的逗号分隔列表，用方括号括起来，顺序如下：\n$\\left[ G_{\\mathrm{NTS}}^{(1)}, E_{\\mathrm{NTS}}^{(1)}, G_{\\mathrm{STS}}^{(1)}, E_{\\mathrm{STS}}^{(1)}, \\dots, G_{\\mathrm{NTS}}^{(4)}, E_{\\mathrm{NTS}}^{(4)}, G_{\\mathrm{STS}}^{(4)}, E_{\\mathrm{STS}}^{(4)} \\right]$，\n每个值以十进制表示法打印，最多保留十二位有效数字。", "solution": "我们从接触运动学和弱约束原理开始。在界面 $\\Gamma$ 上，法向间隙定义为 $g_n = \\mathbf{n}\\cdot(\\mathbf{x}_s - \\mathbf{x}_m)$，其中 $\\mathbf{n}$ 是主面上的外法线，$\\mathbf{x}_s$ 和 $\\mathbf{x}_m$ 分别表示从面和主面上对应点的当前位置。如果两个物体都经历相同的刚体运动 $\\mathbf{u}(\\mathbf{x}) = \\mathbf{u}_0$，并且初始构型沿 $\\Gamma$ 重合，则 $\\mathbf{x}_s = \\mathbf{X}_s + \\mathbf{u}_0$ 和 $\\mathbf{x}_m = \\mathbf{X}_m + \\mathbf{u}_0$，其中在 $\\Gamma$ 上 $\\mathbf{X}_s = \\mathbf{X}_m$，因此\n$$\ng_n = \\mathbf{n} \\cdot \\big( (\\mathbf{X}_s + \\mathbf{u}_0) - (\\mathbf{X}_m + \\mathbf{u}_0) \\big) = \\mathbf{n} \\cdot (\\mathbf{X}_s - \\mathbf{X}_m) = 0.\n$$\n因此，精确运动学得出处处 $g_n = 0$。\n\n在通过拉格朗日乘子施加的无摩擦接触公式中，法向接触的弱形式可以简化为在 $\\Gamma$ 上的一维迹形式：\n$$\n\\int_{\\Gamma} w \\, t_n \\, \\mathrm{d}x = \\int_{\\Gamma} w \\, \\lambda_n \\, \\mathrm{d}x\n$$\n对于所有容许的标量测试函数 $w$；因此在弱意义下 $t_n = \\lambda_n$。对于一个恒定的规定拉格朗日乘子场 $\\lambda_n(x) = p_0$，精确的牵引力场为 $t_n(x) = p_0$。\n\n我们现在描述用于计算 patch test 的离散实现以及它们如何与基本原理联系起来。\n\n点对面（NTS）离散化。NTS 方法通过将每个从节点投影到其在主面上的最近点，并使用从节点求积（节点集中）来近似界面积分，从而施加接触条件。对于具有节点 $\\{x^s_i\\}_{i=0}^{N_s}$ 的从网格，定义节点 $x^s_i$ 处的贡献长度为\n$$\nw^s_i = \\begin{cases}\n\\frac{1}{2}(x^s_{i+1} - x^s_i),  i=0,\\\\\n\\frac{1}{2}(x^s_{i+1} - x^s_{i-1}),  0  i  N_s,\\\\\n\\frac{1}{2}(x^s_{i} - x^s_{i-1}),  i=N_s,\n\\end{cases}\n$$\n主网格贡献长度 $\\{w^m_j\\}_{j=0}^{N_m}$ 的定义与此类似。在恒定乘子 $\\lambda_n = p_0$ 下，$x^s_i$ 处的集中从节点力为 $f^s_i = p_0 \\, w^s_i$。包含 $x^s_i$ 的唯一主段具有端点 $(x^m_j, x^m_{j+1})$，在投影位置处求值的局部线性主形函数给出的权重为 $N_1 = 1 - \\xi$，$N_2 = \\xi$，其中 $\\xi = (x^s_i - x^m_j)/(x^m_{j+1} - x^m_j) \\in [0,1]$。对主节点力的等值反向贡献为 $f^m_j \\mathrel{+}= f^s_i N_1$ 和 $f^m_{j+1} \\mathrel{+}= f^s_i N_2$。重建的主节点牵引力则定义为\n$$\nt^m_j = \\frac{f^m_j}{w^m_j}.\n$$\n通过在相邻节点值 $t^m_j$ 和 $t^m_{j+1}$ 之间进行线性插值，可以得到每个主段上的连续牵引力场，记为 $t^{\\mathrm{NTS}}(x)$。这种构造是对弱等式 $t_n = \\lambda_n$ 的一种近似，仅在从求积与主基函数特定对齐的情况下（例如，当主节点与从节点对齐时，或者当主基函数是全局线性时）才是精确的。通常情况下，非匹配网格会导致从节点求积用从剖分上的梯形法则来近似 $\\int N_j \\, \\mathrm{d}x$，这对于在从单元内部具有斜率不连续性的函数来说是不精确的；这会产生非零的差异。\n\n段对段（STS）砂浆法离散化。STS 方法通过一致质量矩阵将拉格朗日乘子场投影到主迹空间上。令 $N_j(x)$ 表示主节点基函数（线性形函数）。主质量矩阵 $M \\in \\mathbb{R}^{(N_m+1)\\times(N_m+1)}$ 的项为\n$$\nM_{ab} = \\int_{\\Gamma} N_a(x) N_b(x) \\, \\mathrm{d}x,\n$$\n右侧项为\n$$\nb_a = \\int_{\\Gamma} N_a(x) \\, \\lambda_n(x) \\, \\mathrm{d}x = p_0 \\int_{\\Gamma} N_a(x) \\, \\mathrm{d}x.\n$$\n求解 $M \\mathbf{c} = \\mathbf{b}$ 得到主节点牵引力系数 $\\mathbf{c} = (c_0, \\dots, c_{N_m})^\\top$ 和通过对 $\\{c_j\\}$ 进行线性插值得到的连续牵引力场 $t^{\\mathrm{STS}}(x)$。由于主基函数构成单位分解，并且我们进行了一致积分，一个恒定场 $p_0$ 会被精确地再现；也就是说，对所有 $j$ 都有 $c_j = p_0$，并且 $t^{\\mathrm{STS}}(x) \\equiv p_0$。\n\n间隙一致性评估。在对两个物体施加精确运动学 $\\mathbf{u} = \\mathbf{u}_0$ 且初始界面重合的情况下，每个从节点投影到主界面上的法向分离为零，因此 NTS 在从节点上的最大法向间隙为\n$$\nG_{\\mathrm{NTS}} = \\max_i |g_n(x^s_i)| = 0.\n$$\n对于 STS，在主段上的标准求积点处评估同样得到\n$$\nG_{\\mathrm{STS}} = \\max_{q} |g_n(x_q)| = 0.\n$$\n在数值上，这些值应在舍入误差范围内为零。\n\n牵引力平衡缺陷。对于任一重建的连续牵引力 $t(x)$，我们在主面上计算离散 $L^2$ 误差\n$$\nE = \\left( \\int_{\\Gamma} (t(x) - p_0)^2 \\, \\mathrm{d}x \\right)^{1/2},\n$$\n通过在每个主段上进行两点高斯求积来近似。对于 STS，$E_{\\mathrm{STS}}$ 在求解器容差范围内为零。对于 NTS，对于非匹配剖分，$E_{\\mathrm{NTS}}$通常不为零；它在特殊情况下消失，例如单个主段（基函数全局线性）或匹配网格（主节点扭折点与从求积节点重合），这反映了从节点梯形法则对线性函数的精确积分。\n\n程序的算法设计：\n1. 对每个测试用例，构造主、从节点数组、常数 $p_0$ 和位移 $\\mathbf{u}_0$。由于所有节点都位于 $y=0$ 上且两个物体共享相同的 $\\mathbf{u}_0$，法向间隙恒为零；计算 $G_{\\mathrm{NTS}}$ 作为从节点上的最大绝对间隙，$G_{\\mathrm{STS}}$ 作为每个主段上两点高斯点上的最大绝对间隙，以验证数值零点。\n2. 计算主、从节点的贡献长度，即相邻段长度之和的一半（端点使用单个相邻段的一半）。\n3. NTS 牵引力重建：\n   - 组装从节点力 $f^s_i = p_0 \\, w^s_i$。\n   - 对每个从节点，找到包含它的主段，计算局部坐标 $\\xi \\in [0,1]$，并通过 $(1-\\xi, \\xi)$ 的累加方式将 $f^s_i$ 分配给相邻的主节点。\n   - 将累积的主节点力除以主节点贡献长度，得到主节点牵引力值，并在段上进行线性插值以定义 $t^{\\mathrm{NTS}}(x)$。\n   - 在每个主段上计算 $E_{\\mathrm{NTS}}$ 的两点高斯求积近似值。\n4. STS 牵引力重建：\n   - 使用长度为 $h$ 的段上的局部贡献 $M^{(e)} = \\frac{h}{6} \\begin{bmatrix}2  1\\\\ 1  2\\end{bmatrix}$ 组装一致的一维质量矩阵 $M$。\n   - 使用局部向量 $b^{(e)} = p_0 \\frac{h}{2} \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$ 组装右侧项。\n   - 求解 $M \\mathbf{c} = \\mathbf{b}$ 得到主节点牵引力值，并在段上进行线性插值以定义 $t^{\\mathrm{STS}}(x)$。\n   - 计算 $E_{\\mathrm{STS}}$ 的两点高斯求积近似值。\n5. 对每个测试用例，聚合四个标量 $[G_{\\mathrm{NTS}}, E_{\\mathrm{NTS}}, G_{\\mathrm{STS}}, E_{\\mathrm{STS}}]$，并按规定的单行格式打印所有结果。\n\n给定测试套件的预期定性结果：\n- 在情况 1 和情况 4（非匹配网格）中，由于精确运动学，$G_{\\mathrm{NTS}} \\approx 0$ 和 $G_{\\mathrm{STS}} \\approx 0$，而由于位于从单元内部的主节点扭折点处的求积不一致性，$E_{\\mathrm{NTS}}$ 严格为正；$E_{\\mathrm{STS}}$ 在数值上为零。\n- 在情况 2（单个主段）中，两种方法都产生 $E \\approx 0$，因为主基函数是全局线性的，从节点梯形法则能精确积分它们。\n- 在情况 3（匹配网格）中，两种方法都产生 $E \\approx 0$，因为从求积节点与主扭折点重合，使得梯形法则对于分段线性基函数是精确的。\n\n这表明，从运动学定义和弱约束出发，当网格不匹配时，NTS 方法可能违反精确的牵引力平衡 $t_n = \\lambda_n$，而 STS 砂浆法则在弱意义下精确地再现了恒定牵引力场；两者都在刚体运动下保持 $g_n = 0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef tributary_lengths(nodes):\n    nodes = np.asarray(nodes, dtype=float)\n    n = len(nodes)\n    w = np.zeros(n, dtype=float)\n    if n == 1:\n        w[0] = 0.0\n        return w\n    # End nodes\n    w[0] = 0.5 * (nodes[1] - nodes[0])\n    w[-1] = 0.5 * (nodes[-1] - nodes[-2])\n    # Interior nodes\n    for i in range(1, n - 1):\n        w[i] = 0.5 * (nodes[i+1] - nodes[i-1])\n    return w\n\ndef find_master_segment(x, xm):\n    # Returns index j such that x in [xm[j], xm[j+1]]\n    # Clamp x to [xm[0], xm[-1]]\n    if x = xm[0]:\n        return 0\n    if x = xm[-1]:\n        return len(xm) - 2\n    j = np.searchsorted(xm, x, side='right') - 1\n    if j == len(xm) - 1:\n        j = len(xm) - 2\n    if j  0:\n        j = 0\n    return j\n\ndef gauss_points_segment(xa, xb):\n    # Two-point Gauss on [xa, xb]\n    h = xb - xa\n    # Reference points +-1/sqrt(3)\n    gp_ref = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n    # Map to physical\n    xg = 0.5*(xb + xa) + 0.5*h*gp_ref\n    wg = np.array([1.0, 1.0]) * 0.5 * h  # weights include Jacobian\n    # Also return shape functions at gauss points in reference [-1,1] space mapped to xi in [0,1]\n    xi = 0.5*(gp_ref + 1.0)  # 0..1\n    N = np.vstack([1.0 - xi, xi]).T  # shape functions N1,N2 at gauss points\n    return xg, wg, N\n\ndef nts_reconstruct_master_traction(xm, xs, p0):\n    xm = np.asarray(xm, dtype=float)\n    xs = np.asarray(xs, dtype=float)\n    wm = tributary_lengths(xm)\n    ws = tributary_lengths(xs)\n    # Slave nodal forces\n    fs = p0 * ws\n    # Accumulate master nodal forces\n    fm = np.zeros_like(xm)\n    for i, x in enumerate(xs):\n        # Distribute fs[i] to the containing master segment nodes with linear weights\n        j = find_master_segment(x, xm)\n        xa = xm[j]\n        xb = xm[j+1]\n        h = xb - xa\n        if h = 0:\n            # Degenerate; skip\n            continue\n        xi = (x - xa) / h  # in [0,1] ideally\n        N1 = 1.0 - xi\n        N2 = xi\n        fm[j] += fs[i] * N1\n        fm[j+1] += fs[i] * N2\n    # Reconstructed nodal traction on master\n    # Avoid division by zero: if wm[j]==0, set traction to 0 (no measure)\n    tm = np.zeros_like(xm)\n    for j in range(len(xm)):\n        if wm[j]  0:\n            tm[j] = fm[j] / wm[j]\n        else:\n            tm[j] = 0.0\n    return tm  # nodal values at master nodes\n\ndef sts_reconstruct_master_traction(xm, p0):\n    xm = np.asarray(xm, dtype=float)\n    nm = len(xm)\n    # Assemble mass matrix M and RHS b\n    M = np.zeros((nm, nm), dtype=float)\n    b = np.zeros(nm, dtype=float)\n    for j in range(nm - 1):\n        xa = xm[j]\n        xb = xm[j+1]\n        h = xb - xa\n        # Local mass matrix for linear 1D element\n        Mloc = (h / 6.0) * np.array([[2.0, 1.0],\n                                     [1.0, 2.0]], dtype=float)\n        # Local RHS for constant p0: integral of N * p0 over element\n        bloc = (h / 2.0) * np.array([1.0, 1.0], dtype=float) * p0\n        # Assembly\n        M[j:j+2, j:j+2] += Mloc\n        b[j:j+2] += bloc\n    # Solve M c = b\n    # Use a robust solver; M is symmetric positive definite\n    c = np.linalg.solve(M, b)\n    return c  # nodal values at master nodes\n\ndef traction_L2_error(xm, tnodal, p0):\n    # Compute L2 error norm between linear interpolated tnodal and constant p0\n    err2 = 0.0\n    for j in range(len(xm) - 1):\n        xa = xm[j]\n        xb = xm[j+1]\n        xg, wg, N = gauss_points_segment(xa, xb)\n        # Interpolate traction at gauss points\n        tj = np.array([tnodal[j], tnodal[j+1]])\n        tg = N @ tj\n        diff = tg - p0\n        err2 += np.sum((diff**2) * wg)\n    return np.sqrt(err2)\n\ndef nts_gap_max(xs, xm, u0):\n    # Under rigid-body motion with identical u0, the gap is zero.\n    # Evaluate at slave nodes: n = (0,1), both y=0 always -> gap = 0\n    # Compute explicitly as zeros to reflect evaluation\n    # We keep code that could be extended but for this straight interface, it's zero.\n    gaps = np.zeros(len(xs), dtype=float)\n    return float(np.max(np.abs(gaps)))\n\ndef sts_gap_max(xm, u0):\n    # Evaluate at two-point Gauss points on each master segment; also zero\n    max_gap = 0.0\n    for j in range(len(xm) - 1):\n        xa = xm[j]\n        xb = xm[j+1]\n        xg, wg, N = gauss_points_segment(xa, xb)\n        gaps = np.zeros_like(xg)  # all zero for this exact kinematics\n        max_gap = max(max_gap, float(np.max(np.abs(gaps))))\n    return float(max_gap)\n\ndef format_float(x):\n    # Format with up to 12 significant digits to satisfy problem statement\n    return f\"{x:.12g}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"xm\": [0.0, 0.25, 0.55, 0.8, 1.0],\n            \"xs\": [0.0, 0.2, 0.6, 0.9, 1.0],\n            \"p0\": 3.0,\n            \"u0\": (0.01, -0.02)\n        },\n        # Case 2\n        {\n            \"xm\": [0.0, 1.0],\n            \"xs\": [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0],\n            \"p0\": 1.5,\n            \"u0\": (0.0, 0.0)\n        },\n        # Case 3\n        {\n            \"xm\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"xs\": [0.0, 0.25, 0.5, 0.75, 1.0],\n            \"p0\": 2.2,\n            \"u0\": (0.003, 0.004)\n        },\n        # Case 4\n        {\n            \"xm\": [0.0, 0.05, 0.9, 1.0],\n            \"xs\": [0.0, 0.4, 0.41, 0.8, 1.0],\n            \"p0\": 5.0,\n            \"u0\": (-0.02, 0.01)\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        xm = np.array(case[\"xm\"], dtype=float)\n        xs = np.array(case[\"xs\"], dtype=float)\n        p0 = float(case[\"p0\"])\n        u0 = tuple(case[\"u0\"])\n\n        # Gap measures\n        G_nts = nts_gap_max(xs, xm, u0)\n        G_sts = sts_gap_max(xm, u0)\n\n        # NTS traction reconstruction and error\n        tnodal_nts = nts_reconstruct_master_traction(xm, xs, p0)\n        E_nts = traction_L2_error(xm, tnodal_nts, p0)\n\n        # STS traction reconstruction and error\n        tnodal_sts = sts_reconstruct_master_traction(xm, p0)\n        E_sts = traction_L2_error(xm, tnodal_sts, p0)\n\n        # Append in the prescribed order: G_NTS, E_NTS, G_STS, E_STS\n        results.extend([G_nts, E_nts, G_sts, E_sts])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(format_float(r) for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3509964"}]}