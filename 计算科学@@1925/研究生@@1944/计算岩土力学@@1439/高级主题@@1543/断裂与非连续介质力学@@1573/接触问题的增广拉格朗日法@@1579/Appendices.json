{"hands_on_practices": [{"introduction": "在接触力学中，罚函数法是一种直观的约束处理方法，但它需要一个非常大的罚参数 $\\rho$ 才能精确地施加约束，这往往会导致数值病态。本练习通过一个简单的一维接触模型，旨在让您亲手实践并对比罚函数法与增广拉格朗日法。通过这个对比，您将清晰地看到增广拉格朗日法如何通过迭代更新拉格朗日乘子，在避免使用巨大罚参数的同时，有效减少接触区域的穿透，从而揭示其在计算鲁棒性方面的核心优势。[@problem_id:3501911]", "problem": "在计算岩土力学中，考虑一个一维无摩擦单边接触模型。一个具有标量位移 $u$ 的单节点受到位于原点的刚性障碍物的约束，非侵入条件要求 $u \\le 0$。该节点连接到一个刚度为 $k$ 的线性弹性弹簧，并受到一个沿正方向（朝向障碍物）作用的压缩外荷载 $P$。平衡状态必须满足力平衡和接触互补条件，这些条件源于基本原理：弹簧力的线性弹性、施加约束的接触反力，以及单边接触的 Karush–Kuhn–Tucker (KKT) 条件。\n\n基本设定如下：\n- 线性弹簧行为：内力为 $k u$。\n- 外荷载：广义力为 $P$（正值将节点推向障碍物）。\n- 单边约束：可行集由 $u \\le 0$ 定义。\n- 接触反作用力 $N \\ge 0$ 用于抵抗侵入，并遵循互补条件 $N u = 0$。\n\n使用增广拉格朗日方法求解该约束静态问题。不等式约束写作 $c(u) \\le 0$，其中 $c(u) = u$。引入与该约束相关的拉格朗日乘子 $\\lambda \\ge 0$，并通过对约束违反的正值部分施加二次罚项来进行增广。增广泛函是弹性势能、外力功、拉格朗日项以及关于约束正值部分的二次项之和，由于在约束边界处的非光滑性，必须分段处理。增广拉格朗日算法交替执行以下步骤：\n- 主步：对于固定的乘子 $\\lambda$，在分段光滑的增广泛函上对 $u$ 强制执行驻定性条件。\n- 投影乘子更新：对不等式约束 $c(u) \\le 0$ 进行适当的投影更新。\n\n您的任务是：\n1. 为此单自由度接触问题实现增广拉格朗日迭代。在每次迭代中，根据由 $c(u)$ 的正值部分引起的分段定义，精确求解关于 $u$ 的标量主驻定性条件，然后使用对 $c(u) \\le 0$ 合适的投影方法更新乘子。使用一个能够通过检查微小侵入量和力平衡一致性来检测接触条件是否满足的停止准则。\n2. 为同一问题实现纯罚函数法，通过最小化由弹性势能、外力功和对约束违反的正值部分的二次罚项组成的能量，不含任何乘子项或更新。\n3. 对两种方法，报告定义为 $\\max(u,0)$ 的侵入量，单位为米，四舍五入到六位小数。\n4. 使用以下具有物理合理性的参数测试套件（除非明确说明，所有常数均为严格正值）。刚度 $k$ 的单位是牛顿/米 ($\\mathrm{N/m}$)，荷载 $P$ 的单位是牛顿 ($\\mathrm{N}$)，罚参数 $\\rho$ 的单位是牛顿/米 ($\\mathrm{N/m}$)，初始乘子 $\\lambda_0$ 的单位是牛顿 ($\\mathrm{N}$)。对于每个测试用例，还需为增广拉格朗日方法指定最大迭代次数 $n_{\\max}$ 和容差 $t$：\n   - 测试用例 1：$k = 5 \\times 10^{6}\\ \\mathrm{N/m}$, $P = 1 \\times 10^{4}\\ \\mathrm{N}$, $\\rho = 5 \\times 10^{6}\\ \\mathrm{N/m}$, $\\lambda_0 = 0\\ \\mathrm{N}$, $n_{\\max} = 20$, $t = 1 \\times 10^{-12}$。\n   - 测试用例 2：$k = 5 \\times 10^{6}\\ \\mathrm{N/m}$, $P = 1 \\times 10^{4}\\ \\mathrm{N}$, $\\rho = 2 \\times 10^{4}\\ \\mathrm{N/m}$, $\\lambda_0 = 0\\ \\mathrm{N}$, $n_{\\max} = 300$, $t = 1 \\times 10^{-12}$。\n   - 测试用例 3：$k = 2 \\times 10^{6}\\ \\mathrm{N/m}$, $P = 8 \\times 10^{3}\\ \\mathrm{N}$, $\\rho = 2 \\times 10^{5}\\ \\mathrm{N/m}$, $\\lambda_0 = 1.2 \\times 10^{4}\\ \\mathrm{N}$, $n_{\\max} = 100$, $t = 1 \\times 10^{-12}$。\n   - 测试用例 4：$k = 1 \\times 10^{6}\\ \\mathrm{N/m}$, $P = 0\\ \\mathrm{N}$, $\\rho = 1 \\times 10^{5}\\ \\mathrm{N/m}$, $\\lambda_0 = 0\\ \\mathrm{N}$, $n_{\\max} = 10$, $t = 1 \\times 10^{-12}$。\n\n对于每个测试用例，您的程序必须计算：\n- 使用增广拉格朗日方法计算的侵入量，单位为米，四舍五入到六位小数。\n- 使用纯罚函数法计算的侵入量，单位为米，四舍五入到六位小数。\n- 增广拉格朗日方法实际执行的迭代次数（一个整数）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{aug\\_pen}_{1}, \\text{pen\\_only}_{1}, \\text{iters}_{1}, \\text{aug\\_pen}_{2}, \\text{pen\\_only}_{2}, \\text{iters}_{2}, \\text{aug\\_pen}_{3}, \\text{pen\\_only}_{3}, \\text{iters}_{3}, \\text{aug\\_pen}_{4}, \\text{pen\\_only}_{4}, \\text{iters}_{4}]$，其中每个 $\\text{aug\\_pen}_{i}$ 和 $\\text{pen\\_only}_{i}$ 是一个以米为单位、四舍五入到六位小数的浮点数，每个 $\\text{iters}_{i}$ 是一个整数。", "solution": "其基本要素是基本的接触条件和一致的增广拉格朗日公式。在一维情况下，线性弹性理论得出内力为 $k u$。一个沿正方向作用的压缩外荷载 $P$ 将节点推向障碍物。刚性障碍物强制实现非侵入条件 $u \\le 0$，接触反作用力 $N \\ge 0$ 满足互补条件 $N u = 0$ 并确保静态力平衡。这可以由 Karush–Kuhn–Tucker (KKT) 系统表示：\n$$\nu \\le 0,\\quad \\lambda \\ge 0,\\quad \\lambda u = 0,\\quad k u - P + \\lambda = 0\n$$\n其中 $\\lambda$ 是代表接触反作用力的拉格朗日乘子。\n\n为了缓解纯罚函数法相关的病态问题，增广拉格朗日方法引入了一个拉格朗日乘子和对不等式约束正值部分的二次罚项。对于不等式 $c(u) \\le 0$，其中 $c(u) = u$，定义增广泛函为\n$$\n\\mathcal{L}_\\rho(u,\\lambda) = \\frac{1}{2} k u^2 - P u + \\lambda\\, c(u) + \\frac{\\rho}{2} \\big(c(u)\\big)_+^2,\n$$\n其中 $(x)_+ = \\max(x,0)$ 且 $\\rho > 0$ 是罚参数。通过将关于 $u$ 的导数设为零，并处理 $(c(u))_+$ 的分段性质，可以得到主驻定性条件：\n$$\n\\frac{\\partial \\mathcal{L}_\\rho}{\\partial u} = k u - P + \\lambda + \\rho (u)_+.\n$$\n这给出了一个分段线性方程：\n- 如果 $u > 0$，则 $(u)_+ = u$ 并且\n$$\nk u - P + \\lambda + \\rho u = 0 \\quad \\Rightarrow \\quad (k+\\rho) u = P - \\lambda \\quad \\Rightarrow \\quad u = \\frac{P - \\lambda}{k+\\rho}.\n$$\n- 如果 $u \\le 0$，则 $(u)_+ = 0$ 并且\n$$\nk u - P + \\lambda = 0 \\quad \\Rightarrow \\quad u = \\frac{P - \\lambda}{k}.\n$$\n一致性条件是 $u > 0$ 当且仅当 $\\lambda < P$，以及 $u \\le 0$ 当且仅当 $\\lambda \\ge P$。因此，标量主更新的精确形式为\n$$\nu^{k+1} =\n\\begin{cases}\n\\dfrac{P - \\lambda^k}{k+\\rho},  & \\text{如果 } \\lambda^k < P, \\\\\n\\dfrac{P - \\lambda^k}{k},  & \\text{如果 } \\lambda^k \\ge P,\n\\end{cases}\n$$\n而不等式 $c(u) \\le 0$ 的投影乘子更新为\n$$\n\\lambda^{k+1} = \\max\\big(0,\\, \\lambda^k + \\rho\\, c(u^{k+1})\\big) = \\max\\big(0,\\, \\lambda^k + \\rho\\, u^{k+1}\\big).\n$$\n这两个步骤定义了增广拉格朗日迭代。\n\n通过分析乘子的递归关系，可以得出收敛性和侵入缓解的结论。当 $\\lambda^k < P$ 时，可得\n$$\n\\lambda^{k+1} = \\lambda^k + \\rho \\frac{P - \\lambda^k}{k+\\rho} = \\left(1 - \\frac{\\rho}{k+\\rho}\\right) \\lambda^k + \\frac{\\rho}{k+\\rho} P = \\frac{k}{k+\\rho}\\, \\lambda^k + \\frac{\\rho}{k+\\rho}\\, P.\n$$\n这是一个向 $P$ 收缩的压缩映射，压缩因子为 $\\frac{k}{k+\\rho} \\in (0,1)$。因此 $u^{k+1} = \\frac{P - \\lambda^k}{k+\\rho}$ 呈几何级数递减，并且随着 $\\lambda^k \\to P$，侵入量 $\\max(u^{k+1},0)$ 趋于零。当 $\\lambda^k \\ge P$ 时，有\n$$\n\\lambda^{k+1} = \\lambda^k + \\rho \\frac{P - \\lambda^k}{k} = \\left(1 - \\frac{\\rho}{k}\\right)\\lambda^k + \\frac{\\rho}{k} P,\n$$\n只要 $\\rho \\in (0, 2k)$，它也向 $P$ 收缩。在实践中，选择与 $k$ 相当的 $\\rho$ 可以在不需要过大 $\\rho$ 的情况下快速减少侵入。这展示了核心的缓解机制：乘子更新提供了必要的反作用力，而增广项则对主求解过程进行正则化。\n\n对于纯罚函数法，乘子被省略，能量为\n$$\n\\Pi_\\rho(u) = \\frac{1}{2} k u^2 - P u + \\frac{\\rho}{2} (u)_+^2,\n$$\n其驻定性条件为\n$$\nk u - P + \\rho (u)_+ = 0.\n$$\n对于 $P \\ge 0$，解为 $u = \\frac{P}{k+\\rho} > 0$，这导致侵入量严格为正，除非 $\\rho \\to \\infty$。因此，与增广拉格朗日方法不同，纯罚函数法需要非常大的 $\\rho$ 才能有效抑制侵入，这在数值上是不理想的。\n\n单自由度的算法设计：\n- 输入 $(k,P,\\rho,\\lambda_0,n_{\\max},t)$。\n- 初始化 $\\lambda \\leftarrow \\lambda_0$。\n- 对于从 $1$ 到 $n_{\\max}$ 的 $n$：\n  - 如果 $\\lambda < P$，则设 $u \\leftarrow \\frac{P - \\lambda}{k+\\rho}$；否则设 $u \\leftarrow \\frac{P - \\lambda}{k}$。\n  - 更新 $\\lambda \\leftarrow \\max(0, \\lambda + \\rho u)$。\n  - 定义侵入量 $p \\leftarrow \\max(u,0)$。\n  - 定义残差 $r \\leftarrow k u - P + \\lambda$。\n  - 如果 $p \\le t$ 且 $|r| \\le t$，则停止。\n- 返回 $p$ 和执行的迭代次数。\n- 对于仅罚函数法，求解 $u = \\frac{P}{k+\\rho}$ (对于 $P \\ge 0$)，并返回 $p = \\max(u,0)$。\n\n单位和输出：\n- 报告以米为单位的侵入量（四舍五入到六位小数）。\n- 报告迭代次数（整数）。\n- 应用上述测试套件参数，并按指定顺序打印单行逗号分隔列表。\n\n该构造严谨地证明了增广项加乘子更新通过将乘子收敛到接触反力 $P$ 并将间隙驱动到零，从而在不需要过大 $\\rho$ 的情况下缓解了侵入，而当 $\\rho$ 适中时，纯罚函数法会留下与 $\\frac{P}{k+\\rho}$ 成比例的残余侵入。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef augmented_contact_1d(k, P, rho, lambda0, max_iter, tol):\n    \"\"\"\n    Augmented Lagrangian for 1D unilateral contact with constraint u = 0.\n    Returns penetration magnitude max(u, 0) and iterations performed.\n    \"\"\"\n    lam = float(lambda0)\n    u = 0.0\n    iters = 0\n    for it in range(1, max_iter + 1):\n        # Primal update based on piecewise stationarity\n        if lam  P:\n            u = (P - lam) / (k + rho)\n        else:\n            u = (P - lam) / k\n        \n        # Store previous lambda to check for convergence\n        lam_old = lam\n        \n        # Multiplier update with projection for c(u) = u = 0\n        lam = max(0.0, lam + rho * u)\n        \n        # Penetration magnitude and residual for KKT conditions\n        pen = max(u, 0.0)\n        # Residual of the equilibrium equation: k*u - P + lambda = 0\n        residual = k * u - P + lam\n        iters = it\n        \n        # Stopping criterion: small penetration and force balance is met.\n        # An alternative check on lambda change can also be used.\n        if pen = tol and abs(residual) = tol:\n            break\n            \n    return pen, iters\n\ndef penalty_only_1d(k, P, rho):\n    \"\"\"\n    Pure penalty solution for 1D unilateral contact with constraint u = 0.\n    For P >= 0, the minimizer is u = P/(k+rho) > 0; report penetration magnitude.\n    \"\"\"\n    if P  0: # Body is pulled away from the wall\n        return 0.0\n    # For compressive load P >= 0, closed-form solution\n    u = P / (k + rho)\n    return max(u, 0.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (k [N/m], P [N], rho [N/m], lambda0 [N], max_iter, tol)\n    test_cases = [\n        (5e6, 1e4, 5e6, 0.0, 20, 1e-12),       # Test case 1\n        (5e6, 1e4, 2e4, 0.0, 300, 1e-12),      # Test case 2\n        (2e6, 8e3, 2e5, 1.2e4, 100, 1e-12),    # Test case 3\n        (1e6, 0.0, 1e5, 0.0, 10, 1e-12),       # Test case 4\n    ]\n\n    results = []\n    for k, P, rho, lambda0, max_iter, tol in test_cases:\n        aug_pen, iters = augmented_contact_1d(k, P, rho, lambda0, max_iter, tol)\n        pen_only = penalty_only_1d(k, P, rho)\n        # Round penetrations to six decimals as required; iterations are integers\n        results.append(f\"{aug_pen:.6f}\")\n        results.append(f\"{pen_only:.6f}\")\n        results.append(str(iters))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3501911"}, {"introduction": "真实的岩土力学接触问题不仅涉及法向的不可穿透约束，还包含更为复杂的切向摩擦行为。经典的库仑摩擦定律由于其非光滑的特性，给基于牛顿法的求解器带来了数值挑战。本练习将指导您探索一种关键的计算技巧：使用光滑函数，如 $p$-范数或Huber型函数，来近似非光滑的摩擦锥 [@problem_id:3501885]。您将通过量化光滑化参数 $\\epsilon$ 对粘滑判断和接触力计算精度的影响，深入理解在保证算法收敛性和维持物理真实性之间进行权衡的艺术。", "problem": "在计算地质力学中，考虑一个局部单接触点，其具有一个二维（$2$D）切向牵引力矢量 $\\mathbf{t}^{\\mathrm{tr}} = (t_1, t_2)$（单位为帕斯卡 Pa）、一个正法向压力 $p_n$（单位为帕斯卡 Pa）以及一个无量纲的摩擦系数 $\\mu$。经典的 Coulomb 摩擦锥定义为集合 $\\mathcal{C} = \\{ \\mathbf{t} \\in \\mathbb{R}^2 \\, | \\, \\| \\mathbf{t} \\|_2 \\le \\mu p_n \\}$，其中 $\\| \\cdot \\|_2$ 表示欧几里得范数。当 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n$ 时，接触状态为黏着（stick），而当 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2  \\mu p_n$ 时，则发生滑移（slip）。在增广拉格朗日框架中，将 $\\mathbf{t}^{\\mathrm{tr}}$ 投影到 $\\mathcal{C}$ 上是指导拉格朗日乘子和罚约束更新的一个关键子步骤。\n\n为了研究在增广拉格朗日接触更新中使用的摩擦锥的光滑近似，定义了两个由光滑参数 $\\epsilon  0$ 参数化的光滑代理范数族 $\\phi_{\\epsilon}(\\mathbf{t})$：\n\n- 一个 $p$-范数代理，其中 $\\epsilon$ 控制指数 $p$：\n$$\n\\phi_{\\epsilon}^{\\mathrm{pnorm}}(\\mathbf{t}) = \\left( |t_1|^{p} + |t_2|^{p} \\right)^{1/p}, \\quad \\text{其中 } p = 2 + \\epsilon.\n$$\n\n- 一个针对欧几里得范数的 Huber 型代理，其阈值为 $\\epsilon$：\n$$\n\\phi_{\\epsilon}^{\\mathrm{Huber}}(\\mathbf{t}) =\n\\begin{cases}\n\\dfrac{r^2}{2\\epsilon},   \\text{若 } r \\le \\epsilon, \\\\\nr - \\dfrac{\\epsilon}{2},   \\text{若 } r  \\epsilon,\n\\end{cases}\n\\quad \\text{其中 } r = \\sqrt{t_1^2 + t_2^2}.\n$$\n\n使用代理 $\\phi_{\\epsilon}$，通过条件 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n$ 定义黏着，通过 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})  \\mu p_n$ 定义滑移，从而构建一个基于光滑化的黏滑分类器。相应地，定义在增广拉格朗日更新中使用的基于光滑化的牵引力大小投影如下：如果 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n$，则将投影后的大小设置为试探大小，即 $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2$；否则，沿当前方向收缩大小以满足光滑边界，即 $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\cdot \\dfrac{\\mu p_n}{\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})}$。对于精确的 Coulomb 锥投影，投影后的大小为 $\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min\\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2, \\mu p_n \\right)$。\n\n你的任务是：\n\n$1.$ 从 Coulomb 摩擦定义和通过增广拉格朗日方法实施约束的思想出发，为精确锥和上述定义的光滑代理，用纯数学术语表述黏滑判定准则和投影方案。\n\n$2.$ 实现一个程序，对于下述每个测试用例，计算：\n- 通过比较 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2$ 与 $\\mu p_n$ 得出的精确黏滑分类，\n- 通过比较 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})$ 与 $\\mu p_n$ 得出的基于光滑化的黏滑分类，\n- 归一化牵引力大小误差\n$$\nE = \\dfrac{\\left| \\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 - \\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 \\right|}{\\mu p_n},\n$$\n该误差是无量纲的，\n- 错分指示符\n$$\nI =\n\\begin{cases}\n1,   \\text{如果精确分类与基于光滑化的黏滑分类不同}, \\\\\n0,   \\text{否则}.\n\\end{cases}\n$$\n\n$3.$ 通过报告每个用例的 $E$ 和 $I$ 来量化光滑参数 $\\epsilon$ 与黏滑转换精度之间的权衡。所有应力和牵引力必须以帕斯卡（Pa）为单位处理。输出 $E$ 和 $I$ 是无量纲的。\n\n使用以下测试套件。对于所有用例，取 $\\mu = 0.6$ 和 $p_n = 1.0 \\times 10^{6}$ Pa。每个用例指定了代理类型、光滑参数 $\\epsilon$ 以及 $\\mathbf{t}^{\\mathrm{tr}}$ 的分量（单位：帕斯卡，Pa）：\n\n$1.$ $\\left( \\text{pnorm}, \\epsilon = 0.0, t_1 = 0.30 \\times 10^{6}, t_2 = 0.20 \\times 10^{6} \\right)$\n\n$2.$ $\\left( \\text{pnorm}, \\epsilon = 1.0, t_1 = 0.45 \\times 10^{6}, t_2 = 0.45 \\times 10^{6} \\right)$\n\n$3.$ $\\left( \\text{pnorm}, \\epsilon = 0.5, t_1 = 0.80 \\times 10^{6}, t_2 = 0.40 \\times 10^{6} \\right)$\n\n$4.$ $\\left( \\text{pnorm}, \\epsilon = 1.0, t_1 = 0.60 \\times 10^{6}, t_2 = 0.00 \\times 10^{6} \\right)$\n\n$5.$ $\\left( \\text{Huber}, \\epsilon = 1.0 \\times 10^{5}, t_1 = 0.59 \\times 10^{6}, t_2 = 0.05 \\times 10^{6} \\right)$\n\n$6.$ $\\left( \\text{Huber}, \\epsilon = 2.0 \\times 10^{5}, t_1 = 0.45 \\times 10^{6}, t_2 = 0.45 \\times 10^{6} \\right)$\n\n$7.$ $\\left( \\text{Huber}, \\epsilon = 1.0 \\times 10^{3}, t_1 = 0.80 \\times 10^{6}, t_2 = 0.40 \\times 10^{6} \\right)$\n\n$8.$ $\\left( \\text{Huber}, \\epsilon = 1.0 \\times 10^{5}, t_1 = 0.00 \\times 10^{6}, t_2 = 0.00 \\times 10^{6} \\right)$\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[E_1, I_1, E_2, I_2, \\dots, E_8, I_8]$，其中 $E_k$ 是测试用例 $k$ 的归一化牵引力大小误差，$I_k$ 是测试用例 $k$ 的错分指示符。", "solution": "其基本依据是经典的 Coulomb 摩擦定律和用于约束优化的增广拉格朗日方法。一个接触点上的 Coulomb 摩擦指出，切向牵引力矢量 $\\mathbf{t} \\in \\mathbb{R}^2$ 必须位于由 $\\| \\mathbf{t} \\|_2 \\le \\mu p_n$ 定义的摩擦锥内，其中 $\\mu  0$ 是摩擦系数，$p_n  0$ 是法向压力。当无约束的试探牵引力 $\\mathbf{t}^{\\mathrm{tr}}$ 已满足边界条件 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n$ 时，发生黏着；而当 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2  \\mu p_n$ 时，发生滑移，此时牵引力必须被投影回锥的边界上。\n\n增广拉格朗日方法通过向拉格朗日量中增加罚项来施加约束，并通过包含向可行集投影的子步骤来迭代更新原始变量和对偶变量。考虑一个局部摩擦子问题，其中对于已知的 $\\mathbf{t}^{\\mathrm{tr}}$，执行向可行摩擦锥的投影。精确投影保留了方向，并将大小限制在阈值 $\\mu p_n$ 以内。这导出了精确的投影后大小\n$$\n\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min \\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2, \\mu p_n \\right).\n$$\n该定义源于在欧几里得范数下与 Coulomb 约束一致的牵引力最小变化，这在切向牵引力空间中即为经典的径向返回映射。因此，黏滑判定准则为\n$$\n\\text{若 } \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n \\text{ 则黏着}, \\quad \\text{否则滑移}.\n$$\n\n为了在增广拉格朗日迭代中保证可微性和数值鲁棒性，通过 $\\phi_{\\epsilon}(\\mathbf{t}) \\approx \\| \\mathbf{t} \\|_2$ 引入了摩擦锥边界的光滑代理。考虑了两种特定的代理：\n\n$1.$ $p$-范数代理\n$$\n\\phi_{\\epsilon}^{\\mathrm{pnorm}}(\\mathbf{t}) = \\left( |t_1|^{p} + |t_2|^{p} \\right)^{1/p}, \\quad p = 2 + \\epsilon,\n$$\n其中参数 $\\epsilon$ 控制 $p$ 与 $2$ 的偏差。当 $\\epsilon \\to 0$ 时，$p \\to 2$，且 $\\phi_{\\epsilon}^{\\mathrm{pnorm}}$ 收敛于欧几里得范数。对于 $\\epsilon  0$，$p  2$ 产生的范数会减小较小分量的贡献，这倾向于低估混合分量矢量的欧几里得范数，但在坐标轴上保持精确。\n\n$2.$ Huber 型代理\n$$\n\\phi_{\\epsilon}^{\\mathrm{Huber}}(\\mathbf{t}) =\n\\begin{cases}\n\\dfrac{r^2}{2\\epsilon},   \\text{若 } r \\le \\epsilon, \\\\\nr - \\dfrac{\\epsilon}{2},   \\text{若 } r  \\epsilon,\n\\end{cases}\n\\quad r = \\sqrt{t_1^2 + t_2^2},\n$$\n它在 $\\mathbf{t} = \\mathbf{0}$ 附近是光滑的，并且当 $r \\gg \\epsilon$ 时接近欧几里得范数。当 $r$ 相对于 $\\epsilon$ 较小时，此代理会低估范数，这可能在分类中扩大表观的黏着区域。\n\n有了代理之后，基于光滑化的黏滑判定被表述为\n$$\n\\text{若 } \\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n \\text{ 则黏着}, \\quad \\text{否则滑移}.\n$$\n该准则通过光滑代理区域修改了边界，并在需要可微约束违反度量的增广拉格朗日更新中充当代理。\n\n对于与增广拉格朗日强制实施一致的投影步骤，我们保留试探方向，仅调整其大小。如果基于光滑化的分类器指示黏着，则不作任何改变：\n$$\n\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2.\n$$\n如果指示滑移，我们通过按阈值与代理范数之比缩放试探大小，来收缩大小以达到代理边界水平，\n$$\n\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\cdot \\frac{\\mu p_n}{\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})}.\n$$\n这种缩放使代理度量与阈值 $\\mu p_n$ 对齐，与精确情况下的径向返回类似，但用代理替换了欧几里得范数。精确的投影后大小为\n$$\n\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min \\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2, \\mu p_n \\right).\n$$\n\n为了量化光滑参数 $\\epsilon$ 与黏滑精度之间的权衡，我们为每个测试用例计算：\n- 归一化牵引力大小误差\n$$\nE = \\frac{\\left| \\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 - \\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 \\right|}{\\mu p_n},\n$$\n它是无量纲的，以及\n- 错分指示符\n$$\nI =\n\\begin{cases}\n1,   \\text{若 } \\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n \\right) \\text{ xor } \\left( \\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n \\right), \\\\\n0,   \\text{否则}.\n\\end{cases}\n$$\n\n算法上，对于每个测试用例：\n$1.$ 计算 $r = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2$。\n$2.$ 使用指定的代理计算 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})$。\n$3.$ 通过比较 $r$ 与 $\\mu p_n$ 来确定精确的黏滑状态。\n$4.$ 通过比较 $\\phi_{\\epsilon}$ 与 $\\mu p_n$ 来确定基于代理的黏滑状态。\n$5.$ 计算 $\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min(r, \\mu p_n)$。\n$6.$ 如果代理指示黏着，则计算 $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = r$，否则计算 $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = r \\cdot \\dfrac{\\mu p_n}{\\phi_{\\epsilon}}$。\n$7.$ 通过用 $\\mu p_n$ 归一化来计算 $E$。\n$8.$ 通过比较精确分类和代理分类来计算 $I$。\n\n该测试套件涵盖：\n- 一个严格在锥内部的一般情况（理想路径），\n- 一个在阈值附近及以外的对称情况，其中 $p  2$ 的 $p$-范数光滑化可能低估欧几里得范数并导致错分，\n- 一个远在锥外的情况（明显滑移），\n- 一个恰好在锥边界上的情况，\n- 在阈值附近使用中等 $\\epsilon$ 的 Huber 光滑化，\n- 使用较大 $\\epsilon$ 的 Huber 光滑化，这会显著低估范数并可能将滑移错分为黏着，\n- 使用较小 $\\epsilon$ 的 Huber 光滑化，其结果与欧几里得范数非常接近，\n- 一个零牵引力的边界情况。\n\n最终程序将所有测试用例的 $E$ 和 $I$ 汇总到一个列表中，并按要求的格式以单行打印，所有值均为无量纲。这量化了每个代理因光滑参数 $\\epsilon$ 引起的投影牵引力大小的连续误差和离散错分。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef norm2(t):\n    \"\"\"Euclidean norm of a 2D vector.\"\"\"\n    return float(np.sqrt(t[0]**2 + t[1]**2))\n\ndef phi_pnorm(t, epsilon):\n    \"\"\"\n    p-norm surrogate with p = 2 + epsilon.\n    For epsilon = 0.0, this equals the Euclidean norm.\n    \"\"\"\n    p = 2.0 + float(epsilon)\n    if p == 2.0:\n        return norm2(t)\n    # Use absolute values to define the p-norm.\n    return float((abs(t[0])**p + abs(t[1])**p) ** (1.0 / p))\n\ndef phi_huber(t, epsilon):\n    \"\"\"\n    Huber-type surrogate of the Euclidean norm with threshold epsilon  0.\n    For r = epsilon: r^2 / (2*epsilon)\n    For r >  epsilon: r - epsilon/2\n    \"\"\"\n    r = norm2(t)\n    eps = float(epsilon)\n    if eps = 0.0:\n        # Degenerate case: fallback to Euclidean norm.\n        return r\n    if r = eps:\n        return (r**2) / (2.0 * eps)\n    else:\n        return r - 0.5 * eps\n\ndef classify_exact(t, mu, p_n):\n    \"\"\"Exact stick-slip classification under Coulomb cone.\"\"\"\n    r = norm2(t)\n    return r = mu * p_n\n\ndef classify_smooth(t, mu, p_n, kind, epsilon):\n    \"\"\"Smoothing-based stick-slip classification using surrogate phi_epsilon.\"\"\"\n    if kind == 'pnorm':\n        phi = phi_pnorm(t, epsilon)\n    elif kind == 'huber':\n        phi = phi_huber(t, epsilon)\n    else:\n        raise ValueError(\"Unknown smoothing kind.\")\n    return phi = mu * p_n\n\ndef project_exact_magnitude(t, mu, p_n):\n    \"\"\"Exact projected magnitude onto Coulomb cone.\"\"\"\n    r = norm2(t)\n    return min(r, mu * p_n)\n\ndef project_smooth_magnitude(t, mu, p_n, kind, epsilon):\n    \"\"\"\n    Smoothing-based projection magnitude:\n    - If surrogate classifies stick, keep magnitude r.\n    - If slip, scale magnitude by (mu*p_n)/phi to meet the surrogate boundary.\n    \"\"\"\n    r = norm2(t)\n    if kind == 'pnorm':\n        phi = phi_pnorm(t, epsilon)\n    elif kind == 'huber':\n        phi = phi_huber(t, epsilon)\n    else:\n        raise ValueError(\"Unknown smoothing kind.\")\n    # Stick region: do not change traction\n    if phi = mu * p_n:\n        return r\n    # Slip region: shrink along direction to surrogate boundary\n    # Protect against division by zero in pathological cases\n    denom = phi if phi > 0.0 else 1e-16\n    scale = (mu * p_n) / denom\n    return r * scale\n\ndef solve():\n    # Define global parameters: friction coefficient and normal compression (Pa)\n    mu = 0.6\n    p_n = 1.0e6  # Pa\n\n    # Test cases: (kind, epsilon, t1, t2)\n    test_cases = [\n        ('pnorm', 0.0, 0.30e6, 0.20e6),   # 1: inside cone (happy path)\n        ('pnorm', 1.0, 0.45e6, 0.45e6),   # 2: symmetric near threshold, potential misclassification\n        ('pnorm', 0.5, 0.80e6, 0.40e6),   # 3: outside cone (clear slip)\n        ('pnorm', 1.0, 0.60e6, 0.00e6),   # 4: exactly on boundary\n        ('huber', 1.0e5, 0.59e6, 0.05e6), # 5: near threshold, moderate epsilon\n        ('huber', 2.0e5, 0.45e6, 0.45e6), # 6: larger epsilon, potential misclassification\n        ('huber', 1.0e3, 0.80e6, 0.40e6), # 7: small epsilon, close to exact\n        ('huber', 1.0e5, 0.00e6, 0.00e6), # 8: zero traction edge case\n    ]\n\n    results = []\n    for kind, epsilon, t1, t2 in test_cases:\n        t = (t1, t2)\n        # Exact classification and projection\n        stick_exact = classify_exact(t, mu, p_n)\n        mag_exact = project_exact_magnitude(t, mu, p_n)\n        # Smoothing-based classification and projection\n        stick_smooth = classify_smooth(t, mu, p_n, kind, epsilon)\n        mag_smooth = project_smooth_magnitude(t, mu, p_n, kind, epsilon)\n        # Normalized magnitude error\n        norm_factor = mu * p_n\n        if norm_factor == 0:\n            E = abs(mag_smooth - mag_exact)\n        else:\n            E = abs(mag_smooth - mag_exact) / norm_factor\n        # Misclassification indicator\n        I = 1 if (stick_exact != stick_smooth) else 0\n        results.append(E)\n        results.append(I)\n\n    # Format floats with a reasonable precision; integers as-is.\n    formatted = []\n    for val in results:\n        if isinstance(val, float):\n            formatted.append(f\"{val:.8f}\")\n        else:\n            formatted.append(str(int(val)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```", "id": "3501885"}, {"introduction": "一个数值方法的优劣不仅取决于其能否求解问题，更在于其解的精度和收敛性。本练习将带您进入更深层次的算法分析，通过网格加密研究来考察接触反力（即拉格朗日乘子 $\\lambda$）的收敛性质。您将对比罚函数法和增广拉格朗日法在网格细化 ($h \\to 0$) 过程中的表现，并亲眼见证增广拉格朗日法作为一种混合方法所特有的“超收敛”现象 [@problem_id:3501910]。这种现象意味着该方法能以远高于位移解的精度计算出接触力，这在工程应用中具有极高的价值。", "problem": "考虑一根长度为$L$的一维小应变线性弹性杆，其杨氏模量$E$和横截面积$A$为常数。轴向位移场为$u(x)$，其中$x \\in [0,L]$。位于$x=0$的左端受到一个给定位移$u(0)=\\bar u0$。位于$x=L$的右端可能与一个位于零位移处的刚性不可动障碍物发生无摩擦单边接触。非穿透约束为$u(L) \\le 0$。设$x=L$处的界面牵引力乘子（反力）为$\\lambda \\ge 0$。$x=L$处的西尼奥里尼（Signorini）条件为$u(L) \\le 0$，$\\lambda \\ge 0$和$\\lambda\\,u(L)=0$。精确的连续介质解（如果接触激活）是一个均匀压缩状态，其位移呈线性分布$u(x)=\\bar u\\left(1-\\frac{x}{L}\\right)$，接触间隙为$u(L)=0$，精确的界面牵引力大小为$\\lambda^\\star = \\frac{E A}{L}\\,\\bar u$。所有力必须以牛顿（N）为单位解释，位移以米（m）为单位，所有输入和输出必须与这些单位保持一致。\n\n您将使用标准的线性有限元方法来近似此问题，该方法包含$N$个等尺寸的单元，单元长度为$h=L/N$，节点未知数为$u_i$，$i=0,\\dots,N$。全局刚度矩阵由单元刚度$k_e = \\frac{E A}{h}\\begin{bmatrix}1  -1\\\\ -1  1\\end{bmatrix}$组装而成。狄利克雷（Dirichlet）条件为$u_0=\\bar u$。接触约束位于节点$N$。\n\n必须实现并比较两种数值策略来近似牵引力乘子$\\lambda$：\n\n- 罚函数法（Penalty method）。通过增加一个刚度为$k_p \\ge 0$的边界罚弹簧来替换节点$N$处的单边约束，该弹簧对正位移$u_N0$进行惩罚。得到的未知自由节点向量（节点$1$到$N$）的代数系统为\n$$\nK_{ff}\\,\\mathbf{u}_f = -K_{f0}\\,\\bar u, \\quad \\text{其中} \\quad K_{NN} \\leftarrow K_{NN} + k_p\n$$\n罚函数牵引力近似为\n$$\n\\lambda_p = k_p\\,\\max(u_N,0)\n$$\n当$\\alpha \\ge 0$时，使用典型稳定化$k_p = \\alpha\\,\\frac{E A}{h}$。此外，为了测试固定罚函数的边缘情况，如果$\\alpha0$，则设置$k_p = (-\\alpha)\\,\\frac{E A}{L}$（相对于$h$为常数）。\n\n- 使用乌扎瓦（Uzawa）迭代的增广拉格朗日方法（ALM）。在节点$N$处引入拉格朗日乘子$\\lambda$和增广参数$\\rho0$。给定$\\lambda^{(k)}$，求解线性平衡子问题\n$$\nK_{ff}\\,\\mathbf{u}_f^{(k)} = -K_{f0}\\,\\bar u - \\mathbf{e}_N\\,\\lambda^{(k)}\n$$\n其中$\\mathbf{e}_N \\in \\mathbb{R}^{N}$是选择最后一个自由度（节点$N$）的单位向量。然后通过投影乌扎瓦步更新乘子\n$$\n\\lambda^{(k+1)} = \\max\\big(0,\\;\\lambda^{(k)} + \\rho\\,u_N^{(k)}\\big)\n$$\n迭代直至收敛。为进行测试，设$\\rho = \\gamma\\,\\frac{E A}{L}$，其中给定一个标量$\\gamma0$。\n\n任务。对于一组规定的测试场景（如下所述），以及每个场景的一系列加密序列$N \\in \\{4,8,16,32,64\\}$，实现两种方法来计算近似的界面牵引力$\\lambda_p$（罚函数法）和$\\lambda_{\\text{ALM}}$（增广拉格朗日法），并将它们与精确值$\\lambda^\\star=\\frac{EA}{L}\\,\\bar u$进行比较。对于每个$N$，计算相对误差\n$$\n\\varepsilon_{\\text{method}}(N) = \\frac{|\\lambda_{\\text{method}}(N) - \\lambda^\\star|}{\\lambda^\\star}\n$$\n对于罚函数法，通过对整个加密集上的$\\log\\big(\\varepsilon_{\\text{penalty}}(N)\\big)$与$\\log(h)$进行线性最小二乘拟合，估计观测到的相对于$h$的收敛率$p$。对于增广拉格朗日方法，计算加密集上的最大相对误差$\\max_N \\varepsilon_{\\text{ALM}}(N)$，并检查此处定义的布尔谓词“超收敛”是否成立，即$\\max_N \\varepsilon_{\\text{ALM}}(N) \\le 10^{-10}$。\n\n科学基础。从接触边界处的小应变线性弹性势能、虚功原理和西尼奥里尼（Signorini）条件出发。罚函数近似将不等式替换为一个柔性约束，该约束仅在$k_p \\to \\infty$时才精确，而增广拉格朗日方法通过一个带有增广量$\\rho$的对偶更新来强制实现互补性，从而恢复了一致性。\n\n数值单位与一致性。所有输入必须解释为：$E$的单位是帕斯卡（Pa），$A$的单位是平方米（$\\mathrm{m}^2$），$L$的单位是米（m），$\\bar u$的单位是米（m）。精确和近似的牵引力单位是牛顿（N）。相对误差是无量纲的。问题不涉及角度，因此无需单位。\n\n测试套件。使用以下场景；对每个场景，在加密集$N \\in \\{4,8,16,32,64\\}$上进行计算：\n\n- 测试 1（理想路径）：$E=30\\times 10^{9}\\,\\mathrm{Pa}$，$A=1\\times 10^{-2}\\,\\mathrm{m}^2$，$L=2\\,\\mathrm{m}$，$\\bar u=5\\times 10^{-3}\\,\\mathrm{m}$，$\\alpha=10$（因此$k_p=\\alpha\\,EA/h$），$\\gamma=1$（因此$\\rho=\\gamma\\,EA/L$）。\n\n- 测试 2（较温和的罚函数和较慢的对偶步）：$E=70\\times 10^{9}\\,\\mathrm{Pa}$，$A=5\\times 10^{-3}\\,\\mathrm{m}^2$，$L=3\\,\\mathrm{m}$，$\\bar u=2\\times 10^{-3}\\,\\mathrm{m}$，$\\alpha=1$，$\\gamma=0.5$。\n\n- 测试 3（使用固定罚函数的边缘情况）：$E=50\\times 10^{9}\\,\\mathrm{Pa}$，$A=2\\times 10^{-2}\\,\\mathrm{m}^2$，$L=1.5\\,\\mathrm{m}$，$\\bar u=1\\times 10^{-3}\\,\\mathrm{m}$，$\\alpha=-1$（因此$k_p=(-\\alpha)\\,EA/L$且不随$h$变化），$\\gamma=1.5$。\n\n必须遵守的算法细节：\n\n- 从长度为$h=L/N$的线性单元组装全局刚度矩阵$K \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，单元刚度为$k_e=\\frac{EA}{h}\\begin{bmatrix}1  -1\\\\ -1  1\\end{bmatrix}$。\n\n- 通过消去第一行和第一列来强施加$u_0=\\bar u$。简化后的右侧项必须包括由给定位移产生的贡献。\n\n- 罚函数法：如果$\\alpha \\ge 0$，设$k_p=\\alpha\\,EA/h$；如果$\\alpha0$，设$k_p=(-\\alpha)\\,EA/L$。将$k_p$加到对应于节点$N$（最后一个自由度）的简化矩阵项上。然后计算$\\lambda_p = k_p\\,\\max(u_N,0)$。\n\n- 增广拉格朗日方法：初始化$\\lambda^{(0)}=0$，设$\\rho=\\gamma\\,EA/L$，并进行迭代\n    - 求解$K_{ff}\\,\\mathbf{u}_f^{(k)} = -K_{f0}\\,\\bar u - \\mathbf{e}_N\\,\\lambda^{(k)}$，\n    - 更新$\\lambda^{(k+1)}=\\max\\big(0,\\lambda^{(k)} + \\rho\\,u_N^{(k)}\\big)$，\n  直到$|u_N^{(k)}| \\le 10^{-12}$或达到最大迭代次数$1000$次。\n\n- 精确牵引力：$\\lambda^\\star=\\frac{EA}{L}\\,\\bar u$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个列表，每个测试场景对应一个条目。每个条目本身是一个包含三项的列表：拟合的罚函数收敛率$p$（浮点数），增广拉格朗日法在所有加密级别上的最大相对误差（浮点数），以及一个指示增广拉格朗日法是否超收敛（如上文定义）的布尔值。具体来说，输出必须如下所示\n$$\n[\\,[p_1,\\,\\text{maxErrALM}_1,\\,\\text{isSuper}_1],\\,[p_2,\\,\\text{maxErrALM}_2,\\,\\text{isSuper}_2],\\,[p_3,\\,\\text{maxErrALM}_3,\\,\\text{isSuper}_3]\\,],\n$$\n并使用标准的Python列表格式打印为单行。", "solution": "该问题要求通过有限元方法（FEM）对一维弹性杆的接触问题进行数值求解，并对比罚函数法与增广拉格朗日法（ALM）的性能，特别是接触力的收敛性。\n\n#### 1. 有限元离散化\n首先，使用$N$个线性有限元将连续的杆离散化。这会产生$N+1$个节点。全局刚度矩阵$K$通过组装每个单元的刚度矩阵$k_e = \\frac{EA}{h}\\begin{pmatrix}1  -1 \\\\ -1  1\\end{pmatrix}$得到。将节点位移向量$\\mathbf{u}$划分为已知部分$u_0 = \\bar u$和未知部分$\\mathbf{u}_f = [u_1, \\dots, u_N]^T$。这导致了自由度上的简化线性系统：\n$$\nK_{ff}\\mathbf{u}_f = \\mathbf{f}_f - K_{f0}u_0\n$$\n由于外部载荷仅为接触反力$\\lambda$（作用于节点$N$），该系统变为：\n$$\nK_{ff}\\mathbf{u}_f = -K_{f0}\\bar u - \\lambda \\mathbf{e}_N\n$$\n其中$\\mathbf{e}_N$是选择节点$N$的单位向量。\n\n#### 2. 罚函数法\n罚函数法通过在节点$N$处引入一个罚弹簧来近似硬接触约束。接触力被近似为$\\lambda \\approx k_p u_N$（仅当$u_N > 0$时）。将此关系代入平衡方程中，可以得到一个只包含位移未知数的系统：\n$$\n(K_{ff} + k_p \\mathbf{e}_N \\mathbf{e}_N^T) \\mathbf{u}_f = -K_{f0}\\bar u\n$$\n这等效于将罚刚度$k_p$加到$K_{ff}$的最后一个对角元素上。求解该系统得到$\\mathbf{u}_f$，进而得到$u_N$。近似的接触力则为$\\lambda_p = k_p \\max(u_N, 0)$。此方法是一个近似，其精度依赖于罚参数$k_p$的大小。\n- 当$k_p = \\alpha EA/h$时，罚刚度随着网格加密而增加。可以预期误差与$h$成正比，即收敛率为$p=1$。\n- 当$k_p = (-\\alpha) EA/L$时，罚刚度是固定的。误差将收敛到一个非零常数，因此收敛率为$p=0$。\n\n#### 3. 增广拉格朗日方法 (ALM)\nALM是一种迭代方法，它通过乌扎瓦（Uzawa）算法同时求解位移和接触力。在每次迭代$k$中：\n1.  **主问题求解**：保持拉格朗日乘子$\\lambda^{(k)}$固定，求解一个标准的线性弹性问题以获得位移$\\mathbf{u}_f^{(k)}$：\n    $$\n    K_{ff}\\mathbf{u}_f^{(k)} = -K_{f0}\\bar u - \\lambda^{(k)}\\mathbf{e}_N\n    $$\n2.  **对偶更新**：使用求得的接触节点位移$u_N^{(k)}$来更新拉格朗日乘子：\n    $$\n    \\lambda^{(k+1)} = \\max(0, \\lambda^{(k)} + \\rho u_N^{(k)})\n    $$\n    此更新步骤旨在通过一个类似积分控制器的机制逐步消除约束违反（即$u_N \\neq 0$）。\n\n迭代持续进行，直到接触间隙$u_N$和力残差足够小。对于此特定问题，由于线性有限元能够精确表示精确解（线性位移场），ALM能够收敛到离散系统的精确解。因此，$\\lambda_{\\text{ALM}}$应该在机器精度和迭代容差范围内与精确接触力$\\lambda^\\star$匹配，且与网格尺寸$N$无关。这种与网格无关的极高精度被称为**超收敛**。\n\n#### 4. 分析与实现\n该算法的实现遵循上述步骤。对于每个测试场景和每个加密级别$N$，分别用两种方法计算接触力$\\lambda_p$和$\\lambda_{\\text{ALM}}$，并计算其相对于精确解$\\lambda^\\star$的误差。\n\n- **收敛率估计**：对于罚函数法，通过对数-对数坐标系下的相对误差与网格尺寸$h$进行线性回归来估计收敛率$p$。斜率即为收敛率。\n- **超收敛检查**：对于ALM，计算所有网格加密级别上的最大相对误差。如果该最大误差低于一个非常小的阈值（如$10^{-10}$），则认为超收敛成立。\n\n该过程将揭示两种方法的根本区别：罚函数法是一种不一致的方法，其误差取决于罚参数和网格尺寸；而ALM是一种一致的方法，能够为该问题恢复精确的接触力，不受网格尺寸影响。", "answer": "```python\nimport numpy as np\n\ndef assemble_and_partition(N, L, E, A):\n    \"\"\"\n    Assembles the global stiffness matrix K for a 1D bar with N elements,\n    and partitions it into K_ff and K_f0 for the free DOFs.\n    \"\"\"\n    h = L / N\n    # The total number of nodes is N+1, so K is (N+1)x(N+1)\n    K = np.zeros((N + 1, N + 1))\n    # Elemental stiffness matrix\n    ke = (E * A / h) * np.array([[1, -1], [-1, 1]])\n\n    # Assemble global K from elemental contributions\n    for i in range(N):\n        K[i:i+2, i:i+2] += ke\n    \n    # Partition K. Node 0 is prescribed. Nodes 1 to N are free.\n    # K_ff corresponds to free DOFs (nodes 1 to N)\n    K_ff = K[1:, 1:]\n    # K_f0 is the coupling between free and prescribed DOFs\n    K_f0 = K[1:, 0]\n    \n    return K_ff, K_f0\n\ndef solve_penalty(N, L, E, A, u_bar, alpha, K_ff, K_f0):\n    \"\"\"\n    Solves the contact problem using the penalty method.\n    \"\"\"\n    h = L / N\n    \n    # Define penalty parameter k_p based on alpha\n    if alpha >= 0:\n        k_p = alpha * E * A / h\n    else:  # Edge case for fixed penalty\n        k_p = (-alpha) * E * A / L\n        \n    K_prime_ff = K_ff.copy()\n    # Add penalty stiffness to the diagonal entry for the contact node (node N)\n    K_prime_ff[-1, -1] += k_p\n    \n    # RHS vector from prescribed displacement\n    # K_f0 is a 1D array, so we reshape for matrix multiplication later if needed,\n    # but here direct multiplication with scalar u_bar works element-wise.\n    b = -K_f0 * u_bar\n    \n    # Solve for free displacements\n    u_f = np.linalg.solve(K_prime_ff, b)\n    u_N = u_f[-1]\n    \n    # Calculate approximate traction\n    lambda_p = k_p * max(u_N, 0)\n    return lambda_p\n\ndef solve_alm(N, L, E, A, u_bar, gamma, K_ff, K_f0):\n    \"\"\"\n    Solves the contact problem using the Augmented Lagrangian Method (ALM)\n    with Uzawa iterations.\n    \"\"\"\n    rho = gamma * E * A / L\n    lambda_alm = 0.0\n    \n    # RHS contribution from prescribed displacement\n    b_const = -K_f0 * u_bar\n    # Unit vector to select the last DOF (node N)\n    e_N = np.zeros(N)\n    e_N[-1] = 1.0\n    \n    # Max iterations and tolerance\n    max_iter = 1000\n    tol = 1e-12\n\n    for _ in range(max_iter):\n        # Full RHS for the current iteration\n        b_alm = b_const - e_N * lambda_alm\n        # Solve for displacements\n        u_f = np.linalg.solve(K_ff, b_alm)\n        u_N = u_f[-1]\n        \n        # Check for convergence on primal feasibility (gap closure)\n        if abs(u_N) = tol:\n            break\n            \n        # Update Lagrange multiplier (projected Uzawa step)\n        lambda_alm = max(0, lambda_alm + rho * u_N)\n\n    return lambda_alm\n\ndef solve():\n    \"\"\"\n    Main function to run all test scenarios and produce the final output.\n    \"\"\"\n    test_cases = [\n        # E (Pa), A (m^2), L (m), u_bar (m), alpha, gamma\n        (30e9, 1e-2, 2.0, 5e-3, 10.0, 1.0),\n        (70e9, 5e-3, 3.0, 2e-3, 1.0, 0.5),\n        (50e9, 2e-2, 1.5, 1e-3, -1.0, 1.5),\n    ]\n    refinement_N = [4, 8, 16, 32, 64]\n\n    all_results = []\n\n    for E, A, L, u_bar, alpha, gamma in test_cases:\n        # Exact traction magnitude\n        lambda_star = E * A * u_bar / L\n        \n        penalty_errors = []\n        alm_errors = []\n        h_values = []\n\n        for N in refinement_N:\n            h = L / N\n            h_values.append(h)\n            \n            K_ff, K_f0 = assemble_and_partition(N, L, E, A)\n\n            # --- Penalty Method ---\n            lambda_p = solve_penalty(N, L, E, A, u_bar, alpha, K_ff, K_f0)\n            # Avoid division by zero if lambda_star is zero\n            err_p = abs(lambda_p - lambda_star) / lambda_star if lambda_star != 0 else abs(lambda_p)\n            penalty_errors.append(err_p)\n            \n            # --- Augmented Lagrangian Method ---\n            lambda_alm = solve_alm(N, L, E, A, u_bar, gamma, K_ff, K_f0)\n            err_alm = abs(lambda_alm - lambda_star) / lambda_star if lambda_star != 0 else abs(lambda_alm)\n            alm_errors.append(err_alm)\n\n        # --- Post-processing for the current test case ---\n        \n        # 1. Penalty convergence rate\n        # Using np.polyfit for linear least-squares on log-log data\n        # log(err) = p * log(h) + c\n        log_h = np.log(np.array(h_values))\n        log_err_p = np.log(np.array(penalty_errors))\n        # polyfit returns [slope, intercept] for degree 1\n        p, _ = np.polyfit(log_h, log_err_p, 1)\n\n        # 2. ALM max error and superconvergence check\n        max_err_alm = np.max(alm_errors)\n        is_super = max_err_alm = 1e-10\n\n        all_results.append([p, max_err_alm, is_super])\n\n    # Print the final result in the exact specified format\n    print(all_results)\n\nsolve()\n```", "id": "3501910"}]}