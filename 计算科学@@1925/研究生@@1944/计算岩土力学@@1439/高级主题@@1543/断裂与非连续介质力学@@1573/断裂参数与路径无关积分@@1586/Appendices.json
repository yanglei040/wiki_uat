{"hands_on_practices": [{"introduction": "理解应力强度因子 $K$ 与能量释放率 $G$ 之间的关系是断裂力学的核心。本练习将引导您通过一个实际的计算，具体探讨这种关系如何依赖于平面应力与平面应变这两种不同的约束状态。通过分析一个具有不同厚度的岩石试样，您将亲手计算出在相同应力强度因子 $K_{I}$ 下，由于三维约束效应的不同而导致的能量释放率 $G$ 的差异[@problem_id:3526160]，从而深刻理解几何形状在结构断裂评估中的关键作用。", "problem": "一系列几何相似的饱和砂岩单边缺口棱柱试样，在排水条件下、准静态加载下进行拉伸测试。裂纹为贯穿厚度裂纹，相对于韧带中心对称，且裂纹前缘是直的。该材料在断裂前遵循线弹性行为，且非弹性（过程）区与试样尺寸相比很小。考虑该系列中的两个试样，它们的所有面内尺寸和载荷都相同，但厚度不同：一个薄试样，厚度为 $B_{1} = 8\\,\\mathrm{mm}$；一个厚试样，厚度为 $B_{2} = 200\\,\\mathrm{mm}$。排水杨氏模量为 $E = 25\\,\\mathrm{GPa}$，排水泊松比为 $\\nu = 0.25$。在给定的载荷水平下，两个试样的I型应力强度因子均为 $K_{I} = 2.5\\,\\mathrm{MPa}\\sqrt{\\mathrm{m}}$。假设由于面外约束，薄试样在裂纹中面上受平面应力状态控制，而厚试样在裂纹中面上受平面应变状态控制。\n\n从能量释放率 $G$ 的定义（总势能对裂纹面积的负导数）以及线弹性断裂力学中 $J$ 积分的路径无关性出发，使用各向同性线弹性材料的近尖端渐近场，通过一个取决于面外约束的有效模量 $E'$，将 $G$ 与应力强度因子 $K_{I}$ 联系起来。确定适用于平面应力和平面应变的 $E'$，然后计算在指定的 $K_{I}$ 下，当厚度从 $B_{1}$ 增加到 $B_{2}$ 时，能量释放率的数值变化\n$$\\Delta G = G_{\\text{plane stress}} - G_{\\text{plane strain}}$$\n\n最终答案以 $\\mathrm{J/m^{2}}$ 为单位，表示为一个数字，并四舍五入到四位有效数字。", "solution": "对问题陈述进行评估，认定其有效。该问题科学上基于线弹性断裂力学（LEFM）的原理，问题设定良好，提供了所有必要信息，并且其表述是客观的。诸如线弹性、小范围屈服以及对不同厚度试样应用平面应力和平面应变条件的假设，在此背景下是标准且恰当的。所提供的材料属性和应力强度因子对于像砂岩这样的岩土材料是物理上现实的。\n\n问题的核心是确定在平面应力和平面应变条件下，能量释放率 $G$ 与I型应力强度因子 $K_I$ 之间的关系，然后计算在给定 $K_I$ 下 $G$ 的差值。\n\n能量释放率 $G$ 定义为势能 $\\Pi$ 相对于裂纹面积 $A$ 的变化率。对于厚度为 $B$ 的物体中长度为 $a$ 的裂纹，裂纹面积为 $A = aB$。因此，能量释放率由下式给出：\n$$G = -\\frac{d\\Pi}{dA} = -\\frac{1}{B}\\frac{d\\Pi}{da}$$\n在线弹性断裂力学中，能量释放率 $G$ 等效于 $J$ 积分，$J$ 积分是在包围裂纹尖端的围线 $\\Gamma$ 上计算的路径无关积分。$J$ 积分定义为：\n$$J = \\int_{\\Gamma} \\left( W n_1 - T_i \\frac{\\partial u_i}{\\partial x_1} \\right) d\\Gamma$$\n其中 $W$ 是应变能密度，$n_1$ 是围线 $\\Gamma$ 的单位外法线在裂纹扩展方向（$x_1$方向）上的分量，$T_i = \\sigma_{ij}n_j$ 是围线上的面力矢量分量，$u_i$ 是位移矢量分量。\n\n$J$ 积分的路径无关性使其可以利用应力和位移的近尖端渐近场进行评估。对于各向同性线弹性材料中的I型裂纹，这些场在以裂纹尖端为中心建立的极坐标系 $(r, \\theta)$ 中给出：\n$$\\sigma_{ij}(r, \\theta) = \\frac{K_I}{\\sqrt{2\\pi r}} f_{ij}(\\theta) + \\text{高阶项}$$\n$$u_i(r, \\theta) = \\frac{K_I}{2\\mu} \\sqrt{\\frac{r}{2\\pi}} g_i(\\theta) + \\text{高阶项}$$\n其中 $\\mu = \\frac{E}{2(1+\\nu)}$ 是剪切模量，$f_{ij}$ 和 $g_i$ 是 $\\theta$ 的无量纲函数。应变能密度 $W = \\frac{1}{2}\\sigma_{ij}\\varepsilon_{ij}$ 的主导项将与 $r^{-1}$ 成正比。在裂纹尖端周围半径为 $r$ 的无穷小圆形路径上计算 $J$ 积分，会得到一个与 $r$ 无关的结果，该结果将 $J$（并因此将 $G$）与 $K_I$ 联系起来。这个公认的推导结果具有以下形式：\n$$G = J = \\frac{K_I^2}{E'}$$\n其中 $E'$ 是一个有效的杨氏模量，它取决于面外约束，即取决于状态是平面应力还是平面应变。\n\n对于薄试样 ($B_1 = 8\\,\\mathrm{mm}$)，假设中面主要处于平面应力状态。平面应力的定义条件是 $\\sigma_{zz} = \\sigma_{xz} = \\sigma_{yz} = 0$。当用 $E$ 和 $\\nu$ 表示时，其面内应力-应变关系与标准三维形式相比没有改变。能量释放率与杨氏模量 $E$ 直接相关。\n对于平面应力：\n$$G_{\\text{plane stress}} = \\frac{K_I^2}{E}$$\n因此，平面应力的有效模量是 $E'_{\\text{pl. stress}} = E$。\n\n对于厚试样 ($B_2 = 200\\,\\mathrm{mm}$)，由于高的面外约束，假设中面处于平面应变状态。平面应变的定义条件是 $\\varepsilon_{zz} = \\varepsilon_{xz} = \\varepsilon_{yz} = 0$。约束条件 $\\varepsilon_{zz} = 0$ 意味着在厚度方向上存在非零应力 $\\sigma_{zz} = \\nu(\\sigma_{xx} + \\sigma_{yy})$。这使得材料在 $xy$ 平面内的响应变硬。面内应力-应变关系被修正，由此产生的能量释放率为：\n对于平面应变：\n$$G_{\\text{plane strain}} = \\frac{(1-\\nu^2)K_I^2}{E}$$\n因此，平面应变的有效模量是 $E'_{\\text{pl. strain}} = \\frac{E}{1-\\nu^2}$。\n\n问题要求计算在应力强度因子 $K_I = 2.5\\,\\mathrm{MPa}\\sqrt{\\mathrm{m}}$ 保持不变的情况下，当条件从平面应力（薄试样）变为平面应变（厚试样）时，能量释放率的变化量 $\\Delta G$。\n$$\\Delta G = G_{\\text{plane stress}} - G_{\\text{plane strain}}$$\n将 $G$ 以 $K_I$ 表示的表达式代入：\n$$\\Delta G = \\frac{K_I^2}{E} - \\frac{(1-\\nu^2)K_I^2}{E}$$\n提取公因式：\n$$\\Delta G = \\frac{K_I^2}{E} \\left( 1 - (1-\\nu^2) \\right) = \\frac{K_I^2}{E} (1 - 1 + \\nu^2) = \\frac{\\nu^2 K_I^2}{E}$$\n现在，我们将给定的数值代入此表达式。使用一致的单位制（国际单位制：帕斯卡，米）至关重要。\n给定的值为：\n$K_I = 2.5\\,\\mathrm{MPa}\\sqrt{\\mathrm{m}} = 2.5 \\times 10^6\\,\\mathrm{Pa}\\sqrt{\\mathrm{m}}$\n$E = 25\\,\\mathrm{GPa} = 25 \\times 10^9\\,\\mathrm{Pa}$\n$\\nu = 0.25$\n\n将这些值代入 $\\Delta G$ 的方程中：\n$$\\Delta G = \\frac{(0.25)^2 \\times (2.5 \\times 10^6\\,\\mathrm{Pa}\\sqrt{\\mathrm{m}})^2}{25 \\times 10^9\\,\\mathrm{Pa}}$$\n$$\\Delta G = \\frac{0.0625 \\times 6.25 \\times 10^{12}\\,\\mathrm{Pa}^2\\cdot\\mathrm{m}}{25 \\times 10^9\\,\\mathrm{Pa}}$$\n$$\\Delta G = \\frac{0.390625 \\times 10^{12}}{25 \\times 10^9}\\,\\mathrm{Pa}\\cdot\\mathrm{m}$$\n$$\\Delta G = 0.015625 \\times 10^3\\,\\mathrm{Pa}\\cdot\\mathrm{m}$$\n$$\\Delta G = 15.625\\,\\mathrm{Pa}\\cdot\\mathrm{m}$$\n由于 $1\\,\\mathrm{Pa} = 1\\,\\mathrm{N/m^2}$，单位为 $(\\mathrm{N/m^2})\\cdot\\mathrm{m} = \\mathrm{N/m}$。此外，由于 $1\\,\\mathrm{J} = 1\\,\\mathrm{N}\\cdot\\mathrm{m}$，我们可以写作 $\\mathrm{N/m} = (\\mathrm{N}\\cdot\\mathrm{m})/\\mathrm{m}^2 = \\mathrm{J/m^2}$，这是能量释放率的正确单位。\n所以，$\\Delta G = 15.625\\,\\mathrm{J/m^2}$。\n\n问题要求答案四舍五入到四位有效数字。\n$$\\Delta G \\approx 15.63\\,\\mathrm{J/m^2}$$\n这个正值表明，对于给定的应力强度因子 $K_I$，在平面应力条件下每单位裂纹扩展释放的能量比在平面应变条件下更多。这在物理上是一致的，因为平面应变状态更“硬”。", "answer": "$$ \\boxed{15.63} $$", "id": "3526160"}, {"introduction": "理论的优雅需要通过计算的严谨来验证。J-积分的路径无关性是其在断裂分析中强大功能的基础，但这一特性如何在离散的数值世界中体现？本练习 [@problem_id:3526090] 将指导您从第一性原理出发，编写一个程序来数值计算 J-积分。您将使用裂纹尖端的渐近位移场，在一个理想化的设定中，通过代码实现对 J-积分定义的直接诠释，并数值验证其路径无关性以及与应力强度因子 $K$ 的关系，这是从理论走向计算验证的关键一步。", "problem": "您的任务是为一块处于均匀拉伸状态下的中心裂纹板设计、分析并实现一个计算基准，以验证用于有限元法 (FEM) 和扩展有限元法 (XFEM) 的 I 型应力强度因子和路径无关 $J$ 积分的数值评估。该基准必须基于各向同性、均质材料在线性弹性断裂力学和小应变假设的框架下。您可以使用的基本依据包括线性弹性定律、应变能密度的定义，以及路径无关 $J$ 积分作为围绕裂纹尖端的能量项的线积分的定义。不应预先假设任何进一步的简化公式。所有角度必须以弧度处理。所有物理量必须采用国际单位制 (SI)：应力单位为帕斯卡 ($\\text{Pa}$)，弹性模量单位为帕斯卡 ($\\text{Pa}$)，裂纹长度单位为米 ($\\text{m}$)，$J$ 积分单位为牛顿/米 ($\\text{N/m}$)。\n\n构型为一块半裂纹长度为 $a$ 的中心裂纹无限大板，承受垂直于裂纹平面的均匀远程拉应力 $\\sigma$。此几何形状的精确 I 型应力强度因子由 $K_I = \\sigma \\sqrt{\\pi a}$ 给出。您必须验证，基于围绕裂纹尖端的 $J$ 积分的路径无关定义，将围线积分应用于 I 型加载的领先阶近尖端位移场，能够再现能量释放率并且是路径无关的。然后，使用适当的本构关系，将数值计算得到的 $J$ 转换为 $K$ 的数值估计，并将其与上述精确的 $K_I$ 进行比较。\n\n您的程序必须实现以下步骤和检查：\n1. 从应变、应力和应变能密度的定义，以及围绕裂纹尖端的闭合围线上的路径无关积分 $J$ 出发，构建一个沿以裂纹尖端为中心、半径为 $R$ 的圆形路径的 $J$ 的数值围线积分。该积分必须用应变能密度 $W$、柯西应力张量 $\\boldsymbol{\\sigma}$、位移梯度 $\\partial u_i / \\partial x_1$ 以及沿围线的外法向单位向量 $\\boldsymbol{n}$ 来表示。\n2. 使用小应变下各向同性线性弹性固体中 I 型裂纹尖端的领先阶渐近位移场，以提供所需的位移梯度，并通过线性弹性关系得到应力和应变能密度。显式地实现所需的平面应力和平面应变本构关系。\n3. 在圆形路径上，使用在 $\\theta \\in [0, 2\\pi)$ 范围内的均匀角度采样，对 $J$ 的线积分进行数值近似。通过使用两个不同的半径 $R_1$ 和 $R_2$（其中 $R_1 \\neq R_2$）来证明其路径无关性。\n4. 对于每种构型，使用您必须从允许使用的基本原理中推导出的 $J$ 和 $K$ 之间的标准线性弹性关系，将计算出的 $J$ 转换为 $K$ 的数值估计。然后将数值计算得到的 $K$ 与上面给出的精确 $K_I$ 进行比较。\n5. 针对角度采样分辨率和路径无关性，规定并强制执行收敛准则。具体而言，对于 $N \\in \\{64, 128, 256, 512\\}$ 个角度点，要求：\n   - 当 $N$ 增加时，$J$ 相对于精确值 $J$ 的相对误差单调递减。\n   - 在 $N=512$ 时，最终相对误差满足容差 $|J_{\\text{num}} - J_{\\text{exact}}|/J_{\\text{exact}} \\leq 10^{-3}$。\n   - 在 $N=512$ 时，由 $J$ 重构的 $K$ 满足 $|K_{\\text{num}} - K_I|/K_I \\leq 10^{-3}$。\n   - 在 $N=512$ 且 $R_1 = 0.01 a$ 和 $R_2 = 0.03 a$ 时，通过 $|J(R_1) - J(R_2)|/J_{\\text{exact}} \\leq 10^{-3}$ 测量的路径无关性得到满足。\n\n将该基准实现为一个单一程序，用于评估以下由 $(\\sigma, a, E, \\nu, \\text{plane})$ 指定的独立案例测试套件，其中 $\\text{plane} \\in \\{\\text{plane\\_strain}, \\text{plane\\_stress}\\}$：\n- 案例 1 (理想路径，高刚度材料，中等裂纹): $(\\sigma = 50 \\times 10^{6}\\ \\text{Pa},\\ a = 0.05\\ \\text{m},\\ E = 210 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.30,\\ \\text{plane\\_strain})$。\n- 案例 2 (较软材料，较大裂纹，平面应力): $(\\sigma = 12 \\times 10^{6}\\ \\text{Pa},\\ a = 0.5\\ \\text{m},\\ E = 30 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.25,\\ \\text{plane\\_stress})$。\n- 案例 3 (小裂纹，高 E): $(\\sigma = 3 \\times 10^{6}\\ \\text{Pa},\\ a = 0.005\\ \\text{m},\\ E = 70 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.33,\\ \\text{plane\\_strain})$。\n- 案例 4 (较高应力，较大裂纹，平面应力): $(\\sigma = 80 \\times 10^{6}\\ \\text{Pa},\\ a = 0.2\\ \\text{m},\\ E = 100 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.20,\\ \\text{plane\\_stress})$。\n\n对于每个案例，计算精确的 $K_I = \\sigma \\sqrt{\\pi a}$ 和基于线性弹性的精确 $J$ 值，然后在 $R_1 = 0.01 a$ 和 $R_2 = 0.03 a$ 以及 $N \\in \\{64, 128, 256, 512\\}$ 的条件下运行 $J$ 的数值围线积分。对于每个案例，报告一个布尔值，指示上述所有四个准则是否都得到满足。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如“[True,False,True,True]”。每个条目按上面列出的顺序对应一个测试案例。角度必须是弧度。所有物理输入必须采用指定的国际单位制单位，任何中间或最终的能量量都必须以 $\\text{N/m}$ 为单位。", "solution": "我们从线性弹性和路径无关 $J$ 积分的定义开始。设 $\\boldsymbol{u}$ 表示位移矢量，$\\boldsymbol{\\varepsilon}$ 表示小应变张量，其分量为 $\\varepsilon_{ij} = \\tfrac{1}{2}(\\partial u_i/\\partial x_j + \\partial u_j/\\partial x_i)$，$\\boldsymbol{\\sigma}$ 表示通过线性各向同性本构关系与 $\\boldsymbol{\\varepsilon}$ 相关联的柯西应力张量。应变能密度定义为 $W = \\tfrac{1}{2} \\sigma_{ij} \\varepsilon_{ij}$。对于一个沿 $x$ 轴分布、尖端位于原点且裂纹扩展方向沿 $x_1 \\equiv x$ 的裂纹，其路径无关积分为\n$$\nJ = \\int_{\\Gamma} \\left( W n_1 - \\sigma_{ij} n_j \\frac{\\partial u_i}{\\partial x_1} \\right) \\,\\mathrm{d}s,\n$$\n其中 $\\Gamma$ 是围绕裂纹尖端的任意逆时针围线，$\\boldsymbol{n}$ 是外法向单位向量，$\\mathrm{d}s$ 是沿 $\\Gamma$ 的线元。\n\n对于以裂纹尖端为中心、半径为 $R$ 的圆形围线，由极角 $\\theta \\in [0,2\\pi)$ 参数化，其外法向为 $\\boldsymbol{n} = \\boldsymbol{e}_r = (\\cos\\theta,\\sin\\theta)$，且 $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$。被积函数根据局部近尖端场进行评估。\n\n对于小应变下各向同性线性弹性材料中的 I 型裂纹尖端的领先阶渐近场，其在极坐标 $(r,\\theta)$ 下的位移由 Williams 展开给出，这是众所周知的。引入剪切模量 $ \\mu = E/(2(1+\\nu))$ 和由下式定义的参数 $\\kappa$ \n$$\n\\kappa = \n\\begin{cases}\n3 - 4\\nu,  \\text{平面应变},\\\\\n\\dfrac{3 - \\nu}{1 + \\nu},  \\text{平面应力},\n\\end{cases}\n$$\n径向和环向位移由下式给出\n$$\nu_r(r,\\theta) = \\frac{K}{2\\mu}\\sqrt{\\frac{r}{2\\pi}} \\cos\\left(\\frac{\\theta}{2}\\right) \\left( \\kappa - \\cos\\theta \\right),\n\\qquad\nu_\\theta(r,\\theta) = \\frac{K}{2\\mu}\\sqrt{\\frac{r}{2\\pi}} \\sin\\left(\\frac{\\theta}{2}\\right) \\left( \\kappa - 2 + \\cos\\theta \\right).\n$$\n这些公式提供了直到 $O\\!\\left(r^{3/2}\\right)$ 修正项的近尖端场。笛卡尔位移通过旋转得到\n$$\nu_x = u_r \\cos\\theta - u_\\theta \\sin\\theta, \\qquad u_y = u_r \\sin\\theta + u_\\theta \\cos\\theta.\n$$\n为了计算 $J$ 积分，我们需要位移梯度 $\\partial u_i/\\partial x_j$，这可以通过在极坐标下使用链式法则得到。对于任意标量场 $f(r,\\theta)$，\n$$\n\\frac{\\partial f}{\\partial x} = \\cos\\theta \\frac{\\partial f}{\\partial r} - \\frac{\\sin\\theta}{r}\\frac{\\partial f}{\\partial \\theta}, \n\\qquad\n\\frac{\\partial f}{\\partial y} = \\sin\\theta \\frac{\\partial f}{\\partial r} + \\frac{\\cos\\theta}{r}\\frac{\\partial f}{\\partial \\theta}.\n$$\n我们首先计算 $\\partial u_r/\\partial r$、$\\partial u_r/\\partial \\theta$、$\\partial u_\\theta/\\partial r$ 和 $\\partial u_\\theta/\\partial \\theta$。引入 $A(r) = \\dfrac{K}{2\\mu}\\sqrt{\\dfrac{r}{2\\pi}}$，我们有 $\\dfrac{\\mathrm{d}A}{\\mathrm{d}r} = \\dfrac{A}{2r}$。因此，\n$$\n\\frac{\\partial u_r}{\\partial r} = \\frac{A}{2r} \\cos\\left(\\frac{\\theta}{2}\\right)\\left(\\kappa - \\cos\\theta\\right),\n$$\n$$\n\\frac{\\partial u_r}{\\partial \\theta} = A\\left[ -\\frac{1}{2}\\sin\\left(\\frac{\\theta}{2}\\right)\\left(\\kappa - \\cos\\theta\\right) + \\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\theta \\right],\n$$\n$$\n\\frac{\\partial u_\\theta}{\\partial r} = \\frac{A}{2r} \\sin\\left(\\frac{\\theta}{2}\\right)\\left(\\kappa - 2 + \\cos\\theta\\right),\n$$\n$$\n\\frac{\\partial u_\\theta}{\\partial \\theta} = A\\left[ \\frac{1}{2}\\cos\\left(\\frac{\\theta}{2}\\right)\\left(\\kappa - 2 + \\cos\\theta\\right) - \\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\theta \\right].\n$$\n然后我们通过对 $u_x$ 和 $u_y$ 直接微分得到 $\\dfrac{\\partial u_x}{\\partial r}$、$\\dfrac{\\partial u_x}{\\partial \\theta}$、$\\dfrac{\\partial u_y}{\\partial r}$ 和 $\\dfrac{\\partial u_y}{\\partial \\theta}$：\n$$\n\\frac{\\partial u_x}{\\partial r} = \\frac{\\partial u_r}{\\partial r}\\cos\\theta - \\frac{\\partial u_\\theta}{\\partial r}\\sin\\theta,\n$$\n$$\n\\frac{\\partial u_x}{\\partial \\theta} = \\frac{\\partial u_r}{\\partial \\theta}\\cos\\theta - u_r \\sin\\theta - \\frac{\\partial u_\\theta}{\\partial \\theta}\\sin\\theta - u_\\theta \\cos\\theta,\n$$\n$$\n\\frac{\\partial u_y}{\\partial r} = \\frac{\\partial u_r}{\\partial r}\\sin\\theta + \\frac{\\partial u_\\theta}{\\partial r}\\cos\\theta,\n$$\n$$\n\\frac{\\partial u_y}{\\partial \\theta} = \\frac{\\partial u_r}{\\partial \\theta}\\sin\\theta + u_r \\cos\\theta + \\frac{\\partial u_\\theta}{\\partial \\theta}\\cos\\theta - u_\\theta \\sin\\theta.\n$$\n有了这些，笛卡尔梯度可由链式法则得出：\n$$\n\\frac{\\partial u_x}{\\partial x} = \\cos\\theta \\frac{\\partial u_x}{\\partial r} - \\frac{\\sin\\theta}{r}\\frac{\\partial u_x}{\\partial \\theta}, \\qquad\n\\frac{\\partial u_x}{\\partial y} = \\sin\\theta \\frac{\\partial u_x}{\\partial r} + \\frac{\\cos\\theta}{r}\\frac{\\partial u_x}{\\partial \\theta},\n$$\n$$\n\\frac{\\partial u_y}{\\partial x} = \\cos\\theta \\frac{\\partial u_y}{\\partial r} - \\frac{\\sin\\theta}{r}\\frac{\\partial u_y}{\\partial \\theta}, \\qquad\n\\frac{\\partial u_y}{\\partial y} = \\sin\\theta \\frac{\\partial u_y}{\\partial r} + \\frac{\\cos\\theta}{r}\\frac{\\partial u_y}{\\partial \\theta}.\n$$\n于是，小应变为\n$$\n\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x}, \\qquad \\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y}, \\qquad \\varepsilon_{xy} = \\frac{1}{2}\\left( \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x} \\right).\n$$\n应力取决于平面条件。对于平面应力，\n$$\n\\sigma_{xx} = \\frac{E}{1-\\nu^2}\\left(\\varepsilon_{xx} + \\nu \\varepsilon_{yy}\\right), \\quad\n\\sigma_{yy} = \\frac{E}{1-\\nu^2}\\left(\\varepsilon_{yy} + \\nu \\varepsilon_{xx}\\right), \\quad\n\\sigma_{xy} = 2\\mu \\varepsilon_{xy}.\n$$\n对于平面应变，定义 $\\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu = \\dfrac{E}{2(1+\\nu)}$，\n$$\n\\sigma_{xx} = 2\\mu \\varepsilon_{xx} + \\lambda (\\varepsilon_{xx} + \\varepsilon_{yy}), \\quad\n\\sigma_{yy} = 2\\mu \\varepsilon_{yy} + \\lambda (\\varepsilon_{xx} + \\varepsilon_{yy}), \\quad\n\\sigma_{xy} = 2\\mu \\varepsilon_{xy}.\n$$\n应变能密度为 $W = \\tfrac{1}{2}(\\sigma_{xx}\\varepsilon_{xx} + \\sigma_{yy}\\varepsilon_{yy} + 2\\sigma_{xy}\\varepsilon_{xy})$。沿着圆形围线，外法向单位向量为 $\\boldsymbol{n} = (\\cos\\theta, \\sin\\theta)$。$J$ 的线积分简化为\n$$\nJ = \\int_{0}^{2\\pi} \\left[ W n_x - \\sigma_{xj} n_j \\frac{\\partial u_x}{\\partial x} - \\sigma_{yj} n_j \\frac{\\partial u_y}{\\partial x} \\right] R \\,\\mathrm{d}\\theta,\n$$\n其中 $n_x = \\cos\\theta$，$n_y = \\sin\\theta$，且 $j \\in \\{x,y\\}$。张量缩并为 $\\sigma_{xj} n_j = \\sigma_{xx} n_x + \\sigma_{xy} n_y$ 和 $\\sigma_{yj} n_j = \\sigma_{xy} n_x + \\sigma_{yy} n_y$。该积分使用在 $\\theta \\in [0,2\\pi)$ 上的均匀角度采样进行数值计算，采用复合矩形或梯形法则。\n\n为了与均匀拉伸下中心裂纹板的精确基准进行比较，精确的 I 型应力强度因子为\n$$\nK_I = \\sigma \\sqrt{\\pi a}.\n$$\n在线性弹性力学中，能量释放率等于 $J$ 积分，对于各向同性材料，存在一个从渐近场和本构关系推导出的 $J$ 和 $K$ 之间的经典等价关系：\n$$\nJ = \\frac{K^2}{E'},\n$$\n其中\n$$\nE' = \n\\begin{cases}\nE,  \\text{平面应力},\\\\\n\\dfrac{E}{1-\\nu^2},  \\text{平面应变}.\n\\end{cases}\n$$\n此关系是通过将从渐近位移场和应力场获得的、穿过环绕裂纹尖端围线的弹性能力流，与 $J$ 积分中的表面牵引力和位移梯度功项相等，然后使用本构律以 $K$ 表示能量密度而得出的。因此，该基准的精确 $J$ 值为\n$$\nJ_{\\text{exact}} = \\frac{K_I^2}{E'} = \\frac{\\sigma^2 \\pi a}{E'}.\n$$\n数值算法如下。对于每个测试案例：\n1. 根据平面条件计算 $K_I = \\sigma \\sqrt{\\pi a}$ 和 $E'$。设置 $J_{\\text{exact}} = K_I^2 / E'$。\n2. 对于 $N \\in \\{64, 128, 256, 512\\}$ 和 $R \\in \\{0.01 a, 0.03 a\\}$，在半径 $R$ 处，针对 $K = K_I$ 和给定的 $(E,\\nu,\\text{plane})$，评估近尖端位移 $(u_r, u_\\theta)$。计算位移梯度、应变、应力和 $W$，然后构建被积函数并近似计算在 $\\theta \\in [0,2\\pi)$ 上的 $J$ 积分。\n3. 对每个 $N$，计算相对误差 $|J_{\\text{num}}(R_1,N) - J_{\\text{exact}}| / J_{\\text{exact}}$，并检查它是否随 $N$ 的增加而单调不增。\n4. 在 $N=512$ 时，验证在 $R_1$ 处的 $J$ 的绝对相对误差至多为 $10^{-3}$，并且路径无关性准则 $|J(R_1) - J(R_2)|/J_{\\text{exact}} \\le 10^{-3}$ 成立。同时计算 $K_{\\text{num}} = \\sqrt{E' J_{\\text{num}}(R_1)}$ 并验证 $|K_{\\text{num}} - K_I| / K_I \\le 10^{-3}$。\n5. 当且仅当所有准则都满足时，该案例通过。\n\n测试套件和输出。程序必须评估：\n- 案例 1：$(\\sigma = 50 \\times 10^{6}\\ \\text{Pa},\\ a = 0.05\\ \\text{m},\\ E = 210 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.30,\\ \\text{plane\\_strain})$。\n- 案例 2：$(\\sigma = 12 \\times 10^{6}\\ \\text{Pa},\\ a = 0.5\\ \\text{m},\\ E = 30 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.25,\\ \\text{plane\\_stress})$。\n- 案例 3：$(\\sigma = 3 \\times 10^{6}\\ \\text{Pa},\\ a = 0.005\\ \\text{m},\\ E = 70 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.33,\\ \\text{plane\\_strain})$。\n- 案例 4：$(\\sigma = 80 \\times 10^{6}\\ \\text{Pa},\\ a = 0.2\\ \\text{m},\\ E = 100 \\times 10^{9}\\ \\text{Pa},\\ \\nu = 0.20,\\ \\text{plane\\_stress})$。\n\n对于每个案例，输出一个布尔值，指示是否所有准则都得到满足。最终的程序输出必须是包含这些布尔值的单行列表，例如，“[True,False,True,True]”。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef j_integral_mode_I(K, E, nu, plane, R, N):\n    \"\"\"\n    Compute the J-integral for Mode I using near-tip asymptotic fields\n    along a circular contour of radius R with N angular points.\n\n    Inputs:\n        K: Mode I stress intensity factor (Pa * sqrt(m))\n        E: Young's modulus (Pa)\n        nu: Poisson's ratio (-)\n        plane: 'plane_strain' or 'plane_stress'\n        R: contour radius (m)\n        N: number of angular points\n\n    Returns:\n        J: computed J-integral (N/m)\n    \"\"\"\n    # Material parameters\n    mu = E / (2.0 * (1.0 + nu))\n    if plane == 'plane_strain':\n        kappa = 3.0 - 4.0 * nu\n        lam = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        Eprime = E / (1.0 - nu**2)\n    elif plane == 'plane_stress':\n        kappa = (3.0 - nu) / (1.0 + nu)\n        lam = 0.0  # Not used in plane stress stiffness directly\n        Eprime = E\n    else:\n        raise ValueError(\"Unknown plane condition\")\n\n    # Angular sampling\n    theta = 2.0 * np.pi * np.arange(N) / N\n    c = np.cos(theta)\n    s = np.sin(theta)\n    c2 = np.cos(theta / 2.0)\n    s2 = np.sin(theta / 2.0)\n\n    # Near-tip displacement amplitude\n    A = (K / (2.0 * mu)) * np.sqrt(R / (2.0 * np.pi))  # scalar\n\n    # u_r and u_theta\n    ur = A * c2 * (kappa - np.cos(theta))\n    ut = A * s2 * (kappa - 2.0 + np.cos(theta))\n\n    # Derivatives wrt r\n    ur_r = (A / (2.0 * R)) * c2 * (kappa - np.cos(theta))\n    ut_r = (A / (2.0 * R)) * s2 * (kappa - 2.0 + np.cos(theta))\n\n    # Derivatives wrt theta\n    ur_t = A * (-0.5 * s2 * (kappa - np.cos(theta)) + c2 * np.sin(theta))\n    ut_t = A * (0.5 * c2 * (kappa - 2.0 + np.cos(theta)) - s2 * np.sin(theta))\n\n    # Convert to Cartesian components u_x, u_y\n    ux = ur * c - ut * s\n    uy = ur * s + ut * c\n\n    # Derivatives of u_x and u_y wrt r\n    ux_r = ur_r * c - ut_r * s\n    uy_r = ur_r * s + ut_r * c\n\n    # Derivatives wrt theta\n    ux_t = ur_t * c - ur * s - ut_t * s - ut * c\n    uy_t = ur_t * s + ur * c + ut_t * c - ut * s\n\n    # Chain rule to get Cartesian gradients\n    # du/dx = cos(theta)*du/dr - (sin(theta)/r)*du/dtheta\n    # du/dy = sin(theta)*du/dr + (cos(theta)/r)*du/dtheta\n    invR = 1.0 / R\n    ux_x = c * ux_r - s * invR * ux_t\n    ux_y = s * ux_r + c * invR * ux_t\n    uy_x = c * uy_r - s * invR * uy_t\n    uy_y = s * uy_r + c * invR * uy_t\n\n    # Small strains\n    exx = ux_x\n    eyy = uy_y\n    exy = 0.5 * (ux_y + uy_x)\n\n    # Stresses\n    if plane == 'plane_stress':\n        cE = E / (1.0 - nu**2)\n        sxx = cE * (exx + nu * eyy)\n        syy = cE * (eyy + nu * exx)\n        sxy = 2.0 * mu * exy\n    else:  # plane strain\n        tr = exx + eyy\n        sxx = 2.0 * mu * exx + lam * tr\n        syy = 2.0 * mu * eyy + lam * tr\n        sxy = 2.0 * mu * exy\n\n    # Strain energy density\n    W = 0.5 * (sxx * exx + syy * eyy + 2.0 * sxy * exy)\n\n    # Normal vector on the circle\n    nx = c\n    ny = s\n\n    # Contractions with normal\n    sig_xn = sxx * nx + sxy * ny\n    sig_yn = sxy * nx + syy * ny\n\n    # J-integrand: f(theta) = W * n_x - sigma_ij n_j * du_i/dx\n    # where i in {x,y} and du_i/dx = {ux_x, uy_x}\n    integrand = W * nx - (sig_xn * ux_x + sig_yn * uy_x)\n\n    # Numerical integration over theta\n    dtheta = 2.0 * np.pi / N\n    J = np.sum(integrand) * R * dtheta\n    return J\n\ndef run_case(sigma, a, E, nu, plane):\n    # Exact K_I and J_exact\n    KI = sigma * np.sqrt(np.pi * a)\n    Eprime = E / (1.0 - nu**2) if plane == 'plane_strain' else E\n    J_exact = KI**2 / Eprime\n\n    # Radii and angular resolutions\n    R1 = 0.01 * a\n    R2 = 0.03 * a\n    N_list = [64, 128, 256, 512]\n\n    # Compute J over N_list at R1 and path independence at final N\n    J_errors = []\n    prev_err = None\n    monotonic = True\n    for N in N_list:\n        JN = j_integral_mode_I(KI, E, nu, plane, R1, N)\n        err = abs(JN - J_exact) / J_exact\n        J_errors.append(err)\n        if prev_err is not None and err > prev_err + 1e-14:\n            monotonic = False\n        prev_err = err\n\n    # Final resolution checks at N=512\n    N_final = N_list[-1]\n    J_R1 = j_integral_mode_I(KI, E, nu, plane, R1, N_final)\n    J_R2 = j_integral_mode_I(KI, E, nu, plane, R2, N_final)\n    rel_err_J_final = abs(J_R1 - J_exact) / J_exact\n    path_rel = abs(J_R1 - J_R2) / J_exact\n\n    # Recovered K from J\n    K_num = np.sqrt(Eprime * J_R1)\n    rel_err_K = abs(K_num - KI) / KI\n\n    # Tolerances\n    tol_J = 1e-3\n    tol_path = 1e-3\n    tol_K = 1e-3\n\n    all_good = (monotonic and (rel_err_J_final = tol_J) and (path_rel = tol_path) and (rel_err_K = tol_K))\n    return all_good\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (sigma [Pa], a [m], E [Pa], nu [-], plane)\n    test_cases = [\n        (50e6, 0.05, 210e9, 0.30, 'plane_strain'),\n        (12e6, 0.5, 30e9, 0.25, 'plane_stress'),\n        (3e6, 0.005, 70e9, 0.33, 'plane_strain'),\n        (80e6, 0.2, 100e9, 0.20, 'plane_stress'),\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, a, E, nu, plane = case\n        result = run_case(sigma, a, E, nu, plane)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert booleans to 'True'/'False' strings automatically by map(str, ...)\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3526090"}, {"introduction": "在有限元分析中，我们用平滑的多项式来逼近复杂的物理场，但当遇到裂纹尖端的奇异场时，这种逼近的局限性便显现出来，成为计算误差的主要来源。本练习 [@problem_id:3526101] 通过一个精巧的一维代理模型，让您能精确地探究有限元插值阶次对提取应力强度因子（SIF）精度的影响。您不仅会量化这种插值误差，还将学习和实践多种实用的误差估计方法，如 p-差分和理查德森外推，这些是评估和控制计算断裂力学模拟可信度的核心技能。", "problem": "你需要在一个数学上受控的环境中研究，有限元方法的插值阶数如何影响通过裂纹尖端位移外推法计算的应力强度因子（SIF）估计值的精度。请在线性弹性断裂力学（LEFM）的框架内展开工作，并使用近尖端渐近理论作为基本依据。为了分离插值效应，请使用以下无量纲替代模型来表示沿裂纹线方向（角度为零）的近尖端位移：一个由 $$u(r) = K \\sqrt{r}$$ 定义的标量场，其中 $$r \\ge 0$$ 是距裂纹尖端的径向距离，$$K  0$$ 是真实的无量纲应力强度因子（SIF）。该替代模型捕捉了裂纹尖端附近LEFM渐近理论所基于的平方根奇异标度，并允许进行受控的数值实验。\n\n为了模拟邻近裂纹尖端的第一个单元（单元长度 $$h  0$$）上的近尖端有限元插值，请在区间 $$[0,h]$$ 上使用次数为 $$p \\in \\{1,2,3,\\dots\\}$$ 的等参多项式插值来近似 $$u(r)$$，该插值使用位于 $$r_i = i \\, h/p$$（其中 $$i = 0,1,\\dots,p$$）的 $$p+1$$ 个等距节点和标准的 Lagrange 基多项式。将所得的插值函数表示为 $$u_h^{(p)}(r)$$。你的程序必须通过对精确节点值 $$u(r_i)$$ 执行 Lagrange 插值来构造 $$u_h^{(p)}(r)$$。\n\n定义两个仅使用 $$u_h^{(p)}(r)$$ 的位移外推SIF估计器：\n\n- 单点估计器：对于一个固定分数 $$\\beta \\in (0,1)$$，定义 $$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h) := \\dfrac{u_h^{(p)}(\\beta h)}{\\sqrt{\\beta h}}.$$\n\n- 最小二乘估计器：对于固定数量 $$m \\ge 3$$ 的内部采样点 $$r_j \\in (0,h)$$，找到使 $$\\sum_{j=1}^{m} \\left(u_h^{(p)}(r_j) - a \\sqrt{r_j}\\right)^2$$ 最小化的 $$a \\in \\mathbb{R}$$，并设置 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) := a.$$\n\n对于最小二乘估计器，请注意，因为拟合函数关于 $$a$$ 是线性的，所以其最小化器可明确表示为 $$a = \\dfrac{\\sum_{j=1}^{m} \\sqrt{r_j} \\, u_h^{(p)}(r_j)}{\\sum_{j=1}^{m} r_j}.$$\n\n你还必须提出并实现实用的误差估计器，以评估当 $$h \\to 0$$ 和/或 $$p$$ 增加时向真实值 $$K$$ 的收敛性：\n\n1. 阶数差分估计器（p-差分）：对于固定的 $$h$$ 和 $$p \\ge 2$$，定义 $$\\eta_p(h) := \\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) - \\widehat{K}_{\\mathrm{ls}}^{(p-1)}(h)\\right|.$$ 对于 $$p = 1$$，此估计器未定义；在这种情况下，返回 $$-1.0$$。\n\n2. 基于Richardson的带有观测阶数的估计器：假设渐近形式为 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) = K + C h^{q} + o(h^{q})$$，其中 $$C \\neq 0$$ 和 $$q  0$$ 是取决于 $$p$$ 和目标函数正则性的未知常数。对于固定的 $$p$$，计算 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h), \\widehat{K}_{\\mathrm{ls}}^{(p)}(h/2), \\widehat{K}_{\\mathrm{ls}}^{(p)}(h/4)$$ 并估计观测阶数 $$q_{\\mathrm{obs}} := \\dfrac{\\log\\left(\\left|\\widehat{K}(h) - \\widehat{K}(h/2)\\right| / \\left|\\widehat{K}(h/2) - \\widehat{K}(h/4)\\right|\\right)}{\\log(2)}.$$ 然后在网格尺寸 $$h$$ 处定义 Richardson 误差估计为 $$\\varepsilon_R(h) := \\dfrac{\\left|\\widehat{K}(h) - \\widehat{K}(h/2)\\right|}{2^{q_{\\mathrm{obs}}} - 1}.$$ 如果 $$q_{\\mathrm{obs}}$$ 的计算是病态的（例如，分母过小），则设置 $$\\varepsilon_R(h) := 0.0.$$。\n\n3. 形状残差指标：使用在选定的 $$m$$ 个内部点上对 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$ 进行的最小二乘拟合，定义归一化残差 $$\\rho(h) := \\dfrac{\\sqrt{\\sum_{j=1}^{m} \\left(u_h^{(p)}(r_j) - \\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\sqrt{r_j}\\right)^2}}{\\sqrt{\\sum_{j=1}^{m} \\left(\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\sqrt{r_j}\\right)^2}}.$$ 将 $$\\rho(h)$$ 视为偏离预期平方根分布的无量纲指标。\n\n本问题中所有量均为无量纲，因此无需报告物理单位。\n\n你的任务是实现一个程序，对于下面测试套件中列出的每个测试用例，构造 $$u_h^{(p)}(r)$$，计算两个SIF估计器 $$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h)$$ 和 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$，计算上述三个误差指标，并返回一个单行，其中包含聚合到单个列表中的所有结果。\n\n所有计算使用以下固定参数：\n- 真实SIF：$$K = 1.8$$。\n- 单点分数：$$\\beta = 0.35$$。\n- 最小二乘采样：使用 $$m = 5$$ 个内部点 $$r_j$$，这些点在 $$(\\varepsilon h, (1-\\varepsilon) h)$$ 上等距分布，其中 $$\\varepsilon = 0.13$$。\n\n对于每个测试用例，按此顺序输出一个包含以下五个浮点数的列表：\n- 单点估计器的相对误差 $$\\left|\\widehat{K}_{\\mathrm{sp}}^{(p)}(h) - K\\right|/K.$$\n- 最小二乘估计器的相对误差 $$\\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) - K\\right|/K.$$\n- 由 $$\\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\right|$$ 归一化的相对p-差分估计器，即 $$\\eta_p(h) / \\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\right|$$，如果 $$p=1$$ 则为 $$-1.0$$。\n- 在 $$h$$ 处的基于Richardson的相对误差估计，即 $$\\varepsilon_R(h) / \\left|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\right|.$$\n- 形状残差指标 $$\\rho(h).$$\n\n测试套件：\n- 用例 $$1$$：$$p = 1, \\, h = 1.0.$$\n- 用例 $$2$$：$$p = 2, \\, h = 1.0.$$\n- 用例 $$3$$：$$p = 3, \\, h = 0.5.$$\n- 用例 $$4$$：$$p = 3, \\, h = 0.125.$$\n- 用例 $$5$$：$$p = 2, \\, h = 0.05.$$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，每个元素是对应一个测试用例的五个浮点数列表。例如，输出必须类似于 $$\\left[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],\\dots\\right]$$，不含任何其他文本或换行。", "solution": "用户提供了一个线性弹性断裂力学（LEFM）领域的计算问题。我将首先验证问题陈述，然后提供详细的解决方案。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n\n-   **替代场**：$$u(r) = K \\sqrt{r}$$，对于 $$r \\ge 0$$。\n-   **真实SIF**：$$K = 1.8$$（无量纲）。\n-   **有限元近似**：在 $$[0, h]$$ 上使用 $$p+1$$ 个等距节点 $$r_i = i h/p$$ 的次数为 $$p$$ 的 Lagrange 插值多项式 $$u_h^{(p)}(r)$$。\n-   **单点SIF估计器**：$$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h) = u_h^{(p)}(\\beta h) / \\sqrt{\\beta h}$$，其中 $$\\beta = 0.35$$。\n-   **最小二乘SIF估计器**：$$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) = a$$，其中 $$a$$ 最小化 $$\\sum_{j=1}^{m} (u_h^{(p)}(r_j) - a \\sqrt{r_j})^2$$。采样点 $$r_j$$（$$m=5$$）在 $$(\\varepsilon h, (1-\\varepsilon) h)$$ 上等距分布，其中 $$\\varepsilon = 0.13$$。$$a$$ 的显式解已给出：$$a = (\\sum_{j=1}^{m} \\sqrt{r_j} u_h^{(p)}(r_j)) / (\\sum_{j=1}^{m} r_j)$$。\n-   **p-差分估计器**：$$\\eta_p(h) = |\\widehat{K}_{\\mathrm{ls}}^{(p)}(h) - \\widehat{K}_{\\mathrm{ls}}^{(p-1)}(h)|$$，对于 $$p \\ge 2$$。对于 $$p=1$$，输出为 $$-1.0$$。\n-   **基于Richardson的误差估计器**：\n    -   需要计算在 $$h$$、$$h/2$$ 和 $$h/4$$ 处的 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}$$。\n    -   观测阶数：$$q_{\\mathrm{obs}} = \\log(|\\widehat{K}(h) - \\widehat{K}(h/2)| / |\\widehat{K}(h/2) - \\widehat{K}(h/4)|) / \\log(2)$$。\n    -   误差估计：$$\\varepsilon_R(h) = |\\widehat{K}(h) - \\widehat{K}(h/2)| / (2^{q_{\\mathrm{obs}}} - 1)$$。\n    -   对于病态情况，指定了备用值 $$\\varepsilon_R(h) = 0.0$$。\n-   **形状残差指标**：$$\\rho(h) = \\sqrt{\\sum_{j=1}^{m} (u_h^{(p)}(r_j) - \\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\sqrt{r_j})^2} / \\sqrt{\\sum_{j=1}^{m} (\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)\\sqrt{r_j})^2}$$。\n-   **测试用例**：$$(p,h)$$ 对：$$(1, 1.0), (2, 1.0), (3, 0.5), (3, 0.125), (2, 0.05)$$。\n-   **输出格式**：对于每个用例，一个包含5个浮点数的列表：$$[|\\widehat{K}_{\\mathrm{sp}}/K-1|, |\\widehat{K}_{\\mathrm{ls}}/K-1|, \\eta_p/|\\widehat{K}_{\\mathrm{ls}}|, \\varepsilon_R/|\\widehat{K}_{\\mathrm{ls}}|, \\rho]$$。\n\n**步骤2：使用提取的给定条件进行验证**\n\n-   **科学依据充分**：该问题是一个构思良好的计算断裂力学数值实验。它正确地使用了LEFM的 $$\\sqrt{r}$$ 奇异性、标准的有限元插值概念（Lagrange多项式），以及成熟的SIF提取技术（位移外推法）和误差估计方法（p-差分、Richardson外推法、残差）。该问题在科学上是合理的。\n-   **适定的**：所有参数和函数都有明确定义。计算估计器的方法是明确的。在给定条件下，Lagrange插值函数和最小二乘最小化器的存在性和唯一性得到保证。潜在的除零问题要么被自然避免（例如，最小二乘和单点公式中的分母在 $$h0$$ 时为正），要么有规定的处理方式（例如，Richardson估计器中的病态条件）。\n-   **客观的**：问题以精确的数学术语陈述，没有主观性或歧义。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。它是自洽的、有科学依据的且适定的。我将继续制定并实施解决方案。\n\n### 解决方案设计\n\n该解决方案涉及为每个指定的测试用例实现一系列数值计算。总体设计将是一个Python脚本，它会遍历测试用例，并为每个用例计算所需的五个量。\n\n**1. Lagrange插值**\n对于给定的多项式次数 $$p$$ 和单元尺寸 $$h$$，构造插值函数 $$u_h^{(p)}(r)$$。这需要：\n-   定义 $$p+1$$ 个等距插值节点 $$r_i = i \\cdot h/p$$，其中 $$i = 0, \\dots, p$$。\n-   计算这些节点上的精确位移值：$$y_i = u(r_i) = K \\sqrt{r_i}$$。\n-   使用这些节点和值来构建一个插值函数。`scipy.interpolate.BarycentricInterpolator`（重心插值器）是完成此任务的高效且数值稳定的选择。它将用于在任意点 $$r \\in [0, h]$$ 上评估 $$u_h^{(p)}(r)$$。\n\n**2. SIF估计器**\n-   **单点估计器** $$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h)$$：通过在 $$r = \\beta h$$ 处评估插值函数 $$u_h^{(p)}(r)$$ 并应用公式 $$\\widehat{K}_{\\mathrm{sp}}^{(p)}(h) = u_h^{(p)}(\\beta h) / \\sqrt{\\beta h}$$ 来计算。\n-   **最小二乘估计器** $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$：这需要定义在 $$[\\varepsilon h, (1-\\varepsilon)h]$$ 中等距分布的 $$m=5$$ 个采样点 $$r_j$$。在这些点上评估插值函数 $$u_h^{(p)}(r)$$。然后使用从最小二乘原理导出的给定显式公式计算估计器 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$。\n\n**3. 误差和残差指标**\n这些指标的计算依赖于其他 $$(p, h)$$ 对的计算结果。为了高效管理这一点，将使用缓存机制（字典或记忆化）来存储和检索先前计算的 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$ 值，以避免重复工作。\n\n-   **p-差分估计器** $$\\eta_p(h)$$：对于次数为 $$p  1$$ 的测试用例，这需要 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$ 和 $$\\widehat{K}_{\\mathrm{ls}}^{(p-1)}(h)$$。后者将按需计算（如果尚未缓存）。对于 $$p=1$$，返回指定的 $$-1.0$$ 值。然后将结果由 $$|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)|$$ 归一化。\n-   **基于Richardson的估计器** $$\\varepsilon_R(h)$$：对于测试用例 $$(p, h)$$，这需要在三个网格尺寸（$$h, h/2, h/4$$）上计算的 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}$$。这些值将通过带缓存的计算函数获得。然后根据给定公式计算观测阶数 $$q_{\\mathrm{obs}}$$ 和误差估计 $$\\varepsilon_R(h)$$。将实现一个容差检查来检测病态分母（接近零的值），在这种情况下，按规定将 $$\\varepsilon_R(h)$$ 设置为 $$0.0$$。结果由 $$|\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)|$$ 归一化。\n-   **形状残差指标** $$\\rho(h)$$：该指标量化了插值位移剖面与理想 $$\\sqrt{r}$$ 形状的偏差。它使用采样点上的 $$u_h^{(p)}(r_j)$$ 值和计算出的 $$\\widehat{K}_{\\mathrm{ls}}^{(p)}(h)$$，遵循给定的归一化均方根残差公式进行计算。\n\n**4. 程序结构**\n主程序将定义全局常数（$$K, \\beta, m, \\varepsilon$$）和测试套件。它将遍历每个测试用例，协调对上述计算例程的调用。一个中心的、带缓存的函数 `get_k_ls(p, h)` 将作为所有需要的最小二乘SIF值的单一访问点。每个测试用例的最终结果将被收集并按要求格式化为单个字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem by calculating SIF estimators\n    and error indicators for a set of test cases.\n    \"\"\"\n    # Define the fixed parameters from the problem statement.\n    K_TRUE = 1.8\n    BETA = 0.35\n    M_LS = 5\n    EPSILON_LS = 0.13\n    TOL = 1e-14  # Tolerance for floating point comparisons\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1.0),\n        (2, 1.0),\n        (3, 0.5),\n        (3, 0.125),\n        (2, 0.05),\n    ]\n\n    # Cache to store computed K_ls values to avoid redundant calculations.\n    k_ls_cache = {}\n\n    def get_k_ls(p, h):\n        \"\"\"\n        Computes the least-squares SIF estimator K_ls for a given (p, h) pair.\n        Uses a cache to store and retrieve results.\n        \"\"\"\n        if (p, h) in k_ls_cache:\n            return k_ls_cache[(p, h)]\n\n        # 1. Construct the Lagrange interpolant u_h_p(r)\n        nodes_r = np.linspace(0, h, p + 1)\n        nodes_u = K_TRUE * np.sqrt(nodes_r)\n        \n        # BarycentricInterpolator is efficient for evaluation\n        # but needs at least one point. p=0 is not in the problem but is handled.\n        if p == 0:\n            interpolator = lambda r: np.full_like(np.asarray(r), nodes_u[0])\n        else:\n            interpolator = BarycentricInterpolator(nodes_r, nodes_u)\n        \n        # 2. Define least-squares sampling points\n        r_j = np.linspace(EPSILON_LS * h, (1 - EPSILON_LS) * h, M_LS)\n        \n        # 3. Evaluate interpolant at sampling points\n        u_vals_at_r_j = interpolator(r_j)\n        \n        # 4. Compute K_ls using the explicit formula\n        numerator = np.sum(np.sqrt(r_j) * u_vals_at_r_j)\n        denominator = np.sum(r_j)\n        \n        k_ls = numerator / denominator if denominator > TOL else 0.0\n        \n        # 5. Cache the result and return\n        k_ls_cache[(p, h)] = k_ls\n        return k_ls\n\n    results = []\n    for p, h in test_cases:\n        # A. Construct the Lagrange interpolant for the current main test case (p, h)\n        main_nodes_r = np.linspace(0, h, p + 1)\n        main_nodes_u = K_TRUE * np.sqrt(main_nodes_r)\n        if p == 0:\n            main_interpolator = lambda r: np.full_like(np.asarray(r), main_nodes_u[0])\n        else:\n            main_interpolator = BarycentricInterpolator(main_nodes_r, main_nodes_u)\n\n        # 1. Relative error of the single-point estimator\n        k_sp = 0.0\n        if BETA * h > 0:\n            u_at_beta_h = main_interpolator(BETA * h)\n            k_sp = u_at_beta_h / np.sqrt(BETA * h)\n        rel_err_k_sp = abs(k_sp - K_TRUE) / K_TRUE\n        \n        # 2. Relative error of the least-squares estimator\n        k_ls_h = get_k_ls(p, h)\n        rel_err_k_ls = abs(k_ls_h - K_TRUE) / K_TRUE\n        \n        # 3. Relative p-difference estimator, normalized\n        if p == 1:\n            eta_p_rel = -1.0\n        else:\n            k_ls_p_minus_1 = get_k_ls(p - 1, h)\n            eta_p = abs(k_ls_h - k_ls_p_minus_1)\n            eta_p_rel = eta_p / abs(k_ls_h) if abs(k_ls_h) > TOL else 0.0\n\n        # 4. Richardson-based relative error estimate, normalized\n        k_ls_h2 = get_k_ls(p, h / 2.0)\n        k_ls_h4 = get_k_ls(p, h / 4.0)\n\n        diff1 = abs(k_ls_h - k_ls_h2)\n        diff2 = abs(k_ls_h2 - k_ls_h4)\n\n        epsilon_R_rel = 0.0\n        # If denominator for q_obs is too small, Richardson is ill-conditioned\n        if diff2 > TOL:\n            ratio = diff1 / diff2\n            if ratio > 0: # log requires positive argument\n                q_obs = np.log(ratio) / np.log(2.0)\n                denom_richardson = 2**q_obs - 1\n                if abs(denom_richardson) > TOL:\n                    epsilon_R = diff1 / denom_richardson\n                    epsilon_R_rel = abs(epsilon_R) / abs(k_ls_h) if abs(k_ls_h) > TOL else 0.0\n        \n        # 5. Shape-residual indicator\n        main_r_j = np.linspace(EPSILON_LS * h, (1 - EPSILON_LS) * h, M_LS)\n        main_u_vals = main_interpolator(main_r_j)\n        \n        residuals_sq = (main_u_vals - k_ls_h * np.sqrt(main_r_j))**2\n        num_rho = np.sqrt(np.sum(residuals_sq))\n        \n        fit_vals_sq = (k_ls_h * np.sqrt(main_r_j))**2\n        den_rho = np.sqrt(np.sum(fit_vals_sq))\n        \n        rho = num_rho / den_rho if den_rho > TOL else 0.0\n        \n        results.append([rel_err_k_sp, rel_err_k_ls, eta_p_rel, epsilon_R_rel, rho])\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res_list in results:\n        part = f\"[{','.join(f'{val:.7g}' for val in res_list)}]\"\n        formatted_results.append(part)\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3526101"}]}