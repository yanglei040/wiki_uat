{"hands_on_practices": [{"introduction": "扩展有限元方法（XFEM）的核心思想是在标准有限元近似中加入额外的“扩展”函数来表征不连续性，例如裂纹。这些扩展函数会引入新的未知参数，即扩展自由度（DOFs）。本练习通过一个具体的裂尖单元场景，帮助您掌握如何计算一个扩展单元的总自由度，这是理解并构建XFEM代数系统的第一步。通过这个计算，您将能更好地理解为避免数值问题（如基函数线性相关）而采用特定扩展策略的背后原因[@problem_id:3524336]。", "problem": "考虑一个在平面应变条件下的单个四节点双线性四边形单元，该单元用于模拟均质、各向同性岩石基质，并采用单位分解扩展有限元方法（XFEM）框架。该单元的节点物理坐标为 $\\boldsymbol{x}_1=(0,0)$、$\\boldsymbol{x}_2=(L,0)$、$\\boldsymbol{x}_3=(L,L)$ 和 $\\boldsymbol{x}_4=(0,L)$，其中 $L0$ 是边长。一个无牵引力裂纹从左侧边界上的点 $(0,0.5L)$ 进入单元，其裂纹尖端位于单元内部的点 $\\boldsymbol{x}_{\\mathrm{tip}}=(0.3L,0.3L)$。力学未知量为每个节点的位移分量 $u_x$ 和 $u_y$。增强位移近似是通过使用 Heaviside 阶跃函数 $H$ 来表示裂纹面上的位移跳跃，并使用四个线性无关的近尖端渐近分支函数 $F_1$、$F_2$、$F_3$、$F_4$ 来表示奇异的裂纹尖端场来构造的。在单位分解构造中，每个增强函数乘以增强节点处的标准形函数，并引入一个未知系数向量，其大小等于位移分量的数量。\n\n为避免过度增强和病态问题，采用以下选择策略：\n- 仅将四个近尖端分支增强函数附加到节点1和2（底部边缘的两个节点，与进入的裂纹路径对齐且最靠近裂纹尖端区域）。\n- 仅将 Heaviside 增强函数附加到节点3和4（顶部边缘的两个节点），因为它们的节点支撑域被裂纹切割，但它们远离尖端主导区。\n- 不要将 Heaviside 增强函数和近尖端分支增强函数分配给同一个节点。\n\n根据上述选择策略以及在二维问题中每个节点都具有 $u_x$ 和 $u_y$ 位移分量这一事实，计算该单元在增强后的总自由度数。解释为什么这种选择策略能够产生一个与物理场一致的、稳定且非冗余的增强近似。以纯计数（无量纲）的形式给出最终答案。无需四舍五入。", "solution": "该问题要求计算一个四节点四边形单元在扩展有限元方法（XFEM）框架下为模拟裂纹而增强后的总自由度（DOFs）数。在 XFEM 中，总位移场 $\\boldsymbol{u}(\\boldsymbol{x})$ 被近似为标准有限元（FE）部分和增强部分之和。对于有裂纹的问题，一个增强节点可以有关联于跳跃函数（Heaviside）和/或奇异裂纹尖端分支函数的额外自由度。\n\nXFEM 位移近似的一般形式为：\n$$\n\\boldsymbol{u}(\\boldsymbol{x}) = \\sum_{i \\in I_s} N_i(\\boldsymbol{x})\\boldsymbol{u}_i + \\sum_{j \\in I_H} N_j(\\boldsymbol{x}) H(\\boldsymbol{x}) \\boldsymbol{a}_j + \\sum_{k \\in I_T} N_k(\\boldsymbol{x}) \\left( \\sum_{\\alpha=1}^{N_f} F_\\alpha(\\boldsymbol{x}) \\boldsymbol{b}_{k\\alpha} \\right)\n$$\n其中：\n- $N_i(\\boldsymbol{x})$ 是与节点 $i$ 相关联的标准有限元形函数。\n- $\\boldsymbol{u}_i$ 是节点 $i$ 的标准自由度向量。\n- $I_s$ 是单元中所有节点的集合。\n- $H(\\boldsymbol{x})$ 是 Heaviside 阶跃函数，对于其支撑域被裂纹切割的节点 ($j \\in I_H$)，该函数非零。$\\boldsymbol{a}_j$ 是 Heaviside 函数的增强自由度向量。\n- $F_\\alpha(\\boldsymbol{x})$ 是近尖端渐近分支函数，用于其支撑域包含裂纹尖端的节点 ($k \\in I_T$) 。$\\boldsymbol{b}_{k\\alpha}$ 是与节点 $k$ 和分支函数 $\\alpha$ 相关联的增强自由度向量。$N_f$ 是分支函数的数量。\n- 在二维问题中，未知量是大小为 2 的向量，对应于 $u_x$ 和 $u_y$ 位移分量。例如，$\\boldsymbol{u}_i = \\{u_{ix}, u_{iy}\\}$。\n\n我们将根据问题陈述中提供的具体增强策略，通过对标准部分和两种增强类型的贡献求和来计算总自由度数。\n\n1.  **标准自由度：**\n    该单元是一个有节点1、2、3、4的四节点双线性四边形单元。在标准有限元公式中，每个节点都有与之关联的自由度。对于二维力学问题（平面应变），每个节点有 2 个自由度（$u_x$ 和 $u_y$）。\n    - 节点数：4。\n    - 每个节点的标准自由度：2。\n    - 标准总自由度 = (节点数) $\\times$ (每个节点的标准自由度) = $4 \\times 2 = 8$。\n\n2.  **增强自由度（Heaviside 函数）：**\n    Heaviside 函数 $H(\\boldsymbol{x})$ 用于模拟裂纹面上的位移不连续性。问题陈述指出，Heaviside 增强仅附加到节点3和4。\n    - Heaviside 增强节点数：2 (节点3和4)。\n    - 每个节点的增强函数数量：1 (函数 $H(\\boldsymbol{x})$)。\n    - 每个增强函数的自由度：2 (每个位移分量一个，即向量 $\\boldsymbol{a}_j = \\{a_{jx}, a_{jy}\\}$)。\n    - Heaviside 增强总自由度 = (增强节点数) $\\times$ (函数数量) $\\times$ (每个函数的自由度) = $2 \\times 1 \\times 2 = 4$。\n\n3.  **增强自由度（近尖端分支函数）：**\n    近尖端分支函数 $F_\\alpha(\\boldsymbol{x})$ 用于捕捉裂纹尖端处的奇异应力和应变场。问题明确指出使用了四个线性无关的分支函数（$F_1, F_2, F_3, F_4$）。这些增强仅附加到节点1和2。\n    - 尖端增强节点数：2 (节点1和2)。\n    - 每个节点的增强函数数量：4 (函数 $F_1, F_2, F_3, F_4$)。\n    - 每个增强函数的自由度：2 (每个位移分量一个，即向量 $\\boldsymbol{b}_{k\\alpha}$)。\n    - 尖端增强总自由度 = (增强节点数) $\\times$ (函数数量) $\\times$ (每个函数的自由度) = $2 \\times 4 \\times 2 = 16$。\n\n4.  **总自由度：**\n    单元的总自由度数是标准自由度与所有增强自由度之和。\n    - 总自由度 = (标准自由度) + (Heaviside 自由度) + (尖端自由度)\n    - 总自由度 = $8 + 4 + 16 = 28$。\n\n**增强策略的合理解释：**\n所提供的策略旨在确保一个稳定且非冗余的公式，避免了由此产生的线性方程组的病态问题。这是通过防止基函数之间的线性相关性来实现的。\n\n- **线性相关性问题：** 有限元形函数的单位分解（PU）特性表明，对于单元中的任意点 $\\boldsymbol{x}$，都有 $\\sum_i N_i(\\boldsymbol{x}) = 1$。如果一个单元中的所有节点都用同一个函数，比如 $G(\\boldsymbol{x})$，进行增强，那么基的增强部分包含项 $\\sum_i N_i(\\boldsymbol{x}) G(\\boldsymbol{x}) = G(\\boldsymbol{x})$。如果函数 $G(\\boldsymbol{x})$ 已经可以由标准有限元基（或其他增强函数集）再现，这将引入线性相关性，导致刚度矩阵奇异。\n\n- **Heaviside 函数和尖端函数的冗余性：** 对于各向同性弹性材料中的裂纹，四个标准分支函数（例如，$F_\\alpha \\in \\{\\sqrt{r}\\sin(\\frac{\\theta}{2}), \\sqrt{r}\\cos(\\frac{\\theta}{2}), \\sqrt{r}\\sin(\\frac{\\theta}{2})\\sin(\\theta), \\sqrt{r}\\cos(\\frac{\\theta}{2})\\sin(\\theta)\\}$）的集合可以在尖端附近表示穿过裂纹面（$\\theta = \\pm\\pi$）的位移跳跃。因此，将 Heaviside 增强 $H(\\boldsymbol{x})$ 添加到一个已经用全套尖端函数增强的节点上是多余的。由尖端增强基函数所张成的函数空间已经包含了 Heaviside 函数旨在模拟的跳跃行为。用两组函数同时增强一个节点（或覆盖尖端的一组节点）会引入线性相关性和数值不稳定性。\n\n- **所选策略的稳定性：** 该问题指定的策略通过划分增强任务来避免此问题：\n    1.  靠近尖端的节点（1和2）用分支函数（$F_\\alpha$）进行增强，以捕捉复杂的奇异场。\n    2.  其支撑域被裂纹切割但远离尖端主导区的节点（3和4）用 Heaviside 函数（$H$）进行增强，以模拟位移跳跃。\n这种分离确保了基函数保持线性无关。尖端函数处理奇异性（包括尖端处的跳跃），而 Heaviside 函数处理远离尖端的常规跳跃。这种分工与底层物理原理一致，并导致一个适定且稳定的数值系统。", "answer": "$$\\boxed{28}$$", "id": "3524336"}, {"introduction": "在构建了扩展近似之后，任何有限元分析的下一步都是通过在每个单元上积分来组装系统矩阵（如刚度矩阵）。当一个单元被裂纹切割时，由于被积函数（包含了不连续的扩展函数）的非光滑性，积分过程变得不再标准。本实践练习将引导您通过编程实现处理这一挑战最常用的技术：将被切割的单元划分为多个光滑的子区域，并在每个子区域上使用标准的高斯积分[@problem_id:3524345]。", "problem": "考虑一个用于计算岩土力学中裂纹和界面的扩展有限元法（XFEM）的四节点双线性四边形有限元。裂纹由水平集函数 $\\phi(x,y)=y$ 表示，不连续增强使用亥维赛函数 $H(\\phi)$，其中当 $\\phi0$ 时 $H(\\phi)=1$，当 $\\phi0$ 时 $H(\\phi)=0$。该方形单元是轴对齐的，由四个角节点定义，其物理坐标 $(x,y)$ 的顺序为左下、右下、右上、左上。在父域 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 上的双线性形函数 $N_I(\\xi,\\eta)$（$I=1,2,3,4$）是标准的四节点四边形基函数。设轴对齐矩形的单元映射为线性（仿射），其中 $(x,y)$ 由 $x=x_c+\\frac{L_x}{2}\\xi$ 和 $y=y_c+\\frac{L_y}{2}\\eta$ 给出，其中 $x_c=\\frac{x_{\\min}+x_{\\max}}{2}$，$y_c=\\frac{y_{\\min}+y_{\\max}}{2}$，$L_x=x_{\\max}-x_{\\min}$，$L_y=y_{\\max}-y_{\\min}$。雅可比行列式为常数，等于 $J=\\frac{L_x L_y}{4}$。\n\n你的任务是编写一个完整的、可运行的程序，为每个给定的测试用例计算以下内容：\n- 相对于单元面积的裂纹正侧（$\\{(x,y)\\mid y0\\}$）和负侧（$\\{(x,y)\\mid y0\\}$）的面积分数。线 $y=0$ 的测度为零，对面积没有贡献。\n- 积分 $\\int_{\\Omega_e} N_I(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$（$I=1,2,3,4$），其中 $\\Omega_e$ 表示物理坐标中的单元域。积分必须通过对单元在裂纹正侧的部分（即多边形区域 $\\Omega_e^+=\\Omega_e\\cap\\{y\\ge 0\\}$，注意边界 $y=0$ 的测度为零）进行子三角剖分，将 $\\Omega_e^+$ 分解为三角形，并应用一个对最高为2次的多项式精确的三角形求积法则来执行。\n\n使用的基本原理：\n- 亥维赛函数定义：当 $\\phi0$ 时 $H(\\phi)=1$，当 $\\phi0$ 时 $H(\\phi)=0$。\n- 父正方形上的双线性四边形形函数 $N_I(\\xi,\\eta)$ 以及到轴对齐矩形的 $(x,y)$ 的仿射映射。\n- 在具有常数雅可比行列式 $J$ 的仿射映射下的积分变换。\n- 阶数足以精确积分二次多项式的精确三角形求积。\n\n子三角剖分要求：\n- 用半平面 $y\\ge 0$ 裁剪单元的凸多边形以获得多边形 $\\Omega_e^+$。\n- 将 $\\Omega_e^+$ 三角剖分为完全覆盖它的不重叠三角形。\n- 对每个三角形，使用一个标准的3点求积法，该方法对最高为2次的多项式精确，使用重心坐标点和权重。函数 $f$ 在三角形 $T$ 上的积分必须执行为 $\\int_T f(x,y)\\,\\mathrm{d}A = |T|\\sum_{k=1}^{3} w_k f(x_k,y_k)$，其中 $|T|$ 是三角形面积，$(x_k,y_k)$ 是求积点，$w_k$ 是权重，使得 $\\sum_k w_k=1$ 并且该法则对2次多项式精确。\n\n形函数：\n- 在父域 $(\\xi,\\eta)\\in[-1,1]^2$ 上使用标准的四节点双线性四边形基函数：$N_1(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1+\\eta)$, $N_4(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1+\\eta)$。通过 $\\xi=\\frac{2(x-x_c)}{L_x}$ 和 $\\eta=\\frac{2(y-y_c)}{L_y}$ 映射回 $(\\xi,\\eta)$，在物理坐标 $(x,y)$ 处计算 $N_I$。\n\n测试套件：\n为确保覆盖率，包括以下五个方形单元，每个单元由节点坐标 $(x,y)$ 按顺序定义：左下、右下、右上、左上。\n1. 情况1：$\\{(-1,-1),(1,-1),(1,1),(-1,1)\\}$（裂纹穿过中心；对称分裂）。\n2. 情况2：$\\{(2,0.2),(3,0.2),(3,1.2),(2,1.2)\\}$（完全位于 $y=0$ 上方）。\n3. 情况3：$\\{(-0.5,-2.0),(0.5,-2.0),(0.5,-1.0),(-0.5,-1.0)\\}$（完全位于 $y=0$ 下方）。\n4. 情况4：$\\{(0.0,-0.2),(1.0,-0.2),(1.0,0.8),(0.0,0.8)\\}$（非对称地跨越 $y=0$）。\n5. 情况5：$\\{(0.0,0.0),(1.0,0.0),(1.0,1.0),(0.0,1.0)\\}$（边界情况，裂纹与底边 $y=0$ 重合；正侧为整个单元，负侧面积为零）。\n\n输出规格：\n- 对于上述顺序中的每个测试用例，计算：\n  - $f_{\\text{pos}}=\\frac{|\\Omega_e^+|}{|\\Omega_e|}$，\n  - $f_{\\text{neg}}=\\frac{|\\Omega_e^-|}{|\\Omega_e|}$，其中 $\\Omega_e^-=\\Omega_e\\cap\\{y\\le 0\\}$ 且 $|\\cdot|$ 表示面积，\n  - $I_1=\\int_{\\Omega_e} N_1(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$，\n  - $I_2=\\int_{\\Omega_e} N_2(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$，\n  - $I_3=\\int_{\\Omega_e} N_3(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$，\n  - $I_4=\\int_{\\Omega_e} N_4(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号内以逗号分隔的列表。对于按顺序 $k=1,2,3,4,5$ 的情况 $k$，将六个值 $[f_{\\text{pos}},f_{\\text{neg}},I_1,I_2,I_3,I_4]$ 附加到最终列表中，因此最终输出是按测试套件顺序排列的30个浮点数的扁平列表。\n\n所有值都是无量纲的，并且必须以浮点数形式报告。此问题不涉及角度，因此不需要角度单位。程序必须是完全自包含的，不得读取输入文件；它应按上述规定嵌入测试套件，并以要求的格式精确打印最终答案。", "solution": "用户提供的问题被评估为有效，因为它在科学上基于计算力学原理，特别是扩展有限元法（XFEM）。该问题是适定的、客观的，并包含推导唯一且可验证解所需的所有必要信息。因此，我们将进行完整的推导和实现。\n\n该问题要求计算一个被裂纹切割的四节点四边形单元的面积分数和增强形函数积分。裂纹由水平集函数 $\\phi(x,y) = y$ 定义，对应于 $y=0$ 处的一条水平线。增强基于亥维赛函数 $H(\\phi)$，当 $\\phi  0$ 时为 $1$，当 $\\phi  0$ 时为 $0$。因此，每个标准形函数 $N_I$ 的目标积分为：\n$$ I_I = \\int_{\\Omega_e} N_I(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A $$\n其中 $\\Omega_e$ 是有限元的域。根据 $H(\\phi(x,y)) = H(y)$ 的定义，积分简化为在单元 $y0$ 的部分上进行积分：\n$$ I_I = \\int_{\\Omega_e \\cap \\{y0\\}} N_I(x,y)\\,\\mathrm{d}A = \\int_{\\Omega_e^+} N_I(x,y)\\,\\mathrm{d}A $$\n域 $\\Omega_e^+$ 是单元中 $y$ 坐标为正的部分。问题指明线 $y=0$ 的测度为零，对面积或积分没有贡献。\n\n每个测试用例的求解过程包括以下步骤：\n1.  **几何表征**：定义单元的几何形状并确定积分域 $\\Omega_e^+$。\n2.  **面积分数计算**：计算单元面积 $|\\Omega_e|$、正部面积 $|\\Omega_e^+|$ 和负部面积 $|\\Omega_e^-|$，然后求得分数 $f_{\\text{pos}} = |\\Omega_e^+|/|\\Omega_e|$ 和 $f_{\\text{neg}} = |\\Omega_e^-|/|\\Omega_e|$。\n3.  **数值积分**：对域 $\\Omega_e^+$ 进行三角剖分，并在每个三角形上应用3点求积法则来计算积分 $I_I$。\n\n让我们详细说明每个步骤。\n\n**1. 几何表征与裁剪**\n对于每个测试用例，单元都是一个由四个角节点定义的轴对齐正方形或矩形。设这些节点的坐标定义了单元的边界：$x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max}$。单元域为 $\\Omega_e = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$。积分域为 $\\Omega_e^+ = \\Omega_e \\cap \\{(x,y) | y  0\\}$。由于单元是轴对齐的矩形，因此所得域 $\\Omega_e^+$ 也是一个矩形（或为空）。我们可以通过考虑单元的y范围来确定 $\\Omega_e^+$：\n- 如果 $y_{\\min} \\ge 0$，则整个单元位于正半平面。因此，$\\Omega_e^+ = \\Omega_e$。\n- 如果 $y_{\\max} \\le 0$，则整个单元位于负半平面。因此，$\\Omega_e^+$ 是一个空集，其面积为 $0$。\n- 如果 $y_{\\min}  0  y_{\\max}$，则单元被线 $y=0$ 切割。域 $\\Omega_e^+$ 是由 $[x_{\\min}, x_{\\max}] \\times [0, y_{\\max}]$ 定义的矩形。\n\n**2. 面积分数计算**\n单元的总面积为 $|\\Omega_e| = (x_{\\max}-x_{\\min})(y_{\\max}-y_{\\min}) = L_x L_y$。正部面积 $|\\Omega_e^+|$ 可以从定义 $\\Omega_e^+$ 的多边形的顶点计算得出。一个通用的方法是用于具有顶点 $(x_1, y_1), (x_2, y_2), \\dots, (x_n, y_n)$ 的多边形的鞋带公式：\n$$ |\\Omega_e^+| = \\frac{1}{2} \\left| \\sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \\right| \\quad (\\text{with } (x_{n+1}, y_{n+1}) = (x_1, y_1)) $$\n负部的面积是 $|\\Omega_e^-| = |\\Omega_e| - |\\Omega_e^+|$。面积分数则为：\n$$ f_{\\text{pos}} = \\frac{|\\Omega_e^+|}{|\\Omega_e|} \\quad \\text{and} \\quad f_{\\text{neg}} = \\frac{|\\Omega_e^-|}{|\\Omega_e|} = 1 - f_{\\text{pos}} $$\n\n**3. 数值积分**\n积分 $I_I$ 是在 $\\Omega_e^+$ 上计算的。如果 $|\\Omega_e^+| = 0$，则对所有 $I$， $I_I=0$。否则，我们继续进行三角剖分和求积。\n\n**3.1 三角剖分：**\n域 $\\Omega_e^+$ 是一个凸矩形，可以平凡地三角剖分为两个三角形。设矩形 $\\Omega_e^+$ 的顶点按逆时针顺序为 $v_1, v_2, v_3, v_4$。我们可以构成两个三角形，$T_1 = (v_1, v_2, v_3)$ 和 $T_2 = (v_1, v_3, v_4)$。\n\n**3.2 求积法则：**\n问题指定了一个对最高为2次的多项式精确的三角形3点求积法则。对于一个具有顶点 $p_1, p_2, p_3$ 的三角形 $T$，函数 $f(x,y)$ 的积分近似为：\n$$ \\int_T f(x,y) \\, \\mathrm{d}A \\approx |T| \\sum_{k=1}^{3} w_k f(q_k) $$\n其中 $|T|$ 是三角形的面积。指定的法则在三角形边的中点使用求积点 $q_k$，并使用相等的权重 $w_k = 1/3$。\n$$ q_1 = \\frac{p_1+p_2}{2}, \\quad q_2 = \\frac{p_2+p_3}{2}, \\quad q_3 = \\frac{p_3+p_1}{2} $$\n在 $\\Omega_e^+$ 上的总积分是其组成三角形上积分的总和：\n$$ I_I = \\int_{T_1} N_I(x,y) \\, \\mathrm{d}A + \\int_{T_2} N_I(x,y) \\, \\mathrm{d}A $$\n\n**3.3 形函数求值：**\n为了在求积点 $(x_q, y_q)$ 处计算形函数 $N_I(x,y)$，我们必须首先将该点从物理域映射到父域 $(\\xi_q, \\eta_q) \\in [-1,1]^2$。该映射由下式给出：\n$$ \\xi_q = \\frac{2(x_q-x_c)}{L_x} \\quad \\text{and} \\quad \\eta_q = \\frac{2(y_q-y_c)}{L_y} $$\n其中 $L_x = x_{\\max}-x_{\\min}$，$L_y = y_{\\max}-y_{\\min}$，$x_c = (x_{\\min}+x_{\\max})/2$，$y_c = (y_{\\min}+y_{\\max})/2$。注意，这些参数指的是原始的、未裁剪的单元。计算出 $(\\xi_q,\\eta_q)$ 后，我们使用标准的双线性形函数：\n\\begin{align*}\nN_1(\\xi_q, \\eta_q) = \\frac{1}{4}(1-\\xi_q)(1-\\eta_q) \\\\\nN_2(\\xi_q, \\eta_q) = \\frac{1}{4}(1+\\xi_q)(1-\\eta_q) \\\\\nN_3(\\xi_q, \\eta_q) = \\frac{1}{4}(1+\\xi_q)(1+\\eta_q) \\\\\nN_4(\\xi_q, \\eta_q) = \\frac{1}{4}(1-\\xi_q)(1+\\eta_q)\n\\end{align*}\n被积函数 $N_I(x,y)$ 是 $(x,y)$ 的双线性函数，即2次多项式。所选的求积法则对此类多项式是精确的，因此数值积分将产生精确结果，直到浮点精度。\n\n对提供的五个测试用例中的每一个都实施了整个程序。对于单元完全位于裂纹上方或下方的情况，计算将大大简化。如果单元完全位于下方（$y_{\\max} \\le 0$），则 $f_{\\text{pos}}=0$，$f_{\\text{neg}}=1$，并且所有 $I_I=0$。如果它完全位于上方（$y_{\\min} \\ge 0$），则 $f_{\\text{pos}}=1$，$f_{\\text{neg}}=0$。在这种情况下，积分 $\\int_{\\Omega_e} N_I \\mathrm{d}A$ 可以解析计算：\n$$ \\int_{\\Omega_e} N_I \\mathrm{d}A = \\int_{-1}^{1}\\int_{-1}^{1} N_I(\\xi, \\eta) J \\mathrm{d}\\xi \\mathrm{d}\\eta = J \\int_{-1}^{1}\\int_{-1}^{1} N_I(\\xi, \\eta) \\mathrm{d}\\xi \\mathrm{d}\\eta = J \\times 1 = \\frac{L_x L_y}{4} $$\n因此，对于一个完全为正的单元，每个积分 $I_I$ 等于单元面积的四分之一。这为数值实现提供了一个有用的验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    # Test suite: 5 square elements defined by corner nodes (x,y)\n    # Order: bottom-left, bottom-right, top-right, top-left.\n    test_cases = [\n        # Case 1: Symmetric split\n        [(-1.0, -1.0), (1.0, -1.0), (1.0, 1.0), (-1.0, 1.0)],\n        # Case 2: Entirely above y=0\n        [(2.0, 0.2), (3.0, 0.2), (3.0, 1.2), (2.0, 1.2)],\n        # Case 3: Entirely below y=0\n        [(-0.5, -2.0), (0.5, -2.0), (0.5, -1.0), (-0.5, -1.0)],\n        # Case 4: Asymmetric straddle of y=0\n        [(0.0, -0.2), (1.0, -0.2), (1.0, 0.8), (0.0, 0.8)],\n        # Case 5: Boundary case on y=0\n        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n    ]\n    \n    all_results = []\n    for case_nodes in test_cases:\n        results = compute_for_element(case_nodes)\n        all_results.extend(results)\n\n    # Format the final output string\n    output_str = f\"[{','.join(f'{val:.15f}' for val in all_results)}]\"\n    print(output_str)\n\ndef compute_for_element(nodes):\n    \"\"\"\n    Computes area fractions and enriched integrals for a single element.\n\n    Args:\n        nodes (list of tuples): A list of four (x, y) coordinates for the\n                                element nodes in the order: BL, BR, TR, TL.\n\n    Returns:\n        list: A list of six float values: [f_pos, f_neg, I1, I2, I3, I4].\n    \"\"\"\n    nodes_arr = np.array(nodes, dtype=float)\n    x_coords, y_coords = nodes_arr[:, 0], nodes_arr[:, 1]\n    \n    x_min, x_max = np.min(x_coords), np.max(x_coords)\n    y_min, y_max = np.min(y_coords), np.max(y_coords)\n\n    L_x = x_max - x_min\n    L_y = y_max - y_min\n    \n    if L_x == 0 or L_y == 0: # Degenerate element\n        return [0.0] * 6\n\n    element_area = L_x * L_y\n    \n    # 1. Determine the vertices of the positive polygon Omega_e^+\n    positive_polygon_verts = []\n    if y_max = 0:\n        # Element is entirely below or on the crack line\n        positive_area = 0.0\n    elif y_min >= 0:\n        # Element is entirely above or on the crack line\n        positive_polygon_verts = [(x_min, y_min), (x_max, y_min), (x_max, y_max), (x_min, y_max)]\n        positive_area = element_area\n    else: # y_min  0  y_max\n        # Element is cut by the crack\n        positive_polygon_verts = [(x_min, 0), (x_max, 0), (x_max, y_max), (x_min, y_max)]\n        positive_area = L_x * y_max\n        \n    # 2. Calculate area fractions\n    f_pos = positive_area / element_area\n    f_neg = 1.0 - f_pos\n\n    # 3. Calculate integrals I1, I2, I3, I4\n    integrals = np.zeros(4)\n    if not positive_polygon_verts:\n        return [f_pos, f_neg, 0.0, 0.0, 0.0, 0.0]\n        \n    # --- Triangulation and Quadrature ---\n    # The positive polygon is always a rectangle, so we can split it into two triangles.\n    # Vertices v1, v2, v3, v4 in CCW order\n    v1, v2, v3, v4 = [np.array(p) for p in positive_polygon_verts]\n    triangles = [(v1, v2, v3), (v1, v3, v4)]\n\n    # Element mapping parameters\n    x_c = (x_min + x_max) / 2.0\n    y_c = (y_min + y_max) / 2.0\n    \n    for tri_verts in triangles:\n        p1, p2, p3 = tri_verts\n        \n        # Triangle area using cross product\n        tri_area = 0.5 * np.abs(np.cross(p2 - p1, p3 - p1))\n        \n        # 3-point quadrature: midpoints of sides, weights are 1/3\n        q_points = [\n            (p1 + p2) / 2.0,\n            (p2 + p3) / 2.0,\n            (p3 + p1) / 2.0,\n        ]\n        \n        n_vals_at_q_points = np.zeros((3, 4))\n        for i, q_point in enumerate(q_points):\n            x_q, y_q = q_point\n            \n            # Map physical coords (x_q, y_q) to parent coords (xi, eta)\n            xi = 2.0 * (x_q - x_c) / L_x if L_x != 0 else 0\n            eta = 2.0 * (y_q - y_c) / L_y if L_y != 0 else 0\n            \n            # Evaluate shape functions N_I(xi, eta)\n            N1 = 0.25 * (1 - xi) * (1 - eta)\n            N2 = 0.25 * (1 + xi) * (1 - eta)\n            N3 = 0.25 * (1 + xi) * (1 + eta)\n            N4 = 0.25 * (1 - xi) * (1 + eta)\n            n_vals_at_q_points[i, :] = [N1, N2, N3, N4]\n\n        # Sum contributions from quadrature points\n        # (weight is 1/3 for all points)\n        avg_n_vals = np.mean(n_vals_at_q_points, axis=0)\n        integrals += tri_area * avg_n_vals\n        \n    return [f_pos, f_neg] + integrals.tolist()\n    \n# Run the solver\nsolve()\n\n```", "id": "3524345"}, {"introduction": "施加边界条件是求解有限元问题的最后关键步骤之一，但在XFEM中这并非易事。虽然在标准有限元中直接施加位移约束（Dirichlet边界条件）很简单，但当裂纹与边界相交时，不恰当的处理会过度约束系统，导致物理上错误的结果。本练习探讨了在扩展有限元中正确施加位移边界条件的几种成熟方法，这对于开发稳健的XFEM程序至关重要[@problem_id:3524306]。", "problem": "在线性弹性小应变计算岩土力学中，设一个物体占据域 $\\Omega \\subset \\mathbb{R}^d$，其中 $d \\in \\{2,3\\}$，该物体包含一个由符号距离水平集 $\\phi(\\mathbf{x})$ 隐式描述的裂纹 $\\Gamma_c$。按照惯例，$H(\\phi(\\mathbf{x})) \\in \\{-1,+1\\}$ 表示裂纹两侧的亥维赛函数。外边界 $\\partial \\Omega$ 分解为狄利克雷（Dirichlet）部分 $\\Gamma_D$ 和诺伊曼（Neumann）部分 $\\Gamma_N$，在 $\\Gamma_D$ 上有给定的位移 $\\bar{\\mathbf{u}}(\\mathbf{x})$。扩展有限元法（XFEM）的位移场近似使用单位分解概念，表示为\n$$\n\\mathbf{u}_h(\\mathbf{x}) \\;=\\; \\sum_{i \\in I} N_i(\\mathbf{x})\\,\\mathbf{u}_i \\;+\\; \\sum_{j \\in I_H} N_j(\\mathbf{x})\\,H(\\phi(\\mathbf{x}))\\,\\mathbf{a}_j \\;+\\; \\sum_{k \\in I_T} N_k(\\mathbf{x}) \\sum_{\\alpha=1}^{4} F_\\alpha(\\mathbf{x})\\,\\mathbf{b}_{k\\alpha},\n$$\n其中 $N_i(\\mathbf{x})$ 是标准形函数，$I$ 是所有节点的集合，$I_H$ 是使用跳跃（亥维赛）函数增强的节点集合，$I_T$ 是使用裂纹尖端函数 $F_\\alpha(\\mathbf{x})$ 增强的节点集合，而 $\\{\\mathbf{u}_i\\}$、$\\{\\mathbf{a}_j\\}$ 和 $\\{\\mathbf{b}_{k\\alpha}\\}$ 是相关的自由度（DOF）。假设使用拉格朗日单元，因此 $N_i(\\mathbf{x}_i)=1$ 且 $N_{m \\neq i}(\\mathbf{x}_i)=0$，并假设在实际实现中采用常用的移位增强，即用 $N_j(\\mathbf{x})\\,[H(\\phi(\\mathbf{x}))-H(\\phi(\\mathbf{x}_j))]$ 替代 $N_j(\\mathbf{x})\\,H(\\phi(\\mathbf{x}))$，以确保增强形函数在增强节点处为零。\n\n考虑一个非平凡情况，即裂纹 $\\Gamma_c$ 与狄利克雷边界 $\\Gamma_D$ 在点 $\\mathbf{x}^\\ast$ 处相交，因此至少有一个边界节点 $i \\in \\Gamma_D$ 属于增强的支集（例如，被裂纹切割或位于尖端增强区域内）。必须在不过度约束增强近似的情况下，在 $\\Gamma_D$ 上施加物理边界位移，尤其是在其支集被 $\\Gamma_c$ 切割的边界节点处。设 $\\mathbf{u}_h^\\pm$ 表示从由 $H(\\phi)$ 决定的裂纹 $\\pm$ 侧逼近时 $\\mathbf{u}_h$ 在 $\\Gamma_D$ 上的迹，并注意沿着 $\\Gamma_D$ 远离 $\\mathbf{x}^\\ast$ 的任何开放边界段，两个迹中只有一个存在。\n\n下列陈述中，哪些正确描述了当裂纹切割边界节点时，在 XFEM 中一致地施加 $\\Gamma_D$ 上的狄利克雷条件的方法，并正确处理增强自由度以避免过度约束？选择所有适用的选项。\n\nA. 预先将与 $\\Gamma_D$ 上节点相关的所有增强自由度设置为零，并通过仅强施加 $\\Gamma_D$ 上的标准自由度 $\\{\\mathbf{u}_i\\}$ 来强制 $\\mathbf{u}_h=\\bar{\\mathbf{u}}$。这通过消除边界处的增强来避免任何额外的约束。\n\nB. 使用弱施加方法（如拉格朗日乘子法、尼采法或罚函数法），将狄利克雷条件施加在沿实际边界侧的物理边界迹 $\\mathbf{u}_h^\\pm$ 上，该方法在 $\\Gamma_D$ 上积分，因此约束仅作用于构成边界侧迹的标准自由度和增强自由度的线性组合上；仅对另一侧裂纹面有贡献的增强自由度不受边界条件的约束。\n\nC. 通过将标准自由度和这些节点上的所有增强自由度都设置为给定（prescribed）位移 $\\bar{\\mathbf{u}}(\\mathbf{x}_i)$，来强施加所有边界节点上的节点值，从而对被裂纹切割的边界节点上存在的每个自由度强制施加相同的位移。\n\nD. 通过将增强函数乘以一个在 $\\Gamma_D$ 上为零且在远离 $\\Gamma_D$ 处为正的 $C^0$ 斜坡函数 $r(\\mathbf{x})$ 来修正 $\\Gamma_D$ 附近的增强，使得增强对边界迹的贡献在 $\\Gamma_D$ 上恒等于零；然后仅对标准自由度强施加狄利克雷条件。这消除了在 $\\Gamma_D$ 上约束增强自由度的需要，并防止了过度约束。\n\nE. 将每个被切割的边界节点复制为两个重合的节点，每个裂纹侧一个，保留两组增强自由度，并对两个复制节点施加相同的给定（prescribed）位移，以使两个边界侧迹在节点处接收相同的狄利克雷数据；这保证了在 XFEM 中对被切割的边界节点进行非过度约束的施加。", "solution": "### 步骤 1：提取已知信息\n问题陈述为计算岩土力学中的一个线性弹性小应变问题提供了以下信息：\n- 一个物体占据域 $\\Omega \\subset \\mathbb{R}^d$，其中 $d \\in \\{2,3\\}$。\n- 该物体包含一个由符号距离水平集函数 $\\phi(\\mathbf{x})$ 隐式描述的裂纹 $\\Gamma_c$。\n- 亥维赛函数 $H(\\phi(\\mathbf{x})) \\in \\{-1,+1\\}$ 表示裂纹的两侧。\n- 外边界 $\\partial \\Omega$ 分解为狄利克雷部分 $\\Gamma_D$ 和诺伊曼部分 $\\Gamma_N$。\n- 在 $\\Gamma_D$ 上给定一个位移 $\\bar{\\mathbf{u}}(\\mathbf{x})$。\n- 扩展有限元法 (XFEM) 的位移近似由下式给出：\n$$\n\\mathbf{u}_h(\\mathbf{x}) \\;=\\; \\sum_{i \\in I} N_i(\\mathbf{x})\\,\\mathbf{u}_i \\;+\\; \\sum_{j \\in I_H} N_j(\\mathbf{x})\\,H(\\phi(\\mathbf{x}))\\,\\mathbf{a}_j \\;+\\; \\sum_{k \\in I_T} N_k(\\mathbf{x}) \\sum_{\\alpha=1}^{4} F_\\alpha(\\mathbf{x})\\,\\mathbf{b}_{k\\alpha}\n$$\n- $N_i(\\mathbf{x})$ 是标准的拉格朗日形函数，满足 $N_i(\\mathbf{x}_i)=1$ 和 $N_{m \\neq i}(\\mathbf{x}_i)=0$。\n- $\\{\\mathbf{u}_i\\}$、$\\{\\mathbf{a}_j\\}$ 和 $\\{\\mathbf{b}_{k\\alpha}\\}$ 分别是标准、亥维赛增强和裂纹尖端增强的自由度 (DOF)。\n- 在实现中使用了形式为 $N_j(\\mathbf{x})\\,[H(\\phi(\\mathbf{x}))-H(\\phi(\\mathbf{x}_j))]$ 的移位增强。\n- 核心问题考虑裂纹 $\\Gamma_c$ 与狄利克雷边界 $\\Gamma_D$ 在点 $\\mathbf{x}^\\ast$ 处相交的情况。\n- 目标是找到一种在不使系统过度约束的情况下，在 $\\Gamma_D$ 上施加狄利克雷条件的方法。\n\n### 步骤 2：使用提取的已知信息进行验证\n1.  **科学基础**：该问题牢固地植根于计算力学领域，特别是应用于断裂力学的扩展有限元法。所提供的 XFEM 公式是标准的。在被不连续面切割的单元上施加狄利克雷边界条件的问题，是 XFEM 中一个有据可查、至关重要且非平凡的挑战。所使用的所有概念（水平集、单位分解、增强函数）在该领域都是标准的。该问题在科学上是有效的。\n2.  **适定性**：该问题要求从给定列表中识别描述有效数值程序的正确陈述。这是一个定义明确、目标清晰的任务。\n3.  **客观性**：语言精确、正式且技术性强。问题设置中没有主观或基于观点的陈述。\n\n问题陈述没有表现出任何诸如科学上不合理、不完整、矛盾或模棱两可的缺陷。它描述了计算断裂力学中一个标准但复杂的情况。\n\n### 步骤 3：结论与行动\n问题有效。现在开始求解过程。\n\n### 推导与选项分析\n\n在与裂纹相交的边界上施加狄利克雷边界条件的核心问题在于，单个增强节点对裂纹两侧的位移场都有贡献。然而，边界条件仅适用于物理边界，该边界位于裂纹的一侧。对与边界节点相关的所有自由度进行朴素的强施加可能导致系统被过度约束，从而人为地限制了裂纹的张开运动学，产生物理上不正确的结果。\n\n我们考虑边界 $\\Gamma_D$ 上的一个节点 $j$，其支集被裂纹 $\\Gamma_c$ 切割。在节点 $j$ 支集内的点 $\\mathbf{x} \\in \\Gamma_D$ 处的位移由 $\\mathbf{u}_h(\\mathbf{x})$ 的迹给出。假设这部分边界对应于裂纹的“+”侧，其中 $H(\\phi(\\mathbf{x})) = +1$。位移迹为：\n$$\n\\mathbf{u}_h^+(\\mathbf{x}) = \\sum_{i \\in I} N_i(\\mathbf{x})\\,\\mathbf{u}_i + \\sum_{j' \\in I_H} N_{j'}(\\mathbf{x})\\,(+1)\\,\\mathbf{a}_{j'} + \\dots\n$$\n狄利克雷条件要求对于所有 $\\mathbf{x} \\in \\Gamma_D$，都有 $\\mathbf{u}_h^+(\\mathbf{x}) = \\bar{\\mathbf{u}}(\\mathbf{x})$。这对标准自由度 $\\{\\mathbf{u}_i\\}$ 和增强自由度 $\\{\\mathbf{a}_j\\}$ 的线性组合施加了约束。然而，增强自由度 $\\{\\mathbf{a}_j\\}$ 也定义了裂纹另一侧（裂纹面）的位移，而这一侧不属于 $\\Gamma_D$：\n$$\n\\mathbf{u}_h^-(\\mathbf{x}) = \\sum_{i \\in I} N_i(\\mathbf{x})\\,\\mathbf{u}_i + \\sum_{j' \\in I_H} N_{j'}(\\mathbf{x})\\,(-1)\\,\\mathbf{a}_{j'} + \\dots\n$$\n裂纹张开量与 $\\mathbf{u}_h^+ - \\mathbf{u}_h^-$ 成正比，这直接与增强自由度 $\\{\\mathbf{a}_j\\}$ 相关。边界条件对 $\\{\\mathbf{a}_j\\}$ 的不当约束因此会污染裂纹张开的物理特性。问题中提到的移位增强 $N_j(\\mathbf{x})\\,[H(\\phi(\\mathbf{x}))-H(\\phi(\\mathbf{x}_j))]$ 简化了节点处的强施加，但并未解决在整个边界单元面上约束函数的基本问题。\n\n我们现在将根据每个选项提供一致且适定的边界条件施加方法的能力来评估它们。\n\n**选项 A: 预先将与 $\\Gamma_D$ 上节点相关的所有增强自由度设置为零，并通过仅强施加 $\\Gamma_D$ 上的标准自由度 $\\{\\mathbf{u}_i\\}$ 来强制 $\\mathbf{u}_h=\\bar{\\mathbf{u}}$。这通过消除边界处的增强来避免任何额外的约束。**\n\n该方法建议对所有在 $\\Gamma_D$ 上的节点 $j,k$，设置 $\\mathbf{a}_j = \\mathbf{0}$ 和 $\\mathbf{b}_{k\\alpha} = \\mathbf{0}$。当增强自由度为零时，这些节点支集内的 XFEM 近似退化为标准 FEM 近似，即 $\\mathbf{u}_h(\\mathbf{x}) = \\sum N_i(\\mathbf{x})\\mathbf{u}_i$。然后可以对标准自由度 $\\{\\mathbf{u}_i\\}$ 强施加狄利克雷条件，而不会产生过度约束。虽然这个过程在数学上很简单，并且可以得到一个可解的系统，但它与裂纹到达边界的问题在物理上不一致。将增强自由度设置为零会迫使与边界节点相关的整个增强区域内裂纹两侧的位移跳跃为零。这实际上是在边界附近的有限区域内“愈合”或“闭合”了裂纹，这是一个重大且通常不正确的建模错误。这是一种为了方便而牺牲精度的过于简化的方法。从严谨的角度来看，它不是一种一致的施加方法，因为它未能正确地表示问题的物理特性。\n\n**结论：不正确。**\n\n**选项 B: 使用弱施加方法（如拉格朗日乘子法、尼采法或罚函数法），将狄利克雷条件施加在沿实际边界侧的物理边界迹 $\\mathbf{u}_h^\\pm$ 上，该方法在 $\\Gamma_D$ 上积分，因此约束仅作用于构成边界侧迹的标准自由度和增强自由度的线性组合上；仅对另一侧裂纹面有贡献的增强自由度不受边界条件的约束。**\n\n该陈述准确地描述了解决此问题的现代且最稳健的方法。弱施加方法在 $\\Gamma_D$ 上以积分意义强制施加条件 $\\mathbf{u}_h = \\bar{\\mathbf{u}}$。例如，罚函数法向势能中添加一项，如 $\\frac{\\beta}{2}\\int_{\\Gamma_D} (\\mathbf{u}_h - \\bar{\\mathbf{u}}) \\cdot (\\mathbf{u}_h - \\bar{\\mathbf{u}}) \\,d\\Gamma$，其中 $\\beta$ 是一个大的罚参数。因为积分是在物理边界 $\\Gamma_D$ 上进行的，所以它只涉及 $\\mathbf{u}_h$ 在裂纹相关侧（例如 $\\mathbf{u}_h^+$）的迹。该公式自然地将约束应用于构成该迹的 $\\{\\mathbf{u}_i\\}$、$\\{\\mathbf{a}_j\\}$ 等的特定线性组合。自由度不是预先被单独约束的。最终的方程组以一种既满足体平衡方程又以弱形式满足边界条件的方式，确定了包括增强自由度在内的所有自由度的值。该方法不会对裂纹张开施加任何人为约束，并已被证明是一致的且能产生最优收敛率。尼采法是此类技术中一种特别流行且优雅的方法。该描述精确且正确。\n\n**结论：正确。**\n\n**选项 C: 通过将标准自由度和这些节点上的所有增强自由度都设置为给定（prescribed）位移 $\\bar{\\mathbf{u}}(\\mathbf{x}_i)$，来强施加所有边界节点上的节点值，从而对被裂纹切割的边界节点上存在的每个自由度强制施加相同的位移。**\n\n这种方法在根本上是有缺陷的。标准自由度 $\\mathbf{u}_i$ 代表节点位移，而增强自由度 $\\mathbf{a}_j$ 代表裂纹两侧的位移跳跃大小。它们在物理上和量纲上都是不同的量。设置 $\\mathbf{a}_j = \\bar{\\mathbf{u}}(\\mathbf{x}_j)$ 在物理上是无意义的，并且构成了对裂纹张开的一个任意、不正确的约束。即使将 $\\mathbf{a}_j$ 设置为 $\\mathbf{0}$，这仍然是一个临时的约束。试图对不同类型的自由度强制施加相同的值，是基于对 XFEM 基函数的误解而导致系统过度约束的典型例子。\n\n**结论：不正确。**\n\n**选项 D: 通过将增强函数乘以一个在 $\\Gamma_D$ 上为零且在远离 $\\Gamma_D$ 处为正的 $C^0$ 斜坡函数 $r(\\mathbf{x})$ 来修正 $\\Gamma_D$ 附近的增强，使得增强对边界迹的贡献在 $\\Gamma_D$ 上恒等于零；然后仅对标准自由度强施加狄利克雷条件。这消除了在 $\\Gamma_D$ 上约束增强自由度的需要，并防止了过度约束。**\n\n这描述了一种有效且已知的技术，通常被称为“渐逝增强”或“边界修正XFEM”。近似的增强部分被修改，例如修改为 $N_j(\\mathbf{x}) r(\\mathbf{x}) H(\\phi(\\mathbf{x})) \\mathbf{a}_j$。由于斜坡函数 $r(\\mathbf{x})$ 被构造成对于任何 $\\mathbf{x} \\in \\Gamma_D$ 都为零，因此整个增强项在狄利克雷边界上消失。因此，位移在 $\\Gamma_D$ 上的迹变为 $\\mathbf{u}_h|_{\\Gamma_D} = \\sum N_i(\\mathbf{x}) \\mathbf{u}_i|_{\\Gamma_D}$。然后可以通过标准自由度强施加狄利克雷条件（例如，对于 $\\Gamma_D$ 上的节点，$\\mathbf{u}_i = \\bar{\\mathbf{u}}(\\mathbf{x}_i)$），而没有任何过度约束的风险，因为增强自由度 $\\{\\mathbf{a}_j\\}$ 不会出现在边界约束方程中。该方法提供了一种数学上一致的方式来构建一个适定的问题。它隐含地施加了裂纹张开量在边界上恰好为零的物理约束，这比选项 A 的方法更局部化和精细。这是 XFEM 文献中一种公认的方法。\n\n**结论：正确。**\n\n**选项 E: 将每个被切割的边界节点复制为两个重合的节点，每个裂纹侧一个，保留两组增强自由度，并对两个复制节点施加相同的给定（prescribed）位移，以使两个边界侧迹在节点处接收相同的狄利克雷数据；这保证了在 XFEM 中对被切割的边界节点进行非过度约束的施加。**\n\n这个过程在概念上与 XFEM 的基本原理不一致。XFEM 在一个固定的、底层的网格上丰富近似空间，而不改变网格的连接性或拓扑结构。复制节点是一种拓扑修改，是其他方法的特征，例如带有不连续界面单元的标准有限元或一些幻影节点法。问题中给出的基于单组单位分解函数 $\\{N_i\\}$ 的 XFEM 公式与重合但不同的节点概念不兼容。这个选项描述的是一种完全不同的方法，并将其错误地表述为一种 XFEM 程序。\n\n**结论：不正确。**", "answer": "$$\\boxed{BD}$$", "id": "3524306"}]}