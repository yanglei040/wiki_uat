{"hands_on_practices": [{"introduction": "扩展有限元法（XFEM）的基础在于修正被不连续面切割的单元的刚度矩阵。第一个练习提供了一个从第一性原理出发，亲手实现这一核心概念的机会。通过计算单个三角形单元的增强刚度贡献，你将对亥维赛德（Heaviside）增强函数如何改变单元的力学响应获得具体的理解。", "problem": "考虑一个在平面应变条件下的二维小应变、各向同性、线性弹性问题中的单个线性三角形有限元，该单元被一个由水平集场隐式表示的直线裂纹所穿过。使用带有位移富集函数的 Heaviside 富集来捕捉单元内裂纹上的位移跳跃。该裂纹由一个通过节点值指定的分段线性标量场的零水平集表示。假设裂纹是无牵引力的，并且 Heaviside 函数在由水平集符号定义的每个积分子域内是恒定的。\n\n对于每个测试用例，您必须计算仅与富集自由度相关的单元级刚度贡献。请使用子单元求积法，其中包含两个分别对应于正负水平集区域的积分子域。每个测试用例的结果是富集-富集刚度子矩阵，该矩阵以行主序展平。\n\n推导和实现需基于以下第一性原理：\n- 使用虚功原理，其中双线性形式涉及应变-位移算子和本构算子的乘积在域上的积分。假设平面应变弹性，厚度为 $t$。\n- 使用标准的线性三角形形函数，其空间梯度在整个单元上是恒定的。\n- 通过水平集函数 $\\phi(\\mathbf{x})$ 来表示裂纹，该函数通过其节点值在单元上呈线性变化。将 Heaviside 函数定义为：当 $\\phi \\ge 0$ 时，$H(\\phi) = +1$；当 $\\phi  0$ 时，$H(\\phi) = -1$。采用 $H(0)=+1$ 的约定。\n- 在节点 $i$ 处使用位移的 Heaviside 富集，其形式为 $H(\\phi(\\mathbf{x})) - H(\\phi_i)$，其中 $\\phi_i$ 是节点 $i$ 处的节点水平集值。\n\n积分要求：\n- 通过使用直线 $\\phi(\\mathbf{x})=0$ 切割三角形，将三角形划分为两个积分子域。该直线是通过沿每条边对 $\\phi$ 进行线性插值得到的。正子域为 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) \\ge 0\\}$，负子域为 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) \\le 0\\}$。假设 Heaviside 函数在每个子域内是恒定的，并在这两个子域上分别进行积分。\n- 使用基于沿边线性插值的精确多边形裁剪来找到子域多边形及其面积。由于使用的是线性三角形，最终的刚度贡献可以表示为子域面积和恒定应变-位移矩阵的函数。\n\n材料和运动学数据：\n- 杨氏模量 $E$ 和泊松比 $\\nu$ 定义了平面应变本构矩阵。\n- 刚度需乘以单元厚度 $t$。\n- 单元有三个节点，其坐标为 $(x_i,y_i)$，节点水平集值为 $\\phi_i$。\n\n富集与输出：\n- 使用上述的位移 Heaviside 富集方法，对所有三个单元节点的每个节点的两个位移分量（水平和垂直）进行富集。\n- 按照 $[u_{1x}^{\\mathrm{enr}}, u_{1y}^{\\mathrm{enr}}, u_{2x}^{\\mathrm{enr}}, u_{2y}^{\\mathrm{enr}}, u_{3x}^{\\mathrm{enr}}, u_{3y}^{\\mathrm{enr}}]$ 的顺序，组装与三个节点上的富集自由度相对应的 $6 \\times 6$ 富集-富集刚度子矩阵。\n\n物理单位：\n- 使用国际单位制 (SI)。输入长度单位为米， $E$ 的单位为帕斯卡，厚度 $t$ 的单位为米。\n- 刚度条目的单位表示为牛顿/米 $[\\mathrm{N/m}]$。\n\n测试套件：\n实现您的程序，为以下三种情况计算富集-富集刚度子矩阵。在每种情况下，使用指定的节点坐标 $(x_i,y_i)$ 和水平集值 $\\phi_i$，且三种情况下的材料参数和厚度均相同。\n\n- 情况 1（正常情况）：\n  - 节点：$(x_1,y_1) = (0,0)$，$(x_2,y_2) = (2,0)$，$(x_3,y_3) = (0,1)$。\n  - 水平集值：$\\phi_1 = -0.2$，$\\phi_2 = +0.3$，$\\phi_3 = +0.4$。\n- 情况 2（顶点在裂纹上的边界条件）：\n  - 节点：$(x_1,y_1) = (0,0)$，$(x_2,y_2) = (1.5,0)$，$(x_3,y_3) = (0.5,1.0)$。\n  - 水平集值：$\\phi_1 = 0.0$，$\\phi_2 = +0.5$，$\\phi_3 = -0.5$。\n- 情况 3（切割面积非常小的边缘情况）：\n  - 节点：$(x_1,y_1) = (0,0)$，$(x_2,y_2) = (2,0)$，$(x_3,y_3) = (0,1)$。\n  - 水平集值：$\\phi_1 = -0.001$，$\\phi_2 = +0.001$，$\\phi_3 = +0.001$。\n\n所有情况下的材料参数和厚度：\n- 杨氏模量：$E = 30 \\times 10^{9}\\ \\mathrm{Pa}$。\n- 泊松比：$\\nu = 0.25$。\n- 厚度：$t = 1.0\\ \\mathrm{m}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，每个内部列表是对应测试用例的以行主序展平的富集-富集刚度子矩阵。例如，输出格式必须完全是：\n  - $[ [k_{11}, k_{12}, \\ldots, k_{16}, \\ldots, k_{66}], [\\ldots], [\\ldots] ]$\n- 条目必须是表示刚度的浮点数，单位为 $[\\mathrm{N/m}]$。", "solution": "该问题要求计算一个在平面应变条件下、被直线裂纹穿过的单个线性三角形有限元的富集-富集刚度子矩阵，记为 $\\mathbf{K}^{\\mathrm{bb}}$。裂纹由一个分段线性水平集函数 $\\phi(\\mathbf{x})$ 隐式表示。该公式基于扩展有限元法 (XFEM)，并使用位移的 Heaviside 富集。\n\n刚度矩阵源于虚功原理，该原理指出内功的变分等于外功的变分。对于线性弹性体，内部虚功通过包含应变 $\\boldsymbol{\\epsilon}$ 和应力 $\\boldsymbol{\\sigma}$ 的双线性形式表示：\n$$ a(\\delta \\mathbf{u}, \\mathbf{u}) = \\int_{\\Omega^e} \\boldsymbol{\\epsilon}(\\delta \\mathbf{u})^T \\boldsymbol{\\sigma}(\\mathbf{u}) \\, d\\Omega = \\int_{\\Omega^e} \\boldsymbol{\\epsilon}(\\delta \\mathbf{u})^T \\mathbf{D} \\, \\boldsymbol{\\epsilon}(\\mathbf{u}) \\, d\\Omega $$\n其中 $\\delta \\mathbf{u}$ 是虚位移场，$\\mathbf{u}$ 是位移场，$\\boldsymbol{\\epsilon}$ 是应变向量（采用 Voigt 记法），$\\mathbf{D}$ 是材料本构矩阵，$\\Omega^e$ 是单元域。对于此问题，我们还必须乘以单元厚度 $t$。\n\n单元内的位移场 $\\mathbf{u}(\\mathbf{x})$ 使用 XFEM 框架进行近似。它包括一个标准部分和一个富集部分：\n$$ \\mathbf{u}(\\mathbf{x}) = \\sum_{i=1}^{3} N_i(\\mathbf{x})\\mathbf{u}_i + \\sum_{j=1}^{3} N_j(\\mathbf{x}) F_j(\\mathbf{x}) \\mathbf{b}_j $$\n此处，$N_i(\\mathbf{x})$ 是标准线性三角形形函数，$\\mathbf{u}_i$ 是标准节点位移向量，$\\mathbf{b}_j$ 是富集节点位移向量。节点 $j$ 的富集函数是位移的 Heaviside 函数，定义为 $F_j(\\mathbf{x}) = H(\\phi(\\mathbf{x})) - H(\\phi_j)$，其中 $\\phi_j$ 是节点 $j$ 处的水平集值。Heaviside 函数的定义为：当 $\\phi \\ge 0$ 时，$H(\\phi)=+1$；当 $\\phi  0$ 时，$H(\\phi)=-1$。\n\n我们只关心来自富集自由度 $\\mathbf{b}_j$ 的刚度贡献。对应于位移富集部分 $\\mathbf{u}^{\\mathrm{b}}(\\mathbf{x}) = \\sum_{j=1}^{3} N_j(\\mathbf{x}) F_j(\\mathbf{x}) \\mathbf{b}_j$ 的应变场，可通过应用微分应变-位移算子得到，其矩阵形式为 $\\boldsymbol{\\epsilon}^{\\mathrm{b}} = \\sum_{j=1}^{3} \\mathbf{B}_j^{\\mathrm{b}} \\mathbf{b}_j$。\n\n问题指出，积分在两个子域上执行，即 $\\Omega^+ = \\{\\mathbf{x} \\in \\Omega^e \\mid \\phi(\\mathbf{x}) \\ge 0\\}$ 和 $\\Omega^- = \\{\\mathbf{x} \\in \\Omega^e \\mid \\phi(\\mathbf{x})  0\\}$，并且在每个子域内，假定 Heaviside 函数 $H(\\phi(\\mathbf{x}))$ 是常数。在 $\\Omega^+$ 中，$H(\\phi(\\mathbf{x}))=+1$；在 $\\Omega^-$ 中，$H(\\phi(\\mathbf{x}))=-1$。这意味着富集函数的梯度 $\\nabla F_j(\\mathbf{x})$ 在每个子域内为零。因此，富集部分的应变-位移矩阵 $\\mathbf{B}_j^{\\mathrm{b}}$ 被简化为：\n$$ \\mathbf{B}_j^{\\mathrm{b}}(\\mathbf{x}) = \\nabla_s (N_j(\\mathbf{x}) F_j(\\mathbf{x})) = (\\nabla N_j) F_j(\\mathbf{x}) + N_j (\\nabla F_j) \\approx (\\nabla N_j) F_j(\\mathbf{x}) $$\n对于线性三角形，形函数的梯度 $\\nabla N_j$ 是恒定的。节点 $j$ 的标准应变-位移矩阵 $\\mathbf{B}_j$ 也是恒定的。因此，$\\mathbf{B}_j^{\\mathrm{b}}(\\mathbf{x}) = \\mathbf{B}_j F_j(\\mathbf{x})$。\n\n富集-富集刚度矩阵中耦合节点 $i$ 和 $j$ 的富集自由度 (DOF) 的 $2 \\times 2$ 子块 $\\mathbf{K}_{ij}^{\\mathrm{bb}}$ 由以下公式给出：\n$$ \\mathbf{K}_{ij}^{\\mathrm{bb}} = t \\int_{\\Omega^e} (\\mathbf{B}_i^{\\mathrm{b}})^T \\mathbf{D} \\, \\mathbf{B}_j^{\\mathrm{b}} \\, d\\Omega = t \\int_{\\Omega^e} (\\mathbf{B}_i F_i(\\mathbf{x}))^T \\mathbf{D} \\, (\\mathbf{B}_j F_j(\\mathbf{x})) \\, d\\Omega $$\n由于 $\\mathbf{B}_i$、$\\mathbf{B}_j$ 和 $\\mathbf{D}$ 是常数矩阵，它们可以从积分中提出：\n$$ \\mathbf{K}_{ij}^{\\mathrm{bb}} = t \\, (\\mathbf{B}_i)^T \\mathbf{D} \\, \\mathbf{B}_j \\int_{\\Omega^e} F_i(\\mathbf{x}) F_j(\\mathbf{x}) \\, d\\Omega $$\n积分项通过划分域来计算：\n$$ I_{ij} = \\int_{\\Omega^e} F_i(\\mathbf{x}) F_j(\\mathbf{x}) \\, d\\Omega = \\int_{\\Omega^+} F_i(\\mathbf{x})F_j(\\mathbf{x}) \\, d\\Omega + \\int_{\\Omega^-} F_i(\\mathbf{x})F_j(\\mathbf{x}) \\, d\\Omega $$\n在每个子域内，富集函数是常数。令 $H_k = H(\\phi_k)$。\n在 $\\Omega^+$ 中，$F_k(\\mathbf{x}) = +1 - H_k$。\n在 $\\Omega^-$ 中，$F_k(\\mathbf{x}) = -1 - H_k$。\n让我们定义系数 $s_k^+$ 和 $s_k^-$：\n如果 $\\phi_k \\ge 0$，则 $H_k = +1$。这意味着在 $\\Omega^+$ 中 $F_k(\\mathbf{x}) = 1-1=0$，在 $\\Omega^-$ 中 $F_k(\\mathbf{x}) = -1-1=-2$。所以，$s_k^+=0$，$s_k^-=-2$。\n如果 $\\phi_k  0$，则 $H_k = -1$。这意味着在 $\\Omega^+$ 中 $F_k(\\mathbf{x}) = 1-(-1)=2$，在 $\\Omega^-$ 中 $F_k(\\mathbf{x}) = -1-(-1)=0$。所以，$s_k^+=2$，$s_k^-=0$。\n积分变为：\n$$ I_{ij} = s_i^+ s_j^+ \\int_{\\Omega^+} d\\Omega + s_i^- s_j^- \\int_{\\Omega^-} d\\Omega = (s_i^+ s_j^+) A^+ + (s_i^- s_j^-) A^- $$\n其中 $A^+$ 和 $A^-$ 分别是正子域和负子域的面积。\n\n计算步骤如下：\n1.  对于给定节点为 $(\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3)$ 的三角形单元，计算其总面积 $A$ 和 $i=1,2,3$ 时的常数应变-位移矩阵 $\\mathbf{B}_i$：\n    $$ A = \\frac{1}{2} |x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)| $$\n    $$ \\mathbf{B}_i = \\frac{1}{2A} \\begin{bmatrix} y_j-y_k  0 \\\\ 0  x_k-x_j \\\\ x_k-x_j  y_j-y_k \\end{bmatrix} \\quad \\text{对于循环的 } (i,j,k) $$\n2.  计算平面应变本构矩阵 $\\mathbf{D}$：\n    $$ \\mathbf{D} = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1  \\frac{\\nu}{1-\\nu}  0 \\\\ \\frac{\\nu}{1-\\nu}  1  0 \\\\ 0  0  \\frac{1-2\\nu}{2(1-\\nu)} \\end{bmatrix} $$\n3.  通过用直线 $\\phi(\\mathbf{x})=0$ 切割三角形来确定子域 $\\Omega^+$ 和 $\\Omega^-$。该直线通过对节点 $\\phi_i$ 值进行线性插值得到。计算面积 $A^+$ 和 $A^-$。如果单元未被裂纹切割（即所有 $\\phi_i$ 具有相同的符号状态），则一个面积为 $A$，另一个为 $0$。如果单元被切割，直线 $\\phi(\\mathbf{x})=0$ 与两条边相交，将三角形划分为一个较小的三角形和一个四边形。计算这些多边形的面积。\n4.  对于每个节点 $i=1,2,3$，根据 $\\phi_i$ 的符号确定系数 $s_i^+$ 和 $s_i^-$。\n5.  从其 $2 \\times 2$ 子块 $\\mathbf{K}_{ij}^{\\mathrm{bb}}$（其中 $i,j \\in \\{1,2,3\\}$）组装完整的 $6 \\times 6$ 矩阵 $\\mathbf{K}^{\\mathrm{bb}}$：\n    $$ \\mathbf{K}_{ij}^{\\mathrm{bb}} = t \\, \\left( (s_i^+ s_j^+) A^+ + (s_i^- s_j^-) A^- \\right) \\, (\\mathbf{B}_i)^T \\mathbf{D} \\, \\mathbf{B}_j $$\n    这些子块根据自由度 (DOF) 排序 $[u_{1x}^{\\mathrm{enr}}, u_{1y}^{\\mathrm{enr}}, u_{2x}^{\\mathrm{enr}}, u_{2y}^{\\mathrm{enr}}, u_{3x}^{\\mathrm{enr}}, u_{3y}^{\\mathrm{enr}}]$ 放置在矩阵中。\n6.  最终结果是将 $6 \\times 6$ 矩阵 $\\mathbf{K}^{\\mathrm{bb}}$ 以行主序展平为向量。\n此过程将应用于每个测试用例。", "answer": "```python\nimport numpy as np\n\ndef compute_stiffness_submatrix(nodes, phis, E, nu, t):\n    \"\"\"\n    Computes the enriched-enriched stiffness submatrix for a cracked linear triangle.\n\n    Args:\n        nodes (list of tuples): Coordinates of the 3 element nodes [(x1,y1), (x2,y2), (x3,y3)].\n        phis (tuple): Nodal level set values (phi1, phi2, phi3).\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        t (float): Element thickness.\n\n    Returns:\n        list: The 6x6 enriched-enriched stiffness matrix, flattened in row-major order.\n    \"\"\"\n    node_coords = np.array(nodes, dtype=float)\n    x = node_coords[:, 0]\n    y = node_coords[:, 1]\n\n    # 1. Compute element geometric properties (Area A, B matrices)\n    A_total = 0.5 * np.abs(x[0]*(y[1]-y[2]) + x[1]*(y[2]-y[0]) + x[2]*(y[0]-y[1]))\n    if A_total == 0:\n        return [0.0] * 36\n\n    # Gradients of shape functions\n    dN_dx = np.array([y[1]-y[2], y[2]-y[0], y[0]-y[1]]) / (2 * A_total)\n    dN_dy = np.array([x[2]-x[1], x[0]-x[2], x[1]-x[0]]) / (2 * A_total)\n\n    # B matrices\n    B_matrices = []\n    for i in range(3):\n        B_i = np.array([\n            [dN_dx[i], 0],\n            [0, dN_dy[i]],\n            [dN_dy[i], dN_dx[i]]\n        ])\n        B_matrices.append(B_i)\n\n    # 2. Compute plane strain constitutive matrix D\n    d_const = E * (1 - nu) / ((1 + nu) * (1 - 2 * nu))\n    D = d_const * np.array([\n        [1, nu / (1 - nu), 0],\n        [nu / (1 - nu), 1, 0],\n        [0, 0, (1 - 2 * nu) / (2 * (1 - nu))]\n    ])\n\n    # 3. Determine subdomain areas A+ and A-\n    pos_nodes_idx = [i for i, phi in enumerate(phis) if phi >= 0]\n    neg_nodes_idx = [i for i, phi in enumerate(phis) if phi  0]\n\n    A_pos, A_neg = 0.0, 0.0\n\n    if len(pos_nodes_idx) == 3:\n        A_pos = A_total\n    elif len(neg_nodes_idx) == 3:\n        A_neg = A_total\n    else:  # Element is cut\n        # This function interpolates to find the point on an edge where phi=0\n        def get_intersection(p1_idx, p2_idx):\n            phi1, phi2 = phis[p1_idx], phis[p2_idx]\n            pt1, pt2 = node_coords[p1_idx], node_coords[p2_idx]\n            # using formula p = (phi2*p1 - phi1*p2) / (phi2-phi1) for robustness even if one is 0\n            return (phi2 * pt1 - phi1 * pt2) / (phi2 - phi1)\n\n        def polygon_area(verts):\n            if len(verts)  3:\n                return 0.0\n            # Shoelace formula\n            area = 0.0\n            for i in range(len(verts)):\n                p1 = verts[i]\n                p2 = verts[(i + 1) % len(verts)]\n                area += p1[0] * p2[1] - p2[0] * p1[1]\n            return 0.5 * np.abs(area)\n        \n        # Identify the single node and the two other nodes\n        if len(neg_nodes_idx) == 1:\n            single_node_idx = neg_nodes_idx[0]\n            other_nodes_idx = pos_nodes_idx\n            is_single_node_neg = True\n        else: # len(pos_nodes_idx) == 1\n            single_node_idx = pos_nodes_idx[0]\n            other_nodes_idx = neg_nodes_idx\n            is_single_node_neg = False\n            \n        p_s = node_coords[single_node_idx]\n        \n        p_int1 = get_intersection(single_node_idx, other_nodes_idx[0])\n        p_int2 = get_intersection(single_node_idx, other_nodes_idx[1])\n        \n        small_poly_verts = [p_s, p_int1, p_int2]\n        small_area = polygon_area(small_poly_verts)\n\n        if is_single_node_neg:\n            A_neg = small_area\n            A_pos = A_total - A_neg\n        else:\n            A_pos = small_area\n            A_neg = A_total - A_pos\n\n    # 4. Determine s factors\n    s_pos, s_neg = [], []\n    for phi in phis:\n        if phi >= 0: # Node on positive side or on crack\n            s_pos.append(0)\n            s_neg.append(-2)\n        else: # Node on negative side\n            s_pos.append(2)\n            s_neg.append(0)\n\n    # 5. Assemble K_bb\n    K_bb = np.zeros((6, 6))\n    M_ij_cache = {} # Cache for (Bi^T * D * Bj)\n\n    for i in range(3):\n        for j in range(3):\n            # Calculate integral term I_ij\n            I_ij = (s_pos[i] * s_pos[j]) * A_pos + (s_neg[i] * s_neg[j]) * A_neg\n            \n            if I_ij == 0:\n                continue\n\n            # Calculate matrix product part (Bi^T * D * Bj)\n            # Use symmetry to reduce calculations\n            if (i, j) in M_ij_cache:\n                M_ij = M_ij_cache[(i,j)]\n            elif (j,i) in M_ij_cache:\n                M_ij = M_ij_cache[(j,i)].T\n            else:\n                M_ij = B_matrices[i].T @ D @ B_matrices[j]\n                M_ij_cache[(i,j)] = M_ij\n\n            K_ij_block = t * I_ij * M_ij\n\n            # Place block in the 6x6 matrix\n            row_start, col_start = 2 * i, 2 * j\n            K_bb[row_start:row_start+2, col_start:col_start+2] = K_ij_block\n\n    # 6. Flatten and return\n    return K_bb.flatten().tolist()\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Material and geometry parameters\n    E = 30.0e9  # Pa\n    nu = 0.25\n    t = 1.0     # m\n\n    # Test suite\n    test_cases = [\n        {\n            \"nodes\": ((0.0, 0.0), (2.0, 0.0), (0.0, 1.0)),\n            \"phis\": (-0.2, 0.3, 0.4)\n        },\n        {\n            \"nodes\": ((0.0, 0.0), (1.5, 0.0), (0.5, 1.0)),\n            \"phis\": (0.0, 0.5, -0.5)\n        },\n        {\n            \"nodes\": ((0.0, 0.0), (2.0, 0.0), (0.0, 1.0)),\n            \"phis\": (-0.001, 0.001, 0.001)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        stiffness_flat = compute_stiffness_submatrix(case[\"nodes\"], case[\"phis\"], E, nu, t)\n        results.append(stiffness_flat)\n\n    # Format output as specified\n    formatted_results = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    print(formatted_results)\n\nsolve()\n\n```", "id": "3523124"}, {"introduction": "虽然增强近似空间使我们能够模拟不连续性，但如果处理不当，也可能引入数值伪影。本练习使用一个简单的一维杆来演示因在裂纹邻近的未增强单元中违反单位分解（partition of unity）特性而产生的“污染误差”。通过将 XFEM 解与精确解进行比较，你将量化此误差，并体会到更先进的混合策略的必要性。", "problem": "考虑一根长度为 $L$、横截面积恒为 $A$ 的一维小应变线性弹性杆。材料的杨氏模量为 $E$。该杆占据区间 $x \\in [0,L]$。在 $x = x_c$ 处有一条内部无牵引力裂纹，其被建模为位移的强不连续性，由符号距离函数 $\\phi(x) = x - x_c$ 的零水平集表示。边界条件为本质边界条件：$u(0) = 0$ 和 $u(L) = \\bar{u}$。无体力或外部牵引力。单位必须统一使用国际单位制（SI）：$L$ 的单位为米，$A$ 的单位为平方米，$E$ 的单位为帕斯卡，$\\bar{u}$ 的单位为米。最终答案必须以米为单位报告位移。\n\n离散化采用扩展有限元法 (XFEM)，并使用 Heaviside 增强来表示跨裂纹的位移跳跃。离散近似解为\n$$\nu_h(x) = \\sum_{i=0}^{N} N_i(x) \\, u_i + \\sum_{i \\in \\mathcal{E}} N_i(x) \\left( H(x) - H(x_i) \\right) a_i,\n$$\n其中 $N_i(x)$ 是在包含 $N$ 个单元和 $N+1$ 个节点的均匀网格上的标准线性形函数，$u_i$ 是标准节点位移，$a_i$ 是与 Heaviside 增强相关的增强自由度，$\\mathcal{E}$ 是其支承域被裂纹切割的节点集合，$H(x)$ 是 Heaviside 函数，定义为当 $x \\ge x_c$ 时 $H(x) = +1$，当 $x  x_c$ 时 $H(x) = -1$。在本问题中，混合修正（也称为用于在混合单元中恢复单位分解特性的斜坡函数或修正函数）被有意忽略。这意味着增强函数完全按照所写的形式使用，在与被切割单元相邻的单元中没有施加额外的修正。\n\n控制弱形式源于一维小应变弹性力学的虚功原理：寻找 $u \\in \\mathcal{U}$ 使得\n$$\n\\int_{0}^{L} E A \\, u'(x) \\, v'(x) \\, dx = 0 \\quad \\text{for all } v \\in \\mathcal{V},\n$$\n其中 $u(0) = 0$ 且 $u(L) = \\bar{u}$，$\\mathcal{V}$ 是在 $0$ 和 $L$ 处为零的容许变分空间。内部裂纹面是无牵引力的。增强允许 $u$ 在 $x_c$ 处不连续，而体积分的计算仅通过将被切割单元分裂成 $H(x)$ 为常数的子域来完成。所有积分都在 $H(x)$ 为常数的子域上分段执行；不使用混合修正。\n\n对于这个带有无牵引力内部裂纹的边值问题，其精确解是在给定边界条件下弹性势能的极小值点，因此是分段常数：\n$$\nu_{\\text{exact}}(x) = \\begin{cases}\n0,  x  x_c, \\\\\n\\bar{u},  x \\ge x_c.\n\\end{cases}\n$$\n因此，在中点 $x_m = L/2$ 处的精确位移为\n$$\nu_{\\text{exact}}(L/2) = \\begin{cases}\n0,  L/2  x_c, \\\\\n\\bar{u},  L/2 \\ge x_c.\n\\end{cases}\n$$\n\n任务：实现一个程序，为所述的一维杆组装 XFEM 刚度矩阵，使用 Heaviside 增强且不进行任何混合修正。使用均匀线性有限元，并仅将被切割单元分裂成两个子域进行积分。施加本质边界条件 $u(0) = 0$ 和 $u(L) = \\bar{u}$。求解离散未知量，并计算中点 $x_m = L/2$ 处的位移。对于下述每个测试用例，计算中点处的绝对误差\n$$\ne = \\left| u_h(L/2) - u_{\\text{exact}}(L/2) \\right|,\n$$\n并以米为单位，将 $e$ 作为浮点数报告。\n\n所有测试用例采用以下常量：$E = 30 \\times 10^{9}\\ \\text{Pa}$，$A = 1.0 \\times 10^{-2}\\ \\text{m}^2$，$L = 1.0\\ \\text{m}$，以及 $\\bar{u} = 1.0 \\times 10^{-3}\\ \\text{m}$。\n\n实现以下测试套件，其中改变了网格分辨率和裂纹位置：\n- 测试 1 (正常路径)：$N = 10$，$x_c = 0.33\\ \\text{m}$。\n- 测试 2 (裂纹位于中点右侧)：$N = 11$，$x_c = 0.52\\ \\text{m}$。\n- 测试 3 (裂纹位于中点，边界情况定义 $H(L/2) = +1$)：$N = 4$，$x_c = 0.50\\ \\text{m}$。\n- 测试 4 (粗网格，裂纹靠近左端)：$N = 3$，$x_c = 0.12\\ \\text{m}$。\n\n输出规范：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与上述测试顺序一致，例如：“[result1,result2,result3,result4]”。每个结果必须是以米为单位的绝对误差 $e$，且为浮点数。\n\n所有角度（如有）必须以弧度为单位。所有百分比（如有）必须表示为小数或分数，不得使用百分号。不应打印任何其他文本。", "solution": "用户提供了一个计算力学问题，要求为带内部裂纹的一维杆实现扩展有限元法 (XFEM)。\n\n### 步骤 1：提取已知条件\n- **问题类型**：带内部无牵引力裂纹的一维小应变线性弹性杆。\n- **控制方程（弱形式）**：$\\int_{0}^{L} E A \\, u'(x) \\, v'(x) \\, dx = 0$。\n- **域**：$x \\in [0,L]$。\n- **边界条件**：$u(0) = 0$, $u(L) = \\bar{u}$。\n- **材料与几何**：杨氏模量 $E$，横截面积 $A$，长度 $L$。\n- **裂纹模型**：在 $x=x_c$ 处的强不连续性，由 $\\phi(x) = x-x_c$ 的零水平集表示。\n- **离散化**：$N$ 个线性有限元（$N+1$ 个节点）的均匀网格。\n- **XFEM 近似**：$u_h(x) = \\sum_{i=0}^{N} N_i(x) \\, u_i + \\sum_{i \\in \\mathcal{E}} N_i(x) \\left( H(x) - H(x_i) \\right) a_i$。\n- **Heaviside 函数**：当 $x \\ge x_c$ 时 $H(x) = +1$，当 $x  x_c$ 时 $H(x) = -1$。\n- **增强节点**：$\\mathcal{E}$ 是其支承域被裂纹切割的节点集合。\n- **简化**：忽略混合修正。通过分裂被切割单元进行积分。\n- **精确解**：当 $x  x_c$ 时 $u_{\\text{exact}}(x) = 0$，当 $x \\ge x_c$ 时 $u_{\\text{exact}}(x) = \\bar{u}$。\n- **任务**：为多个测试用例计算绝对误差 $e = \\left| u_h(L/2) - u_{\\text{exact}}(L/2) \\right|$。\n- **常量**：$E = 30 \\times 10^{9}\\ \\text{Pa}$，$A = 1.0 \\times 10^{-2}\\ \\text{m}^2$，$L = 1.0\\ \\text{m}$，$\\bar{u} = 1.0 \\times 10^{-3}\\ \\text{m}$。\n- **测试用例**：\n    1. $N = 10$，$x_c = 0.33\\ \\text{m}$。\n    2. $N = 11$，$x_c = 0.52\\ \\text{m}$。\n    3. $N = 4$，$x_c = 0.50\\ \\text{m}$。\n    4. $N = 3$，$x_c = 0.12\\ \\text{m}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于线弹性力学和有限元法，两者都是基本且成熟的科学原理。XFEM 是一种标准的先进数值技术。该问题在科学上是合理的。\n- **适定性**：该问题提供了一个定义明确的边值问题，具有足够的数据和清晰的边界条件。无牵引力裂纹的存在使其成为一个具有唯一、稳定解（分段常数位移场）的问题。数值格式已指定。\n- **客观性**：该问题使用精确的数学和工程术语进行陈述。没有主观或基于观点的陈述。\n- **完整性与一致性**：问题提供了所有必要的参数（$E, A, L, \\bar{u}$）、离散化细节（$N$，线性单元）以及具体的测试用例（$x_c$）。指定的 XFEM 公式，尽管通过忽略混合单元进行了简化，但仍是一种一致且可形式化的方法。裂纹与节点重合的边界情况（$N=4, x_c=0.5$）需要仔细解释“其支承域被切割的节点”这一短语，但这是 XFEM 实现中的一个标准挑战，并不会使问题无效。仅增强裂纹所在位置的节点的解释与所提供的定义是一致的。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。将提供一个合理的解决方案。\n\n### 基于原理的解决方案\n\n该解决方案需要组装并求解一个由一维弹性问题的 XFEM 离散化产生的线性方程组。\n\n**1. 离散化与自由度 (DOF)**\n域 $[0, L]$ 被离散为 $N$ 个尺寸为 $h=L/N$ 的均匀线性单元。节点位于 $x_i = i \\cdot h$，其中 $i=0, \\dots, N$。\n总自由度由标准节点位移 $u_i$ 和增强自由度 $a_j$ 组成。增强节点集 $\\mathcal{E}$ 是那些其支承域被裂纹 $x_c$ 切割的节点。\n对于一维线性单元，节点 $j$ 的支承域是区间 $[x_{j-1}, x_{j+1}]$。\n- 如果裂纹严格位于单元 $(I, I+1)$ 内部，即 $x_I  x_c  x_{I+1}$，则节点 $I$ 和 $I+1$ 的支承域被切割。因此，$\\mathcal{E} = \\{I, I+1\\}$。总自由度数为 $(N+1) + 2$。\n- 如果裂纹正好位于节点 $I$ 处，即 $x_c = x_I$，则只有节点 $I$ 的支承域被切割。因此，$\\mathcal{E} = \\{I\\}$。总自由度数为 $(N+1) + 1$。\n\n**2. 刚度矩阵推导**\n全局刚度矩阵 $\\mathbf{K}$ 由单元刚度矩阵 $\\mathbf{k}^e$ 组装而成。其项由 $K_{ij} = \\int_0^L EA\\, \\psi_i'(x) \\psi_j'(x) dx$ 给出，其中 $\\psi_i(x)$ 是全局基函数。这些基函数可以是标准形函数 $N_k(x)$ 或增强基函数 $N_j(x)(H(x)-H(x_j))$。\n\n**标准单元：** 对于未受增强影响的单元，使用一维杆单元的标准 $2 \\times 2$ 刚度矩阵：\n$$\n\\mathbf{k}^e_{std} = \\frac{EA}{h}\n\\begin{bmatrix}\n1  -1 \\\\\n-1  1\n\\end{bmatrix}\n$$\n\n**裂纹位于单元内：** 如果裂纹 $x_c$ 位于具有节点 $I$ 和 $I+1$ 的单元 $e_c$ 内，则该单元为“被切割单元”。增强节点为 $\\mathcal{E}=\\{I,I+1\\}$。局部自由度为 $(u_I, u_{I+1}, a_I, a_{I+1})$。需要计算增强基函数的导数。设增强基为 $\\psi_j^a(x) = N_j(x)(H(x)-H(x_j))$。\n- 对于节点 $I$，$x_I  x_c \\implies H(x_I)=-1$。对于 $x \\in (x_c, x_{I+1})$，$H(x)=+1$，因此 $(\\psi_I^a)' = (2N_I)' = 2N_I' = -2/h$。对于 $x \\in (x_I, x_c)$，$H(x)=-1$，因此 $(\\psi_I^a)' = (0 \\cdot N_I)'=0$。\n- 对于节点 $I+1$，$x_{I+1} > x_c \\implies H(x_{I+1})=+1$。对于 $x \\in (x_I, x_c)$，$H(x)=-1$，因此 $(\\psi_{I+1}^a)' = (-2N_{I+1})' = -2N_{I+1}' = -2/h$。对于 $x \\in (x_c, x_{I+1})$，$H(x)=+1$，因此 $(\\psi_{I+1}^a)'=0$。\n\n单元刚度矩阵通过在 $x_c$ 处分裂积分来计算：$\\mathbf{k}^{e_c} = \\int_{x_I}^{x_{I+1}} EA \\mathbf{B}^T\\mathbf{B} dx = \\int_{x_I}^{x_c} \\dots + \\int_{x_c}^{x_{I+1}} \\dots$。令 $\\alpha = (x_c - x_I)/h$ 和 $\\beta = (x_{I+1} - x_c)/h$。这得到：\n$$\n\\mathbf{k}^{e_c} = \\frac{EA}{h}\n\\begin{bmatrix}\n1  -1  2\\beta  2\\alpha \\\\\n-1  1  -2\\beta  -2\\alpha \\\\\n2\\beta  -2\\beta  4\\beta  0 \\\\\n2\\alpha  -2\\alpha  0  4\\alpha\n\\end{bmatrix}\n$$\n\n**裂纹位于节点上：** 如果裂纹位于节点 $I$ 处，$x_c=x_I$，则 $\\mathcal{E}=\\{I\\}$。增强函数为 $\\psi_I^a(x) = N_I(x)(H(x)-H(x_I)) = N_I(x)(H(x)-1)$。\n- 对于 $x > x_I$，$H(x)=1$，因此 $\\psi_I^a(x)=0$。增强对裂纹右侧的单元（$e \\ge I$）没有影响。它们是标准单元。\n- 对于 $x  x_I$，$H(x)=-1$，因此 $\\psi_I^a(x) = -2N_I(x)$。这会影响单元 $I-1$（具有节点 $I-1, I$）。在此单元内，导数为 $(\\psi_I^a)' = -2N_I'(x) = -2(-1/h) = 2/h$。\n单元 $I-1$ 的自由度为 $(u_{I-1}, u_I, a_I)$。$3 \\times 3$ 的单元刚度矩阵为：\n$$\n\\mathbf{k}^{e_{I-1}} = \\frac{EA}{h}\n\\begin{bmatrix}\n1  -1  2 \\\\\n-1  1  -2 \\\\\n2  -2  4\n\\end{bmatrix}\n$$\n\n**3. 系统组装与求解**\n组装全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{F}$（在此为零）。系统方程为 $\\mathbf{K}\\mathbf{d}=\\mathbf{F}$。通过对系统进行分区来施加本质边界条件 $u_0 = 0$ 和 $u_N = \\bar{u}$。所有自由度集合 $\\mathbf{d}$ 被分为未知（自由）自由度 $\\mathbf{d}_f$ 和指定自由度 $\\mathbf{d}_p = [u_0, u_N]^T = [0, \\bar{u}]^T$。\n系统变为：\n$$\n\\begin{bmatrix}\n\\mathbf{K}_{ff}  \\mathbf{K}_{fp} \\\\\n\\mathbf{K}_{pf}  \\mathbf{K}_{pp}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{d}_f \\\\\n\\mathbf{d}_p\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{0} \\\\\n\\mathbf{F}_p\n\\end{bmatrix}\n$$\n自由自由度通过求解子系统 $\\mathbf{K}_{ff}\\mathbf{d}_f = -\\mathbf{K}_{fp}\\mathbf{d}_p$ 来找到。\n\n**4. 后处理**\n一旦得到完整的自由度向量 $\\mathbf{d}$，就可以使用 XFEM 近似式计算中点 $x_m = L/2$ 处的位移：\n$$\nu_h(x_m) = \\sum_{i=0}^{N} N_i(x_m) u_i + \\sum_{j \\in \\mathcal{E}} N_j(x_m) \\left( H(x_m) - H(x_j) \\right) a_j\n$$\n第一项涉及使用包含 $x_m$ 的单元的标准形函数进行插值。第二项加上任何其支承域包含 $x_m$ 的增强节点的贡献。然后计算绝对误差 $e = |u_h(L/2) - u_{exact}(L/2)|$。精确解 $u_{exact}(L/2)$ 在 $x_m  x_c$ 时为 $0$，在 $x_m \\ge x_c$ 时为 $\\bar{u}$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D XFEM bar problem.\n    \"\"\"\n    \n    # Constants from the problem statement (SI units)\n    E = 30e9  # Pa\n    A = 1.0e-2 # m^2\n    L = 1.0   # m\n    u_bar = 1.0e-3 # m\n\n    # Test suite\n    test_cases = [\n        {'N': 10, 'xc': 0.33},\n        {'N': 11, 'xc': 0.52},\n        {'N': 4,  'xc': 0.50},\n        {'N': 3,  'xc': 0.12},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_xfem_error(case['N'], case['xc'], L, E, A, u_bar)\n        results.append(error)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_xfem_error(N, xc, L, E, A, u_bar):\n    \"\"\"\n    Computes the absolute error at midspan for a single XFEM test case.\n    \"\"\"\n    h = L / N\n    nodes = np.linspace(0, L, N + 1)\n\n    # 1. Identify enriched nodes and case type\n    enriched_nodes_indices = []\n    cut_element_idx = -1\n    crack_on_node_idx = -1\n    \n    node_at_crack = np.where(np.isclose(nodes, xc))[0]\n    if node_at_crack.size > 0:\n        crack_on_node_idx = node_at_crack[0]\n        enriched_nodes_indices = [crack_on_node_idx]\n    else:\n        cut_element_idx = int(np.floor(xc / h))\n        enriched_nodes_indices = [cut_element_idx, cut_element_idx + 1]\n    \n    num_enriched_dofs = len(enriched_nodes_indices)\n    total_dofs = N + 1 + num_enriched_dofs\n    enriched_node_to_a_idx = {node_idx: N + 1 + i for i, node_idx in enumerate(enriched_nodes_indices)}\n\n    # 2. Assemble global stiffness matrix K\n    K = np.zeros((total_dofs, total_dofs))\n    \n    for i in range(N):\n        n1, n2 = i, i+1\n        \n        is_cut_element = (cut_element_idx == i)\n        is_pre_crack_enriched = (crack_on_node_idx > 0 and i == crack_on_node_idx - 1)\n\n        if is_cut_element:\n            alpha = (xc - nodes[i]) / h\n            beta = (nodes[i+1] - xc) / h\n            k_e = (E * A / h) * np.array([\n                [1, -1, 2 * beta, 2 * alpha],\n                [-1, 1, -2 * beta, -2 * alpha],\n                [2 * beta, -2 * beta, 4 * beta, 0],\n                [2 * alpha, -2 * alpha, 0, 4 * alpha]\n            ])\n            \n            u1_idx, u2_idx = n1, n2\n            a1_idx = enriched_node_to_a_idx[n1]\n            a2_idx = enriched_node_to_a_idx[n2]\n            dof_map = [u1_idx, u2_idx, a1_idx, a2_idx]\n            K[np.ix_(dof_map, dof_map)] += k_e\n            \n        elif is_pre_crack_enriched:\n            k_e = (E * A / h) * np.array([\n                [1, -1, 2],\n                [-1, 1, -2],\n                [2, -2, 4]\n            ])\n            \n            u1_idx, u2_idx = n1, n2\n            a_idx = enriched_node_to_a_idx[crack_on_node_idx]\n            dof_map = [u1_idx, u2_idx, a_idx]\n            K[np.ix_(dof_map, dof_map)] += k_e\n            \n        else: # Standard element\n            k_std = (E * A / h) * np.array([[1, -1], [-1, 1]])\n            dof_map = [n1, n2]\n            K[np.ix_(dof_map, dof_map)] += k_std\n\n    # 3. Apply BCs and solve linear system\n    prescribed_dofs = {0, N}\n    free_dofs = sorted(list(set(range(total_dofs)) - prescribed_dofs))\n    \n    d_p = np.array([0., u_bar])\n    \n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    K_fp = K[np.ix_(free_dofs, list(prescribed_dofs))]\n    \n    rhs = -K_fp @ d_p\n    d_f = np.linalg.solve(K_ff, rhs)\n    \n    d = np.zeros(total_dofs)\n    d[list(prescribed_dofs)] = d_p\n    d[free_dofs] = d_f\n\n    # 4. Evaluate displacement u_h at midspan L/2\n    x_m = L / 2\n    \n    # Find element containing x_m\n    elem_mid_idx = int(np.floor(x_m / h))\n    if np.isclose(x_m, L): elem_mid_idx = N - 1\n        \n    # Standard interpolation part\n    j1, j2 = elem_mid_idx, elem_mid_idx + 1\n    xi_mid = (x_m - nodes[j1]) / h\n    N1_mid, N2_mid = 1 - xi_mid, xi_mid\n    u_h = N1_mid * d[j1] + N2_mid * d[j2]\n    \n    # Enrichment part\n    H = lambda x: 1.0 if x >= xc else -1.0\n    \n    for enriched_node in enriched_nodes_indices:\n        x_j_minus_1 = nodes[enriched_node - 1] if enriched_node > 0 else -np.inf\n        x_j         = nodes[enriched_node]\n        x_j_plus_1  = nodes[enriched_node + 1] if enriched_node  N else np.inf\n\n        N_j_mid = 0.0\n        if x_j_minus_1 = x_m = x_j:\n            N_j_mid = (x_m - x_j_minus_1) / h\n        elif x_j  x_m = x_j_plus_1:\n            N_j_mid = (x_j_plus_1 - x_m) / h\n        \n        if N_j_mid > 0:\n            a_j = d[enriched_node_to_a_idx[enriched_node]]\n            u_h += N_j_mid * (H(x_m) - H(x_j)) * a_j\n            \n    # 5. Compute absolute error\n    u_exact_mid = u_bar if x_m >= xc else 0.0\n    error = np.abs(u_h - u_exact_mid)\n    \n    return error\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3523133"}, {"introduction": "模拟不连续面的运动学只是问题的一半；我们还必须描述控制界面行为的物理定律，例如接触和摩擦。最后一个练习将重点从运动学转向非线性本构模型。你将为一个黏聚摩擦接触定律推导其一致算法切线（consistent algorithmic tangent），这是在用于求解这些复杂非线性问题的牛顿-拉弗森（Newton-Raphson）求解器中实现二次收敛的关键组成部分。", "problem": "考虑一个二维小变形固体，其内部位移不连续性由一个符号距离函数 $\\phi(\\mathbf{x})=0$ 的零水平集隐式表示。在扩展有限元法（XFEM）中，位移场通过 Heaviside 函数进行扩展，使得扩展部分在 $\\phi=0$ 处产生位移跳跃。关注界面上的单个积分点 $\\mathbf{x}^{\\star}$，其单位法向量为 $\\mathbf{n}$，单位切向量为 $\\mathbf{t}$，其中局部一位移跳跃 $\\mathbf{g}=\\begin{pmatrix} g_{n} \\\\ g_{t} \\end{pmatrix}$ 是通过将扩展位移差投影到 $(\\mathbf{n},\\mathbf{t})$ 上来定义的。假设由于在 $\\mathbf{x}^{\\star}$ 处的局部形函数插值，间隙 $\\mathbf{g}$ 与该点的扩展自由度向量重合，因此从扩展自由度到 $\\mathbf{g}$ 的映射是单位映射。假设为准静态条件，并且接触在压缩状态下是激活的，即 $g_{n}\\ge 0$ 且无张开。\n\n在界面上，牵引力向量 $\\mathbf{t}=\\begin{pmatrix} t_{n} \\\\ t_{t} \\end{pmatrix}$ 在局部坐标系 $(\\mathbf{n},\\mathbf{t})$ 中由一个粘聚摩擦定律控制：\n- 法向响应：$t_{n}=k_{n}\\,g_{n}$，其中 $k_{n}>0$。\n- 切向响应：一个带有罚函数 $k_{t}>0$ 的弹性预测器，以及一个 Coulomb 型的摩擦屈服函数 $f=\\lvert t_{t}\\rvert - \\mu\\,t_{n} - H\\,p \\le 0$，其中摩擦系数 $\\mu>0$，关于累积滑移 $p$ 的线性各向同性硬化模量 $H>0$，以及关联切向塑性流动 $dp=\\lvert d\\lambda\\rvert$，$dg_{t}^{p}=d\\lambda\\,\\operatorname{sign}(t_{t})$，其中 $d\\lambda\\ge 0$ 是塑性乘子增量。假设在给定的 Newton 步中，$\\operatorname{sign}(t_{t})$ 保持不变。在粘滞状态下，$f0$ 且 $t_{t}=k_{t}\\,g_{t}$。在滑移状态下，$f=0$ 且一致性条件成立。\n\n你正在通过应用于残差 $\\mathbf{r}(\\mathbf{g})=\\mathbf{t}(\\mathbf{g})-\\boldsymbol{\\tau}^{\\star}=\\mathbf{0}$ 的 Newton 法求解在 $\\mathbf{x}^{\\star}$ 处的局部界面平衡方程以得到间隙 $\\mathbf{g}$，其中 $\\boldsymbol{\\tau}^{\\star}$ 是周围体材料在 $\\mathbf{x}^{\\star}$ 处所要求的牵引力。Newton 法由在当前状态下评估的一致性线性化（算法切线）$\\mathbf{C}=\\partial \\mathbf{t}/\\partial \\mathbf{g}$ 驱动。\n\n任务：\n1) 从上述本构定义出发，并在滑移状态下强制执行一致性条件，推导粘滞和滑移两种情况的一致性算法切线 $\\mathbf{C}=\\partial \\mathbf{t}/\\partial \\mathbf{g}$，表示为在 $(\\mathbf{n},\\mathbf{t})$ 基底下的一个 $2\\times 2$ 矩阵。你的推导必须消去塑性乘子增量 $d\\lambda$ 和累积滑移增量 $dp$，用微分量 $dg_{n}$ 和 $dg_{t}$ 表示。\n2) 使用你的结果解释，为什么当活动集（粘滞或滑移）不变时，使用此一致性切线的 Newton 方法对扩展界面问题表现出二次局部收敛性，尽管在界面的其他地方存在位移跳跃和潜在的粘滞-滑移转换。\n3) 现在特化到一个滑移点，其 $\\operatorname{sign}(t_{t})=+1$，参数为 $k_{n}=2.0\\times 10^{8}$，$k_{t}=1.0\\times 10^{8}$，$\\mu=0.6$ 和 $H=5.0\\times 10^{7}$（均采用一致性单位）。设 Newton 迭代应用于 $\\mathbf{r}(\\mathbf{g})=\\mathbf{t}(\\mathbf{g})-\\boldsymbol{\\tau}^{\\star}$，使用任务1中得到的一致性切线。计算与此滑移状态相关的解处的线性化 Newton 误差传播算子的谱半径 $\\rho$。最终答案表示为一个无单位的实数。无需四舍五入。", "solution": "该问题要求推导粘聚摩擦界面定律的一致性算法切线，解释相关的 Newton-Raphson 格式的收敛特性，并计算一个特定情况下的谱半径。\n\n局部问题是找到间隙向量 $\\mathbf{g} = \\begin{pmatrix} g_n \\\\ g_t \\end{pmatrix}$，该向量求解平衡方程 $\\mathbf{r}(\\mathbf{g}) = \\mathbf{t}(\\mathbf{g}) - \\boldsymbol{\\tau}^{\\star} = \\mathbf{0}$，其中 $\\mathbf{t}(\\mathbf{g}) = \\begin{pmatrix} t_n(g_n) \\\\ t_t(g_n, g_t) \\end{pmatrix}$ 是来自本构律的牵引力向量，而 $\\boldsymbol{\\tau}^{\\star}$ 是一个给定的外部牵引力。这个问题使用 Newton 法求解，该方法需要残差的雅可比矩阵，$\\mathbf{C} = \\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{g}} = \\frac{\\partial \\mathbf{t}}{\\partial \\mathbf{g}}$，即一致性算法切线。\n\n### 任务1：一致性算法切线的推导\n\n我们寻求 $2 \\times 2$ 矩阵 $\\mathbf{C}$，使得 $d\\mathbf{t} = \\mathbf{C}d\\mathbf{g}$，其中 $d\\mathbf{t} = \\begin{pmatrix} dt_n \\\\ dt_t \\end{pmatrix}$ 且 $d\\mathbf{g} = \\begin{pmatrix} dg_n \\\\ dg_t \\end{pmatrix}$。\n\n法向牵引力 $t_n$ 由线性关系 $t_n = k_n g_n$ 给出。其微分是直接的：\n$$dt_n = k_n dg_n$$\n这确定了 $\\mathbf{C}$ 的第一行：$\\frac{\\partial t_n}{\\partial g_n} = k_n$ 且 $\\frac{\\partial t_n}{\\partial g_t} = 0$。\n\n切向响应是弹塑性的。总切向间隙增量 $dg_t$ 被加法分解为一个弹性部分 $dg_t^e$ 和一个塑性部分 $dg_t^p$：\n$$dg_t = dg_t^e + dg_t^p$$\n切向牵引力通过罚刚度 $k_t$ 与间隙的弹性部分相关：\n$$t_t = k_t g_t^e$$\n以微分形式，有 $dt_t = k_t dg_t^e$。代入 $dg_t^e = dg_t - dg_t^p$，我们得到：\n$$dt_t = k_t (dg_t - dg_t^p)$$\n塑性流动法则给出为 $dg_t^p = d\\lambda \\operatorname{sign}(t_t)$，其中 $d\\lambda \\ge 0$ 是塑性乘子增量。令 $s_t = \\operatorname{sign}(t_t)$。则：\n$$dt_t = k_t (dg_t - s_t d\\lambda)$$\n这个关系是通用的。$d\\lambda$ 的值区分了粘滞和滑移情况。\n\n**情况1：粘滞**\n在粘滞状态下，屈服函数未激活，$f  0$。对于足够小的载荷增量，状态保持弹性，没有塑性流动。\n$$d\\lambda = 0$$\n因此，$dg_t^p=0$，牵引力增量是纯弹性的：\n$$dt_t = k_t dg_t$$\n在这种情况下，切向牵引力不依赖于法向间隙，所以 $\\frac{\\partial t_t}{\\partial g_n} = 0$。导数为 $\\frac{\\partial t_t}{\\partial g_n} = 0$ 和 $\\frac{\\partial t_t}{\\partial g_t} = k_t$。\n粘滞情况的一致性切线 $\\mathbf{C}_{\\text{stick}}$ 是对角弹性切线矩阵：\n$$\\mathbf{C}_{\\text{stick}} = \\begin{pmatrix} k_n  0 \\\\ 0  k_t \\end{pmatrix}$$\n\n**情况2：滑移**\n在滑移状态下，牵引力状态位于屈服面上，$f=0$，并且在进一步加载时保持在该面上，这意味着一致性条件 $df=0$。屈服函数为：\n$$f = |t_t| - \\mu t_n - H p = s_t t_t - \\mu t_n - H p = 0$$\n微分形式的一致性条件是：\n$$df = s_t dt_t - \\mu dt_n - H dp = 0$$\n累积滑移增量是 $dp = |d\\lambda| = d\\lambda$。代入 $dt_t$，$dt_n$ 和 $dp$ 的表达式：\n$$s_t \\left( k_t (dg_t - s_t d\\lambda) \\right) - \\mu (k_n dg_n) - H (d\\lambda) = 0$$\n$$s_t k_t dg_t - k_t s_t^2 d\\lambda - \\mu k_n dg_n - H d\\lambda = 0$$\n因为 $s_t^2 = 1$，我们可以合并项来求解 $d\\lambda$：\n$$(k_t + H) d\\lambda = s_t k_t dg_t - \\mu k_n dg_n$$\n$$d\\lambda = \\frac{s_t k_t dg_t - \\mu k_n dg_n}{k_t + H}$$\n现在，我们将 $d\\lambda$ 的这个表达式代回 $dt_t$ 的关系式中：\n$$dt_t = k_t(dg_t - s_t d\\lambda) = k_t \\left( dg_t - s_t \\frac{s_t k_t dg_t - \\mu k_n dg_n}{k_t + H} \\right)$$\n$$dt_t = k_t \\left( \\frac{(k_t + H)dg_t - (s_t^2 k_t dg_t - s_t \\mu k_n dg_n)}{k_t + H} \\right)$$\n$$dt_t = \\frac{k_t}{k_t + H} \\left( k_t dg_t + H dg_t - k_t dg_t + s_t \\mu k_n dg_n \\right)$$\n$$dt_t = \\frac{k_t s_t \\mu k_n}{k_t + H} dg_n + \\frac{k_t H}{k_t + H} dg_t$$\n根据此表达式和 $dt_n = k_n dg_n + 0 \\cdot dg_t$，我们可以确定滑移情况的一致性切线矩阵 $\\mathbf{C}_{\\text{slide}}$ 的分量：\n$$\\frac{\\partial t_t}{\\partial g_n} = \\frac{s_t \\mu k_n k_t}{k_t + H} \\quad \\text{和} \\quad \\frac{\\partial t_t}{\\partial g_t} = \\frac{k_t H}{k_t + H}$$\n完整的矩阵是：\n$$\\mathbf{C}_{\\text{slide}} = \\begin{pmatrix} k_n  0 \\\\ \\frac{s_t \\mu k_n k_t}{k_t + H}  \\frac{k_t H}{k_t + H} \\end{pmatrix}$$\n这个矩阵是非对称的，这在具有非关联流动法则的塑性模型中，或者如此例中不同分量（法向弹性和切向塑性）之间存在耦合的情况下很常见。\n\n### 任务2：二次收敛性的解释\n\nNewton-Raphson 方法用于找到残差方程 $\\mathbf{r}(\\mathbf{g})=\\mathbf{0}$ 的根 $\\mathbf{g}^*$。该方法的一次迭代形式为：\n$$\\mathbf{g}_{k+1} = \\mathbf{g}_k - [\\mathbf{J}_{\\mathbf{r}}(\\mathbf{g}_k)]^{-1} \\mathbf{r}(\\mathbf{g}_k)$$\n其中 $\\mathbf{J}_{\\mathbf{r}}(\\mathbf{g}_k)$ 是残差函数 $\\mathbf{r}$ 在当前迭代点 $\\mathbf{g}_k$ 处的雅可比矩阵。在我们的问题中，$\\mathbf{J}_{\\mathbf{r}}(\\mathbf{g}) = \\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{g}} = \\frac{\\partial \\mathbf{t}}{\\partial \\mathbf{g}} = \\mathbf{C}(\\mathbf{g})$。因此，迭代过程为：\n$$\\mathbf{g}_{k+1} = \\mathbf{g}_k - [\\mathbf{C}(\\mathbf{g}_k)]^{-1} \\mathbf{r}(\\mathbf{g}_k)$$\nNewton-Raphson 方法的收敛速度由其迭代映射函数 $\\mathbf{F}(\\mathbf{g}) = \\mathbf{g} - [\\mathbf{C}(\\mathbf{g})]^{-1} \\mathbf{r}(\\mathbf{g})$ 的性质决定。第 $k+1$ 次迭代的误差通过 $\\mathbf{F}$ 在解 $\\mathbf{g}^*$ 附近的泰勒展开与第 $k$ 次迭代的误差相关联。该展开式中的一阶项由映射的雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{g}^*) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}}|_{\\mathbf{g}^*}$ 控制。\n我们来计算这个雅可比矩阵：\n$$\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}} = \\frac{\\partial}{\\partial \\mathbf{g}} \\left( \\mathbf{g} - [\\mathbf{C}(\\mathbf{g})]^{-1} \\mathbf{r}(\\mathbf{g}) \\right) = \\mathbf{I} - \\frac{\\partial}{\\partial \\mathbf{g}} \\left( [\\mathbf{C}(\\mathbf{g})]^{-1} \\mathbf{r}(\\mathbf{g}) \\right)$$\n使用乘法法则：\n$$\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}} = \\mathbf{I} - \\left( \\frac{\\partial([\\mathbf{C}(\\mathbf{g})]^{-1})}{\\partial \\mathbf{g}} \\mathbf{r}(\\mathbf{g}) + [\\mathbf{C}(\\mathbf{g})]^{-1} \\frac{\\partial \\mathbf{r}(\\mathbf{g})}{\\partial \\mathbf{g}} \\right)$$\n我们知道 $\\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{g}} = \\mathbf{C}(\\mathbf{g})$。所以第二项简化为 $[\\mathbf{C}(\\mathbf{g})]^{-1} \\mathbf{C}(\\mathbf{g}) = \\mathbf{I}$。\n$$\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}} = \\mathbf{I} - \\left( \\frac{\\partial([\\mathbf{C}(\\mathbf{g})]^{-1})}{\\partial \\mathbf{g}} \\mathbf{r}(\\mathbf{g}) + \\mathbf{I} \\right) = - \\frac{\\partial([\\mathbf{C}(\\mathbf{g})]^{-1})}{\\partial \\mathbf{g}} \\mathbf{r}(\\mathbf{g})$$\n为了获得局部收敛速度，我们在解 $\\mathbf{g}^*$ 处评估这个雅可比矩阵。根据定义，$\\mathbf{r}(\\mathbf{g}^*) = \\mathbf{0}$。因此：\n$$\\mathbf{J}_{\\mathbf{F}}(\\mathbf{g}^*) = - \\frac{\\partial([\\mathbf{C}(\\mathbf{g})]^{-1})}{\\partial \\mathbf{g}}\\bigg|_{\\mathbf{g}^*} \\mathbf{r}(\\mathbf{g}^*) = \\mathbf{0}$$\nNewton 迭代映射的雅可比矩阵在解处是零矩阵。这是至少二次收敛的条件。这个结果成立是因为 Newton 更新中使用的切线 $\\mathbf{C}$ 是算法残差的*精确*或*一致*雅可比矩阵。“当活动集（粘滞或滑移）不变时”这一限定条件至关重要，因为它确保了函数 $\\mathbf{r}(\\mathbf{g})$ 在解的邻域内是连续可微的，这是泰勒级数分析的前提条件。问题的假设将 XFEM 和全局问题的复杂性解耦，使得二次收敛成为局部本构求解器的一个属性。\n\n### 任务3：谱半径的计算\n\n“线性化 Newton 误差传播算子”是在解 $\\mathbf{g}^*$ 处评估的 Newton 迭代映射函数 $\\mathbf{F}(\\mathbf{g})$ 的雅可比矩阵。这个我们记为 $\\mathbf{G}$ 的算子，控制着小误差 $\\mathbf{e}_k = \\mathbf{g}_k - \\mathbf{g}^*$ 的传播：$\\mathbf{e}_{k+1} \\approx \\mathbf{G} \\mathbf{e}_k$。\n如任务2中所推导，该算子为：\n$$\\mathbf{G} = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}}\\bigg|_{\\mathbf{g}^*} = \\mathbf{0}$$\n该算子是 $2 \\times 2$ 的零矩阵。零矩阵的特征值都为零。谱半径 $\\rho(\\mathbf{G})$ 定义为特征值绝对值的最大值。\n对于零矩阵，特征值为 $\\lambda_1 = 0$ 和 $\\lambda_2 = 0$。因此，谱半径为：\n$$\\rho(\\mathbf{G}) = \\max(|0|, |0|) = 0$$\n这个结果是标准 Newton-Raphson 方法的一个基本属性，也是其二次收敛速度的数学原因。$k_n$、$k_t$、$\\mu$ 和 $H$ 的具体数值对于计算切线矩阵 $\\mathbf{C}_{\\text{slide}}$ 本身是必要的，但对于确定解处的误差传播算子的谱半径则不是必需的，当使用一致性切线且活动集稳定时，该谱半径始终为零。", "answer": "0", "id": "3523088"}]}