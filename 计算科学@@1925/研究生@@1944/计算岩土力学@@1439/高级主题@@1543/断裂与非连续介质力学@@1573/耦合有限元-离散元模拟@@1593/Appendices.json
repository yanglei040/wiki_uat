{"hands_on_practices": [{"introduction": "当同时使用连续介质（FEM）和离散元（DEM）方法对一个系统进行建模时，一个关键挑战出现在重叠区域：如何施加像重力这样的体力而又避免重复计算？本练习将引导您理解力分配的基本原则 [@problem_id:3512677]。通过推导正确的缩放因子，您将确保数值模型的总重量精确反映物理现实，从而维持全局静力平衡。", "problem": "一个棱柱状土样在有限元法 (FEM) 和离散元法 (DEM) 的耦合模拟中被建模。该土样是一个尺寸为 $L_{x} = 2\\,\\mathrm{m}$、$L_{y} = 3\\,\\mathrm{m}$ 和 $L_{z} = 1\\,\\mathrm{m}$ 的长方体，因此其总体积为 $V = L_{x} L_{y} L_{z}$。土壤的体积密度是均匀的，等于 $\\rho = 1700\\,\\mathrm{kg/m^{3}}$。重力沿 $y$ 轴负方向作用，大小为 $g = 9.81\\,\\mathrm{m/s^{2}}$。位于 $y=0$ 处的基底是完全刚性的、无摩擦的，并提供唯一的竖向反力。没有其他外部荷载作用于该土样。\n\n为了在一个子区域内捕捉颗粒尺度的响应，一个尺寸为 $a = 1\\,\\mathrm{m}$、$b = 2\\,\\mathrm{m}$ 和 $c = 1\\,\\mathrm{m}$ 的长方体子体积 $V_{p}$ 同时由 $N_{p} = 1600$ 个 DEM 颗粒表示，每个颗粒的质量为 $m_{p} = 0.375\\,\\mathrm{kg}$。DEM 颗粒承受其自身的重力 $m_{p} g$。FEM 连续体覆盖整个试样，包括 $V_{p}$。为避免在 $V_{p}$ 中重复计算体力，该区域的 FEM 体力密度按一个未知的常数因子 $\\alpha \\in [0,1]$ 进行缩放，而在 $V_{p}$ 之外，FEM 使用完整的体力密度 $\\rho g$。离散元法 (DEM) 颗粒通过运动学/接触约束在重叠区域与连续体耦合，但不会改变 $g$。\n\n仅从 Newton 第二定律和体力作为 $\\rho \\mathbf{g}$ 在体积上的积分的定义出发，推导保证竖直方向上全局静力平衡的 $\\alpha$ 条件，从而避免在重叠区域中重复计算重力。然后，利用该条件，计算在所述配置下，重力荷载作用时基底的竖向反力（总压缩支承力）。\n\n仅报告最终的基底反力大小，单位为 $\\mathrm{kN}$，并四舍五入到四位有效数字。", "solution": "问题要求计算在有限元法 (FEM) 和离散元法 (DEM) 耦合模拟下，棱柱状土样在重力荷载作用下基底的竖向反力。求解首先需要建立在耦合域中重力的一致性表达条件，然后应用静力平衡。\n\n根据 Newton 第二定律，对于处于静力平衡的系统，所有外力的矢量和为零。设竖直方向为 $y$ 轴。作用在土样上的外力为沿 $y$ 轴负方向作用的总重力 $\\mathbf{W}_{total}$ 和沿 $y$ 轴正方向作用的基底反力 $\\mathbf{F}_{R}$。问题陈述基底提供了唯一的竖向反力。因此，为了在竖直方向上达到静力平衡，我们有：\n$$ \\sum F_{y} = F_{R} - W_{total} = 0 $$\n其中 $F_{R}$ 和 $W_{total}$ 分别是这两个力的大小。这意味着基底反力的大小等于系统的总重量：\n$$ F_{R} = W_{total} $$\n\n问题的核心是确定 FEM/DEM 耦合模型必须表示的正确的总重量 $W_{total}$。为使数值模拟具有物理意义，其计算出的总重力必须与它所模拟的物理对象上作用的重力完全相同。该物理对象是一个总体积为 $V$、均匀体积密度为 $\\rho$ 的棱柱状土样。其总质量为 $M = \\rho V$，总重量为 $W_{physical} = M g = \\rho V g$。因此，我们必须施加条件，使从数值模型计算出的总重量 $W_{model}$ 等于这个物理重量：\n$$ W_{model} = W_{physical} = \\rho V g $$\n\n数值模型中的总重量 $W_{model}$ 是施加在 FEM 域 ($W_{FEM}$) 和 DEM 域 ($W_{DEM}$) 的重力之和：\n$$ W_{model} = W_{FEM} + W_{DEM} $$\n\nDEM 的贡献包括作用在子体积 $V_{p}$ 内 $N_{p}$ 个离散颗粒上的重力。每个颗粒的质量为 $m_{p}$。所有 DEM 颗粒的总重量是：\n$$ W_{DEM} = N_{p} m_{p} g $$\n\nFEM 的贡献是体力密度在整个体积 $V$ 上的积分。体力密度是分段定义的。试样体积 $V$ 由子体积 $V_{p}$ 和剩余体积 $V_{out} = V - V_{p}$ 组成。\n在重叠区域之外，来自 FEM 连续体的重力是使用完整的体力密度 $\\rho g$ 计算的：\n$$ W_{FEM, out} = \\int_{V_{out}} \\rho g \\,dV = \\rho g V_{out} = \\rho g (V - V_{p}) $$\n在重叠区域 $V_{p}$ 内部，FEM 体力密度按一个因子 $\\alpha$ 进行缩放：\n$$ W_{FEM, in} = \\int_{V_{p}} \\alpha \\rho g \\,dV = \\alpha \\rho g V_{p} $$\nFEM 的总重量是这两部分之和：\n$$ W_{FEM} = W_{FEM, out} + W_{FEM, in} = \\rho g (V - V_{p}) + \\alpha \\rho g V_{p} $$\n\n现在，我们可以组合出模型总重量的表达式：\n$$ W_{model} = W_{FEM} + W_{DEM} = \\left[ \\rho g (V - V_{p}) + \\alpha \\rho g V_{p} \\right] + N_{p} m_{p} g $$\n\n为避免在重叠区域 $V_p$ 中重复计算重力并确保物理一致性，我们强制 $W_{model} = W_{physical}$：\n$$ \\rho g (V - V_{p}) + \\alpha \\rho g V_{p} + N_{p} m_{p} g = \\rho g V $$\n由于 $g \\neq 0$，我们可以将所有项除以 $g$：\n$$ \\rho (V - V_{p}) + \\alpha \\rho V_{p} + N_{p} m_{p} = \\rho V $$\n展开第一项：\n$$ \\rho V - \\rho V_{p} + \\alpha \\rho V_{p} + N_{p} m_{p} = \\rho V $$\n两边减去 $\\rho V$ 并重新整理以求解 $\\alpha$：\n$$ -\\rho V_{p} + \\alpha \\rho V_{p} + N_{p} m_{p} = 0 $$\n$$ \\alpha \\rho V_{p} = \\rho V_{p} - N_{p} m_{p} $$\n$$ \\alpha = \\frac{\\rho V_{p} - N_{p} m_{p}}{\\rho V_{p}} = 1 - \\frac{N_{p} m_{p}}{\\rho V_{p}} $$\n这个方程是关于 $\\alpha$ 的条件，它确保了重力在 FEM 和 DEM 表示之间被正确分配，从而使它们的总和等于真实的物理重量。\n\n问题要求的是基底的竖向反力 $F_{R}$。根据静力平衡已确定，$F_{R} = W_{total}$。推导出的耦合方案的全部目的就是确保模型的总重量 $W_{model}$ 等于土样的物理重量 $W_{physical} = \\rho V g$。因此，需要由基底平衡的总向下的力就是整个土块的物理重量。\n\n我们现在使用给定数据计算这个值：\n试样的尺寸为 $L_{x} = 2\\,\\mathrm{m}$、$L_{y} = 3\\,\\mathrm{m}$ 和 $L_{z} = 1\\,\\mathrm{m}$。\n总体积为 $V = L_{x} L_{y} L_{z} = (2\\,\\mathrm{m}) (3\\,\\mathrm{m}) (1\\,\\mathrm{m}) = 6\\,\\mathrm{m^3}$。\n体积密度为 $\\rho = 1700\\,\\mathrm{kg/m^{3}}$。\n重力加速度为 $g = 9.81\\,\\mathrm{m/s^{2}}$。\n\n物理试样的总重量，也就是所需的基底反力，是：\n$$ F_{R} = \\rho V g = (1700\\,\\mathrm{kg/m^3}) \\times (6\\,\\mathrm{m^3}) \\times (9.81\\,\\mathrm{m/s^2}) $$\n$$ F_{R} = (10200\\,\\mathrm{kg}) \\times (9.81\\,\\mathrm{m/s^2}) = 100062\\,\\mathrm{N} $$\n\n问题要求答案以千牛顿 ($\\mathrm{kN}$) 为单位，并四舍五入到四位有效数字。\n$$ F_{R} = 100.062\\,\\mathrm{kN} $$\n四舍五入到四位有效数字得到：\n$$ F_{R} \\approx 100.1\\,\\mathrm{kN} $$\n按要求的标准科学记数法写出：$1.001 \\times 10^2\\,\\mathrm{kN}$。", "answer": "$$\\boxed{1.001 \\times 10^{2}}$$", "id": "3512677"}, {"introduction": "为了使DEM粒子能够与FEM连续体相互作用，模拟程序必须首先确定粒子位于哪个单元内或受其影响。这项“粒子定位”任务是基础性的，但由于浮点运算的不精确性，它很容易出错，尤其是在单元边界附近。本练习将挑战您超越简单的判断，实现一个基于后向误差分析的、数值上稳健的定位算法，这是开发可靠耦合代码的一项关键技能 [@problem_id:3512704]。", "problem": "考虑在二维空间中将离散元法（DEM）粒子与有限元法（FEM）网格耦合。FEM网格由线性三角形单元组成，每个单元由平面中的三个顶点坐标定义。通过识别 DEM 粒子所在位置 $\\mathbf{p} \\in \\mathbb{R}^2$ 所在的 FEM 单元，并计算其相对于该单元的重心坐标，来确定该粒子的位置。使用以下基本原理：相对于三角形顶点 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 的重心坐标 $\\lambda_a$、$\\lambda_b$ 和 $\\lambda_c$ 满足 $\\mathbf{p} = \\lambda_a \\mathbf{a} + \\lambda_b \\mathbf{b} + \\lambda_c \\mathbf{c}$ 和 $\\lambda_a + \\lambda_b + \\lambda_c = 1$，并且一个点在三角形内部的充分必要条件是其所有重心坐标均为非负值。在浮点运算中，舍入误差会干扰计算出的重心坐标，可能导致在单元边界附近出现分类错误。设计一个鲁棒算法，该算法使用重心坐标在网格中定位 $\\mathbf{p}$，并基于矩阵条件数和机器精度推导出一个容差，以避免在边界处发生分类错误。\n\n您的任务是：\n- 通过求解重心坐标的后向误差分析，推导出一个分类容差。设 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 为三角形顶点，设 $\\mathbf{A} = [\\mathbf{b}-\\mathbf{a}, \\mathbf{c}-\\mathbf{a}] \\in \\mathbb{R}^{2 \\times 2}$，且 $\\mathbf{x} = [\\lambda_b, \\lambda_c]^\\top$。重心坐标可通过求解 $\\mathbf{A}\\mathbf{x} = \\mathbf{p}-\\mathbf{a}$ 和 $\\lambda_a = 1 - \\lambda_b - \\lambda_c$ 得出。使用单位舍入误差为 $u$ 的标准浮点模型，推导出一个界限 $\\tau$，该界限依赖于谱条件数 $\\kappa_2(\\mathbf{A})$、范数 $\\|\\mathbf{A}\\|_2$ 和 $\\|\\mathbf{p}-\\mathbf{a}\\|_2$ 以及 $u$，使得如果一个真实的重心坐标满足 $|\\lambda_i| \\le \\tau$（其中 $i \\in \\{a,b,c\\}$），那么计算出的坐标的符号可能会因舍入误差而损坏，从而导致朴素的符号检验出现分类错误。\n- 实现一个鲁棒的定位器。对于每个三角形，该定位器计算重心坐标，评估推导出的容差 $\\tau$，并在所有坐标都满足 $\\lambda_i \\ge -\\tau$ 且其和满足 $|\\lambda_a + \\lambda_b + \\lambda_c - 1| \\le 3\\tau$ 的情况下，将点分类为在该三角形内部。如果由于靠近边界，多个相邻的三角形都满足此鲁棒准则，则选择使最小重心坐标 $\\min(\\lambda_a, \\lambda_b, \\lambda_c)$ 最大化的三角形；如果出现平局，则按最小的三角形索引来决定。\n- 实现一个朴素的定位器。该定位器仅在所有 $\\lambda_i \\ge 0$ 且 $|\\lambda_a + \\lambda_b + \\lambda_c - 1| \\le \\delta$（其中 $\\delta$ 是一个固定的微小阈值）的情况下将点分类为在三角形内部，并选择第一个通过此测试的三角形；否则，它不返回任何三角形。\n- 对于所提供测试套件中的每个测试用例，返回鲁棒定位器所选三角形的整数索引，以及一个布尔值，该布尔值指示朴素定位器是否相对于鲁棒定位器对该点进行了错误分类（即，朴素定位器要么没有返回三角形，要么返回了与鲁棒定位器不同的三角形索引）。\n\n不涉及物理单位；所有量均为无量纲。不使用角度。布尔值表示为字面量 $\\text{True}$ 或 $\\text{False}$，整数用十进制形式表示，浮点数用十进制形式表示。\n\n测试套件：\n- 网格 $\\mathcal{M}_1$，包含索引为 $0$ 和 $1$ 的三角形：\n  - 三角形 $0$：顶点 $\\mathbf{a} = (0,0)$, $\\mathbf{b} = (1,0)$, $\\mathbf{c} = (1,1)$。\n  - 三角形 $1$：顶点 $\\mathbf{a} = (0,0)$, $\\mathbf{b} = (1,1)$, $\\mathbf{c} = (0,1)$。\n  - 点 $\\mathbf{p}_1 = (0.7, 0.2)$，一个普通的内部点情况。\n  - 点 $\\mathbf{p}_2 = (0.5, 0.5)$，恰好位于三角形 $0$ 和 $1$ 之间的共享对角线上。\n- 网格 $\\mathcal{M}_2$，包含索引为 $0$ 的三角形：\n  - 三角形 $0$：顶点 $\\mathbf{a} = (0,0)$, $\\mathbf{b} = (10^{-8}, 0)$, $\\mathbf{c} = (0, 1)$，一个非常狭长的单元。\n  - 点 $\\mathbf{p}_3 = (0, 0.5)$，位于长边 $\\overline{\\mathbf{a}\\mathbf{c}}$ 上。\n  - 点 $\\mathbf{p}_4 = (0, 0)$，恰好位于顶点 $\\mathbf{a}$ 处。\n- 网格 $\\mathcal{M}_3$，包含索引为 $0$ 的三角形：\n  - 三角形 $0$：顶点 $\\mathbf{a} = (0,0)$, $\\mathbf{b} = (2, 0)$, $\\mathbf{c} = (2, 2 \\cdot 10^{-12})$，另一个近乎共线的极端狭长单元。\n  - 点 $\\mathbf{p}_5 = (1, 10^{-12})$，靠近边 $\\overline{\\mathbf{a}\\mathbf{b}}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例对应一个形如 $[i, b]$ 的子列表，其中 $i$ 是所选鲁棒三角形的索引（一个整数），$b$ 是错误分类的布尔值。对于所描述的五个测试用例，您的输出必须严格遵循格式\n$[[i_1,b_1],[i_2,b_2],[i_3,b_3],[i_4,b_4],[i_5,b_5]]$。", "solution": "用户要求设计并实现一个鲁棒算法，用于在二维三角形网格中定位一个点，同时考虑浮点数的不精确性。这涉及到基于后向误差分析推导重心坐标分类的容差。\n\n### 问题验证\n\n问题陈述已经过验证，被认为是**有效的**。它在计算几何和数值线性代数方面有科学依据，是适定的、客观的且自洽的。虽然朴素定位器的容差 $\\delta$ 没有给定具体值，但它被描述为“一个固定的微小阈值”，对此使用机器 epsilon 是一个标准且合理的选择。在鲁棒方法中，对重心坐标和的检查 $|\\sum \\lambda_i - 1| \\le 3\\tau$ 比根据 $\\lambda_a$ 的规定计算方法所必需的更为宽松，但这并不构成致命的矛盾，可以按规定实现。\n\n### 第 1 部分：分类容差 $\\tau$ 的推导\n\n一个粒子在 $\\mathbf{p} \\in \\mathbb{R}^2$ 的位置可以用三角形顶点 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 通过重心坐标 $\\lambda_a$、$\\lambda_b$ 和 $\\lambda_c$ 来表示：\n$$ \\mathbf{p} = \\lambda_a \\mathbf{a} + \\lambda_b \\mathbf{b} + \\lambda_c \\mathbf{c} $$\n约束条件为：\n$$ \\lambda_a + \\lambda_b + \\lambda_c = 1 $$\n一个点 $\\mathbf{p}$ 在三角形内部或边界上的充分必要条件是，对于 $i \\in \\{a,b,c\\}$，有 $0 \\le \\lambda_i \\le 1$。\n\n按照规定，我们可以通过求解一个 $2 \\times 2$ 线性系统来找到 $\\lambda_b$ 和 $\\lambda_c$。将 $\\lambda_a = 1 - \\lambda_b - \\lambda_c$ 代入位置方程可得：\n$$ \\mathbf{p} = (1 - \\lambda_b - \\lambda_c)\\mathbf{a} + \\lambda_b \\mathbf{b} + \\lambda_c \\mathbf{c} $$\n$$ \\mathbf{p} - \\mathbf{a} = \\lambda_b (\\mathbf{b} - \\mathbf{a}) + \\lambda_c (\\mathbf{c} - \\mathbf{a}) $$\n这可以写成矩阵形式 $\\mathbf{A}\\mathbf{x} = \\mathbf{y}$，其中：\n$$ \\mathbf{A} = \\begin{bmatrix} \\mathbf{b} - \\mathbf{a}  \\mathbf{c} - \\mathbf{a} \\end{bmatrix} \\in \\mathbb{R}^{2 \\times 2}, \\quad \\mathbf{x} = \\begin{bmatrix} \\lambda_b \\\\ \\lambda_c \\end{bmatrix}, \\quad \\mathbf{y} = \\mathbf{p} - \\mathbf{a} $$\n当使用浮点运算求解该系统时，相对于真实解 $\\mathbf{x}$ 的计算解 $\\hat{\\mathbf{x}}$ 会包含误差。求解线性系统（例如，使用带部分主元法的 LU 分解）的标准后向误差分析指出，计算解 $\\hat{\\mathbf{x}}$ 是一个扰动系统的精确解：\n$$ (\\mathbf{A} + \\mathbf{E})\\hat{\\mathbf{x}} = \\mathbf{y} $$\n其中 $\\mathbf{E}$ 是一个后向误差矩阵。$\\mathbf{E}$ 的范数的一个标准界限由下式给出：\n$$ \\|\\mathbf{E}\\|_2 \\le C_s u \\|\\mathbf{A}\\|_2 $$\n其中 $u$ 是单位舍入误差（机器 epsilon），$C_s$ 是一个小的常数，取决于维度（$n=2$）和求解器的稳定性（例如，与增长因子相关，对于 $n=2$ 而言该因子很小）。\n\n前向误差 $\\delta\\mathbf{x} = \\hat{\\mathbf{x}} - \\mathbf{x}$ 是有界的。从 $\\mathbf{x} = \\mathbf{A}^{-1}\\mathbf{y}$ 和 $\\hat{\\mathbf{x}} = (\\mathbf{A}+\\mathbf{E})^{-1}\\mathbf{y}$，我们有：\n$$ \\hat{\\mathbf{x}} - \\mathbf{x} = ((\\mathbf{A}+\\mathbf{E})^{-1} - \\mathbf{A}^{-1})\\mathbf{y} \\approx -\\mathbf{A}^{-1}\\mathbf{E}\\mathbf{A}^{-1}\\mathbf{y} = -\\mathbf{A}^{-1}\\mathbf{E}\\mathbf{x} $$\n取范数，我们得到前向误差的一个界限：\n$$ \\|\\delta\\mathbf{x}\\|_2 = \\|\\hat{\\mathbf{x}} - \\mathbf{x}\\|_2 \\le \\|\\mathbf{A}^{-1}\\|_2 \\|\\mathbf{E}\\|_2 \\|\\mathbf{x}\\|_2 $$\n代入 $\\|\\mathbf{E}\\|_2$ 的界限：\n$$ \\|\\delta\\mathbf{x}\\|_2 \\le \\|\\mathbf{A}^{-1}\\|_2 (C_s u \\|\\mathbf{A}\\|_2) \\|\\mathbf{x}\\|_2 = C_s u (\\|\\mathbf{A}\\|_2 \\|\\mathbf{A}^{-1}\\|_2) \\|\\mathbf{x}\\|_2 $$\n$$ \\|\\delta\\mathbf{x}\\|_2 \\le C_s u \\kappa_2(\\mathbf{A}) \\|\\mathbf{x}\\|_2 $$\n其中 $\\kappa_2(\\mathbf{A}) = \\|\\mathbf{A}\\|_2 \\|\\mathbf{A}^{-1}\\|_2$ 是 $\\mathbf{A}$ 的谱条件数。\n\n$\\mathbf{x}$ 的各个分量（即 $\\delta\\lambda_b$ 和 $\\delta\\lambda_c$）的误差受误差向量的范数限制：$\\max (|\\delta\\lambda_b|, |\\delta\\lambda_c|) \\le \\|\\delta\\mathbf{x}\\|_2$。\n$\\lambda_a$ 中的误差由其定义 $\\lambda_a = 1 - \\lambda_b - \\lambda_c$ 推导得出。计算值为 $\\hat{\\lambda}_a = 1 - \\hat{\\lambda}_b - \\hat{\\lambda}_c$（在此步骤中为精确算术）。误差为：\n$$ \\delta\\lambda_a = \\hat{\\lambda}_a - \\lambda_a = (1 - \\hat{\\lambda}_b - \\hat{\\lambda}_c) - (1 - \\lambda_b - \\lambda_c) = -(\\hat{\\lambda}_b - \\lambda_b) - (\\hat{\\lambda}_c - \\lambda_c) = -(\\delta\\lambda_b + \\delta\\lambda_c) $$\n该误差的大小有界：\n$$ |\\delta\\lambda_a| \\le |\\delta\\lambda_b| + |\\delta\\lambda_c| \\le \\sqrt{2}\\sqrt{(\\delta\\lambda_b)^2 + (\\delta\\lambda_c)^2} = \\sqrt{2}\\|\\delta\\mathbf{x}\\|_2 $$\n因此，所有三个重心坐标上的最大误差的界限为 $\\sqrt{2}\\|\\delta\\mathbf{x}\\|_2$。我们将容差 $\\tau$ 定义为该最大误差的一个安全上界：\n$$ \\tau = \\sqrt{2} \\|\\delta\\mathbf{x}\\|_2 \\le \\sqrt{2} C_s u \\kappa_2(\\mathbf{A}) \\|\\mathbf{x}\\|_2 $$\n由于真实解 $\\mathbf{x}$ 未知，我们使用计算解 $\\hat{\\mathbf{x}}$ 作为近似，即 $\\|\\mathbf{x}\\|_2 \\approx \\|\\hat{\\mathbf{x}}\\|_2$。我们选择一个相当保守的常数 $C = \\sqrt{2}C_s$。对于一个 $2 \\times 2$ 系统，选择 $C=6$ 是足够的。这导出了容差 $\\tau$ 的最终公式：\n$$ \\tau = C u \\kappa_2(\\mathbf{A}) \\|\\hat{\\mathbf{x}}\\|_2 = C u \\kappa_2(\\mathbf{A}) \\left\\| \\begin{bmatrix} \\hat{\\lambda}_b \\\\ \\hat{\\lambda}_c \\end{bmatrix} \\right\\|_2 $$\n这个 $\\tau$ 的表达式依赖于单位舍入误差 $u$、条件数 $\\kappa_2(\\mathbf{A})$ 和计算解向量的范数，而后者又依赖于 $\\mathbf{A}$ 和 $\\mathbf{p}-\\mathbf{a}$。这满足了所有要求。\n\n### 第 2 部分：算法设计\n\n**鲁棒定位器算法：**\n对于网格中的每个三角形：\n1.  构造矩阵 $\\mathbf{A} = [\\mathbf{b}-\\mathbf{a}, \\mathbf{c}-\\mathbf{a}]$ 和向量 $\\mathbf{y} = \\mathbf{p}-\\mathbf{a}$。\n2.  尝试求解 $\\mathbf{A}\\mathbf{x} = \\mathbf{y}$ 以得到 $\\mathbf{x} = [\\lambda_b, \\lambda_c]^\\top$。如果矩阵是奇异的，则该点无法在此三角形中定位。\n3.  计算 $\\lambda_a = 1 - \\lambda_b - \\lambda_c$。\n4.  计算容差 $\\tau = C u \\kappa_2(\\mathbf{A}) \\|\\mathbf{x}\\|_2$，其中 $C=6$，$u$ 为机器 epsilon。\n5.  如果所有重心坐标 $\\lambda_i$ 满足 $\\lambda_i \\ge -\\tau$ 且求和条件 $|\\lambda_a + \\lambda_b + \\lambda_c - 1| \\le 3\\tau$ 成立，则将该点分类为“鲁棒地在内部”。\n6.  维护一个列表，包含所有满足此鲁棒准则的三角形。\n7.  如果找到一个或多个候选三角形，选择使最小重心坐标 $\\min(\\lambda_a, \\lambda_b, \\lambda_c)$ 最大化的那个。通过选择具有最小三角形索引的候选者来打破平局。如果没有三角形满足该准则，则返回一个未找到三角形的指示符（例如，索引 $-1$）。\n\n**朴素定位器算法：**\n按索引顺序，对于网格中的每个三角形：\n1.  如上计算重心坐标 $(\\lambda_a, \\lambda_b, \\lambda_c)$。\n2.  如果对于所有 $i \\in \\{a, b, c\\}$ 都有 $\\lambda_i \\ge 0$ 且 $|\\lambda_a + \\lambda_b + \\lambda_c - 1| \\le \\delta$（其中 $\\delta$ 是一个固定的微小阈值，我们使用 $\\delta = u$），则将该点分类为在内部。\n3.  返回第一个通过此测试的三角形的索引。\n4.  如果循环完成而没有找到这样的三角形，则返回一个未找到三角形的指示符。\n\n这两种算法的配对允许将一个简单的几何测试与一个数值鲁棒的测试进行直接比较，从而突显出在病态（狭长）单元边界附近的点所发生的错误分类。\n\n### 第 3 部分：实现\n```python\nimport numpy as np\nfrom typing import List, Tuple\n\n# Type definitions for clarity\nPoint = Tuple[float, float]\nTriangle = Tuple[Point, Point, Point]\nMesh = List[Triangle]\n\ndef calculate_barycentric_coords(triangle: Triangle, point: Point):\n    \"\"\"\n    Computes barycentric coordinates of a point w.r.t. a triangle.\n    \n    The coordinates (lambda_a, lambda_b, lambda_c) for a point p and triangle\n    vertices (a,b,c) are found by solving the linear system derived from:\n    p = lambda_a*a + lambda_b*b + lambda_c*c\n    1 = lambda_a + lambda_b + lambda_c\n\n    This leads to A*x = y, where:\n    A = [b-a, c-a]\n    x = [lambda_b, lambda_c]^T\n    y = p-a\n    and lambda_a = 1 - lambda_b - lambda_c.\n\n    Returns:\n        A tuple containing:\n        - np.ndarray: The array of barycentric coordinates [lambda_a, lambda_b, lambda_c].\n        - np.ndarray: The matrix A used in the calculation.\n        - np.ndarray: The solution vector x = [lambda_b, lambda_c].\n        Returns (None, None, None) if the system is not solvable.\n    \"\"\"\n    a, b, c = np.array(triangle[0]), np.array(triangle[1]), np.array(triangle[2])\n    p = np.array(point)\n\n    # Form the linear system A*x = y, with A being a 2x2 matrix\n    mat_a = np.array([b - a, c - a]).T\n    vec_y = p - a\n\n    try:\n        # Solve for x = [lambda_b, lambda_c]\n        x_c = np.linalg.solve(mat_a, vec_y)\n        lambda_b_c = x_c[0]\n        lambda_c_c = x_c[1]\n\n        # Calculate the third coordinate based on the sum-to-one property\n        lambda_a_c = 1.0 - lambda_b_c - lambda_c_c\n        \n        lambdas = np.array([lambda_a_c, lambda_b_c, lambda_c_c])\n        return lambdas, mat_a, x_c\n    except np.linalg.LinAlgError:\n        # Matrix is singular or near-singular. Point cannot be uniquely located in this element.\n        return None, None, None\n\ndef locate_robust(mesh: Mesh, point: Point) - int:\n    \"\"\"\n    Finds the triangle containing the point using a robust classification method.\n    The method uses a dynamically computed tolerance `tau` based on matrix\n    conditioning to avoid misclassification near element boundaries.\n    \"\"\"\n    candidate_triangles = []\n    u = np.finfo(float).eps\n\n    for i, tri in enumerate(mesh):\n        lambdas, mat_a, x_c = calculate_barycentric_coords(tri, point)\n        \n        if lambdas is None:\n            continue\n\n        # Derived tolerance `tau`\n        # tau = C * u * kappa * ||x_c||\n        # A small integer constant C is chosen based on backward error analysis.\n        C = 6.0\n        kappa = np.linalg.cond(mat_a, 2)\n        norm_x = np.linalg.norm(x_c, 2)\n        tau = C * u * kappa * norm_x\n        \n        # Robustness checks\n        sum_check = abs(np.sum(lambdas) - 1.0) = 3 * tau\n        sign_check = np.all(lambdas >= -tau)\n\n        if sum_check and sign_check:\n            candidate_triangles.append({'index': i, 'min_lambda': np.min(lambdas)})\n            \n    if not candidate_triangles:\n        return -1\n\n    # Select the best candidate based on the problem's criteria:\n    # 1. Maximize the minimum barycentric coordinate.\n    # 2. Break ties by the smallest triangle index.\n    # Sorting ensures this: primary key is -min_lambda (so max comes first),\n    # secondary key is the index.\n    sorted_candidates = sorted(candidate_triangles, key=lambda d: (-d['min_lambda'], d['index']))\n    \n    return sorted_candidates[0]['index']\n\n\ndef locate_naive(mesh: Mesh, point: Point) - int:\n    \"\"\"\n    Finds the triangle containing the point using a naive classification.\n    The method uses a fixed, small tolerance `delta` and a strict non-negativity test.\n    \"\"\"\n    # Per the problem description, `delta` is a fixed tiny threshold.\n    # We choose machine epsilon as a standard value for this.\n    delta = np.finfo(float).eps\n\n    for i, tri in enumerate(mesh):\n        lambdas, _, _ = calculate_barycentric_coords(tri, point)\n        \n        if lambdas is None:\n            continue\n\n        # Naive checks\n        sum_check = abs(np.sum(lambdas) - 1.0) = delta\n        sign_check = np.all(lambdas >= 0.0)\n\n        if sum_check and sign_check:\n            # \"selects the first triangle that passes this test\"\n            return i\n            \n    return -1\n\n\ndef solve_for_problem2():\n    \"\"\"\n    Main function to run the test suite and produce the final output for problem 2.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Mesh M1\n    tri0_m1 = ((0.0, 0.0), (1.0, 0.0), (1.0, 1.0))\n    tri1_m1 = ((0.0, 0.0), (1.0, 1.0), (0.0, 1.0))\n    mesh1 = [tri0_m1, tri1_m1]\n    \n    # Mesh M2\n    tri0_m2 = ((0.0, 0.0), (1e-8, 0.0), (0.0, 1.0))\n    mesh2 = [tri0_m2]\n\n    # Mesh M3\n    tri0_m3 = ((0.0, 0.0), (2.0, 0.0), (2.0, 2e-12))\n    mesh3 = [tri0_m3]\n\n    test_cases = [\n        (mesh1, (0.7, 0.2)),    # Case 1: p1, general inside point in M1\n        (mesh1, (0.5, 0.5)),    # Case 2: p2, exactly on shared boundary in M1\n        (mesh2, (0.0, 0.5)),    # Case 3: p3, on long edge of skinny triangle in M2\n        (mesh2, (0.0, 0.0)),    # Case 4: p4, exactly at a vertex in M2\n        (mesh3, (1.0, 1e-12)),  # Case 5: p5, on edge of extremely skinny triangle in M3\n    ]\n    \n    final_results = []\n    \n    for mesh, point in test_cases:\n        robust_idx = locate_robust(mesh, point)\n        naive_idx = locate_naive(mesh, point)\n        \n        # Misclassification occurs if the naive locator fails to find a triangle\n        # or identifies a different one than the robust locator.\n        misclassified = (robust_idx != naive_idx)\n        final_results.append([robust_idx, misclassified])\n        \n    # Format the final output according to the specified single-line format.\n    result_str_list = [f\"[{res[0]}, {str(res[1])}]\" for res in final_results]\n    return f\"[{','.join(result_str_list)}]\"\n\n# The function call is commented out to prevent execution in a non-python environment.\n# print(solve_for_problem2())\n```", "answer": "[[0, False],[0, True],[0, True],[0, True],[0, True]]", "id": "3512704"}, {"introduction": "一旦确定了粒子-单元对，就必须计算它们之间的力学相互作用。本练习通过实现一个历史依赖的库仑摩擦模型（该模型控制着粘着-滑移行为），深入探讨了接触力学的核心。您将使用预测-校正算法，一种在计算塑性力学中广泛使用的技术，来增量式地更新接触力，同时严格执行摩擦定律 [@problem_id:3512619]。", "problem": "在计算岩土力学中，考虑离散元法（DEM）粒子与有限元法（FEM）边界之间的单个接触。该接触在切向遵循库仑摩擦定律和线性弹性定律，并通过存储的弹性切向位移表现出历史相关性。设状态变量为局部切平面中的弹性切向位移向量 $\\boldsymbol{\\delta}_t \\in \\mathbb{R}^d$，切向接触力由胡克定律给出 $\\mathbf{f}_t = k_t \\boldsymbol{\\delta}_t$，其中 $k_t > 0$ 是切向接触刚度。库仑摩擦约束要求切向力的大小满足不等式 $||\\mathbf{f}_t|| \\le \\mu f_n$，其中 $\\mu \\ge 0$ 是摩擦系数，$f_n \\ge 0$ 是法向压缩接触力的大小。一个时间步内的增量切向相对位移为 $\\Delta \\mathbf{u}_t \\in \\mathbb{R}^d$。更新必须是历史相关的：新的弹性切向位移取决于先前的状态和增量。\n\n从接触力学的基本原理和核心定义出发：\n- 牛顿第二定律，\n- 切向的胡克定律 $\\mathbf{f}_t = k_t \\boldsymbol{\\delta}_t$，\n- 由容许集 $\\{\\mathbf{f}_t \\in \\mathbb{R}^d \\mid ||\\mathbf{f}_t|| \\le \\mu f_n\\}$ 表示的库仑摩擦定律，\n- 粘滞状态下切向位移弹性部分的增量运动学可加性，\n\n推导一个用于切向接触力的预测-校正增量更新法则，以在步末强制执行 $||\\mathbf{f}_t|| \\le \\mu f_n$。预测器应假设纯弹性粘滞行为，而校正器应在库仑约束被违反时（粘滑转换），对弹性切向位移进行最小调整以满足该约束。您的更新必须：\n- 使用弹性试探状态来预测 $\\boldsymbol{\\delta}_t^{\\text{trial}}$ 和 $\\mathbf{f}_t^{\\text{trial}}$，\n- 通过检查试探力的库仑容许性来判断粘滞与滑动，\n- 在粘滞情况下，接受试探状态，\n- 在滑动情况下，校正弹性切向位移，使更新后的力位于边界 $||\\mathbf{f}_t|| = \\mu f_n$ 上，并与试探状态方向相同，确保为恢复容许性做出最小的必要改变。\n\n实现一个程序，为每个测试用例计算更新后的切向力大小 $||\\mathbf{f}_t^{n+1}||$（单位为牛顿）和一个粘滞指示符（粘滞时为整数 $1$，滑动时为 $0$）。程序必须接受每个测试用例的以下参数：先前的弹性切向位移 $\\boldsymbol{\\delta}_t^n$（单位为米），增量 $\\Delta \\mathbf{u}_t$（单位为米），切向刚度 $k_t$（单位为牛顿/米），摩擦系数 $\\mu$（无量纲），以及法向力大小 $f_n$（单位为牛顿）。假设切向空间是二维的，即 $d = 2$。\n\n以牛顿为单位表示最终的切向力大小，并以整数表示粘滞指示符。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果表示为一个列表 $\\left[||\\mathbf{f}_t^{n+1}||, s\\right]$，其中 $s \\in \\{0,1\\}$。\n\n使用以下六个参数集的测试套件来检验更新法则，涵盖一般情况、滑动、边界相等、零法向力、非零历史和混合方向滑动。对于每个集合，列出参数 $\\left(\\boldsymbol{\\delta}_t^n, \\Delta \\mathbf{u}_t, k_t, \\mu, f_n\\right)$:\n\n- 测试 $1$ (一般粘滞): $\\boldsymbol{\\delta}_t^n = [0, 0]$ 米, $\\Delta \\mathbf{u}_t = [0.002, 0]$ 米, $k_t = 100000$ 牛顿/米, $\\mu = 0.6$, $f_n = 1000$ 牛顿。\n- 测试 $2$ (一般滑动): $\\boldsymbol{\\delta}_t^n = [0, 0]$ 米, $\\Delta \\mathbf{u}_t = [0.01, 0]$ 米, $k_t = 100000$ 牛顿/米, $\\mu = 0.6$, $f_n = 1000$ 牛顿。\n- 测试 $3$ (边界相等): $\\boldsymbol{\\delta}_t^n = [0, 0]$ 米, $\\Delta \\mathbf{u}_t = [0.006, 0]$ 米, $k_t = 100000$ 牛顿/米, $\\mu = 0.6$, $f_n = 1000$ 牛顿。\n- 测试 $4$ (零法向力): $\\boldsymbol{\\delta}_t^n = [0, 0]$ 米, $\\Delta \\mathbf{u}_t = [0.01, 0]$ 米, $k_t = 100000$ 牛顿/米, $\\mu = 0.6$, $f_n = 0$ 牛顿。\n- 测试 $5$ (导致滑动的非零历史): $\\boldsymbol{\\delta}_t^n = [0.005, 0]$ 米, $\\Delta \\mathbf{u}_t = [0.003, 0]$ 米, $k_t = 100000$ 牛顿/米, $\\mu = 0.6$, $f_n = 1000$ 牛顿。\n- 测试 $6$ (混合方向滑动): $\\boldsymbol{\\delta}_t^n = [0.002, 0.002]$ 米, $\\Delta \\mathbf{u}_t = [0.004, -0.003]$ 米, $k_t = 100000$ 牛顿/米, $\\mu = 0.6$, $f_n = 1000$ 牛顿。\n\n您的程序必须计算每个测试用例的更新后切向力大小 $||\\mathbf{f}_t^{n+1}||$（单位为牛顿）和作为整数的粘滞指示符。程序必须输出包含六个结果的单行逗号分隔列表，格式为 $\\left[ [||\\mathbf{f}_t^{n+1}||, s], \\ldots \\right]$。", "solution": "该问题陈述是有效的，因为它在计算接触力学中提出了一个适定且有科学依据的问题，并为其解决提供了所有必要的数据。任务是推导并实现一个预测-校正算法，也称为返回映射算法，用于在库仑摩擦定律下更新切向接触力。\n\n时间步开始时的接触状态（由上标 $n$ 表示）由弹性切向位移向量 $\\boldsymbol{\\delta}_t^n$ 表征。目标是计算时间步结束时（$n+1$）的更新状态，给定在该步中发生的增量相对切向位移 $\\Delta \\mathbf{u}_t$。控制接触的基本方程是切向力的胡克定律 $\\mathbf{f}_t = k_t \\boldsymbol{\\delta}_t$ 和库仑摩擦约束 $||\\mathbf{f}_t|| \\le \\mu f_n$。\n\n推导过程分三个阶段进行：假设弹性行为的预测阶段，对照摩擦准则的容许性检查阶段，以及在违反准则时强制执行该准则的校正阶段。\n\n**1. 预测器：弹性试探状态**\n\n预测步骤假设接触面“粘滞”，意味着增量相对位移 $\\Delta \\mathbf{u}_t$ 完全由弹性切向位移的变化来适应。步末的试探弹性切向位移 $\\boldsymbol{\\delta}_t^{\\text{trial}}$ 通过将位移增量加到先前的弹性位移上来计算：\n$$\n\\boldsymbol{\\delta}_t^{\\text{trial}} = \\boldsymbol{\\delta}_t^n + \\Delta \\mathbf{u}_t\n$$\n其中 $\\boldsymbol{\\delta}_t^n$ 是时间步开始时的弹性切向位移。\n\n使用胡克定律，相应的试探切向接触力 $\\mathbf{f}_t^{\\text{trial}}$ 为：\n$$\n\\mathbf{f}_t^{\\text{trial}} = k_t \\boldsymbol{\\delta}_t^{\\text{trial}}\n$$\n\n**2. 容许性检查：库仑摩擦定律**\n\n库仑摩擦定律定义了一个容许切向力的凸集。一个切向力 $\\mathbf{f}_t$ 是容许的，当且仅当其大小不超过最大静摩擦力，该力与法向接触力大小 $f_n$ 成正比。设 $f_{t,\\text{max}}$ 为此最大大小：\n$$\nf_{t,\\text{max}} = \\mu f_n\n$$\n其中 $\\mu$ 是摩擦系数。请注意，问题将 $f_n$ 作为当前步的法向力大小提供，我们将其解释为 $f_n^{n+1}$。容许性条件是：\n$$\n||\\mathbf{f}_t|| \\le f_{t,\\text{max}}\n$$\n我们对试探力 $\\mathbf{f}_t^{\\text{trial}}$ 评估此条件。\n\n**3. 校正器：状态更新**\n\n更新法则取决于容许性检查的结果。\n\n**情况 A：粘滞条件**\n\n如果试探力的大小在容许范围内，即\n$$\n||\\mathbf{f}_t^{\\text{trial}}|| \\le f_{t,\\text{max}}\n$$\n则最初的“粘滞”假设得到验证。接触不发生滑动。时间步结束时（$n+1$）的最终状态与试探状态相同。粘滞指示符 $s$ 设置为 $1$。\n- 更新后的弹性切向位移：$\\boldsymbol{\\delta}_t^{n+1} = \\boldsymbol{\\delta}_t^{\\text{trial}}$\n- 更新后的切向力：$\\mathbf{f}_t^{n+1} = \\mathbf{f}_t^{\\text{trial}}$\n- 更新后的切向力大小：$||\\mathbf{f}_t^{n+1}|| = ||\\mathbf{f}_t^{\\text{trial}}||$\n- 粘滞指示符：$s = 1$\n\n这种情况也能正确处理 $||\\mathbf{f}_t^{\\text{trial}}|| = f_{t,\\text{max}}$ 的边界条件。\n\n**情况 B：滑动条件**\n\n如果试探力的大小超过容许极限，即\n$$\n||\\mathbf{f}_t^{\\text{trial}}|| > f_{t,\\text{max}}\n$$\n则“粘滞”假设无效。接触必须滑动，并发生塑性（不可逆）变形。更新后的切向力 $\\mathbf{f}_t^{n+1}$ 必须位于容许区域的边界（摩擦圆）上。最小变化原理（或者更正式地，最大塑性耗散原理）规定，校正是通过将试探力径向返回到摩擦圆上进行的。这意味着最终的力向量 $\\mathbf{f}_t^{n+1}$ 与试探力向量 $\\mathbf{f}_t^{\\text{trial}}$ 方向相同，但其大小被缩减至 $f_{t,\\text{max}}$。粘滞指示符 $s$ 设置为 $0$。\n\n更新后的力计算如下：\n$$\n\\mathbf{f}_t^{n+1} = f_{t,\\text{max}} \\frac{\\mathbf{f}_t^{\\text{trial}}}{||\\mathbf{f}_t^{\\text{trial}}||}\n$$\n这可以用一个缩放因子 $\\gamma$ 来表示：\n$$\n\\gamma = \\frac{f_{t,\\text{max}}}{||\\mathbf{f}_t^{\\text{trial}}||}\n$$\n在滑动情况下，$0 \\le \\gamma  1$。更新后的状态变量为：\n- 更新后的切向力：$\\mathbf{f}_t^{n+1} = \\gamma \\mathbf{f}_t^{\\text{trial}}$\n- 更新后的弹性切向位移：$\\boldsymbol{\\delta}_t^{n+1} = \\gamma \\boldsymbol{\\delta}_t^{\\text{trial}}$\n- 更新后的切向力大小：$||\\mathbf{f}_t^{n+1}|| = f_{t,\\text{max}} = \\mu f_n$\n- 粘滞指示符：$s = 0$\n\n这种径向返回公式确保了唯一且物理上一致的解。它还能正确处理 $f_n = 0$ 的情况，此时 $f_{t,\\text{max}} = 0$。任何非零的试探力都将导致滑动，最终的力大小将正确更新为 $0$。\n\n实现将对每个提供的测试用例遵循此算法逻辑。\n\n### 实现\n```python\nimport numpy as np\n\ndef solve_for_problem3():\n    \"\"\"\n    Computes the updated tangential contact force and stick/slip status\n    for a series of test cases based on a predictor-corrector algorithm\n    for Coulomb friction.\n    \"\"\"\n    # Test cases defined as tuples of:\n    # (delta_t_n, delta_u_t, k_t, mu, f_n)\n    # where delta_t_n and delta_u_t are 2D vectors.\n    test_cases = [\n        (np.array([0.0, 0.0]), np.array([0.002, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.0, 0.0]), np.array([0.01, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.0, 0.0]), np.array([0.006, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.0, 0.0]), np.array([0.01, 0.0]), 100000.0, 0.6, 0.0),\n        (np.array([0.005, 0.0]), np.array([0.003, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.002, 0.002]), np.array([0.004, -0.003]), 100000.0, 0.6, 1000.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_t_n, delta_u_t, k_t, mu, f_n = case\n\n        # Step 1: Predictor (Elastic Trial State)\n        # Assume pure stick behavior where the incremental displacement is purely elastic.\n        delta_t_trial = delta_t_n + delta_u_t\n        f_t_trial = k_t * delta_t_trial\n\n        # Step 2: Admissibility Check\n        # Calculate the magnitude of the trial force and the maximum allowable friction force.\n        f_t_trial_norm = np.linalg.norm(f_t_trial)\n        f_t_max = mu * f_n\n\n        # Step 3: Corrector (Update based on stick/slip condition)\n        if f_t_trial_norm = f_t_max:\n            # Case A: Stick condition is met.\n            # The trial state is the final state.\n            f_t_final_norm = f_t_trial_norm\n            stick_indicator = 1\n        else:\n            # Case B: Slip condition.\n            # The force is corrected by scaling it back to the friction circle.\n            # The magnitude of the final force is the maximum allowable friction force.\n            f_t_final_norm = f_t_max\n            stick_indicator = 0\n        \n        results.append([f_t_final_norm, stick_indicator])\n\n    # Format the final output string as a list of lists.\n    # Each inner list is formatted as [force_magnitude, stick_indicator].\n    formatted_results = [f\"[{res[0]}, {res[1]}]\" for res in results]\n    return f\"[{','.join(formatted_results)}]\"\n\n# The function call is commented out to prevent execution in a non-python environment.\n# print(solve_for_problem3())\n```", "answer": "[[200.0, 1],[600.0, 0],[600.0, 1],[0.0, 0],[600.0, 0],[600.0, 0]]", "id": "3512619"}]}