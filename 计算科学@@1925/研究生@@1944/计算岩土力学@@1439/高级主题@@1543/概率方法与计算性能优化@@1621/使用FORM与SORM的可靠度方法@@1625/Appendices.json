{"hands_on_practices": [{"introduction": "本实践从一个经典的岩土工程问题——无限边坡的稳定性分析——入手，旨在帮助您掌握一阶可靠度方法 (FORM) 的基本应用。通过为一个线性极限状态函数推导并计算可靠度指标 $\\beta$，您将亲身体会随机变量之间的相关性如何影响系统的整体可靠性。这项练习 [@problem_id:3556073] 是理解更复杂可靠度分析的基石。", "problem": "考虑一个黏聚-摩擦性土坡的平面极限平衡问题，该土坡受莫尔-库仑剪切强度准则控制，其剪切强度由 $\\tau = c + \\sigma_n \\tan\\varphi$ 给出。重点研究长边坡（单位宽度）上平行于坡面的平移（平面）滑动，假设为干燥条件且无孔隙水压力。设坡体倾角为 $\\theta$（单位为度），潜在滑动面位于垂直深度 $z$（单位为米）处。单位重量 $\\gamma$（单位为千牛/立方米）是确定性的。不确定的土壤参数为黏聚力 $c$（单位为千帕）和摩擦度量 $\\tan\\varphi$（无量纲），它们被建模为联合正态分布，其均值为 $\\mu_c$ 和 $\\mu_{\\tan\\varphi}$，标准差为 $\\sigma_c$ 和 $\\sigma_{\\tan\\varphi}$，相关系数为 $\\rho_{c,\\tan\\varphi} \\in (-1,1)$。所有其他量均为确定性的。\n\n使用以下基本依据：(i) 莫尔-库仑强度的定义，(ii) 沿坡面和垂直于坡面方向的静力平衡，以及 (iii) 将极限状态函数 $g(\\mathbf{X})$ 定义为总抗力与总驱动作用之差，其中破坏由 $g(\\mathbf{X}) \\le 0$ 定义。在一阶可靠度方法 (FORM) 中，可靠度指标定义为 Hasofer–Lind 可靠度指标 $\\beta$，即标准正态空间中原点到极限状态面 $g=0$ 的最小距离。如果 $g(\\mathbf{X})$ 对于基本随机变量是仿射的，并且这些变量服从联合正态分布，那么 $g$ 也服从正态分布，其可靠度指标可以用其在原始空间中的均值和标准差表示。\n\n任务：在上述假设下，使用第一性原理推导平行于坡面的平面滑动的极限状态函数 $g(c,\\tan\\varphi)$，然后计算下面指定的每个测试用例的 FORM 可靠度指标 $\\beta$。你的程序必须：\n- 在计算中将任何以度为单位的角度输入转换为弧度。\n- 在每个测试用例中，将 $\\gamma$、$\\theta$ 和 $z$ 视为确定性常数。\n- 将 $c$ 和 $\\tan\\varphi$ 视为具有给定均值、标准差和相关系数 $\\rho_{c,\\tan\\varphi}$ 的联合正态分布。\n- 仅使用推导出的、基于第一性原理的 $g(c,\\tan\\varphi)$ 表达式，以及与一阶可靠度方法对于正态分布的仿射极限状态函数相一致的 $\\beta$ 表达式。\n\n你的程序必须生成单行输出，其中包含所有测试用例的可靠度指标，形式为用方括号括起来的逗号分隔列表（例如，“[beta1,beta2,...]”），其中每个条目都是一个浮点数。不允许有其他文本。\n\n角度单位要求：所有角度输入均以度为单位提供；在进行任何三角运算时，请在内部将其转换为弧度。\n\n物理单位：输入请使用以下单位：$c$ 的单位为千帕，$\\gamma$ 的单位为千牛/立方米，$z$ 的单位为米，$\\theta$ 的单位为度。输出（可靠度指标）为无量纲浮点数。\n\n测试套件：\n每个测试用例是一个元组 $\\left(\\mu_c,\\sigma_c,\\mu_{\\tan\\varphi},\\sigma_{\\tan\\varphi},\\gamma,z,\\theta,\\rho_{c,\\tan\\varphi}\\right)$，使用上述单位和约定。\n\n- 案例 1（正常路径，负相关）：$\\left(10.0,3.0,\\tan(28^\\circ),0.08,18.0,5.0,30.0,-0.8\\right)$。\n- 案例 2（正常路径，零相关）：$\\left(10.0,3.0,\\tan(28^\\circ),0.08,18.0,5.0,30.0,0.0\\right)$。\n- 案例 3（正常路径，正相关）：$\\left(10.0,3.0,\\tan(28^\\circ),0.08,18.0,5.0,30.0,0.8\\right)$。\n- 案例 4（接近临界平均安全性，强正相关）：$\\left(5.0,3.0,\\tan(28^\\circ),0.08,18.0,5.0,30.0,0.9\\right)$。\n- 案例 5（边界覆盖，接近相关性上限）：$\\left(10.0,3.0,\\tan(28^\\circ),0.08,18.0,5.0,30.0,0.95\\right)$。\n- 案例 6（边界覆盖，接近相关性下限）：$\\left(10.0,3.0,\\tan(28^\\circ),0.08,18.0,5.0,30.0,-0.95\\right)$。\n\n要求的最终输出格式：你的程序应生成单行输出，包含与测试套件案例顺序相同的、用方括号括起来的逗号分隔结果列表，例如，“[result1,result2,result3,result4,result5,result6]”。", "solution": "我们从莫尔-库仑剪切强度表达式 $\\tau = c + \\sigma_n \\tan\\varphi$ 开始，其中 $c$ 是黏聚力，$\\varphi$ 是摩擦角。考虑一个干燥的黏聚-摩擦性土体，其坡体倾角为 $\\theta$，滑动面深度为 $z$，宽度为单位宽度，其平移破坏面平行于坡面。设 $\\gamma$ 表示单位重量。在单位水平长度上，考虑一个垂直测量的厚度为 $z$ 的土条。其单位宽度上的重量为 $W = \\gamma z \\cdot 1$，并适当地沿坡面进行投影。对于长边坡（有效无限长）且滑动面平行于坡面的经典静力学分析表明，重量沿滑动面的分量为 $W \\sin\\theta$，法向分量为 $W \\cos\\theta$。对于单位宽度，并将有效平面面积的归一化吸收到系数中，可以得到广泛接受的干燥无限边坡安全系数公式：\n$$\n\\text{FS} = \\frac{\\text{抗滑力}}{\\text{下滑力}} = \\frac{c}{\\gamma z \\sin\\theta \\cos\\theta} + \\frac{\\tan\\varphi}{\\tan\\theta}.\n$$\n该表达式直接源于沿坡面和垂直于坡面方向的力平衡，其中剪切抗力由作用于单位宽度上的黏聚力 $c$ 和摩擦阻力 $\\sigma_n \\tan\\varphi$ 组成，而 $\\sigma_n$ 与重量的法向分量成正比。\n\n将极限状态函数定义为\n$$\ng(c,\\tan\\varphi) = \\text{FS} - 1 = \\frac{c}{\\gamma z \\sin\\theta \\cos\\theta} + \\frac{\\tan\\varphi}{\\tan\\theta} - 1.\n$$\n在这里，对于每个案例，$\\gamma$、$z$ 和 $\\theta$ 是确定性常数，而 $c$ 和 $\\tan\\varphi$ 是随机的。注意，对于固定的 $\\gamma$、$z$ 和 $\\theta$，$g$ 是 $(c,\\tan\\varphi)$ 的仿射函数。\n\n设随机向量为 $\\mathbf{X} = [c, \\ t]^\\top$，其中 $t = \\tan\\varphi$。假设 $\\mathbf{X}$ 服从联合正态分布，其均值为 $\\boldsymbol{\\mu} = [\\mu_c,\\ \\mu_t]^\\top$，标准差为 $\\boldsymbol{\\sigma} = [\\sigma_c,\\ \\sigma_t]^\\top$，相关系数为 $\\rho_{c,t}$。因为 $g(\\mathbf{X})$ 是 $\\mathbf{X}$ 的仿射函数，所以 $g$ 也服从正态分布，其均值为\n$$\n\\mu_g = a_c \\mu_c + a_t \\mu_t + b,\n$$\n方差为\n$$\n\\sigma_g^2 = a_c^2 \\sigma_c^2 + a_t^2 \\sigma_t^2 + 2 \\rho_{c,t} a_c a_t \\sigma_c \\sigma_t,\n$$\n其中\n$$\na_c = \\frac{1}{\\gamma z \\sin\\theta \\cos\\theta}, \\quad a_t = \\frac{1}{\\tan\\theta}, \\quad b = -1.\n$$\n对于正态分布的极限状态函数，一阶可靠度方法 (FORM) 的可靠度指标（Hasofer–Lind 指标）恰好是\n$$\n\\beta = \\frac{\\mu_g}{\\sigma_g}.\n$$\n这是因为在标准正态空间中，极限状态是一个距原点有符号距离为 $\\beta$ 的超平面，并且对于联合正态变量，从 $\\mathbf{X}$ 到该空间的变换是线性的。\n\n可靠度指标对相关系数的敏感性可以通过对 $\\beta$ 关于 $\\rho_{c,t}$ 求导得出。由于\n$$\n\\sigma_g^2 = A + 2 \\rho_{c,t} B, \\quad\\text{其中}\\quad A = a_c^2 \\sigma_c^2 + a_t^2 \\sigma_t^2,\\ \\ B = a_c a_t \\sigma_c \\sigma_t,\n$$\n我们有\n$$\n\\beta(\\rho_{c,t}) = \\frac{\\mu_g}{\\sqrt{A + 2 \\rho_{c,t} B}},\n$$\n因此\n$$\n\\frac{\\partial \\beta}{\\partial \\rho_{c,t}} = - \\mu_g \\, \\frac{B}{\\left(A + 2 \\rho_{c,t} B\\right)^{3/2}}.\n$$\n鉴于通常 $a_c > 0$、$a_t > 0$、$\\sigma_c > 0$、$\\sigma_t > 0$，我们有 $B > 0$。因此，当 $\\mu_g > 0$（平均安全状态）时，$\\partial \\beta / \\partial \\rho_{c,t}  0$，所以正相关会降低可靠度，而负相关会提高可靠度。力学上的解释是，在正相关的情况下，对总抗力有正贡献的黏聚力和摩擦度量会同向波动；这两个参数同时出现低值的可能性在最可能破坏方向上变得更大，这增加了 $g$ 的离散度，从而降低了 $\\beta$。在负相关的情况下，较低的黏聚力往往被较高的摩擦度量所抵消（反之亦然），这减少了 $g$ 的离散程度，从而提高了 $\\beta$。\n\n关于二阶可靠度方法 (SORM)：对于仿射极限状态函数，极限状态面在设计点的主曲率为零，二阶修正项消失。因此，在这种情况下，SORM 精确地简化为 FORM。\n\n算法实现步骤：\n1. 对每个测试用例，将 $\\theta$ 从度转换为弧度。\n2. 计算 $a_c = 1/(\\gamma z \\sin\\theta \\cos\\theta)$、$a_t = 1/\\tan\\theta$ 和 $b=-1$。\n3. 计算 $\\mu_g = a_c \\mu_c + a_t \\mu_t + b$。\n4. 计算 $\\sigma_g = \\sqrt{a_c^2 \\sigma_c^2 + a_t^2 \\sigma_t^2 + 2 \\rho_{c,t} a_c a_t \\sigma_c \\sigma_t}$。\n5. 计算 $\\beta = \\mu_g / \\sigma_g$。\n6. 将所有测试用例的可靠度指标汇总到一个列表中，并按照要求的格式作为唯一的输出行打印。\n\n指定的测试套件包括：\n- 三个“正常路径”案例，具有相同的均值和标准差，但 $\\rho_{c,t}$ 在负、零和正值之间变化，以揭示 $\\beta(\\rho)$ 的单调趋势。\n- 一个接近临界状态的案例，其 $\\mu_c$ 较小且具有强正相关性，以显示当平均安全裕度较小时的敏感性。\n- 两个边界覆盖案例，其 $\\rho_{c,t}$ 接近 $\\pm 0.95$，以测试在相关性极限附近的数值稳定性。\n\n所有输出都是无量纲的浮点数，对应于给定案例的 FORM 可靠度指标。", "answer": "```python\nimport numpy as np\n\ndef beta_form_affine(mu_c, sig_c, mu_tanphi, sig_tanphi, gamma, z, theta_deg, rho_ct):\n    # Convert degrees to radians for trigonometric operations\n    theta = np.deg2rad(theta_deg)\n    # Coefficients for the affine limit-state function g = a_c * c + a_t * tan(phi) + b\n    # For dry infinite (long) slope with a plane parallel to surface:\n    # FS = c/(gamma * z * sin(theta) * cos(theta)) + tan(phi)/tan(theta)\n    # g = FS - 1\n    sin_t = np.sin(theta)\n    cos_t = np.cos(theta)\n    tan_t = np.tan(theta)\n    # Guard against pathological angle values\n    if abs(tan_t)  1e-12 or abs(sin_t * cos_t)  1e-12:\n        return np.nan\n    a_c = 1.0 / (gamma * z * sin_t * cos_t)\n    a_t = 1.0 / tan_t\n    b = -1.0\n\n    mu_g = a_c * mu_c + a_t * mu_tanphi + b\n    # Variance of g with correlation only between c and tanphi\n    A = (a_c ** 2) * (sig_c ** 2) + (a_t ** 2) * (sig_tanphi ** 2)\n    B = a_c * a_t * sig_c * sig_tanphi\n    var_g = A + 2.0 * rho_ct * B\n    # Numerical guard for small negative due to rounding\n    if var_g  0 and var_g > -1e-14:\n        var_g = 0.0\n    if var_g = 0.0:\n        # Degenerate variance, return inf or nan depending on mean\n        return np.inf if mu_g > 0 else (-np.inf if mu_g  0 else np.nan)\n    sig_g = np.sqrt(var_g)\n    beta = mu_g / sig_g\n    return beta\n\ndef solve():\n    # Define the test cases as specified in the problem statement.\n    # Each tuple: (mu_c, sig_c, mu_tanphi, sig_tanphi, gamma, z, theta_deg, rho_ct)\n    deg = np.pi / 180.0\n    mu_tan_28 = np.tan(28.0 * deg)\n    test_cases = [\n        (10.0, 3.0, mu_tan_28, 0.08, 18.0, 5.0, 30.0, -0.8),   # Case 1\n        (10.0, 3.0, mu_tan_28, 0.08, 18.0, 5.0, 30.0,  0.0),   # Case 2\n        (10.0, 3.0, mu_tan_28, 0.08, 18.0, 5.0, 30.0,  0.8),   # Case 3\n        ( 5.0, 3.0, mu_tan_28, 0.08, 18.0, 5.0, 30.0,  0.9),   # Case 4 (near-critical mean)\n        (10.0, 3.0, mu_tan_28, 0.08, 18.0, 5.0, 30.0,  0.95),  # Case 5 (high positive corr)\n        (10.0, 3.0, mu_tan_28, 0.08, 18.0, 5.0, 30.0, -0.95),  # Case 6 (high negative corr)\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_c, sig_c, mu_t, sig_t, gamma, z, theta_deg, rho_ct = case\n        beta = beta_form_affine(mu_c, sig_c, mu_t, sig_t, gamma, z, theta_deg, rho_ct)\n        # Convert numpy types to native Python floats for clean printing\n        results.append(float(beta))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3556073"}, {"introduction": "在实际工程中，极限状态函数通常是高度非线性的，例如来自有限元分析的结果。本实践将引导您探索标准 Hasofer-Lind-Rackwitz-Fiessler (HL-RF) 算法在处理此类问题时可能遇到的收敛性挑战。通过亲手实现并对比 HL-RF 与带有线搜索策略的改进算法 (iHLRF)，您将深刻理解提升算法鲁棒性的重要性及其对可靠度指标计算的影响 [@problem_id:3556024]。", "problem": "考虑一个在标准正态空间中进行的概率性边坡稳定性评估。设极限状态函数 $g(\\mathbf{u})$ 是对一个均質边坡进行弹塑性有限元 (FE) 抗剪强度折减分析的光滑代理模型，它在 $\\mathbb{R}^3$ 上定义为：\n$$\ng(\\mathbf{u}) \\;=\\; a_1 \\,\\tanh\\!\\left( s(\\mathbf{u}) \\right) \\;+\\; a_2 \\,\\exp\\!\\left(d\\,u_3\\right) \\;+\\; a_3 \\,\\sin\\!\\left(f\\,u_2\\right) \\;+\\; a_4 \\,u_1\\,u_2\\,u_3 \\;-\\; g_0,\n$$\n其中\n$$\ns(\\mathbf{u}) \\;=\\; b_1\\,u_1 \\;+\\; b_2\\,u_2^3 \\;+\\; b_3\\,u_1\\,u_3.\n$$\n所有三角函数参数均以弧度为单位。变量 $u_1$、$u_2$ 和 $u_3$ 是标准正态变量，代表了与岩土力学系统的一阶可靠度方法 (FORM) 建模一致的、经过转换的材料强度参数和应力状态指标。失效域为 $\\{\\,\\mathbf{u}\\in\\mathbb{R}^3: g(\\mathbf{u}) \\le 0\\,\\}$，安全域为 $\\{\\,\\mathbf{u}\\in\\mathbb{R}^3: g(\\mathbf{u})  0\\,\\}$。\n\n从 Hasofer-Lind 可靠度指标的基本定义出发，FORM 中的可靠度指标 $\\beta$ 是标准正态空间中从原点到极限状态面 $g(\\mathbf{u})=0$ 的最小欧几里得距离，\n$$\n\\beta \\;=\\; \\min_{\\mathbf{u}\\in\\mathbb{R}^3} \\left\\{\\, \\|\\mathbf{u}\\|_2 \\;:\\; g(\\mathbf{u})=0 \\,\\right\\}.\n$$\n实现两种迭代算法来找到满足 $g(\\mathbf{u}^\\star)=0$ 并最小化 $\\|\\mathbf{u}\\|_2$ 的设计点 $\\mathbf{u}^\\star$，然后计算 $\\beta=\\|\\mathbf{u}^\\star\\|_2$：\n- Hasofer-Lind and Rackwitz-Fiessler 方法 (HL-RF)，该方法基于 $g$ 的线性化和标准正态空间的几何特性进行更新。\n- 改进的 Hasofer-Lind and Rackwitz-Fiessler 方法 (iHLRF)，该方法通过引入由评价函数的下降准則引导的回溯线搜索来增强 HL-RF，以提高在强非线性 $g$ 上的收敛性。\n\n您的实现必须解析地计算梯度 $\\nabla g(\\mathbf{u})$ 并在两种算法中使用它。使用固定的初始猜测值 $\\mathbf{u}_0=\\mathbf{0}$，最多 $200$ 次迭代，极限状态残差 $|g(\\mathbf{u})|$ 的标量容差 $\\varepsilon_g=10^{-8}$，以及步长 $\\|\\mathbf{u}_{k+1}-\\mathbf{u}_k\\|_2$ 的容差 $\\varepsilon_u=10^{-8}$。对于 iHLRF 线搜索，对评价函数 $\\phi(\\mathbf{u})=\\tfrac{1}{2}g(\\mathbf{u})^2$ 使用 Armijo 回溯条件，其中 Armijo 参数 $c=10^{-4}$，收缩因子 $\\rho=0.5$。如果 $|g(\\mathbf{u})|\\le \\varepsilon_g$ 和 $\\|\\mathbf{u}_{k+1}-\\mathbf{u}_k\\|_2\\le \\varepsilon_u$ 同时满足，则宣告收敛；否则，在 200 次迭代后宣告不收斂。\n\n设计您的程序以评估以下参数集 $\\left(a_1,b_1,b_2,b_3,a_2,d,a_3,f,a_4,g_0\\right)$ 的测试套件，这些参数集被选择用于检验弹塑性有限元边坡稳定性代理模型典型的非线性特性：\n- 测试用例 1 (中等非线性，预计为“理想路径”)：$\\left( a_1, b_1, b_2, b_3, a_2, d, a_3, f, a_4, g_0 \\right) = \\left( 1.6, 0.9, 0.35, 0.6, 0.4, 0.8, 0.25, 1.2, 0.1, 1.0 \\right)$。\n- 测试用例 2 (强非线性，具有更强的三次和振荡耦合)：$\\left( a_1, b_1, b_2, b_3, a_2, d, a_3, f, a_4, g_0 \\right) = \\left( 2.0, 1.1, 0.8, 0.9, 0.6, 1.0, 0.5, 2.5, 0.2, 1.2 \\right)$。\n- 测试用例 3 (原点附近的平坦曲率，一个边界条件的边缘情况)：$\\left( a_1, b_1, b_2, b_3, a_2, d, a_3, f, a_4, g_0 \\right) = \\left( 0.8, 0.1, 0.05, 0.0, 1.0, 0.05, 0.05, 0.6, 0.02, 1.0 \\right)$。\n\n对于每个测试用例，计算并报告：\n- 来自 HL-RF 的可靠度指标, $\\beta_{\\text{HLRF}}$。\n- HL-RF 的迭代次数, $N_{\\text{HLRF}}$。\n- HL-RF 的收敛标志, $\\text{conv}_{\\text{HLRF}}$ (使用布尔值 $\\text{True}$ 或 $\\text{False}$)。\n- 来自 iHLRF 的可靠度指标, $\\beta_{\\text{iHLRF}}$。\n- iHLRF 的迭代次数, $N_{\\text{iHLRF}}$。\n- iHLRF 的收敛标志, $\\text{conv}_{\\text{iHLRF}}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按测试用例和方法排序，包含测试用例 1 的六个值，后跟测试用例 2 的六个值，再后跟测试用例 3 的六个值。因此，最终输出必须有 18 个条目，顺序如下：\n$$\n\\left[ \\beta_{\\text{HLRF},1},\\, N_{\\text{HLRF},1},\\, \\text{conv}_{\\text{HLRF},1},\\, \\beta_{\\text{iHLRF},1},\\, N_{\\text{iHLRF},1},\\, \\text{conv}_{\\text{iHLRF},1},\\, \\beta_{\\text{HLRF},2},\\, N_{\\text{HLRF},2},\\, \\text{conv}_{\\text{HLRF},2},\\, \\beta_{\\text{iHLRF},2},\\, N_{\\text{iHLRF},2},\\, \\text{conv}_{\\text{iHLRF},2},\\, \\beta_{\\text{HLRF},3},\\, N_{\\text{HLRF},3},\\, \\text{conv}_{\\text{HLRF},3},\\, \\beta_{\\text{iHLRF},3},\\, N_{\\text{iHLRF},3},\\, \\text{conv}_{\\text{iHLRF},3} \\right].\n$$\n所有报告的可靠度指标都是无量纲数；请将它们报告为浮点值。将迭代次数报告为整数，收敛标志报告为布尔值。", "solution": "所提出的问题是结构可靠度分析中的一个基本约束优化任务，具体使用了 First-Order Reliability Method (FORM)。目标是确定在随机变量 $\\mathbf{u} \\in \\mathbb{R}^3$ 的标准正态空间中，从原点到失效面 $g(\\mathbf{u})=0$ 的最短欧几里得距离。这个最小距离就是 Hasofer-Lind 可靠度指标 $\\beta$。位于此最小距离处的失效面上的点被称为设计点 $\\mathbf{u}^\\star$。\n\n该问题在数学上表述为：\n$$\n\\beta \\;=\\; \\min_{\\mathbf{u}\\in\\mathbb{R}^3} \\left\\{\\, \\|\\mathbf{u}\\|_2 \\right\\} \\quad \\text{subject to} \\quad g(\\mathbf{u})=0\n$$\n其中 $\\|\\mathbf{u}\\|_2 = \\sqrt{u_1^2 + u_2^2 + u_3^2}$。极限状态函数 $g(\\mathbf{u})$ 由下式给出：\n$$\ng(\\mathbf{u}) \\;=\\; a_1 \\,\\tanh\\!\\left( s(\\mathbf{u}) \\right) \\;+\\; a_2 \\,\\exp\\!\\left(d\\,u_3\\right) \\;+\\; a_3 \\,\\sin\\!\\left(f\\,u_2\\right) \\;+\\; a_4 \\,u_1\\,u_2\\,u_3 \\;-\\; g_0\n$$\n其辅助函数 $s(\\mathbf{u})$ 为：\n$$\ns(\\mathbf{u}) \\;=\\; b_1\\,u_1 \\;+\\; b_2\\,u_2^3 \\;+\\; b_3\\,u_1\\,u_3\n$$\n该问题使用两种迭代数值算法求解：Hasofer-Lind and Rackwitz-Fiessler (HL-RF) 方法和一个带有线搜索的改进版本 (iHLRF)。两种方法都需要极限状态函数的梯度 $\\nabla g(\\mathbf{u})$。\n\n首先，我们推导 $g(\\mathbf{u})$ 的解析梯度。 $s(\\mathbf{u})$ 的偏导数是：\n$$\n\\frac{\\partial s}{\\partial u_1} = b_1 + b_3 u_3 \\qquad\n\\frac{\\partial s}{\\partial u_2} = 3 b_2 u_2^2 \\qquad\n\\frac{\\partial s}{\\partial u_3} = b_3 u_1\n$$\n使用链式法则和导数 $\\frac{d}{dx}\\tanh(x) = \\text{sech}^2(x) = 1 - \\tanh^2(x)$，梯度 $\\nabla g(\\mathbf{u}) = \\left[ \\frac{\\partial g}{\\partial u_1}, \\frac{\\partial g}{\\partial u_2}, \\frac{\\partial g}{\\partial u_3} \\right]^T$ 的分量是：\n$$\n\\frac{\\partial g}{\\partial u_1} = a_1 \\,\\text{sech}^2(s(\\mathbf{u})) \\frac{\\partial s}{\\partial u_1} + a_4 u_2 u_3 = a_1 \\,\\text{sech}^2(s(\\mathbf{u}))(b_1 + b_3 u_3) + a_4 u_2 u_3\n$$\n$$\n\\frac{\\partial g}{\\partial u_2} = a_1 \\,\\text{sech}^2(s(\\mathbf{u})) \\frac{\\partial s}{\\partial u_2} + a_3 f \\cos(f u_2) + a_4 u_1 u_3 = a_1 \\,\\text{sech}^2(s(\\mathbf{u}))(3 b_2 u_2^2) + a_3 f \\cos(f u_2) + a_4 u_1 u_3\n$$\n$$\n\\frac{\\partial g}{\\partial u_3} = a_1 \\,\\text{sech}^2(s(\\mathbf{u})) \\frac{\\partial s}{\\partial u_3} + a_2 d \\exp(d u_3) + a_4 u_1 u_2 = a_1 \\,\\text{sech}^2(s(\\mathbf{u}))(b_3 u_1) + a_2 d \\exp(d u_3) + a_4 u_1 u_2\n$$\n\n约束优化问题的解 $\\mathbf{u}^\\star$ 满足 Karush-Kuhn-Tucker (KKT) 条件。一个关键条件是，在解处，目标函数 $\\nabla (\\|\\mathbf{u}\\|_2)$ 的梯度必须与约束函数 $\\nabla g(\\mathbf{u})$ 的梯度平行。这意味着向量 $\\mathbf{u}^\\star$ 在 $\\mathbf{u}^\\star$ 点处与极限状态面 $g(\\mathbf{u})=0$ 垂直，即 $\\mathbf{u}^\\star = -\\lambda \\nabla g(\\mathbf{u}^\\star)$，其中 $\\lambda > 0$ 是某个标量。迭代算法利用了这一几何特性。\n\n**Hasofer-Lind and Rackwitz-Fiessler (HL-RF) 算法**\nHL-RF 算法是一个迭代过程，它从一个初始点 $\\mathbf{u}_0$ 开始，生成一个收敛于设计点 $\\mathbf{u}^\\star$ 的点序列 $\\mathbf{u}_1, \\mathbf{u}_2, \\dots$。在每次迭代 $k$ 中，该算法在当前点 $\\mathbf{u}_k$ 处将极限状态面线性化。然后，下一个迭代点 $\\mathbf{u}_{k+1}$ 被计算为这个线性化曲面（一个超平面）上距离原点最近的点。这导出了以下更新公式：\n$$\n\\mathbf{u}_{k+1} = \\frac{\\nabla g(\\mathbf{u}_k)^T \\mathbf{u}_k - g(\\mathbf{u}_k)}{\\|\\nabla g(\\mathbf{u}_k)\\|_2^2} \\nabla g(\\mathbf{u}_k)\n$$\n迭代从 $\\mathbf{u}_0 = \\mathbf{0}$ 开始，并一直进行直到达到收敛，收敛的定义是同时满足两个条件：极限状态函数的残差足够小，$|g(\\mathbf{u}_{k+1})| \\le \\varepsilon_g$，并且迭代点的变化足够小，$\\|\\mathbf{u}_{k+1} - \\mathbf{u}_k\\|_2 \\le \\varepsilon_u$。收敛到 $\\mathbf{u}^\\star$ 后，可靠度指标为 $\\beta = \\|\\mathbf{u}^\\star\\|_2$。\n\n**改进的 Hasofer-Lind and Rackwitz-Fiessler (iHLRF) 算法**\n对于强非线性极限状态函数，标准的 HL-RF 算法可能会表现出较差的收敛性，例如振荡或发散。iHLRF 方法通过引入回溯线搜索来控制步长，从而提高了鲁棒性。\niHLRF 方法首先使用标准的 HL-RF 更新计算一个目标点 $\\mathbf{u}_{k+1}^{\\text{target}}$。这定义了一个搜索方向 $\\mathbf{d}_k = \\mathbf{u}_{k+1}^{\\text{target}} - \\mathbf{u}_k$。然后通过 $\\mathbf{u}_{k+1} = \\mathbf{u}_k + \\eta \\mathbf{d}_k$ 找到下一个迭代点，其中 $\\eta \\in (0, 1]$ 是由线搜索确定的步长参数。\n线搜索旨在确保评价函数有充分的下降。根据规定，评价函数为 $\\phi(\\mathbf{u}) = \\frac{1}{2}g(\\mathbf{u})^2$，它惩罚偏離极限状态面的距离。Armijo 的充分下降条件是：\n$$\n\\phi(\\mathbf{u}_k + \\eta \\mathbf{d}_k) \\le \\phi(\\mathbf{u}_k) + c \\eta \\nabla \\phi(\\mathbf{u}_k)^T \\mathbf{d}_k\n$$\n其中 $c$ 是 Armijo 参数 ($10^{-4}$)，且 $\\nabla\\phi(\\mathbf{u}_k) = g(\\mathbf{u}_k)\\nabla g(\\mathbf{u}_k)$。方向导数项简化为 $\\nabla \\phi(\\mathbf{u}_k)^T \\mathbf{d}_k = -g(\\mathbf{u}_k)^2$。线搜索从 $\\eta=1$ 开始，并用收缩因子 $\\rho$ ($0.5$) 逐次减小它，直到满足 Armijo 条件。这种稳定化的步长确保了向解的更可靠的推进，特别是当迭代点远离设计点或处于高曲率区域时。\n\n所提供的测试用例将使用两种算法的 Python 实现进行评估，从 $\\mathbf{u}_0 = \\mathbf{0}$ 开始，并使用指定的容差和迭代限制。结果将展示这两种方法在具有不同非线性程度问题上的比较性能和鲁棒性。对于初始猜测值 $\\mathbf{u}_0 = \\mathbf{0}$ 恰好位于极限状态面（$g(\\mathbf{0})=0$）上的特殊情况，如测试用例 3，算法能正确处理，并立即收敛于 $\\beta=0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the reliability analysis problem for all test cases.\n    \"\"\"\n\n    class ReliabilityProblem:\n        \"\"\"\n        A class to encapsulate the limit-state function and its gradient.\n        \"\"\"\n        def __init__(self, params):\n            # Unpack parameters for the specific problem instance.\n            self.a1, self.b1, self.b2, self.b3, self.a2, self.d, \\\n            self.a3, self.f, self.a4, self.g0 = params\n\n        def s_func(self, u):\n            \"\"\"Computes the auxiliary function s(u).\"\"\"\n            u1, u2, u3 = u\n            return self.b1 * u1 + self.b2 * u2**3 + self.b3 * u1 * u3\n\n        def g_func(self, u):\n            \"\"\"Computes the limit-state function g(u).\"\"\"\n            u1, u2, u3 = u\n            s_val = self.s_func(u)\n            term1 = self.a1 * np.tanh(s_val)\n            term2 = self.a2 * np.exp(self.d * u3)\n            term3 = self.a3 * np.sin(self.f * u2)\n            term4 = self.a4 * u1 * u2 * u3\n            return term1 + term2 + term3 + term4 - self.g0\n\n        def grad_g_func(self, u):\n            \"\"\"Computes the gradient of the limit-state function g(u).\"\"\"\n            u1, u2, u3 = u\n            s_val = self.s_func(u)\n            sech2_s = 1.0 / (np.cosh(s_val)**2)\n\n            # Partial derivatives of s(u)\n            ds_du1 = self.b1 + self.b3 * u3\n            ds_du2 = 3 * self.b2 * u2**2\n            ds_du3 = self.b3 * u1\n\n            # Partial derivatives of g(u)\n            dg_du1 = self.a1 * sech2_s * ds_du1 + self.a4 * u2 * u3\n            dg_du2 = self.a1 * sech2_s * ds_du2 + self.a3 * self.f * np.cos(self.f * u2) + self.a4 * u1 * u3\n            dg_du3 = self.a1 * sech2_s * ds_du3 + self.a2 * self.d * np.exp(self.d * u3) + self.a4 * u1 * u2\n            \n            return np.array([dg_du1, dg_du2, dg_du3])\n\n    def hlrf_solver(problem, u0, max_iter, tol_g, tol_u):\n        \"\"\"\n        Solves for the reliability index using the HL-RF algorithm.\n        \"\"\"\n        u_k = np.copy(u0)\n        \n        for k in range(max_iter):\n            g_k = problem.g_func(u_k)\n            grad_g_k = problem.grad_g_func(u_k)\n            \n            norm_grad_g_sq = np.dot(grad_g_k, grad_g_k)\n            if norm_grad_g_sq  1e-16: # Avoid division by zero\n                return 0.0, k, False\n\n            # HL-RF update formula\n            factor = (np.dot(grad_g_k, u_k) - g_k) / norm_grad_g_sq\n            u_k_plus_1 = factor * grad_g_k\n            \n            step_norm = np.linalg.norm(u_k_plus_1 - u_k)\n            g_k_plus_1 = problem.g_func(u_k_plus_1)\n            \n            u_k = u_k_plus_1\n            \n            if abs(g_k_plus_1) = tol_g and step_norm = tol_u:\n                beta = np.linalg.norm(u_k)\n                return beta, k + 1, True\n        \n        beta = np.linalg.norm(u_k)\n        return beta, max_iter, False\n\n    def ihlrf_solver(problem, u0, max_iter, tol_g, tol_u, armijo_c, rho):\n        \"\"\"\n        Solves for the reliability index using the improved HL-RF algorithm with Armijo line search.\n        \"\"\"\n        u_k = np.copy(u0)\n        \n        for k in range(max_iter):\n            g_k = problem.g_func(u_k)\n            grad_g_k = problem.grad_g_func(u_k)\n\n            norm_grad_g_sq = np.dot(grad_g_k, grad_g_k)\n            if norm_grad_g_sq  1e-16:\n                return 0.0, k, False\n            \n            # HL-RF target point\n            factor = (np.dot(grad_g_k, u_k) - g_k) / norm_grad_g_sq\n            u_target = factor * grad_g_k\n            \n            # Search direction\n            d_k = u_target - u_k\n            \n            # Armijo backtracking line search\n            eta = 1.0\n            phi_k = 0.5 * g_k**2\n            # Directional derivative term: grad_phi_k.T @ d_k = -g_k**2\n            descent_term = -armijo_c * (g_k**2)\n            \n            while True:\n                u_next_try = u_k + eta * d_k\n                g_next_try = problem.g_func(u_next_try)\n                phi_next = 0.5 * g_next_try**2\n                \n                # Armijo condition\n                if phi_next = phi_k + eta * descent_term or eta  1e-8:\n                    u_k_plus_1 = u_next_try\n                    break\n                eta *= rho\n            \n            step_norm = np.linalg.norm(u_k_plus_1 - u_k)\n            g_k_plus_1 = problem.g_func(u_k_plus_1)\n\n            u_k = u_k_plus_1\n\n            if abs(g_k_plus_1) = tol_g and step_norm = tol_u:\n                beta = np.linalg.norm(u_k)\n                return beta, k + 1, True\n\n        beta = np.linalg.norm(u_k)\n        return beta, max_iter, False\n\n    # Problem parameters\n    test_cases = [\n        (1.6, 0.9, 0.35, 0.6, 0.4, 0.8, 0.25, 1.2, 0.1, 1.0),\n        (2.0, 1.1, 0.8, 0.9, 0.6, 1.0, 0.5, 2.5, 0.2, 1.2),\n        (0.8, 0.1, 0.05, 0.0, 1.0, 0.05, 0.05, 0.6, 0.02, 1.0)\n    ]\n    \n    # Algorithmic settings\n    u_initial = np.array([0.0, 0.0, 0.0])\n    max_iterations = 200\n    g_tolerance = 1e-8\n    u_tolerance = 1e-8\n    armijo_c_param = 1e-4\n    rho_contraction = 0.5\n\n    results = []\n    for params in test_cases:\n        problem = ReliabilityProblem(params)\n        \n        # Run HL-RF\n        beta_hlrf, n_hlrf, conv_hlrf = hlrf_solver(problem, u_initial, max_iterations, g_tolerance, u_tolerance)\n        results.extend([beta_hlrf, n_hlrf, conv_hlrf])\n        \n        # Run iHLRF\n        beta_ihlf, n_ihlf, conv_ihlf = ihlrf_solver(problem, u_initial, max_iterations, g_tolerance, u_tolerance, armijo_c_param, rho_contraction)\n        results.extend([beta_ihlf, n_ihlf, conv_ihlf])\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3556024"}]}