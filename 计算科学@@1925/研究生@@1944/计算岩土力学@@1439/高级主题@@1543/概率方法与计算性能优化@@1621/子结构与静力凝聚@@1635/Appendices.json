{"hands_on_practices": [{"introduction": "要真正掌握静态凝聚的精髓，最好的方法莫过于亲手推导一个简单的例子。本练习将引导你使用一个基本的一维杆单元系统，从第一性原理出发，推导出凝聚后的刚度与力项。通过这个过程，你不仅能巩固其背后的代数运算，还能深刻理解其物理意义，特别是它如何反映子结构的整体平衡条件。[@problem_id:3565840]", "problem": "一根直的、等截面的一维杆被离散为两个线性二节点有限元，它们在一个界面节点处相连。设全局节点从左到右标记为 $\\{1,2,3\\}$，其中单元 $1$ 连接节点 $\\{1,2\\}$，单元 $2$ 连接节点 $\\{2,3\\}$。两个单元的轴向刚度分别为 $k_1$ 和 $k_2$，其物理单位均为 $\\text{N}/\\text{m}$。记节点轴向位移为 $u_1$、$u_2$、$u_3$，外加节点轴向载荷为 $f_1$、$f_2$、$f_3$（在轴向正方向上为正）。\n\n假设为小应变、线性弹性和准静态条件。作为基本依据，使用 (i) 节点处的力平衡，(ii) 每个单元的线性弹性轴向力-位移关系，以及 (iii) 局部坐标系中标准的二节点杆单元刚度表示。\n\n任务：\n1. 从已知的二节点杆单元刚度 $\\mathbf{k}_e = k_e \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$（其中对于单元 $1$ 和 $2$， $k_e$ 分别为 $k_1, k_2$）出发，按照全局自由度顺序 $\\{u_1,u_2,u_3\\}$ 组装系统的全局刚度矩阵 $\\mathbf{K}$。用 $k_1$ 和 $k_2$ 显式地写出组装后的 $\\mathbf{K}$。\n\n2. 对全局系统 $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$ 进行分区，选择界面位移 $u_2$ 作为唯一的“凝聚”自由度，两个边界位移 $\\{u_1,u_3\\}$ 作为“消去”自由度。即，写作 $\\mathbf{u} = \\begin{pmatrix} \\mathbf{u}_b \\\\ \\mathbf{u}_c \\end{pmatrix}$，其中 $\\mathbf{u}_b = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$ 且 $\\mathbf{u}_c = \\begin{pmatrix} u_2 \\end{pmatrix}$，并用 $k_1$ 和 $k_2$ 显式地写出矩阵块 $\\mathbf{K}_{bb}$、$\\mathbf{K}_{bc}$、$\\mathbf{K}_{cb}$ 和 $\\mathbf{K}_{cc}$。\n\n3. 使用基于舒尔补（Schur complement）的静态凝聚法，消去 $\\mathbf{u}_b$ 以获得形式为\n$$\nS\\,u_2 \\;=\\; g,\n$$\n的单个标量界面平衡方程，其中 $S$ 是凝聚标量刚度，$g$ 是凝聚标量载荷。用 $k_1$、$k_2$ 以及节点载荷 $f_1$、$f_2$、$f_3$ 显式地推导出 $S$ 和 $g$。验证分区后的刚度是对称的，并且 $S$ 和 $g$ 的物理单位分别与刚度和力一致。\n\n$g$ 的最终答案以牛顿（Newtons）为单位表示。不要进行数值计算；请提供精确的代数表达式。最终答案仅报告 $g$。", "solution": "首先验证问题，以确保其在科学上是合理的、内容自洽且适定的。\n\n### 步骤 1：提取已知条件\n- **系统**：一根直的、等截面的一维杆。\n- **离散化**：两个线性二节点有限元，在一个界面节点处相连。\n- **节点**：全局节点标记为 {$1$, $2$, $3$}。单元 $1$ 连接节点 {$1, 2$}；单元 $2$ 连接节点 {$2, 3$}。\n- **刚度**：单元 $1$ 的轴向刚度为 $k_1$。单元 $2$ 的轴向刚度为 $k_2$。单位为 $\\text{N}/\\text{m}$。\n- **自由度 (DOFs)**：节点轴向位移为 $u_1, u_2, u_3$。\n- **载荷**：外部节点轴向载荷为 $f_1, f_2, f_3$。\n- **假设**：小应变、线性弹性、准静态条件。\n- **控制原理**：(i) 力平衡，(ii) 线性弹性力-位移关系，(iii) 标准二节点杆单元刚度矩阵。\n- **单元刚度矩阵**：对于 $k_e \\in \\{k_1, k_2\\}$，$\\mathbf{k}_e = k_e \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$。\n- **任务 1**：按自由度顺序 $\\{u_1, u_2, u_3\\}$ 组装全局刚度矩阵 $\\mathbf{K}$。\n- **任务 2**：使用 $\\mathbf{u}_c = u_2$（“凝聚”）和 $\\mathbf{u}_b = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$（“消去”）对系统 $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$ 进行分区。确定矩阵块 $\\mathbf{K}_{bb}$、$\\mathbf{K}_{bc}$、$\\mathbf{K}_{cb}$、$\\mathbf{K}_{cc}$。\n- **任务 3**：使用静态凝聚法消去 $\\mathbf{u}_b$，并推导出凝聚系统 $S u_2 = g$。推导标量刚度 $S$ 和标量载荷 $g$ 的表达式。\n- **最终答案**：报告 $g$ 的精确代数表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n这个问题是有限元法（FEM）应用于结构力学的一个标准练习。所有概念，包括单元刚度矩阵、全局组装和静态凝聚（通过舒尔补），都是计算力学中基本且公认的原理。问题的陈述语言清晰、客观，并为得到唯一解提供了所有必要的信息。分区方案虽然不是凝聚法最常见的应用，但在数学上是明确定义的。所需矩阵逆（$\\mathbf{K}_{bb}^{-1}$）存在的条件是满足的，因为单元刚度 $k_1, k_2$ 在物理上要求为正。这个问题具有科学依据、是适定的且客观的。\n\n### 步骤 3：结论与操作\n问题有效。将提供完整的解答。\n\n### 解题推导\n\n**1. 全局刚度矩阵 $\\mathbf{K}$ 的组装**\n\n系统由两个单元组成。单元刚度矩阵是根据其各自的局部节点顺序给出的。\n对于单元 $1$（节点 $1, 2$），刚度矩阵为：\n$$ \\mathbf{k}^{(1)} = k_1 \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\n对于单元 $2$（节点 $2, 3$），刚度矩阵为：\n$$ \\mathbf{k}^{(2)} = k_2 \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\n全局刚度矩阵 $\\mathbf{K}$ 是通过直接刚度法针对全局自由度 $\\{u_1, u_2, u_3\\}$ 组装的。单元矩阵的各项被加到全局矩阵的相应位置。\n\n$K_{11}$ 来自 $\\mathbf{k}^{(1)}$ 的 $(1,1)$ 项。\n$K_{22}$ 来自 $\\mathbf{k}^{(1)}$ 的 $(2,2)$ 项和 $\\mathbf{k}^{(2)}$ 的 $(1,1)$ 项。\n$K_{33}$ 来自 $\\mathbf{k}^{(2)}$ 的 $(2,2)$ 项。\n非对角项也类似地组装。\n\n$$\n\\mathbf{K} =\n\\begin{pmatrix}\nk_1  -k_1  0 \\\\\n-k_1  k_1 + k_2  -k_2 \\\\\n0  -k_2  k_2\n\\end{pmatrix}\n$$\n全局方程组为 $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$，其中 $\\mathbf{u} = \\begin{pmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{pmatrix}$ 且 $\\mathbf{f} = \\begin{pmatrix} f_1 \\\\ f_2 \\\\ f_3 \\end{pmatrix}$。\n\n**2. 对全局系统进行分区**\n\n问题指定了一种分区方式，其中“凝聚”（保留）的自由度为 $\\mathbf{u}_c = u_2$，“消去”的自由度为 $\\mathbf{u}_b = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$。为了符合分块矩阵的结构，我们必须对方程组重新排序，使其对应于自由度向量 $\\begin{pmatrix} \\mathbf{u}_c \\\\ \\mathbf{u}_b \\end{pmatrix} = \\begin{pmatrix} u_2 \\\\ u_1 \\\\ u_3 \\end{pmatrix}$。相应的力向量为 $\\begin{pmatrix} \\mathbf{f}_c \\\\ \\mathbf{f}_b \\end{pmatrix} = \\begin{pmatrix} f_2 \\\\ f_1 \\\\ f_3 \\end{pmatrix}$。\n\n重排后的刚度矩阵，记为 $\\mathbf{K}'$，是通过对 $\\mathbf{K}$ 的行和列进行置换以匹配新的自由度顺序 $\\{2, 1, 3\\}$ 得到的。\n$$\n\\mathbf{K}' =\n\\begin{pmatrix}\nK_{22}  K_{21}  K_{23} \\\\\nK_{12}  K_{11}  K_{13} \\\\\nK_{32}  K_{31}  K_{33}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nk_1+k_2  -k_1  -k_2 \\\\\n-k_1  k_1  0 \\\\\n-k_2  0  k_2\n\\end{pmatrix}\n$$\n分区后的系统为 $\\mathbf{K}' \\begin{pmatrix} \\mathbf{u}_c \\\\ \\mathbf{u}_b \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f}_c \\\\ \\mathbf{f}_b \\end{pmatrix}$。我们确定其矩阵块如下：\n$$\n\\mathbf{K}' =\n\\left[\n\\begin{array}{c|cc}\n\\mathbf{K}_{cc}  \\mathbf{K}_{cb} \\\\\n\\hline\n\\mathbf{K}_{bc}  \\mathbf{K}_{bb}\n\\end{array}\n\\right]\n$$\n具体的矩阵块是：\n- $\\mathbf{K}_{cc} = [k_1+k_2]$（一个 $1 \\times 1$ 矩阵）\n- $\\mathbf{K}_{cb} = \\begin{pmatrix} -k_1  -k_2 \\end{pmatrix}$（一个 $1 \\times 2$ 矩阵）\n- $\\mathbf{K}_{bc} = \\begin{pmatrix} -k_1 \\\\ -k_2 \\end{pmatrix}$（一个 $2 \\times 1$ 矩阵）\n- $\\mathbf{K}_{bb} = \\begin{pmatrix} k_1  0 \\\\ 0  k_2 \\end{pmatrix}$（一个 $2 \\times 2$ 矩阵）\n\n分区后的方程组为：\n$$ \\mathbf{K}_{cc} \\mathbf{u}_c + \\mathbf{K}_{cb} \\mathbf{u}_b = \\mathbf{f}_c $$\n$$ \\mathbf{K}_{bc} \\mathbf{u}_c + \\mathbf{K}_{bb} \\mathbf{u}_b = \\mathbf{f}_b $$\n\n**3. 静态凝聚**\n\n按要求消去 $\\mathbf{u}_b$。从第二个方程得到：\n$$ \\mathbf{K}_{bb} \\mathbf{u}_b = \\mathbf{f}_b - \\mathbf{K}_{bc} \\mathbf{u}_c $$\n为了求解 $\\mathbf{u}_b$，我们必须对 $\\mathbf{K}_{bb}$ 求逆。行列式为 $\\det(\\mathbf{K}_{bb}) = k_1 k_2$。由于 $k_1$ 和 $k_2$ 代表物理刚度，它们是严格为正的，所以 $\\det(\\mathbf{K}_{bb}) > 0$ 且逆矩阵存在。\n$$ \\mathbf{K}_{bb}^{-1} = \\frac{1}{k_1 k_2} \\begin{pmatrix} k_2  0 \\\\ 0  k_1 \\end{pmatrix} = \\begin{pmatrix} 1/k_1  0 \\\\ 0  1/k_2 \\end{pmatrix} $$\n因此，\n$$ \\mathbf{u}_b = \\mathbf{K}_{bb}^{-1} (\\mathbf{f}_b - \\mathbf{K}_{bc} \\mathbf{u}_c) $$\n将此代入第一个方程：\n$$ \\mathbf{K}_{cc} \\mathbf{u}_c + \\mathbf{K}_{cb} \\left( \\mathbf{K}_{bb}^{-1} (\\mathbf{f}_b - \\mathbf{K}_{bc} \\mathbf{u}_c) \\right) = \\mathbf{f}_c $$\n重新排列各项以对 $\\mathbf{u}_c$ 进行分组：\n$$ (\\mathbf{K}_{cc} - \\mathbf{K}_{cb} \\mathbf{K}_{bb}^{-1} \\mathbf{K}_{bc}) \\mathbf{u}_c = \\mathbf{f}_c - \\mathbf{K}_{cb} \\mathbf{K}_{bb}^{-1} \\mathbf{f}_b $$\n这就是凝聚系统 $S u_2 = g$，其中 $S$ 是 $\\mathbf{K}_{bb}$ 在 $\\mathbf{K}'$中的舒尔补。\n\n让我们计算 $S$ 和 $g$。\n$$ S = \\mathbf{K}_{cc} - \\mathbf{K}_{cb} \\mathbf{K}_{bb}^{-1} \\mathbf{K}_{bc} $$\n$$ S = (k_1+k_2) - \\begin{pmatrix} -k_1  -k_2 \\end{pmatrix} \\begin{pmatrix} 1/k_1  0 \\\\ 0  1/k_2 \\end{pmatrix} \\begin{pmatrix} -k_1 \\\\ -k_2 \\end{pmatrix} $$\n$$ S = (k_1+k_2) - \\begin{pmatrix} -1  -1 \\end{pmatrix} \\begin{pmatrix} -k_1 \\\\ -k_2 \\end{pmatrix} $$\n$$ S = (k_1+k_2) - ((-1)(-k_1) + (-1)(-k_2)) $$\n$$ S = (k_1+k_2) - (k_1+k_2) = 0 $$\n凝聚刚度为 $S=0$。这在物理上对应于这样一个事实：无约束的杆具有刚体模态，而凝聚过程分离出了静态平衡的条件。$S$ 的单位是 $\\text{N}/\\text{m}$，这是相符的。\n\n现在我们计算凝聚载荷向量 $g$。\n$$ g = \\mathbf{f}_c - \\mathbf{K}_{cb} \\mathbf{K}_{bb}^{-1} \\mathbf{f}_b $$\n回顾 $\\mathbf{f}_c = f_2$ 和 $\\mathbf{f}_b = \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix}$：\n$$ g = f_2 - \\begin{pmatrix} -k_1  -k_2 \\end{pmatrix} \\begin{pmatrix} 1/k_1  0 \\\\ 0  1/k_2 \\end{pmatrix} \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix} $$\n$$ g = f_2 - \\begin{pmatrix} -1  -1 \\end{pmatrix} \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix} $$\n$$ g = f_2 - ((-1)f_1 + (-1)f_3) $$\n$$ g = f_2 - (-f_1 - f_3) = f_1 + f_2 + f_3 $$\n$g$ 的最终表达式是所有外部节点力之和。凝聚方程为 $0 \\cdot u_2 = f_1 + f_2 + f_3$。这表明，要存在静态解，作用在自由浮动系统上的净外力必须为零，即 $g=0$。$g$ 的物理单位是牛顿 ($\\text{N}$)，因为它是力的总和。\n\n问题要求给出 $g$ 的表达式。\n$$ g = f_1 + f_2 + f_3 $$\n这就是最终推导出的表达式。", "answer": "$$\n\\boxed{f_1 + f_2 + f_3}\n$$", "id": "3565840"}, {"introduction": "从解析推导转向大规模的实际计算，我们面临一个新的挑战：对于包含数百万自由度的真实问题，显式地构建稠密的舒尔补矩阵 $S$ 在计算上是不可行的。关键在于实现其对向量的“乘积”操作，$y_b = S x_b$，这正是共轭梯度等迭代求解器所需要的全部。本练习将指导你设计必要的数据结构与算法，以实现这种“免矩阵”的高效计算方法，这是高性能科学计算中的核心技巧。[@problem_id:3565877]", "problem": "要求您实现一个由子结构法和静力凝聚产生的界面算子的应用，而无需显式组装全局舒尔补。目标是设计数据结构和组装映射，以便通过仅在内部自由度（DOF）上进行局部子域求解以及在界面向量上进行收集-散布操作，来实现该算子在全局界面向量上的作用。\n\n考虑一组由 $s$ 索引的子域，每个子域的刚度矩阵被分块为内部和界面自由度。基本前提是，控制线性系统是对称正定的，并且源于一个适定的变分形式，对内部自由度执行分块高斯消元会产生一个仅作用于界面自由度的算子。您不能显式组装全局算子；相反，您必须通过在内部自由度上进行局部线性求解，并通过组装映射求和贡献，来实现其在给定界面向量上的作用。\n\n程序要求：\n- 为每个子域 $s$ 设计一个数据结构，用于存储矩阵 $K_{ii}^{(s)}$、$K_{ib}^{(s)}$、$K_{bi}^{(s)}$、$K_{bb}^{(s)}$ 以及一个映射 $\\phi^{(s)}$，该映射将每个局部界面自由度索引 $j$ 映射到全局界面索引 $\\phi^{(s)}(j)$。\n- 实现一个函数，在给定全局界面向量 $x_b \\in \\mathbb{R}^{N_b}$ 的情况下，通过以下步骤计算 $y_b = S x_b$，而无需组装 $S$：\n  - 使用 $\\phi^{(s)}$ 收集局部切片 $x_b^{(s)}$，\n  - 对每个子域的内部自由度求解一个局部内部系统，\n  - 形成局部界面贡献，\n  - 使用 $\\phi^{(s)}$ 将这些贡献散布并求和回全局界面向量。\n- 您的程序必须对下面给出的一组测试用例应用此操作，并打印结果向量。\n\n定义和约束：\n- 所有矩阵和向量均为实值。\n- 如果一个子域没有内部自由度，则将其内部块视为空，并跳过内部求解；其贡献仅取决于其界面块。\n- 所有界面映射都是从局部索引到全局索引的多对一映射，重叠的贡献必须求和。\n- 不涉及角度。不需要物理单位。\n\n测试套件：\n为以下三个测试用例提供结果。对于每个子域 $s$，给定 $K_{ii}^{(s)} \\in \\mathbb{R}^{n_i^{(s)} \\times n_i^{(s)}}$、$K_{ib}^{(s)} \\in \\mathbb{R}^{n_i^{(s)} \\times n_b^{(s)}}$、$K_{bi}^{(s)} \\in \\mathbb{R}^{n_b^{(s)} \\times n_i^{(s)}}$、$K_{bb}^{(s)} \\in \\mathbb{R}^{n_b^{(s)} \\times n_b^{(s)}}$，以及一个局部到全局的界面映射 $\\phi^{(s)}: \\{0,\\ldots,n_b^{(s)}-1\\} \\to \\{0,\\ldots,N_b-1\\}$。全局界面向量 $x_b$ 的长度为 $N_b$。\n\n- 测试用例 A：\n  - 全局界面大小 $N_b = 1$。\n  - 子域：单个子域 $s$，其中\n    $$\n    K_{ii}^{(s)} =\n    \\begin{bmatrix}\n    4  1 \\\\\n    1  3\n    \\end{bmatrix},\\quad\n    K_{ib}^{(s)} =\n    \\begin{bmatrix}\n    1 \\\\\n    2\n    \\end{bmatrix},\\quad\n    K_{bi}^{(s)} =\n    \\begin{bmatrix}\n    1  2\n    \\end{bmatrix},\\quad\n    K_{bb}^{(s)} =\n    \\begin{bmatrix}\n    5\n    \\end{bmatrix}.\n    $$\n    局部到全局的映射为 $\\phi^{(s)} = [0]$。\n  - 使用 $x_b = [1.5]$。\n- 测试用例 B：\n  - 全局界面大小 $N_b = 3$。\n  - 子域：两个子域 $s \\in \\{1,2\\}$，具体如下。\n    - 子域 $s=1$：\n      $$\n      K_{ii}^{(1)} =\n      \\begin{bmatrix}\n      3\n      \\end{bmatrix},\\quad\n      K_{ib}^{(1)} =\n      \\begin{bmatrix}\n      1  -1\n      \\end{bmatrix},\\quad\n      K_{bi}^{(1)} =\n      \\begin{bmatrix}\n      1 \\\\\n      -1\n      \\end{bmatrix},\\quad\n      K_{bb}^{(1)} =\n      \\begin{bmatrix}\n      4  0.5 \\\\\n      0.5  2\n      \\end{bmatrix}.\n      $$\n      局部到全局的映射为 $\\phi^{(1)} = [0, 1]$。\n    - 子域 $s=2$：\n      $$\n      K_{ii}^{(2)} =\n      \\begin{bmatrix}\n      6  1 \\\\\n      1  4\n      \\end{bmatrix},\\quad\n      K_{ib}^{(2)} =\n      \\begin{bmatrix}\n      2  0 \\\\\n      -1  3\n      \\end{bmatrix},\\quad\n      K_{bi}^{(2)} =\n      \\begin{bmatrix}\n      2  -1 \\\\\n      0  3\n      \\end{bmatrix},\\quad\n      K_{bb}^{(2)} =\n      \\begin{bmatrix}\n      3  -0.2 \\\\\n      -0.2  5\n      \\end{bmatrix}.\n      $$\n      局部到全局的映射为 $\\phi^{(2)} = [1, 2]$。\n  - 使用 $x_b = [1.0,\\,-0.5,\\,2.0]$。\n- 测试用例 C：\n  - 全局界面大小 $N_b = 3$。\n  - 子域：三个子域 $s \\in \\{1,2,3\\}$，具体如下。\n    - 子域 $s=1$ (无内部自由度)：\n      $$\n      K_{ii}^{(1)} \\in \\mathbb{R}^{0 \\times 0},\\quad\n      K_{ib}^{(1)} \\in \\mathbb{R}^{0 \\times 2},\\quad\n      K_{bi}^{(1)} \\in \\mathbb{R}^{2 \\times 0},\\quad\n      K_{bb}^{(1)} =\n      \\begin{bmatrix}\n      2  0.3 \\\\\n      0.3  1.5\n      \\end{bmatrix}.\n      $$\n      局部到全局的映射为 $\\phi^{(1)} = [0, 1]$。\n    - 子域 $s=2$：\n      $$\n      K_{ii}^{(2)} =\n      \\begin{bmatrix}\n      2\n      \\end{bmatrix},\\quad\n      K_{ib}^{(2)} =\n      \\begin{bmatrix}\n      -1  0.5\n      \\end{bmatrix},\\quad\n      K_{bi}^{(2)} =\n      \\begin{bmatrix}\n      -1 \\\\\n      0.5\n      \\end{bmatrix},\\quad\n      K_{bb}^{(2)} =\n      \\begin{bmatrix}\n      1  0.1 \\\\\n      0.1  2\n      \\end{bmatrix}.\n      $$\n      局部到全局的映射为 $\\phi^{(2)} = [1, 2]$。\n    - 子域 $s=3$：\n      $$\n      K_{ii}^{(3)} =\n      \\begin{bmatrix}\n      7  0 \\\\\n      0  8\n      \\end{bmatrix},\\quad\n      K_{ib}^{(3)} =\n      \\begin{bmatrix}\n      1 \\\\\n      2\n      \\end{bmatrix},\\quad\n      K_{bi}^{(3)} =\n      \\begin{bmatrix}\n      1  2\n      \\end{bmatrix},\\quad\n      K_{bb}^{(3)} =\n      \\begin{bmatrix}\n      4\n      \\end{bmatrix}.\n      $$\n      局部到全局的映射为 $\\phi^{(3)} = [2]$。\n  - 使用 $x_b = [0.2,\\,-1.2,\\,0.7]$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。此列表的每个元素对应一个测试用例，并且必须本身是表示该测试用例的结果全局界面向量 $y_b$ 的列表。例如，打印的结构必须类似于 $[\\,[\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,\\ldots\\,]$。\n- 使用标准四舍五入法，将所有浮点数表示为小数点后 $6$ 位。", "solution": "该问题是有效的，因为它在科学上是合理的、适定的，并提供了完整的规范。它描述了计算力学中的一个标准数值过程，称为静力凝聚，这是某些域分解方法（如有限元撕裂与连接法 (FETI) 或通用子结构法）的关键组成部分。该问题要求在不显式构造全局舒尔补算子的情况下，实现该算子与向量的乘积。\n\n其指导原则基于全局线性方程组的分块，这通常源于有限元方法 (FEM) 离散化。对于一个划分为内部自由度（DOF，索引为 $i$）和界面（或边界）自由度（索引为 $b$）的系统，单个子域 $s$ 的线性系统可以写为：\n$$\n\\begin{bmatrix} K_{ii}^{(s)}  K_{ib}^{(s)} \\\\ K_{bi}^{(s)}  K_{bb}^{(s)} \\end{bmatrix}\n\\begin{bmatrix} x_i^{(s)} \\\\ x_b^{(s)} \\end{bmatrix}\n=\n\\begin{bmatrix} f_i^{(s)} \\\\ f_b^{(s)} \\end{bmatrix}\n$$\n这里，$K^{(s)}$ 是子域 $s$ 的刚度矩阵，$x^{(s)}$ 是未知位移向量，$f^{(s)}$ 是施加的节点力向量。索引 $i$ 和 $b$ 分别指局部内部和局部界面自由度。\n\n静力凝聚是消除内部自由度 $x_i^{(s)}$ 的过程。假设没有外力施加于内部自由度（即 $f_i^{(s)} = 0$），块系统的第一行给出：\n$$\nK_{ii}^{(s)} x_i^{(s)} + K_{ib}^{(s)} x_b^{(s)} = 0\n$$\n由于问题陈述该系统源于一个适定形式，矩阵 $K_{ii}^{(s)}$（子域边界“被夹紧”时的刚度）是对称正定的，因此是可逆的。我们可以用界面位移 $x_b^{(s)}$ 来表示内部位移 $x_i^{(s)}$：\n$$\nx_i^{(s)} = -(K_{ii}^{(s)})^{-1} K_{ib}^{(s)} x_b^{(s)}\n$$\n将此代入描述界面自由度上力的块系统第二行，我们得到：\n$$\nf_b^{(s)} = K_{bi}^{(s)} x_i^{(s)} + K_{bb}^{(s)} x_b^{(s)} = K_{bi}^{(s)} \\left( -(K_{ii}^{(s)})^{-1} K_{ib}^{(s)} x_b^{(s)} \\right) + K_{bb}^{(s)} x_b^{(s)}\n$$\n这可以简化为：\n$$\nf_b^{(s)} = \\left( K_{bb}^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} K_{ib}^{(s)} \\right) x_b^{(s)}\n$$\n括号中的项是局部舒尔补矩阵 $S^{(s)}$：\n$$\nS^{(s)} = K_{bb}^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} K_{ib}^{(s)}\n$$\n$S^{(s)}$ 关联了局部界面自由度的位移与作用于其上的力，此时内部的影响已被“凝聚”掉。\n\n全局界面系统是通过组装所有子域的贡献形成的。全局舒尔补 $S$ 是投射到全局界面自由度上的局部舒尔补之和。如果 $A^{(s)}$ 表示从全局界面向量到子域 $s$ 的局部界面向量的映射（或收集），那么其转置 $A^{(s)T}$ 表示从局部到全局的散布（和求和）。全局算子为 $S = \\sum_s A^{(s)T} S^{(s)} A^{(s)}$。\n\n问题要求计算此全局算子在给定全局界面向量 $x_b$ 上的作用，即计算 $y_b = S x_b$，而无需显式构造 $S$ 或局部 $S^{(s)}$ 矩阵。计算过程如下：\n$$\ny_b = \\left( \\sum_s A^{(s)T} S^{(s)} A^{(s)} \\right) x_b = \\sum_s A^{(s)T} \\left( S^{(s)} (A^{(s)} x_b) \\right)\n$$\n令 $x_b^{(s)} = A^{(s)} x_b$ 为从 $x_b$ 中收集的局部向量。核心任务是为每个子域计算局部乘积 $y_b^{(s)} = S^{(s)} x_b^{(s)}$，然后散布并相加结果：$y_b = \\sum_s A^{(s)T} y_b^{(s)}$。\n\n局部乘积 $y_b^{(s)} = S^{(s)} x_b^{(s)}$ 可以高效地计算为：\n$$\ny_b^{(s)} = \\left( K_{bb}^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} K_{ib}^{(s)} \\right) x_b^{(s)} = K_{bb}^{(s)} x_b^{(s)} - K_{bi}^{(s)} \\left( (K_{ii}^{(s)})^{-1} (K_{ib}^{(s)} x_b^{(s)}) \\right)\n$$\n为避免构造矩阵的逆 $(K_{ii}^{(s)})^{-1}$，此计算分步进行：\n1.  计算内部问题的右端项：$v^{(s)} = K_{ib}^{(s)} x_b^{(s)}$。\n2.  求解局部内部系统以获得辅助向量 $u_i^{(s)}$：$K_{ii}^{(s)} u_i^{(s)} = v^{(s)}$。这是“在内部自由度上的局部求解”。\n3.  计算最终的局部贡献：$y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)} - K_{bi}^{(s)} u_i^{(s)}$。\n\n如果一个子域 $s$ 没有内部自由度（$n_i^{(s)} = 0$），则矩阵 $K_{ii}^{(s)}$、$K_{ib}^{(s)}$ 和 $K_{bi}^{(s)}$ 是空的。涉及逆的舒尔补项消失，局部贡献简化为 $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)}$。\n\n总体算法如下：\n1.  将全局结果向量 $y_b$ 初始化为零，长度为 $N_b$。\n2.  对于每个子域 $s$：\n    a.  **收集**：使用映射 $\\phi^{(s)}$ 从全局向量 $x_b$ 中提取局部界面向量 $x_b^{(s)}$。\n    b.  **计算局部贡献**：\n        i. 如果 $n_i^{(s)} > 0$，通过如上所述执行局部求解来计算 $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} (K_{ib}^{(s)} x_b^{(s)})$。\n        ii. 如果 $n_i^{(s)} = 0$，计算 $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)}$。\n    c.  **散布**：使用映射 $\\phi^{(s)}$ 将局部结果 $y_b^{(s)}$ 的元素加到全局向量 $y_b$ 的相应位置上。\n3.  最终的向量 $y_b$ 是操作 $S x_b$ 的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_schur_operator(Nb, subdomains, xb):\n    \"\"\"\n    Computes the action of the Schur complement operator S on a vector xb.\n\n    This function computes yb = S @ xb without explicitly assembling S.\n    The computation is done subdomain by subdomain using gather-solve-scatter ops.\n\n    Args:\n        Nb (int): The total number of global interface DOFs.\n        subdomains (list): A list of dictionaries, each representing a subdomain's data.\n        xb (np.ndarray): The global interface vector.\n\n    Returns:\n        np.ndarray: The resulting global interface vector yb.\n    \"\"\"\n    yb = np.zeros(Nb, dtype=float)\n\n    for s_data in subdomains:\n        Kii = s_data['Kii']\n        Kib = s_data['Kib']\n        Kbi = s_data['Kbi']\n        Kbb = s_data['Kbb']\n        phi = s_data['phi']\n        ni_s = Kii.shape[0]\n\n        # 1. Gather operation: extract local interface vector from global vector\n        xb_s = xb[phi]\n\n        # 2. Compute local contribution yb_s = S_s * xb_s\n        if ni_s > 0:\n            # S_s = Kbb_s - Kbi_s * inv(Kii_s) * Kib_s\n            # We compute the product yb_s = S_s @ xb_s in steps:\n            # a. Compute intermediate vector v_s = Kib_s @ xb_s\n            v_s = Kib @ xb_s\n            # b. Solve the local interior system: Kii_s * u_i_s = v_s\n            u_i_s = np.linalg.solve(Kii, v_s)\n            # c. Compute local contribution: yb_s = Kbb_s @ xb_s - Kbi_s @ u_i_s\n            yb_s = Kbb @ xb_s - Kbi @ u_i_s\n        else:\n            # If no interior DOFs, S_s = Kbb_s\n            yb_s = Kbb @ xb_s\n        \n        # 3. Scatter operation: add local contribution back to global vector\n        # np.add.at is a vectorized way to perform this scatter-add operation.\n        np.add.at(yb, phi, yb_s)\n\n    return yb\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {\n            \"Nb\": 1,\n            \"subdomains\": [\n                {\n                    \"Kii\": np.array([[4, 1], [1, 3]]),\n                    \"Kib\": np.array([[1], [2]]),\n                    \"Kbi\": np.array([[1, 2]]),\n                    \"Kbb\": np.array([[5]]),\n                    \"phi\": np.array([0]),\n                }\n            ],\n            \"xb\": np.array([1.5]),\n        },\n        # Test Case B\n        {\n            \"Nb\": 3,\n            \"subdomains\": [\n                {\n                    \"Kii\": np.array([[3]]),\n                    \"Kib\": np.array([[1, -1]]),\n                    \"Kbi\": np.array([[1], [-1]]),\n                    \"Kbb\": np.array([[4, 0.5], [0.5, 2]]),\n                    \"phi\": np.array([0, 1]),\n                },\n                {\n                    \"Kii\": np.array([[6, 1], [1, 4]]),\n                    \"Kib\": np.array([[2, 0], [-1, 3]]),\n                    \"Kbi\": np.array([[2, -1], [0, 3]]),\n                    \"Kbb\": np.array([[3, -0.2], [-0.2, 5]]),\n                    \"phi\": np.array([1, 2]),\n                },\n            ],\n            \"xb\": np.array([1.0, -0.5, 2.0]),\n        },\n        # Test Case C\n        {\n            \"Nb\": 3,\n            \"subdomains\": [\n                { # Subdomain with no interior DOFs\n                    \"Kii\": np.empty((0, 0)),\n                    \"Kib\": np.empty((0, 2)),\n                    \"Kbi\": np.empty((2, 0)),\n                    \"Kbb\": np.array([[2, 0.3], [0.3, 1.5]]),\n                    \"phi\": np.array([0, 1]),\n                },\n                {\n                    \"Kii\": np.array([[2]]),\n                    \"Kib\": np.array([[-1, 0.5]]),\n                    \"Kbi\": np.array([[-1], [0.5]]),\n                    \"Kbb\": np.array([[1, 0.1], [0.1, 2]]),\n                    \"phi\": np.array([1, 2]),\n                },\n                {\n                    \"Kii\": np.array([[7, 0], [0, 8]]),\n                    \"Kib\": np.array([[1], [2]]),\n                    \"Kbi\": np.array([[1, 2]]),\n                    \"Kbb\": np.array([[4]]),\n                    \"phi\": np.array([2]),\n                },\n            ],\n            \"xb\": np.array([0.2, -1.2, 0.7]),\n        },\n    ]\n\n    results_str = []\n    for case in test_cases:\n        Nb = case[\"Nb\"]\n        subdomains = case[\"subdomains\"]\n        xb = case[\"xb\"]\n        \n        yb = apply_schur_operator(Nb, subdomains, xb)\n        \n        # Format the result vector as a string list with 6 decimal places\n        formatted_yb = [f\"{val:.6f}\" for val in yb]\n        results_str.append(f\"[{','.join(formatted_yb)}]\")\n\n    # Print the final output in the required format: [[...],[...],...]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3565877"}]}