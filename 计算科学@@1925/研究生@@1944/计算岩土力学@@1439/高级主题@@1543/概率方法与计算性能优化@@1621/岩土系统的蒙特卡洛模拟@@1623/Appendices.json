{"hands_on_practices": [{"introduction": "在岩土工程中，我们经常需要根据有限的、分布通常未知的现场测量数据来估计土体参数（例如平均沉降）。这个练习将引导您使用“自助法”（bootstrap method），这是一种强大的、由数据驱动的非参数技术，用于量化参数估计的不确定性。通过这个实践，您将学会如何在不依赖于正态分布等强假设的情况下，稳健地评估估计值的置信区间，这对于处理具有偏态分布特征的真实岩土数据至关重要[@problem_id:3544691]。", "problem": "一位岩土工程师正在研究浅基础的竖向沉降。设随机沉降用 $S$ 表示，单位为毫米，且 $S \\ge 0$。该工程师收集了一个由测量的沉降值组成的独立同分布样本 $\\{S_1,\\dots,S_n\\}$，并试图使用非参数自助法来量化平均沉降估计量的不确定性，并评估其在偏态分布下的稳健性。\n\n使用以下基础理论：随机变量的期望和方差的定义；样本均值 $\\bar{S}_n = \\frac{1}{n}\\sum_{i=1}^n S_i$ 作为总体均值估计量的定义；大数定律（证明自助法经验分布可近似数据生成分布）；以及有放回重抽样原理来近似估计量的抽样分布。不要使用任何估计量的闭式置信区间表达式。相反，应使用自助法重抽样来量化不确定性，并构建一个偏差校正和加速置信区间。确保所有计算均以毫米为单位进行，并以毫米为单位陈述答案，四舍五入到三位小数。\n\n对于下述每个测试用例，执行以下步骤：\n1. 使用指定的种子和为 $S$ 指定的偏态分布，模拟一个合成数据集 $\\{S_i\\}_{i=1}^n$。\n2. 计算点估计值 $\\hat{\\mu} = \\bar{S}_n$。\n3. 执行 $B$ 次自助法重抽样（从 $\\{S_i\\}_{i=1}^n$ 中有放回地抽样），以获得均值的自助法复制值集合 $\\{\\hat{\\mu}^{\\ast b}\\}_{b=1}^B$。根据这些复制值，计算：\n   - 自助法标准误 $\\widehat{\\mathrm{se}}_{\\text{boot}}$，即 $\\{\\hat{\\mu}^{\\ast b}\\}_{b=1}^B$ 的样本标准差。\n   - 从 $\\hat{\\mu}$ 的自助法分布构建的、针对 $\\mu$ 的名义水平为 $0.95$ 的双侧偏差校正和加速区间。不要使用任何参数化或渐近高斯区间进行此构建。\n4. 为了评估稳健性，根据指定的分布模型和参数，计算 $S$ 的总体均值 $\\mu$ 和总体标准差 $\\sigma$。计算样本均值的真实标准误 $\\mathrm{se}_{\\text{true}} = \\sigma / \\sqrt{n}$。记录：\n   - 覆盖指示符 $c$，定义为：如果计算出的区间包含 $\\mu$，则 $c = 1$，否则 $c = 0$。\n   - 比率 $r = \\widehat{\\mathrm{se}}_{\\text{boot}} / \\mathrm{se}_{\\text{true}}$。\n5. 对于每个测试用例，将结果生成为一个列表 $[\\hat{\\mu}, \\widehat{\\mathrm{se}}_{\\text{boot}}, L, U, c, r]$，其中 $[L,U]$ 是为 $\\mu$ 计算出的 $0.95$ 偏差校正和加速区间。除 $c$ 外的所有量都必须是单位为毫米的浮点数；$c$ 必须是整数 $0$ 或 $1$。将所有浮点数四舍五入到三位小数。\n\n用于步骤 4 的分布和总体公式：\n- 如果 $S$ 服从参数为 $(\\mu_{\\log}, \\sigma_{\\log})$ 的对数正态分布，则 $\\mu = \\exp(\\mu_{\\log} + \\tfrac{1}{2}\\sigma_{\\log}^2)$ 且 $\\sigma^2 = \\left(\\exp(\\sigma_{\\log}^2) - 1\\right)\\exp(2\\mu_{\\log} + \\sigma_{\\log}^2)$。\n- 如果 $S$ 服从形状参数为 $k$、尺度参数为 $\\theta$ 的伽马分布，则 $\\mu = k\\theta$ 且 $\\sigma^2 = k\\theta^2$。\n\n测试套件：\n- 用例 A（中等偏度，较大 $n$）：对数正态分布，参数为 $(\\mu_{\\log}, \\sigma_{\\log}) = (2.4, 0.5)$，$n = 60$，$B = 5000$，种子 $= 20240501$。\n- 用例 B（高偏度，较小 $n$）：对数正态分布，参数为 $(\\mu_{\\log}, \\sigma_{\\log}) = (2.0, 1.0)$，$n = 25$，$B = 5000$，种子 $= 20240502$。\n- 用例 C（重尾伽马分布）：伽马分布，参数为 $(k, \\theta) = (0.5, 30.0)$，$n = 40$，$B = 5000$，种子 $= 20240503$。\n- 用例 D（极高偏度，临界 $n$）：对数正态分布，参数为 $(\\mu_{\\log}, \\sigma_{\\log}) = (2.3, 1.2)$，$n = 12$，$B = 5000$，种子 $= 20240504$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身就是一个列表 $[\\hat{\\mu}, \\widehat{\\mathrm{se}}_{\\text{boot}}, L, U, c, r]$，代表一个测试用例的结果，单位为毫米，浮点数四舍五入到三位小数，$c$ 为整数。例如，打印的行应如下所示：\n$[\\,[\\hat{\\mu}_A,\\widehat{\\mathrm{se}}_{\\text{boot},A},L_A,U_A,c_A,r_A],[\\hat{\\mu}_B,\\widehat{\\mathrm{se}}_{\\text{boot},B},L_B,U_B,c_B,r_B],\\dots\\,]$。", "solution": "所提出的问题是分析非参数自助法在量化代表岩土沉降的偏态非负随机变量的估计均值不确定性方面的性能。这涉及生成合成数据，计算点估计，然后使用偏差校正和加速（BCa）自助法构建置信区间。然后将结果与已知的真实总体参数进行比较，以评估自助法的准确性和稳健性，特别是在小样本量和高度偏态分布的情况下。该问题定义明确、科学合理且计算上可行。我们着手解决。\n\n### 科学原理与算法设计\n\n问题的核心在于应用基于重抽样的统计推断。其基本原理是大数定律和中心极限定理，前者为自助法提供了理论基础，而后者的假设在处理偏态数据时常常被违反，这激发了对如 BCa 区间等更稳健方法的需求。\n\n**1. 自助法原理**\n设 $F$ 是沉降 $S$ 的真实但未知的累积分布函数（CDF）。我们有一个从 $F$ 中抽取的独立同分布样本 $\\{S_1, S_2, \\dots, S_n\\}$。样本均值 $\\hat{\\mu} = \\bar{S}_n = \\frac{1}{n}\\sum_{i=1}^n S_i$ 是我们对真实总体均值 $\\mu = E_F[S]$ 的估计量。为了评估 $\\hat{\\mu}$ 的不确定性，我们需要它的抽样分布。由于 $F$ 是未知的，我们无法直接推导出这个分布。\n\n自助法原理通过用经验分布函数（EDF）$\\hat{F}_n$ 替代 $F$ 来规避这个问题。$\\hat{F}_n$ 是一个离散均匀分布，它在每个观测数据点 $S_i$ 上赋予 $1/n$ 的概率质量。这种替代的有效性由 Glivenko-Cantelli 定理证明，该定理指出当 $n \\to \\infty$ 时，$\\hat{F}_n$ 收敛于 $F$。然后，我们通过从 $\\hat{F}_n$ 中重复抽样并为每个样本计算统计量来近似 $\\hat{\\mu}$ 的抽样分布。这个过程被称为有放回重抽样。\n\n**2. 自助法算法与标准误**\n生成均值的自助法分布的算法如下：\n- 对于 $b = 1, \\dots, B$，其中 $B$ 是大量的自助法复制次数：\n  1. 通过从原始样本 $\\{S_1, \\dots, S_n\\}$ 中有放回地抽取 $n$ 次，生成一个自助样本 $\\{S_1^{*b}, \\dots, S_n^{*b}\\}$。\n  2. 计算该自助样本的均值：$\\hat{\\mu}^{*b} = \\frac{1}{n} \\sum_{i=1}^n S_i^{*b}$。\n- 集合 $\\{\\hat{\\mu}^{*1}, \\dots, \\hat{\\mu}^{*B}\\}$ 构成了经验自助法分布，它可作为 $\\hat{\\mu}$ 真实抽样分布的近似。\n- 自助法标准误 $\\widehat{\\mathrm{se}}_{\\text{boot}}$ 是这些自助法复制值的样本标准差，提供了对真实标准误 $\\mathrm{se}_{\\text{true}} = \\sigma/\\sqrt{n}$ 的一个估计：\n$$ \\widehat{\\mathrm{se}}_{\\text{boot}} = \\sqrt{\\frac{1}{B-1} \\sum_{b=1}^B \\left(\\hat{\\mu}^{*b} - \\frac{1}{B}\\sum_{j=1}^B \\hat{\\mu}^{*j}\\right)^2} $$\n\n**3. 偏差校正和加速（BCa）置信区间**\n对于偏态或有偏的抽样分布，一个由排序后的自助法复制值 $\\{\\hat{\\mu}^*\\}$ 构建的简单百分位区间可能会表现出较差的覆盖概率。BCa 区间通过调整分位数端点来改进百分位方法，以考虑两个因素：偏差和加速（偏度）。\n\n一个 $1-\\alpha$ 置信区间由 $[\\hat{\\mu}^*_{(\\alpha_1)}, \\hat{\\mu}^*_{(\\alpha_2)}]$ 给出。这里，$\\hat{\\mu}^*_{(p)}$ 表示自助法复制值的第 $p$ 分位数。BCa 方法如下计算调整后的分位数 $\\alpha_1$ 和 $\\alpha_2$：\n$$ \\alpha_1 = \\Phi\\left( \\hat{z}_0 + \\frac{\\hat{z}_0 + z^{(\\alpha/2)}}{1 - \\hat{a}(\\hat{z}_0 + z^{(\\alpha/2)})} \\right) $$\n$$ \\alpha_2 = \\Phi\\left( \\hat{z}_0 + \\frac{\\hat{z}_0 + z^{(1-\\alpha/2)}}{1 - \\hat{a}(\\hat{z}_0 + z^{(1-\\alpha/2)})} \\right) $$\n其中：\n- $\\Phi(\\cdot)$ 是标准正态累积分布函数（CDF）。\n- $z^{(p)}$ 是标准正态分布的第 $p$ 分位数（即 $\\Phi^{-1}(p)$）。对于 $95\\%$ 的区间，$\\alpha=0.05$，$z^{(0.025)} \\approx -1.96$，$z^{(0.975)} \\approx 1.96$。\n- $\\hat{z}_0$ 是偏差校正因子。\n- $\\hat{a}$ 是加速因子。\n\n**3.1. 偏差校正因子 ($\\hat{z}_0$)**\n偏差校正因子衡量自助法分布的中位数偏差。它被计算为与小于原始样本估计值 $\\hat{\\mu}$ 的自助法复制值所占比例相对应的标准正态分位数：\n$$ \\hat{z}_0 = \\Phi^{-1}\\left( \\frac{\\#\\{\\hat{\\mu}^{*b} < \\hat{\\mu}\\}}{B} \\right) $$\n如果自助法分布是中位数无偏的（即 $\\text{median}(\\{\\hat{\\mu}^{*b}\\}) = \\hat{\\mu}$），那么这个比例是 $0.5$，且 $\\hat{z}_0 = \\Phi^{-1}(0.5) = 0$。\n\n**3.2. 加速因子 ($\\hat{a}$)**\n加速因子 $\\hat{a}$ 校正了抽样分布的偏度，或者等效地，校正了 $\\hat{\\mu}$ 的标准误如何随着真实参数 $\\mu$ 的变化而变化。它使用刀切法（jackknife method）进行估计。统计量的刀切估计是通过每次系统地剔除一个观测值来计算的。\n1. 对于 $i = 1, \\dots, n$，令 $\\hat{\\mu}_{(-i)}$ 为移除第 $i$ 个数据点 $S_i$ 后的样本均值。\n2. 令 $\\bar{\\mu}_{(\\cdot)} = \\frac{1}{n} \\sum_{i=1}^n \\hat{\\mu}_{(-i)}$ 为这些刀切估计值的均值。\n3. 加速因子则估计为：\n$$ \\hat{a} = \\frac{\\sum_{i=1}^n (\\bar{\\mu}_{(\\cdot)} - \\hat{\\mu}_{(-i)})^3}{6 \\left[ \\sum_{i=1}^n (\\bar{\\mu}_{(\\cdot)} - \\hat{\\mu}_{(-i)})^2 \\right]^{3/2}} $$\n如果分母中的平方和为零（对于连续数据而言，这极不可能发生），则取 $\\hat{a}$ 为 $0$。\n\n**4. 算法实现摘要**\n对每个指定的测试用例：\n1.  **数据生成**：设置随机种子。从指定的分布（对数正态或伽马）及其给定参数生成一个大小为 $n$ 的样本 $\\{S_i\\}_{i=1}^n$。\n2.  **点估计**：计算样本均值 $\\hat{\\mu} = \\bar{S}_n$。\n3.  **自助法重抽样**：\n    - 通过对原始数据进行有放回重抽样，生成 $B$ 个自助样本。\n    - 对每个自助样本计算其均值，得到 $B$ 个自助法复制值 $\\{\\hat{\\mu}^{*b}\\}$。\n4.  **不确定性量化**：\n    - 计算自助法标准误 $\\widehat{\\mathrm{se}}_{\\text{boot}}$，即 $\\{\\hat{\\mu}^{*b}\\}$ 的样本标准差。\n    - 对自助法复制值进行排序。\n    - 使用小于 $\\hat{\\mu}$ 的自助法均值比例来计算偏差校正因子 $\\hat{z}_0$。\n    - 使用刀切法程序对原始样本计算加速因子 $\\hat{a}$。\n    - 使用 BCa 公式计算置信水平为 $95\\%$（$\\alpha=0.05$）的调整后分位数水平 $\\alpha_1$ 和 $\\alpha_2$。\n    - 通过从排序后的自助法复制值中找到相应的分位数，确定置信区间的下界和上界 $[L, U]$。\n5.  **评估**：\n    - 使用提供的解析公式，根据给定的分布计算真实的总体均值 $\\mu$ 和标准差 $\\sigma$。\n    - 计算均值的真实标准误：$\\mathrm{se}_{\\text{true}} = \\sigma / \\sqrt{n}$。\n    - 确定覆盖指示符 $c$：如果 $\\mu \\in [L, U]$，则 $c=1$，否则 $c=0$。\n    - 计算性能比率 $r = \\widehat{\\mathrm{se}}_{\\text{boot}} / \\mathrm{se}_{\\text{true}}$。\n6.  **输出**：存储并格式化最终列表 $[\\hat{\\mu}, \\widehat{\\mathrm{se}}_{\\text{boot}}, L, U, c, r]$，将所有浮点数四舍五入到三位小数。\n\n这一全面的流程允许在分布偏度和样本量变化的条件下，对 BCa 自助法的性能进行严格评估，这些条件是岩土工程和许多其他科学领域中的特征性挑战。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, lognorm, gamma\n\ndef solve():\n    \"\"\"\n    Solves the problem by performing bootstrap analysis for each test case.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    # format: (distribution_name, {params}, n, B, seed)\n    test_cases = [\n        ('lognormal', {'mu_log': 2.4, 'sigma_log': 0.5}, 60, 5000, 20240501),\n        ('lognormal', {'mu_log': 2.0, 'sigma_log': 1.0}, 25, 5000, 20240502),\n        ('gamma', {'k': 0.5, 'theta': 30.0}, 40, 5000, 20240503),\n        ('lognormal', {'mu_log': 2.3, 'sigma_log': 1.2}, 12, 5000, 20240504),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        dist_name, params, n, B, seed = case\n        \n        # 1. Simulate synthetic dataset\n        rng = np.random.default_rng(seed)\n        if dist_name == 'lognormal':\n            mu_log, sigma_log = params['mu_log'], params['sigma_log']\n            # scipy.stats.lognorm takes s=sigma_log, scale=exp(mu_log)\n            # which is equivalent to np.random.lognormal(mean=mu_log, sigma=sigma_log)\n            data = rng.lognormal(mean=mu_log, sigma=sigma_log, size=n)\n            \n            # 4. Compute true population parameters (Lognormal)\n            mu_true = np.exp(mu_log + 0.5 * sigma_log**2)\n            sigma_true = np.sqrt((np.exp(sigma_log**2) - 1) * np.exp(2 * mu_log + sigma_log**2))\n\n        elif dist_name == 'gamma':\n            k, theta = params['k'], params['theta']\n            # scipy.stats.gamma takes a=k, scale=theta\n            data = rng.gamma(shape=k, scale=theta, size=n)\n\n            # 4. Compute true population parameters (Gamma)\n            mu_true = k * theta\n            sigma_true = np.sqrt(k * theta**2)\n\n        # 2. Compute point estimate\n        mu_hat = np.mean(data)\n\n        # 3. Perform B bootstrap resamples\n        bootstrap_means = np.zeros(B)\n        for b in range(B):\n            bootstrap_sample = rng.choice(data, size=n, replace=True)\n            bootstrap_means[b] = np.mean(bootstrap_sample)\n\n        # Compute bootstrap standard error\n        se_boot = np.std(bootstrap_means, ddof=1)\n\n        # Compute BCa confidence interval\n        # Bias-correction factor z0\n        prop_less = np.sum(bootstrap_means < mu_hat) / B\n        z0_hat = norm.ppf(prop_less)\n\n        # Acceleration factor a_hat (using jackknife)\n        jackknife_means = np.zeros(n)\n        for i in range(n):\n            jackknife_sample = np.delete(data, i)\n            jackknife_means[i] = np.mean(jackknife_sample)\n        \n        jack_mean_of_means = np.mean(jackknife_means)\n        devs = jack_mean_of_means - jackknife_means\n        num_a = np.sum(devs**3)\n        den_a = 6 * (np.sum(devs**2))**1.5\n        a_hat = 0.0 if den_a == 0.0 else num_a / den_a\n        \n        # BCa interval endpoints\n        alpha = 0.05\n        z_alpha1 = norm.ppf(alpha / 2)\n        z_alpha2 = norm.ppf(1 - alpha / 2)\n        \n        num1 = z0_hat + z_alpha1\n        adj_alpha1_arg = z0_hat + num1 / (1 - a_hat * num1)\n        \n        num2 = z0_hat + z_alpha2\n        adj_alpha2_arg = z0_hat + num2 / (1 - a_hat * num2)\n\n        adj_alpha1 = norm.cdf(adj_alpha1_arg)\n        adj_alpha2 = norm.cdf(adj_alpha2_arg)\n\n        # Find interval limits L and U from percentiles\n        bca_interval = np.percentile(bootstrap_means, [100 * adj_alpha1, 100 * adj_alpha2])\n        L, U = bca_interval[0], bca_interval[1]\n\n        # 4. Compute true standard error and metrics\n        se_true = sigma_true / np.sqrt(n)\n        \n        # 5. Record coverage indicator and ratio\n        c = 1 if (L <= mu_true <= U) else 0\n        r = se_boot / se_true if se_true > 0 else 0\n\n        # Append results for this case, rounding floats\n        current_result = [\n            round(mu_hat, 3), \n            round(se_boot, 3), \n            round(L, 3), \n            round(U, 3), \n            c, \n            round(r, 3)\n        ]\n        all_results.append(current_result)\n\n    # Final print statement in the exact required format without extra spaces\n    result_strings = []\n    for res in all_results:\n        # Format each float to exactly 3 decimal places\n        formatted_nums = [f\"{x:.3f}\" if i != 4 else str(int(x)) for i, x in enumerate(res)]\n        result_strings.append(f\"[{','.join(formatted_nums)}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3544691"}, {"introduction": "在掌握了如何量化单个参数的不确定性之后，我们将进一步模拟地质系统中的空间变异性。本练习将向您展示如何使用马尔可夫链来表示层状的土体地层，并利用贝叶斯定理结合现场勘探数据（如静力触探试验CPT）来更新我们的地质模型。这个练习提供了一个从地质不确定性建模到工程性能评估（如开挖支护墙的变形）的完整工作流程，生动地展示了蒙特卡洛模拟在解决复杂岩土工程问题中的综合应用[@problem_id:3544647]。", "problem": "您的任务是构建一个完整的、可运行的程序，通过使用马尔可夫链模型生成以静力触探试验（CPT）测量为条件的随机地层序列，对开挖墙体变形超越概率进行蒙特卡洛分析。其科学基础必须明确：地层序列被建模为符合柯尔莫哥洛夫性质的离散时间马尔可夫链，基于CPT测量的条件化使用贝叶斯定理和似然模型，土体的侧向反力被理想化为遵循胡克定律的温克勒地基。墙体侧向变形采用基于平衡和虚功原理的运动学上限定法，并假设位移形态是均匀的。\n\n以下元素定义了建模假设和数据。\n\n1. 状态与马尔可夫链。考虑三种土体状态 $S=\\{\\mathrm{SC},\\mathrm{S},\\mathrm{STC}\\}$，其中 $\\mathrm{SC}$ 代表软黏土，$\\mathrm{S}$ 代表砂土，$\\mathrm{STC}$ 代表硬黏土。一个沿深度索引为 $i=1,\\dots,n$ 的地层剖面由序列 $s_1,\\dots,s_n$ 表示，其中 $s_i \\in S$。设马尔可夫链转移矩阵为 $T\\in\\mathbb{R}^{3\\times 3}$，其中 $T_{ab}=\\mathbb{P}(s_i=b\\mid s_{i-1}=a)$，对于 $a,b\\in S$；并设初始分布为 $\\pi\\in\\mathbb{R}^3$，其中 $\\pi_a=\\mathbb{P}(s_1=a)$。该马尔可夫链假设满足柯尔莫哥洛夫性质 $\\mathbb{P}(s_i\\mid s_{i-1},\\dots,s_1)=\\mathbb{P}(s_i\\mid s_{i-1})$。\n\n2. CPT观测与似然模型。对于每个深度索引 $i$，给定一个观测向量 $o_i=[q_{c,i},R_{f,i}]$，其中 $q_{c,i}$ 是以兆帕（MPa）为单位的CPT锥尖阻力，$R_{f,i}$ 是以小数表示的摩阻比（例如，$0.02$ 对应 $2\\%$）。在给定状态 $s_i$ 的条件下观测到 $o_i$ 的条件似然被建模为协方差为对角阵的二元高斯分布，\n$$\n\\mathcal{L}(o_i\\mid s_i=a)=\\prod_{j=1}^{2}\\frac{1}{\\sqrt{2\\pi}\\,\\sigma_{a,j}}\\exp\\!\\left(-\\frac{(o_{i,j}-\\mu_{a,j})^2}{2\\sigma_{a,j}^2}\\right),\n$$\n其中 $\\mu_{a}=[\\mu_{a,1},\\mu_{a,2}]$ 和 $\\sigma_{a}=[\\sigma_{a,1},\\sigma_{a,2}]$ 分别是状态 $a$ 的均值和标准差，且 $o_{i,1}=q_{c,i}$，$o_{i,2}=R_{f,i}$。\n\n3. 条件马尔可夫链采样。对于 $i=1$，根据贝叶斯定理，给定 $o_1$ 时 $s_1$ 的后验概率满足，\n$$\n\\mathbb{P}(s_1=a\\mid o_1)\\propto \\pi_a\\,\\mathcal{L}(o_1\\mid s_1=a).\n$$\n对于 $i\\geq 2$，以前一个采样状态为条件的一步后验概率使用\n$$\n\\mathbb{P}(s_i=b\\mid s_{i-1}=a,o_i)\\propto T_{ab}\\,\\mathcal{L}(o_i\\mid s_i=b),\n$$\n并且对每个深度，从这个分类分布中采样 $s_i$。\n\n4. 温克勒地基与等效刚度。土体的侧向反力被理想化为具有地基反力系数 $k(z)$（单位 $\\mathrm{N}/\\mathrm{m}^3$）的温克勒地基。对于沿高度为 $H$ 的墙体的一个均匀侧向位移形态 $\\delta$，分布力的平衡要求\n$$\np_e H = \\delta \\int_{0}^{H}k(z)\\,\\mathrm{d}z,\n$$\n其中 $p_e$ 是作用在墙上的均匀开挖引起的侧向压力（单位 $\\mathrm{Pa}$）。求解侧向变形可得\n$$\n\\delta = \\frac{p_e H}{\\int_{0}^{H}k(z)\\,\\mathrm{d}z}.\n$$\n将墙体离散为 $n$ 个厚度为 $\\Delta z = H/n$ 的土层，其中 $k(z)$ 在第 $i$ 个区间上是分段常数，其值为 $k_i$，则积分变为 $\\int_0^H k(z)\\,\\mathrm{d}z \\approx \\sum_{i=1}^{n}k_i\\,\\Delta z$。\n\n5. 通过约束模量从CPT推求地基反力。对于深度索引为 $i$、状态为 $s_i=a$ 的土层，地基反力系数与约束模量 $M_i$ 相关联，即\n$$\nk_i = \\beta_{a}\\,M_i,\\quad M_i=c_{M,a}\\,q_{c,i},\n$$\n其中，在计算 $M_i$ 时，$q_{c,i}$ 从 $\\mathrm{MPa}$ 转换为 $\\mathrm{Pa}$，$c_{M,a}$ 是一个依赖于土体状态的无量纲相关系数，$\\beta_a$ 的单位是 $\\mathrm{m}^{-1}$，代表一个获得 $\\mathrm{N}/\\mathrm{m}^3$ 的几何缩放。常数 $c_{M,a}$ 和 $\\beta_a$ 在下方提供。\n\n6. 蒙特卡洛超越概率。对于每次蒙特卡洛模拟，采样一个以CPT测量值为条件的地层剖面 $s_1,\\dots,s_n$，使用离散化公式计算 $\\delta$，并记录对于指定的阈值 $\\delta_{\\mathrm{th}}$（单位为米），是否有 $\\delta>\\delta_{\\mathrm{th}}$。超越概率是 $\\delta>\\delta_{\\mathrm{th}}$ 的模拟次数所占的比例。\n\n使用以下针对状态和似然的固定参数（所有测试用例均相同）来实现上述算法：\n- 状态均值 $\\mu_a$ 和标准差 $\\sigma_a$ 对于 $a\\in S$：\n  - 软黏土 ($\\mathrm{SC}$): $\\mu_{\\mathrm{SC}}=[1.5,0.04]$, $\\sigma_{\\mathrm{SC}}=[0.5,0.01]$。\n  - 砂土 ($\\mathrm{S}$): $\\mu_{\\mathrm{S}}=[12.0,0.01]$, $\\sigma_{\\mathrm{S}}=[3.0,0.004]$。\n  - 硬黏土 ($\\mathrm{STC}$): $\\mu_{\\mathrm{STC}}=[6.0,0.03]$, $\\sigma_{\\mathrm{STC}}=[1.5,0.008]$。\n- 地基反力相关常数：$c_{M,\\mathrm{SC}}=8$, $c_{M,\\mathrm{S}}=5$, $c_{M,\\mathrm{STC}}=10$，以及 $\\beta_{\\mathrm{SC}}=0.2\\,\\mathrm{m}^{-1}$, $\\beta_{\\mathrm{S}}=1.2\\,\\mathrm{m}^{-1}$, $\\beta_{\\mathrm{STC}}=0.6\\,\\mathrm{m}^{-1}$。\n- 角度单位不适用；所有需要物理单位的输出在计算中必须以米表示变形，以帕斯卡（$\\mathrm{Pa}$）表示压力。\n\n测试套件。您的程序必须计算以下三个测试用例的超越概率。在所有用例中，CPT数据都有 $n=20$ 个深度点；墙高 $H$ 和压力 $p_e$ 是指定的，并且必须使用 $\\Delta z = H/n$。所有CPT $q_{c,i}$ 值都以 $\\mathrm{MPa}$ 为单位，所有 $R_{f,i}$ 值都是小数。所有概率必须以小数形式返回。\n\n- 测试用例 $\\mathrm{A}$（混合地层，中等转移概率）：\n  - 墙高：$H=10$ 米。\n  - 侧向压力：$p_e=50{,}000$ 帕斯卡（即 $50$ 千帕）。\n  - 初始分布：对于 $[\\mathrm{SC},\\mathrm{S},\\mathrm{STC}]$ 为 $\\pi=[0.4,0.4,0.2]$。\n  - 转移矩阵：\n    $$\n    T=\n    \\begin{bmatrix}\n    0.6  0.25  0.15\\\\\n    0.15  0.7  0.15\\\\\n    0.2  0.2  0.6\n    \\end{bmatrix}.\n    $$\n  - CPT数组：\n    $$\n    q_c=[2.0,1.2,1.4,5.0,8.0,12.5,15.0,13.5,11.0,9.0,6.0,5.5,4.5,3.5,2.5,2.0,1.8,1.6,1.4,1.2],\n    $$\n    $$\n    R_f=[0.04,0.05,0.045,0.035,0.02,0.012,0.009,0.011,0.013,0.015,0.025,0.028,0.03,0.032,0.035,0.04,0.042,0.045,0.05,0.055].\n    $$\n  - 蒙特卡洛模拟次数：$N_{\\mathrm{MC}}=5000$。\n  - 变形阈值：$\\delta_{\\mathrm{th}}=0.002$ 米。\n\n- 测试用例 $\\mathrm{B}$（砂土主导的CPT，高持续性转移概率）：\n  - 墙高：$H=12$ 米。\n  - 侧向压力：$p_e=40{,}000$ 帕斯卡。\n  - 初始分布：$\\pi=[0.2,0.7,0.1]$。\n  - 转移矩阵：\n    $$\n    T=\n    \\begin{bmatrix}\n    0.9  0.05  0.05\\\\\n    0.05  0.9  0.05\\\\\n    0.05  0.05  0.9\n    \\end{bmatrix}.\n    $$\n  - CPT数组：\n    $$\n    q_c=[9.0,10.5,12.0,14.0,16.0,18.0,20.0,18.0,16.0,14.0,12.0,10.0,9.0,8.0,7.0,7.5,8.5,9.5,10.5,11.5],\n    $$\n    $$\n    R_f=[0.012,0.011,0.010,0.009,0.009,0.008,0.008,0.009,0.009,0.010,0.011,0.012,0.013,0.014,0.015,0.014,0.013,0.012,0.011,0.010].\n    $$\n  - 蒙特卡洛模拟次数：$N_{\\mathrm{MC}}=3000$。\n  - 变形阈值：$\\delta_{\\mathrm{th}}=0.0015$ 米。\n\n- 测试用例 $\\mathrm{C}$（黏土主导的CPT，中等转移概率，小样本）：\n  - 墙高：$H=10$ 米。\n  - 侧向压力：$p_e=80{,}000$ 帕斯卡。\n  - 初始分布：$\\pi=[0.6,0.2,0.2]$。\n  - 转移矩阵：\n    $$\n    T=\n    \\begin{bmatrix}\n    0.7  0.15  0.15\\\\\n    0.3  0.4  0.3\\\\\n    0.25  0.2  0.55\n    \\end{bmatrix}.\n    $$\n  - CPT数组：\n    $$\n    q_c=[1.0,1.2,1.1,1.3,1.5,1.6,1.7,1.8,1.9,2.0,2.0,1.9,1.8,1.7,1.6,1.5,1.4,1.3,1.2,1.1],\n    $$\n    $$\n    R_f=[0.055,0.05,0.052,0.048,0.045,0.043,0.042,0.040,0.038,0.036,0.037,0.039,0.041,0.043,0.045,0.047,0.05,0.052,0.054,0.056].\n    $$\n  - 蒙特卡洛模拟次数：$N_{\\mathrm{MC}}=200$。\n  - 变形阈值：$\\delta_{\\mathrm{th}}=0.005$ 米。\n\n程序要求：\n- 使用固定的伪随机种子以确保可复现性。\n- 使用为 $s_1$ 和 $i\\geq 2$ 的 $s_i$ 定义的后验分类分布实现采样。\n- 在计算 $M_i$ 之前将 $q_c$ 从 $\\mathrm{MPa}$ 转换为 $\\mathrm{Pa}$；对每个测试用例使用 $\\Delta z=H/n$。\n- 对每个测试用例，报告超越概率 $\\mathbb{P}(\\delta>\\delta_{\\mathrm{th}})$，结果为小数点后保留5位有效数字的小数。\n- 最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_A,r_B,r_C]$），其中 $r_A,r_B,r_C$ 分别是测试用例 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$ 的超越概率。\n\n所有数值答案在适用时必须以国际单位制（SI）表示，变形单位为米，压力单位为帕斯卡。最终打印的行必须只包含带有小数点后5位小数的方括号列表。", "solution": "该问题要求构建一个蒙特卡洛模拟，以估计开挖支护墙的侧向变形超过给定阈值的概率。这是一个岩土工程可靠度分析问题，融合了随机过程、贝叶斯推断和土力学的概念。解决方案的结构是首先为每个组件定义理论模型，然后概述模拟的计算算法。\n\n### 理论框架\n\n该解决方案基于三个相互关联的模型：地层随机模型、墙土相互作用的岩土模型，以及从测量中推断土体类型的概率模型。\n\n**1. 随机地层：离散时间马尔可夫链**\n\n土体剖面被理想化为一系列离散的土层，每层属于三种状态之一，$S=\\{\\mathrm{SC}, \\mathrm{S}, \\mathrm{STC}\\}$，分别代表软黏土、砂土和硬黏土。随深度变化的土体状态序列 $s_1, s_2, \\dots, s_n$ 被建模为一阶离散时间马尔可夫链。该模型由两个部分表征：\n- 一个初始概率分布 $\\pi \\in \\mathbb{R}^3$，其中 $\\pi_a = \\mathbb{P}(s_1=a)$ 给出了第一层为土体类型 $a \\in S$ 的概率。\n- 一个转移矩阵 $T \\in \\mathbb{R}^{3 \\times 3}$，其中条目 $T_{ab} = \\mathbb{P}(s_i=b \\mid s_{i-1}=a)$ 是在一个深度步长内从状态 $a$ 转移到状态 $b$ 的概率。\n该模型遵循马尔可夫（柯尔莫哥洛夫）性质，意味着任何土层 $s_i$ 的状态仅依赖于其紧邻的上一层 $s_{i-1}$ 的状态，即 $\\mathbb{P}(s_i \\mid s_{i-1}, \\dots, s_1) = \\mathbb{P}(s_i \\mid s_{i-1})$。\n\n**2. 基于CPT数据的贝叶斯推断**\n\n通过将马尔可夫模型以原位静力触探试验（CPT）测量值为条件，可以降低地层的不确定性。在每个深度索引 $i$ 处，都有一个观测向量 $o_i = [q_{c,i}, R_{f,i}]$，由锥尖阻力 $q_{c,i}$ 和摩阻比 $R_{f,i}$ 组成。观测值 $o_i$ 与土体状态 $s_i$ 之间的联系由一个似然模型 $\\mathcal{L}(o_i \\mid s_i=a)$ 给出。该似然被建模为协方差矩阵为对角阵的二元高斯分布：\n$$\n\\mathcal{L}(o_i \\mid s_i=a) = \\mathcal{N}(o_{i,1} \\mid \\mu_{a,1}, \\sigma_{a,1}^2) \\cdot \\mathcal{N}(o_{i,2} \\mid \\mu_{a,2}, \\sigma_{a,2}^2) = \\prod_{j=1}^{2}\\frac{1}{\\sqrt{2\\pi}\\,\\sigma_{a,j}}\\exp\\!\\left(-\\frac{(o_{i,j}-\\mu_{a,j})^2}{2\\sigma_{a,j}^2}\\right)\n$$\n其中 $[\\mu_{a,1}, \\mu_{a,2}]$ 和 $[\\sigma_{a,1}, \\sigma_{a,2}]$ 是CPT测量值依赖于状态的均值和标准差。\n\n贝叶斯定理被用来更新每个深度的土体状态概率。这定义了条件模拟的采样分布：\n- 对于第一层 ($i=1$)，状态 $s_1=a$ 的后验概率与先验概率和似然的乘积成正比：\n$$\n\\mathbb{P}(s_1=a \\mid o_1) \\propto \\pi_a \\mathcal{L}(o_1 \\mid s_1=a)\n$$\n- 对于后续层 ($i \\ge 2$)，给定前一个采样的状态 $s_{i-1}=a$ 和当前观测值 $o_i$，状态 $s_i=b$ 的后验概率为：\n$$\n\\mathbb{P}(s_i=b \\mid s_{i-1}=a, o_i) \\propto T_{ab} \\mathcal{L}(o_i \\mid s_i=b)\n$$\n在每一步中，通过确保所有可能状态的概率之和为一来解决比例关系。\n\n**3. 岩土模型：温克勒地基与墙体变形**\n\n抵抗墙体运动的土体力学行为通过温克勒地基模型进行了简化。土体被表示为一系列独立的线性弹性弹簧，其地基反力系数为 $k(z)$，单位为力/单位面积/单位位移（$\\mathrm{N/m^3}$）。对于墙体的均匀侧向位移 $\\delta$，虚功原理（或简单的力平衡）规定，外压力所做的功必须等于储存在土弹簧中的能量。对于高度为 $H$ 的墙体上均匀的开挖诱导压力 $p_e$，这种平衡表示为：\n$$\np_e H = \\delta \\int_{0}^{H} k(z) \\, \\mathrm{d}z\n$$\n求解变形 $\\delta$ 可得：\n$$\n\\delta = \\frac{p_e H}{\\int_{0}^{H} k(z) \\, \\mathrm{d}z}\n$$\n该积分在 $n$ 个土层上进行离散化，每个土层厚度为 $\\Delta z = H/n$。假设每个土层 $i$ 内的地基反力系数 $k_i$ 是常数，则积分可用求和来近似：\n$$\n\\int_{0}^{H} k(z) \\, \\mathrm{d}z \\approx \\sum_{i=1}^{n} k_i \\Delta z\n$$\n给定土层的地基反力系数 $k_i$ 是通过一个标准的经验相关关系，根据其土体类型 $s_i=a$ 和CPT锥尖阻力 $q_{c,i}$ 来确定的。首先，约束模量 $M_i$ 估计为 $M_i = c_{M,a} q_{c,i}$，其中 $c_{M,a}$ 是一个无量纲因子。然后，$k_i$ 与 $M_i$ 通过 $k_i = \\beta_a M_i$ 相关联，其中 $\\beta_a$ 是一个单位为 $\\mathrm{m}^{-1}$ 的缩放因子。确保单位兼容至关重要；因此，以兆帕（$\\mathrm{MPa}$）为单位的 $q_{c,i}$ 必须通过乘以 $10^6$ 转换为帕斯卡（$\\mathrm{Pa}$，或 $\\mathrm{N/m^2}$）。\n\n### 蒙特卡洛模拟算法\n\n超越概率 $\\mathbb{P}(\\delta > \\delta_{\\mathrm{th}})$ 是使用蒙特卡洛模拟来估计的。该过程涉及生成大量随机但有条件的地层剖面，并为每个剖面计算产生的变形。\n\n对每个测试用例，总体算法流程如下：\n1.  **初始化**：设置模拟次数 $N_{\\mathrm{MC}}$，超越计数器为零，并定义所有模型参数（$H, p_e, \\pi, T, \\delta_{\\mathrm{th}}$ 等）。预先计算似然矩阵 $\\mathcal{L}_{ia} = \\mathcal{L}(o_i \\mid s_i=a)$，该矩阵对所有土层 $i=1,\\dots,n$ 和所有状态 $a \\in S$ 均适用。\n2.  **模拟循环**：重复 $k=1, \\dots, N_{\\mathrm{MC}}$ 次：\n    a.  **生成一个地层剖面**：\n        i.  对于土层 $i=1$：计算后验概率 $\\mathbb{P}(s_1=a \\mid o_1)$ 并从此分类分布中采样一个状态 $s_1$。\n        ii. 对于土层 $i=2, \\dots, n$：给定采样的状态 $s_{i-1}$，计算后验概率 $\\mathbb{P}(s_i=b \\mid s_{i-1}, o_i)$ 并采样一个状态 $s_i$。\n    b.  **计算墙体变形**：使用生成的地层剖面 $(s_1, \\dots, s_n)$ 和给定的 $q_c$ 数组，计算每层的地基反力系数 $k_i$。然后，使用离散化公式计算总墙体变形 $\\delta$：\n        $$\n        \\delta = \\frac{p_e H}{\\sum_{i=1}^{n} k_i \\Delta z} = \\frac{p_e n}{\\sum_{i=1}^{n} k_i}\n        $$\n    c.  **检查是否超越**：将计算出的变形 $\\delta$ 与阈值 $\\delta_{\\mathrm{th}}$ 进行比较。如果 $\\delta > \\delta_{\\mathrm{th}}$，则增加超越计数器。\n3.  **估计概率**：所有模拟完成后，超越概率估计为超越次数与总模拟次数的比值：\n    $$\n    \\mathbb{P}(\\delta > \\delta_{\\mathrm{th}}) \\approx \\frac{\\text{超越计数}}{\\text{N}_{\\mathrm{MC}}}\n    $$\n此过程应用于每个测试用例及其特定参数，以获得所需的概率。固定的随机种子确保了结果的可复现性。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run Monte Carlo simulations for all test cases and print the results.\n    \"\"\"\n    # Set a fixed seed for reproducibility of the Monte Carlo simulation.\n    np.random.seed(42)\n\n    # --- Fixed Parameters (common to all test cases) ---\n    # Map states to integer indices for array access\n    state_map = {'SC': 0, 'S': 1, 'STC': 2}\n    states = ['SC', 'S', 'STC']\n    n_states = len(states)\n\n    # Likelihood model parameters (mean and std. dev. for [qc, Rf])\n    # qc is in MPa, Rf is a decimal\n    means = np.array([\n        [1.5, 0.04],  # SC\n        [12.0, 0.01], # S\n        [6.0, 0.03]   # STC\n    ])\n    stds = np.array([\n        [0.5, 0.01],  # SC\n        [3.0, 0.004], # S\n        [1.5, 0.008]  # STC\n    ])\n    \n    # Subgrade reaction correlation constants\n    c_M = np.array([8.0, 5.0, 10.0])   # Dimensionless, for SC, S, STC\n    beta = np.array([0.2, 1.2, 0.6])  # Units of 1/m, for SC, S, STC\n\n    def calculate_likelihoods(qc, Rf, n_layers):\n        \"\"\"\n        Calculates the likelihood of observations for each layer and each state.\n        L_ia = P(o_i | s_i = a)\n        \"\"\"\n        likelihoods = np.zeros((n_layers, n_states))\n        observations = np.stack([qc, Rf], axis=1)\n        for i in range(n_layers):\n            for j in range(n_states):\n                # Likelihood is the product of two independent Gaussian PDFs\n                lik_qc = norm.pdf(observations[i, 0], loc=means[j, 0], scale=stds[j, 0])\n                lik_Rf = norm.pdf(observations[i, 1], loc=means[j, 1], scale=stds[j, 1])\n                likelihoods[i, j] = lik_qc * lik_Rf\n        return likelihoods\n\n    def sample_stratigraphy(pi, T, likelihoods, n_layers):\n        \"\"\"\n        Samples one realization of the stratigraphic profile conditioned on observations.\n        \"\"\"\n        stratigraphy = np.zeros(n_layers, dtype=int)\n        \n        # Layer 1 (i=0)\n        unnormalized_posterior_s1 = pi * likelihoods[0, :]\n        posterior_s1 = unnormalized_posterior_s1 / np.sum(unnormalized_posterior_s1)\n        stratigraphy[0] = np.random.choice(n_states, p=posterior_s1)\n\n        # Layers 2 to n (i=1 to n-1)\n        for i in range(1, n_layers):\n            prev_state = stratigraphy[i-1]\n            prior = T[prev_state, :]\n            unnormalized_posterior_si = prior * likelihoods[i, :]\n            # Handle case where all probabilities are zero to avoid NaN\n            if np.sum(unnormalized_posterior_si) == 0:\n                 # This can happen if an observation is extremely unlikely under all states.\n                 # A uniform distribution is a reasonable fallback.\n                 posterior_si = np.full(n_states, 1.0 / n_states)\n            else:\n                 posterior_si = unnormalized_posterior_si / np.sum(unnormalized_posterior_si)\n            \n            stratigraphy[i] = np.random.choice(n_states, p=posterior_si)\n        \n        return stratigraphy\n\n    def calculate_deflection(stratigraphy, qc, H, pe, n_layers):\n        \"\"\"\n        Calculates wall deflection for a given stratigraphy.\n        \"\"\"\n        # Convert qc from MPa to Pa\n        qc_pa = qc * 1e6\n        \n        # Calculate subgrade reaction coefficients k_i for each layer\n        # k_i = beta[s_i] * c_M[s_i] * qc_pa[i]\n        k_values = beta[stratigraphy] * c_M[stratigraphy] * qc_pa\n        \n        # Calculate deflection using the discretized formula: delta = (pe * n) / sum(k_i)\n        sum_k = np.sum(k_values)\n        if sum_k == 0:\n            return np.inf  # Avoid division by zero\n        \n        delta = (pe * n_layers) / sum_k\n        return delta\n\n\n    def run_monte_carlo(params):\n        \"\"\"\n        Runs the full Monte Carlo simulation for a single test case.\n        \"\"\"\n        H = params['H']\n        pe = params['pe']\n        pi = np.array(params['pi'])\n        T = np.array(params['T'])\n        qc = np.array(params['qc'])\n        Rf = np.array(params['Rf'])\n        N_MC = params['N_MC']\n        delta_th = params['delta_th']\n        n_layers = 20\n\n        # Pre-compute likelihoods as they are constant for all replications\n        likelihoods = calculate_likelihoods(qc, Rf, n_layers)\n\n        exceedance_count = 0\n        for _ in range(N_MC):\n            # 1. Sample a stratigraphic profile\n            stratigraphy = sample_stratigraphy(pi, T, likelihoods, n_layers)\n            \n            # 2. Calculate wall deflection\n            delta = calculate_deflection(stratigraphy, qc, H, pe, n_layers)\n            \n            # 3. Check for exceedance\n            if delta > delta_th:\n                exceedance_count += 1\n        \n        # 4. Estimate probability\n        probability = exceedance_count / N_MC\n        return probability\n\n    test_cases = [\n        {\n            'name': 'A',\n            'H': 10, 'pe': 50000,\n            'pi': [0.4, 0.4, 0.2],\n            'T': [[0.6, 0.25, 0.15], [0.15, 0.7, 0.15], [0.2, 0.2, 0.6]],\n            'qc': [2.0, 1.2, 1.4, 5.0, 8.0, 12.5, 15.0, 13.5, 11.0, 9.0, 6.0, 5.5, 4.5, 3.5, 2.5, 2.0, 1.8, 1.6, 1.4, 1.2],\n            'Rf': [0.04, 0.05, 0.045, 0.035, 0.02, 0.012, 0.009, 0.011, 0.013, 0.015, 0.025, 0.028, 0.03, 0.032, 0.035, 0.04, 0.042, 0.045, 0.05, 0.055],\n            'N_MC': 5000, 'delta_th': 0.002\n        },\n        {\n            'name': 'B',\n            'H': 12, 'pe': 40000,\n            'pi': [0.2, 0.7, 0.1],\n            'T': [[0.9, 0.05, 0.05], [0.05, 0.9, 0.05], [0.05, 0.05, 0.9]],\n            'qc': [9.0, 10.5, 12.0, 14.0, 16.0, 18.0, 20.0, 18.0, 16.0, 14.0, 12.0, 10.0, 9.0, 8.0, 7.0, 7.5, 8.5, 9.5, 10.5, 11.5],\n            'Rf': [0.012, 0.011, 0.010, 0.009, 0.009, 0.008, 0.008, 0.009, 0.009, 0.010, 0.011, 0.012, 0.013, 0.014, 0.015, 0.014, 0.013, 0.012, 0.011, 0.010],\n            'N_MC': 3000, 'delta_th': 0.0015\n        },\n        {\n            'name': 'C',\n            'H': 10, 'pe': 80000,\n            'pi': [0.6, 0.2, 0.2],\n            'T': [[0.7, 0.15, 0.15], [0.3, 0.4, 0.3], [0.25, 0.2, 0.55]],\n            'qc': [1.0, 1.2, 1.1, 1.3, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.0, 1.9, 1.8, 1.7, 1.6, 1.5, 1.4, 1.3, 1.2, 1.1],\n            'Rf': [0.055, 0.05, 0.052, 0.048, 0.045, 0.043, 0.042, 0.040, 0.038, 0.036, 0.037, 0.039, 0.041, 0.043, 0.045, 0.047, 0.05, 0.052, 0.054, 0.056],\n            'N_MC': 200, 'delta_th': 0.005\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        prob = run_monte_carlo(case)\n        results.append(f\"{prob:.5f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3544647"}, {"introduction": "最后一个练习将带您进入高级计算岩土力学的两个核心领域。首先，它介绍了一种复杂的空间点过程——内曼-斯科特过程（Neyman–Scott process），用于模拟如软弱夹层等聚集性地质特征，这些特征是简单模型难以捕捉的。其次，本练习超越了仅仅估计失效概率的范畴，引入了似然比法（likelihood-ratio method）来计算灵敏度，这能帮助我们回答关键的工程问题：哪些模型参数对系统安全性的影响最大？[@problem_id:3544703]。", "problem": "考虑一个三维域，其模型为一个无量纲单位下边长为 $A$ 的立方体，并配备周期性边界条件（一个三维环面）。软弱材料透镜体被模型化为由三维 Neyman–Scott 簇点过程（也称为泊松簇过程）生成的球形夹杂物。一个半径为 $r_{\\mathrm{t}}$、长度为 $L$ 的直圆形隧道位于域的中心，并沿 $z$ 轴对齐。\n\nNeyman–Scott 过程的构建如下。父代点由强度为 $\\lambda_{\\mathrm{p}}$（以每单位体积的期望父代点数衡量）的均匀泊松点过程生成。在给定父代点的条件下，每个父代点 $i$ 产生一个泊松分布的子代点数 $K_i$，其均值为 $\\mu_{\\mathrm{c}}$，且各父代点之间相互独立。每个子代点相对于其父代点的位置，会有一个独立同分布的三维高斯偏移，该偏移在每个坐标上的均值为零，标准差为 $\\sigma$。然后，使用周期性边界将子代点包裹到立方体域中。假设所有随机元素在给定参数下是相互独立的。\n\n每个子代点代表一个半径固定为 $r_{\\ell}$ 的球形软弱透镜体的中心。定义一个简单的稳定性指数 $S$ 为 $S = 1 - \\beta M$，其中 $M$ 是其球体与隧道实体相交的软弱透镜体数量，$\\beta$ 是一个无量纲的弱化因子。假设隧道占据了径向距离 $\\sqrt{x^2 + y^2} \\le r_{\\mathrm{t}}$ 且轴向坐标 $|z| \\le L/2$ 的点集；一个中心位于 $(x,y,z)$、半径为 $r_{\\ell}$ 的球形透镜体与隧道相交，当且仅当同时满足以下两个条件：$\\sqrt{x^2 + y^2} \\le r_{\\mathrm{t}} + r_{\\ell}$ 和 $|z| \\le L/2 + r_{\\ell}$。当且仅当 $S \\le 0$ 时，声明发生坍塌事件。\n\n您的任务是设计并实现一个蒙特卡洛模拟，以针对指定的参数集估计以下内容：\n- 坍塌概率 $P_{\\mathrm{col}}(\\lambda_{\\mathrm{p}}, \\mu_{\\mathrm{c}})$。\n- 坍塌概率相对于父代点强度的敏感度 $\\partial P_{\\mathrm{col}} / \\partial \\lambda_{\\mathrm{p}}$。\n- 坍塌概率相对于每个父代点的平均子代点数的敏感度 $\\partial P_{\\mathrm{col}} / \\partial \\mu_{\\mathrm{c}}$。\n\n您必须使用从 Neyman–Scott 过程的概率定律推导出的似然比（得分函数）方法。将高斯离散和空间包裹处理为不依赖于 $\\lambda_{\\mathrm{p}}$ 或 $\\mu_{\\mathrm{c}}$。使用周期性边界条件以避免边缘效应。所有量均为无量纲。在所有测试用例中使用相同的伪随机种子，以确保结果可复现。\n\n您可以使用的基础理论：\n- 在体积 $V$ 上的均匀泊松点过程中，点数 $N$ 服从均值为 $\\lambda V$ 的泊松分布，其对数似然贡献为 $N \\log(\\lambda V) - \\lambda V - \\log(N!)$。\n- 在给定父代点的条件下，每个父代点的独立泊松子代点计数的对数似然贡献为 $\\sum_{i=1}^{N_{\\mathrm{p}}} \\left( K_i \\log \\mu_{\\mathrm{c}} - \\mu_{\\mathrm{c}} - \\log (K_i!) \\right)$。\n- 对于似然比敏感度，对于参数 $\\theta$，$\\partial \\mathbb{E}[H]/\\partial \\theta = \\mathbb{E}\\left[H \\cdot \\partial \\log f(X;\\theta)/\\partial \\theta \\right]$，其中 $H$ 是任何可积泛函，$f$ 是采样密度。\n\n蒙特卡洛要求：\n- 实现一个模拟，每个测试用例包含固定数量的独立重复实验 $N_{\\mathrm{mc}}$。在每次重复实验中，生成 Neyman–Scott 过程在立方体域中的一个实现，计算坍塌指示符（坍塌时为 $1$，否则为 $0$），并计算从父代点和子代点计数的泊松分布推导出的关于 $\\lambda_{\\mathrm{p}}$ 和 $\\mu_{\\mathrm{c}}$ 的得分函数权重。进行适当的平均以估计概率及其两个敏感度。\n- 使用单个伪随机种子 $s$ 来初始化生成器。为了在保持可复现性的同时使测试用例多样化，您可以将测试用例索引添加到 $s$ 中。\n- 对子代点位置使用周期性边界包裹：对于每个坐标 $u \\in \\{x,y,z\\}$，包裹后的坐标是 $u_{\\mathrm{wrapped}} = \\left(\\left(u + A/2\\right) \\bmod A\\right) - A/2$。\n\n测试套件：\n使用 $N_{\\mathrm{mc}} = 5000$ 和公共种子 $s = 12345$。对于所有情况，域是边长 $A = 10$ 的立方体，因此体积为 $V = A^3$。隧道参数以原点为中心，轴线沿 $z$ 轴。\n\n提供四个参数集以测试不同情况：\n- 情况 1（中等聚集）：$\\lambda_{\\mathrm{p}} = 0.02$, $\\mu_{\\mathrm{c}} = 10$, $\\sigma = 0.3$, $r_{\\ell} = 0.2$, $r_{\\mathrm{t}} = 0.5$, $L = 8$, $\\beta = 0.5$。\n- 情况 2（稀疏聚集）：$\\lambda_{\\mathrm{p}} = 0.001$, $\\mu_{\\mathrm{c}} = 2$, $\\sigma = 0.4$, $r_{\\ell} = 0.2$, $r_{\\mathrm{t}} = 0.5$, $L = 8$, $\\beta = 0.5$。\n- 情况 3（密集聚集，紧密聚集）：$\\lambda_{\\mathrm{p}} = 0.02$, $\\mu_{\\mathrm{c}} = 30$, $\\sigma = 0.1$, $r_{\\ell} = 0.2$, $r_{\\mathrm{t}} = 0.5$, $L = 8$, $\\beta = 0.5$。\n- 情况 4（存在主导的破坏）：$\\lambda_{\\mathrm{p}} = 0.015$, $\\mu_{\\mathrm{c}} = 5$, $\\sigma = 0.25$, $r_{\\ell} = 0.25$, $r_{\\mathrm{t}} = 0.5$, $L = 8$, $\\beta = 1.0$。\n\n输出规范：\n- 对于每个测试用例，计算三个实数：坍塌概率的蒙特卡洛估计值，$\\partial P_{\\mathrm{col}}/\\partial \\lambda_{\\mathrm{p}}$ 的蒙特卡洛估计值，以及 $\\partial P_{\\mathrm{col}}/\\partial \\mu_{\\mathrm{c}}$ 的蒙特卡洛估计值。\n- 您的程序应生成单行输出，其中包含一个列表的列表，格式为逗号分隔。每个内部列表包含按上述顺序排列的三个浮点数，并用方括号括起来。例如，您的输出格式必须与此完全相同：\"[[p1,dpl1,dpm1],[p2,dpl2,dpm2],[p3,dpl3,dpm3],[p4,dpl4,dpm4]]\"，其中每个符号代表一个定义的浮点数。\n\n所有答案都是无量纲实数，您必须完全按照测试套件中给出的参数使用。不应读取任何其他输入。", "solution": "用户提供了一个在计算岩土力学领域中定义明确的问题，要求使用蒙特卡洛模拟来估计隧道坍塌概率及其敏感度。该问题具有科学依据，内容自洽，且算法上已明确指定。因此，该问题被认为是有效的。\n\n### I. 基于原理的解决方案设计\n\n核心任务是估计一个随机过程函数的期望，以及该期望关于过程的两个参数的敏感度。该随机过程是一个 Neyman-Scott 簇过程，用于模拟软弱材料透镜体的空间分布。该函数是一个隧道坍塌事件的指示函数。参数是父代点的强度 $\\lambda_{\\mathrm{p}}$ 和每个父代点的平均子代点数 $\\mu_{\\mathrm{c}}$。\n\n令 $X$ 代表 Neyman-Scott 过程的一次实现，包括所有生成的透镜体的数量和位置。令 $H(X)$ 为坍塌指示函数，其中如果发生坍塌 $H(X)=1$，否则 $H(X)=0$。坍塌概率为 $P_{\\mathrm{col}} = \\mathbb{E}[H(X)]$。问题要求计算此概率及其敏感度 $\\partial P_{\\mathrm{col}}/\\partial \\lambda_{\\mathrm{p}}$ 和 $\\partial P_{\\mathrm{col}}/\\partial \\mu_{\\mathrm{c}}$。\n\n似然比法（也称为得分函数法）是指定的技术。该方法利用了以下恒等式：对于参数 $\\theta$ 和一族概率分布 $f(x; \\theta)$，期望的导数可以表示为另一个期望：\n$$\n\\frac{\\partial}{\\partial \\theta} \\mathbb{E}[H(X)] = \\frac{\\partial}{\\partial \\theta} \\int H(x) f(x; \\theta) dx = \\int H(x) \\frac{\\partial f(x; \\theta)}{\\partial \\theta} dx\n$$\n假设正则性条件允许在积分号下进行微分，我们可以写成：\n$$\n\\int H(x) \\left( \\frac{1}{f(x; \\theta)} \\frac{\\partial f(x; \\theta)}{\\partial \\theta} \\right) f(x; \\theta) dx = \\int H(x) \\frac{\\partial \\log f(x; \\theta)}{\\partial \\theta} f(x; \\theta) dx = \\mathbb{E}\\left[H(X) \\frac{\\partial \\log f(X; \\theta)}{\\partial \\theta}\\right]\n$$\n项 $W_{\\theta}(X) = \\frac{\\partial \\log f(X; \\theta)}{\\partial \\theta}$ 被称为得分函数或似然比权重。\n\n### II. 得分函数的推导\n\n过程中依赖于参数 $\\lambda_{\\mathrm{p}}$ 和 $\\mu_{\\mathrm{c}}$ 的随机元素是父代点和子代点的数量。\n1.  在体积为 $V=A^3$ 的域中，父代点的数量 $N_{\\mathrm{p}}$ 服从均值为 $\\lambda_{\\mathrm{p}} V$ 的泊松分布。其概率质量函数为 $P(N_{\\mathrm{p}}=n) = \\frac{(\\lambda_{\\mathrm{p}}V)^n e^{-\\lambda_{\\mathrm{p}}V}}{n!}$。\n2.  给定 $N_{\\mathrm{p}}$，每个父代点 $i=1, \\dots, N_{\\mathrm{p}}$ 的子代点数量 $K_i$ 均独立地服从均值为 $\\mu_{\\mathrm{c}}$ 的泊松分布。其概率质量函数为 $P(K_i=k) = \\frac{\\mu_{\\mathrm{c}}^k e^{-\\mu_{\\mathrm{c}}}}{k!}$。\n\n计数 $(N_{\\mathrm{p}}, K_1, \\dots, K_{N_{\\mathrm{p}}})$ 的联合对数似然是各个过程对数似然之和：\n$$\n\\mathcal{L} = \\log P(N_{\\mathrm{p}}) + \\sum_{i=1}^{N_{\\mathrm{p}}} \\log P(K_i)\n$$\n使用泊松对数似然的标准形式 $\\log P(k|\\lambda) = k \\log \\lambda - \\lambda - \\log(k!)$，我们有：\n$$\n\\mathcal{L}(\\lambda_{\\mathrm{p}}, \\mu_{\\mathrm{c}}) = (N_{\\mathrm{p}} \\log(\\lambda_{\\mathrm{p}} V) - \\lambda_{\\mathrm{p}} V - \\log(N_{\\mathrm{p}}!)) + \\sum_{i=1}^{N_{\\mathrm{p}}} (K_i \\log \\mu_{\\mathrm{c}} - \\mu_{\\mathrm{c}} - \\log(K_i!))\n$$\n问题指明其他随机元素（位置）不依赖于 $\\lambda_{\\mathrm{p}}$ 或 $\\mu_{\\mathrm{c}}$，因此它们的似然项对关于这些参数的导数没有贡献。\n\n关于 $\\lambda_{\\mathrm{p}}$ 的得分函数是 $\\mathcal{L}$ 对 $\\lambda_{\\mathrm{p}}$ 的偏导数：\n$$\nW_{\\lambda_{\\mathrm{p}}} = \\frac{\\partial \\mathcal{L}}{\\partial \\lambda_{\\mathrm{p}}} = \\frac{\\partial}{\\partial \\lambda_{\\mathrm{p}}} (N_{\\mathrm{p}} \\log \\lambda_{\\mathrm{p}} + N_{\\mathrm{p}} \\log V - \\lambda_{\\mathrm{p}} V) = \\frac{N_{\\mathrm{p}}}{\\lambda_{\\mathrm{p}}} - V\n$$\n关于 $\\mu_{\\mathrm{c}}$ 的得分函数是 $\\mathcal{L}$ 对 $\\mu_{\\mathrm{c}}$ 的偏导数：\n$$\nW_{\\mu_{\\mathrm{c}}} = \\frac{\\partial \\mathcal{L}}{\\partial \\mu_{\\mathrm{c}}} = \\frac{\\partial}{\\partial \\mu_{\\mathrm{c}}} \\left( \\log \\mu_{\\mathrm{c}} \\sum_{i=1}^{N_{\\mathrm{p}}} K_i - N_{\\mathrm{p}} \\mu_{\\mathrm{c}} \\right) = \\frac{1}{\\mu_{\\mathrm{c}}} \\sum_{i=1}^{N_{\\mathrm{p}}} K_i - N_{\\mathrm{p}}\n$$\n令 $M_{\\mathrm{total}} = \\sum_{i=1}^{N_{\\mathrm{p}}} K_i$ 为生成的子代点（透镜体）总数。得分函数简化为 $W_{\\mu_{\\mathrm{c}}} = \\frac{M_{\\mathrm{total}}}{\\mu_{\\mathrm{c}}} - N_{\\mathrm{p}}$。\n\n### III. 蒙特卡洛估计量\n\n使用具有 $N_{\\mathrm{mc}}$ 次独立重复实验的蒙特卡洛模拟，我们生成样本 $(X_j)_{j=1}^{N_{\\mathrm{mc}}}$。对于每次重复实验 $j$，我们计算坍塌指示符 $H_j = H(X_j)$ 和得分函数 $W_{\\lambda_{\\mathrm{p}}, j}$ 和 $W_{\\mu_{\\mathrm{c}}, j}$。所需量的估计量是样本均值：\n- 坍塌概率：$\\hat{P}_{\\mathrm{col}} = \\frac{1}{N_{\\mathrm{mc}}} \\sum_{j=1}^{N_{\\mathrm{mc}}} H_j$\n- 对 $\\lambda_{\\mathrm{p}}$ 的敏感度：$\\frac{\\widehat{\\partial P_{\\mathrm{col}}}}{\\partial \\lambda_{\\mathrm{p}}} = \\frac{1}{N_{\\mathrm{mc}}} \\sum_{j=1}^{N_{\\mathrm{mc}}} H_j \\cdot W_{\\lambda_{\\mathrm{p}}, j}$\n- 对 $\\mu_{\\mathrm{c}}$ 的敏感度：$\\frac{\\widehat{\\partial P_{\\mathrm{col}}}}{\\partial \\mu_{\\mathrm{c}}} = \\frac{1}{N_{\\mathrm{mc}}} \\sum_{j=1}^{N_{\\mathrm{mc}}} H_j \\cdot W_{\\mu_{\\mathrm{c}}, j}$\n\n### IV. 单次重复实验的算法\n\n对于给定的参数集 $(\\lambda_{\\mathrm{p}}, \\mu_{\\mathrm{c}}, \\sigma, r_{\\ell}, r_{\\mathrm{t}}, L, \\beta)$ 和域边长 $A$，一次蒙特卡洛重复实验按以下步骤进行：\n\n1.  **生成父代点**：从均值为 $\\lambda_{\\mathrm{p}} V$（其中 $V = A^3$）的泊松分布中抽取父代点数量 $N_{\\mathrm{p}}$。如果 $N_{\\mathrm{p}} > 0$，则在立方体 $[-A/2, A/2]^3$ 中均匀生成它们的位置。\n\n2.  **生成子代点**：如果 $N_{\\mathrm{p}} > 0$，则为每个父代点从均值为 $\\mu_{\\mathrm{c}}$ 的泊松分布中抽取子代点数量 $(K_i)_{i=1}^{N_{\\mathrm{p}}}$。计算子代点总数 $M_{\\mathrm{total}} = \\sum_{i=1}^{N_{\\mathrmp}} K_i$。\n\n3.  **定位子代点**：如果 $M_{\\mathrm{total}} > 0$：\n    a. 对于 $M_{\\mathrm{total}}$ 个子代点中的每一个，确定其父代点的位置。\n    b. 通过从均值为 $0$、标准差为 $\\sigma$ 的正态分布中抽取三个独立的样本，生成一个三维位移向量。\n    c. 将位移加到父代点的位置上，得到未包裹的子代点位置 $(x,y,z)$。\n    d. 使用公式 $u_{\\mathrm{wrapped}} = ((u + A/2) \\pmod A) - A/2$ 对每个坐标 $u \\in \\{x,y,z\\}$ 应用周期性边界条件，将位置带入域 $[-A/2, A/2]^3$ 内。\n\n4.  **计算相交数量**：计算其中心 $(x_k, y_k, z_k)$ 满足与隧道相交条件的子代点（透镜体）数量 $M$：$\\sqrt{x_k^2 + y_k^2} \\le r_{\\mathrm{t}} + r_{\\ell}$ 且 $|z_k| \\le L/2 + r_{\\ell}$。\n\n5.  **检查是否坍塌**：如果稳定性指数 $S = 1 - \\beta M \\le 0$（等价于 $M \\ge 1/\\beta$），则发生坍塌。如果发生坍塌，设置坍塌指示符 $H=1$，否则 $H=0$。\n\n6.  **计算得分**：计算此次重复实验的得分函数值：\n    - $W_{\\lambda_{\\mathrm{p}}} = N_{\\mathrm{p}}/\\lambda_{\\mathrm{p}} - V$\n    - $W_{\\mu_{\\mathrm{c}}} = M_{\\mathrm{total}}/\\mu_{\\mathrm{c}} - N_{\\mathrm{p}}$\n\n7.  **存储结果**：此次重复实验的值为 $H$，$H \\cdot W_{\\lambda_{\\mathrm{p}}}$ 和 $H \\cdot W_{\\mu_{\\mathrm{c}}}$。然后将这些值加到运行总和中，在所有 $N_{\\mathrm{mc}}$ 次重复实验完成后进行平均。请注意，如果 $H=0$，则对敏感度估计量的贡献为零，这简化了计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Monte Carlo simulation to estimate tunnel collapse probability\n    and its sensitivities using the likelihood-ratio method.\n    \"\"\"\n\n    def run_simulation(case_params, n_mc, seed):\n        \"\"\"\n        Runs the Monte Carlo simulation for a single test case.\n        \"\"\"\n        # Unpack parameters\n        lambda_p, mu_c, sigma, r_l, r_t, L, beta = case_params\n        A = 10.0\n        V = A**3\n        \n        # Initialize random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Accumulators for estimates\n        sum_H = 0.0\n        sum_H_W_lp = 0.0\n        sum_H_W_mc = 0.0\n        \n        # Collapse condition threshold\n        M_collapse_threshold = 1.0 / beta\n\n        # Intersection geometry thresholds\n        radial_threshold_sq = (r_t + r_l)**2\n        axial_threshold = L / 2.0 + r_l\n\n        for _ in range(n_mc):\n            # Step 1: Generate Parents\n            Np = rng.poisson(lambda_p * V)\n            \n            if Np == 0:\n                # No parents means no offspring, no collapse.\n                # H is 0. W_lp is -V, W_mc is 0.\n                # H*W is 0. No need to update sums.\n                continue\n            \n            # locations are uniform in [-A/2, A/2]^3\n            parent_locs = rng.uniform(-A/2, A/2, size=(Np, 3))\n\n            # Step 2: Generate Offspring counts\n            # K_i for each parent\n            K_counts = rng.poisson(mu_c, size=Np)\n            M_total = np.sum(K_counts)\n\n            if M_total == 0:\n                # No offspring, no collapse.\n                # H is 0. W_lp_j is Np/lambda_p - V, W_mc_j is 0 - Np.\n                # H*W is 0. No need to update sums.\n                continue\n\n            # Step 3: Position Offspring\n            # Create an index to map each offspring to its parent\n            parent_indices = np.repeat(np.arange(Np), K_counts)\n            \n            # Get parent locations for all offspring\n            offspring_parent_locs = parent_locs[parent_indices]\n            \n            # Generate all displacements at once\n            displacements = rng.normal(0, sigma, size=(M_total, 3))\n            \n            # Calculate unwrapped offspring locations\n            offspring_locs_unwrapped = offspring_parent_locs + displacements\n            \n            # Apply periodic boundary wrapping\n            offspring_locs = ((offspring_locs_unwrapped + A/2) % A) - A/2\n\n            # Step 4: Count Intersections\n            x, y, z = offspring_locs[:, 0], offspring_locs[:, 1], offspring_locs[:, 2]\n            \n            radial_dist_sq = x**2 + y**2\n            axial_dist_abs = np.abs(z)\n\n            # Boolean mask for intersecting lenses\n            intersect_mask = (radial_dist_sq <= radial_threshold_sq) & (axial_dist_abs <= axial_threshold)\n            \n            M = np.sum(intersect_mask)\n\n            # Step 5: Check for Collapse\n            H = 1.0 if M >= M_collapse_threshold else 0.0\n\n            # Step 6  7: Calculate Scores and Update Accumulators\n            if H > 0: # Only need to calculate scores if collapse occurs\n                sum_H += H # which is just 1.0\n\n                W_lp = Np / lambda_p - V\n                W_mc = M_total / mu_c - Np\n\n                sum_H_W_lp += W_lp # H is 1\n                sum_H_W_mc += W_mc # H is 1\n        \n        # Calculate final estimates by averaging\n        p_col = sum_H / n_mc\n        dp_dlambda_p = sum_H_W_lp / n_mc\n        dp_dmu_c = sum_H_W_mc / n_mc\n\n        return [p_col, dp_dlambda_p, dp_dmu_c]\n\n    # Global simulation parameters\n    N_mc = 5000\n    common_seed = 12345\n    \n    # Test cases as defined in the problem\n    test_cases = [\n        # (lambda_p, mu_c, sigma, r_l, r_t, L, beta)\n        (0.02, 10, 0.3, 0.2, 0.5, 8, 0.5),    # Case 1\n        (0.001, 2, 0.4, 0.2, 0.5, 8, 0.5),   # Case 2\n        (0.02, 30, 0.1, 0.2, 0.5, 8, 0.5),    # Case 3\n        (0.015, 5, 0.25, 0.25, 0.5, 8, 1.0) # Case 4\n    ]\n\n    all_results = []\n    for i, case in enumerate(test_cases):\n        # Diversify seed per test case for independent-like sample paths\n        case_seed = common_seed + i\n        result = run_simulation(case, N_mc, case_seed)\n        all_results.append(result)\n    \n    # Format the output string exactly as specified\n    output_str = \"[\" + \",\".join([f\"[{p},{dpl},{dpm}]\" for p, dpl, dpm in all_results]) + \"]\"\n\n    print(output_str)\n\nsolve()\n```", "id": "3544703"}]}