{"hands_on_practices": [{"introduction": "在岩土力学中，我们经常需要从充满噪声的测量数据中估计材料参数。本练习将引导您完成一个基础但至关重要的任务：当先验知识和测量误差均可由高斯分布描述时，如何从第一性原理出发，通过解析推导得到参数的后验分布。以估算岩石的杨氏模量 $E$ 为例 [@problem_id:3502888]，您将通过完成“配方法”这一经典步骤，亲手揭示贝叶斯更新在高斯模型下的简洁与优雅，并为更复杂的计算分析打下坚实的数学基础。", "problem": "一个来自均质砂岩地层的圆柱状岩心在小应变条件下进行单轴压缩测试。测试的重点是推断杨氏模量，记为 $E$，假定其在试样尺度上是空间均匀的。关于 $E$ 的先验信念被建模为高斯随机变量 $E \\sim \\mathcal{N}(\\mu_{0}, \\sigma_{0}^{2})$，其中 $\\mu_{0}$ 和 $\\sigma_{0}^{2}$ 是已知常数，反映了来自更广泛地层研究的先验校准结果。在测试过程中，从应力-应变曲线的线性段计算出重复的局部割线刚度估计值 $\\{y_{i}\\}_{i=1}^{n}$。由于仪器噪声和分段尺度上的微观结构变异性，每个 $y_{i}$ 被建模为关于真实 $E$ 的独立同分布 (i.i.d.) 高斯观测值，其测量方差 $\\sigma^{2}$ 已知，即 $y_{i} \\mid E \\sim \\mathcal{N}(E, \\sigma^{2})$，且对于 $i=1,\\dots,n$ 相互独立。假设 $\\sigma^{2}$ 从先前的传感器校准中已知，并且高斯先验在 $E$ 的可行值范围内是一个合适的近似，因此其在负值上的小概率质量对于物理诠释而言可以忽略不计。\n\n从贝叶斯定理和高斯概率密度函数的定义出发，并且仅使用 $\\{y_{i}\\}_{i=1}^{n}$ 的独立性以及所述的随机假设，推导出完全归一化的后验密度 $p(E \\mid y_{1},\\dots,y_{n})$，其应为 $E$, $\\mu_{0}$, $\\sigma_{0}^{2}$, $\\sigma^{2}$, $n$ 和数据 $\\{y_{i}\\}_{i=1}^{n}$ 的显式函数。你的推导过程必须通过显式地构建先验密度和似然函数的乘积，合并关于 $E$ 的项，并在指数部分进行配方以揭示其高斯形式，而不能借助于任何预先记忆的共轭公式。\n\n将你的最终结果表示为后验密度 $p(E \\mid y_{1},\\dots,y_{n})$ 的单一闭式解析表达式，该表达式相对于 $E$ 是完全归一化的。不需要进行数值计算，也不应进行任何四舍五入。", "solution": "该问题要求在给定一组 $n$ 个独立测量值 $\\{y_{i}\\}_{i=1}^{n}$ 的情况下，推导杨氏模量 $E$ 的后验概率密度函数 $p(E \\mid y_{1},\\dots,y_{n})$。推导必须从第一性原理出发，使用贝叶斯定理、指定的先验和似然分布，并通过对所得表达式的指数部分进行配方来完成。\n\n首先，我们必须验证问题陈述。\n\n**步骤1：提取已知条件**\n- 关注的参数：杨氏模量，$E$。\n- $E$ 的先验分布：$p(E) = \\mathcal{N}(E \\mid \\mu_{0}, \\sigma_{0}^{2})$，其中 $\\mu_{0}$ 和 $\\sigma_{0}^{2}$ 是已知常数。\n- 数据：一组 $n$ 个测量值，$\\{y_{i}\\}_{i=1}^{n}$。\n- 似然函数（给定参数下的数据分布）：每个测量值 $y_i$ 都是条件独立的，并且从高斯分布中抽取，$y_{i} \\mid E \\sim \\mathcal{N}(E, \\sigma^{2})$，对于 $i=1,\\dots,n$。测量方差 $\\sigma^{2}$ 已知。\n- 假设：高斯先验在 $E$ 负值上的概率质量可以忽略不计。\n- 任务：通过显式构建先验和似然的乘积并进行配方，推导完全归一化的后验密度 $p(E \\mid y_{1},\\dots,y_{n})$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，它为一个从含噪声数据中进行参数估计的标准工程任务建模。在贝叶斯统计中，对先验和似然均使用高斯分布是一种常用且合理的方法，特别是对于那些中心趋势和对称不确定性是合理近似的物理参数。该问题是适定的，提供了推导唯一后验分布所需的所有必要信息（先验、似然、独立性假设）。语言客观而精确。该问题满足所有有效性标准；它并非不健全、不完整、不切实际或不适定。\n\n**步骤3：结论与行动**\n问题是有效的。我们将继续进行推导。\n\n推导从贝叶斯定理开始，该定理指出后验概率密度与似然函数和先验概率密度的乘积成正比：\n$$p(E \\mid y_{1},\\dots,y_{n}) \\propto p(y_{1},\\dots,y_{n} \\mid E) p(E)$$\n\n$E$ 的先验分布为高斯分布：\n$$p(E) = \\frac{1}{\\sqrt{2\\pi\\sigma_{0}^{2}}} \\exp\\left(-\\frac{(E - \\mu_{0})^2}{2\\sigma_{0}^{2}}\\right)$$\n\n在给定 $E$ 的条件下，测量值 $\\{y_{i}\\}_{i=1}^{n}$ 是独立同分布的。因此，似然函数是每个测量值的单个概率的乘积：\n$$p(y_{1},\\dots,y_{n} \\mid E) = \\prod_{i=1}^{n} p(y_{i} \\mid E)$$\n每个测量值 $y_{i}$ 均从以 $E$ 为中心、方差为 $\\sigma^{2}$ 的高斯分布中抽取：\n$$p(y_{i} \\mid E) = \\frac{1}{\\sqrt{2\\pi\\sigma^{2}}} \\exp\\left(-\\frac{(y_{i} - E)^2}{2\\sigma^{2}}\\right)$$\n将此代入乘积中，得到完整的似然函数：\n$$p(y_{1},\\dots,y_{n} \\mid E) = \\prod_{i=1}^{n} \\left[ \\frac{1}{\\sqrt{2\\pi\\sigma^{2}}} \\exp\\left(-\\frac{(y_{i} - E)^2}{2\\sigma^{2}}\\right) \\right] = \\left(\\frac{1}{\\sqrt{2\\pi\\sigma^{2}}}\\right)^{n} \\exp\\left(-\\sum_{i=1}^{n} \\frac{(y_{i} - E)^2}{2\\sigma^{2}}\\right)$$\n\n现在，我们通过将先验与似然相乘来构成未归一化的后验。我们可以暂时忽略常数归一化因子，而专注于指数项，因为它们包含了对 $E$ 的依赖关系。\n$$p(E \\mid y_{1},\\dots,y_{n}) \\propto \\exp\\left(-\\frac{(E - \\mu_{0})^2}{2\\sigma_{0}^{2}}\\right) \\exp\\left(-\\sum_{i=1}^{n} \\frac{(y_{i} - E)^2}{2\\sigma^{2}}\\right)$$\n$$p(E \\mid y_{1},\\dots,y_{n}) \\propto \\exp\\left(-\\frac{(E - \\mu_{0})^2}{2\\sigma_{0}^{2}} - \\frac{1}{2\\sigma^{2}}\\sum_{i=1}^{n} (y_{i} - E)^2 \\right)$$\n\n我们来分析指数函数的参数，记为 $Q(E)$：\n$$Q(E) = -\\frac{1}{2} \\left[ \\frac{(E - \\mu_{0})^2}{\\sigma_{0}^{2}} + \\frac{1}{\\sigma^{2}}\\sum_{i=1}^{n} (y_{i} - E)^2 \\right]$$\n为了确定后验分布的形式，我们展开关于 $E$ 的二次项：\n$$(E - \\mu_{0})^2 = E^2 - 2E\\mu_{0} + \\mu_{0}^2$$\n$$\\sum_{i=1}^{n} (y_{i} - E)^2 = \\sum_{i=1}^{n} (E^2 - 2Ey_{i} + y_{i}^2) = nE^2 - 2E\\sum_{i=1}^{n}y_{i} + \\sum_{i=1}^{n}y_{i}^2$$\n将这些代回 $Q(E)$ 的表达式中，并按 $E$ 的幂次对各项进行分组：\n$$Q(E) = -\\frac{1}{2} \\left[ \\frac{E^2 - 2E\\mu_{0} + \\mu_{0}^2}{\\sigma_{0}^{2}} + \\frac{nE^2 - 2E\\sum_{i=1}^{n}y_{i} + \\sum_{i=1}^{n}y_{i}^2}{\\sigma^{2}} \\right]$$\n$$Q(E) = -\\frac{1}{2} \\left[ E^2\\left(\\frac{1}{\\sigma_{0}^{2}} + \\frac{n}{\\sigma^{2}}\\right) - 2E\\left(\\frac{\\mu_{0}}{\\sigma_{0}^{2}} + \\frac{\\sum_{i=1}^{n}y_{i}}{\\sigma^{2}}\\right) + \\left(\\frac{\\mu_{0}^2}{\\sigma_{0}^{2}} + \\frac{\\sum_{i=1}^{n}y_{i}^2}{\\sigma^{2}}\\right) \\right]$$\n\n括号内的表达式是 $E$ 的一个二次函数。这意味着后验分布也是高斯分布。一个通用的未归一化高斯形式是 $\\exp(-\\frac{1}{2\\sigma_n^2}(E - \\mu_n)^2)$。我们继续进行配方，以求得后验均值 $\\mu_n$ 和方差 $\\sigma_n^2$。\n\n令 $E^2$ 的系数为 $\\frac{1}{\\sigma_n^2}$：\n$$\\frac{1}{\\sigma_n^2} = \\frac{1}{\\sigma_{0}^{2}} + \\frac{n}{\\sigma^{2}}$$\n这就定义了后验方差 $\\sigma_n^2$。\n令 $-2E$ 的系数为 $\\frac{\\mu_n}{\\sigma_n^2}$：\n$$\\frac{\\mu_n}{\\sigma_n^2} = \\frac{\\mu_{0}}{\\sigma_{0}^{2}} + \\frac{\\sum_{i=1}^{n}y_{i}}{\\sigma^{2}}$$\n这就定义了后验均值 $\\mu_n$。\n\n使用这些定义，我们可以重写 $Q(E)$：\n$$Q(E) = -\\frac{1}{2} \\left[ \\frac{1}{\\sigma_n^2}E^2 - 2\\frac{\\mu_n}{\\sigma_n^2}E + C \\right]$$\n其中 $C$ 代表不依赖于 $E$ 的项。\n对包含 $E$ 的项进行配方：\n$$\\frac{1}{\\sigma_n^2}E^2 - 2\\frac{\\mu_n}{\\sigma_n^2}E = \\frac{1}{\\sigma_n^2}(E^2 - 2\\mu_n E) = \\frac{1}{\\sigma_n^2}( (E - \\mu_n)^2 - \\mu_n^2 )$$\n所以，\n$$Q(E) = -\\frac{1}{2} \\left[ \\frac{(E - \\mu_n)^2}{\\sigma_n^2} - \\frac{\\mu_n^2}{\\sigma_n^2} + C \\right] = -\\frac{(E - \\mu_n)^2}{2\\sigma_n^2} + \\text{constant}$$\n不依赖于 $E$ 的项被吸收到后验密度的归一化常数中。\n因此，后验分布与一个高斯核成正比：\n$$p(E \\mid y_{1},\\dots,y_{n}) \\propto \\exp\\left( -\\frac{(E - \\mu_n)^2}{2\\sigma_n^2} \\right)$$\n这证实了后验分布是一个高斯分布，即 $p(E \\mid y_{1},\\dots,y_{n}) = \\mathcal{N}(E \\mid \\mu_n, \\sigma_n^2)$。\n归一化后的后验密度为：\n$$p(E \\mid y_{1},\\dots,y_{n}) = \\frac{1}{\\sqrt{2\\pi\\sigma_n^2}}\\exp\\left( -\\frac{(E - \\mu_n)^2}{2\\sigma_n^2} \\right)$$\n\n我们现在用给定的量显式地写出参数 $\\mu_n$ 和 $\\sigma_n^2$。\n后验方差 $\\sigma_n^2$ 是后验精度的倒数：\n$$\\sigma_n^2 = \\left( \\frac{1}{\\sigma_{0}^{2}} + \\frac{n}{\\sigma^{2}} \\right)^{-1} = \\frac{\\sigma_{0}^{2}\\sigma^{2}}{\\sigma^{2} + n\\sigma_{0}^{2}}$$\n后验均值 $\\mu_n$ 为：\n$$\\mu_n = \\sigma_n^2 \\left( \\frac{\\mu_{0}}{\\sigma_{0}^{2}} + \\frac{\\sum_{i=1}^{n}y_{i}}{\\sigma^{2}} \\right) = \\frac{\\sigma_{0}^{2}\\sigma^{2}}{\\sigma^{2} + n\\sigma_{0}^{2}} \\left( \\frac{\\mu_{0}\\sigma^{2} + \\sigma_{0}^{2}\\sum_{i=1}^{n}y_{i}}{\\sigma_{0}^{2}\\sigma^{2}} \\right) = \\frac{\\mu_{0}\\sigma^{2} + \\sigma_{0}^{2}\\sum_{i=1}^{n}y_{i}}{\\sigma^{2} + n\\sigma_{0}^{2}}$$\n\n将这些 $\\mu_n$ 和 $\\sigma_n^2$ 的表达式代回归一化的高斯概率密度函数（PDF）中，即可得到最终结果。为了更紧凑地表示，我们可以用后验精度 $\\frac{1}{\\sigma_n^2} = \\frac{1}{\\sigma_0^2} + \\frac{n}{\\sigma^2}$ 和 $\\mu_n$ 的表达式来表示最终答案。\n\n后验密度的最终表达式为：\n$$p(E \\mid y_{1},\\dots,y_{n}) = \\frac{1}{\\sqrt{2\\pi \\left(\\frac{\\sigma_0^2 \\sigma^2}{\\sigma^2 + n\\sigma_0^2}\\right)}} \\exp\\left( -\\frac{\\left(E - \\frac{\\mu_0\\sigma^2 + \\sigma_0^2\\sum_{i=1}^{n}y_i}{\\sigma^2 + n\\sigma_0^2}\\right)^2}{2 \\left(\\frac{\\sigma_0^2 \\sigma^2}{\\sigma^2 + n\\sigma_0^2}\\right)} \\right)$$\n这可以通过将方差的分母移到指数前因子和指数中来重写：\n$$p(E \\mid y_{1},\\dots,y_{n}) = \\sqrt{\\frac{\\sigma^2 + n\\sigma_0^2}{2\\pi \\sigma_0^2 \\sigma^2}} \\exp\\left( -\\frac{\\sigma^2 + n\\sigma_0^2}{2\\sigma_0^2 \\sigma^2}\\left(E - \\frac{\\mu_0\\sigma^2 + \\sigma_0^2\\sum_{i=1}^{n}y_i}{\\sigma^2 + n\\sigma_0^2}\\right)^2 \\right)$$", "answer": "$$\n\\boxed{\n\\sqrt{\\frac{1}{2\\pi}\\left(\\frac{1}{\\sigma_{0}^{2}} + \\frac{n}{\\sigma^{2}}\\right)} \\exp\\left( -\\frac{1}{2}\\left(\\frac{1}{\\sigma_{0}^{2}} + \\frac{n}{\\sigma^{2}}\\right) \\left(E - \\frac{\\frac{\\mu_{0}}{\\sigma_{0}^{2}} + \\frac{1}{\\sigma^{2}}\\sum_{i=1}^{n}y_{i}}{\\frac{1}{\\sigma_{0}^{2}} + \\frac{n}{\\sigma^{2}}}\\right)^{2} \\right)\n}\n$$", "id": "3502888"}, {"introduction": "在掌握了如何推导后验分布之后，一个关键的实践问题随之而来：“我的先验信念对最终结论有多大影响？”本练习 [@problem_id:3502949] 建立在前一个练习的高斯模型之上，要求您通过编程进行一次系统的灵敏度分析。您将探索在不同质量（从模糊到确信）的先验知识和不同数量的数据下，杨氏模量 $E$ 的后验估计会如何变化，从而直观地理解后验分布是作为先验信念与数据证据之间动态平衡的结果。", "problem": "为在计算岩土力学模拟中使用，对一个沉积岩试样进行了一系列单轴压缩试验，以估算其杨氏模量 $E$（单位：$\\mathrm{GPa}$）。在线性弹性范围内的测量方案产生了 $n$ 个独立的比值 $y_i = \\sigma_i / \\varepsilon_i$，这些比值作为真实模量 $E$ 的带噪声的观测值，其中 $\\sigma_i$ 是轴向应力，$\\varepsilon_i$ 是轴向应变。仪器和校准报告指明了一个近似高斯测量误差模型：给定真实模量 $E$ 的条件下，每个观测值 $y_i$ 的条件分布为 $y_i \\mid E \\sim \\mathcal{N}(E,\\sigma^2)$，其中方差 $\\sigma^2$（单位：$\\mathrm{GPa}^2$）已知。$E$ 的先验分布被设为高斯分布 $E \\sim \\mathcal{N}(\\mu_0,\\sigma_0^2)$，其中 $(\\mu_0,\\sigma_0)$ 是编码了关于 $E$ 的先验信念的超参数。\n\n从贝叶斯定理以及高斯似然和高斯先验的定义出发，推导一个算法以实现以下目标：\n- 在上述高斯-高斯模型下，根据观测值 $\\{y_i\\}_{i=1}^n$ 和超参数 $(\\mu_0,\\sigma_0)$ 计算 $E$ 的后验分布。\n- 计算 $E$ 的后验均值（单位：$\\mathrm{GPa}$）以及后验均值相对于先验超参数 $(\\mu_0,\\sigma_0)$ 的局部敏感度，该敏感度定义为偏导数 $\\partial \\mathbb{E}[E \\mid \\{y_i\\}] / \\partial \\mu_0$ 和 $\\partial \\mathbb{E}[E \\mid \\{y_i\\}] / \\partial \\sigma_0$。这些导数是无量纲的。\n\n使用以下数据集和测量方差作为似然函数：\n- 观测值（单位：$\\mathrm{GPa}$）：$y = [\\,24.8,\\,25.1,\\,25.5,\\,24.9,\\,25.0,\\,25.3,\\,24.7,\\,25.2\\,]$。\n- 已知测量标准差：$\\sigma = 0.5$（因此测量方差为 $\\sigma^2 = 0.25$，单位 $\\mathrm{GPa}^2$）。\n\n通过为以下先验超参数和样本大小的测试集评估后验均值及其局部敏感度，来进行敏感度分析：\n1. 基准，中等信息量先验，全样本：$(\\mu_0,\\sigma_0) = (25.0\\,\\mathrm{GPa},\\,2.0\\,\\mathrm{GPa})$，$n = 8$。\n2. 高信息量且有偏的先验，全样本：$(\\mu_0,\\sigma_0) = (35.0\\,\\mathrm{GPa},\\,0.5\\,\\mathrm{GPa})$，$n = 8$。\n3. 非常模糊的先验，全样本：$(\\mu_0,\\sigma_0) = (20.0\\,\\mathrm{GPa},\\,10.0\\,\\mathrm{GPa})$，$n = 8$。\n4. 基准先验，小样本边缘情况（使用前 $n$ 个观测值）：$(\\mu_0,\\sigma_0) = (25.0\\,\\mathrm{GPa},\\,2.0\\,\\mathrm{GPa})$，$n = 2$。\n5. 近似正确、极高信息量的先验，全样本：$(\\mu_0,\\sigma_0) = (25.1\\,\\mathrm{GPa},\\,0.1\\,\\mathrm{GPa})$，$n = 8$。\n\n科学真实性要求：\n- 将 $E$ 视为连续标量参数。\n- 将 $\\sigma^2$ 视为已知并通过校准固定，不要对其进行估计。\n- 当适用时，所有计算中模量的单位必须是 $\\mathrm{GPa}$，方差的单位必须是 $\\mathrm{GPa}^2$。\n- 局部敏感度是无量纲的。\n\n您的程序必须实现推导出的算法，并为每个测试用例生成单行输出，其中包含一个含有三个浮点数的列表：\n- $E$ 的后验均值（单位：$\\mathrm{GPa}$），四舍五入到六位小数。\n- 后验均值相对于 $\\mu_0$ 的局部敏感度，四舍五入到六位小数。\n- 后验均值相对于 $\\sigma_0$ 的局部敏感度，四舍五入到六位小数。\n\n最终输出格式：\n- 一行输出，包含一个由逗号分隔的各测试用例结果列表，每个结果本身是一个包含三个浮点数的列表，所有内容都用方括号括起来。例如：$[\\,[m_1,s_{\\mu,1},s_{\\sigma_0,1}],\\,[m_2,s_{\\mu,2},s_{\\sigma_0,2}],\\,\\dots\\,]$。\n- 后验均值必须以 $\\mathrm{GPa}$ 为单位表示，敏感度必须是无量纲的。", "solution": "该问题要求推导一个算法，用于对杨氏模量参数 $E$ 进行贝叶斯更新，并随后计算后验均值及其相对于先验超参数的敏感度。该模型假设测量数据服从高斯似然，参数 $E$ 服从高斯先验。这是一个共轭先验模型的经典示例。\n\n首先，我们基于贝叶斯定理建立数学框架。在给定一组 $n$ 个独立观测值 $\\{y_i\\}_{i=1}^n$ 的条件下，参数 $E$ 的后验概率分布与给定参数时数据的似然和参数的先验分布的乘积成正比：\n$$ p(E \\mid \\{y_i\\}_{i=1}^n) \\propto p(\\{y_i\\}_{i=1}^n \\mid E) \\cdot p(E) $$\n\n问题指明了以下分布：\n1.  **似然函数**：每个观测值 $y_i$ 均从均值为 $E$、已知方差为 $\\sigma^2$ 的正态分布中抽取。由于观测值是独立的，联合似然是各个似然的乘积：\n    $$ p(\\{y_i\\} \\mid E) = \\prod_{i=1}^n \\mathcal{N}(y_i \\mid E, \\sigma^2) = \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(y_i - E)^2}{2\\sigma^2}\\right) $$\n    $$ p(\\{y_i\\} \\mid E) = (2\\pi\\sigma^2)^{-n/2} \\exp\\left(-\\frac{1}{2\\sigma^2}\\sum_{i=1}^n (y_i - E)^2\\right) $$\n\n2.  **先验分布**：关于 $E$ 的先验信念被建模为具有超参数 $\\mu_0$（先验均值）和 $\\sigma_0^2$（先验方差）的正态分布：\n    $$ p(E) = \\mathcal{N}(E \\mid \\mu_0, \\sigma_0^2) = \\frac{1}{\\sqrt{2\\pi\\sigma_0^2}} \\exp\\left(-\\frac{(E - \\mu_0)^2}{2\\sigma_0^2}\\right) $$\n\n为了求得后验分布，我们将似然与先验结合起来。我们关注指数项，因为归一化常数不依赖于 $E$：\n$$ p(E \\mid \\{y_i\\}) \\propto \\exp\\left(-\\frac{1}{2\\sigma^2}\\sum_{i=1}^n (y_i - E)^2\\right) \\exp\\left(-\\frac{(E - \\mu_0)^2}{2\\sigma_0^2}\\right) $$\n$$ p(E \\mid \\{y_i\\}) \\propto \\exp\\left( -\\frac{1}{2} \\left[ \\frac{\\sum_{i=1}^n (y_i - E)^2}{\\sigma^2} + \\frac{(E - \\mu_0)^2}{\\sigma_0^2} \\right] \\right) $$\n\n指数中的表达式是 $E$ 的一个二次函数。这意味着后验分布也是一个正态分布，我们设为 $E \\mid \\{y_i\\} \\sim \\mathcal{N}(\\mu_n, \\sigma_n^2)$。为了找到其参数 $\\mu_n$ 和 $\\sigma_n^2$，我们可以对指数中的 $E$ 进行配方。\n设指数为 $-\\frac{1}{2} Q(E)$。展开 $Q(E)$ 中的各项：\n$$ Q(E) = \\frac{1}{\\sigma^2}\\sum_{i=1}^n (y_i^2 - 2y_iE + E^2) + \\frac{1}{\\sigma_0^2}(E^2 - 2E\\mu_0 + \\mu_0^2) $$\n按 $E$ 的幂次对各项进行分组：\n$$ Q(E) = E^2\\left(\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_0^2}\\right) - 2E\\left(\\frac{\\sum y_i}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_0^2}\\right) + \\text{const} $$\n对于一个正态分布 $\\mathcal{N}(\\mu_n, \\sigma_n^2)$，其指数项为 $-\\frac{(E-\\mu_n)^2}{2\\sigma_n^2} = -\\frac{1}{2}\\left(\\frac{E^2}{\\sigma_n^2} - \\frac{2E\\mu_n}{\\sigma_n^2} + \\frac{\\mu_n^2}{\\sigma_n^2}\\right)$。\n通过匹配 $E^2$ 的系数，我们得到后验方差的倒数（即后验精度）：\n$$ \\frac{1}{\\sigma_n^2} = \\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_0^2} $$\n因此，后验方差 $\\sigma_n^2$ 为：\n$$ \\sigma_n^2 = \\left(\\frac{n}{\\sigma^2} + \\frac{1}{\\sigma_0^2}\\right)^{-1} = \\frac{\\sigma^2\\sigma_0^2}{n\\sigma_0^2 + \\sigma^2} $$\n\n通过匹配 $E$ 的系数，我们得到后验均值 $\\mu_n$：\n$$ \\frac{\\mu_n}{\\sigma_n^2} = \\frac{\\sum y_i}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_0^2} $$\n令 $\\bar{y} = \\frac{1}{n}\\sum_{i=1}^n y_i$ 为观测值的样本均值。\n$$ \\mu_n = \\sigma_n^2 \\left(\\frac{n\\bar{y}}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_0^2}\\right) $$\n代入 $\\sigma_n^2$ 的表达式：\n$$ \\mu_n = \\left(\\frac{\\sigma^2\\sigma_0^2}{n\\sigma_0^2 + \\sigma^2}\\right) \\left(\\frac{n\\bar{y}\\sigma_0^2 + \\mu_0\\sigma^2}{\\sigma^2\\sigma_0^2}\\right) = \\frac{n\\bar{y}\\sigma_0^2 + \\mu_0\\sigma^2}{n\\sigma_0^2 + \\sigma^2} $$\n\n后验均值，记作 $M(\\mu_0, \\sigma_0) = \\mathbb{E}[E \\mid \\{y_i\\}] = \\mu_n$，是我们需为其计算局部敏感度的量。\n$$ M(\\mu_0, \\sigma_0) = \\frac{n\\bar{y}\\sigma_0^2 + \\mu_0\\sigma^2}{n\\sigma_0^2 + \\sigma^2} $$\n\n接下来，我们推导 $M$ 相对于先验超参数 $\\mu_0$ 和 $\\sigma_0$ 的偏导数。\n\n1.  **相对于 $\\mu_0$ 的敏感度**：我们将 $M$ 对 $\\mu_0$ 求导，并将所有其他变量（$n, \\bar{y}, \\sigma^2, \\sigma_0$）视为常数。\n    $$ \\frac{\\partial M}{\\partial \\mu_0} = \\frac{\\partial}{\\partial \\mu_0} \\left( \\frac{n\\bar{y}\\sigma_0^2 + \\mu_0\\sigma^2}{n\\sigma_0^2 + \\sigma^2} \\right) = \\frac{1}{n\\sigma_0^2 + \\sigma^2} \\cdot \\frac{\\partial}{\\partial \\mu_0} (n\\bar{y}\\sigma_0^2 + \\mu_0\\sigma^2) $$\n    $$ \\frac{\\partial M}{\\partial \\mu_0} = \\frac{\\sigma^2}{n\\sigma_0^2 + \\sigma^2} $$\n\n2.  **相对于 $\\sigma_0$ 的敏感度**：我们将 $M$ 对 $\\sigma_0$ 求导。这需要使用商法则。令 $u(\\sigma_0) = n\\bar{y}\\sigma_0^2 + \\mu_0\\sigma^2$ 和 $v(\\sigma_0) = n\\sigma_0^2 + \\sigma^2$。它们对 $\\sigma_0$ 的导数分别为 $\\frac{\\partial u}{\\partial \\sigma_0} = 2n\\bar{y}\\sigma_0$ 和 $\\frac{\\partial v}{\\partial \\sigma_0} = 2n\\sigma_0$。\n    $$ \\frac{\\partial M}{\\partial \\sigma_0} = \\frac{v \\frac{\\partial u}{\\partial \\sigma_0} - u \\frac{\\partial v}{\\partial \\sigma_0}}{v^2} = \\frac{(n\\sigma_0^2 + \\sigma^2)(2n\\bar{y}\\sigma_0) - (n\\bar{y}\\sigma_0^2 + \\mu_0\\sigma^2)(2n\\sigma_0)}{(n\\sigma_0^2 + \\sigma^2)^2} $$\n    展开分子：\n    $$ (2n^2\\bar{y}\\sigma_0^3 + 2n\\bar{y}\\sigma_0\\sigma^2) - (2n^2\\bar{y}\\sigma_0^3 + 2n\\mu_0\\sigma_0\\sigma^2) $$\n    $$ = 2n\\bar{y}\\sigma_0\\sigma^2 - 2n\\mu_0\\sigma_0\\sigma^2 = 2n\\sigma_0\\sigma^2(\\bar{y} - \\mu_0) $$\n    相对于 $\\sigma_0$ 的敏感度的最终表达式为：\n    $$ \\frac{\\partial M}{\\partial \\sigma_0} = \\frac{2n\\sigma_0\\sigma^2(\\bar{y} - \\mu_0)}{(n\\sigma_0^2 + \\sigma^2)^2} $$\n\n要实现的算法如下：\n对于每个具有给定先验超参数 $(\\mu_0, \\sigma_0)$ 和样本大小 $n$ 的测试用例：\n1.  从数据集中选择前 $n$ 个观测值，并计算样本均值 $\\bar{y}$。\n2.  使用给定的测量标准差 $\\sigma$ 来计算方差 $\\sigma^2$。\n3.  使用推导出的公式计算后验均值 $M$。\n4.  计算敏感度 $\\frac{\\partial M}{\\partial \\mu_0}$。\n5.  计算敏感度 $\\frac{\\partial M}{\\partial \\sigma_0}$。\n6.  存储三个得到的浮点数。\n所有单位必须保持一致（模量单位为 $\\mathrm{GPa}$，方差单位为 $\\mathrm{GPa}^2$）。从推导的公式中可以验证，敏感度是无量纲的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Bayesian inference problem for Young's modulus,\n    calculating the posterior mean and its sensitivities for several test cases.\n    \"\"\"\n\n    # Full dataset of observations for Young's modulus E, in GPa.\n    y_full = np.array([24.8, 25.1, 25.5, 24.9, 25.0, 25.3, 24.7, 25.2])\n\n    # Known measurement standard deviation in GPa.\n    sigma = 0.5\n\n    # Test suite of prior hyperparameters (mu_0, sigma_0) and sample sizes (n).\n    test_cases = [\n        # (mu_0 [GPa], sigma_0 [GPa], n)\n        (25.0, 2.0, 8),  # 1. Baseline, moderately informative prior, full sample\n        (35.0, 0.5, 8),  # 2. Highly informative and biased prior, full sample\n        (20.0, 10.0, 8), # 3. Very vague prior, full sample\n        (25.0, 2.0, 2),  # 4. Baseline prior, small sample edge case\n        (25.1, 0.1, 8),  # 5. Near-correct, extremely informative prior, full sample\n    ]\n\n    all_results = []\n\n    for mu_0, sigma_0, n in test_cases:\n        # 1. Prepare data for the current case\n        # Use the first n observations from the full dataset.\n        y_obs = y_full[:n]\n        # Calculate the sample mean (y_bar).\n        y_bar = np.mean(y_obs)\n\n        # 2. Calculate intermediate quantities based on derived formulas\n        # Measurement variance (sigma^2).\n        sigma_sq = sigma**2\n        # Prior variance (sigma_0^2).\n        sigma0_sq = sigma_0**2\n        \n        # Common denominator in the expressions for posterior mean and sensitivities.\n        denominator = n * sigma0_sq + sigma_sq\n        \n        # 3. Compute posterior mean and sensitivities\n        # Posterior mean of E, denoted as M.\n        # M = (n * y_bar * sigma_0^2 + mu_0 * sigma^2) / (n * sigma_0^2 + sigma^2)\n        posterior_mean = (n * y_bar * sigma0_sq + mu_0 * sigma_sq) / denominator\n        \n        # Sensitivity of the posterior mean with respect to the prior mean (mu_0).\n        # S_mu0 = sigma^2 / (n * sigma_0^2 + sigma^2)\n        sensitivity_mu0 = sigma_sq / denominator\n        \n        # Sensitivity of the posterior mean with respect to the prior std. dev. (sigma_0).\n        # S_sigma0 = (2 * n * sigma_0 * sigma^2 * (y_bar - mu_0)) / (n * sigma_0^2 + sigma^2)^2\n        sensitivity_sigma0 = (2 * n * sigma_0 * sigma_sq * (y_bar - mu_0)) / (denominator**2)\n\n        # 4. Round results to six decimal places as required.\n        m_rounded = round(posterior_mean, 6)\n        s_mu0_rounded = round(sensitivity_mu0, 6)\n        s_sigma0_rounded = round(sensitivity_sigma0, 6)\n\n        # Append the list of results for the current test case.\n        all_results.append([m_rounded, s_mu0_rounded, s_sigma0_rounded])\n\n    # 5. Format and print the final output\n    # The required format is a string representation of a list of lists,\n    # with no whitespace. Example: [[a,b,c],[d,e,f]]\n    final_output_string = str(all_results).replace(' ', '')\n    print(final_output_string)\n\nsolve()\n```", "id": "3502949"}, {"introduction": "现在，让我们从理想化的共轭模型迈向更符合工程实际的复杂场景。本练习 [@problem_id:3502946] 将带您解决一个核心的岩土工程问题：利用三轴试验数据估计土体的莫尔-库仑（Mohr-Coulomb）强度参数——黏聚力 $c$ 和内摩擦角 $\\phi$。由于该模型是非线性的，且先验分布（如对数正态分布）与似然函数不构成共轭，我们无法得到解析形式的后验。因此，本练习将指导您使用数值优化方法来求解后验概率密度最大点，即最大后验（MAP）估计，这是在实际应用中处理非共轭贝叶斯问题的常用且强大的技术。", "problem": "您必须实现一个完整的程序，通过对峰值强度的似然和基于地质背景的先验进行建模，来对轴对称三轴压缩试验的莫尔-库仑参数执行贝叶斯更新，然后计算黏聚力和摩擦角的最大后验 (MAP) 估计。未知参数是黏聚力 $c$ (单位为千帕，kPa) 和摩擦角 $\\phi$ (单位为度)。必须对一个测试套件中的多个数据集执行此估计，每个数据集由指定围压下的峰值强度观测值组成。您的程序必须处理所有数据集，以物理上有意义的单位计算$(c,\\phi)$的后验众数，并以指定格式生成单行输出。\n\n基本背景：\n- 莫尔-库仑破坏准则被用作三轴压缩破坏时峰值强度的本构基础。对于围压为 $\\sigma_3$ (单位 kPa) 且破坏时偏应力为 $q = \\sigma_1 - \\sigma_3$ (单位 kPa) 的轴对称三轴试验，由黏聚力 $c$ 和摩擦角 $\\phi$ 预测的莫尔-库仑峰值偏应力为\n$$\nq(c,\\phi,\\sigma_3) = \\frac{2\\,c\\,\\cos\\phi_r}{1 - \\sin\\phi_r} + \\frac{2\\,\\sigma_3\\,\\sin\\phi_r}{1 - \\sin\\phi_r},\n$$\n其中 $\\phi_r$ 是以弧度表示的摩擦角，而 $\\phi$ 是以度表示的；因此，$\\phi_r = \\phi \\times \\pi/180$。\n- 贝叶斯推断使用贝叶斯法则进行，该法则指出，在给定数据的情况下，$(c,\\phi)$的后验密度与似然乘以先验成正比。最大后验 (MAP) 估计是后验概率的最大化者。\n\n似然和先验的建模假设：\n- 似然：对于由 $j$ 索引的每个数据集，其在围压 $\\{\\sigma_{3,j,i}\\}_{i=1}^{n_j}$ 下的观测峰值偏应力为 $\\{q_{j,i}^{\\text{obs}}\\}_{i=1}^{n_j}$，假设存在独立的、标准差已知为 $s_j$ (单位 kPa) 的高斯测量误差，因此\n$$\nq_{j,i}^{\\text{obs}} = q(c,\\phi,\\sigma_{3,j,i}) + \\epsilon_{j,i}, \\quad \\epsilon_{j,i} \\sim \\mathcal{N}(0, s_j^2).\n$$\n- $c$ 的先验：假设一个由 $\\log c \\sim \\mathcal{N}(\\mu_{c,j}, \\sigma_{c,j}^2)$ 指定的对数正态先验，这强制要求 $c  0$。\n- $\\phi$ 的先验：假设一个高斯先验 $\\phi \\sim \\mathcal{N}(\\mu_{\\phi,j}, \\sigma_{\\phi,j}^2)$，并截断到物理上合理的区间 $[\\phi_{\\min,j}, \\phi_{\\max,j}]$ (单位为度)。假定$(c,\\phi)$是先验独立的。\n\n您的任务：\n- 对于测试套件中的每个数据集，通过在 $c  0$ 和 $\\phi \\in [\\phi_{\\min}, \\phi_{\\max}]$ 的范围内数值最大化后验密度，来计算 MAP 估计 $(c_{\\text{MAP}}, \\phi_{\\text{MAP}})$。如果您通过最小化负对数后验来实现，请确保对边界和数值稳定性进行适当处理。\n- 以 kPa 为单位表示 $c_{\\text{MAP}}$ 的最终值，以度为单位表示 $\\phi_{\\text{MAP}}$ 的最终值。最终输出中的角度必须以度为单位。输入无需单位转换，因为它们已经以 kPa 和度为单位提供。\n\n测试套件：\n- 数据集 $1$ (类砂土，中等黏聚力)：\n    - 围压 $\\sigma_{3,1} = [$ $100$, $300$, $600$ $]$ kPa。\n    - 观测峰值偏应力 $q_{1}^{\\text{obs}} = [$ $304.0$, $704.0$, $1302.0$ $]$ kPa。\n    - 观测噪声标准差 $s_1 = $ $20.0$ kPa。\n    - 先验超参数：$\\mu_{c,1} = \\log($ $25.0$ $)$, $\\sigma_{c,1} = $ $0.4$；$\\mu_{\\phi,1} = $ $32.0$ 度, $\\sigma_{\\phi,1} = $ $5.0$ 度；截断边界 $[\\phi_{\\min,1}, \\phi_{\\max,1}] = [$ $15.0$, $45.0$ $]$ 度。\n- 数据集 $2$ (净砂，黏聚力接近零)：\n    - 围压 $\\sigma_{3,2} = [$ $50$, $150$, $300$ $]$ kPa。\n    - 观测峰值偏应力 $q_{2}^{\\text{obs}} = [$ $154.0$, $420.0$, $832.0$ $]$ kPa。\n    - 观测噪声标准差 $s_2 = $ $15.0$ kPa。\n    - 先验超参数：$\\mu_{c,2} = \\log($ $3.0$ $)$, $\\sigma_{c,2} = $ $0.5$；$\\mu_{\\phi,2} = $ $35.0$ 度, $\\sigma_{\\phi,2} = $ $3.0$ 度；截断边界 $[\\phi_{\\min,2}, \\phi_{\\max,2}] = [$ $20.0$, $50.0$ $]$ 度。\n- 数据集 $3$ (类黏土，较高黏聚力，较低摩擦角，数据较弱)：\n    - 围压 $\\sigma_{3,3} = [$ $50$, $150$, $300$ $]$ kPa。\n    - 观测峰值偏应力 $q_{3}^{\\text{obs}} = [$ $340.0$, $430.0$, $610.0$ $]$ kPa。\n    - 观测噪声标准差 $s_3 = $ $50.0$ kPa。\n    - 先验超参数：$\\mu_{c,3} = \\log($ $120.0$ $)$, $\\sigma_{c,3} = $ $0.3$；$\\mu_{\\phi,3} = $ $18.0$ 度, $\\sigma_{\\phi,3} = $ $4.0$ 度；截断边界 $[\\phi_{\\min,3}, \\phi_{\\max,3}] = [$ $12.0$, $35.0$ $]$ 度。\n\n算法和数值要求：\n- 使用一个稳健的、能处理 $c$ 和 $\\phi$ 边界的数值优化器。使用从先验超参数派生的多个初始猜测值，以减轻局部最优解问题。\n- 实现对数似然、 $c$ 的对数先验 (对数正态) 和 $\\phi$ 的对数先验 (在给定区间上截断的高斯)，以及最终的对数后验。您可以省略不依赖于$(c,\\phi)$的加性常数，因为它们不影响 MAP 估计。\n- 确保在使用三角函数时将 $\\phi$ 转换为弧度，并在输出时保持为度。\n- 强制执行 $c  0$ 和 $\\phi_{\\min} \\le \\phi \\le \\phi_{\\max}$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个数据集的输出应为一个双元素列表 $[c_{\\text{MAP}}, \\phi_{\\text{MAP}}]$，其中 $c_{\\text{MAP}}$ 的单位为 kPa，$\\phi_{\\text{MAP}}$ 的单位为度，两者均四舍五入到三位小数。例如，输出必须如下所示\n[$[$ $c_1$ $,$ $\\phi_1$ $]$ $,$ $[$ $c_2$ $,$ $\\phi_2$ $]$ $,$ $[$ $c_3$ $,$ $\\phi_3$ $]$]\n其中实际数值已被替换。\n\n您的程序必须是完全自包含的，不需要用户输入，并严格遵守指定的执行环境。您的程序生成的最终答案必须是指定格式的浮点数或浮点数列表。", "solution": "该问题要求在给定三轴试验的实验数据的情况下，找到莫尔-库仑参数——黏聚力 $c$ 和摩擦角 $\\phi$ ——的最大后验 (MAP) 估计。这通过最大化后验概率密度函数 $p(c, \\phi | \\text{data})$ 来实现，根据贝叶斯法则，该函数正比于似然与先验概率的乘积：\n\n$$\np(c, \\phi | \\text{data}) \\propto p(\\text{data} | c, \\phi) \\cdot p(c, \\phi)\n$$\n\n参数 $c$ 和 $\\phi$ 被假定为先验独立，因此 $p(c, \\phi) = p(c) \\cdot p(\\phi)$。最大化后验密度等同于最大化其对数（即对数后验），或最小化其负数（即负对数后验）。出于数值稳定性的考虑，后者通常是首选。我们将用作最小化目标函数的负对数后验 $F(c, \\phi)$ 是：\n\n$$\nF(c, \\phi) = -\\log[p(\\text{data} | c, \\phi)] - \\log[p(c)] - \\log[p(\\phi)]\n$$\n\n让我们为通用数据集 $j$ 定义每一项。待估计的参数是 $(c, \\phi)$，数据由 $n_j$ 对观测到的峰值偏应力 $\\{q_{j,i}^{\\text{obs}}\\}$ 和相应的围压 $\\{\\sigma_{3,j,i}\\}$ 组成。\n\n**1. 似然项**\n\n预测峰值偏应力的模型由莫尔-库仑破坏准则给出：\n$$\nq_{\\text{pred}}(c, \\phi, \\sigma_3) = \\frac{2c\\cos\\phi_r}{1 - \\sin\\phi_r} + \\frac{2\\sigma_3\\sin\\phi_r}{1 - \\sin\\phi_r}\n$$\n其中 $\\phi_r = \\phi \\cdot \\pi/180$ 是以弧度表示的摩擦角。\n\n观测值被假设为受到独立同分布的高斯噪声的干扰，$q_{j,i}^{\\text{obs}} = q_{\\text{pred}}(c, \\phi, \\sigma_{3,j,i}) + \\epsilon_{j,i}$，其中 $\\epsilon_{j,i} \\sim \\mathcal{N}(0, s_j^2)$。单个观测值 $q_{j,i}^{\\text{obs}}$ 的概率密度为：\n$$\np(q_{j,i}^{\\text{obs}} | c, \\phi) = \\frac{1}{\\sqrt{2\\pi s_j^2}} \\exp\\left(-\\frac{(q_{j,i}^{\\text{obs}} - q_{\\text{pred}}(c, \\phi, \\sigma_{3,j,i}))^2}{2s_j^2}\\right)\n$$\n由于观测值是独立的，总似然是各个密度的乘积。对数似然是各个对数密度的和：\n$$\n\\log[p(\\text{data}_j | c, \\phi)] = \\sum_{i=1}^{n_j} \\left( -\\frac{1}{2}\\log(2\\pi s_j^2) - \\frac{(q_{j,i}^{\\text{obs}} - q_{\\text{pred}}(c, \\phi, \\sigma_{3,j,i}))^2}{2s_j^2} \\right)\n$$\n为了优化，我们可以舍去常数项 $-\\frac{n_j}{2}\\log(2\\pi s_j^2)$。要最小化的负对数似然项与误差平方和成正比：\n$$\n-\\log[p(\\text{data}_j | c, \\phi)] \\propto \\frac{1}{2s_j^2} \\sum_{i=1}^{n_j} (q_{j,i}^{\\text{obs}} - q_{\\text{pred}}(c, \\phi, \\sigma_{3,j,i}))^2\n$$\n\n**2. 黏聚力 $c$ 的先验项**\n\n黏聚力 $c$ 被赋予一个对数正态先验，由 $\\log c \\sim \\mathcal{N}(\\mu_{c,j}, \\sigma_{c,j}^2)$ 指定。 $c$ 的概率密度函数为：\n$$\np(c) = \\frac{1}{c\\sigma_{c,j}\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\log c - \\mu_{c,j})^2}{2\\sigma_{c,j}^2}\\right) \\quad \\text{for } c > 0\n$$\n对数先验是：\n$$\n\\log[p(c)] = -\\log c - \\frac{1}{2}\\log(2\\pi\\sigma_{c,j}^2) - \\frac{(\\log c - \\mu_{c,j})^2}{2\\sigma_{c,j}^2}\n$$\n舍去常数项 $-\\frac{1}{2}\\log(2\\pi\\sigma_{c,j}^2)$，要最小化的 $c$ 的负对数先验项为：\n$$\n-\\log[p(c)] \\propto \\log c + \\frac{(\\log c - \\mu_{c,j})^2}{2\\sigma_{c,j}^2}\n$$\n\n**3. 摩擦角 $\\phi$ 的先验项**\n\n摩擦角 $\\phi$ 被赋予一个高斯先验，$\\phi \\sim \\mathcal{N}(\\mu_{\\phi,j}, \\sigma_{\\phi,j}^2)$，并截断到区间 $[\\phi_{\\min,j}, \\phi_{\\max,j}]$。其概率密度函数为：\n$$\np(\\phi) = \\begin{cases} \\frac{1}{Z} \\frac{1}{\\sigma_{\\phi,j}\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\phi - \\mu_{\\phi,j})^2}{2\\sigma_{\\phi,j}^2}\\right)  \\text{if } \\phi \\in [\\phi_{\\min,j}, \\phi_{\\max,j}] \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n其中 $Z$ 是一个归一化常数，确保密度在区间上的积分为 $1$。由于 $Z$ 不依赖于 $\\phi$，因此它在对数后验中是一个加性常数，在优化过程中可以忽略。因此，要最小化的负对数先验项是：\n$$\n-\\log[p(\\phi)] \\propto \\frac{(\\phi - \\mu_{\\phi,j})^2}{2\\sigma_{\\phi,j}^2}\n$$\n截断约束 $\\phi \\in [\\phi_{\\min,j}, \\phi_{\\max,j}]$ 将在数值优化中作为边界强制执行。\n\n**4. 完整的目标函数与优化策略**\n\n结合所有项，对于每个数据集 $j$ 需要最小化的完整目标函数 $F(c, \\phi)$ 是：\n$$\nF(c, \\phi) = \\frac{1}{2s_j^2} \\sum_{i=1}^{n_j} (q_{j,i}^{\\text{obs}} - q_{\\text{pred}}(c, \\phi, \\sigma_{3,j,i}))^2 + \\log c + \\frac{(\\log c - \\mu_{c,j})^2}{2\\sigma_{c,j}^2} + \\frac{(\\phi - \\mu_{\\phi,j})^2}{2\\sigma_{\\phi,j}^2}\n$$\n此最小化过程受箱形约束 $c > 0$ 和 $\\phi_{\\min,j} \\le \\phi \\le \\phi_{\\max,j}$ 的限制。对于数值实现， $c$ 的下界被设置为一个很小的正值 (例如 $10^{-9}$) 以避免计算 $\\log(0)$，而上界可以不加约束。\n\n我们将使用一个能够处理箱形约束的数值优化算法，具体是 `scipy.optimize.minimize` 中提供的 L-BFGS-B 算法。为增加找到全局最小值的可能性，我们将从多个初始点开始优化。这些点是根据先验分布系统地选择的：一个在先验均值 $(\\exp(\\mu_{c,j}), \\mu_{\\phi,j})$ 处，其他点则在一个标准差之外，并确保它们在指定边界内。在所有尝试中，能够使目标函数 $F(c, \\phi)$ 取得最小值的解即为 $(c_{\\text{MAP}}, \\phi_{\\text{MAP}})$。最终结果经过四舍五入并按指定格式呈现。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Performs Bayesian MAP estimation of Mohr-Coulomb parameters for three datasets.\n    \"\"\"\n\n    # Define the three test cases as specified in the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Dataset 1\",\n            \"sigma3\": np.array([100.0, 300.0, 600.0]),\n            \"q_obs\": np.array([304.0, 704.0, 1302.0]),\n            \"s\": 20.0,\n            \"mu_c\": np.log(25.0),\n            \"sigma_c\": 0.4,\n            \"mu_phi\": 32.0,\n            \"sigma_phi\": 5.0,\n            \"phi_bounds\": (15.0, 45.0),\n        },\n        {\n            \"name\": \"Dataset 2\",\n            \"sigma3\": np.array([50.0, 150.0, 300.0]),\n            \"q_obs\": np.array([154.0, 420.0, 832.0]),\n            \"s\": 15.0,\n            \"mu_c\": np.log(3.0),\n            \"sigma_c\": 0.5,\n            \"mu_phi\": 35.0,\n            \"sigma_phi\": 3.0,\n            \"phi_bounds\": (20.0, 50.0),\n        },\n        {\n            \"name\": \"Dataset 3\",\n            \"sigma3\": np.array([50.0, 150.0, 300.0]),\n            \"q_obs\": np.array([340.0, 430.0, 610.0]),\n            \"s\": 50.0,\n            \"mu_c\": np.log(120.0),\n            \"sigma_c\": 0.3,\n            \"mu_phi\": 18.0,\n            \"sigma_phi\": 4.0,\n            \"phi_bounds\": (12.0, 35.0),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Extract data for the current case for clarity\n        sigma3_data = case[\"sigma3\"]\n        q_obs_data = case[\"q_obs\"]\n        s = case[\"s\"]\n        mu_c = case[\"mu_c\"]\n        sigma_c = case[\"sigma_c\"]\n        mu_phi = case[\"mu_phi\"]\n        sigma_phi = case[\"sigma_phi\"]\n        phi_min, phi_max = case[\"phi_bounds\"]\n\n        def mohr_coulomb_model(c, phi_deg, sigma3):\n            \"\"\"\n            Calculates predicted deviatoric stress q based on Mohr-Coulomb.\n            c: cohesion (kPa)\n            phi_deg: friction angle (degrees)\n            sigma3: confining pressure (kPa)\n            \"\"\"\n            phi_rad = np.deg2rad(phi_deg)\n            sin_phi = np.sin(phi_rad)\n            cos_phi = np.cos(phi_rad)\n            \n            # Avoid division by zero if phi is 90 degrees\n            if np.isclose(sin_phi, 1.0):\n                return np.inf\n            \n            denominator = 1.0 - sin_phi\n            \n            q_pred = (2 * c * cos_phi + 2 * sigma3 * sin_phi) / denominator\n            return q_pred\n\n        def neg_log_posterior(params):\n            \"\"\"\n            Objective function: negative log-posterior probability.\n            params: a list or array [c, phi]\n            \"\"\"\n            c, phi = params\n\n            # Parameter bounds check (though handled by optimizer, this adds robustness)\n            if c = 0 or not (phi_min = phi = phi_max):\n                return np.inf\n\n            # 1. Negative Log-Likelihood\n            q_pred = mohr_coulomb_model(c, phi, sigma3_data)\n            sse = np.sum((q_obs_data - q_pred)**2)\n            neg_log_likelihood = sse / (2 * s**2)\n\n            # 2. Negative Log-Prior for c (Lognormal)\n            log_c = np.log(c)\n            neg_log_prior_c = log_c + ((log_c - mu_c)**2) / (2 * sigma_c**2)\n            \n            # 3. Negative Log-Prior for phi (Truncated Normal)\n            neg_log_prior_phi = ((phi - mu_phi)**2) / (2 * sigma_phi**2)\n\n            return neg_log_likelihood + neg_log_prior_c + neg_log_prior_phi\n\n        # Define bounds for the optimizer\n        # c > 0 (practically > a small epsilon)\n        # phi_min = phi = phi_max\n        bounds = [(1e-9, None), (phi_min, phi_max)]\n\n        # Set up multiple initial guesses to improve robustness against local minima\n        initial_guesses = []\n        # Guess 1: Prior mean\n        c0_mean = np.exp(mu_c)\n        phi0_mean = mu_phi\n        initial_guesses.append([c0_mean, phi0_mean])\n        \n        # Additional guesses based on prior standard deviation\n        c0_plus_std = np.exp(mu_c + sigma_c)\n        phi0_plus_std = np.clip(mu_phi + sigma_phi, phi_min, phi_max)\n        initial_guesses.append([c0_plus_std, phi0_plus_std])\n        \n        c0_minus_std = np.exp(mu_c - sigma_c)\n        phi0_minus_std = np.clip(mu_phi - sigma_phi, phi_min, phi_max)\n        initial_guesses.append([c0_minus_std, phi0_minus_std])\n\n        best_result = None\n        min_f_val = np.inf\n\n        for x0 in initial_guesses:\n            res = minimize(\n                neg_log_posterior,\n                x0=x0,\n                method='L-BFGS-B',\n                bounds=bounds\n            )\n            if res.success and res.fun  min_f_val:\n                min_f_val = res.fun\n                best_result = res.x\n\n        # Store the MAP estimate for c and phi, rounded to three decimal places\n        if best_result is not None:\n            c_map = round(best_result[0], 3)\n            phi_map = round(best_result[1], 3)\n            results.append([c_map, phi_map])\n        else:\n            # Fallback in case of optimization failure, though unlikely with this setup\n            results.append([np.nan, np.nan])\n\n    # Format the output as per the specification\n    # e.g., [[c1,phi1],[c2,phi2],[c3,phi3]]\n    output_str = \"[\" + \",\".join([f\"[{c},{p}]\" for c, p in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3502946"}]}