{"hands_on_practices": [{"introduction": "许多降阶建模技术的第一步是将高维数据（如模拟快照）压缩成一个紧凑的低维基。本征正交分解（Proper Orthogonal Decomposition, POD）是实现这一目标的最优线性方法。本练习将重点关注一个关键步骤：如何确定需要多少个基向量（模态）才能在所需精度下捕捉系统的主要“能量”或信息。[@problem_id:3555778]", "problem": "在计算岩土力学中，一个高保真有限元模型通过对分层土层中孔隙弹性固结进行参数化模拟，生成了一个快照矩阵 $\\mathbf{X} \\in \\mathbb{R}^{n \\times m}$。考虑通过对 $\\mathbf{X}$ 进行奇异值分解 (SVD) 构建的本征正交分解 (POD) 基，其中 $\\mathbf{X} = \\mathbf{U} \\boldsymbol{\\Sigma} \\mathbf{V}^{\\top}$，奇异值为 $\\{\\sigma_i\\}_{i \\ge 1}$ 且满足 $\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge 0$。令秩-$r$ POD 投影算子为 $\\mathbf{P}_r = \\mathbf{U}_r \\mathbf{U}_r^{\\top}$，其中 $\\mathbf{U}_r$ 包含前 $r$ 个左奇异向量。\n\n您的任务是选择模态数 $r$，以满足相对投影误差的给定容差。将快照弗罗贝尼乌斯范数下的相对投影误差定义为\n$$\nE_r \\equiv \\frac{\\|\\mathbf{X} - \\mathbf{P}_r \\mathbf{X}\\|_F}{\\|\\mathbf{X}\\|_F}.\n$$\n从奇异值分解的定义和弗罗贝尼乌斯范数的性质出发，推导出一个规则，用于确定在给定容差 $\\epsilon \\in (0,1)$ 下保证 $E_r \\le \\epsilon$ 的最小 $r$。然后，在许多岩土力学数据集的奇异值呈几何衰减这一科学上合理且经验上观察到的衰减剖面下，\n$$\n\\sigma_i = \\sigma_1 \\, q^{\\,i-1}, \\quad \\text{其中} \\quad \\sigma_1 = 1 \\quad \\text{且} \\quad q = 0.82,\n$$\n假设该序列无限延伸，并计算残余能量\n$$\n\\sum_{i>r} \\sigma_i^2\n$$\n在容差为 $\\epsilon = 10^{-3}$ 的情况下。\n\n将您的最终答案表示为包含 $(r, \\sum_{i>r} \\sigma_i^2)$ 的行矩阵。将残余能量四舍五入至四位有效数字。最终答案中不要包含单位。", "solution": "该问题是有效的。它在科学上基于线性代数和降阶建模的原理，特别是通过奇异值分解 (SVD) 实现的本征正交分解 (POD)，这是计算科学中的一种标准技术。该问题是适定的，提供了所有必要的数据和定义，可以得出一个唯一的、可验证的解。\n\n第一个任务是推导一个规则，用于选择最小模态数 $r$，以满足相对投影误差 $E_r$ 的给定容差 $\\epsilon$。误差定义为：\n$$\nE_r = \\frac{\\|\\mathbf{X} - \\mathbf{P}_r \\mathbf{X}\\|_F}{\\|\\mathbf{X}\\|_F}\n$$\n处理该量的平方更为方便：\n$$\nE_r^2 = \\frac{\\|\\mathbf{X} - \\mathbf{P}_r \\mathbf{X}\\|_F^2}{\\|\\mathbf{X}\\|_F^2}\n$$\n矩阵 $\\mathbf{A}$ 的弗罗贝尼乌斯范数与其奇异值 $\\{\\sigma_i\\}$ 的关系为 $\\|\\mathbf{A}\\|_F^2 = \\sum_i \\sigma_i^2$。快照矩阵 $\\mathbf{X}$ 的奇异值给定为 $\\{\\sigma_i\\}_{i \\ge 1}$。因此，分母中的范数平方为：\n$$\n\\|\\mathbf{X}\\|_F^2 = \\sum_{i=1}^{k} \\sigma_i^2\n$$\n其中 $k = \\text{rank}(\\mathbf{X})$。\n\n对于分子，我们首先分析表示投影误差的矩阵 $\\mathbf{X} - \\mathbf{P}_r \\mathbf{X}$。$\\mathbf{X}$ 的SVD可以写成一系列秩-1矩阵的和：\n$$\n\\mathbf{X} = \\sum_{i=1}^k \\sigma_i \\mathbf{u}_i \\mathbf{v}_i^{\\top}\n$$\n其中 $\\mathbf{u}_i$ 和 $\\mathbf{v}_i$ 分别是第 $i$ 个左奇异向量和右奇异向量。投影算子 $\\mathbf{P}_r = \\mathbf{U}_r \\mathbf{U}_r^{\\top}$ 是到由前 $r$ 个左奇异向量 $\\{\\mathbf{u}_1, \\dots, \\mathbf{u}_r\\}$ 张成的子空间上的正交投影。将此投影算子应用于向量 $\\mathbf{w}$ 可得 $\\mathbf{P}_r \\mathbf{w} = \\sum_{i=1}^r (\\mathbf{u}_i^{\\top}\\mathbf{w})\\mathbf{u}_i$。将此投影算子应用于矩阵 $\\mathbf{X}$ 可得：\n$$\n\\mathbf{P}_r \\mathbf{X} = \\left(\\sum_{j=1}^r \\mathbf{u}_j \\mathbf{u}_j^{\\top}\\right) \\left(\\sum_{i=1}^k \\sigma_i \\mathbf{u}_i \\mathbf{v}_i^{\\top}\\right) = \\sum_{j=1}^r \\sum_{i=1}^k \\sigma_i (\\mathbf{u}_j \\mathbf{u}_j^{\\top} \\mathbf{u}_i) \\mathbf{v}_i^{\\top}\n$$\n由于奇异向量的正交规范性，$\\mathbf{u}_j^{\\top} \\mathbf{u}_i = \\delta_{ij}$ (克罗内克δ函数)。表达式简化为：\n$$\n\\mathbf{P}_r \\mathbf{X} = \\sum_{i=1}^r \\sigma_i \\mathbf{u}_i \\mathbf{v}_i^{\\top}\n$$\n这是著名的 Eckart-Young-Mirsky 定理的结果，该定理指出 $\\mathbf{P}_r\\mathbf{X}$ 是 $\\mathbf{X}$ 在弗罗贝尼乌斯范数下的最佳秩-$r$ 近似。那么误差矩阵为：\n$$\n\\mathbf{X} - \\mathbf{P}_r \\mathbf{X} = \\sum_{i=1}^k \\sigma_i \\mathbf{u}_i \\mathbf{v}_i^{\\top} - \\sum_{i=1}^r \\sigma_i \\mathbf{u}_i \\mathbf{v}_i^{\\top} = \\sum_{i=r+1}^k \\sigma_i \\mathbf{u}_i \\mathbf{v}_i^{\\top}\n$$\n右侧的表达式本身就是一个SVD，其奇异值为 $\\{\\sigma_{r+1}, \\sigma_{r+2}, \\dots, \\sigma_k\\}$。因此，误差矩阵的弗罗贝尼乌斯范数的平方为：\n$$\n\\|\\mathbf{X} - \\mathbf{P}_r \\mathbf{X}\\|_F^2 = \\sum_{i=r+1}^k \\sigma_i^2\n$$\n问题陈述中假设奇异值序列无限延伸，因此我们将有限上界 $k$ 替换为 $\\infty$。相对误差的平方变为：\n$$\nE_r^2 = \\frac{\\sum_{i=r+1}^\\infty \\sigma_i^2}{\\sum_{i=1}^\\infty \\sigma_i^2}\n$$\n选择 $r$ 的条件是 $E_r \\le \\epsilon$，这等价于 $E_r^2 \\le \\epsilon^2$。因此，求最小 $r$ 的规则是找到满足以下条件的最小整数 $r$：\n$$\n\\frac{\\sum_{i=r+1}^\\infty \\sigma_i^2}{\\sum_{i=1}^\\infty \\sigma_i^2} \\le \\epsilon^2\n$$\n现在，我们将此规则应用于指定的奇异值衰减剖面：\n$$\n\\sigma_i = \\sigma_1 q^{i-1} \\quad \\text{其中} \\quad \\sigma_1 = 1 \\quad \\text{且} \\quad q = 0.82\n$$\n奇异值的平方为 $\\sigma_i^2 = (\\sigma_1^2) (q^2)^{i-1} = (q^2)^{i-1}$，因为 $\\sigma_1=1$。这些和是无穷几何级数。总和 (分母) 为：\n$$\n\\sum_{i=1}^\\infty \\sigma_i^2 = \\sum_{i=1}^\\infty (q^2)^{i-1} = \\sum_{j=0}^\\infty (q^2)^j = \\frac{1}{1-q^2}\n$$\n该级数收敛，因为 $|q| = 0.82  1$，所以 $q^2  1$。截断尾部的和 (分子) 为：\n$$\n\\sum_{i=r+1}^\\infty \\sigma_i^2 = \\sum_{i=r+1}^\\infty (q^2)^{i-1} = (q^2)^r + (q^2)^{r+1} + \\dots = \\frac{(q^2)^r}{1-q^2}\n$$\n将这些代入关于 $r$ 的不等式中：\n$$\n\\frac{\\frac{(q^2)^r}{1-q^2}}{\\frac{1}{1-q^2}} \\le \\epsilon^2 \\implies (q^2)^r \\le \\epsilon^2\n$$\n对两边取平方根 (所有量均为正) 得到一个更简单的关系：\n$$\nq^r \\le \\epsilon\n$$\n我们需要找到满足此条件的最小整数 $r$。对两边取自然对数：\n$$\nr \\ln(q) \\le \\ln(\\epsilon)\n$$\n由于 $q=0.82  1$，$\\ln(q)$ 是负数。除以 $\\ln(q)$ 会使不等式方向反转：\n$$\nr \\ge \\frac{\\ln(\\epsilon)}{\\ln(q)}\n$$\n给定 $\\epsilon = 10^{-3}$ 和 $q = 0.82$。\n$$\nr \\ge \\frac{\\ln(10^{-3})}{\\ln(0.82)} = \\frac{-3 \\ln(10)}{\\ln(0.82)}\n$$\n使用数值 $\\ln(10) \\approx 2.302585$ 和 $\\ln(0.82) \\approx -0.198451$：\n$$\nr \\ge \\frac{-3 \\times 2.302585}{-0.198451} \\approx \\frac{-6.907755}{-0.198451} \\approx 34.808\n$$\n由于 $r$ 必须是整数，所以其最小值为 $r = \\lceil 34.808 \\rceil = 35$。\n\n第二个任务是计算此 $r$ 值对应的残余能量 $\\sum_{i>r} \\sigma_i^2$。由于 $r=35$，这就是和 $\\sum_{i=36}^\\infty \\sigma_i^2$。这是我们之前计算的分子项，在 $r=35$ 处求值。\n$$\n\\sum_{i>35} \\sigma_i^2 = \\sum_{i=36}^\\infty \\sigma_i^2 = \\frac{(q^2)^{35}}{1-q^2}\n$$\n我们有 $q=0.82$，所以 $q^2 = 0.82^2 = 0.6724$。\n$$\n\\sum_{i>35} \\sigma_i^2 = \\frac{(0.6724)^{35}}{1-0.6724} = \\frac{(0.6724)^{35}}{0.3276}\n$$\n计算其值：\n$$\n(0.6724)^{35} \\approx 9.245235 \\times 10^{-7}\n$$\n$$\n\\sum_{i>35} \\sigma_i^2 \\approx \\frac{9.245235 \\times 10^{-7}}{0.3276} \\approx 2.8221096 \\times 10^{-6}\n$$\n四舍五入到四位有效数字，残余能量为 $2.822 \\times 10^{-6}$。\n\n最终答案是行矩阵 $(r, \\sum_{i>r} \\sigma_i^2)$。\n这两个分量是 $r=35$ 和残余能量 $2.822 \\times 10^{-6}$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n35  2.822 \\times 10^{-6}\n\\end{pmatrix}\n}\n$$", "id": "3555778"}, {"introduction": "降低模型阶数不仅能节省每一步的计算量，还能从根本上改变系统的数值特性。本练习将探讨降阶模型对于显式时间积分方案的一个关键优势，这在波动传播问题中很常见。通过投影到低频模态构成的基上，我们可以显著放宽完整模型中严格的时间步长限制（CFL条件）。[@problem_id:3555710]", "problem": "一维饱和土柱由Biot型动力学建模。经过标准的混合有限元空间半离散化和对流体变量进行分块静态凝聚以分离出波传播部分后，针对固体位移自由度的无阻尼半离散方程可以写成如下二阶形式：\n$$\nM \\, \\ddot{u}(t) + K \\, u(t) = 0,\n$$\n其中 $M \\in \\mathbb{R}^{N \\times N}$ 是对称正定矩阵，$K \\in \\mathbb{R}^{N \\times N}$ 是对称半正定矩阵。考虑将显式中心差分时间积分应用于上述齐次系统。令矩阵对 $(K,M)$ 的广义特征对求解\n$$\nK \\, \\phi_i = \\lambda_i \\, M \\, \\phi_i, \\quad i=1,\\dots,N,\n$$\n其中 $0  \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_N$。假设特征向量是 $M$-正交归一的，即 $\\phi_i^{\\top} M \\phi_j = \\delta_{ij}$。\n\n通过伽辽金投影到由前 $r$ 个广义特征向量 ($r \\ll N$) 张成的子空间上，构建一个降阶模型，形成满足 $V^{\\top} M V = I_r$ 的降阶基矩阵 $V = [\\phi_1,\\dots,\\phi_r] \\in \\mathbb{R}^{N \\times r}$。降阶算子为 $M_r = V^{\\top} M V = I_r$ 和 $K_r = V^{\\top} K V$，降阶模型为 $M_r \\ddot{q}(t) + K_r q(t) = 0$。\n\n从中心差分时间积分和二阶线性系统模态分析的基本原理出发，推导全阶模型和降阶模型的稳定性时间步长约束，并用每种情况下保留的最大广义特征值表示。然后，使用以下全阶广义特征值（按升序排列），\n$$\n\\lambda_1 = 1.44 \\times 10^{6}, \\quad\n\\lambda_2 = 2.25 \\times 10^{6}, \\quad\n\\lambda_3 = 1.00 \\times 10^{7}, \\quad\n\\lambda_4 = 4.00 \\times 10^{7}, \\quad\n\\lambda_5 = 1.60 \\times 10^{8}, \\quad\n\\lambda_6 = 3.60 \\times 10^{8}, \\quad\n\\lambda_7 = 6.25 \\times 10^{8}, \\quad\n\\lambda_8 = 9.00 \\times 10^{8},\n$$\n并取 $r=5$，计算比率\n$$\nR \\equiv \\frac{\\Delta t_{\\text{max,ROM}}}{\\Delta t_{\\text{max,FOM}}}.\n$$\n将 $R$ 作为无量纲数报告，并四舍五入到四位有效数字。", "solution": "问题要求推导应用于二阶线性系统的显式中心差分时间积分格式的稳定性条件，首先是针对全阶模型（FOM），然后是针对降阶模型（ROM）。随后，需要计算ROM和FOM的最大允许时间步长之比。\n\n全阶半离散系统由下式给出：\n$$\nM \\, \\ddot{u}(t) + K \\, u(t) = 0\n$$\n其中 $M$ 是对称正定的，$K$ 是对称半正定的。\n\n显式中心差分格式将时间步 $t_n$ 处的二阶时间导数近似为：\n$$\n\\ddot{u}(t_n) \\approx \\frac{u_{n+1} - 2u_n + u_{n-1}}{(\\Delta t)^2}\n$$\n其中 $u_n \\equiv u(t_n)$，$\\Delta t$ 是时间步长。将此代入控制方程，得到离散时间更新规则：\n$$\nM \\left( \\frac{u_{n+1} - 2u_n + u_{n-1}}{(\\Delta t)^2} \\right) + K u_n = 0\n$$\n为分析此格式的稳定性，我们进行模态分析。解 $u(t)$ 可以表示为广义特征向量 $\\phi_i$ 的线性组合：\n$$\nu(t) = \\sum_{i=1}^{N} \\eta_i(t) \\phi_i\n$$\n其中 $\\eta_i(t)$ 是模态坐标。将此模态展开式代入原方程得到：\n$$\nM \\sum_{i=1}^{N} \\ddot{\\eta}_i(t) \\phi_i + K \\sum_{i=1}^{N} \\eta_i(t) \\phi_i = 0\n$$\n左乘一个特征向量的转置 $\\phi_j^{\\top}$ 得到：\n$$\n\\sum_{i=1}^{N} \\ddot{\\eta}_i(t) (\\phi_j^{\\top} M \\phi_i) + \\sum_{i=1}^{N} \\eta_i(t) (\\phi_j^{\\top} K \\phi_i) = 0\n$$\n使用给定的 $M$-正交归一条件 $\\phi_j^{\\top} M \\phi_i = \\delta_{ij}$ 和广义特征问题的定义 $K \\phi_i = \\lambda_i M \\phi_i$（这意味着 $\\phi_j^{\\top} K \\phi_i = \\lambda_i \\phi_j^{\\top} M \\phi_i = \\lambda_i \\delta_{ij}$），系统解耦为 $N$ 个独立的标量方程：\n$$\n\\ddot{\\eta}_j(t) + \\lambda_j \\eta_j(t) = 0, \\quad j=1, \\dots, N\n$$\n第 $j$ 阶模态的自然频率是 $\\omega_j = \\sqrt{\\lambda_j}$。将中心差分格式应用于此标量模态方程，得到：\n$$\n\\frac{\\eta_{j, n+1} - 2\\eta_{j, n} + \\eta_{j, n-1}}{(\\Delta t)^2} + \\lambda_j \\eta_{j, n} = 0\n$$\n这可以重写为一个线性递推关系：\n$$\n\\eta_{j, n+1} - (2 - \\lambda_j (\\Delta t)^2) \\eta_{j, n} + \\eta_{j, n-1} = 0\n$$\n为使数值解稳定（即不无界增长），此递推关系的特征多项式的根的模必须小于或等于 $1$。假设解的形式为 $\\eta_{j,n} = G^n$，我们得到特征方程：\n$$\nG^2 - (2 - \\lambda_j (\\Delta t)^2) G + 1 = 0\n$$\n为了使根 $G$ 的模 $|G| \\le 1$，该二次方程的判别式必须为非正，这确保了根是单位圆上的共轭复数。\n$$\n(2 - \\lambda_j (\\Delta t)^2)^2 - 4 \\le 0\n$$\n这个不等式等价于：\n$$\n-2 \\le 2 - \\lambda_j (\\Delta t)^2 \\le 2\n$$\n右边的不等式 $2 - \\lambda_j (\\Delta t)^2 \\le 2$ 意味着 $-\\lambda_j (\\Delta t)^2 \\le 0$，因为 $\\lambda_j > 0$，所以这总是成立的。左边的不等式施加了稳定性约束：\n$$\n-2 \\le 2 - \\lambda_j (\\Delta t)^2 \\implies \\lambda_j (\\Delta t)^2 \\le 4\n$$\n这个条件必须对所有模态都成立，因此它由最大特征值 $\\lambda_N$ 决定：\n$$\n\\lambda_N (\\Delta t)^2 \\le 4 \\implies \\Delta t \\le \\frac{2}{\\sqrt{\\lambda_N}}\n$$\n因此，全阶模型（FOM）的最大稳定时间步长是：\n$$\n\\Delta t_{\\text{max,FOM}} = \\frac{2}{\\sqrt{\\lambda_N}}\n$$\n现在，我们考虑降阶模型（ROM）。ROM是通过伽辽金投影到由前 $r$ 个特征向量 $V = [\\phi_1, \\dots, \\phi_r]$ 张成的子空间上构建的。降阶系统是：\n$$\nM_r \\ddot{q}(t) + K_r q(t) = 0\n$$\n其中 $M_r = V^{\\top} M V$ 和 $K_r = V^{\\top} K V$。基于特征向量的 $M$-正交归一性，降阶质量矩阵是大小为 $r$ 的单位矩阵：\n$$\n(M_r)_{ij} = \\phi_i^{\\top} M \\phi_j = \\delta_{ij} \\implies M_r = I_r\n$$\n降阶刚度矩阵 $K_r$ 变为对角矩阵：\n$$\n(K_r)_{ij} = \\phi_i^{\\top} K \\phi_j = \\phi_i^{\\top} (\\lambda_j M \\phi_j) = \\lambda_j (\\phi_i^{\\top} M \\phi_j) = \\lambda_j \\delta_{ij}\n$$\n所以，$K_r = \\text{diag}(\\lambda_1, \\dots, \\lambda_r)$。降阶系统已经解耦：\n$$\nI_r \\ddot{q}(t) + \\text{diag}(\\lambda_1, \\dots, \\lambda_r) q(t) = 0\n$$\n这对应于 $r$ 个标量方程：\n$$\n\\ddot{q}_i(t) + \\lambda_i q_i(t) = 0, \\quad i=1, \\dots, r\n$$\nROM的稳定性分析与FOM的单个模态的稳定性分析相同。稳定性条件必须对所有保留的模态都成立，因此它受限于保留的最大特征值 $\\lambda_r$：\n$$\n\\lambda_r (\\Delta t)^2 \\le 4 \\implies \\Delta t \\le \\frac{2}{\\sqrt{\\lambda_r}}\n$$\nROM的最大稳定时间步长是：\n$$\n\\Delta t_{\\text{max,ROM}} = \\frac{2}{\\sqrt{\\lambda_r}}\n$$\n我们被要求计算比率 $R \\equiv \\frac{\\Delta t_{\\text{max,ROM}}}{\\Delta t_{\\text{max,FOM}}}$。\n$$\nR = \\frac{2 / \\sqrt{\\lambda_r}}{2 / \\sqrt{\\lambda_N}} = \\sqrt{\\frac{\\lambda_N}{\\lambda_r}}\n$$\n问题提供了一个包含8个特征值的列表，这意味着全阶模型的维度为 $N=8$。最大特征值是 $\\lambda_N = \\lambda_8 = 9.00 \\times 10^8$。ROM是用 $r=5$ 构建的，因此保留的最大特征值是 $\\lambda_r = \\lambda_5 = 1.60 \\times 10^8$。\n\n将这些值代入 $R$ 的表达式中：\n$$\nR = \\sqrt{\\frac{9.00 \\times 10^8}{1.60 \\times 10^8}} = \\sqrt{\\frac{9.00}{1.60}} = \\sqrt{5.625}\n$$\n计算数值：\n$$\nR \\approx 2.371708245...\n$$\n四舍五入到四位有效数字，我们得到 $R = 2.372$。", "answer": "$$\n\\boxed{2.372}\n$$", "id": "3555710"}, {"introduction": "在工程实践中，我们常需要构建参数化代理模型，使其在一系列输入参数范围内都保持准确。本练习将超越简单的数据压缩，介绍一种更智能的基构建方法。我们将通过寻找当前代理模型最不准确的参数点，来迭代地、有策略地构建一个高效且有针对性的降阶基，这一方法被称为“贪心算法”(greedy algorithm)。[@problem_id:3555733]", "problem": "考虑一个在一维闭区间 $[0,1]$ 上的无量纲稳态孔隙压力扩散问题，该问题由质量守恒和达西定律控制。设孔隙压力场为 $p(x;\\mu)$，空间变化的无量纲渗透率 $k(x;\\mu)$ 依赖于标量参数 $ \\mu \\in [-0.9,0.9] $。控制方程为二阶线性椭圆边值问题\n$$\n-\\frac{d}{dx}\\left(k(x;\\mu)\\frac{dp}{dx}(x;\\mu)\\right) = s(x),\n$$\n边界条件为狄利克雷边界条件 $p(0;\\mu) = p_L$ 和 $p(1;\\mu) = p_R$，其中所有量均为无量纲。假设渗透率由下式给出\n$$\nk(x;\\mu) = \\exp\\big(\\mu \\sin(2\\pi x)\\big),\n$$\n源项规定为\n$$\ns(x) = s_0 \\cos(2\\pi x),\n$$\n其中 $s_0$ 是一个无量纲振幅。\n\n将域离散为 $N$ 个等距节点，间距为 $ \\Delta x = 1/(N-1) $，并使用算術平均法近似半节点处的通量。对于内部节点 $i = 2,\\dots,N-1$（使用基于1的索引），定义 $k_{i+\\frac{1}{2}} = (k_i + k_{i+1})/2$ 和 $k_{i-\\frac{1}{2}} = (k_i + k_{i-1})/2$，并强制执行离散平衡\n$$\n\\frac{1}{\\Delta x^2}\\Big( k_{i+\\frac{1}{2}}\\,p_{i+1} - \\big(k_{i+\\frac{1}{2}} + k_{i-\\frac{1}{2}}\\big)\\,p_i + k_{i-\\frac{1}{2}}\\,p_{i-1} \\Big) = s_i,\n$$\n边界条件为 $p_1 = p_L$ 和 $p_N = p_R$。对于每个参数 $ \\mu $，这将产生一个线性系统 $A(\\mu)\\,p(\\mu) = b(\\mu)$。\n\n通过将解表示为 $p^r(x;\\mu) = g(x) + u^r(x;\\mu)$ 来构建降阶基 (RB) 代理模型，其中 $g(x)$ 是满足 $g(0) = p_L$ 和 $g(1) = p_R$ 的任意函数，$u^r(x;\\mu)$ 在一个基 $V$ 中展开，该基的列向量在两个边界处均为零。使用伽辽金投影到 $V$ 的生成空间上，通过求解以下方程来计算 $u^r(\\mu)$\n$$\nV^\\top A(\\mu) V\\, a(\\mu) = V^\\top\\big(b(\\mu) - A(\\mu) g\\big), \\quad u^r(\\mu) = V a(\\mu).\n$$\n将残差定义为 $r(\\mu) = A(\\mu)\\,p^r(\\mu) - b(\\mu)$。\n\n实现一种由基于残差的误差估计器驱动的贪心快照选择策略，该估计器针对关键节点位置的孔隙压力。设训练参数集为 $ \\{\\mu_j\\}_{j=1}^{M} $，包含 $M$ 个在 $[-0.9,0.9]$ 上均匀分布的点。给定一组关键位置 $ \\{x_c\\} $，定义一个对角权重向量 $w \\in \\mathbb{R}^N$，其元素 $w_i$ 会显著增加与关键位置及其紧邻邻居相关的离散方程所对应的行上的残差贡献。使用加权残差范数\n$$\n\\varepsilon(\\mu) = \\left( \\sum_{i=1}^{N} w_i\\, r_i(\\mu)^2 \\right)^{1/2}\n$$\n作为贪心选择标准：在每次贪心迭代中，将剩余训练参数中使 $ \\varepsilon(\\mu) $ 最大化的参数 $ \\mu $ 处的快照添加到基中。\n\n作为基准，实现均匀快照选择，即在 $[-0.9,0.9]$ 上均匀间隔的 $r$ 个参数处获取 $r$ 个快照。\n\n对于贪心和均匀策略，在测试参数集上评估代理模型，并报告在指定关键节点位置处孔隙压力的平均绝对误差，该误差在所有测试参数上取平均值。\n\n所有量均为无量纲，所有计算必须使用上述有限差分格式进行。降阶基必须对波动场 $u^r$ 在边界节点处强制为零值。必须使用算术平均法计算 $k_{i\\pm\\frac{1}{2}}$。\n\n您的程序必须实现以下三个测试用例，每个用例都指定了问题大小、边界数据、源振幅、降阶基大小、关键位置、训练集和测试集，具体如下：\n\n- 测试用例 A（一般情况）：\n    - 网格大小：$N = 50$。\n    - 边界值：$p_L = 1.0$, $p_R = 0.0$。\n    - 源振幅：$s_0 = 0.2$。\n    - 降阶基大小：$r = 5$。\n    - 关键位置：$x_c \\in \\{0.3, 0.7\\}$。\n    - 训练集：$M = 21$ 个在 $[-0.9, 0.9]$ 上均匀分布的参数。\n    - 测试参数：$\\{-0.9, -0.45, 0.0, 0.45, 0.9\\}$。\n\n- 测试用例 B（边界主导情况，无源项）：\n    - 网格大小：$N = 80$。\n    - 边界值：$p_L = -1.0$, $p_R = 1.0$。\n    - 源振幅：$s_0 = 0.0$。\n    - 降阶基大小：$r = 7$。\n    - 关键位置：$x_c \\in \\{0.95\\}$。\n    - 训练集：$M = 21$ 个在 $[-0.9, 0.9]$ 上均匀分布的参数。\n    - 测试参数：$\\{-0.9, -0.45, 0.0, 0.45, 0.9\\}$。\n\n- 测试用例 C（源主导情况，边界值相等）：\n    - 网格大小：$N = 100$。\n    - 边界值：$p_L = 0.5$, $p_R = 0.5$。\n    - 源振幅：$s_0 = 0.3$。\n    - 降阶基大小：$r = 6$。\n    - 关键位置：$x_c \\in \\{0.5\\}$。\n    - 训练集：$M = 21$ 个在 $[-0.9, 0.9]$ 上均匀分布的参数。\n    - 测试参数：$\\{-0.9, -0.45, 0.0, 0.45, 0.9\\}$。\n\n对于目标性基于残差的误差估计器，权重 $w_i$ 在各处均等于 $1$，但在对应于关键位置的行处，$w_i$ 必须设置为一个大值 $ \\alpha $，在其紧邻邻居处，$w_i$ 必须设置为 $ \\alpha/2 $。使用 $ \\alpha = 50 $。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，列表包含六个四舍五入到六位小数的浮点数，分别对应于测试用例 A、测试用例 B 和测试用例 C 中，在测试参数上贪心策略和均匀策略在关键位置的平均绝对误差，顺序如下\n$$\n[\\text{err}_{A,\\mathrm{greedy}}, \\text{err}_{A,\\mathrm{uniform}}, \\text{err}_{B,\\mathrm{greedy}}, \\text{err}_{B,\\mathrm{uniform}}, \\text{err}_{C,\\mathrm{greedy}}, \\text{err}_{C,\\mathrm{uniform}}].\n$$", "solution": "该问题被认为是有效的，因为它具有科学依据、良定性、客观性和内部一致性。它代表了计算岩土力学领域的一个标准练习，特别关注于参数化偏微分方程的降阶建模。\n\n### 1. 问题阐述与离散化\n\n物理问题是定义在域 $x \\in [0, 1]$ 上的一个一维稳态孔隙压力扩散方程。控制方程是一个二阶线性椭圆偏微分方程 (PDE)：\n$$\n-\\frac{d}{dx}\\left(k(x;\\mu)\\frac{dp}{dx}(x;\\mu)\\right) = s(x)\n$$\n此处，$p(x;\\mu)$ 是孔隙压力，它依赖于空间坐标 $x$ 和一个标量参数 $\\mu$。渗透率 $k(x;\\mu) = \\exp\\big(\\mu \\sin(2\\pi x)\\big)$ 是一个空间非均匀函数，同样依赖于 $\\mu \\in [-0.9, 0.9]$。源项是 $s(x) = s_0 \\cos(2\\pi x)$，并施加了狄利克雷边界条件：$p(0;\\mu) = p_L$ 和 $p(1;\\mu) = p_R$。\n\n为数值求解此问题，我们在一个由 $N$ 个节点 $x_i = (i-1)\\Delta x$（对于 $i=1,\\dots,N$，使用基于1的索引）组成的均匀网格上采用有限差分法，其中网格间距为 $\\Delta x = 1/(N-1)$。问题为任意内部节点 $i=2,\\dots,N-1$ 指定了离散平衡方程：\n$$\n\\frac{1}{\\Delta x^2}\\Big( k_{i+\\frac{1}{2}}\\,p_{i+1} - \\big(k_{i+\\frac{1}{2}} + k_{i-\\frac{1}{2}}\\big)\\,p_i + k_{i-\\frac{1}{2}}\\,p_{i-1} \\Big) = s_i\n$$\n其中 $p_i$ 是 $p(x_i;\\mu)$ 的近似值，$s_i = s(x_i)$。节点间的渗透率通过算术平均计算：$k_{i\\pm\\frac{1}{2}} = (k_i + k_{i\\pm 1})/2$。\n\n### 2. 全阶模型 (FOM)\n\n内部节点的离散方程与边界条件 $p_1 = p_L$ 和 $p_N = p_R$ 相结合，构成一个包含 $N$ 个线性代数方程的方程组。该系统可写为矩阵形式：\n$$\nA(\\mu)\\,p(\\mu) = b(\\mu)\n$$\n其中 $p(\\mu) \\in \\mathbb{R}^N$ 是节点压力向量，$A(\\mu) \\in \\mathbb{R}^{N \\times N}$ 是系统矩阵，$b(\\mu) \\in \\mathbb{R}^N$ 是右端向量。为便于实现，使用基于0的索引（节点 $i=0,\\dots,N-1$），矩阵 $A(\\mu)$ 和向量 $b(\\mu)$ 的构建如下：\n\n对于边界节点：\n- 第 $i=0$ 行：$A_{0,0} = 1$，所有其他 $A_{0,j}=0$。对应的右端项是 $b_0 = p_L$。\n- 第 $i=N-1$ 行：$A_{N-1,N-1} = 1$，所有其他 $A_{N-1,j}=0$。对应的右端项是 $b_{N-1} = p_R$。\n\n对于内部节点 $i=1,\\dots,N-2$：\n- $A_{i,i-1} = \\frac{k_{i-1/2}}{\\Delta x^2} = \\frac{k_{i-1} + k_i}{2\\Delta x^2}$\n- $A_{i,i} = -\\frac{k_{i-1/2} + k_{i+1/2}}{\\Delta x^2} = -\\frac{k_{i-1} + 2k_i + k_{i+1}}{2\\Delta x^2}$\n- $A_{i,i+1} = \\frac{k_{i+1/2}}{\\Delta x^2} = \\frac{k_i + k_{i+1}}{2\\Delta x^2}$\n- 所有其他 $A_{i,j}=0$。右端项是 $b_i = s_i = s_0 \\cos(2\\pi x_i)$。\n\n对于任意给定的参数 $\\mu$，可以求解此线性系统以获得高保真或“真值”解，我们称之为全阶模型 (FOM) 解。\n\n### 3. 通过伽辽金投影的降阶模型 (ROM)\n\n降阶基方法的核心思想是找到一个低维子空间，该子空间能有效捕捉解流形 $\\{p(\\mu) \\mid \\mu \\in [-0.9, 0.9]\\}$ 的行为。为处理非齐次边界条件，将解分解为：\n$$\np^r(x;\\mu) = g(x) + u^r(x;\\mu)\n$$\n其中 $g(x)$ 是一个满足边界条件的“提升”函数，即 $g(0) = p_L$ 和 $g(1) = p_R$。一个简单的线性函数 $g(x) = p_L + (p_R - p_L)x$ 即可。波动场 $u^r(x;\\mu)$ 则具有齐次边界条件，$u^r(0;\\mu) = u^r(1;\\mu) = 0$。\n\n场 $u^r(\\mu)$ 被近似为基向量的线性组合，这些基向量存储在矩阵 $V \\in \\mathbb{R}^{N \\times r}$ 的列中，其中 $r \\ll N$：\n$$\nu^r(\\mu) = V a(\\mu)\n$$\n$V$ 的列是标准正交的，并且在边界节点处为零，从而确保 $u^r(\\mu)$ 满足其齐次边界条件。向量 $a(\\mu) \\in \\mathbb{R}^r$ 包含未知系数。\n\n将 ROM 近似代入 FOM 系统，得到残差 $r(\\mu) = A(\\mu)(g+Va(\\mu)) - b(\\mu)$。伽辽金投影法要求此残差与基子空间正交，即 $V^\\top r(\\mu)=0$。这导出了一个用于求解系数 $a(\\mu)$ 的规模小得多的线性系统：\n$$\nV^\\top A(\\mu) V a(\\mu) = V^\\top (b(\\mu) - A(\\mu)g)\n$$\n这是一个大小为 $r \\times r$ 的降阶系统。求解 $a(\\mu)$ 并重构解在计算上比求解原始的 $N \\times N$ FOM 系统要廉价得多。\n\n### 4. 基构造策略\n\nROM 的质量在很大程度上取决于基 $V$ 的选择。我们实现并比较两种策略。\n\n#### 4.1. 均匀快照选择\n这是一种直接的方法，其中基是根据在预选参数值处的解来构造的。我们在区间 $[-0.9, 0.9]$ 中均匀选择 $r$ 个参数 $\\{\\mu_j\\}_{j=1}^r$。对于每个 $\\mu_j$，我们计算 FOM 解 $p(\\mu_j)$，得到波动部分 $u_j = p(\\mu_j) - g$，并收集这些“快照”。然后将快照集 $\\{u_j\\}_{j=1}^r$ 正交化（例如，使用 QR 分解）以形成标准正交基 $V$。\n\n#### 4.2. 贪心快照选择\n这是一种自适应策略，旨在构建一个更优的基。它迭代地选择当前基表示效果不佳的快照。选择过程由一个基于残差的误差估计器驱动。算法流程如下：\n1.  初始化一个空基 $V$ 和一个训练参数集 $\\mathcal{M}_{train}$。\n2.  对于 $k=1, \\dots, r$：\n    a. 对于每个参数 $\\mu \\in \\mathcal{M}_{train}$，使用当前基 $V$ 计算 ROM 解 $p^r(\\mu)$。如果 $V$ 为空，则 $p^r(\\mu) = g$。\n    b. 计算 FOM 残差 $r(\\mu) = A(\\mu)p^r(\\mu) - b(\\mu)$。\n    c. 评估误差估计器，即残差的加权范数：$\\varepsilon(\\mu) = \\left( \\sum_{i=0}^{N-1} w_i\\, r_i(\\mu)^2 \\right)^{1/2}$。权重 $w_i$ 在对应于关键位置的行处设为 $\\alpha=50$，在其紧邻邻居处设为 $\\alpha/2=25$，其他地方设为 $1$。这旨在提高指定关注点处的解的精度。\n    d. 找到使误差估计器最大化的参数 $\\mu^*$：$\\mu^* = \\arg\\max_{\\mu \\in \\mathcal{M}_{train}} \\varepsilon(\\mu)$。\n    e. 计算 FOM 快照 $p(\\mu^*)$ 及其波动部分 $u^* = p(\\mu^*) - g$。\n    f. 通过将 $u^*$ 与现有基向量正交化并添加得到的归一化向量来扩充基 $V$。\n    g. 从 $\\mathcal{M}_{train}$ 中移除 $\\mu^*$。\n\n### 5. 误差评估\n\n每个 ROM 的精度在一组测试参数 $\\mathcal{M}_{test}$ 上进行评估。对于每个 $\\mu_{test} \\in \\mathcal{M}_{test}$，我们计算 ROM 解 $p^r(\\mu_{test})$ 和真实的 FOM 解 $p(\\mu_{test})$。该参数的误差是在关键节点索引集 $\\mathcal{I}_c$ 上的平均绝对差：\n$$\nE(\\mu_{test}) = \\frac{1}{|\\mathcal{I}_c|} \\sum_{i \\in \\mathcal{I}_c} |p_i(\\mu_{test}) - p^r_i(\\mu_{test})|\n$$\n最终报告的误差是这些值在所有测试参数上的平均值：\n$$\n\\text{Error} = \\frac{1}{|\\mathcal{M}_{test}|} \\sum_{\\mu_{test} \\in \\mathcal{M}_{test}} E(\\mu_{test})\n$$\n对每个测试用例，都针对贪心和均匀基选择策略执行此过程。", "answer": "```python\nimport numpy as np\n\ndef assemble_fom(N, p_L, p_R, s_0, mu):\n    \"\"\"Assembles the Full-Order Model (FOM) system A*p = b.\"\"\"\n    x = np.linspace(0.0, 1.0, N)\n    dx = 1.0 / (N - 1)\n    \n    k = np.exp(mu * np.sin(2 * np.pi * x))\n    s = s_0 * np.cos(2 * np.pi * x)\n    \n    A = np.zeros((N, N))\n    b = np.zeros(N)\n    \n    # Boundary conditions\n    A[0, 0] = 1.0\n    b[0] = p_L\n    A[N - 1, N - 1] = 1.0\n    b[N - 1] = p_R\n    \n    # Interior nodes (0-based indexing)\n    for i in range(1, N - 1):\n        k_minus_half = (k[i - 1] + k[i]) / 2.0\n        k_plus_half = (k[i] + k[i + 1]) / 2.0\n        \n        A[i, i - 1] = k_minus_half / (dx**2)\n        A[i, i] = -(k_minus_half + k_plus_half) / (dx**2)\n        A[i, i + 1] = k_plus_half / (dx**2)\n        b[i] = s[i]\n        \n    return A, b\n\ndef solve_fom(N, p_L, p_R, s_0, mu):\n    \"\"\"Solves the FOM system for a given parameter mu.\"\"\"\n    A, b = assemble_fom(N, p_L, p_R, s_0, mu)\n    p_fom = np.linalg.solve(A, b)\n    return p_fom\n\ndef get_orthonormal_basis(vectors):\n    \"\"\"Computes an orthonormal basis from a set of vectors using QR decomposition.\"\"\"\n    if not vectors:\n        return np.array([]).reshape(len(vectors[0]) if vectors else 0, 0)\n    Q, _ = np.linalg.qr(np.array(vectors).T)\n    return Q\n\ndef solve_rom(A, b, g, V):\n    \"\"\"Solves the Reduced-Order Model (ROM) for a given basis V.\"\"\"\n    if V.shape[1] == 0:\n        return g\n    \n    A_r = V.T @ A @ V\n    b_r = V.T @ (b - A @ g)\n    \n    try:\n        a = np.linalg.solve(A_r, b_r)\n    except np.linalg.LinAlgError:\n         # In case reduced matrix is singular\n        a = np.linalg.lstsq(A_r, b_r, rcond=None)[0]\n\n    u_r = V @ a\n    p_r = g + u_r\n    return p_r\n\ndef run_test_case(N, p_L, p_R, s_0, r_size, x_c, M, test_mus):\n    \"\"\"Runs a single test case for both greedy and uniform strategies.\"\"\"\n    x = np.linspace(0.0, 1.0, N)\n    dx = 1.0 / (N - 1)\n    \n    # Critical location indices\n    crit_indices = [np.argmin(np.abs(x - val)) for val in x_c]\n    \n    # Lifting function\n    g = p_L + (p_R - p_L) * x\n    \n    # Training parameters\n    train_mus = np.linspace(-0.9, 0.9, M)\n\n    # --- Greedy Strategy ---\n    V_greedy = np.zeros((N, 0))\n    greedy_mus = list(train_mus)\n    \n    w = np.ones(N)\n    alpha = 50.0\n    for idx in crit_indices:\n        w[idx] = alpha\n        if idx > 0:\n            w[idx-1] = max(w[idx-1], alpha/2.0)\n        if idx  N-1:\n            w[idx+1] = max(w[idx+1], alpha/2.0)\n            \n    for _ in range(r_size):\n        max_err = -1.0\n        best_mu = -1.0\n        \n        for mu in greedy_mus:\n            A, b = assemble_fom(N, p_L, p_R, s_0, mu)\n            p_r = solve_rom(A, b, g, V_greedy)\n            \n            # Calculate weighted residual norm\n            residual = A @ p_r - b\n            # Zero out BC rows as they are exactly satisfied by construction\n            residual[0] = 0\n            residual[-1] = 0\n            err_indicator = np.linalg.norm(np.sqrt(w) * residual)\n\n            if err_indicator > max_err:\n                max_err = err_indicator\n                best_mu = mu\n        \n        # Add snapshot for best_mu to basis\n        p_fom_best = solve_fom(N, p_L, p_R, s_0, best_mu)\n        u_new = p_fom_best - g\n        \n        # Orthogonalize and add to basis\n        proj = V_greedy @ (V_greedy.T @ u_new)\n        u_orth = u_new - proj\n        norm_u_orth = np.linalg.norm(u_orth)\n        if norm_u_orth > 1e-10:\n            V_greedy = np.c_[V_greedy, u_orth / norm_u_orth]\n        \n        greedy_mus.remove(best_mu)\n\n    # --- Uniform Strategy ---\n    uniform_mus = np.linspace(-0.9, 0.9, r_size)\n    uniform_snapshots_u = []\n    for mu in uniform_mus:\n        p_fom = solve_fom(N, p_L, p_R, s_0, mu)\n        u_snapshot = p_fom - g\n        uniform_snapshots_u.append(u_snapshot)\n    \n    V_uniform = get_orthonormal_basis(uniform_snapshots_u)\n\n    # --- Error Evaluation ---\n    def evaluate_error(V, test_mus):\n        total_abs_err = 0.0\n        for mu_test in test_mus:\n            A, b = assemble_fom(N, p_L, p_R, s_0, mu_test)\n            p_fom = solve_fom(N, p_L, p_R, s_0, mu_test)\n            p_r = solve_rom(A, b, g, V)\n            \n            abs_err_at_crit = np.abs(p_fom[crit_indices] - p_r[crit_indices])\n            mean_abs_err_per_mu = np.mean(abs_err_at_crit)\n            total_abs_err += mean_abs_err_per_mu\n\n        return total_abs_err / len(test_mus)\n\n    err_greedy = evaluate_error(V_greedy, test_mus)\n    err_uniform = evaluate_error(V_uniform, test_mus)\n\n    return err_greedy, err_uniform\n\n\ndef solve():\n    # Define test cases\n    test_cases = {\n        'A': {\n            'N': 50, 'p_L': 1.0, 'p_R': 0.0, 's_0': 0.2, 'r': 5,\n            'x_c': [0.3, 0.7], 'M': 21,\n            'test_mus': [-0.9, -0.45, 0.0, 0.45, 0.9]\n        },\n        'B': {\n            'N': 80, 'p_L': -1.0, 'p_R': 1.0, 's_0': 0.0, 'r': 7,\n            'x_c': [0.95], 'M': 21,\n            'test_mus': [-0.9, -0.45, 0.0, 0.45, 0.9]\n        },\n        'C': {\n            'N': 100, 'p_L': 0.5, 'p_R': 0.5, 's_0': 0.3, 'r': 6,\n            'x_c': [0.5], 'M': 21,\n            'test_mus': [-0.9, -0.45, 0.0, 0.45, 0.9]\n        }\n    }\n\n    results = []\n    \n    # Case A\n    params_A = test_cases['A']\n    err_A_g, err_A_u = run_test_case(\n        params_A['N'], params_A['p_L'], params_A['p_R'], params_A['s_0'],\n        params_A['r'], params_A['x_c'], params_A['M'], params_A['test_mus']\n    )\n    results.extend([err_A_g, err_A_u])\n    \n    # Case B\n    params_B = test_cases['B']\n    err_B_g, err_B_u = run_test_case(\n        params_B['N'], params_B['p_L'], params_B['p_R'], params_B['s_0'],\n        params_B['r'], params_B['x_c'], params_B['M'], params_B['test_mus']\n    )\n    results.extend([err_B_g, err_B_u])\n\n    # Case C\n    params_C = test_cases['C']\n    err_C_g, err_C_u = run_test_case(\n        params_C['N'], params_C['p_L'], params_C['p_R'], params_C['s_0'],\n        params_C['r'], params_C['x_c'], params_C['M'], params_C['test_mus']\n    )\n    results.extend([err_C_g, err_C_u])\n    \n    # Format and print the final output\n    formatted_results = [f'{res:.6f}' for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3555733"}]}