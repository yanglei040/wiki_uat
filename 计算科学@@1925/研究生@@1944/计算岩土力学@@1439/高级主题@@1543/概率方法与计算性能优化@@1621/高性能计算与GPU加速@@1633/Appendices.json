{"hands_on_practices": [{"introduction": "在有限元方法的GPU加速中，首要任务是为每个计算任务（例如，组装单元刚度矩阵）正确地分配一个独一无二的GPU线程。这个实践练习[@problem_id:3529536]将引导您完成计算所需网格维度和创建安全高效索引方案的基础过程。这构成了任何CUDA或OpenCL内核的基石。", "problem": "考虑在计算岩土力学中二维有限元方法里的并行逐单元集成步骤，该步骤在图形处理器（GPU）上，并于单指令多线程（SIMT）模型下执行。一个网格包含 $N_e$ 个三角形单元，每个单元必须由一个独立的 GPU 线程处理一次且仅一次。线程以一维块网格的形式启动：每个块包含 $B$ 个线程，网格中有 $G$ 个块，块内每个线程和网格中每个块的索引都从 $0$ 开始。启动的线程必须足以覆盖所有单元，但允许启动比单元数量更多的线程，前提是多余的线程能安全地不执行任何工作。你的任务是确定最小的网格大小和一个索引函数，该函数为每个线程至多分配一个单元，覆盖所有 $N_e$ 个单元且每个单元仅覆盖一次，并保证任何额外线程的安全性。对于每个测试用例，你的程序必须计算块的数量 $G$ 和启动的线程总数 $T$，并通过逻辑论证来验证该索引方式能将每个单元索引精确地映射到一个线程，且任何多余的线程不执行任何工作。\n\n仅使用高性能计算和计算岩土力学中 GPU 加速领域公认的基本原理：SIMT 执行模型、由整数除法算法保证的唯一性/存在性，以及基于不等式的保护条件的定义。不要依赖任何预先指定的快捷公式；从这些基础出发推导任何所需的表达式。索引是无物理单位的整数。\n\n为你的设计定义以下要求：\n- 给定 $N_e$ 和线程块大小 $B$，你必须选择与完全覆盖兼容的最小整数网格大小 $G$。\n- 你必须陈述一个从块索引 $b$ 和线程索引 $t$ 到全局索引 $g$ 的显式映射，线程将使用该全局索引来决定是否处理一个单元。\n- 你必须包含一个以不等式表示的安全保护条件，以确保对应超出范围全局索引的线程不执行任何工作。\n- 你必须使用整数除法算法来证明，在你的映射和保护条件下，每个单元索引 $e \\in \\{0,1,\\dots,N_e-1\\}$ 都被一个且仅一个有效线程映射。\n\n对于每个测试用例，你的程序必须输出一个结构为包含三个值的列表的结果：\n- $G$：最小块数（一个整数），\n- $T$：启动的线程总数，等于 $G \\cdot B$（一个整数），\n- 一个布尔标志，表明映射和保护条件是否共同确保了 $N_e$ 个单元中的每一个都被精确处理一次，并且任何全局索引会超出有效范围的线程都不执行任何工作。\n\n测试套件（使用这些确切的值）：\n- 案例 1（典型的不可整除大数值）：$N_e = 10^6$， $B = 256$。\n- 案例 2（可精确整除）：$N_e = 1024$， $B = 256$。\n- 案例 3（小于一个块的小网格）：$N_e = 10$， $B = 256$。\n- 案例 4（单线程块）：$N_e = 17$， $B = 1$。\n- 案例 5（非常大的不可整除数值）：$N_e = 10^7$， $B = 1024$。\n\n你的程序应该生成单行输出，其中包含一个逗号分隔的列表，列表被方括号包围，每个测试用例按顺序贡献一个包含三项的列表。例如，输出格式必须为\n\"[[G1,T1,ok1],[G2,T2,ok2],...]\"，在单行上，没有额外的字符或空格。所有输出都是无物理单位的整数和布尔值。", "solution": "该问题要求设计并验证一种映射方案，用于将 $N_e$ 个计算任务（单元集成）分配给图形处理器（GPU）上的线程网格。该设计必须源于并行计算的基本原理。\n\n设 $N_e$ 为网格中三角形单元的总数，索引范围为 $0$ 到 $N_e-1$。设 $B$ 为每个线程块的线程数，这是一个固定的硬件/启动参数。块内线程的索引为 $t \\in \\{0, 1, \\dots, B-1\\}$。这些块排列成一个大小为 $G$ 的一维网格，索引为 $b \\in \\{0, 1, \\dots, G-1\\}$。启动的线程总数为 $T = G \\cdot B$。\n\n主要目标是将每个单元索引 $e \\in \\{0, 1, \\dots, N_e-1\\}$ 精确地映射到一个线程，确保所有单元都得到处理。这需要定义一个全局线程索引，确定所需的最小网格大小 $G$，并为未分配到任何单元的线程建立一个安全条件。\n\n首先，我们定义一个从线程的局部标识符 $(b, t)$ 到唯一全局索引 $g$ 的映射。一个标准且有效的映射是线性的行主序：\n$$g(b, t) = b \\cdot B + t$$\n此函数将每个唯一的对 $(b, t)$ 映射到一个唯一的整数 $g$。其唯一性由整数除法算法保证。如果我们假设 $g(b_1, t_1) = g(b_2, t_2)$，那么 $b_1 B + t_1 = b_2 B + t_2$。由于 $0 \\le t_1  B$ 且 $0 \\le t_2  B$，根据除以 $B$ 时商和余数的唯一性，我们必然有 $b_1 = b_2$ 和 $t_1 = t_2$。因此，从线程标识符集合 $\\{(b,t)\\}$ 到全局索引集合 $\\{0, 1, \\dots, T-1\\}$ 的映射是一个双射。\n\n接下来，我们确定处理所有 $N_e$ 个单元所需的最小块数 $G$。最直接的分配策略是将单元 $e$ 映射到全局索引为 $g=e$ 的线程。为确保每个单元都能被分配一个线程，启动的线程总数 $T$ 必须至少为 $N_e$。\n$$T \\ge N_e$$\n代入 $T = G \\cdot B$，我们得到：\n$$G \\cdot B \\ge N_e$$\n由于 $G$ 必须是整数，我们寻求满足此不等式的最小整数 $G$。用正整数 $B$ 除此不等式，得到 $G \\ge N_e / B$。满足此条件的最小整数是除法结果的向上取整，即 $G = \\lceil N_e / B \\rceil$。\n\n由于问题要求从整数除法算法推导，我们将其形式化。令 $N_e = qB + r$，其中 $q$ 和 $r$ 是整数，且 $0 \\le r  B$。\n- 如果可以整除（$r=0$），则 $N_e = qB$。这 $N_e$ 个单元可以完美地分配给 $q$ 个块。因此，最小块数为 $G=q = N_e/B$。\n- 如果不能整除（$r0$），则 $q$ 个满块可以处理 $qB$ 个单元。剩下的 $r$ 个单元（$1 \\le r \\le B-1$）需要一个额外的块来处理。因此，总块数为 $G = q+1$。\n\n这两种情况可以使用整数算术统一成一个表达式，这也是它在代码中的实现方式。对于正整数 $x, y$，向上取整运算 $\\lceil x/y \\rceil$ 可以通过 $(x + y - 1) // y$ 来计算，其中 `//` 表示整数除法（即舍弃余数）。\n让我们验证这个公式：$G = (N_e + B - 1) // B$。\n令 $N_e = qB + r$，其中 $0 \\le r  B$。\n$$ G = \\left\\lfloor \\frac{N_e + B - 1}{B} \\right\\rfloor = \\left\\lfloor \\frac{qB + r + B - 1}{B} \\right\\rfloor = \\left\\lfloor q + 1 + \\frac{r-1}{B} \\right\\rfloor = q + 1 + \\left\\lfloor \\frac{r-1}{B} \\right\\rfloor $$\n- 如果 $r=0$，那么 $\\lfloor \\frac{-1}{B} \\rfloor = -1$（因为 $B \\ge 1$），所以 $G = q + 1 - 1 = q$。这是正确的。\n- 如果 $r0$，那么 $1 \\le r \\le B-1$，这意味着 $0 \\le r-1 \\le B-2$。因此，$0 \\le \\frac{r-1}{B}  1$，并且 $\\lfloor \\frac{r-1}{B} \\rfloor = 0$。这得出 $G = q + 1 + 0 = q+1$。这也是正确的。\n因此，最小网格大小由 $G = (N_e + B - 1) // B$ 正确给出。启动的线程总数为 $T = G \\cdot B$。\n\n当 $T \\ge N_e$ 时，某些线程的全局索引 $g$ 可能大于或等于 $N_e$。这些线程是多余的，必须不执行任何工作。这通过一个安全保护条件来实现。每个线程计算其全局索引 $g = bB+t$，并且只有当其索引对应于一个有效的单元索引时才继续执行其任务。该条件是：\n$$g  N_e$$\n全局索引为 $g$ 的线程被分配处理单元 $e=g$。如果 $g \\ge N_e$，则条件为假，该线程将安全地终止此任务的执行路径。\n\n最后，我们必须证明该方案能对每个单元 $e \\in \\{0, 1, \\dots, N_e-1\\}$ 精确处理一次。\n1.  **存在性与唯一性**：对于任何单元索引 $e$，整数除法算法指出，存在唯一的整数 $q$ 和 $r$ 使得 $e = q \\cdot B + r$ 且 $0 \\le r  B$。我们可以通过设置其块索引 $b=q$ 和其块内线程索引 $t=r$ 来唯一地识别一个线程。因此，对于每个单元 $e$，有且仅有一对 $(b,t)$ 能通过全局索引公式 $g = bB+t=e$ 生成它。\n\n2.  **完备性**：我们必须证明为单元 $e$ 标识的线程 $(b,t)$ 确实被启动了。启动的块的索引范围是从 $0$ 到 $G-1$。单元 $e$ 的块索引是 $b = e // B = \\lfloor e/B \\rfloor$。由于 $e  N_e$，可推得 $e/B  N_e/B$。因为 $b$ 是整数，我们有 $b = \\lfloor e/B \\rfloor \\le e/B  N_e/B \\le \\lceil N_e/B \\rceil = G$。因为 $b$ 和 $G$ 都是整数，所以 $b  G$ 严格成立。这证实了负责单元 $e$ 的线程所在的块总是在 $G$ 个已启动块的网格之内。\n\n3.  **正确性与安全性**：负责单元 $e$ 的线程 $(b,t)$ 计算其全局索引 $g=e$。安全检查是 $g  N_e$。因为我们是从一个满足 $e  N_e$ 的单元 $e$ 开始的，所以对于分配给有效单元的线程，这个条件总是为真。反之，任何计算出的全局索引 $g$ 满足 $g \\ge N_e$ 的线程将无法通过检查，并且不执行任何工作。\n\n这样就完成了推导和证明。该方案保证了 $N_e$ 个单元中的每一个都由一个且仅一个线程处理，并且所有多余的线程都保持空闲。因此，输出中要求的布尔标志对于所有测试用例都将是 `True`，因为该逻辑在构造上是健全的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates GPU grid parameters for a set of test cases based on\n    first principles of thread-to-task mapping.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (Ne, B), where Ne is the number of elements\n    # and B is the block size (threads per block).\n    test_cases = [\n        (10**6, 256),\n        (1024, 256),\n        (10, 256),\n        (17, 1),\n        (10**7, 1024),\n    ]\n\n    results = []\n    for Ne, B in test_cases:\n        # 1. Calculate the minimal number of blocks (G).\n        # The number of blocks G must be large enough such that G * B >= Ne.\n        # The smallest integer G satisfying this is ceil(Ne / B).\n        # In integer arithmetic, this is equivalent to (Ne + B - 1) // B.\n        # This formula is derived from the properties of integer division\n        # and correctly handles both divisible and non-divisible cases.\n        G = (Ne + B - 1) // B\n\n        # 2. Calculate the total number of launched threads (T).\n        # This is the product of the number of blocks and the threads per block.\n        T = G * B\n\n        # 3. Verify the correctness of the mapping.\n        # The mapping g = b*B + t and the guard condition g  Ne ensure\n        # that for every element index e in [0, Ne-1], exactly one thread\n        # (with g = e) will process it. This is guaranteed by the\n        # uniqueness property of the integer division algorithm. Any thread with\n        # g >= Ne will not perform work due to the guard. Thus, the logic\n        # is always correct by construction.\n        is_correct = True\n\n        results.append([G, T, is_correct])\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists,\n    # with no whitespace between elements.\n    # e.g., \"[[G1,T1,True],[G2,T2,True]]\"\n    result_strings = [f\"[{g},{t},{str(ok).lower()}]\" for g, t, ok in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3529536"}, {"introduction": "仅仅启动正确数量的线程只是开始；实现高性能还需要理解这些线程如何利用GPU的硬件资源。这个实践练习[@problem_id:3529483]深入探讨了“占用率” (occupancy) 这一核心概念。您将分析一个内核对寄存器和共享内存等资源的需求，如何决定了可以并发运行的线程数量，这直接影响GPU隐藏内存延迟和最大化计算吞吐量的能力。", "problem": "一个用于大规模盆地模型的三维多孔弹性有限元组装内核被移植到图形处理单元（GPU）上，以加速单元级刚度和耦合矩阵的计算。每个线程更新一个高斯点状态，并在进行 warp 同步归约之前在共享内存中累积贡献。由于本构更新和张量代数，该内核每个线程使用 $R_{t}=64$ 个寄存器。每个块的暂存器（scratchpad）保存形函数梯度、局部矩阵和累加器，每个块需要 $S_{b}=48\\ \\mathrm{kB}$ 的共享内存。该 GPU 每个流式多处理器（SM）的资源限制为：每个 SM 最多 $R_{\\max}=64\\times 1024$ 个寄存器，每个 SM 最多 $S_{\\max}=100\\ \\mathrm{kB}$ 共享内存，以及每个 SM 最多 $T_{\\max}=2048$ 个线程。假设线程以大小为 $W=32$ 的线程束（warp）进行调度，并且内核以每个块 $B_{t}=256$ 个线程启动。假设每个 SM 上并发块的架构上限足够大，对此内核不构成限制，并且资源分配除了所述数量外没有额外的粒度开销。使用 $1\\ \\mathrm{kB}=1024\\ \\mathrm{B}$。\n\n仅使用以下基本资源约束：(i) 一个 SM 上所有驻留块使用的总寄存器数不能超过 $R_{\\max}$，(ii) 一个 SM 上所有驻留块使用的总共享内存不能超过 $S_{\\max}$，以及 (iii) 一个 SM 上的总驻留线程数不能超过 $T_{\\max}$，计算每个 SM 的最大驻留块数和由此产生的占用率。将占用率定义为活动线程束与每个 SM 上最大可能线程束的比率，并将占用率表示为精确的小数形式。以以下顺序提供您的最终答案，包含两个值：每个 SM 的最大驻留块数，占用率。不需要四舍五入，最终答案中不应包含任何单位。", "solution": "问题陈述已经过严格验证，被认为是科学合理的、定义明确的、客观的和完整的。确定 GPU 流式多处理器（SM）上最大驻留块数和由此产生的占用率所需的所有必要参数均已提供。该问题是 GPU 性能分析中的一个标准练习，其背景是一个合理的计算地球力学情境。\n\n目标是计算每个 SM 的最大并发块数（表示为 $N_{B, \\text{max}}$）和相应的理论占用率 $\\mathcal{O}$。最大块数受到 SM 有限资源的限制，即寄存器、共享内存和线程调度能力。我们必须分别计算每种资源支持的最大块数，然后将这些值中的最小值确定为总的最大值。\n\n问题中给出的已知条件是：\n- 每个线程的寄存器数：$R_{t} = 64$\n- 每个块的共享内存：$S_{b} = 48\\ \\mathrm{kB}$\n- 每个块的线程数：$B_{t} = 256$\n- 每个 SM 的最大寄存器数：$R_{\\max} = 64 \\times 1024 = 65536$\n- 每个 SM 的最大共享内存：$S_{\\max} = 100\\ \\mathrm{kB}$\n- 每个 SM 的最大线程数：$T_{\\max} = 2048$\n- 线程束大小：$W = 32$\n\n设 $N_B$ 为单个 SM 上的驻留块数。\n\n首先，我们确定可用寄存器总数对 $N_B$ 的限制。一个块所需的总寄存器数是每个块的线程数与每个线程的寄存器数的乘积：\n$$R_{\\text{block}} = B_{t} \\times R_{t} = 256 \\times 64 = 16384\\ \\text{registers}$$\n$N_B$ 个块所需的总寄存器数为 $N_B \\times R_{\\text{block}}$。这不能超过 SM 的寄存器容量 $R_{\\max}$。\n$$N_B \\times R_{\\text{block}} \\le R_{\\max}$$\n因此，寄存器文件支持的最大块数 $N_{B, \\text{reg}}$ 为：\n$$N_{B, \\text{reg}} = \\left\\lfloor \\frac{R_{\\max}}{R_{\\text{block}}} \\right\\rfloor = \\left\\lfloor \\frac{65536}{16384} \\right\\rfloor = \\lfloor 4 \\rfloor = 4$$\n\n其次，我们确定共享内存容量施加的限制。每个块需要 $S_b = 48\\ \\mathrm{kB}$。$N_B$ 个块所需的总共享内存为 $N_B \\times S_b$。这不能超过 SM 的共享内存容量 $S_{\\max}$。\n$$N_B \\times S_b \\le S_{\\max}$$\n共享内存支持的最大块数 $N_{B, \\text{smem}}$ 为：\n$$N_{B, \\text{smem}} = \\left\\lfloor \\frac{S_{\\max}}{S_b} \\right\\rfloor = \\left\\lfloor \\frac{100\\ \\mathrm{kB}}{48\\ \\mathrm{kB}} \\right\\rfloor = \\lfloor 2.0833... \\rfloor = 2$$\n\n第三，我们确定最大驻留线程数施加的限制。每个块包含 $B_t = 256$ 个线程。$N_B$ 个块的总线程数为 $N_B \\times B_t$。这不能超过 SM 的线程容量 $T_{\\max}$。\n$$N_B \\times B_t \\le T_{\\max}$$\n线程调度器支持的最大块数 $N_{B, \\text{threads}}$ 为：\n$$N_{B, \\text{threads}} = \\left\\lfloor \\frac{T_{\\max}}{B_t} \\right\\rfloor = \\left\\lfloor \\frac{2048}{256} \\right\\rfloor = \\lfloor 8 \\rfloor = 8$$\n\n每个 SM 的总最大驻留块数 $N_{B, \\text{max}}$ 是这三个限制中的最小值，因为所有约束必须同时满足。问题陈述指出，每个 SM 的块的架构上限是非限制性的。\n$$N_{B, \\text{max}} = \\min(N_{B, \\text{reg}}, N_{B, \\text{smem}}, N_{B, \\text{threads}}) = \\min(4, 2, 8) = 2$$\n因此，最多可以有 $2$ 个块驻留在 SM 上，限制资源是共享内存。\n\n接下来，我们计算占用率 $\\mathcal{O}$。占用率定义为活动线程束与每个 SM 上最大可能线程束的比率。\n$N_{B, \\text{max}}$ 个块的活动线程数为：\n$$T_{\\text{active}} = N_{B, \\text{max}} \\times B_t = 2 \\times 256 = 512\\ \\text{threads}$$\n活动线程束的数量是活动线程数除以线程束大小 $W$：\n$$W_{\\text{active}} = \\frac{T_{\\text{active}}}{W} = \\frac{512}{32} = 16\\ \\text{warps}$$\n一个 SM 可以支持的最大线程束数是最大线程数除以线程束大小：\n$$W_{\\max} = \\frac{T_{\\max}}{W} = \\frac{2048}{32} = 64\\ \\text{warps}$$\n占用率是这两个量的比值：\n$$\\mathcal{O} = \\frac{W_{\\text{active}}}{W_{\\max}} = \\frac{16}{64} = \\frac{1}{4}$$\n或者，占用率可以直接计算为活动线程数与最大线程数的比值：\n$$\\mathcal{O} = \\frac{T_{\\text{active}}}{T_{\\max}} = \\frac{N_{B, \\text{max}} \\times B_t}{T_{\\max}} = \\frac{2 \\times 256}{2048} = \\frac{512}{2048} = \\frac{1}{4}$$\n作为小数，这个值是 $0.25$。\n\n最终结果是每个 SM 最多 2 个驻留块，占用率为 0.25。", "answer": "$$\\boxed{\\begin{pmatrix} 2  0.25 \\end{pmatrix}}$$", "id": "3529483"}]}