{"hands_on_practices": [{"introduction": "任何无网格方法的核心在于其从离散的粒子值中准确重建连续场的能力。本练习 [@problem_id:3543176] 将经典的SPH近似与经过修正的再生核粒子法(RKPM)进行直接比较。通过这个实践，您将亲身体会到SPH在边界处的“边界缺陷”问题，并理解RKPM为实现多项式再生而引入的修正思想，这是理解不同无网格方法优劣的关键一步。", "problem": "考虑一个占据域 $x \\in [0,1]$ 的一维弹性土杆，其非均匀真实正应力场由 $\\sigma_{xx}(x) = \\sigma_0 \\exp\\!\\left(-x/L\\right)$ 给出，其中 $\\sigma_0$ 是一个恒定的应力幅值，$L$ 是一个特征衰减长度。您将对此场的经典光滑粒子流体动力学 (Smoothed Particle Hydrodynamics, SPH) 近似与具有线性多项式再生的再生核粒子法 (Reproducing Kernel Particle Method, RKPM) 的插值精度进行基准测试。此任务纯粹是插值：无需求解任何运动或平衡的控制方程。$\\sigma_0$ 的单位为 $\\mathrm{kPa}$，$L$ 的单位为 $\\mathrm{m}$；所要求的输出是无单位的无量纲相对误差。\n\n您的推导和实现必须从以下基本原理出发，不得使用预先推导的捷径公式：\n\n- 标量场 $f(x)$ 的核函数近似，表示为与一个满足归一化和正性的径向对称、紧支集核函数 $W(r,h)$ 的磨光卷积，其中 $r = |x - \\xi|$，$h$ 是光滑长度。\n- 使用粒子位置 $x_j$ 处的粒子体积 $V_j$ 对域上积分的离散粒子近似。\n- 为选定的多项式基定义 RKPM 修正的多项式再生（矩）条件，确保该基的精确再生。\n\n仅使用这些基本原理，执行以下操作：\n\n- 从连续核函数近似和使用均匀粒子间距的离散求积法推导经典 SPH 粒子插值函数 $\\tilde{f}_{\\mathrm{SPH}}(x)$。除了核函数本身的归一化外，不要假设任何边界修正或重归一化。\n- 使用线性多项式基 $p(x) = [1, x]^\\top$ 和一个紧支集核函数，通过在每个计算点处的局部矩矩阵强制执行线性再生条件，来推导 RKPM 粒子插值函数 $\\tilde{f}_{\\mathrm{RKPM}}(x)$。\n- 对于两种方法，都使用相同的一维三次样条核函数，其紧支集半径为 $2h$，并一致地实现它。通过添加一个极小的对角稳定项来确保任何出现的矩阵求逆的数值稳定性，并说明您选择的理由。\n- 使用在 $[0,1]$ 上的 $N$ 个粒子的均匀节点离散化来计算，节点体积 $V_j$ 等于节点间距 $\\Delta x = 1/(N-1)$。\n\n精度评估：\n\n- 对于每个测试用例，在 $[0,1]$ 中的 $M$ 个均匀分布的采样点上评估两种插值函数，并分别计算每种方法的相对 $L^2$ 误差\n$$\n\\varepsilon = \\sqrt{\\dfrac{\\sum_{k=1}^{M}\\left(\\tilde{\\sigma}(x_k)-\\sigma_{xx}(x_k)\\right)^2}{\\sum_{k=1}^{M}\\left(\\sigma_{xx}(x_k)\\right)^2}},\n$$\n此误差是无量纲的；请将其报告为无单位的实数。\n\n测试套件：\n\n为以下 $3$ 个测试用例实现并运行您的程序。在每个用例中，域为 $[0,1]$（单位 $\\mathrm{m}$），$\\sigma_0$ 的单位为 $\\mathrm{kPa}$，光滑长度为 $h = \\alpha \\Delta x$，其中 $\\alpha$ 是指定的光滑长度与间距之比。输出是相对 $L^2$ 误差，它们是无量纲的。\n\n- 用例 $1$（理想情况，中等衰减，核函数支撑域分辨率良好）：\n  - $\\sigma_0 = 100$,\n  - $L = 0.3$,\n  - $N = 51$,\n  - $\\alpha = 2.5$,\n  - $M = 401$.\n\n- 用例 $2$（边界挑战，最小支撑域，更陡峭的衰减）：\n  - $\\sigma_0 = 100$,\n  - $L = 0.1$,\n  - $N = 51$,\n  - $\\alpha = 1.01$,\n  - $M = 401$.\n\n- 用例 $3$（高分辨率，中等支撑域，非常陡峭的衰减）：\n  - $\\sigma_0 = 100$,\n  - $L = 0.05$,\n  - $N = 201$,\n  - $\\alpha = 2.0$,\n  - $M = 1001$.\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的 $6$ 个浮点数的扁平列表。该列表必须按顺序包含每个 $3$ 个用例的经典 SPH 相对 $L^2$ 误差，后跟 RKPM 相对 $L^2$ 误差。也就是说，输出必须是以下形式\n$[\\varepsilon_{\\mathrm{SPH}}^{(1)},\\varepsilon_{\\mathrm{RKPM}}^{(1)},\\varepsilon_{\\mathrm{SPH}}^{(2)},\\varepsilon_{\\mathrm{RKPM}}^{(2)},\\varepsilon_{\\mathrm{SPH}}^{(3)},\\varepsilon_{\\mathrm{RKPM}}^{(3)}]$,\n其中每个 $\\varepsilon$ 都以浮点数形式报告，且无单位。", "solution": "该问题要求对经典光滑粒子流体动力学 (SPH) 和再生核粒子法 (RKPM) 在一维非均匀应力场下的插值精度进行比较分析。推导过程必须源于基本原理。\n\n通过核函数近似，标量场 $f(x)$ 的连续表示由以下卷积积分给出：\n$$\n\\langle f(x) \\rangle = \\int_{\\Omega} f(\\xi) W(x - \\xi, h) d\\xi\n$$\n其中 $W$ 是光滑长度为 $h$ 的核函数，$\\Omega$ 是问题域。核函数是一个对称、正值且具有紧支集的函数，对于距离边界足够远的点 $x$，满足归一化条件 $\\int_{\\Omega} W(x - \\xi, h) d\\xi = 1$。\n\n该积分使用一组 $N$ 个粒子进行离散化，这些粒子位于位置 $x_j$，具有相关联的体积 $V_j$。积分的离散近似产生了通用的粒子近似公式：\n$$\n\\tilde{f}(x) = \\sum_{j=1}^{N} f(x_j) W(x - x_j, h) V_j\n$$\n其中 $f(x_j)$ 是粒子 $j$ 处的场值。问题指定了在域 $x \\in [0, 1]$ 上的均匀粒子分布，因此粒子位置为 $x_j = (j-1)\\Delta x$，其中 $j=1, \\dots, N$，间距为 $\\Delta x = 1/(N-1)$，粒子体积为 $V_j = \\Delta x$。\n\n指定的核函数是一维三次样条核函数，其紧支集半径为 $2h$。令 $r = |x - \\xi|$ 和 $q = r/h$。核函数定义如下：\n$$\nW(r, h) = \\frac{1}{h} \\phi(q) \\quad \\text{其中} \\quad \\phi(q) = \\begin{cases} \\frac{2}{3} - q^2 + \\frac{1}{2}q^3 & 0 \\le q < 1 \\\\ \\frac{1}{6}(2-q)^3 & 1 \\le q < 2 \\\\ 0 & q \\ge 2 \\end{cases}\n$$\n因子 $1/h$ 确保了核函数在无限域中是归一化的。\n\n需要插值的场是正应力 $\\sigma_{xx}(x) = \\sigma_0 \\exp(-x/L)$。\n\n**经典SPH插值**\n\n经典SPH插值函数，表示为 $\\tilde{\\sigma}_{\\mathrm{SPH}}(x)$，是直接从粒子近似公式推导出来的，未对边界效应进行任何修正。代入给定的应力场和离散化：\n$$\n\\tilde{\\sigma}_{\\mathrm{SPH}}(x) = \\sum_{j=1}^{N} \\sigma_{xx}(x_j) W(x - x_j, h) V_j\n$$\n这种 formulations 在域的边界附近精度不足。由于核函数被边界截断，离散和 $\\sum_j W(x - x_j, h) V_j$ 不再等于 $1$，导致即使是再生一个常数函数时也会出现误差。这被称为边界缺陷或零阶一致性误差。\n\n**再生核粒子法 (RKPM) 插值**\n\nRKPM 通过修正核函数来强制精确再生一个多项式基，从而纠正此缺陷。对于此问题，需要一个线性基 $\\mathbf{p}(x) = [1, x]^\\top$。RKPM 插值函数构建如下：\n$$\n\\tilde{\\sigma}_{\\mathrm{RKPM}}(x) = \\sum_{j=1}^{N} \\Psi_j(x) \\sigma_{xx}(x_j) V_j\n$$\n其中 $\\Psi_j(x)$ 是粒子 $j$ 的修正形函数，定义为：\n$$\n\\Psi_j(x) = C(x, x-x_j) W(x-x_j, h)\n$$\n修正函数 $C(x, x-x_j)$ 是一个关于 $x_j$ 的多项式，其系数取决于计算点 $x$：\n$$\nC(x, x-x_j) = \\mathbf{b}(x)^\\top \\mathbf{p}(x_j) = b_0(x) \\cdot 1 + b_1(x) \\cdot x_j\n$$\n系数向量 $\\mathbf{b}(x) = [b_0(x), b_1(x)]^\\top$ 通过强制执行再生条件来确定。这些条件要求在基 $\\mathbf{p}(x)$ 的生成空间内的任何多项式 $P(x)$ 都能被插值格式精确地再生。这等价于满足以下矩条件：\n$$\n\\sum_{j=1}^{N} \\Psi_j(x) \\mathbf{p}(x_j)^\\top = \\mathbf{p}(x)^\\top\n$$\n代入 $\\Psi_j(x)$ 和 $C(x, x-x_j)$ 的定义：\n$$\n\\sum_{j=1}^{N} \\mathbf{b}(x)^\\top \\mathbf{p}(x_j) \\mathbf{p}(x_j)^\\top W(x-x_j, h) V_j = \\mathbf{p}(x)^\\top\n$$\n我们定义矩矩阵 $\\mathbf{M}(x)$ 为：\n$$\n\\mathbf{M}(x) = \\sum_{j=1}^{N} \\mathbf{p}(x_j) \\mathbf{p}(x_j)^\\top W(x-x_j, h) V_j\n$$\n关于 $\\mathbf{b}(x)$ 的方程组变为：\n$$\n\\mathbf{b}(x)^\\top \\mathbf{M}(x) = \\mathbf{p}(x)^\\top \\implies \\mathbf{M}(x) \\mathbf{b}(x) = \\mathbf{p}(x)\n$$\n求解 $\\mathbf{b}(x)$ 可得 $\\mathbf{b}(x) = \\mathbf{M}(x)^{-1} \\mathbf{p}(x)$。因此，修正后的形函数为：\n$$\n\\Psi_j(x) = \\mathbf{p}(x)^\\top \\mathbf{M}(x)^{-1} \\mathbf{p}(x_j) W(x-x_j, h)\n$$\n最终的 RKPM 插值函数为：\n$$\n\\tilde{\\sigma}_{\\mathrm{RKPM}}(x) = \\mathbf{p}(x)^\\top \\mathbf{M}(x)^{-1} \\sum_{j=1}^{N} \\mathbf{p}(x_j) \\sigma_{xx}(x_j) W(x-x_j, h) V_j\n$$\n对于基 $\\mathbf{p}(x) = [1, x]^\\top$，矩矩阵 $\\mathbf{M}(x)$ 是一个 $2 \\times 2$ 矩阵：\n$$\n\\mathbf{M}(x) = \\sum_{j=1}^{N} \\begin{bmatrix} 1 & x_j \\\\ x_j & x_j^2 \\end{bmatrix} W(x - x_j, h) V_j\n$$\n在边界附近，如果核函数支撑域内的粒子数量减少，$\\mathbf{M}(x)$ 可能会变得病态或奇异。为确保数值稳定性，我们通过在其对角线元素上加上一个小的正值来对矩阵进行正则化，即我们求逆 $\\mathbf{M}_{\\text{stab}}(x) = \\mathbf{M}(x) + \\epsilon \\mathbf{I}$，其中 $\\mathbf{I}$ 是单位矩阵，$\\epsilon$ 是一个小数（例如 $10^{-15}$）。这种正则化保证了可逆性，而不会显著影响良态系统的结果。\n\n**精度评估**\n\n每种方法的精度由相对 $L^2$ 误差 $\\varepsilon$ 来量化。插值函数 $\\tilde{\\sigma}_{\\mathrm{SPH}}(x)$ 和 $\\tilde{\\sigma}_{\\mathrm{RKPM}}(x)$ 在 $[0,1]$ 内的 $M$ 个均匀间隔的采样点 $x_k$ 上进行评估。然后按如下方式计算误差：\n$$\n\\varepsilon = \\sqrt{\\dfrac{\\sum_{k=1}^{M}\\left(\\tilde{\\sigma}(x_k)-\\sigma_{xx}(x_k)\\right)^2}{\\sum_{k=1}^{M}\\left(\\sigma_{xx}(x_k)\\right)^2}}\n$$\n这个无量纲的度量标准提供了在整个域上插值误差的归一化度量。对问题陈述中指定的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the benchmark for SPH and RKPM interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: (sigma0, L, N, alpha, M)\n        (100.0, 0.3, 51, 2.5, 401),\n        # Case 2:\n        (100.0, 0.1, 51, 1.01, 401),\n        # Case 3:\n        (100.0, 0.05, 201, 2.0, 1001),\n    ]\n\n    results = []\n    for sigma0, L, N, alpha, M in test_cases:\n        err_sph, err_rkpm = compute_errors(sigma0, L, N, alpha, M)\n        results.extend([err_sph, err_rkpm])\n\n    # Final print statement in the exact required format.\n    # The format string ensures standard float representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef cubic_spline_kernel(r, h):\n    \"\"\"\n    Computes the 1D cubic spline kernel value.\n    compact support radius is 2h.\n    \n    Args:\n        r (float or np.ndarray): Absolute distance |x - xi|.\n        h (float): Smoothing length.\n        \n    Returns:\n        float or np.ndarray: Kernel value W(r, h).\n    \"\"\"\n    if h == 0:\n        return 0.0\n    \n    # The kernel function works on a single value or a numpy array\n    q = np.abs(r) / h\n    \n    # Create masks for the two parts of the spline\n    mask1 = (q >= 0)  (q  1)\n    mask2 = (q >= 1)  (q  2)\n    \n    # Initialize result array of the same shape and type as q\n    val = np.zeros_like(q)\n    \n    # Apply formulas based on masks\n    if val.ndim > 0:\n        q1 = q[mask1]\n        val[mask1] = (2.0/3.0) - q1**2 + 0.5 * q1**3\n        q2 = q[mask2]\n        val[mask2] = (1.0/6.0) * (2.0 - q2)**3\n    else: # Scalar case\n        if mask1:\n            val = (2.0/3.0) - q**2 + 0.5 * q**3\n        elif mask2:\n            val = (1.0/6.0) * (2.0 - q)**3\n            \n    return val / h\n\ndef compute_errors(sigma0, L, N, alpha, M):\n    \"\"\"\n    Computes SPH and RKPM interpolated fields and their relative L2 errors.\n\n    Args:\n        sigma0 (float): Stress amplitude.\n        L (float): Characteristic decay length.\n        N (int): Number of particles.\n        alpha (float): Smoothing length to a particle spacing ratio.\n        M (int): Number of sample points for error evaluation.\n\n    Returns:\n        tuple: A tuple containing (error_sph, error_rkpm).\n    \"\"\"\n    # 1. Discretization setup\n    domain_start, domain_end = 0.0, 1.0\n    particle_pos = np.linspace(domain_start, domain_end, N)\n    delta_x = (domain_end - domain_start) / (N - 1)\n    particle_vol = delta_x\n    h = alpha * delta_x\n    \n    # 2. Field definition\n    true_stress_func = lambda x: sigma0 * np.exp(-x / L)\n    \n    particle_stress_vals = true_stress_func(particle_pos)\n    \n    sample_pos = np.linspace(domain_start, domain_end, M)\n    \n    # 3. Interpolation\n    sph_interpolated = np.zeros(M)\n    rkpm_interpolated = np.zeros(M)\n    \n    for k, x_eval in enumerate(sample_pos):\n        # Find neighboring particles (within kernel support 2h)\n        # For simplicity and given N, we iterate through all particles and check support\n        \n        sum_sph = 0.0\n        moment_matrix = np.zeros((2, 2))\n        moment_vector = np.zeros(2)\n\n        p_eval = np.array([1.0, x_eval]) # Basis vector at evaluation point\n\n        for j in range(N):\n            x_j = particle_pos[j]\n            r = np.abs(x_eval - x_j)\n            \n            if r  2.0 * h:\n                w_ij = cubic_spline_kernel(r, h)\n                sigma_j = particle_stress_vals[j]\n                \n                # SPH calculation\n                sum_sph += sigma_j * w_ij * particle_vol\n                \n                # RKPM calculation\n                p_j = np.array([1.0, x_j]) # Basis vector at particle j\n                p_j_outer_p_j = np.outer(p_j, p_j)\n                \n                moment_matrix += p_j_outer_p_j * w_ij * particle_vol\n                moment_vector += p_j * sigma_j * w_ij * particle_vol\n\n        sph_interpolated[k] = sum_sph\n        \n        # Finalize RKPM for point k\n        # Add stabilization to prevent singularity, as justified in the solution\n        stabilization = 1e-15 * np.eye(2)\n        moment_matrix += stabilization\n        \n        try:\n            M_inv = np.linalg.inv(moment_matrix)\n            rkpm_interpolated[k] = p_eval @ M_inv @ moment_vector\n        except np.linalg.LinAlgError:\n            # Fallback if matrix is singular despite stabilization\n            # This should ideally not be reached\n            rkpm_interpolated[k] = 0.0\n\n    # 4. Error calculation\n    true_stress_at_samples = true_stress_func(sample_pos)\n    \n    # SPH error\n    num_sph = np.sum((sph_interpolated - true_stress_at_samples)**2)\n    den_sph = np.sum(true_stress_at_samples**2)\n    error_sph = np.sqrt(num_sph / den_sph) if den_sph > 0 else 0.0\n    \n    # RKPM error\n    num_rkpm = np.sum((rkpm_interpolated - true_stress_at_samples)**2)\n    den_rkpm = np.sum(true_stress_at_samples**2)\n    error_rkpm = np.sqrt(num_rkpm / den_rkpm) if den_rkpm > 0 else 0.0\n    \n    return error_sph, error_rkpm\n\n# Execute the main function\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3543176"}, {"introduction": "在理解了近似理论的基础后，我们将SPH应用于一个经典的岩土力学问题：三轴压缩试验 [@problem_id:3543179]。本练习旨在演示如何在复杂的弹塑性本构模型（Drucker-Prager）和伺服控制边界条件下使用SPH的梯度算子。通过将数值结果与参考解进行比较，您将量化SPH离散化误差对模拟结果的实际影响，从而连接抽象的理论与具体的计算固体力学实践。", "problem": "考虑一个在小应变下建模的排水轴对称三轴压缩试验，该模型使用无网格光滑粒子流体动力学 (SPH) 运动学近似，并与一个带有关联流动的弹塑性 Drucker–Prager 本构模型耦合。应力与应变采用土力学中的压缩为正符号约定。目标是，对于给定的轴向应变历史和伺服控制的恒定径向（围压）应力，计算在平均应力-偏应力平面上的应力路径，并将基于SPH的数值路径与使用精确均匀应变率通过直接连续介质更新获得的参考路径进行比较。通过应力空间中的 $L^2$型误差来量化差异。\n\n从以下基本和核心定义开始：\n\n- 小应变下的线性各向同性弹性，其杨氏模量为 $E$，泊松比为 $\\nu$，体积模量为 $K = \\dfrac{E}{3(1-2\\nu)}$，剪切模量为 $G = \\dfrac{E}{2(1+\\nu)}$。\n- 柯西应力张量 $\\boldsymbol{\\sigma}$ 和小应变张量 $\\boldsymbol{\\varepsilon}$，其弹性关系为 $\\Delta \\boldsymbol{\\sigma} = 3 K \\Delta \\varepsilon_{\\mathrm{m}} \\dfrac{\\mathbf{I}}{3} + 2 G \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{dev}}$，其中 $\\Delta \\varepsilon_{\\mathrm{m}} = \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon})$ 且 $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{dev}} = \\Delta \\boldsymbol{\\varepsilon} - \\dfrac{\\Delta \\varepsilon_{\\mathrm{m}}}{3} \\mathbf{I}$。\n- 平均应力 $p = \\dfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma})$ 和 von Mises 型偏应力不变量 $q = \\sqrt{3 J_2}$，其中 $J_2$ 是应力偏量的第二不变量。在轴对称条件下，轴向应力为 $\\sigma_{\\mathrm{a}}$，径向应力相等为 $\\sigma_{\\mathrm{r}}$，则有 $p = \\dfrac{\\sigma_{\\mathrm{a}} + 2 \\sigma_{\\mathrm{r}}}{3}$ 和 $q = |\\sigma_{\\mathrm{a}} - \\sigma_{\\mathrm{r}}|$。\n- $(p,q)$ 形式的 Drucker–Prager 屈服函数为 $f = q + \\alpha p - k$，并伴随相关联塑性流动。材料参数 $\\alpha$ 和 $k$ 是摩擦角 $\\varphi$ 和黏聚力 $c$ 的函数，通过标准的内切 Drucker–Prager 映射得到：$\\alpha = \\dfrac{2 \\sin \\varphi}{\\sqrt{3} (3 - \\sin \\varphi)}$ 和 $k = \\dfrac{6 c \\cos \\varphi}{\\sqrt{3} (3 - \\sin \\varphi)}$。\n- 排水条件：孔隙压力变化可忽略不计；应力为有效应力。\n- 每个应变增量 $\\Delta \\boldsymbol{\\varepsilon} = \\mathrm{diag}(\\Delta \\varepsilon_{\\mathrm{r}}, \\Delta \\varepsilon_{\\mathrm{r}}, \\Delta \\varepsilon_{\\mathrm{a}})$ 的轴对称运动学，其中伺服控制在每个增量结束时强制使 $\\sigma_{\\mathrm{r}}$ 等于恒定的围压 $p_{\\mathrm{c}}$。\n\n仅使用 SPH 框架来近似定义每时间步轴向应变增量的均匀轴向速度梯度。具体来说，考虑一个一维域 $x \\in [0,L]$，由 $N$ 个等间距粒子离散化，粒子间距为 $\\Delta x = L/(N-1)$，质量密度为 $\\rho$（可使用任意正常数，注意在一维中比率 $m/\\rho$ 可简化为粒子体积）。采用标准的一维三次B样条核函数，其光滑长度为 $h$，空间导数为 $\\partial W/\\partial x$。对于线性速度场 $v(x) = \\dot{\\varepsilon}_{\\mathrm{a}} x$，在粒子 $i$ 处的轴向速度梯度可通过以下公式近似：\n$$\n\\left(\\frac{\\partial v}{\\partial x}\\right)_i \\approx \\sum_{j} \\frac{m_j}{\\rho_j} \\left(v_j - v_i\\right) \\frac{\\partial W(x_i - x_j, h)}{\\partial x},\n$$\n并将 SPH 估计的均匀轴向应变率定义为这些逐点梯度的算术平均值。由于有限的 $N$ 和 $h$ 会导致核函数在边界附近被截断，该估计值与精确梯度存在差异。\n\n算法任务：\n\n1. 为具有相关联流动的 Drucker–Prager 模型建立轴对称弹塑性返回映射算法，以便在给定应变增量的情况下，将应力从步骤 $n$ 更新到 $n+1$。该更新必须从应变和应力分解为体积和偏量部分的基本操作开始，并通过基于一致性条件计算塑性乘子来强制满足步骤结束时的屈服条件。根据更新后的 $(p^{n+1}, q^{n+1})$ 沿轴对称方向重构 $\\sigma_{\\mathrm{a}}^{n+1}$ 和 $\\sigma_{\\mathrm{r}}^{n+1}$。\n2. 在给定轴向应变增量 $\\Delta \\varepsilon_{\\mathrm{a}}$ 的情况下，通过求解未知的径向应变增量 $\\Delta \\varepsilon_{\\mathrm{r}}$ 来强制执行排水三轴伺服条件 $\\sigma_{\\mathrm{r}}^{n+1} = p_{\\mathrm{c}}$。对残差 $R(\\Delta \\varepsilon_{\\mathrm{r}}) = \\sigma_{\\mathrm{r}}^{n+1}(\\Delta \\varepsilon_{\\mathrm{r}}) - p_{\\mathrm{c}}$ 应用一种基于基础微积分的稳健求根策略（例如，使用有限差分导数的牛顿法）。\n3. 从各向同性应力 $(\\sigma_{\\mathrm{a}}^0,\\sigma_{\\mathrm{r}}^0) = (p_{\\mathrm{c}}, p_{\\mathrm{c}})$ 开始，通过 $n_{\\mathrm{steps}}$ 个等量增量计算两条应力路径，直至达到预设的最终轴向应变 $\\varepsilon_{\\mathrm{a,final}}$：\n   - 一条参考路径，在每一步使用精确的均匀轴向应变增量 $\\Delta \\varepsilon_{\\mathrm{a}} = \\varepsilon_{\\mathrm{a,final}} / n_{\\mathrm{steps}}$。\n   - 一条基于SPH的路径，使用SPH估计的均匀轴向应变增量 $\\Delta \\varepsilon_{\\mathrm{a}}^{\\mathrm{SPH}} = \\gamma \\, \\Delta \\varepsilon_{\\mathrm{a}}$，其中 $\\gamma$ 是在固定粒子集上对线性速度场 $v(x) = x$ 计算一次得到的SPH估计梯度与精确梯度之比。\n4. 在两条路径中，每一步都通过第2项中的伺服程序强制执行 $\\sigma_{\\mathrm{r}}^{n+1} = p_{\\mathrm{c}}$，更新 $(\\sigma_{\\mathrm{a}}, \\sigma_{\\mathrm{r}})$，并记录 $(p,q)$。\n5. 通过在记录的步骤上计算应力空间中的均方根 $L^2$ 型误差，来量化两条路径之间的差异，\n$$\n\\mathcal{E} = \\sqrt{\\frac{1}{M} \\sum_{k=0}^{M-1} \\left[ \\left(p_k^{\\mathrm{SPH}} - p_k^{\\mathrm{ref}}\\right)^2 + \\left(q_k^{\\mathrm{SPH}} - q_k^{\\mathrm{ref}}\\right)^2 \\right]},\n$$\n其中 $M = n_{\\mathrm{steps}} + 1$。以千帕（kilopascals）为单位报告 $\\mathcal{E}$，即将帕斯卡（Pascals）的值除以1000。\n\n在指定之处，角度单位必须为度。内部计算中，应力单位必须为帕斯卡（Pascals）；最终误差必须以千帕（kilopascals）表示。最终输出必须是单行文本，包含一个浮点数列表，每个测试用例对应一个数值，格式需严格遵循下文规定。\n\n使用以下三个案例的测试套件来评估不同的状态和分辨率：\n\n- 案例A（中等摩擦-黏聚力，中等分辨率）：\n  - $E = 100 \\times 10^6$ $\\mathrm{Pa}$，$\\nu = 0.3$，$\\varphi = 30$ $\\mathrm{deg}$，$c = 30 \\times 10^3$ $\\mathrm{Pa}$，$p_{\\mathrm{c}} = 100 \\times 10^3$ $\\mathrm{Pa}$。\n  - 域 $L = 1.0$ $\\mathrm{m}$，$N = 21$，光滑长度因子 $\\eta = 1.2$，因此 $h = \\eta \\Delta x$。\n  - 最终轴向应变 $\\varepsilon_{\\mathrm{a,final}} = 0.02$，步数 $n_{\\mathrm{steps}} = 200$。\n\n- 案例B（高黏聚力，基本弹性，较高分辨率）：\n  - $E = 50 \\times 10^6$ $\\mathrm{Pa}$，$\\nu = 0.2$，$\\varphi = 0$ $\\mathrm{deg}$，$c = 500 \\times 10^3$ $\\mathrm{Pa}$，$p_{\\mathrm{c}} = 150 \\times 10^3$ $\\mathrm{Pa}$。\n  - 域 $L = 1.0$ $\\mathrm{m}$，$N = 51$，光滑长度因子 $\\eta = 1.2$。\n  - 最终轴向应变 $\\varepsilon_{\\mathrm{a,final}} = 0.01$，步数 $n_{\\mathrm{steps}} = 100$。\n\n- 案例C（低摩擦，零黏聚力，粗糙分辨率）：\n  - $E = 80 \\times 10^6$ $\\mathrm{Pa}$，$\\nu = 0.33$，$\\varphi = 10$ $\\mathrm{deg}$，$c = 0$ $\\mathrm{Pa}$，$p_{\\mathrm{c}} = 50 \\times 10^3$ $\\mathrm{Pa}$。\n  - 域 $L = 1.0$ $\\mathrm{m}$，$N = 11$，光滑长度因子 $\\eta = 1.0$。\n  - 最终轴向应变 $\\varepsilon_{\\mathrm{a,final}} = 0.015$，步数 $n_{\\mathrm{steps}} = 150$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[e_A,e_B,e_C]$），其中 $e_A$、$e_B$ 和 $e_C$ 分别是为案例A、B和C计算出的 $L^2$ 型误差 $\\mathcal{E}$（单位为 $\\mathrm{kPa}$）。不允许有其他任何输出。", "solution": "该问题要求计算并比较在弹塑性材料上进行的排水轴对称三轴压缩试验的两条应力路径。该材料由一个带有关联流动的 Drucker–Prager 模型描述，其运动学由小应变定义。其中一条路径是参考路径，使用精确、均匀的轴向应变增量计算。第二条路径使用一个被因子 $\\gamma$ 扰动的轴向应变增量计算，该因子代表了一维光滑粒子流体动力学 (SPH) 梯度近似的离散化误差。这两条路径在平均应力 ($p$) 与偏应力 ($q$) 平面上的差异由一个均方根误差度量来量化。\n\n该解决方案通过以下一系列基于物理的数值程序实现。\n\n首先，我们确定 SPH 离散化误差因子 $\\gamma$。该问题通过考虑一个由 $N$ 个粒子离散化的长度为 $L$ 的一维杆来对此误差进行建模。施加一个线性速度场 $v(x) = \\dot{\\varepsilon}_{\\mathrm{a}} x$，其精确的速度梯度为常数 $\\partial v / \\partial x = \\dot{\\varepsilon}_{\\mathrm{a}}$。SPH 方法使用对其邻近粒子 $j$ 的加权和来近似每个粒子 $i$ 处的该梯度：\n$$\n\\left(\\frac{\\partial v}{\\partial x}\\right)_i \\approx \\sum_{j} V_j \\left(v_j - v_i\\right) \\frac{\\partial W(x_i - x_j, h)}{\\partial x_i}\n$$\n在此，$V_j = m_j/\\rho_j$ 是粒子 $j$ 的体积，对于均匀的一维离散化，它等于粒子间距 $\\Delta x = L/(N-1)$。$W$ 是光滑长度为 $h$ 的一维三次B样条核函数。项 $\\partial W(x_i-x_j, h)/\\partial x_i$ 是核函数的解析梯度。由于核函数的支撑域在区域边界附近被截断，SPH 近似的梯度并非精确值。我们计算所有 $N$ 个粒子上这些逐点梯度的算术平均值，并将 $\\gamma$ 定义为该平均 SPH 梯度与精确梯度之比。为简便起见，我们设置 $\\dot{\\varepsilon}_{\\mathrm{a}}=1$，使精确梯度为1，因此 $\\gamma$ 就是平均 SPH 梯度。这个因子 $\\gamma$ 对每个特定的离散化方案 ($N, h$) 只计算一次。\n\n其次，我们构建核心的本构更新算法。该算法必须在给定一个预设的轴向应变增量 $\\Delta\\varepsilon_{\\mathrm{a}}$ 的条件下，将应力状态从步骤 $n$ 更新到 $n+1$，同时将径向应力 $\\sigma_{\\mathrm{r}}$ 维持在恒定的围压 $p_{\\mathrm{c}}$。这是计算岩土力学中的一个经典伺服控制问题，我们采用嵌套方法来解决。\n\n内层是针对给定全应变增量张量 $\\Delta \\boldsymbol{\\varepsilon} = \\mathrm{diag}(\\Delta \\varepsilon_{\\mathrm{r}}, \\Delta \\varepsilon_{\\mathrm{r}}, \\Delta \\varepsilon_{\\mathrm{a}})$ 的弹塑性应力更新，即返回映射算法。该过程如下：\n1.  计算弹性试探应力状态。将应变增量分解为体积部分 $\\Delta\\varepsilon_{\\mathrm{m}} = \\Delta\\varepsilon_{\\mathrm{a}} + 2\\Delta\\varepsilon_{\\mathrm{r}}$ 和偏量部分 $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{dev}}$。使用各向同性弹性定律计算试探应力增量：$\\Delta p_{\\mathrm{trial}} = K \\Delta\\varepsilon_{\\mathrm{m}}$ 和 $\\Delta \\boldsymbol{s}_{\\mathrm{trial}} = 2G \\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{dev}}$。则 $(p,q)$ 空间中的试探应力状态为 $(p_{\\mathrm{trial}}, q_{\\mathrm{trial}}) = (p^n + \\Delta p_{\\mathrm{trial}}, q^n + \\Delta q_{\\mathrm{trial}})$。对于轴对称情况，$\\Delta q_{\\mathrm{trial}} = 2G(\\Delta \\varepsilon_{\\mathrm{a}} - \\Delta \\varepsilon_{\\mathrm{r}})$。\n2.  检查塑性屈服。将试探状态代入 Drucker–Prager 屈服函数：$f_{\\mathrm{trial}} = q_{\\mathrm{trial}} + \\alpha p_{\\mathrm{trial}} - k$。如果 $f_{\\mathrm{trial}} \\le 0$，则该步为纯弹性，最终应力状态即为试探状态：$(p^{n+1}, q^{n+1}) = (p_{\\mathrm{trial}}, q_{\\mathrm{trial}})$。\n3.  如果 $f_{\\mathrm{trial}}  0$，则发生塑性变形。应力状态必须被“返回”到屈服面上。对于相关联流动法则，通过强制执行一致性条件 $f(p^{n+1}, q^{n+1}) = 0$ 来求得塑性乘子增量 $\\Delta\\lambda$。这得出：\n    $$\n    \\Delta\\lambda = \\frac{f_{\\mathrm{trial}}}{3G + \\alpha^2 K}\n    $$\n    其中 $K$ 和 $G$ 分别是体积模量和剪切模量。然后，最终校正后的应力不变量更新为：\n    $$\n    p^{n+1} = p_{\\mathrm{trial}} - \\alpha K \\Delta\\lambda\n    $$\n    $$\n    q^{n+1} = q_{\\mathrm{trial}} - 3G \\Delta\\lambda\n    $$\n4.  最后，使用轴对称关系：$\\sigma_{\\mathrm{a}} = p + 2q/3$ 和 $\\sigma_{\\mathrm{r}} = p - q/3$，从不变量 $p^{n+1}$ 和 $q^{n+1}$ 重构出更新后的轴向和径向应力分量 $\\sigma_{\\mathrm{a}}^{n+1}$ 和 $\\sigma_{\\mathrm{r}}^{n+1}$。\n\n外层是伺服控制机制。径向应变增量 $\\Delta\\varepsilon_{\\mathrm{r}}$ 是未知的。必须确定其值，使得最终的径向应力 $\\sigma_{\\mathrm{r}}^{n+1}$ 等于目标围压 $p_{\\mathrm{c}}$。这为残差函数 $R(\\Delta\\varepsilon_{\\mathrm{r}}) = \\sigma_{\\mathrm{r}}^{n+1}(\\Delta\\varepsilon_{\\mathrm{r}}) - p_{\\mathrm{c}}$ 定义了一个求根问题，其中 $\\sigma_{\\mathrm{r}}^{n+1}(\\Delta\\varepsilon_{\\mathrm{r}})$ 使用上述完整的弹塑性更新过程计算。我们使用牛顿法求解 $R(\\Delta\\varepsilon_{\\mathrm{r}}) = 0$：\n$$\n\\Delta\\varepsilon_{\\mathrm{r}}^{(k+1)} = \\Delta\\varepsilon_{\\mathrm{r}}^{(k)} - \\frac{R(\\Delta\\varepsilon_{\\mathrm{r}}^{(k)})}{R'(\\Delta\\varepsilon_{\\mathrm{r}}^{(k)})}\n$$\n导数 $R'(\\Delta\\varepsilon_{\\mathrm{r}})$ 使用中心有限差分格式进行稳健近似。$\\Delta\\varepsilon_{\\mathrm{r}}$ 的初始猜测值由约束条件的纯弹性解导出。\n\n第三，执行主模拟循环，共 $n_{\\mathrm{steps}}$ 步。从各向同性应力状态 $(\\sigma_{\\mathrm{a}}^0, \\sigma_{\\mathrm{r}}^0) = (p_{\\mathrm{c}}, p_{\\mathrm{c}})$ 开始，并行运行两个模拟：\n-   **参考路径：** 在每一步中，施加精确的轴向应变增量 $\\Delta\\varepsilon_{\\mathrm{a}} = \\varepsilon_{\\mathrm{a,final}}/n_{\\mathrm{steps}}$。调用伺服控制算法找到相应的 $\\Delta\\varepsilon_{\\mathrm{r}}$ 并更新应力。存储得到的 $(p,q)$ 点。\n-   **基于SPH的路径：** 遵循相同的程序，但使用扰动后的轴向应变增量 $\\Delta\\varepsilon_{\\mathrm{a}}^{\\mathrm{SPH}} = \\gamma \\Delta\\varepsilon_{\\mathrm{a}}$。\n\n最后，在完成两条路径的所有 $M = n_{\\mathrm{steps}} + 1$ 个点（包括初始状态）后，使用指定的 $L^2$ 型误差公式计算差异，该公式测量了 $(p,q)$ 平面中两条路径对应点之间欧几里得距离的均方根值：\n$$\n\\mathcal{E} = \\sqrt{\\frac{1}{M} \\sum_{k=0}^{M-1} \\left[ \\left(p_k^{\\mathrm{SPH}} - p_k^{\\mathrm{ref}}\\right)^2 + \\left(q_k^{\\mathrm{SPH}} - q_k^{\\mathrm{ref}}\\right)^2 \\right]}\n$$\n最终结果以千帕（kPa）为单位报告。对所提供的三个测试案例中的每一个都重复此整个过程。", "answer": "```python\nimport numpy as np\n\ndef cubic_spline_derivative(r, h):\n    \"\"\"\n    Computes the derivative of the 1D cubic spline kernel with respect to\n    the spatial coordinate difference r. This is consistent with the kernel\n    defined in Problem 3.\n    \"\"\"\n    s = np.abs(r) / h\n    val = 0.0\n    alpha_d = 2.0 / 3.0\n\n    if 0 = s and s  1:\n        # Derivative of (1 - 1.5*s^2 + 0.75*s^3) w.r.t s is (-3*s + 2.25*s^2)\n        val = -3.0 * s + (9.0 / 4.0) * s**2\n    elif 1 = s and s  2:\n        # Derivative of (1/4 * (2-s)^3) w.r.t s is -3/4 * (2-s)^2\n        val = -(3.0 / 4.0) * (2.0 - s)**2\n    \n    # dW/dx = (dW/ds) * (ds/dx) = (dW/ds) * sgn(r)/h\n    # The term we need is dW/dr, which is used in dW/dx_i = (dW/dr_ij) * (dr_ij/dx_i) = dW/dr_ij\n    # So we want dW/dr = (sigma/h) * (d(phi)/ds) * (ds/dr) = (sigma/h) * (d(phi)/ds) * (sgn(r)/h)\n    return (alpha_d / h) * val * (np.sign(r) / h)\n\n\ndef calculate_sph_gamma(L, N, h):\n    \"\"\"\n    Calculates the SPH error factor gamma by comparing the SPH-estimated gradient\n    of a linear velocity field to its exact value (1.0).\n    \"\"\"\n    dx = L / (N - 1)\n    positions = np.linspace(0, L, N)\n    velocities = positions  # Corresponds to a linear field v(x)=x with unit gradient\n\n    grad_v_sph = np.zeros(N)\n    for i in range(N):\n        sum_grad = 0.0\n        for j in range(N):\n            r_ij = positions[i] - positions[j]\n            if np.abs(r_ij)  2 * h:\n                # Volume of particle j is dx\n                v_ij = velocities[j] - velocities[i]\n                dW_dx = cubic_spline_derivative(r_ij, h)\n                sum_grad += dx * v_ij * dW_dx\n        \n        grad_v_sph[i] = sum_grad\n\n    gamma = np.mean(grad_v_sph)\n    return gamma\n\ndef update_stress(sigma_a_n, sigma_r_n, delta_eps_a, delta_eps_r, K, G, alpha, k):\n    \"\"\"\n    Performs an elastoplastic stress update for a single step using the\n    Drucker-Prager model with associated flow.\n    \"\"\"\n    delta_eps_m = delta_eps_a + 2 * delta_eps_r\n\n    p_n = (sigma_a_n + 2 * sigma_r_n) / 3.0\n    q_n = sigma_a_n - sigma_r_n\n\n    # Elastic trial step\n    p_trial = p_n + K * delta_eps_m\n    q_trial = q_n + 2 * G * (delta_eps_a - delta_eps_r)\n\n    f_trial = q_trial + alpha * p_trial - k\n\n    if f_trial = 0:  # Elastic step\n        p_np1 = p_trial\n        q_np1 = q_trial\n    else:  # Plastic step (return mapping)\n        denominator = 3 * G + alpha**2 * K\n        delta_lambda = f_trial / denominator if denominator > 1e-12 else 0.0\n        \n        p_np1 = p_trial - alpha * K * delta_lambda\n        q_np1 = q_trial - 3 * G * delta_lambda\n        \n        q_np1 = max(0.0, q_np1)\n    \n    # Reconstruct stress components\n    sigma_a_np1 = p_np1 + (2.0/3.0) * q_np1\n    sigma_r_np1 = p_np1 - (1.0/3.0) * q_np1\n    \n    return sigma_a_np1, sigma_r_np1\n\ndef newton_solver(f, x0, jac_f, tol=1e-9, max_iter=20):\n    \"\"\"A simple Newton-Raphson solver.\"\"\"\n    x = x0\n    for _ in range(max_iter):\n        fx = f(x)\n        if abs(fx)  tol:\n            return x\n        jfx = jac_f(x)\n        if abs(jfx)  1e-12:\n            return x\n        x = x - fx / jfx\n    return x\n\ndef solve_for_case(params):\n    \"\"\"\n    Main solver for a single test case.\n    \"\"\"\n    E, nu, phi_deg, c, pc, L, N, eta, eps_a_final, n_steps = params\n\n    phi_rad = np.radians(phi_deg)\n    K = E / (3.0 * (1.0 - 2.0 * nu))\n    G = E / (2.0 * (1.0 + nu))\n\n    sin_phi = np.sin(phi_rad)\n    cos_phi = np.cos(phi_rad)\n    denom_dp = np.sqrt(3.0) * (3.0 - sin_phi)\n    alpha = (2.0 * sin_phi) / denom_dp\n    k = (6.0 * c * cos_phi) / denom_dp\n\n    dx = L / (N - 1)\n    h = eta * dx\n    gamma = calculate_sph_gamma(L, N, h)\n\n    delta_eps_a_ref = eps_a_final / n_steps\n    delta_eps_a_sph = gamma * delta_eps_a_ref\n\n    path_ref = np.zeros((n_steps + 1, 2))\n    path_sph = np.zeros((n_steps + 1, 2))\n\n    sigma_a_ref, sigma_r_ref = pc, pc\n    sigma_a_sph, sigma_r_sph = pc, pc\n    path_ref[0] = [(pc + 2*pc)/3.0, 0.0]\n    path_sph[0] = [(pc + 2*pc)/3.0, 0.0]\n    \n    for i in range(n_steps):\n        # Reference Path Calculation\n        sigma_a_n_ref, sigma_r_n_ref = sigma_a_ref, sigma_r_ref\n        \n        def R_ref(delta_eps_r):\n            _, updated_sigma_r = update_stress(sigma_a_n_ref, sigma_r_n_ref, delta_eps_a_ref, delta_eps_r, K, G, alpha, k)\n            return updated_sigma_r - pc\n\n        def jac_R_ref(delta_eps_r):\n            pert = 1e-8 * (abs(delta_eps_r) + 1.0)\n            return (R_ref(delta_eps_r + pert) - R_ref(delta_eps_r)) / pert\n\n        num_guess = pc - sigma_r_n_ref - (K - 2*G/3)*delta_eps_a_ref\n        den_guess = 2*K + 4*G/3\n        delta_eps_r_guess_ref = num_guess / den_guess if abs(den_guess) > 1e-9 else 0.0\n        \n        delta_eps_r_sol_ref = newton_solver(R_ref, delta_eps_r_guess_ref, jac_R_ref, tol=1e-8)\n        sigma_a_ref, sigma_r_ref = update_stress(sigma_a_n_ref, sigma_r_n_ref, delta_eps_a_ref, delta_eps_r_sol_ref, K, G, alpha, k)\n        \n        p_ref = (sigma_a_ref + 2 * sigma_r_ref) / 3.0\n        q_ref = sigma_a_ref - sigma_r_ref\n        path_ref[i+1] = [p_ref, q_ref]\n\n        # SPH Path Calculation\n        sigma_a_n_sph, sigma_r_n_sph = sigma_a_sph, sigma_r_sph\n        \n        def R_sph(delta_eps_r):\n            _, updated_sigma_r = update_stress(sigma_a_n_sph, sigma_r_n_sph, delta_eps_a_sph, delta_eps_r, K, G, alpha, k)\n            return updated_sigma_r - pc\n            \n        def jac_R_sph(delta_eps_r):\n            pert = 1e-8 * (abs(delta_eps_r) + 1.0)\n            return (R_sph(delta_eps_r + pert) - R_sph(delta_eps_r)) / pert\n\n        num_guess = pc - sigma_r_n_sph - (K - 2*G/3)*delta_eps_a_sph\n        den_guess = 2*K + 4*G/3\n        delta_eps_r_guess_sph = num_guess / den_guess if abs(den_guess) > 1e-9 else 0.0\n\n        delta_eps_r_sol_sph = newton_solver(R_sph, delta_eps_r_guess_sph, jac_R_sph, tol=1e-8)\n        sigma_a_sph, sigma_r_sph = update_stress(sigma_a_n_sph, sigma_r_n_sph, delta_eps_a_sph, delta_eps_r_sol_sph, K, G, alpha, k)\n\n        p_sph = (sigma_a_sph + 2 * sigma_r_sph) / 3.0\n        q_sph = sigma_a_sph - sigma_r_sph\n        path_sph[i+1] = [p_sph, q_sph]\n\n    diff = path_sph - path_ref\n    squared_errors = np.sum(diff**2, axis=1)\n    mean_squared_error = np.mean(squared_errors)\n    rms_error = np.sqrt(mean_squared_error)\n    \n    return rms_error / 1000.0\n\ndef solve():\n    test_cases = [\n        # Case A: E, nu, phi, c, pc, L, N, eta, eps_a_final, n_steps\n        (100e6, 0.3, 30.0, 30e3, 100e3, 1.0, 21, 1.2, 0.02, 200),\n        # Case B\n        (50e6, 0.2, 0.0, 500e3, 150e3, 1.0, 51, 1.2, 0.01, 100),\n        # Case C\n        (80e6, 0.33, 10.0, 0.0, 50e3, 1.0, 11, 1.0, 0.015, 150),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_for_case(case)\n        results.append(error)\n\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3543179"}, {"introduction": "在真实世界的大规模复杂模拟中，均匀的粒子分辨率往往导致计算效率低下。本练习 [@problem_id:3543233] 聚焦于一个关键的高级主题：自适应加密。您需要设计一个算法，根据物理场（应变梯度）的演化来动态地增加或删除粒子，并必须确保在这些动态调整过程中，质量和动量等基本物理量得到严格守恒，这是构建稳健高效SPH代码的重要一步。", "problem": "考虑一个长度为 $L$、均匀质量密度为 $\\rho$、横截面积为 $A$ 的杆的一维光滑粒子流体动力学 (SPH) 离散化。设粒子位置为 $x_i$（单位：米），质量为 $m_i$（单位：千克），速度为 $v_i$（单位：米/秒），光滑长度为 $h_i$（单位：米），位移为 $u_i$（单位：米）。在小应变运动学下，轴向应变定义为 $\\epsilon = \\partial u / \\partial x$，应变梯度大小为 $\\|\\nabla \\epsilon\\| = |\\partial^2 u / \\partial x^2|$，单位为米分之一。\n\n您必须设计并实现一个自适应粒子加密算法，该算法根据应变梯度大小 $\\|\\nabla \\epsilon\\|$ 插入和删除粒子。该算法必须遵循以下要求：\n\n- SPH 使用一维三次样条核函数。对于间距 $r = x_i - x_j$ 和光滑长度 $h$，定义 $q = |r|/h$，并令\n$$\nW(r,h) = \\frac{\\sigma}{h}\n\\begin{cases}\n1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3,  0 \\le q  1, \\\\\n\\frac{1}{4}(2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n其中在一维情况下 $\\sigma = \\frac{2}{3}$。其关于 $x_i$ 的空间导数为\n$$\n\\frac{\\partial W(r,h)}{\\partial x_i} = \\frac{\\sigma}{h^2}\\,\\text{sign}(r)\\,\n\\begin{cases}\n-3q + \\frac{9}{4}q^2,  0 \\le q  1, \\\\\n-\\frac{3}{4}(2 - q)^2,  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n其中，如果 $r  0$，$\\text{sign}(r)$ 为 $+1$；如果 $r  0$，则为 $-1$；如果 $r = 0$，则为 $0$。\n\n- 通过 SPH 差分格式近似梯度。对于具有粒子值 $A_i$ 的标量场 $A(x)$，使用\n$$\n\\left.\\frac{\\partial A}{\\partial x}\\right|_{i} \\approx \\sum_{j=1}^{N} \\frac{m_j}{\\rho_j}\\left(A_j - A_i\\right)\\,\\frac{\\partial W(r_{ij},h_{ij})}{\\partial x_i},\n$$\n其中 $r_{ij} = x_i - x_j$ 且 $h_{ij} = \\frac{1}{2}(h_i + h_j)$。假设所有 $j$ 的密度均匀，为 $\\rho_j = \\rho$。\n\n- 将粒子 $i$ 处的应变定义为 $\\,\\epsilon_i \\approx \\left.\\frac{\\partial u}{\\partial x}\\right|_i\\,$，应变梯度大小定义为 $\\,g_i = \\left|\\left.\\frac{\\partial \\epsilon}{\\partial x}\\right|_i\\right|\\,$。\n\n- 将粒子 $i$ 处的局部间距 $s_i$ 定义为其与最近邻粒子的最小距离（单位：米）。\n\n- 自适应加密规则：\n  1. 插入（分裂）：如果 $g_i  g_{\\text{insert}}$ 且 $s_i  s_{\\min}$，则将粒子 $i$ 替换为两个子粒子，它们位于 $x_i \\pm \\delta$ 处（其中 $\\delta = s_i/4$），每个子粒子的质量为 $m_i/2$，速度为 $v_i$，位移为 $u_i$，光滑长度为 $h_i/2$。\n  2. 删除（合并）：对于相邻的粒子 $i$ 和 $i+1$，如果它们都满足 $g_i  g_{\\text{delete}}$ 和 $g_{i+1}  g_{\\text{delete}}$，且它们的间距 $s_{i,i+1} = |x_{i+1} - x_i|$ 满足 $s_{i,i+1}  s_{\\max}$，则将它们合并为一个粒子，其质量为 $m_i + m_{i+1}$，位置为 $x = \\frac{m_i x_i + m_{i+1} x_{i+1}}{m_i + m_{i+1}}$，速度为 $v = \\frac{m_i v_i + m_{i+1} v_{i+1}}{m_i + m_{i+1}}$，位移为 $u = \\frac{m_i u_i + m_{i+1} u_{i+1}}{m_i + m_{i+1}}$，光滑长度为 $h = \\frac{1}{2}(h_i + h_{i+1})$。\n\n- 守恒性评估：计算加密前后瞬间的总质量 $M = \\sum_i m_i$（单位：千克）和总线性动量 $P = \\sum_i m_i v_i$（单位：千克·米/秒）。报告绝对差值 $\\Delta M = |M_{\\text{after}} - M_{\\text{before}}|$（单位：千克）和 $\\Delta P = |P_{\\text{after}} - P_{\\text{before}}|$（单位：千克·米/秒）。\n\n您的程序必须使用以下测试套件实现上述内容，其中所有长度单位为米，密度单位为千克/立方米，面积单位为平方米，速度单位为米/秒，应变梯度单位为米分之一：\n\n- 测试用例 1 (正常路径):\n  - 域长度 $L = 1.0$。\n  - 初始粒子数 $N_0 = 41$，呈均匀间距。\n  - 密度 $\\rho = 2000$。\n  - 横截面积 $A = 0.01$。\n  - 光滑长度因子 $\\kappa = 1.2$，因此初始时 $h_i = \\kappa \\Delta x$。\n  - 位移场 $u(x) = 0.01 \\sin(\\pi x)$。\n  - 速度场 $v(x) = 0.1 x$。\n  - 插入阈值 $g_{\\text{insert}} = 0.05$。\n  - 删除阈值 $g_{\\text{delete}} = 0.01$。\n  - 插入的最小间距 $s_{\\min} = 0.020$。\n  - 删除的最大间距 $s_{\\max} = 0.030$。\n\n- 测试用例 2 (无加密边界):\n  - 与测试用例 1 具有相同的 $L$、$N_0$、$\\rho$、$A$、$\\kappa$、$u(x)$ 和 $v(x)$。\n  - 插入阈值 $g_{\\text{insert}} = 1.0$ (过高以至于无法触发)。\n  - 删除阈值 $g_{\\text{delete}} = 0.0$ (没有粒子严格满足小于该值)。\n  - $s_{\\min} = 0.020$。\n  - $s_{\\max} = 0.030$。\n\n- 测试用例 3 (激进插入边缘情况):\n  - 域长度 $L = 1.0$。\n  - 初始粒子数 $N_0 = 21$，呈均匀间距。\n  - 密度 $\\rho = 2000$。\n  - 横截面积 $A = 0.01$。\n  - 光滑长度因子 $\\kappa = 1.2$，因此初始时 $h_i = \\kappa \\Delta x$。\n  - 位移场 $u(x) = 0.05 \\sin(\\pi x)$。\n  - 速度场 $v(x) = 0.2 x$。\n  - 插入阈值 $g_{\\text{insert}} = 0.20$。\n  - 删除阈值 $g_{\\text{delete}} = 0.02$。\n  - 插入的最小间距 $s_{\\min} = 0.040$。\n  - 删除的最大间距 $s_{\\max} = 0.060$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须是所有测试用例的守恒误差的扁平化序列，顺序为 $\\left[\\Delta M_1,\\Delta P_1,\\Delta M_2,\\Delta P_2,\\Delta M_3,\\Delta P_3\\right]$，每个值都是 SI 单位（质量单位为千克，动量单位为千克·米/秒）的浮点数。", "solution": "用户提供的问题要求设计并实现一个用于光滑粒子流体动力学 (SPH) 的一维自适应粒子加密算法。该问题具有科学依据、是良定的，并为确定性解提供了所有必要信息。因此，该问题是有效的。\n\n解决方案是遵循结构化的、基于原则的方法开发的。解决方案的核心是一种算法，该算法基于局部应变梯度大小，通过插入（分裂）和删除（合并）来修改一组 SPH 粒子。\n\n首先，为每个测试用例建立一个初始状态。一组 $N_0$ 个粒子均匀分布在长度为 $L$ 的一维域上。初始粒子间距为 $\\Delta x = L / (N_0 - 1)$。每个粒子 $i$ 被赋予以下属性：\n- 位置：$x_i = i \\cdot \\Delta x$，对于 $i = 0, 1, \\dots, N_0-1$。\n- 质量：$m_i = (\\rho A L) / N_0$，其中 $\\rho$ 是密度，A 是横截面积。\n- 速度：$v_i = v(x_i)$，来自给定的速度场。\n- 位移：$u_i = u(x_i)$，来自给定的位移场。\n- 光滑长度：$h_i = \\kappa \\Delta x$，其中 $\\kappa$ 是一个给定因子。\n\n计算此初始构型的总质量 $M_{\\text{before}} = \\sum_i m_i$ 和总线性动量 $P_{\\text{before}} = \\sum_i m_i v_i$，作为守恒性检查的基准。\n\n加密过程依赖于空间导数的 SPH 近似。使用指定的 SPH 差分公式来计算两个连续的梯度。首先，通过对位移场 $u$ 应用梯度算子来计算每个粒子处的轴向应变 $\\epsilon_i$：\n$$\n\\epsilon_i = \\left.\\frac{\\partial u}{\\partial x}\\right|_{i} \\approx \\sum_{j} \\frac{m_j}{\\rho}\\left(u_j - u_i\\right)\\,\\frac{\\partial W(r_{ij},h_{ij})}{\\partial x_i}\n$$\n其中求和遍及所有其他粒子 $j$，$r_{ij} = x_i - x_j$，$h_{ij} = \\frac{1}{2}(h_i + h_j)$。核函数导数 $\\frac{\\partial W}{\\partial x_i}$ 使用所提供的三次样条函数及其导数进行精确实现，正如其定义所示。\n\n其次，将相同的梯度算子应用于计算出的应变场 $\\epsilon$，以求得每个粒子处的应变梯度。应变梯度大小 $g_i$ 即为其绝对值：\n$$\ng_i = \\left| \\left.\\frac{\\partial \\epsilon}{\\partial x}\\right|_{i} \\right| \\approx \\left| \\sum_{j} \\frac{m_j}{\\rho}\\left(\\epsilon_j - \\epsilon_i\\right)\\,\\frac{\\partial W(r_{ij},h_{ij})}{\\partial x_i} \\right|\n$$\n此外，每个粒子的局部间距 $s_i$ 被确定为与其最近邻的最小距离。对于按位置排序的一维粒子集，此值为 $\\min(|x_i - x_{i-1}|, |x_{i+1} - x_i|)$。\n\n自适应加密算法分两个顺序阶段进行：\n\n1.  **插入（分裂）**：算法遍历所有粒子。如果粒子 $i$ 的应变梯度大小 $g_i$ 超过阈值 $g_{\\text{insert}}$ 且其局部间距 $s_i$ 大于最小值 $s_{\\min}$，则该粒子被标记为待插入。每个被标记的粒子都被替换为两个新的“子”粒子。根据问题的规则，位于位置 $x_i$ 且属性为 $(m_i, v_i, u_i, h_i)$ 的父粒子被替换为两个位于 $x_i \\pm s_i/4$ 的子粒子，每个子粒子的属性为 $(m_i/2, v_i, u_i, h_i/2)$。此过程保持质量和线性动量守恒。\n\n2.  **删除（合并）**：插入过程结束后，粒子集被更新并且必须按位置重新排序。由于粒子分布已改变，需要为此新构型重新计算 SPH 相关量（$\\epsilon_i$, $g_i$）。然后，算法遍历连续的粒子对 $(i, i+1)$。如果两个粒子都满足 $g_i  g_{\\textdelete}$ 和 $g_{i+1}  g_{\\textdelete}$，并且它们的相互間距 $|x_{i+1} - x_i|$ 小於最大值 $s_{\\max}$，则该粒子对将被合并。这两个粒子被替换为一个新的单一粒子，其属性（质量、位置、速度、位移）由保持总质量和总线性动量守恒的公式确定。新的光滑长度是两个原始光滑长度的平均值。使用 `while` 循环处理排序后的粒子，以正确处理连续合并的情况。\n\n最后，在两个阶段都完成后，计算最终粒子集的总质量 $M_{\\text{after}}$ 和总线性动量 $P_{\\text{after}}$。计算绝对差值 $\\Delta M = |M_{\\text{after}} - M_{\\text{before}}|$ 和 $\\Delta P = |P_{\\text{after}} - P_{\\text{before}}|$。由于分裂和合并规则的守恒特性，这些差值预期为零，或是一个可归因于浮点精度误差的极小值。这可作为对实现方案的验证。该算法应用于三个指定的测试用例中的每一个，并收集所得的 $\\Delta M$ 和 $\\Delta P$ 值作为最终输出。", "answer": "```python\nimport numpy as np\n\ndef W(r, h):\n    \"\"\"\n    Computes the 1D cubic spline SPH kernel value.\n    \"\"\"\n    sigma = 2.0 / 3.0\n    if h == 0:\n        return 0.0\n    q = abs(r) / h\n    if q >= 2.0:\n        return 0.0\n    \n    val = 0.0\n    if q  1.0:\n        val = 1.0 - 1.5 * q**2 + 0.75 * q**3\n    elif q  2.0:\n        val = 0.25 * (2.0 - q)**3\n    \n    return (sigma / h) * val\n\ndef dW_dx(r, h):\n    \"\"\"\n    Computes the derivative of the 1D cubic spline SPH kernel.\n    \"\"\"\n    sigma = 2.0 / 3.0\n    if h == 0:\n        return 0.0\n    q = abs(r) / h\n    sign_r = np.sign(r)\n    \n    if q >= 2.0:\n        return 0.0\n\n    derivative_q = 0.0\n    if q  1.0:\n        derivative_q = -3.0 * q + 2.25 * q**2\n    elif q  2.0:\n        derivative_q = -0.75 * (2.0 - q)**2\n    \n    return (sigma / h**2) * sign_r * derivative_q\n\ndef compute_sph_properties(particles, rho):\n    \"\"\"\n    Computes strains, strain gradients, and local spacings for a particle set.\n    \"\"\"\n    n = len(particles)\n    if n == 0:\n        return [], [], []\n\n    strains = np.zeros(n)\n    grads = np.zeros(n)\n    spacings = np.zeros(n)\n    \n    # Store particle properties in arrays for faster access\n    pos = np.array([p['x'] for p in particles])\n    mass = np.array([p['m'] for p in particles])\n    disp = np.array([p['u'] for p in particles])\n    smooth = np.array([p['h'] for p in particles])\n\n    # Compute strains\n    for i in range(n):\n        sum_val = 0.0\n        for j in range(n):\n            if i == j:\n                continue\n            r_ij = pos[i] - pos[j]\n            h_ij = 0.5 * (smooth[i] + smooth[j])\n            grad_W = dW_dx(r_ij, h_ij)\n            sum_val += (mass[j] / rho) * (disp[j] - disp[i]) * grad_W\n        strains[i] = sum_val\n\n    # Compute strain gradients\n    for i in range(n):\n        sum_val = 0.0\n        for j in range(n):\n            if i == j:\n                continue\n            r_ij = pos[i] - pos[j]\n            h_ij = 0.5 * (smooth[i] + smooth[j])\n            grad_W = dW_dx(r_ij, h_ij)\n            sum_val += (mass[j] / rho) * (strains[j] - strains[i]) * grad_W\n        grads[i] = abs(sum_val)\n\n    # Compute spacings (assumes particles are sorted by position)\n    if n > 1:\n        spacings[0] = abs(pos[1] - pos[0])\n        spacings[n-1] = abs(pos[n-1] - pos[n-2])\n        for i in range(1, n - 1):\n            spacings[i] = min(abs(pos[i] - pos[i-1]), abs(pos[i+1] - pos[i]))\n    \n    return strains, grads, spacings\n\ndef run_refinement_cycle(initial_particles, params, rho):\n    \"\"\"\n    Performs one full cycle of insertion and deletion.\n    \"\"\"\n    # --- INSERTION ---\n    if not initial_particles:\n        return []\n\n    strains, grads, spacings = compute_sph_properties(initial_particles, rho)\n    \n    particles_to_split = []\n    for i in range(len(initial_particles)):\n        if grads[i] > params['g_insert'] and spacings[i] > params['s_min']:\n            particles_to_split.append(i)\n\n    particles_after_split = []\n    split_indices = set(particles_to_split)\n    for i, p in enumerate(initial_particles):\n        if i in split_indices:\n            delta = spacings[i] / 4.0\n            \n            child1 = {\n                'x': p['x'] - delta, 'm': p['m'] / 2.0, 'v': p['v'], \n                'u': p['u'], 'h': p['h'] / 2.0\n            }\n            child2 = {\n                'x': p['x'] + delta, 'm': p['m'] / 2.0, 'v': p['v'],\n                'u': p['u'], 'h': p['h'] / 2.0\n            }\n            particles_after_split.extend([child1, child2])\n        else:\n            particles_after_split.append(p)\n\n    particles_after_split.sort(key=lambda p: p['x'])\n    \n    # --- DELETION ---\n    if len(particles_after_split)  2:\n        return particles_after_split\n\n    strains, grads, _ = compute_sph_properties(particles_after_split, rho)\n\n    final_particles = []\n    i = 0\n    n = len(particles_after_split)\n    while i  n:\n        can_merge = False\n        if i  n - 1:\n            g_i = grads[i]\n            g_j = grads[i+1]\n            s_ij = abs(particles_after_split[i+1]['x'] - particles_after_split[i]['x'])\n            if g_i  params['g_delete'] and g_j  params['g_delete'] and s_ij  params['s_max']:\n                can_merge = True\n\n        if can_merge:\n            p_i = particles_after_split[i]\n            p_j = particles_after_split[i+1]\n            m_total = p_i['m'] + p_j['m']\n            \n            merged_particle = {\n                'm': m_total,\n                'x': (p_i['m'] * p_i['x'] + p_j['m'] * p_j['x']) / m_total,\n                'v': (p_i['m'] * p_i['v'] + p_j['m'] * p_j['v']) / m_total,\n                'u': (p_i['m'] * p_i['u'] + p_j['m'] * p_j['u']) / m_total,\n                'h': 0.5 * (p_i['h'] + p_j['h'])\n            }\n            final_particles.append(merged_particle)\n            i += 2\n        else:\n            final_particles.append(particles_after_split[i])\n            i += 1\n            \n    return final_particles\n\n\ndef solve():\n    test_cases = [\n        { # Test Case 1\n            'L': 1.0, 'N0': 41, 'rho': 2000, 'A': 0.01, 'kappa': 1.2,\n            'u_func': lambda x: 0.01 * np.sin(np.pi * x),\n            'v_func': lambda x: 0.1 * x,\n            'g_insert': 0.05, 'g_delete': 0.01,\n            's_min': 0.020, 's_max': 0.030,\n        },\n        { # Test Case 2\n            'L': 1.0, 'N0': 41, 'rho': 2000, 'A': 0.01, 'kappa': 1.2,\n            'u_func': lambda x: 0.01 * np.sin(np.pi * x),\n            'v_func': lambda x: 0.1 * x,\n            'g_insert': 1.0, 'g_delete': 0.0,\n            's_min': 0.020, 's_max': 0.030,\n        },\n        { # Test Case 3\n            'L': 1.0, 'N0': 21, 'rho': 2000, 'A': 0.01, 'kappa': 1.2,\n            'u_func': lambda x: 0.05 * np.sin(np.pi * x),\n            'v_func': lambda x: 0.2 * x,\n            'g_insert': 0.20, 'g_delete': 0.02,\n            's_min': 0.040, 's_max': 0.060,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initial particle setup\n        L, N0, rho, A = case['L'], case['N0'], case['rho'], case['A']\n        delta_x = L / (N0 - 1) if N0 > 1 else L\n        total_mass = rho * A * L\n        particle_mass = total_mass / N0\n        h0 = case['kappa'] * delta_x\n\n        initial_particles = []\n        for i in range(N0):\n            x_i = i * delta_x\n            initial_particles.append({\n                'x': x_i,\n                'm': particle_mass,\n                'v': case['v_func'](x_i),\n                'u': case['u_func'](x_i),\n                'h': h0,\n            })\n            \n        m_before = sum(p['m'] for p in initial_particles)\n        p_before = sum(p['m'] * p['v'] for p in initial_particles)\n\n        # Run refinement\n        final_particles = run_refinement_cycle(initial_particles, case, rho)\n        \n        m_after = sum(p['m'] for p in final_particles)\n        p_after = sum(p['m'] * p['v'] for p in final_particles)\n        \n        delta_m = abs(m_after - m_before)\n        delta_p = abs(p_after - p_before)\n        \n        results.extend([delta_m, delta_p])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3543233"}]}