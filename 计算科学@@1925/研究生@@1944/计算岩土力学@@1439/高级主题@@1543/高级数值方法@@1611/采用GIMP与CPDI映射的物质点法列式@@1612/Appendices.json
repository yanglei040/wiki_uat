{"hands_on_practices": [{"introduction": "在任何数值方法的评估中，“Patch Test”（斑块检验）都是一个基础性的基准。这项练习的目标是验证GIMP和CPDI格式能否精确地再现一个恒定的应变状态，这一特性被称为线性完备性。对于一个数值方法能否收敛到正确解而言，满足斑块检验是一个至关重要的前提条件 [@problem_id:3541702]。", "problem": "考虑一个在质点法（MPM）中使用的结构化、均匀的笛卡尔背景网格上提出的二维小应变线性补丁测试。设均匀网格在两个方向上的间距均为 $h$，节点索引为 $I$ 的节点位于坐标 $(x_I,y_I)$ 处。通过根据线性函数 $u_x(x,y) = a x + b$ 和 $u_y(x,y) = c y + d$ 指定节点位移，在网格节点上施加一个合成的运动学场，其中 $a$、$b$、$c$ 和 $d$ 是给定的实数参数，$(x,y)$ 表示空间位置。目标是验证两种域感知MPM映射方法，即广义插值质点法（GIMP）和对流粒子域插值法（CPDI），能否在变化的粒子域大小和随机的粒子-网格偏移下，在所有质点（粒子）上精确再现恒定的小应变张量 $\\boldsymbol{\\varepsilon}$。验证过程应通过使用每种映射从节点位移计算质点处的应变，并将其与施加的线性位移场引起的精确解析应变进行比较来完成。\n\n推导的基本依据是位移梯度和小应变的运动学定义：位移梯度为 $\\nabla \\mathbf{u} = \\begin{bmatrix} \\frac{\\partial u_x}{\\partial x} & \\frac{\\partial u_x}{\\partial y} \\\\ \\frac{\\partial u_y}{\\partial x} & \\frac{\\partial u_y}{\\partial y} \\end{bmatrix}$，无穷小应变张量为 $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^\\top\\right)$。在补丁测试中，预期的解析应变是恒定的，即 $\\varepsilon_{xx}=a$，$\\varepsilon_{yy}=c$，以及 $\\varepsilon_{xy}=0$。粒子上的数值应变是使用MPM映射从节点位移计算得出的，该映射为每个粒子分配了背景网格形函数在粒子域上的平均梯度。在GIMP中，这个平均值由形函数梯度在矩形粒子域上的面积分定义。在CPDI中，这个平均值由粒子域角点一致地定义，并且当粒子域与网格轴对齐时，对于线性场会产生相同的结果。两种映射都应在此测试中精确再现线性场。\n\n您的任务是实现一个程序，该程序能够：\n- 构建一个间距为 $h$ 的均匀方形网格，其尺寸足够大，以至于能够将随机放置的粒子域完全容纳在网格内部。\n- 生成一组质点，其矩形域在两个方向上的边长均为 $l_p$，使得比率 $l_p/h$ 可以根据每个测试用例变化。粒子中心在内部随机分布，以确保每个粒子域都保持在网格边界内。对于一个测试用例，特意将粒子中心集中在网格线附近，以创建跨越边界的情景。\n- 在所有网格节点上施加来自线性场 $u_x=a x + b$，$u_y=c y + d$ 的节点位移。\n- 对每个粒子，使用以下方法计算数值位移梯度 $\\nabla \\mathbf{u}$ 和小应变 $\\boldsymbol{\\varepsilon}$：\n  1. 基于背景双线性形函数梯度在粒子域上的精确面积平均的GIMP定义（当粒子域与多个网格单元重叠时，通过将其划分为单元子域进行适当处理）。\n  2. 基于每个重叠单元子域内的角点平均梯度，并在整个粒子域上进行面积加权的CPDI定义。\n- 将计算出的粒子应变与精确的解析应变进行比较，并为每个测试用例和每种映射报告所有粒子中 $\\boldsymbol{\\varepsilon}$ 的最大绝对误差。由于 $\\boldsymbol{\\varepsilon}$ 是无量纲的，误差也是无量纲的。\n\n使用一个均匀网格，其间距 $h$ 以米表示，节点坐标也以米表示。位移 $u_x$ 和 $u_y$ 必须以米为单位。应变 $\\boldsymbol{\\varepsilon}$ 必须被视为无量纲量，误差度量也必须是无量纲的。\n\n实现以下测试套件，其中每个测试用例定义了 $(a,b,c,d)$、粒子与网格尺寸之比 $l_p/h$、粒子数量 $N_p$ 以及用于确定性地生成粒子中心的随机种子：\n1. 理想路径：$a=0.03$，$b=0.0$，$c=-0.02$，$d=0.1$，$l_p/h=0.3$，$N_p=50$，种子 $42$。\n2. 接近单元尺寸的域：$a=0.05$，$b=0.5$，$c=0.04$，$d=-0.3$，$l_p/h=0.99$，$N_p=60$，种子 $123$。\n3. 跨边界偏移：$a=-0.01$，$b=0.2$，$c=0.02$，$d=0.0$，$l_p/h=0.6$，$N_p=40$，种子 $2024$；选择靠近网格线的粒子中心，以便许多粒子域在保持在网格内部的同时跨越单元边界。\n4. 非常小的域：$a=0.0$，$b=-0.1$，$c=0.0$，$d=0.25$，$l_p/h=0.05$，$N_p=80$，种子 $7$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[E^{\\mathrm{GIMP}}_1,E^{\\mathrm{CPDI}}_1,E^{\\mathrm{GIMP}}_2,E^{\\mathrm{CPDI}}_2,E^{\\mathrm{GIMP}}_3,E^{\\mathrm{CPDI}}_3,E^{\\mathrm{GIMP}}_4,E^{\\mathrm{CPDI}}_4]$，其中 $E^{\\mathrm{GIMP}}_k$ 和 $E^{\\mathrm{CPDI}}_k$ 分别表示使用GIMP和CPDI映射计算的测试用例 $k$ 中所有粒子应变分量的最大绝对误差。所有输出必须是无量纲的实数。不允许有其他输出。", "solution": "问题陈述经过严格评估，被确定为有效。它构成了计算岩土力学领域中一个适定、具有科学依据的验证问题。具体来说，它描述了质点法（MPM）的线性补丁测试，这是验证数值实现正确性的标准程序。给定的条件是完整的、一致的且物理上是合理的。目标明确，方法（GIMP, CPDI）在MPM的框架内有很好的定义。因此，我们可以进行形式化的求解。\n\n测试的核心原理是广义插值质点法（GIMP）和对流粒子域插值法（CPDI）公式能否精确再现恒定应变状态。这个性质被称为线性完备性，是数值方法在网格细化时收敛到正确解的必要条件。\n\n首先，我们建立解析解。规定的位移场由下式给出：\n$$\nu_x(x,y) = a x + b \\\\\nu_y(x,y) = c y + d\n$$\n其中 $a, b, c, d$ 是常数。位移梯度张量 $\\nabla \\mathbf{u}$ 通过对位移分量求偏导数得到：\n$$\n\\nabla \\mathbf{u} =\n\\begin{bmatrix}\n\\frac{\\partial u_x}{\\partial x} & \\frac{\\partial u_x}{\\partial y} \\\\\n\\frac{\\partial u_y}{\\partial x} & \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}\n$$\n无穷小（小）应变张量 $\\boldsymbol{\\varepsilon}$ 是位移梯度的对称部分：\n$$\n\\boldsymbol{\\varepsilon}_{exact} = \\frac{1}{2} \\left( \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top \\right) = \\frac{1}{2} \\left(\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}\n+\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}^\\top\n\\right)\n=\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}\n$$\n因此，解析应变场在整个域内是恒定的，其分量为 $\\varepsilon_{xx} = a$，$\\varepsilon_{yy} = c$，以及 $\\varepsilon_{xy} = 0$。这是数值方法必须再现的精确解。\n\n在质点法中，位移场 $\\mathbf{u}^h(\\mathbf{x})$ 是使用基于网格的形函数 $S_I(\\mathbf{x})$ 从节点值 $\\mathbf{u}_I$ 插值得到的：\n$$\n\\mathbf{u}^h(\\mathbf{x}) = \\sum_{I} S_I(\\mathbf{x}) \\mathbf{u}_I\n$$\n该问题在间距为 $h$ 的均匀笛卡尔网格上使用双线性形函数。这些函数的一个关键性质是它们构成单位分解（$\\sum_I S_I(\\mathbf{x}) = 1$）并且是线性完备的（$\\sum_I S_I(\\mathbf{x}) \\mathbf{x}_I = \\mathbf{x}$）。由于规定的位移场是线性的，并且节点位移被设置为节点处的精确值，即 $\\mathbf{u}_I = \\mathbf{u}(\\mathbf{x}_I)$，线性完备性保证了插值场在任何地方都能精确再现线性场：$\\mathbf{u}^h(\\mathbf{x}) = \\mathbf{u}(\\mathbf{x})$。\n\n从插值场计算出的位移梯度为：\n$$\n\\nabla \\mathbf{u}^h(\\mathbf{x}) = \\sum_I \\mathbf{u}_I \\otimes \\nabla S_I(\\mathbf{x})\n$$\n由于 $\\mathbf{u}^h(\\mathbf{x}) = \\mathbf{u}(\\mathbf{x})$，因此可以得出 $\\nabla \\mathbf{u}^h(\\mathbf{x}) = \\nabla \\mathbf{u}(\\mathbf{x})$，我们已经发现这是一个常数矩阵。\n\n在GIMP和CPDI中，质点 $p$ 处的位移梯度不是在其中心点计算，而是在粒子域 $\\Omega_p$ 上进行平均。粒子平均梯度为：\n$$\n(\\nabla \\mathbf{u})_p = \\frac{1}{A_p} \\int_{\\Omega_p} \\nabla \\mathbf{u}^h(\\mathbf{x}) \\, dA = \\frac{1}{A_p} \\int_{\\Omega_p} \\left( \\sum_I \\mathbf{u}_I \\otimes \\nabla S_I(\\mathbf{x}) \\right) dA = \\sum_I \\mathbf{u}_I \\otimes \\left( \\frac{1}{A_p} \\int_{\\Omega_p} \\nabla S_I(\\mathbf{x}) \\, dA \\right)\n$$\n其中 $A_p = l_p^2$ 是粒子域的面积。我们将粒子平均形函数梯度定义为 $\\mathbf{G}_{Ip} = \\langle \\nabla S_I \\rangle_p$。因此：\n$$\n(\\nabla \\mathbf{u})_p = \\sum_I \\mathbf{u}_I \\otimes \\mathbf{G}_{Ip}\n$$\n其分量计算如下：\n$$\n(\\nabla u_x)_p = \\sum_I u_{x,I} \\mathbf{G}_{Ip} \\quad \\text{and} \\quad (\\nabla u_y)_p = \\sum_I u_{y,I} \\mathbf{G}_{Ip}\n$$\n更具体地说：\n$$\n(\\nabla \\mathbf{u})_p = \\begin{bmatrix}\n\\sum_I u_{x,I} G_{Ip,x} & \\sum_I u_{x,I} G_{Ip,y} \\\\\n\\sum_I u_{y,I} G_{Ip,x} & \\sum_I u_{y,I} G_{Ip,y}\n\\end{bmatrix}\n$$\n挑战在于为每个支撑域与粒子域 $\\Omega_p$ 相交的节点 $I$ 正确计算 $\\mathbf{G}_{Ip}$ 的分量。对于位于 $\\mathbf{x}_I=(x_I, y_I)$ 的节点，标准的双线性基函数可以写成 $S_I(x,y) = s\\left(\\frac{x-x_I}{h}\\right) s\\left(\\frac{y-y_I}{h}\\right)$，其中 $s(z) = \\max(0, 1-|z|)$ 是一维帽子函数。其导数为 $s'(z) = -\\text{sgn}(z)$，当 $|z| \\in (0,1)$ 时成立，否则为0。\n\n$\\mathbf{G}_{Ip}$ 的分量是可分离积分的结果：\n$$\nG_{Ip,x} = \\frac{1}{A_p} \\int_{y_p-l_p/2}^{y_p+l_p/2} \\int_{x_p-l_p/2}^{x_p+l_p/2} \\frac{\\partial S_I}{\\partial x} \\, dx \\, dy = \\frac{1}{l_p^2 h} \\left[ \\int_{x_p-l_p/2}^{x_p+l_p/2} s'\\left(\\frac{x-x_I}{h}\\right) \\, dx \\right] \\left[ \\int_{y_p-l_p/2}^{y_p+l_p/2} s\\left(\\frac{y-y_I}{h}\\right) \\, dy \\right]\n$$\n根据微积分基本定理，导数 $s'$ 的积分就是 $s$。通过变量替换（$z=(x-x_I)/h$），可以简化积分为：\n$$\nG_{Ip,x} = \\frac{h}{l_p^2} \\left[ s(z) \\right]_{z_1}^{z_2} \\left[ \\int_{w_1}^{w_2} s(w) \\, dw \\right]\n$$\n以及类似地，\n$$\nG_{Ip,y} = \\frac{h}{l_p^2} \\left[ \\int_{z_1}^{z_2} s(z) \\, dz \\right] \\left[ s(w) \\right]_{w_1}^{w_2}\n$$\n其中积分限为 $z_1 = (x_p-l_p/2-x_I)/h$，$z_2 = (x_p+l_p/2-x_I)/h$，$w_1 = (y_p-l_p/2-y_I)/h$ 和 $w_2 = (y_p+l_p/2-y_I)/h$。$s(z)$ 的定积分可以通过考虑其分段定义来解析计算。\n设 $F(z) = \\int_0^z s(t) \\, dt$。那么 $\\int_a^b s(t) \\, dt = F(b) - F(a)$。函数 $F(z)$ 为：\n$$\nF(z) =\n\\begin{cases}\n-0.5 & z \\le -1 \\\\\nz + z^2/2 & -1 < z < 0 \\\\\nz - z^2/2 & 0 \\le z \\le 1 \\\\\n0.5 & z > 1\n\\end{cases}\n$$\n利用这些解析表达式，可以为GIMP计算出达到机器精度的 $\\mathbf{G}_{Ip}$。问题陈述指出，对于轴对齐的矩形粒子域和线性位移场，CPDI公式会给出相同的结果。因此，两者将使用相同的计算方法，并且两种情况下的预期误差都应接近于零，仅受浮点运算的限制。\n\n每个测试用例的算法流程如下：\n1. 定义一个足够大的网格并设置网格间距 $h$。\n2. 使用指定的随机种子生成 $N_p$ 个粒子中心坐标 $(x_p, y_p)$，确保尺寸为 $l_p \\times l_p$ 的粒子域完全包含在网格内部。对于跨边界情况，粒子中心被明确放置在网格线附近。\n3. 对于网格中坐标为 $(x_I, y_I)$ 的每个节点 $I$，计算规定的节点位移 $u_{x,I} = a x_I + b$ 和 $u_{y,I} = c y_I + d$。\n4. 对每个粒子，将其位移梯度张量 $(\\nabla \\mathbf{u})_p$ 初始化为零。\n5. 识别所有形函数支撑域与粒子域重叠的节点 $I$。$S_I$ 的支撑域是一个以 $\\mathbf{x}_I$ 为中心的 $2h \\times 2h$ 方形区域。\n6. 对每个此类活动节点，使用上面推导的精确积分公式计算平均梯度向量 $\\mathbf{G}_{Ip}$。\n7. 累加每个节点对粒子位移梯度的贡献：$(\\nabla \\mathbf{u})_p += \\mathbf{u}_I \\otimes \\mathbf{G}_{Ip}$。\n8. 在遍历所有活动节点后，计算粒子应变张量 $\\boldsymbol{\\varepsilon}_p = \\frac{1}{2}((\\nabla \\mathbf{u})_p + (\\nabla \\mathbf{u})_p^\\top)$。\n9. 计算粒子的误差，即计算出的应变 $\\boldsymbol{\\varepsilon}_p$ 的分量与解析应变 $\\boldsymbol{\\varepsilon}_{exact}$ 的分量之间的最大绝对差。\n10. 测试用例的结果是所有粒子中发现的最大误差。该值将为GIMP和CPDI两种方法分别报告。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef s_hat(z: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the 1D linear B-spline (hat function).\"\"\"\n    z_abs = np.abs(z)\n    return np.where(z_abs < 1.0, 1.0 - z_abs, 0.0)\n\ndef integral_s_hat(z: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the analytical integral of the hat function from 0 to z.\"\"\"\n    res = np.zeros_like(z, dtype=float)\n    \n    # z = -1\n    res[z = -1.0] = -0.5\n    \n    # -1  z  0\n    mask = (-1.0  z)  (z  0.0)\n    res[mask] = z[mask] + 0.5 * z[mask]**2\n    \n    # 0 = z = 1\n    mask = (0.0 = z)  (z = 1.0)\n    res[mask] = z[mask] - 0.5 * z[mask]**2\n\n    # z > 1\n    res[z  1.0] = 0.5\n    \n    return res\n\ndef eval_integral_s_hat(z1: np.ndarray, z2: np.ndarray) - np.ndarray:\n    \"\"\"Computes the definite integral of the hat function from z1 to z2.\"\"\"\n    return integral_s_hat(z2) - integral_s_hat(z1)\n\ndef run_test_case(a, b, c, d, lp_h_ratio, Np, seed, is_edge_crossing):\n    \"\"\"\n    Runs a single patch test case.\n    \"\"\"\n    h = 1.0\n    lp = lp_h_ratio * h\n    \n    # 1. Grid setup\n    grid_dim = 20  # Number of cells in each direction\n    grid_min, grid_max = 0.0, grid_dim * h\n    \n    # Generate node coordinates and displacements\n    x_coords = np.arange(grid_min, grid_max + h, h)\n    y_coords = np.arange(grid_min, grid_max + h, h)\n    nx, ny = len(x_coords), len(y_coords)\n    nodes_x, nodes_y = np.meshgrid(x_coords, y_coords)\n    \n    u_x_nodal = a * nodes_x + b\n    u_y_nodal = c * nodes_y + d\n    \n    # 2. Particle generation\n    rng = np.random.default_rng(seed)\n    particles_pos = np.zeros((Np, 2))\n    \n    # Ensure particles and their domains are within the grid 'interior'\n    # Use a margin of 1 cell from the boundary to avoid edge cases\n    margin = h\n    p_min = grid_min + margin + lp / 2.0\n    p_max = grid_max - margin - lp / 2.0\n\n    if is_edge_crossing:\n        # Concentrate particles near grid lines\n        grid_lines_x_idx = rng.integers(margin + 1, grid_dim - margin - 1, size=Np)\n        grid_lines_y_idx = rng.integers(margin + 1, grid_dim - margin - 1, size=Np)\n        \n        base_x = grid_lines_x_idx * h\n        base_y = grid_lines_y_idx * h\n\n        # Offset by a small amount, ensuring cell crossing\n        offset_mag = 0.4 * lp # Small enough to be near line, large enough to guarantee crossing if lp is large\n        offsets_x = rng.uniform(-offset_mag, offset_mag, size=Np)\n        offsets_y = rng.uniform(-offset_mag, offset_mag, size=Np)\n        \n        particles_pos[:, 0] = np.clip(base_x + offsets_x, p_min, p_max)\n        particles_pos[:, 1] = np.clip(base_y + offsets_y, p_min, p_max)\n    else:\n        particles_pos = rng.uniform(low=p_min, high=p_max, size=(Np, 2))\n\n    max_err = 0.0\n    analytical_strain = np.array([[a, 0.0], [0.0, c]])\n\n    # 3. Process each particle\n    for p_idx in range(Np):\n        xp, yp = particles_pos[p_idx]\n        grad_u_p = np.zeros((2, 2))\n        \n        # Identify active nodes\n        x_min_infl = xp - lp / 2.0 - h\n        x_max_infl = xp + lp / 2.0 + h\n        y_min_infl = yp - lp / 2.0 - h\n        y_max_infl = yp + lp / 2.0 + h\n\n        # Find indices of nodes within the influence region\n        min_i = int(np.floor(x_min_infl / h))\n        max_i = int(np.ceil(x_max_infl / h))\n        min_j = int(np.floor(y_min_infl / h))\n        max_j = int(np.ceil(y_max_infl / h))\n\n        min_i = max(0, min_i)\n        max_i = min(nx-1, max_i)\n        min_j = max(0, min_j)\n        max_j = min(ny-1, max_j)\n\n        for j in range(min_j, max_j + 1):\n            for i in range(min_i, max_i + 1):\n                xi, yi = x_coords[i], y_coords[j]\n\n                # Calculate particle-averaged shape function gradients (G_ip)\n                z1 = (xp - lp / 2.0 - xi) / h\n                z2 = (xp + lp / 2.0 - xi) / h\n                w1 = (yp - lp / 2.0 - yi) / h\n                w2 = (yp + lp / 2.0 - yi) / h\n                \n                term_z_s = s_hat(z2) - s_hat(z1)\n                term_w_s = s_hat(w2) - s_hat(w1)\n                \n                term_z_int_s = eval_integral_s_hat(z1, z2)\n                term_w_int_s = eval_integral_s_hat(w1, w2)\n                \n                if abs(term_z_s)  1e-15 and abs(term_w_s)  1e-15 and \\\n                   abs(term_z_int_s)  1e-15 and abs(term_w_int_s)  1e-15:\n                    continue\n\n                common_factor = h / (lp**2)\n                G_ip_x = common_factor * term_z_s * term_w_int_s\n                G_ip_y = common_factor * term_z_int_s * term_w_s\n                \n                # Accumulate displacement gradient\n                grad_u_p[0, 0] += u_x_nodal[j, i] * G_ip_x\n                grad_u_p[0, 1] += u_x_nodal[j, i] * G_ip_y\n                grad_u_p[1, 0] += u_y_nodal[j, i] * G_ip_x\n                grad_u_p[1, 1] += u_y_nodal[j, i] * G_ip_y\n        \n        # Calculate strain and error\n        strain_p = 0.5 * (grad_u_p + grad_u_p.T)\n        err_matrix = np.abs(strain_p - analytical_strain)\n        \n        if np.max(err_matrix)  max_err:\n            max_err = np.max(err_matrix)\n            \n    return max_err\n\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # a, b, c, d, lp/h, Np, seed, is_edge_crossing\n        (0.03, 0.0, -0.02, 0.1, 0.3, 50, 42, False),\n        (0.05, 0.5, 0.04, -0.3, 0.99, 60, 123, False),\n        (-0.01, 0.2, 0.02, 0.0, 0.6, 40, 2024, True),\n        (0.0, -0.1, 0.0, 0.25, 0.05, 80, 7, False),\n    ]\n\n    results = []\n    for params in test_cases:\n        error = run_test_case(*params)\n        # For this linear patch test with axis-aligned domains, GIMP and CPDI yield identical results.\n        results.append(f\"{error:.15e}\")\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3541702"}, {"introduction": "掌握了线性场的再现能力后，我们转向一个更精妙的物理原理：角动量守恒。这项练习将探讨一些看似合理的数值映射如何在离散格式下引入非物理的内力矩，以及像CPDI这样的格式是如何设计来避免这个问题的。通过这项实践，你将能定量分析这种伪力矩，并测试一种修正方法以恢复角动量守恒 [@problem_id:3541779]。", "problem": "考虑一个用于计算岩土力学的、建立在均匀笛卡尔网格上的二维物质点法，其中单个物质点（粒子）通过映射算子与网格节点相互作用。目标是分析由均匀、对称的 Cauchy 应力引起的内力的离散角动量平衡，并量化在两种粒子到网格映射下由映射引起的力矩：一种是作为朴素广义插值物质点 (Generalized Interpolation Material Point, GIMP) 法代理的角点平均梯度映射，另一种是对流粒子域插值 (Convected Particle Domain Interpolation, CPDI) 映射。然后，你将实现一个对称校正，该校正能在保持线动量的同时消除伪力矩。\n\n从以下基本基础开始：\n\n- 材料子域的连续介质线性动量平衡：内力密度由 Cauchy 应力的散度给出，由粒子离散化产生的节点内力是应力散度与网格形函数梯度的求积。\n- 连续介质角动量平衡要求 Cauchy 应力是对称的，并意味着在没有外力偶的情况下，净内力偶（力矩）为零。\n- 在离散网格公式中，由于面积为 $V_p$、Cauchy 应力为 $\\boldsymbol{\\sigma}_p$ 的粒子 $p$ 作用于网格节点 $i$ 的内部节点力可组装为\n$$\n\\mathbf{f}^{\\text{int}}_i \\;=\\; -\\sum_{p} V_p\\, \\boldsymbol{\\sigma}_p \\cdot \\nabla S_{ip},\n$$\n其中 $\\nabla S_{ip}$ 是与节点 $i$ 和粒子 $p$ 相关联的映射梯度权重。关于原点的离散内力矩为\n$$\n\\tau_z \\;=\\; \\sum_{i} \\big(\\mathbf{x}_i \\times \\mathbf{f}^{\\text{int}}_i\\big)\\cdot \\mathbf{e}_z,\n$$\n其中 $\\mathbf{x}_i$ 是节点 $i$ 的位置，$\\times$ 是三维叉乘，$\\mathbf{e}_z$ 是平面外的单位向量。\n\n本问题中使用的定义和假设：\n\n- 使用间距 $h = 1$ 米的均匀笛卡尔网格。网格节点位于 $(i\\,h, j\\,h)$，其中 $i$ 和 $j$ 为整数。\n- 在任何网格单元内，使用标准的双线性有限元基函数。对于左下角位于 $(x_0, y_0)$ 的单元，其局部坐标为 $\\xi = (x-x_0)/h$ 和 $\\eta = (y-y_0)/h$，附着于四个单元顶点的形函数为\n  - $N_{00} = (1-\\xi)(1-\\eta)$, $N_{10} = \\xi (1-\\eta)$, $N_{01} = (1-\\xi)\\eta$, $N_{11} = \\xi \\eta$,\n  相应的物理梯度为\n  $$\n  \\nabla N_{00} = \\left[-\\frac{1-\\eta}{h}, -\\frac{1-\\xi}{h}\\right],\\;\n  \\nabla N_{10} = \\left[ \\frac{1-\\eta}{h}, -\\frac{\\xi}{h}\\right],\\;\n  \\nabla N_{01} = \\left[-\\frac{\\eta}{h}, \\frac{1-\\xi}{h}\\right],\\;\n  \\nabla N_{11} = \\left[ \\frac{\\eta}{h}, \\frac{\\xi}{h}\\right].\n  $$\n- 粒子 $p$ 的中心为 $\\mathbf{x}_p \\in \\mathbb{R}^2$，轴对齐的半尺寸为 $a = L_x/2$ 米和 $b = L_y/2$ 米，平面内旋转角度为 $\\theta$ 弧度。其四个角点为\n$$\n\\mathbf{x}_p^{(c)} \\;=\\; \\mathbf{x}_p + \\mathbf{R}(\\theta)\\,\\mathbf{q}^{(c)},\\quad \\text{其中}\\quad \\mathbf{q}^{(c)} \\in \\{(\\pm a, \\pm b)\\},\n$$\n按逆时针排序，$\\mathbf{R}(\\theta)$ 是平面旋转矩阵，面积为 $A_p = L_x L_y$。\n- Cauchy 应力是均匀且各向同性的，$\\boldsymbol{\\sigma}_p = p\\,\\mathbf{I}$，其中 $p$ 的单位是帕斯卡，$\\mathbf{I}$ 是单位张量。不存在体力偶，网格节点上也没有外边界力；仅考虑内力。\n- 将比较三种粒子到网格的梯度映射 $\\nabla S_{ip}$：\n  1. 一种朴素的角点平均梯度映射（作为朴素广义插值物质点法的一种代理）：\n     $$\n     \\nabla S_{ip}^{\\text{naive}} \\;=\\; \\frac{1}{4}\\sum_{c=1}^{4} \\nabla N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right),\n     $$\n     其中每个角点 $\\mathbf{x}_p^{(c)}$ 在其所在的单元中进行评估，并对该单元的四个节点产生贡献。\n  2. 对流粒子域插值 (CPDI-1) 映射：\n     $$\n     \\nabla S_{ip}^{\\text{CPDI}} \\;=\\; \\frac{1}{A_p}\\sum_{c=1}^{4} N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\\,\\mathbf{r}^{(c)},\n     $$\n     其中角点向量为\n     $$\n     \\mathbf{r}^{(c)} \\;=\\; \\frac{1}{2}\\,\\begin{bmatrix}\n     y_p^{(c+1)} - y_p^{(c-1)} \\\\\n     -\\left(x_p^{(c+1)} - x_p^{(c-1)}\\right)\n     \\end{bmatrix},\n     $$\n     角点使用循环索引。这是针对凸四边形粒子域的标准 CPDI-1 基于边界积分的梯度。\n  3. 一种对称校正，后验地应用于任何已组装的内部节点力 $\\{\\mathbf{f}^{\\text{int}}_i\\}$，以消除净内力矩，同时保持净内力。设支撑节点位置的算术平均值为 $\\bar{\\mathbf{x}} = \\frac{1}{n}\\sum_i \\mathbf{x}_i$，并设 $J$ 为平面内 $\\pi/2$ 的旋转，$J[x, y]^T = [-y, x]^T$。定义\n     $$\n     \\lambda \\;=\\; -\\,\\frac{\\tau_z}{\\sum_i \\|\\mathbf{x}_i - \\bar{\\mathbf{x}}\\|^2},\\qquad\n     \\delta\\mathbf{f}_i \\;=\\; \\lambda\\,J\\left(\\mathbf{x}_i - \\bar{\\mathbf{x}}\\right),\n     $$\n     校正后的力为 $\\mathbf{f}^{\\text{corr}}_i = \\mathbf{f}^{\\text{int}}_i + \\delta\\mathbf{f}_i$。这种构造保持了 $\\sum_i \\mathbf{f}^{\\text{corr}}_i = \\sum_i \\mathbf{f}^{\\text{int}}_i$ 并强制净内力矩为零。\n\n你的任务：\n\n- 在任何查询点所在的网格单元内，实现与上述网格和基函数一致的双线性形函数求值和梯度计算。\n- 对于给定的粒子，使用上述每种映射 $\\nabla S_{ip}$ 组装节点内力 $\\mathbf{f}^{\\text{int}}_i = - V_p\\, p\\, \\nabla S_{ip}$。包括所有作为任何包含至少一个粒子角点的单元的顶点的节点。\n- 计算标量平面外力矩，单位为牛顿·米，\n$$\n\\tau_z \\;=\\; \\sum_{i} \\left( x_i\\, f^{\\text{int}}_{i,y} - y_i\\, f^{\\text{int}}_{i,x} \\right),\n$$\n分别针对朴素角点平均映射、CPDI 映射，以及应用于朴素映射的对称校正力。将输出四舍五入到合理的浮点表示；单位必须是牛顿·米。\n\n设计一个包含三个案例的测试套件，以探究映射诱导力矩的不同方面：\n\n- 案例 A (理想情况，粒子位于一个单元内)：$\\mathbf{x}_p = (0.5,\\,0.5)$ 米，$(L_x, L_y) = (0.4,\\,0.4)$ 米，$\\theta = 0$ 弧度。\n- 案例 B (边界情况，区域跨越多个单元)：$\\mathbf{x}_p = (0.75,\\,0.5)$ 米，$(L_x, L_y) = (1.2,\\,0.6)$ 米，$\\theta = 0$ 弧度。\n- 案例 C (旋转，区域跨越多个单元)：$\\mathbf{x}_p = (0.5,\\,0.5)$ 米，$(L_x, L_y) = (1.2,\\,0.6)$ 米，$\\theta = \\pi/6$ 弧度。\n\n使用 $h = 1$ 米，$p = 1000$ 帕斯卡，以及 $V_p = A_p = L_x L_y$ 平方米。角度必须以弧度为单位。所有力矩的答案必须以牛顿·米为单位表示为浮点数。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的 9 个结果列表，按如下顺序排列\n$$\n[\\tau^{\\text{naive}}_{\\text{A}},\\;\\tau^{\\text{CPDI}}_{\\text{A}},\\;\\tau^{\\text{corr}}_{\\text{A}},\\;\\tau^{\\text{naive}}_{\\text{B}},\\;\\tau^{\\text{CPDI}}_{\\text{B}},\\;\\tau^{\\text{corr}}_{\\text{B}},\\;\\tau^{\\text{naive}}_{\\text{C}},\\;\\tau^{\\text{CPDI}}_{\\text{C}},\\;\\tau^{\\text{corr}}_{\\text{C}}].\n$$\n不应打印任何其他文本。所有值都必须以牛顿·米为单位。", "solution": "该问题要求在均匀笛卡尔网格上的二维域中，分析物质点法 (MPM) 中由映射引起的伪力矩。我们将实现并比较三种计算节点内力和由此产生的净内力矩的方法，该计算针对承受均匀各向同性应力状态的单个粒子：一种是朴素的角点平均梯度映射（作为朴素 GIMP 的代理），一种是对流粒子域插值 (CPDI) 映射，以及一种应用于朴素映射的后验对称校正。\n\n基本原理是线性动量和角动量的平衡。在连续介质中，对于一个承受对称 Cauchy 应力张量 $\\boldsymbol{\\sigma}$ 且无体力偶的物体，净内力矩为零。在离散的 MPM 公式中，这一特性并不总是得以保持，从而导致数值误差。来自粒子 $p$（体积为 $V_p$，应力为 $\\boldsymbol{\\sigma}_p$）作用于网格节点 $i$ 的离散内力由下式给出：\n$$\n\\mathbf{f}^{\\text{int}}_i = - V_p\\, \\boldsymbol{\\sigma}_p \\cdot \\nabla S_{ip}\n$$\n其中 $\\nabla S_{ip}$ 是网格基函数 $S_i$ 的粒子到网格的映射梯度。鉴于问题指定了均匀各向同性应力 $\\boldsymbol{\\sigma}_p = p\\,\\mathbf{I}$，其中 $p$ 是恒定压力，$\\mathbf{I}$ 是单位张量，该式可简化为：\n$$\n\\mathbf{f}^{\\text{int}}_i = - V_p\\, p\\, \\nabla S_{ip}\n$$\n关于原点的总内力矩是这些节点力矩的总和：\n$$\n\\tau_z = \\sum_{i} \\big(\\mathbf{x}_i \\times \\mathbf{f}^{\\text{int}}_i\\big)\\cdot \\mathbf{e}_z = \\sum_{i} \\left( x_i\\, f^{\\text{int}}_{i,y} - y_i\\, f^{\\text{int}}_{i,x} \\right)\n$$\n其中 $\\mathbf{x}_i = [x_i, y_i]^T$ 是节点 $i$ 的位置，$\\mathbf{f}^{\\text{int}}_i = [f^{\\text{int}}_{i,x}, f^{\\text{int}}_{i,y}]^T$。问题设置在二维空间中，网格间距 $h=1$ 米。考虑单个粒子，其体积 $V_p$ 取为其面积 $A_p = L_x L_y$。给定压力为 $p=1000$ 帕斯卡。\n\n我们的计算流程如下：\n首先，我们建立几何和有限元工具。对于任意点 $\\mathbf{x} \\in \\mathbb{R}^2$，我们必须确定其所在的网格单元，并计算与该单元四个顶点相关的双线性形函数 $N_i(\\mathbf{x})$ 及其梯度 $\\nabla N_i(\\mathbf{x})$。我们在局部坐标 $\\xi, \\eta$ 中实现了所提供的 $N_i$ 和 $\\nabla N_i$ 的公式。\n\n其次，对于三个测试案例中的每一个，我们定义粒子的几何形状。给定其中心 $\\mathbf{x}_p$、尺寸 $(L_x, L_y)$ 和旋转角 $\\theta$，我们计算其四个角点 $\\mathbf{x}_p^{(c)}$ 的世界坐标及其面积 $A_p$。\n\n第三，我们实现三种不同的方法来计算节点力和力矩。\n\n1.  **朴素角点平均映射 (Naive Corner-Averaged Mapping)**：\n    梯度权重是在粒子四个角点处评估的标准有限元形函数梯度的平均值：\n    $$\n    \\nabla S_{ip}^{\\text{naive}} = \\frac{1}{4}\\sum_{c=1}^{4} \\nabla N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\n    $$\n    我们识别出所有作为包含一个或多个粒子角点的任何单元的顶点的唯一网格节点的集合。对于每个这样的节点 $i$，我们对来自每个角点的梯度贡献求和，然后求平均值。接着计算内力 $\\mathbf{f}^{\\text{int}}_i$，并求和得到总力矩 $\\tau_z^{\\text{naive}}$。这种方法通常不守恒角动量，我们预计当粒子未与网格对称排列时，会产生非零力矩。\n\n2.  **对流粒子域插值 (CPDI) 映射**：\n    CPDI 梯度映射被设计为变分一致的，并且已知即使对于一般的四边形粒子域，在均匀应力状态下也能精确地守恒线性和角动量。梯度定义为：\n    $$\n    \\nabla S_{ip}^{\\text{CPDI}} = \\frac{1}{A_p}\\sum_{c=1}^{4} N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\\,\\mathbf{r}^{(c)}\n    $$\n    其中 $\\mathbf{r}^{(c)}$ 是从粒子角点坐标导出的几何向量：\n    $$\n    \\mathbf{r}^{(c)} = \\frac{1}{2}\\,\\begin{bmatrix} y_p^{(c+1)} - y_p^{(c-1)} \\\\ -\\left(x_p^{(c+1)} - x_p^{(c-1)}\\right) \\end{bmatrix}\n    $$\n    该过程首先使用角点的循环索引计算四个向量 $\\mathbf{r}^{(c)}$。然后，对于每个角点，我们在其位置评估形函数 $N_i$，并为 $\\nabla S_{ip}^{\\text{CPDI}}$ 累加加权和。然后计算力和产生的力矩 $\\tau_z^{\\text{CPDI}}$。理论上，我们期望对于所有测试案例，$\\tau_z^{\\text{CPDI}} = 0$。\n\n3.  **对称校正 (Symmetric Correction)**：\n    该方法提供了一种后验强制角动量平衡的方式。从一组产生非零力矩 $\\tau_z$ 的内力 $\\{\\mathbf{f}^{\\text{int}}_i\\}$（在我们的案例中，是来自朴素映射的那些力）开始，我们计算一组校正节点力 $\\{\\delta\\mathbf{f}_i\\}$，它们的净力为零，但净力矩为 $-\\tau_z$。校正定义为：\n    $$\n    \\delta\\mathbf{f}_i = \\lambda\\,J\\left(\\mathbf{x}_i - \\bar{\\mathbf{x}}\\right) \\quad \\text{其中} \\quad \\lambda = -\\,\\frac{\\tau_z}{\\sum_j \\|\\mathbf{x}_j - \\bar{\\mathbf{x}}\\|^2}\n    $$\n    这里，$\\bar{\\mathbf{x}}$ 是支撑节点位置的质心，$J$ 是平面内 $\\pi/2$ 旋转的算子。校正后的力是 $\\mathbf{f}^{\\text{corr}}_i = \\mathbf{f}^{\\text{int}}_i + \\delta\\mathbf{f}_i$。根据构造，$\\sum_i \\mathbf{f}^{\\text{corr}}_i = \\sum_i \\mathbf{f}^{\\text{int}}_i$（如果线性动量平衡存在，则予以保持），并且新的总力矩 $\\tau_z^{\\text{corr}}$ 为零（在浮点精度范围内）。\n\n我们将此三步分析应用于每个测试案例（A、B 和 C），并收集九个最终的力矩值用于最终输出。计算使用双精度浮点算术进行。\n- **案例 A**：一个小的、未旋转的粒子，完全位于一个单元内。由于完全对称，我们预计所有三种方法都将产生零力矩。\n- **案例 B**：一个较大的、未旋转的粒子，跨越一个单元边界。这种不对称性预计会为朴素映射产生一个非零力矩。\n- **案例 C**：一个大的、旋转的粒子，中心位于一个单元内，但跨越多个单元。这种复杂的几何形状也预计会在朴素映射中引起伪力矩。\n\n对于 CPDI 和校正方法，理论上的力矩结果都是 $0$。实现应产生非常接近零的值，反映了浮点运算的精度限制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculations for all test cases.\n    \"\"\"\n    H = 1.0  # Grid spacing\n    P = 1000.0  # Pressure\n\n    # (center, (Lx, Ly), theta)\n    test_cases = [\n        # Case A\n        ((0.5, 0.5), (0.4, 0.4), 0.0),\n        # Case B\n        ((0.75, 0.5), (1.2, 0.6), 0.0),\n        # Case C\n        ((0.5, 0.5), (1.2, 0.6), np.pi / 6.0),\n    ]\n\n    results = []\n    for xp, L, theta in test_cases:\n        particle = Particle(xp, L, theta)\n\n        # 1. Naive corner-averaged mapping\n        naive_forces = calculate_naive_forces(particle, P, H)\n        tau_naive = calculate_torque(naive_forces)\n\n        # 2. CPDI mapping\n        cpdi_forces = calculate_cpdi_forces(particle, P, H)\n        tau_cpdi = calculate_torque(cpdi_forces)\n\n        # 3. Symmetric correction on naive forces\n        _, tau_corr = apply_correction(naive_forces, tau_naive)\n\n        results.extend([tau_naive, tau_cpdi, tau_corr])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_shape_info(point, h=1.0):\n    \"\"\"\n    Calculates shape functions and gradients for a point in a Cartesian grid.\n\n    Args:\n        point (np.ndarray): The (x, y) coordinates of the query point.\n        h (float): The grid cell spacing.\n\n    Returns:\n        dict: A dictionary mapping node coordinates (tuples) to their\n              shape function values ('N') and gradients ('gradN').\n    \"\"\"\n    x, y = point\n    x0 = np.floor(x / h) * h\n    y0 = np.floor(y / h) * h\n\n    xi = (x - x0) / h\n    eta = (y - y0) / h\n\n    # Node coordinates for the cell, ordered to match N00, N10, N01, N11\n    nodes_coords = [\n        (x0, y0),          # For N00\n        (x0 + h, y0),      # For N10\n        (x0, y0 + h),      # For N01\n        (x0 + h, y0 + h),  # For N11\n    ]\n\n    # Shape function values\n    N_vals = [\n        (1 - xi) * (1 - eta),  # N00\n        xi * (1 - eta),        # N10\n        (1 - xi) * eta,        # N01\n        xi * eta,              # N11\n    ]\n\n    # Shape function gradients\n    grad_N_vals = [\n        np.array([-(1 - eta) / h, -(1 - xi) / h]),  # gradN00\n        np.array([(1 - eta) / h, -xi / h]),         # gradN10\n        np.array([-eta / h, (1 - xi) / h]),        # gradN01\n        np.array([eta / h, xi / h]),               # gradN11\n    ]\n\n    info = {}\n    for i in range(4):\n        info[nodes_coords[i]] = {'N': N_vals[i], 'gradN': grad_N_vals[i]}\n    return info\n\nclass Particle:\n    \"\"\"\n    Represents a 2D rectangular material point (particle).\n    \"\"\"\n\n    def __init__(self, xp, L, theta):\n        \"\"\"\n        Initializes the particle's geometry.\n\n        Args:\n            xp (tuple): Center coordinates (x, y).\n            L (tuple): Dimensions (Lx, Ly).\n            theta (float): Rotation angle in radians.\n        \"\"\"\n        self.xp = np.array(xp)\n        self.Lx, self.Ly = L\n        self.theta = theta\n        self.Ap = self.Lx * self.Ly\n\n        a = self.Lx / 2.0\n        b = self.Ly / 2.0\n\n        # Local corner coordinates, ordered CCW for r_c calculation\n        q_local = [\n            np.array([a, -b]),\n            np.array([a, b]),\n            np.array([-a, b]),\n            np.array([-a, -b]),\n        ]\n\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n\n        self.corners = [self.xp + R @ qc for qc in q_local]\n\ndef calculate_naive_forces(particle, p, h):\n    \"\"\"\n    Computes internal nodal forces using the naive corner-averaged mapping.\n    \"\"\"\n    grad_S = {}\n    \n    for c_idx in range(4):\n        corner_pos = particle.corners[c_idx]\n        shape_info = get_shape_info(corner_pos, h)\n        \n        for node_coord, info in shape_info.items():\n            if node_coord not in grad_S:\n                grad_S[node_coord] = np.zeros(2)\n            grad_S[node_coord] += info['gradN']\n            \n    forces = {}\n    for node_coord, summed_grad in grad_S.items():\n        avg_grad = summed_grad / 4.0\n        # Force is -Vp*p*gradS; problem states Vp = Ap\n        forces[node_coord] = -particle.Ap * p * avg_grad\n\n    return forces\n\ndef calculate_cpdi_forces(particle, p, h):\n    \"\"\"\n    Computes internal nodal forces using the CPDI mapping.\n    \"\"\"\n    corners = particle.corners\n    r_c = []\n    for c_idx in range(4):\n        c_prev = (c_idx - 1 + 4) % 4\n        c_next = (c_idx + 1) % 4\n        \n        xp_prev, yp_prev = corners[c_prev]\n        xp_next, yp_next = corners[c_next]\n        \n        r_vec = 0.5 * np.array([yp_next - yp_prev, -(xp_next - xp_prev)])\n        r_c.append(r_vec)\n        \n    grad_S = {}\n    for c_idx in range(4):\n        corner_pos = corners[c_idx]\n        shape_info = get_shape_info(corner_pos, h)\n        r_vec = r_c[c_idx]\n        \n        for node_coord, info in shape_info.items():\n            if node_coord not in grad_S:\n                grad_S[node_coord] = np.zeros(2, dtype=float)\n            grad_S[node_coord] += info['N'] * r_vec\n            \n    forces = {}\n    for node_coord, summed_N_r in grad_S.items():\n        grad = summed_N_r / particle.Ap\n        # Force is -Vp*sigma.gradS = -Vp*p*gradS; Vp=Ap\n        forces[node_coord] = -particle.Ap * p * grad\n\n    return forces\n\ndef calculate_torque(forces):\n    \"\"\"\n    Computes the total 2D torque about the origin from a set of nodal forces.\n    \"\"\"\n    tau_z = 0.0\n    for node_coord, f_int in forces.items():\n        x_i, y_i = node_coord\n        f_x, f_y = f_int\n        tau_z += x_i * f_y - y_i * f_x\n    return tau_z\n\ndef apply_correction(forces, tau_z):\n    \"\"\"\n    Applies the symmetric correction to a set of forces to nullify torque.\n    \"\"\"\n    if np.isclose(tau_z, 0.0):\n        return forces, 0.0\n        \n    node_coords_list = list(forces.keys())\n    node_coords = np.array(node_coords_list)\n    \n    if len(node_coords)  2:\n        return forces, tau_z\n\n    x_bar = np.mean(node_coords, axis=0)\n    \n    sum_sq_dist = np.sum((node_coords - x_bar)**2)\n        \n    if np.isclose(sum_sq_dist, 0.0):\n        return forces, tau_z\n\n    lambda_corr = -tau_z / sum_sq_dist\n    \n    corr_forces = {}\n    for node_coord_tuple in node_coords_list:\n        node_coord = np.array(node_coord_tuple)\n        d_i = node_coord - x_bar\n        # delta_f_i = lambda * J(d_i) where J(d_i) = [-d_i_y, d_i_x]\n        delta_f_i = lambda_corr * np.array([-d_i[1], d_i[0]])\n        corr_forces[node_coord_tuple] = forces[node_coord_tuple] + delta_f_i\n        \n    new_tau = calculate_torque(corr_forces)\n    \n    return corr_forces, new_tau\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3541779"}, {"introduction": "最后的这项练习将理论付诸实践，在一个具有挑战性的场景中检验不同映射格式的性能。这项实践将展示CPDI追踪颗粒变形能力的实际优势。通过在一个高剪切流场中，将其与一个简化的、使用固定颗粒域的方法进行比较，你将亲眼见证精确模拟颗粒形状为何能带来更准确的计算结果 [@problem_id:3541682]。", "problem": "考虑一个二维小应变岩土力学设置，其中使用物质点法（MPM），并采用以下两种映射方式之一：固定粒子域下的广义插值物质点（GIMP）映射，或根据粒子变形梯度更新粒子域角点的对流粒子域插值（CPDI）映射。设背景计算网格为覆盖单位正方形的单个双线性四边形单元，其节点位于 $(0,0)$、$(1,0)$、$(1,1)$ 和 $(0,1)$。将在空间点 $(x,y)$ 处的双线性形函数记为 $N_1(x,y)=(1-x)(1-y)$、$N_2(x,y)=x(1-y)$、$N_3(x,y)=xy$ 和 $N_4(x,y)=(1-x)y$，其梯度 $\\nabla N_i(x,y)$ 为这些函数的标准空间导数。一个密度均匀的物质点（粒子）中心位于 $(x_c,y_c)=(0.5,0.5)$，其初始矩形域的半长度为 $(w_p/2,h_p/2)$，与坐标轴对齐。\n\n空间速度场规定为 $ \\mathbf{v}(x,y) = (\\gamma y,\\, 0) $，由此产生一个恒定的速度梯度 $ \\nabla \\mathbf{v} = \\begin{bmatrix} 0  \\gamma \\\\ 0  0 \\end{bmatrix} $ 和一个对称的变形率张量 $ \\mathbf{D} = \\frac{1}{2}(\\nabla \\mathbf{v} + \\nabla \\mathbf{v}^{\\mathsf{T}}) $。假设材料具有理想刚塑性行为，其 von Mises 屈服应力为 $\\sigma_y$，单位体积的塑性功耗率为 $ \\dot{W}_p = \\sigma_y \\,\\dot{\\varepsilon}_{\\mathrm{eq}} $，其中等效应变率是 $ \\dot{\\varepsilon}_{\\mathrm{eq}} = \\sqrt{\\frac{2}{3}\\,\\mathbf{D}:\\mathbf{D}} $。在一个时间步长 $\\Delta t$ 内，给定场下的单位体积精确塑性功是 $ W_{\\mathrm{exact}} = \\sigma_y \\,\\dot{\\varepsilon}_{\\mathrm{eq}} \\,\\Delta t $，使用精确的 $ \\mathbf{D} $ 计算得出。\n\n您必须实现并比较两种用于粒子到网格传递和网格到粒子梯度恢复的映射策略：\n\n1. 对流粒子域插值（CPDI）：当前粒子域是一个平行四边形，由通过粒子变形梯度 $ \\mathbf{F}_p $ 获得的当前角点向量定义。在小时间步长的显式更新中，取 $ \\mathbf{F}_p = \\mathbf{I} + \\mathbf{L}\\,\\Delta t $，其中 $ \\mathbf{L} = \\nabla \\mathbf{v} $ 在粒子中心处求值，而 $ \\mathbf{I} $ 是单位张量。当前的半边向量是 $ \\mathbf{r}_1 = \\frac{w_p}{2}\\,\\mathbf{F}_p \\mathbf{e}_x $ 和 $ \\mathbf{r}_2 = \\frac{h_p}{2}\\,\\mathbf{F}_p \\mathbf{e}_y $，其中 $ \\mathbf{e}_x=[1,0]^{\\mathsf{T}} $ 和 $ \\mathbf{e}_y=[0,1]^{\\mathsf{T}} $。通过 $(\\xi,\\eta)\\in[-1,1]^2$ 对当前域进行参数化，映射关系为 $ \\mathbf{x}(\\xi,\\eta) = \\mathbf{x}_c + \\xi\\,\\mathbf{r}_1 + \\eta\\,\\mathbf{r}_2 $，并通过数值积分分别计算粒子到节点的质量传递 $ \\int_{\\Omega_p} N_i(\\mathbf{x})\\,\\mathrm{d}A $ 和动量传递 $ \\int_{\\Omega_p} \\mathbf{v}(\\mathbf{x})\\,N_i(\\mathbf{x})\\,\\mathrm{d}A $。节点速度为 $ \\mathbf{v}_i = \\left( \\int_{\\Omega_p} \\mathbf{v}(\\mathbf{x})\\,N_i(\\mathbf{x})\\,\\mathrm{d}A \\right)\\big/\\left( \\int_{\\Omega_p} N_i(\\mathbf{x})\\,\\mathrm{d}A \\right) $。\n\n2. GIMP 风格的固定域映射：使用相同的积分方法，但粒子域为固定的、与坐标轴对齐的矩形域，即取 $ \\mathbf{r}_1 = \\frac{w_p}{2}\\,\\mathbf{e}_x $ 和 $ \\mathbf{r}_2 = \\frac{h_p}{2}\\,\\mathbf{e}_y $，不应用 $ \\mathbf{F}_p $ 来对流角点。粒子中心保持在 $ \\mathbf{x}_c $，并且在这个固定域上执行节点质量和动量的积分。\n\n对于这两种策略，将粒子速度梯度恢复为 $ \\nabla \\mathbf{v}_p \\approx \\sum_{i=1}^4 \\mathbf{v}_i \\otimes \\nabla N_i(\\mathbf{x}_c) $，然后计算 $ \\mathbf{D}_p = \\frac{1}{2}(\\nabla \\mathbf{v}_p + \\nabla \\mathbf{v}_p^{\\mathsf{T}}) $、等效应变率 $ \\dot{\\varepsilon}_{\\mathrm{eq},p} = \\sqrt{\\frac{2}{3}\\,\\mathbf{D}_p:\\mathbf{D}_p} $ 和单位体积的塑性功 $ W_p = \\sigma_y \\,\\dot{\\varepsilon}_{\\mathrm{eq},p}\\,\\Delta t $。通过速度梯度的相对 Frobenius 范数误差 $ E_{\\nabla \\mathbf{v}} = \\|\\nabla \\mathbf{v}_p - \\nabla \\mathbf{v}\\|_F / \\|\\nabla \\mathbf{v}\\|_F $ 和塑性功的相对误差 $ E_W = |W_p - W_{\\mathrm{exact}}|/|W_{\\mathrm{exact}}| $ 来量化误差。\n\n在参数空间 $(\\xi,\\eta)\\in[-1,1]^2$ 的粒子域上使用数值积分（采用适当的高斯积分）来实现上述计算，并假设密度为单位密度，使其在节点速度计算中被抵消。使用以下三个具有指定物理参数的测试用例，内部以帕斯卡（Pa）表示塑性功，但仅输出无量纲的相对误差：\n\n- 测试用例 1（理想情况）：$ w_p = 0.20 $，$ h_p = 0.20 $，$ \\gamma = 200\\,\\mathrm{s}^{-1} $，$ \\Delta t = 2\\cdot 10^{-3}\\,\\mathrm{s} $，$ \\sigma_y = 1.5\\cdot 10^{5}\\,\\mathrm{Pa} $。\n- 测试用例 2（极端剪切，细长域）：$ w_p = 0.20 $，$ h_p = 0.05 $，$ \\gamma = 1000\\,\\mathrm{s}^{-1} $，$ \\Delta t = 10^{-3}\\,\\mathrm{s} $，$ \\sigma_y = 2.0\\cdot 10^{5}\\,\\mathrm{Pa} $。\n- 测试用例 3（小粒子，高剪切）：$ w_p = 0.05 $，$ h_p = 0.05 $，$ \\gamma = 500\\,\\mathrm{s}^{-1} $，$ \\Delta t = 5\\cdot 10^{-4}\\,\\mathrm{s} $，$ \\sigma_y = 1.0\\cdot 10^{5}\\,\\mathrm{Pa} $。\n\n您的程序应为每个测试用例计算 CPDI（更新角点）和 GIMP 风格固定域映射的相对误差对 $ E_{\\nabla \\mathbf{v}} $ 和 $ E_W $。最终输出必须是一行，包含十二个数字，按每个测试用例的 $[E_{\\nabla \\mathbf{v}}^{\\mathrm{CPDI}}, E_{\\nabla \\mathbf{v}}^{\\mathrm{fixed}}, E_{W}^{\\mathrm{CPDI}}, E_{W}^{\\mathrm{fixed}}]$ 顺序依次附加，用逗号分隔并用方括号括起来，总共十二个逗号分隔的浮点数。不得打印任何其他文本。不使用角度；时间单位为秒；速度梯度单位为 $\\mathrm{s}^{-1}$；应力单位为帕斯卡。所有输出均为无量纲的相对误差，因此输出中不包含单位字符串。", "solution": "用户提供的问题是一个有效的计算力学练习。它要求在物质点法（MPM）框架内比较两种不同的粒子到网格的映射策略：对流粒子域插值（CPDI）和使用固定粒子域的简化广义插值物质点（GIMP）法。此比较是定量的，基于恢复给定速度梯度的准确性以及随之而来的塑性功计算。所有参数、物理定律和计算步骤都已指定，使得该问题自成体系、科学基础扎实且适定。\n\n求解过程首先定义作为基准的精确解析量。随后，开发一个数值程序，使用指定的两种 MPM 映射方案计算相同的量。这涉及在粒子域上进行数值积分以将信息传递到网格，然后通过梯度恢复步骤将信息传回粒子。最后，按规定计算误差。\n\n**1. 精确解析解**\n\n问题规定了一个简单的剪切速度场 $\\mathbf{v}(x,y)$，在二维笛卡尔坐标系 $(x,y)$ 中定义为：\n$$\n\\mathbf{v}(x,y) = \\begin{pmatrix} \\gamma y \\\\ 0 \\end{pmatrix}\n$$\n其中 $\\gamma$ 是一个恒定的剪切率。速度梯度张量 $\\nabla \\mathbf{v}$ 在整个域内是均匀的：\n$$\n\\nabla \\mathbf{v} = \\begin{pmatrix} 0  \\gamma \\\\ 0  0 \\end{pmatrix}\n$$\n变形率张量 $\\mathbf{D}$，代表 $\\nabla \\mathbf{v}$ 的对称部分，为：\n$$\n\\mathbf{D} = \\frac{1}{2}(\\nabla \\mathbf{v} + \\nabla \\mathbf{v}^{\\mathsf{T}}) = \\frac{1}{2} \\begin{pmatrix} 0  \\gamma \\\\ \\gamma  0 \\end{pmatrix}\n$$\n等效应变率 $\\dot{\\varepsilon}_{\\mathrm{eq}}$ 由 $\\mathbf{D}$ 的 Frobenius 范数导出：\n$$\n\\dot{\\varepsilon}_{\\mathrm{eq}} = \\sqrt{\\frac{2}{3} \\mathbf{D}:\\mathbf{D}} = \\sqrt{\\frac{2}{3} \\sum_{i,j} D_{ij}^2} = \\sqrt{\\frac{2}{3} \\left( (\\frac{\\gamma}{2})^2 + (\\frac{\\gamma}{2})^2 \\right)} = \\sqrt{\\frac{2}{3} \\frac{\\gamma^2}{2}} = \\frac{|\\gamma|}{\\sqrt{3}}\n$$\n给定一个恒定的 von Mises 屈服应力 $\\sigma_y$ 和一个时间步长 $\\Delta t$，单位体积的精确塑性功 $W_{\\mathrm{exact}}$ 为：\n$$\nW_{\\mathrm{exact}} = \\sigma_y \\dot{\\varepsilon}_{\\mathrm{eq}} \\Delta t = \\sigma_y \\frac{|\\gamma|}{\\sqrt{3}} \\Delta t\n$$\n这些解析结果 $\\nabla \\mathbf{v}$ 和 $W_{\\mathrm{exact}}$ 作为评估数值 MPM 方案准确性的基准。用于相对误差计算的精确速度梯度的 Frobenius 范数为 $\\|\\nabla \\mathbf{v}\\|_F = \\sqrt{\\gamma^2} = |\\gamma|$。\n\n**2. 数值流程：粒子到网格和网格到粒子的传递**\n\nMPM 模拟的核心涉及将质量和动量从物质点（粒子）传递到计算网格的节点上，然后使用节点值在粒子位置恢复场梯度。粒子中心位于 $\\mathbf{x}_c = (0.5, 0.5)$，并最初占据一个尺寸为 $w_p \\times h_p$ 的矩形域 $\\Omega_p$。\n\n背景网格是一个由 4 个节点及其相关形函数 $N_i(\\mathbf{x})$ 定义的单一双线性单元。粒子属性通过在粒子域 $\\Omega_p$ 上积分来传递到节点 $i$。例如，节点 $i$ 的质量 $m_i$ 和动量 $\\mathbf{p}_i$ 计算如下：\n$$\nm_i = \\int_{\\Omega_p} \\rho N_i(\\mathbf{x}) \\mathrm{d}A\n\\quad \\text{和} \\quad\n\\mathbf{p}_i = \\int_{\\Omega_p} \\rho \\mathbf{v}(\\mathbf{x}) N_i(\\mathbf{x}) \\mathrm{d}A\n$$\n假设单位密度（$\\rho=1$），则节点速度 $\\mathbf{v}_i$ 为 $\\mathbf{v}_i = \\mathbf{p}_i / m_i$。\n\n这些积分使用高斯积分进行数值计算。粒子域，可能是一个矩形或平行四边形，从一个规范的方形域 $(\\xi, \\eta) \\in [-1, 1]^2$ 映射而来。映射由 $\\mathbf{x}(\\xi, \\eta) = \\mathbf{x}_c + \\xi \\mathbf{r}_1 + \\eta \\mathbf{r}_2$ 给出，其中 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 是粒子域的半边向量。微分面积元变换为 $\\mathrm{d}A = |\\det(J)| \\mathrm{d}\\xi \\mathrm{d}\\eta$，其中 $J = [\\mathbf{r}_1, \\mathbf{r}_2]$ 是映射的常数雅可比矩阵。积分变为：\n$$\n\\int_{\\Omega_p} f(\\mathbf{x}) \\mathrm{d}A = \\int_{-1}^{1} \\int_{-1}^{1} f(\\mathbf{x}(\\xi, \\eta)) |\\det(J)| \\mathrm{d}\\xi \\mathrm{d}\\eta \\approx |\\det(J)| \\sum_{j=1}^{N_q} \\sum_{k=1}^{N_q} w_j w_k f(\\mathbf{x}(\\xi_j, \\eta_k))\n$$\n其中 $(\\xi_j, \\eta_k)$ 是高斯点，$(w_j, w_k)$ 是对应的 $N_q \\times N_q$ 积分规则的权重。对于所涉及的多项式被积函数，$4 \\times 4$ 规则提供了足够的精度。\n\n两种映射策略在域向量 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 的定义上有所不同：\n\n- **GIMP 风格的固定域：** 粒子域保持为固定的、与坐标轴对齐的矩形。半边向量是恒定的：\n$$\n\\mathbf{r}_1 = \\begin{pmatrix} w_p/2 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{r}_2 = \\begin{pmatrix} 0 \\\\ h_p/2 \\end{pmatrix}\n$$\n\n- **CPDI（对流粒子域插值）：** 粒子域随流变形。粒子处的变形梯度 $\\mathbf{F}_p$ 使用速度梯度 $\\mathbf{L} = \\nabla\\mathbf{v}(\\mathbf{x}_c)$ 在时间步长 $\\Delta t$ 内更新：\n$$\n\\mathbf{F}_p = \\mathbf{I} + \\mathbf{L} \\Delta t = \\begin{pmatrix} 1  \\gamma \\Delta t \\\\ 0  1 \\end{pmatrix}\n$$\n当前的半边向量通过变换初始向量 $\\mathbf{e}_x = [1,0]^{\\mathsf{T}}$ 和 $\\mathbf{e}_y = [0,1]^{\\mathsf{T}}$ 获得：\n$$\n\\mathbf{r}_1 = \\frac{w_p}{2} \\mathbf{F}_p \\mathbf{e}_x = \\begin{pmatrix} w_p/2 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{r}_2 = \\frac{h_p}{2} \\mathbf{F}_p \\mathbf{e}_y = \\begin{pmatrix} (h_p/2)\\gamma\\Delta t \\\\ h_p/2 \\end{pmatrix}\n$$\n这导致积分域为一个剪切的平行四边形。\n\n**3. 梯度恢复与误差计算**\n\n在为每种策略计算出节点速度 $\\mathbf{v}_i$ 后，使用计算出的节点速度和形函数在粒子中心 $\\mathbf{x}_c$ 处的解析梯度 $\\nabla N_i(\\mathbf{x}_c)$ 来恢复速度梯度：\n$$\n\\nabla \\mathbf{v}_p \\approx \\sum_{i=1}^{4} \\mathbf{v}_i \\otimes \\nabla N_i(\\mathbf{x}_c)\n$$\n其中 $\\otimes$ 表示外积。从恢复的 $\\nabla \\mathbf{v}_p$，使用与精确量相同的公式计算相应的粒子变形率张量 $\\mathbf{D}_p$、等效应变率 $\\dot{\\varepsilon}_{\\mathrm{eq},p}$ 和塑性功 $W_p$。\n\n最后，计算相对误差以量化每种方法的准确性：\n$$\nE_{\\nabla \\mathbf{v}} = \\frac{\\|\\nabla \\mathbf{v}_p - \\nabla \\mathbf{v}\\|_F}{\\|\\nabla \\mathbf{v}\\|_F}\n\\quad \\text{和} \\quad\nE_W = \\frac{|W_p - W_{\\mathrm{exact}}|}{|W_{\\mathrm{exact}}|}\n$$\n对问题陈述中指定的三个测试用例中的每一个重复此过程，总共生成十二个误差值。预计 CPDI 会产生较低的误差，因为它明确考虑了域的剪切变形，而固定域方法忽略了这一点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef get_gauss_quadrature(n):\n    \"\"\"Returns Gauss-Legendre quadrature points and weights for the interval [-1, 1].\"\"\"\n    points, weights = special.roots_legendre(n)\n    return points, weights\n\ndef shape_functions(x, y):\n    \"\"\"Evaluates bilinear shape functions at a point (x, y).\"\"\"\n    N1 = (1 - x) * (1 - y)\n    N2 = x * (1 - y)\n    N3 = x * y\n    N4 = (1 - x) * y\n    return np.array([N1, N2, N3, N4])\n\ndef shape_function_gradients(x, y):\n    \"\"\"Evaluates the gradients of bilinear shape functions at a point (x, y).\"\"\"\n    grad_N1 = np.array([-(1 - y), -(1 - x)])\n    grad_N2 = np.array([1 - y, -x])\n    grad_N3 = np.array([y, x])\n    grad_N4 = np.array([-y, 1 - x])\n    return [grad_N1, grad_N2, grad_N3, grad_N4]\n\ndef velocity_field(x, y, gamma):\n    \"\"\"Evaluates the prescribed velocity field v(x,y) = (gamma*y, 0).\"\"\"\n    return np.array([gamma * y, 0.0])\n\ndef compute_errors_for_mapping(params, mapping_type):\n    \"\"\"\n    Computes relative errors for a given mapping strategy (CPDI or Fixed).\n\n    Args:\n        params (tuple): A tuple of (wp, hp, gamma, dt, sigma_y).\n        mapping_type (str): Either 'CPDI' or 'Fixed'.\n\n    Returns:\n        tuple: A tuple containing (E_grad_v, E_W).\n    \"\"\"\n    wp, hp, gamma, dt, sigma_y = params\n    x_c = np.array([0.5, 0.5])\n\n    # 1. Compute exact analytical values\n    grad_v_exact = np.array([[0.0, gamma], [0.0, 0.0]])\n    norm_grad_v_exact = np.linalg.norm(grad_v_exact, 'fro')\n    if np.isclose(norm_grad_v_exact, 0): norm_grad_v_exact = 1.0 # Avoid division by zero\n\n    D_exact = 0.5 * (grad_v_exact + grad_v_exact.T)\n    D_colon_D_exact = np.sum(D_exact * D_exact)\n    e_eq_dot_exact = np.sqrt(2.0 / 3.0 * D_colon_D_exact)\n    W_exact = sigma_y * e_eq_dot_exact * dt\n    if np.isclose(W_exact, 0): W_exact = 1.0 # Avoid division by zero\n\n    # Get shape function gradients at particle center (constant for all calculations)\n    grads_N_at_xc = shape_function_gradients(x_c[0], x_c[1])\n\n    # 2. Define particle domain half-edge vectors r1, r2 based on mapping type\n    if mapping_type == 'Fixed':\n        r1 = np.array([wp / 2.0, 0.0])\n        r2 = np.array([0.0, hp / 2.0])\n    else:  # CPDI\n        Fp = np.array([[1.0, gamma * dt], [0.0, 1.0]])\n        r1 = (wp / 2.0) * Fp @ np.array([1.0, 0.0])\n        r2 = (hp / 2.0) * Fp @ np.array([0.0, 1.0])\n\n    # 3. Compute Jacobian determinant for numerical integration\n    J_det = r1[0] * r2[1] - r1[1] * r2[0]\n\n    # 4. Set up numerical quadrature\n    n_gauss = 4\n    g_points, g_weights = get_gauss_quadrature(n_gauss)\n\n    # 5. Perform particle-to-grid transfer (mass and momentum) via numerical integration\n    m_i = np.zeros(4)\n    p_i = np.zeros((4, 2))\n    for i in range(n_gauss):\n        for j in range(n_gauss):\n            xi, eta = g_points[i], g_points[j]\n            w_xi, w_eta = g_weights[i], g_weights[j]\n\n            # Map from quadrature point in [-1,1]^2 to spatial position\n            pos = x_c + xi * r1 + eta * r2\n            x, y = pos[0], pos[1]\n            \n            # Evaluate quantities at the spatial position\n            Ni_vals = shape_functions(x, y)\n            v_val = velocity_field(x, y, gamma)\n\n            # Accumulate integrals for mass and momentum\n            dV = J_det * w_xi * w_eta\n            m_i += Ni_vals * dV\n            p_i += np.outer(Ni_vals, v_val) * dV\n    \n    # 6. Compute nodal velocities\n    v_i = np.zeros((4, 2))\n    for i in range(4):\n        if m_i[i]  1e-15:\n            v_i[i, :] = p_i[i, :] / m_i[i]\n    \n    # 7. Recover particle velocity gradient from nodal velocities\n    grad_v_p = np.zeros((2, 2))\n    for i in range(4):\n        grad_v_p += np.outer(v_i[i, :], grads_N_at_xc[i])\n\n    # 8. Compute particle rate-of-deformation, strain rate, and plastic work\n    D_p = 0.5 * (grad_v_p + grad_v_p.T)\n    D_p_colon_D_p = np.sum(D_p * D_p)\n    e_eq_dot_p = np.sqrt(2.0 / 3.0 * D_p_colon_D_p)\n    W_p = sigma_y * e_eq_dot_p * dt\n\n    # 9. Compute relative errors\n    error_grad_v = np.linalg.norm(grad_v_p - grad_v_exact, 'fro') / norm_grad_v_exact\n    error_W = np.abs(W_p - W_exact) / np.abs(W_exact)\n\n    return error_grad_v, error_W\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (wp, hp, gamma, dt, sigma_y)\n        (0.20, 0.20, 200.0, 2e-3, 1.5e5),\n        (0.20, 0.05, 1000.0, 1e-3, 2.0e5),\n        (0.05, 0.05, 500.0, 5e-4, 1.0e5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        E_grad_v_cpdi, E_w_cpdi = compute_errors_for_mapping(case, 'CPDI')\n        E_grad_v_fixed, E_w_fixed = compute_errors_for_mapping(case, 'Fixed')\n        all_results.extend([E_grad_v_cpdi, E_grad_v_fixed, E_w_cpdi, E_w_fixed])\n\n    # Format the output as a single-line comma-separated list in brackets\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "3541682"}]}