{"hands_on_practices": [{"introduction": "本练习将提供梯度损伤模型的实践经验，这是解决不适定局部化问题的有力工具。通过推导和求解控制方程，您将直接观察到内部长度尺度参数 $l$ 如何控制损伤区的宽度，从而防止病态的网格依赖性。[@problem_id:3510328]", "problem": "考虑一根占据区间 $x \\in [0,L]$ 且承受单调递增拉力的一维杆。标量损伤变量 $D(x)$ 满足 $D(x) \\in [0,1]$，其中 $D(x) = 0$ 表示未损伤材料，$D(x) = 1$ 表示完全损伤材料。在正则化梯度损伤框架中，$D(x)$ 的准静态稳态是通过最小化一个二次能量泛函来获得的，该泛函通过惩罚 $D(x)$ 的梯度来引入一个内禀长度尺度。设给定的能量释放率场为 $Y(x)$，材料强度参数为 $Y_c  0$。定义归一化驱动项 $s(x)$ 为\n$$\ns(x) = \\min\\left\\{1,\\ \\frac{Y(x)}{Y_c}\\right\\}。\n$$\n采用正则化能量泛函\n$$\n\\Pi[D] = \\int_{0}^{L} \\left( \\frac{1}{2}\\left(D(x) - s(x)\\right)^2 + \\frac{l^2}{2}\\left(\\frac{dD}{dx}(x)\\right)^2 \\right)\\, dx,\n$$\n其中 $l  0$ 是控制损伤局部化区域宽度的内禀长度参数。\n\n您的任务是：\n- 从上述泛函出发，使用变分法推导 $\\Pi[D]$ 在 $D(x)$ 的任意容许变分下达到平稳的必要条件，并获得 $D(x)$ 的控制微分方程以及在 $[0,L]$ 上的自然边界条件。\n- 对于给定的 $Y(x)$，数值求解所推导出的稳态方程以获得 $D(x)$，并量化损伤局部化区域的特征宽度，即 $D(x)$ 的半峰全宽（Full Width at Half Maximum (FWHM)），也就是 $D(x)$ 等于其最大值一半的两个点之间的距离。如果域内未能穿过半峰值水平，则定义 FWHM 为 $L$。\n- 在 $[0,L]$ 上由 $N = 1001$ 个均匀间隔点组成的网格上，实现一个均匀有限差分格式。使用从变分推导中产生的自然边界条件。\n- 使用以下测试组，其中给定的能量释放率是一个中心高斯分布：\n$$\nY(x) = Y_{\\max}\\, \\exp\\!\\left(-\\frac{(x - L/2)^2}{2\\,a^2}\\right),\n$$\n其中 $L = 1$, $Y_c = 1$，并且 $(Y_{\\max}, a, l)$ 取以下组合：\n    - 测试 $1$：$Y_{\\max} = 1.5$, $a = 0.06$, $l = 0.02$。\n    - 测试 $2$：$Y_{\\max} = 1.5$, $a = 0.06$, $l = 0.005$。\n    - 测试 $3$：$Y_{\\max} = 1.5$, $a = 0.06$, $l = 0.08$。\n    - 测试 $4$：$Y_{\\max} = 0.9$, $a = 0.06$, $l = 0.02$。\n- 对每个测试，计算损伤分布 $D(x)$ 和 $D(x)$ 的 FWHM。报告归一化的 FWHM $\\tilde{w} = \\mathrm{FWHM}/L$（无量纲，无物理单位），并四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试 $1$ 到测试 $4$ 顺序排列的结果，形式为逗号分隔的列表并用方括号括起。例如，输出应如下所示：\n$[r_1,r_2,r_3,r_4]$，\n其中每个 $r_i$ 是测试 $i$ 的归一化 FWHM，四舍五入到六位小数。", "solution": "该问题要求从给定的能量泛函推导标量损伤变量 $D(x)$ 的控制方程，对所得的边值问题进行数值求解，并计算若干测试用例的半峰全宽（FWHM）。\n\n### 第1部分：变分推导\n\n分析始于在域 $x \\in [0,L]$ 上定义的能量泛函 $\\Pi[D]$：\n$$\n\\Pi[D] = \\int_{0}^{L} \\mathcal{L}\\left(x, D(x), D'(x)\\right) \\, dx\n$$\n其中 $D'(x) = \\frac{dD}{dx}(x)$，拉格朗日密度 $\\mathcal{L}$ 由下式给出：\n$$\n\\mathcal{L}\\left(x, D, D'\\right) = \\frac{1}{2}\\left(D(x) - s(x)\\right)^2 + \\frac{l^2}{2}\\left(D'(x)\\right)^2\n$$\n这里，$s(x) = \\min\\left\\{1, Y(x)/Y_c\\right\\}$ 是归一化驱动项，$l  0$ 是内禀长度参数。\n\n为找到稳态损伤分布 $D(x)$，我们寻求最小化此能量泛函的函数。$\\Pi[D]$ 达到平稳的必要条件是其一阶变分 $\\delta \\Pi$ 对于任意容许变分 $\\delta D(x)$ 必须为零。一阶变分由下式给出：\n$$\n\\delta \\Pi = \\int_{0}^{L} \\left( \\frac{\\partial \\mathcal{L}}{\\partial D} \\delta D + \\frac{\\partial \\mathcal{L}}{\\partial D'} \\delta D' \\right) dx = 0\n$$\n拉格朗日密度 $\\mathcal{L}$ 对 $D$ 和 $D'$ 的偏导数是：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial D} = D(x) - s(x)\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial D'} = l^2 D'(x)\n$$\n将这些代入 $\\delta \\Pi$ 的表达式中，得到：\n$$\n\\delta \\Pi = \\int_{0}^{L} \\left( \\left(D(x) - s(x)\\right) \\delta D(x) + l^2 D'(x) \\delta D'(x) \\right) dx = 0\n$$\n为了消除 $\\delta D'$，我们对第二项进行分部积分，其中 $\\int u \\, dv = [uv] - \\int v \\, du$。令 $u = l^2 D'(x)$ 且 $dv = \\delta D'(x) \\, dx$，因此 $du = l^2 D''(x) \\, dx$ 且 $v = \\delta D(x)$。这给出：\n$$\n\\int_{0}^{L} l^2 D'(x) \\delta D'(x) \\, dx = \\left[ l^2 D'(x) \\delta D(x) \\right]_{0}^{L} - \\int_{0}^{L} l^2 D''(x) \\delta D(x) \\, dx\n$$\n将此结果代回 $\\delta \\Pi$ 的表达式：\n$$\n\\delta \\Pi = \\int_{0}^{L} \\left( D(x) - s(x) - l^2 D''(x) \\right) \\delta D(x) \\, dx + \\left[ l^2 D'(x) \\delta D(x) \\right]_{0}^{L} = 0\n$$\n此方程必须对所有容许变分 $\\delta D(x)$ 成立。根据变分法基本引理，为使积分项在开区间 $(0, L)$ 上对任意 $\\delta D(x)$ 都为零，乘以 $\\delta D(x)$ 的被积函数必须为零。这得出了欧拉-拉格朗日方程，也就是 $D(x)$ 的控制微分方程：\n$$\nD(x) - s(x) - l^2 D''(x) = 0\n$$\n整理后得到一个线性的二阶常微分方程（亥姆霍兹方程的一种形式）：\n$$\n-l^2 \\frac{d^2D}{dx^2} + D(x) = s(x)\n$$\n此外，边界项也必须为零：\n$$\n\\left[ l^2 D'(x) \\delta D(x) \\right]_{0}^{L} = l^2 D'(L) \\delta D(L) - l^2 D'(0) \\delta D(0) = 0\n$$\n由于没有规定 $D(0)$ 和 $D(L)$ 的具体值（即没有施加本质边界条件），变分 $\\delta D(0)$ 和 $\\delta D(L)$ 是任意的。为使边界项为零，它们的系数必须为零。这提供了**自然边界条件**：\n$$\n\\frac{dD}{dx}(0) = 0 \\quad \\text{和} \\quad \\frac{dD}{dx}(L) = 0\n$$\n这些是齐次诺伊曼边界条件，意味着损伤梯度在杆的两端为零。\n\n### 第2部分：数值实现策略\n\n所推导的边值问题使用均匀网格上的有限差分法进行数值求解。\n\n**离散化：**\n将域 $[0,L]$ 离散为 $N$ 个等间距节点 $x_i = i \\cdot \\Delta x$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/(N-1)$。令 $D_i = D(x_i)$ 和 $s_i = s(x_i)$。\n\n**有限差分近似：**\n在内部节点 $x_i$（$1 \\le i \\le N-2$）处的二阶导数 $D''(x)$ 使用二阶中心差分格式近似：\n$$\n\\frac{d^2D}{dx^2}(x_i) \\approx \\frac{D_{i-1} - 2D_i + D_{i+1}}{(\\Delta x)^2}\n$$\n将此代入控制常微分方程，得到内部节点的离散方程：\n$$\n-l^2 \\left( \\frac{D_{i-1} - 2D_i + D_{i+1}}{(\\Delta x)^2} \\right) + D_i = s_i\n$$\n稍作整理，我们得到：\n$$\n\\left(-\\frac{l^2}{(\\Delta x)^2}\\right) D_{i-1} + \\left(1 + \\frac{2l^2}{(\\Delta x)^2}\\right) D_i + \\left(-\\frac{l^2}{(\\Delta x)^2}\\right) D_{i+1} = s_i\n$$\n\n**边界条件：**\n诺伊曼边界条件 $D'(0)=0$ 和 $D'(L)=0$ 通过使用虚拟点和中心差分来处理，以保持二阶精度。\n在左边界（$x_0=0$），$D'(0) \\approx \\frac{D_1 - D_{-1}}{2\\Delta x} = 0$，这意味着 $D_{-1} = D_1$。在 $i=0$ 处应用离散常微分方程并代入 $D_{-1}=D_1$：\n$$\n\\left(1 + \\frac{2l^2}{(\\Delta x)^2}\\right) D_0 + \\left(-\\frac{2l^2}{(\\Delta x)^2}\\right) D_1 = s_0\n$$\n在右边界（$x_{N-1}=L$），$D'(L) \\approx \\frac{D_N - D_{N-2}}{2\\Delta x} = 0$，这意味着 $D_N = D_{N-2}$。在 $i=N-1$ 处应用离散常微分方程并代入 $D_N=D_{N-2}$：\n$$\n\\left(-\\frac{2l^2}{(\\Delta x)^2}\\right) D_{N-2} + \\left(1 + \\frac{2l^2}{(\\Delta x)^2}\\right) D_{N-1} = s_{N-1}\n$$\n\n**线性系统：**\n这些方程构成了一个关于 $N$ 个未知数 $D_0, D_1, \\dots, D_{N-1}$ 的 $N$ 个线性代数方程组，可以写成矩阵形式 $\\mathbf{A}\\mathbf{D} = \\mathbf{s}$。矩阵 $\\mathbf{A}$ 是一个对称三对角矩阵，其第一行和最后一行的元素经过修改以考虑边界条件。这个系统可以使用标准的线性代数程序求解。\n\n### 第3部分：FWHM 计算\n\n一旦获得离散解向量 $\\mathbf{D}$，FWHM 的计算如下：\n1.  找到最大损伤值 $D_{\\max} = \\max_i(D_i)$。\n2.  计算半峰值 $D_{\\text{half}} = D_{\\max} / 2$。\n3.  根据问题陈述，如果损伤分布未穿过 $D_{\\text{half}}$ 水平（如果 $D_0 \\ge D_{\\text{half}}$ 则会发生），FWHM 定义为 $L$。\n4.  否则，找到 $D(x) = D_{\\text{half}}$ 的两个位置 $x_{\\text{left}}$ 和 $x_{\\text{right}}$。这是通过找到 $(D_k - D_{\\text{half}})$ 符号发生变化的网格索引 $k$ 来完成的。由于问题的对称性，预计会有两个这样的交叉点。\n5.  在每个交叉点处，使用相邻网格点之间的线性插值来找到具有子网格精度的 $x_{\\text{left}}$ 和 $x_{\\text{right}}$。对于 $x_k$ 和 $x_{k+1}$ 之间的交叉点：\n    $$\n    x_{\\text{cross}} = x_k + \\Delta x \\frac{D_{\\text{half}} - D_k}{D_{k+1} - D_k}\n    $$\n6.  然后计算 FWHM 为 $\\mathrm{FWHM} = x_{\\text{right}} - x_{\\text{left}}$。\n7.  最后，归一化的 FWHM 为 $\\tilde{w} = \\mathrm{FWHM}/L$。\n\n对每个测试用例应用此过程以计算所需的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gradient-damage problem for a 1D bar and computes the FWHM of the damage profile.\n    \"\"\"\n    # Define the common parameters and test cases from the problem statement.\n    L = 1.0\n    Y_c = 1.0\n    N = 1001\n\n    test_cases = [\n        # (Y_max, a, l)\n        (1.5, 0.06, 0.02),   # Test 1\n        (1.5, 0.06, 0.005),  # Test 2\n        (1.5, 0.06, 0.08),   # Test 3\n        (0.9, 0.06, 0.02),   # Test 4\n    ]\n\n    results = []\n\n    # Discretize the domain\n    dx = L / (N - 1)\n    x = np.linspace(0.0, L, N)\n\n    for Y_max, a, l in test_cases:\n        # 1. Calculate the normalized driving term s(x)\n        Y = Y_max * np.exp(-(x - L/2)**2 / (2 * a**2))\n        s = np.minimum(1.0, Y / Y_c)\n\n        # 2. Set up the linear system of equations AD = s for the finite difference scheme\n        A = np.zeros((N, N))\n        \n        # Coefficients from the discretized ODE\n        c1 = -l**2 / dx**2\n        c2 = 1.0 - 2.0 * c1\n\n        # Assemble the matrix A\n        # Diagonal elements\n        main_diag = np.full(N, c2)\n        off_diag = np.full(N - 1, c1)\n        \n        A += np.diag(main_diag)\n        A += np.diag(off_diag, k=1)\n        A += np.diag(off_diag, k=-1)\n\n        # Apply natural boundary conditions (D'=0) by modifying the first and last rows\n        # D'_0 = 0 -> D_{-1} = D_1\n        A[0, 1] = 2.0 * c1\n        # D'_{N-1} = 0 -> D_N = D_{N-2}\n        A[N - 1, N - 2] = 2.0 * c1\n        \n        # 3. Solve the linear system for the damage profile D\n        D = np.linalg.solve(A, s)\n\n        # 4. Calculate the Full Width at Half Maximum (FWHM)\n        D_max = np.max(D)\n        D_half = D_max / 2.0\n        \n        # Check for the edge case where the half-maximum level is not crossed\n        if D[0] >= D_half:\n            fwhm = L\n        else:\n            # Find indices where the profile crosses the half-maximum level\n            # These are the indices k where the sign of (D - D_half) changes between k and k+1\n            cross_indices = np.where(np.diff(np.sign(D - D_half)) != 0)[0]\n            \n            if len(cross_indices)  2:\n                # Should not happen for the given symmetric profiles unless D_max is close to D at boundary\n                fwhm = L\n            else:\n                # Left crossing\n                k_left = cross_indices[0]\n                # Linear interpolation for x_left\n                x_left = x[k_left] + dx * (D_half - D[k_left]) / (D[k_left + 1] - D[k_left])\n                \n                # Right crossing\n                k_right = cross_indices[-1] # Use last found crossing\n                # Linear interpolation for x_right\n                x_right = x[k_right] + dx * (D_half - D[k_right]) / (D[k_right + 1] - D[k_right])\n                \n                fwhm = x_right - x_left\n        \n        # Normalize FWHM and round to six decimal places\n        normalized_fwhm = round(fwhm / L, 6)\n        results.append(normalized_fwhm)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3510328"}, {"introduction": "本实践探讨了内聚力区模型的构建，这是模拟岩土地质材料断裂的基石。您将从一个区分拉伸和压缩的热力学势函数中推导出牵引力-分离律，并实现一个混合模式断裂模型，以验证其能量上的一致性。[@problem_id:3510324]", "problem": "考虑一个用于小位移下岩土地质材料的界面损伤公式，该公式使用拉伸-压缩分离来防止压缩下的损伤增长，并能够模拟混合模式断裂。设未知量为标量损伤变量 $d \\in [0,1]$、法向分离量 $\\delta_n$（拉伸时为正）以及切向分离量 $\\delta_s$。单位面积的界面自由能假设为\n$$\n\\psi(\\delta_n,\\delta_s,d) = (1-d)\\,\\frac{k}{2}\\left(\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^{2}\\right) + \\frac{k}{2}\\,\\langle \\delta_n \\rangle_{-}^{2},\n$$\n其中 $k0$ 是弹性罚刚度，$\\langle x \\rangle_{+}=\\max(x,0)$ 和 $\\langle x \\rangle_{-}=\\min(x,0)$ 是麦考利括号。界面牵引力遵循能量共轭关系 $\\mathbf{t} = \\partial \\psi/\\partial \\boldsymbol{\\delta}$，其中 $\\boldsymbol{\\delta}=(\\delta_n,\\delta_s)$。损伤由单调不减的历史变量 $r(t) = \\max_{\\tau \\le t}\\,\\delta_{\\mathrm{eq}}(\\tau)$ 驱动，其中等效分离量为\n$$\n\\delta_{\\mathrm{eq}} = \\sqrt{\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^{2}}.\n$$\n当 $\\delta_{\\mathrm{eq}} = \\delta_0$ 时损伤开始，其中 $\\delta_0 = t_0/k$，$t_0$ 是一个预设的峰值等效牵引力。损伤开始后，在等效分离量上采用线性软化，使得当 $\\delta_{\\mathrm{eq}}=\\delta_0$ 时 $d=0$，当 $\\delta_{\\mathrm{eq}}=\\delta_f(\\varphi)$ 时 $d=1$，其中 $\\delta_f(\\varphi)$ 的选择通过以下方式匹配混合模式断裂能 $G_c(\\varphi)$：\n$$\n\\delta_f(\\varphi) = \\frac{2\\,G_c(\\varphi)}{t_0}.\n$$\n假设混合模式断裂抗力遵循经过充分检验的Benzeggagh–Kenane (BK) 定律\n$$\nG_c(\\varphi) = G_{Ic} + \\big(G_{IIc} - G_{Ic}\\big)\\,\\varphi^{\\eta},\n$$\n其中 $G_{Ic}$ 和 $G_{IIc}$ 分别是纯I型（张开）和纯II型（剪切）模式下的临界能量释放率，$\\eta \\ge 1$ 是一个指数，模式混合度参数 $\\varphi \\in [0,1]$ 在损伤开始时定义为储存在剪切中的可恢复弹性能占总可恢复弹性能的比例，即\n$$\n\\varphi = \\frac{\\delta_s^2}{\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^2}\\Bigg|_{\\delta_{\\mathrm{eq}}=\\delta_0}.\n$$\n\n任务：\n1) 从自由能 $\\psi$ 出发，推导界面的牵引力-分离关系。然后，使用等效分离量 $\\delta_{\\mathrm{eq}}$ 和线性软化假设，证明在拉伸状态下、$\\delta_s/\\langle \\delta_n \\rangle_{+}$ 比值固定的比例加载路径下，直至完全破坏所耗散的总分离功等于由Benzeggagh–Kenane定律定义的 $G_c(\\varphi)$。解释为何在 $\\delta_s=0$ 的纯压缩条件下不能引发损伤演化。\n\n2) 使用您的推导，实现一个算法，在给定材料参数和加载路径的情况下，评估以下内容：\n- 在拉伸状态下、$\\delta_s/\\langle \\delta_n \\rangle_{+}$ 比值恒定的比例路径上，预测的直至破坏的耗散分离功 $G_{\\text{pred}}$。将 $G_{\\text{pred}}$ 与使用相同参数构建的目标值 $G_c(\\varphi)$ 进行比较，并报告比值 $G_{\\text{pred}}/G_c(\\varphi)$（无量纲）。\n- 在单步位移跳跃 $(\\delta_n,\\delta_s)$ 下的损伤起始检查，通过测试 $\\delta_{\\mathrm{eq}} \\ge \\delta_0$ 并返回一个布尔值。\n\n3) 在国际单位制 (SI) 和测试套件中使用以下物理上合理的参数值：\n- 弹性罚刚度 $k = 1.0 \\times 10^{12}$ N/m$^3$。\n- 峰值等效牵引力 $t_0 = 3.0 \\times 10^{6}$ N/m$^2$。\n- I型断裂能 $G_{Ic} = 150.0$ N/m。\n- II型断裂能 $G_{IIc} = 600.0$ N/m。\n- Benzeggagh–Kenane 指数 $\\eta = 1.5$。\n\n评估以下五个案例：\n- 案例A（纯I型）：比例加载，拉伸时 $\\delta_s/\\langle \\delta_n \\rangle_{+} = 0$。输出浮点数 $G_{\\text{pred}}/G_c$。\n- 案例B（纯II型）：比例加载，$\\langle \\delta_n \\rangle_{+} = 0$ 且 $\\delta_s  0$。输出浮点数 $G_{\\text{pred}}/G_c$。\n- 案例C（混合模式）：比例加载，拉伸时 $\\delta_s/\\langle \\delta_n \\rangle_{+} = 1$。输出浮点数 $G_{\\text{pred}}/G_c$。\n- 案例D（仅压缩）：单步跳跃 $\\delta_n = -1.0\\times 10^{-5}$ m, $\\delta_s = 0.0$ m。输出一个布尔值，指示是否发生损伤起始。\n- 案例E（带剪切的压缩，剪切超过阈值）：单步跳跃 $\\delta_n = -1.0\\times 10^{-5}$ m, $\\delta_s = 4.0\\times 10^{-6}$ m。输出一个布尔值，指示是否发生损伤起始。\n\n数值和单位说明：\n- 所有内部计算均使用SI单位（能量为N/m，牵引力为N/m$^2$，分离量为m）。\n- 案例A–C的输出必须是无量纲浮点数，保留六位小数。\n- 案例D–E的输出必须是布尔值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为[案例A, 案例B, 案例C, 案例D, 案例E]。例如：\"[1.000000,1.000000,1.000000,False,True]\"。", "solution": "**第一部分：理论推导**\n\n此问题描述了一个界面内聚区模型，这是计算断裂力学中广泛使用的工具。我们将首先推导界面牵引力的本构关系，然后通过证明分离功与规定的断裂能相匹配来验证模型的能量一致性，最后解释模型在纯压缩下的行为。\n\n**牵引力-分离关系的推导**\n\n界面牵引力 $\\mathbf{t} = (t_n, t_s)$ 与分离向量 $\\boldsymbol{\\delta}=(\\delta_n, \\delta_s)$ 在热力学上共轭，由自由能势 $\\psi$ 导出，即 $\\mathbf{t} = \\partial \\psi/\\partial \\boldsymbol{\\delta}$。自由能密度由下式给出：\n$$\n\\psi(\\delta_n,\\delta_s,d) = (1-d)\\,\\frac{k}{2}\\left(\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^{2}\\right) + \\frac{k}{2}\\,\\langle \\delta_n \\rangle_{-}^{2}\n$$\n其中 $k$ 是弹性罚刚度，$d$ 是损伤变量，$\\langle \\cdot \\rangle_+, \\langle \\cdot \\rangle_-$ 是麦考利括号。\n\n法向牵引力 $t_n$ 是 $\\psi$ 对 $\\delta_n$ 的偏导数：\n$$\nt_n = \\frac{\\partial\\psi}{\\partial\\delta_n} = (1-d)\\,\\frac{k}{2}\\,\\frac{\\partial}{\\partial\\delta_n}(\\langle \\delta_n \\rangle_{+}^{2}) + \\frac{k}{2}\\,\\frac{\\partial}{\\partial\\delta_n}(\\langle \\delta_n \\rangle_{-}^{2})\n$$\n麦考利括号平方的导数是 $\\frac{d}{dx}\\langle x \\rangle_+^2 = 2\\langle x \\rangle_+$ 和 $\\frac{d}{dx}\\langle x \\rangle_-^2 = 2\\langle x \\rangle_-$。应用这些导数可得：\n$$\nt_n = (1-d)\\,k\\,\\langle \\delta_n \\rangle_{+} + k\\,\\langle \\delta_n \\rangle_{-}\n$$\n该关系捕捉了非对称响应：对于拉伸张开（$\\delta_n  0$），$\\langle \\delta_n \\rangle_{+} = \\delta_n$ 且 $\\langle \\delta_n \\rangle_{-} = 0$，因此 $t_n = (1-d)k\\delta_n$。对于压缩（$\\delta_n  0$），$\\langle \\delta_n \\rangle_{+} = 0$ 且 $\\langle \\delta_n \\rangle_{-} = \\delta_n$，因此 $t_n = k\\delta_n$。压缩刚度与损伤无关，这是岩土地质材料的一个关键特征。\n\n切向（剪切）牵引力 $t_s$ 是 $\\psi$ 对 $\\delta_s$ 的偏导数：\n$$\nt_s = \\frac{\\partial\\psi}{\\partial\\delta_s} = (1-d)\\,\\frac{k}{2}\\,(2\\delta_s) = (1-d)\\,k\\,\\delta_s\n$$\n剪切刚度 $(1-d)k$ 会随损伤而退化，与法向分离的正负无关。\n\n**比例加载下的分离功**\n\n分离功，即断裂能，是牵引力为完全分离界面所做的总功。对于一个从完好状态（$\\boldsymbol{\\delta}=\\mathbf{0}$）到完全破坏状态的加载过程，该功由路径积分 $W = \\int_{\\text{path}} \\mathbf{t} \\cdot d\\boldsymbol{\\delta}$ 给出。在完全破坏时，储存的弹性能假定为零（对于拉伸路径），因此总功等于耗散的能量。\n\n我们考虑一个比例拉伸加载路径，其中比率 $\\delta_s/\\langle \\delta_n \\rangle_{+}$ 是常数。由于处于拉伸状态，$\\delta_n  0$，所以 $\\langle \\delta_n \\rangle_+ = \\delta_n$。设 $\\delta_s = \\beta \\delta_n$，其中常数 $\\beta \\ge 0$。无穷小分离向量为 $d\\boldsymbol{\\delta} = (d\\delta_n, d\\delta_s) = (d\\delta_n, \\beta d\\delta_n)$。模式混合度参数 $\\varphi$ 沿此路径为常数：\n$$\n\\varphi = \\frac{\\delta_s^2}{\\delta_n^2 + \\delta_s^2} = \\frac{(\\beta\\delta_n)^2}{\\delta_n^2 + (\\beta\\delta_n)^2} = \\frac{\\beta^2}{1+\\beta^2}\n$$\n等效分离量 $\\delta_{\\mathrm{eq}} = \\sqrt{\\delta_n^2 + \\delta_s^2} = \\sqrt{\\delta_n^2 + \\beta^2\\delta_n^2} = \\delta_n\\sqrt{1+\\beta^2}$。因此，我们可以用 $\\delta_{\\mathrm{eq}}$ 表示 $\\delta_n$ 和 $\\delta_s$：\n$$\n\\delta_n = \\frac{\\delta_{\\mathrm{eq}}}{\\sqrt{1+\\beta^2}}, \\quad \\delta_s = \\frac{\\beta \\delta_{\\mathrm{eq}}}{\\sqrt{1+\\beta^2}}\n$$\n此拉伸路径的牵引力分量为 $t_n = (1-d)k\\delta_n$ 和 $t_s = (1-d)k\\delta_s$。功增量为：\n\\begin{align*}\ndW = t_n d\\delta_n + t_s d\\delta_s \\\\\n= (1-d)k\\delta_n\\,d\\delta_n + (1-d)k\\delta_s\\,d\\delta_s \\\\\n= (1-d)k\\, \\frac{1}{2} d(\\delta_n^2 + \\delta_s^2) \\\\\n= (1-d)k\\, \\frac{1}{2} d(\\delta_{\\mathrm{eq}}^2) = (1-d)k\\,\\delta_{\\mathrm{eq}}\\,d\\delta_{\\mathrm{eq}}\n\\end{align*}\n我们定义一个等效牵引力 $t_{\\mathrm{eq}} = (1-d)k\\delta_{\\mathrm{eq}}$。那么 $dW = t_{\\mathrm{eq}} d\\delta_{\\mathrm{eq}}$。总分离功，即我们旨在证明其等于 $G_c(\\varphi)$ 的量，是 $dW$ 在整个过程中的积分，这对应于 $\\delta_{\\mathrm{eq}}$ 从 $0$ 增加到最终分离量 $\\delta_f$。\n$$\nG_{\\text{pred}} = \\int_0^{\\delta_f} t_{\\mathrm{eq}}(\\delta_{\\mathrm{eq}})\\,d\\delta_{\\mathrm{eq}}\n$$\n问题指定了一个加载响应，该响应在达到峰值等效牵引力 $t_0$（在 $\\delta_{\\mathrm{eq}}=\\delta_0=t_0/k$ 时）之前是线弹性的，随后线性软化至零牵引力（在 $\\delta_{\\mathrm{eq}}=\\delta_f$ 时）。\n因此，等效牵引力-分离定律为：\n$$\nt_{\\mathrm{eq}}(\\delta_{\\mathrm{eq}}) =\n\\begin{cases}\nk\\,\\delta_{\\mathrm{eq}}  \\text{若 } 0 \\le \\delta_{\\mathrm{eq}} \\le \\delta_0 \\\\\nt_0 \\left( \\frac{\\delta_f - \\delta_{\\mathrm{eq}}}{\\delta_f - \\delta_0} \\right)  \\text{若 } \\delta_0  \\delta_{\\mathrm{eq}} \\le \\delta_f \\\\\n0  \\text{若 } \\delta_{\\mathrm{eq}} > \\delta_f\n\\end{cases}\n$$\n功 $G_{\\text{pred}}$ 是此 $t_{\\mathrm{eq}}-\\delta_{\\mathrm{eq}}$ 曲线下的面积。该面积由一个弹性部分的三角形和一个软化部分的三角形组成：\n$$\nG_{\\text{pred}} = \\underbrace{\\frac{1}{2}\\,\\delta_0\\,t_0}_{\\text{弹性}} + \\underbrace{\\frac{1}{2}\\,(\\delta_f - \\delta_0)\\,t_0}_{\\text{软化}} = \\frac{1}{2}\\,t_0\\,(\\delta_0 + \\delta_f - \\delta_0) = \\frac{1}{2}\\,t_0\\,\\delta_f\n$$\n该公式在设计上是能量一致的，通过将最终分离量 $\\delta_f$ 定义为目标断裂能 $G_c(\\varphi)$ 的函数：\n$$\n\\delta_f(\\varphi) = \\frac{2\\,G_c(\\varphi)}{t_0}\n$$\n将此定义代入我们预测的分离功表达式中，得到：\n$$\nG_{\\text{pred}} = \\frac{1}{2}\\,t_0 \\left( \\frac{2\\,G_c(\\varphi)}{t_0} \\right) = G_c(\\varphi)\n$$\n这证明了，在比例拉伸加载下，模型耗散的分离功根据其构造，精确等于Benzeggagh–Kenane定律规定的混合模式断裂能 $G_c(\\varphi)$。\n\n**纯压缩下的损伤行为**\n\n我们必须解释为何在 $\\delta_s=0$ 的纯压缩条件下不能引发损伤演化。损伤演化由历史变量 $r(t) = \\max_{\\tau \\le t}\\,\\delta_{\\mathrm{eq}}(\\tau)$ 控制，当 $r(t)$ 首次达到阈值 $\\delta_0  0$ 时，损伤开始。\n\n考虑一个纯压缩且无剪切的状态：$\\delta_n  0$ 且 $\\delta_s = 0$。等效分离量 $\\delta_{\\mathrm{eq}}$ 计算如下：\n$$\n\\delta_{\\mathrm{eq}} = \\sqrt{\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^{2}} = \\sqrt{(\\max(\\delta_n, 0))^2 + 0^2} = \\sqrt{0^2 + 0} = 0\n$$\n由于在这种加载下 $\\delta_{\\mathrm{eq}}$ 始终为 $0$，历史变量 $r(t)$ 也保持为 $0$。损伤起始的条件是 $\\delta_{\\mathrm{eq}} \\ge \\delta_0$。鉴于 $\\delta_0 = t_0/k  0$，条件 $0 \\ge \\delta_0$ 永远无法满足。因此，损伤永远不会开始，损伤变量 $d$ 保持其初始值 $0$。界面在压缩中仅发生弹性变形，这对于许多岩土地质材料来说是一种物理上真实的行为。\n\n**第二部分：算法实现**\n\n算法将实现所推导的关系式，以评估五个指定案例。对于案例A-C，我们将计算模式混合度 $\\varphi$，然后计算目标断裂能 $G_c(\\varphi)$ 和预测的分离功 $G_{\\text{pred}} = \\frac{1}{2}t_0\\delta_f(\\varphi)$，最后计算它们的比值。对于案例D-E，我们将计算给定单位移跳跃的 $\\delta_{\\mathrm{eq}}$，并将其与起始阈值 $\\delta_0$ 进行比较。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cohesive zone model problem for geomaterials.\n    \"\"\"\n    # 1. Define material parameters and constants in SI units\n    k = 1.0e12  # Elastic penalty stiffness (N/m^3)\n    t0 = 3.0e6    # Peak effective traction (N/m^2)\n    G_Ic = 150.0  # Mode I fracture energy (N/m)\n    G_IIc = 600.0 # Mode II fracture energy (N/m)\n    eta = 1.5     # Benzeggagh-Kenane exponent (dimensionless)\n\n    # Derived parameter: displacement at damage initiation\n    delta_0 = t0 / k\n\n    # 2. Define test cases\n    # For proportional cases, phi is given based on the loading path.\n    # For jump cases, the displacement (delta_n, delta_s) is given.\n    test_cases = [\n        {'type': 'proportional', 'id': 'A', 'phi': 0.0},                # Pure Mode I\n        {'type': 'proportional', 'id': 'B', 'phi': 1.0},                # Pure Mode II\n        {'type': 'proportional', 'id': 'C', 'phi': 0.5},                # Mixed Mode (ds/dn = 1 -> phi = 0.5)\n        {'type': 'jump', 'id': 'D', 'delta': (-1.0e-5, 0.0)},         # Pure compression\n        {'type': 'jump', 'id': 'E', 'delta': (-1.0e-5, 4.0e-6)},        # Compression with shear\n    ]\n\n    results = []\n\n    for case in test_cases:\n        if case['type'] == 'proportional':\n            phi = case['phi']\n            \n            # Calculate target fracture energy using BK law\n            G_c = G_Ic + (G_IIc - G_Ic) * (phi ** eta)\n            \n            # Calculate predicted work of separation from model construction.\n            # By design, delta_f is chosen to ensure energy consistency.\n            delta_f = 2 * G_c / t0\n            G_pred = 0.5 * t0 * delta_f\n\n            # The ratio should be exactly 1.0 by construction.\n            # Handle case where G_c might be zero to avoid division by zero.\n            ratio = G_pred / G_c if G_c > 1e-9 else 1.0\n            results.append(f\"{ratio:.6f}\")\n\n        elif case['type'] == 'jump':\n            delta_n, delta_s = case['delta']\n            \n            # Calculate equivalent displacement based on the model's definition\n            delta_eq = np.sqrt(max(delta_n, 0)**2 + delta_s**2)\n            \n            # Check for damage initiation against the threshold\n            initiates = delta_eq >= delta_0\n            results.append(str(initiates))\n            \n    # Print the final formatted string as requested\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3510324"}, {"introduction": "这最后一个练习处理损伤与塑性之间复杂的相互作用，这是岩土地质材料行为的一个关键方面。您将推导并实现一个完全隐式的、一致的返回映射算法，该算法能同时求解塑性和损伤的演化，这代表了为有限元分析开发高级本构模型的核心任务。[@problem_id:3510309]", "problem": "考虑一个在等温、准静态条件下，描述岩土材料的小应变、各向同性、损伤-塑性耦合模型。运动学变量为无穷小应变张量 $\\boldsymbol{\\varepsilon}$，柯西应力张量为 $\\boldsymbol{\\sigma}$。采用应变等效性假说，因此无损（有效）应力为 $\\tilde{\\boldsymbol{\\sigma}}$，名义应力为 $\\boldsymbol{\\sigma} = (1 - D)\\,\\tilde{\\boldsymbol{\\sigma}}$，其中 $D \\in [0,1)$ 是一个标量各向同性损伤变量。设无损弹性响应是线性和各向同性的，其杨氏模量为 $E$，泊松比为 $\\nu$，剪切模量为 $G = \\dfrac{E}{2(1+\\nu)}$，体积模量为 $K = \\dfrac{E}{3(1 - 2\\nu)}$。定义体积应变 $\\varepsilon_v = \\mathrm{tr}(\\boldsymbol{\\varepsilon})$ 和偏应变 $\\boldsymbol{\\varepsilon}^{\\mathrm{dev}} = \\boldsymbol{\\varepsilon} - \\dfrac{1}{3}\\varepsilon_v \\boldsymbol{I}$，其中 $\\boldsymbol{I}$ 是二阶单位张量。\n\n有效应力遵循胡克定律，其应变可加法分解为弹性和塑性部分，即 $\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}^e + \\boldsymbol{\\varepsilon}^p$，因此有效应力为\n$$\n\\tilde{\\boldsymbol{\\sigma}} = 2G \\left( \\boldsymbol{\\varepsilon}^{\\mathrm{dev}} - \\boldsymbol{\\varepsilon}^{p,\\mathrm{dev}} \\right) + K\\,\\varepsilon_v\\,\\boldsymbol{I}.\n$$\n塑性模型为 $J_2$ (von Mises) 模型，采用关于内变量 $\\kappa$（等效塑性应变）的线性各向同性硬化，因此有效应力的屈服函数为\n$$\nf(\\tilde{\\boldsymbol{\\sigma}},\\kappa) = q(\\tilde{\\boldsymbol{\\sigma}}) - \\sqrt{\\frac{2}{3}}\\left(\\sigma_{y0} + H \\kappa\\right),\n$$\n其中 $q(\\tilde{\\boldsymbol{\\sigma}}) = \\sqrt{\\frac{3}{2}}\\,\\|\\tilde{\\boldsymbol{s}}\\|$，$ \\tilde{\\boldsymbol{s}} = \\tilde{\\boldsymbol{\\sigma}} - \\dfrac{1}{3}\\mathrm{tr}(\\tilde{\\boldsymbol{\\sigma}})\\boldsymbol{I}$ 是有效应力的偏量部分。关联流动法则表述为\n$$\n\\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\gamma}\\,\\frac{\\partial f}{\\partial \\tilde{\\boldsymbol{\\sigma}}}, \\quad \\dot{\\kappa} = \\sqrt{\\frac{2}{3}}\\,\\dot{\\gamma},\n$$\n其中 $\\dot{\\gamma} \\ge 0$ 是塑性乘子率。Kuhn–Tucker 条件和一致性条件适用于 $f$。\n\n损伤是各向同性的，并由一个与硬化变量相关的单调定律控制：\n$$\nD = g(\\kappa) = 1 - \\exp(-a\\,\\kappa),\n$$\n其中 $a  0$。假设 $D$ 不改变屈服函数（有效应力概念），但通过 $\\boldsymbol{\\sigma} = (1-D)\\,\\tilde{\\boldsymbol{\\sigma}}$ 降低名义应力。\n\n您的任务是，在一个给定的总应变 $\\boldsymbol{\\varepsilon}_{n+1}$ 下，从一个已知的先前状态 $(\\boldsymbol{\\varepsilon}^p_n, \\kappa_n, D_n)$ 推导出一个用于单个增量步的一致性返回映射算法，以求解 $(\\boldsymbol{\\varepsilon}^p_{n+1}, \\kappa_{n+1}, D_{n+1})$。从以下基本依据出发：\n- 具有给定模量的小应变运动学和各向同性线弹性。\n- $J_2$ 等效应力的定义和关联流动法则。\n- 塑性的 Kuhn-Tucker 条件和一致性条件。\n- 损伤演化关系 $D = g(\\kappa)$ 和应变等效性 $\\boldsymbol{\\sigma} = (1-D)\\,\\tilde{\\boldsymbol{\\sigma}}$。\n\n推导一个单步、全隐式更新的残差方程组，该方程组在一次牛顿迭代中同时求解塑性乘子增量 $\\Delta\\gamma$、更新后的硬化变量 $\\kappa_{n+1}$ 和更新后的损伤 $D_{n+1}$，并一致性地更新应力 $\\boldsymbol{\\sigma}_{n+1}$。推导过程必须展示如何构建偏应力部分的试探有效应力，一致性条件如何进入残差，$\\Delta\\gamma$ 和 $\\kappa_{n+1}$ 之间的耦合关系，以及损伤残差。清晰地解释最终如何更新应力，以及如何从 $\\boldsymbol{\\sigma}_{n+1}$ 计算名义等效 von Mises 应力。\n\n在程序中实现所推导的算法，以处理以下测试套件。每个测试案例指定 $(E, \\nu, \\sigma_{y0}, H, a)$ 和一个以 Voigt 标记法表示的给定应变，其工程剪切分量为 $[ \\varepsilon_{11}, \\varepsilon_{22}, \\varepsilon_{33}, \\varepsilon_{12}, \\varepsilon_{23}, \\varepsilon_{13} ]$。所有案例的初始状态为 $\\boldsymbol{\\varepsilon}^p_n = \\boldsymbol{0}$，$\\kappa_n = 0$，$D_n = 0$。单位：$E$、$\\sigma_{y0}$ 和 $H$ 必须以 $\\mathrm{MPa}$ 为单位；应变为无量纲；名义等效 von Mises 应力必须以 $\\mathrm{MPa}$ 报告。\n\n测试套件：\n- 案例 1：$(E, \\nu, \\sigma_{y0}, H, a) = (1500, 0.25, 60, 80, 2.0)$，应变 $[0, 0, 0, 0.06, 0, 0]$。\n- 案例 2：$(E, \\nu, \\sigma_{y0}, H, a) = (1500, 0.25, 60, 80, 2.0)$，应变 $[0, 0, 0, 0.02, 0, 0]$。\n- 案例 3：$(E, \\nu, \\sigma_{y0}, H, a) = (1000, 0.30, 20, 10, 10.0)$，应变 $[0, 0, 0, 0.125, 0, 0]$。\n- 案例 4：$(E, \\nu, \\sigma_{y0}, H, a) = (1000, 0.30, 50, 100, 2.0)$，应变 $[-0.01, -0.01, -0.01, 0, 0, 0]$。\n\n对于每个案例，计算并返回收敛后的以下量：更新后的名义等效 von Mises 应力 $q_{n+1}$（单位 $\\mathrm{MPa}$），塑性乘子增量 $\\Delta\\gamma$（无量纲），更新后的硬化变量 $\\kappa_{n+1}$（无量纲），以及更新后的损伤 $D_{n+1}$（无量纲）。程序必须实现一个牛顿迭代过程，同时求解 $\\Delta\\gamma$、$\\kappa_{n+1}$ 和 $D_{n+1}$，然后一致性地更新 $\\boldsymbol{\\sigma}_{n+1}$。对残差向量的欧几里得范数使用 $10^{-12}$ 的收敛容差，并设置最多 $50$ 次迭代。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，将所有测试案例的结果按 $[q_1,\\Delta\\gamma_1,\\kappa_1,D_1,q_2,\\Delta\\gamma_2,\\kappa_2,D_2,\\ldots]$ 的顺序展平。所有浮点数必须四舍五入到六位小数。例如，包含两个测试案例的输出形式为 $[q_1,\\Delta\\gamma_1,\\kappa_1,D_1,q_2,\\Delta\\gamma_2,\\kappa_2,D_2]$，每个值都打印到六位小数。", "solution": "用户提供的问题陈述是有效的。它描述了岩土材料计算损伤塑性力学中的一个标准问题，利用了应变等效性假说和一个与各向同性损伤演化耦合的、带线性硬化的 $J_2$ 塑性模型。该问题具有科学依据、提法恰当、客观，并包含了推导和实现数值解所需的所有必要信息。\n\n### 一致性返回映射算法的推导\n\n目标是为耦合的各向同性损伤-塑性模型构建一个返回映射算法。给定第 $n$ 步的状态 $(\\boldsymbol{\\varepsilon}^p_n, \\kappa_n)$ 和一个给定的总应变 $\\boldsymbol{\\varepsilon}_{n+1}$，我们旨在求解第 $n+1$ 步的状态 $(\\boldsymbol{\\varepsilon}^p_{n+1}, \\kappa_{n+1}, D_{n+1}, \\boldsymbol{\\sigma}_{n+1})$。该算法遵循弹性预测、塑性修正的结构。\n\n#### 1. 基本方程\n\n该模型由以下方程组定义：\n- **应变分解**：$\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}^e + \\boldsymbol{\\varepsilon}^p$。\n- **有效应力**：$\\tilde{\\boldsymbol{\\sigma}} = \\mathbb{C} : \\boldsymbol{\\varepsilon}^e$，其中 $\\mathbb{C}$ 是各向同性线弹性刚度张量。使用体积模量 $K = \\frac{E}{3(1-2\\nu)}$ 和剪切模量 $G = \\frac{E}{2(1+\\nu)}$，可写为：\n$$ \\tilde{\\boldsymbol{\\sigma}} = K\\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}^e)\\,\\boldsymbol{I} + 2G\\,\\mathrm{dev}(\\boldsymbol{\\varepsilon}^e) $$\n由于 $J_2$ 塑性的塑性应变是体积不变的（$\\mathrm{tr}(\\boldsymbol{\\varepsilon}^p) = 0$），我们有 $\\mathrm{tr}(\\boldsymbol{\\varepsilon}^e) = \\mathrm{tr}(\\boldsymbol{\\varepsilon}) = \\varepsilon_v$。有效应力为：\n$$ \\tilde{\\boldsymbol{\\sigma}} = K\\,\\varepsilon_v\\,\\boldsymbol{I} + 2G(\\boldsymbol{\\varepsilon}^{\\text{dev}} - \\boldsymbol{\\varepsilon}^{p,\\text{dev}}) $$\n- **名义应力（应变等效性）**：$\\boldsymbol{\\sigma} = (1 - D)\\,\\tilde{\\boldsymbol{\\sigma}}$。\n- **屈服函数**：$f(\\tilde{\\boldsymbol{\\sigma}},\\kappa) = q(\\tilde{\\boldsymbol{\\sigma}}) - \\sigma_y(\\kappa) = 0$，其中：\n  - 等效有效应力：$q(\\tilde{\\boldsymbol{\\sigma}}) = \\sqrt{\\frac{3}{2}\\tilde{\\boldsymbol{s}}:\\tilde{\\boldsymbol{s}}} = \\sqrt{\\frac{3}{2}}\\|\\tilde{\\boldsymbol{s}}\\|$，其中 $\\tilde{\\boldsymbol{s}} = \\mathrm{dev}(\\tilde{\\boldsymbol{\\sigma}})$。\n  - 屈服强度：$\\sigma_y(\\kappa) = \\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa)$。\n- **流动法则（关联）**：$\\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\gamma}\\,\\frac{\\partial f}{\\partial \\tilde{\\boldsymbol{\\sigma}}}$，其中 $\\dot{\\gamma}$ 是塑性乘子。梯度为 $\\frac{\\partial f}{\\partial \\tilde{\\boldsymbol{\\sigma}}} = \\frac{\\partial q}{\\partial \\tilde{\\boldsymbol{\\sigma}}} = \\sqrt{\\frac{3}{2}}\\frac{\\tilde{\\boldsymbol{s}}}{\\|\\tilde{\\boldsymbol{s}}\\|}$。\n- **硬化法则**：$\\dot{\\kappa} = \\sqrt{\\frac{2}{3}}\\,\\dot{\\gamma}$。\n- **损伤演化法则**：$D = g(\\kappa) = 1 - \\exp(-a\\,\\kappa)$。\n- **Kuhn-Tucker 条件**：$\\dot{\\gamma} \\ge 0$, $f \\le 0$, $\\dot{\\gamma}f = 0$。\n\n#### 2. 弹性预测\n\n首先，假设增量是纯弹性的（$\\Delta\\gamma = 0$）。内变量不发生变化：$\\boldsymbol{\\varepsilon}^p_{n+1} = \\boldsymbol{\\varepsilon}^p_n$ 和 $\\kappa_{n+1} = \\kappa_n$。\n试探有效应力 $\\tilde{\\boldsymbol{\\sigma}}^{\\text{trial}}_{n+1}$ 基于总应变 $\\boldsymbol{\\varepsilon}_{n+1}$ 计算：\n$$ \\tilde{\\boldsymbol{\\sigma}}^{\\text{trial}}_{n+1} = \\mathbb{C} : (\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^p_n) $$\n试探有效应力的偏量部分是：\n$$ \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1} = 2G(\\boldsymbol{\\varepsilon}^{\\text{dev}}_{n+1} - \\boldsymbol{\\varepsilon}^{p,\\text{dev}}_n) $$\n接下来，通过使用试探应力和第 $n$ 步的状态评估屈服函数来检查是否屈服：\n$$ f^{\\text{trial}} = q(\\tilde{\\boldsymbol{\\sigma}}^{\\text{trial}}_{n+1}) - \\sigma_y(\\kappa_n) $$\n如果 $f^{\\text{trial}} \\le 0$，则假设正确。该步是弹性的。状态更新如下：\n$$ \\Delta\\gamma=0, \\quad \\kappa_{n+1} = \\kappa_n, \\quad D_{n+1} = D_n, \\quad \\tilde{\\boldsymbol{\\sigma}}_{n+1} = \\tilde{\\boldsymbol{\\sigma}}^{\\text{trial}}_{n+1}, \\quad \\boldsymbol{\\sigma}_{n+1} = (1-D_n)\\tilde{\\boldsymbol{\\sigma}}_{n+1} $$\n\n#### 3. 塑性修正（返回映射）\n\n如果 $f^{\\text{trial}}  0$，则发生塑性流动，需要进行修正。我们对增量 $\\Delta t$ 上的演化方程使用全隐式后向欧拉积分格式：\n$$ \\Delta\\boldsymbol{\\varepsilon}^p = \\boldsymbol{\\varepsilon}^p_{n+1} - \\boldsymbol{\\varepsilon}^p_n = \\Delta\\gamma \\frac{\\partial f}{\\partial \\tilde{\\boldsymbol{\\sigma}}}\\bigg|_{n+1} $$\n$$ \\kappa_{n+1} = \\kappa_n + \\sqrt{\\frac{2}{3}}\\Delta\\gamma $$\n$$ D_{n+1} = 1 - \\exp(-a\\kappa_{n+1}) $$\n在该步结束时，状态必须满足一致性条件：$f(\\tilde{\\boldsymbol{\\sigma}}_{n+1}, \\kappa_{n+1}) = 0$。\n\n更新后的有效偏应力为：\n$$ \\tilde{\\boldsymbol{s}}_{n+1} = 2G(\\boldsymbol{\\varepsilon}^{\\text{dev}}_{n+1} - \\boldsymbol{\\varepsilon}^{p,\\text{dev}}_{n+1}) = 2G(\\boldsymbol{\\varepsilon}^{\\text{dev}}_{n+1} - \\boldsymbol{\\varepsilon}^{p,\\text{dev}}_n - \\Delta\\boldsymbol{\\varepsilon}^p) = \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1} - 2G\\Delta\\boldsymbol{\\varepsilon}^p $$\n代入流动法则：\n$$ \\tilde{\\boldsymbol{s}}_{n+1} = \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1} - 2G\\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{\\tilde{\\boldsymbol{s}}_{n+1}}{\\|\\tilde{\\boldsymbol{s}}_{n+1}\\|} = \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1} - 3G\\Delta\\gamma \\frac{\\tilde{\\boldsymbol{s}}_{n+1}}{q(\\tilde{\\boldsymbol{\\sigma}}_{n+1})} $$\n这意味着 $\\tilde{\\boldsymbol{s}}_{n+1}$ 与 $\\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1}$ 共线。取范数并乘以 $\\sqrt{3/2}$，得到标准的等效应力径向返回方程：\n$$ q_{n+1} = q^\\text{trial}_{n+1} - 3G\\Delta\\gamma $$\n\n#### 4. 使用牛顿-拉夫逊法同时求解\n\n问题要求同时求解未知量 $(\\Delta\\gamma, \\kappa_{n+1}, D_{n+1})$。这组未知量与控制方程一起构成一个非线性系统，可以使用牛顿-拉夫逊方法求解。设未知量向量为 $\\mathbf{x} = [\\Delta\\gamma, \\kappa_{n+1}, D_{n+1}]^T$。我们构建一个包含三个残差方程的系统 $\\mathbf{R}(\\mathbf{x}) = \\mathbf{0}$。\n\n1.  **硬化残差 ($R_1$)**：根据离散硬化法则：\n    $$ R_1(\\mathbf{x}) = \\kappa_{n+1} - \\kappa_n - \\sqrt{\\frac{2}{3}}\\Delta\\gamma = 0 $$\n2.  **损伤残差 ($R_2$)**：根据损伤演化法则：\n    $$ R_2(\\mathbf{x}) = D_{n+1} - (1 - \\exp(-a\\kappa_{n+1})) = D_{n+1} + \\exp(-a\\kappa_{n+1}) - 1 = 0 $$\n3.  **一致性残差 ($R_3$)**：根据一致性条件 $f_{n+1} = 0$，代入径向返回公式：\n    $$ q_{n+1} - \\sigma_y(\\kappa_{n+1}) = 0 \\implies (q^\\text{trial}_{n+1} - 3G\\Delta\\gamma) - \\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa_{n+1}) = 0 $$\n    $$ R_3(\\mathbf{x}) = q^\\text{trial}_{n+1} - 3G\\Delta\\gamma - \\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa_{n+1}) = 0 $$\n\n牛顿-拉夫逊方法通过求解线性系统 $\\mathbf{J}(\\mathbf{x}^{(i)})\\delta\\mathbf{x} = -\\mathbf{R}(\\mathbf{x}^{(i)})$ 来迭代求解当前猜测值 $\\mathbf{x}^{(i)}$ 的修正量 $\\delta\\mathbf{x}$，其中 $\\mathbf{J}$ 是雅可比矩阵 $J_{ij} = \\frac{\\partial R_i}{\\partial x_j}$。\n\n我们系统的雅可比矩阵为：\n$$\n\\mathbf{J} =\n\\begin{pmatrix}\n\\frac{\\partial R_1}{\\partial \\Delta\\gamma}  \\frac{\\partial R_1}{\\partial \\kappa_{n+1}}  \\frac{\\partial R_1}{\\partial D_{n+1}} \\\\\n\\frac{\\partial R_2}{\\partial \\Delta\\gamma}  \\frac{\\partial R_2}{\\partial \\kappa_{n+1}}  \\frac{\\partial R_2}{\\partial D_{n+1}} \\\\\n\\frac{\\partial R_3}{\\partial \\Delta\\gamma}  \\frac{\\partial R_3}{\\partial \\kappa_{n+1}}  \\frac{\\partial R_3}{\\partial D_{n+1}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\sqrt{2/3}  1  0 \\\\\n0  a \\exp(-a\\kappa_{n+1})  1 \\\\\n-3G  -\\sqrt{2/3} H  0\n\\end{pmatrix}\n$$\n迭代过程为 $\\mathbf{x}^{(i+1)} = \\mathbf{x}^{(i)} + \\delta\\mathbf{x}$，直到残差向量的范数 $\\|\\mathbf{R}\\|$ 小于指定的容差。\n\n#### 5. 最终状态更新\n\n一旦找到 $(\\Delta\\gamma, \\kappa_{n+1}, D_{n+1})$ 的收敛值，就更新其余的状态变量：\n- **有效应力**：\n  $$ \\tilde{\\boldsymbol{s}}_{n+1} = \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1}\\left(1 - \\frac{3G\\Delta\\gamma}{q^\\text{trial}_{n+1}}\\right) $$\n  $$ \\tilde{p}_{n+1} = -K\\,\\varepsilon_v = -K\\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}_{n+1}) $$\n  $$ \\tilde{\\boldsymbol{\\sigma}}_{n+1} = \\tilde{\\boldsymbol{s}}_{n+1} - \\tilde{p}_{n+1}\\boldsymbol{I} $$\n- **名义应力**：\n  $$ \\boldsymbol{\\sigma}_{n+1} = (1-D_{n+1})\\tilde{\\boldsymbol{\\sigma}}_{n+1} $$\n- **名义等效 von Mises 应力**：这是最终需要关注的量。\n  $$ q_{nom, n+1} = \\sqrt{\\frac{3}{2}\\boldsymbol{s}_{n+1}:\\boldsymbol{s}_{n+1}} = \\sqrt{\\frac{3}{2}} \\|(1-D_{n+1})\\tilde{\\boldsymbol{s}}_{n+1}\\| = (1-D_{n+1})q_{n+1} $$\n  从一致性条件可知，$q_{n+1} = \\sigma_y(\\kappa_{n+1}) = \\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa_{n+1})$。因此：\n  $$ q_{nom, n+1} = (1-D_{n+1})\\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa_{n+1}) $$\n  这提供了一种在内变量已知后直接计算最终所需输出的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the damage-plasticity problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: (E, nu, sigma_y0, H, a), strain\n        ((1500, 0.25, 60, 80, 2.0), np.array([0, 0, 0, 0.06, 0, 0])),\n        # Case 2: (E, nu, sigma_y0, H, a), strain\n        ((1500, 0.25, 60, 80, 2.0), np.array([0, 0, 0, 0.02, 0, 0])),\n        # Case 3: (E, nu, sigma_y0, H, a), strain\n        ((1000, 0.30, 20, 10, 10.0), np.array([0, 0, 0, 0.125, 0, 0])),\n        # Case 4: (E, nu, sigma_y0, H, a), strain\n        ((1000, 0.30, 50, 100, 2.0), np.array([-0.01, -0.01, -0.01, 0, 0, 0])),\n    ]\n\n    results = []\n    for params, strain_voigt in test_cases:\n        res = solve_case(params, strain_voigt)\n        results.extend([f\"{v:.6f}\" for v in res])\n\n    print(f\"[{','.join(results)}]\")\n\ndef voigt_to_tensor(voigt_vec):\n    \"\"\"Converts a 6x1 Voigt strain vector (with tensor shear components) to a 3x3 tensor.\"\"\"\n    eps = np.zeros((3, 3))\n    eps[0, 0] = voigt_vec[0]\n    eps[1, 1] = voigt_vec[1]\n    eps[2, 2] = voigt_vec[2]\n    # The problem specifies ε_ij components, so they are tensor components.\n    eps[0, 1] = eps[1, 0] = voigt_vec[3]\n    eps[1, 2] = eps[2, 1] = voigt_vec[4]\n    eps[0, 2] = eps[2, 0] = voigt_vec[5]\n    return eps\n\ndef solve_case(params, strain_voigt_n1):\n    \"\"\"\n    Solves a single load increment for the coupled damage-plasticity model.\n    \"\"\"\n    E, nu, sigma_y0, H, a = params\n    \n    # Material properties\n    G = E / (2.0 * (1.0 + nu))\n    # K is not needed for the requested outputs as plasticity is deviatoric\n\n    # Initial state (step n) - all start from zero\n    eps_p_n_tensor_dev = np.zeros((3, 3))\n    kappa_n = 0.0\n    \n    # Prescribed state (step n+1)\n    eps_n1_tensor = voigt_to_tensor(strain_voigt_n1)\n\n    # Elastic predictor\n    eps_v_n1 = np.trace(eps_n1_tensor)\n    eps_dev_n1_tensor = eps_n1_tensor - (eps_v_n1 / 3.0) * np.identity(3)\n    \n    # Trial effective deviatoric stress\n    s_eff_trial_n1_tensor = 2.0 * G * (eps_dev_n1_tensor - eps_p_n_tensor_dev)\n    \n    # Trial equivalent stress (von Mises)\n    s_eff_trial_n1_norm = np.sqrt(np.sum(s_eff_trial_n1_tensor * s_eff_trial_n1_tensor))\n    q_eff_trial_n1 = np.sqrt(3.0 / 2.0) * s_eff_trial_n1_norm\n\n    # Yield stress at step n\n    sqrt_2_3 = np.sqrt(2.0/3.0)\n    sigma_y_n = sqrt_2_3 * (sigma_y0 + H * kappa_n)\n\n    # Yield check\n    f_trial = q_eff_trial_n1 - sigma_y_n\n    \n    TOL_f = 1e-12\n\n    if f_trial = TOL_f:\n        # --- Elastic step ---\n        delta_gamma = 0.0\n        kappa_n1 = kappa_n\n        D_n1 = 1.0 - np.exp(-a * kappa_n1)\n\n        q_eff_n1 = q_eff_trial_n1\n        q_nom_n1 = (1.0 - D_n1) * q_eff_n1\n\n        return q_nom_n1, delta_gamma, kappa_n1, D_n1\n\n    # --- Plastic step (Return Mapping) ---\n    \n    # Newton-Raphson for [delta_gamma, kappa_n1, D_n1]\n    x = np.array([0.0, kappa_n, 1.0 - np.exp(-a * kappa_n)]) # [delta_gamma, kappa_n1, D_n1]\n    \n    max_iter = 50\n    TOL_R = 1e-12\n\n    for i in range(max_iter):\n        delta_gamma_i, kappa_n1_i, D_n1_i = x\n\n        # Residual vector R\n        R = np.zeros(3)\n        R[0] = kappa_n1_i - kappa_n - sqrt_2_3 * delta_gamma_i\n        R[1] = D_n1_i + np.exp(-a * kappa_n1_i) - 1.0\n        R[2] = q_eff_trial_n1 - 3.0 * G * delta_gamma_i - sqrt_2_3 * (sigma_y0 + H * kappa_n1_i)\n\n        if np.linalg.norm(R)  TOL_R:\n            break\n\n        # Jacobian matrix J\n        J = np.zeros((3, 3))\n        J[0, 0] = -sqrt_2_3\n        J[0, 1] = 1.0\n        J[1, 1] = a * np.exp(-a * kappa_n1_i) # Derivative of exp(-x) is -exp(-x)\n        J[1, 2] = 1.0\n        J[2, 0] = -3.0 * G\n        J[2, 1] = -sqrt_2_3 * H\n\n        # Solve for increment and update\n        try:\n            delta_x = np.linalg.solve(J, -R)\n            x += delta_x\n        except np.linalg.LinAlgError:\n            # Fallback if Jacobian is singular, should not happen in this problem\n            return np.nan, np.nan, np.nan, np.nan\n\n    delta_gamma, kappa_n1, D_n1 = x\n    \n    # Post-convergence calculation\n    # Final nominal equivalent von Mises stress\n    q_nom_n1 = (1.0 - D_n1) * sqrt_2_3 * (sigma_y0 + H * kappa_n1)\n\n    return q_nom_n1, delta_gamma, kappa_n1, D_n1\n\nsolve()\n```", "id": "3510309"}]}