{"hands_on_practices": [{"introduction": "从简单的批处理系统到多道程序设计的演变，其核心驱动力是提高昂贵的中央处理器（CPU）的利用率。本练习通过一个基础的概率模型，让你亲手量化多道程序程度（同时在内存中的进程数）与CPU利用率之间的直接关系。通过这个计算，你将深刻理解为何多道程序设计是现代操作系统的基石 [@problem_id:3623637]。", "problem": "一个分时的多道程序操作系统以固定的 $n$ 的多道程序度运行 $n$ 个独立的用户程序。在任何随机选择的时刻，每个程序独立地处于输入/输出 (I/O) 等待状态的概率为 $p \\in (0,1)$，并以 $1-p$ 的概率准备好进行计算。假设调度程序是理想的：只要至少有一个程序准备就绪，中央处理器 (CPU) 就会立即保持忙碌（没有调度开销或抢占延迟）。请仅使用基本概率原理（独立性和互补事件）作为出发点。\n\n(a) 令 $U(n,p)$ 表示长期的 CPU 利用率，定义为 CPU 在任意时刻处于忙碌状态的概率。请从第一性原理出发，用 $n$ 和 $p$ 推导出 $U(n,p)$。\n\n(b) 使用你的表达式，从数学上证明为什么在固定的 $p \\in (0,1)$ 条件下，增加 $n$ 会严格提高 $U(n,p)$，以及为什么当 $n$ 增大时，$U(n,p)$ 会趋向于完全利用。你的证明必须基于你在 (a) 部分推导出的定义以及独立事件概率的性质。\n\n(c) 对于给定的 I/O 等待概率 $p=0.7$，确定使利用率目标 $U(n,p) \\ge 0.99$ 得以实现的最小整数 $n$。请给出你求解的精确不等式以及获得 $n$ 的步骤。最终答案必须是一个整数。由于答案是精确整数，因此不需要进行舍入。", "solution": "本题将首先验证其前提，然后使用概率论的基本原理按顺序解决每个部分。\n\n(a) CPU 利用率 $U(n,p)$ 的推导。\n\n系统由 $n$ 个独立的用户程序组成。在任何给定时刻，每个程序 $i$（其中 $i \\in \\{1, 2, \\dots, n\\}$）处于以下两种状态之一：\n1.  处于输入/输出 (I/O) 等待状态，概率为 $p$。将此事件表示为 $W_i$。因此，$P(W_i) = p$。\n2.  准备好计算，概率为 $1-p$。将此事件表示为 $R_i$。因此，$P(R_i) = 1-p$。\n\n题目指出调度程序是理想的，这意味着中央处理器 (CPU) 忙碌当且仅当至少有一个程序处于准备就绪状态。CPU 利用率 $U(n,p)$ 定义为 CPU 忙碌的概率。\n\n更直接的方法是首先计算其互补事件的概率：CPU 空闲。CPU 空闲当且仅当*所有* $n$ 个程序同时处于 I/O 等待状态。将“CPU 空闲”事件表示为 $I_{CPU}$。\n$$ I_{CPU} \\iff W_1 \\cap W_2 \\cap \\dots \\cap W_n $$\n题目明确指出程序是独立的。因此，这些事件交集的概率是它们各自概率的乘积：\n$$ P(I_{CPU}) = P(W_1 \\cap W_2 \\cap \\dots \\cap W_n) = P(W_1) \\times P(W_2) \\times \\dots \\times P(W_n) $$\n由于对所有 $i$ 都有 $P(W_i) = p$，这变为：\n$$ P(I_{CPU}) = \\prod_{i=1}^{n} P(W_i) = p \\times p \\times \\dots \\times p \\text{（$n$ 次）} = p^n $$\n“CPU 忙碌”事件是“CPU 空闲”事件的互补事件。因此，CPU 利用率 $U(n,p)$ 是：\n$$ U(n,p) = 1 - P(I_{CPU}) $$\n代入 $P(I_{CPU})$ 的表达式，我们从第一性原理得到 CPU 利用率的表达式：\n$$ U(n,p) = 1 - p^n $$\n\n(b) 对 $U(n,p)$ 行为的数学证明。\n\n首先，我们将证明对于固定的 $p \\in (0,1)$，增加多道程序度 $n$ 会严格提高 CPU 利用率 $U(n,p)$。这需要证明对于任何整数 $n \\ge 1$，都有 $U(n+1, p) > U(n, p)$。\n\n从我们推导的表达式：\n$$ U(n+1, p) = 1 - p^{n+1} $$\n$$ U(n, p) = 1 - p^n $$\n因此，不等式 $U(n+1, p) > U(n, p)$ 等价于：\n$$ 1 - p^{n+1} > 1 - p^n $$\n两边同时减去 $1$ 得：\n$$ -p^{n+1} > -p^n $$\n两边同时乘以 $-1$ 会使不等号反向：\n$$ p^{n+1} < p^n $$\n由于 $p \\in (0,1)$，$p$ 是严格为正的，所以我们可以将两边同时除以 $p^n$ 而不改变不等号的方向：\n$$ \\frac{p^{n+1}}{p^n} < \\frac{p^n}{p^n} $$\n$$ p < 1 $$\n根据题目定义 $p \\in (0,1)$，这最后一个不等式是成立的。因此，从数学上证明了 $U(n,p)$ 是关于 $n$ 的严格递增函数。\n\n其次，我们将证明当 $n$ 增大时，$U(n,p)$ 趋近于完全利用（即 $1$）。这需要计算 $U(n,p)$ 当 $n \\to \\infty$ 时的极限。\n$$ \\lim_{n \\to \\infty} U(n,p) = \\lim_{n \\to \\infty} (1 - p^n) $$\n我们可以将其写为：\n$$ \\lim_{n \\to \\infty} 1 - \\lim_{n \\to \\infty} p^n $$\n对于任何满足 $|p| < 1$ 的实数 $p$，当 $n \\to \\infty$ 时，$p^n$ 的极限为 $0$。题目中说明 $p \\in (0,1)$，这满足该条件。\n$$ \\lim_{n \\to \\infty} p^n = 0 $$\n因此，利用率的极限是：\n$$ \\lim_{n \\to \\infty} U(n,p) = 1 - 0 = 1 $$\n这表明，当多道程序度变得非常大时，CPU 利用率趋近于 $100\\%$。\n\n(c) 最小多道程序度 $n$ 的计算。\n\n我们已知 I/O 等待概率 $p=0.7$ 和至少为 $0.99$ 的目标利用率。我们需要找到满足 $U(n, 0.7) \\ge 0.99$ 的最小整数 $n$。\n\n需要求解的不等式是：\n$$ 1 - (0.7)^n \\ge 0.99 $$\n我们着手求解 $n$。首先，分离出包含 $n$ 的项：\n$$ -(0.7)^n \\ge 0.99 - 1 $$\n$$ -(0.7)^n \\ge -0.01 $$\n乘以 $-1$ 并反转不等号：\n$$ (0.7)^n \\le 0.01 $$\n为了求解指数 $n$，我们对两边取自然对数。由于自然对数函数 $\\ln(x)$ 在 $x > 0$ 时是严格递增的，不等号的方向保持不变。\n$$ \\ln((0.7)^n) \\le \\ln(0.01) $$\n使用对数幂法则 $\\ln(a^b) = b \\ln(a)$：\n$$ n \\ln(0.7) \\le \\ln(0.01) $$\n现在，我们必须除以 $\\ln(0.7)$。关键要注意的是，由于 $0.7 < 1$，$\\ln(0.7)$ 的值是负数。不等式两边同时除以一个负数会使不等号的方向反转。\n$$ n \\ge \\frac{\\ln(0.01)}{\\ln(0.7)} $$\n我们可以计算出右侧的数值：\n$$ \\ln(0.01) \\approx -4.60517 $$\n$$ \\ln(0.7) \\approx -0.35667 $$\n$$ n \\ge \\frac{-4.60517}{-0.35667} \\approx 12.911 $$\n所以，我们必须有 $n \\ge 12.911$。由于多道程序度 $n$ 必须是整数，满足此条件的最小整数值是大于 $12.911$ 的下一个整数，即 $13$。\n验证如下：\n当 $n=12$ 时，$U(12, 0.7) = 1 - (0.7)^{12} \\approx 1 - 0.01384 = 0.98616$，小于 $0.99$。\n当 $n=13$ 时，$U(13, 0.7) = 1 - (0.7)^{13} \\approx 1 - 0.009688 = 0.99031$，大于或等于 $0.99$。\n因此，最小整数 $n$ 是 $13$。", "answer": "$$\\boxed{13}$$", "id": "3623637"}, {"introduction": "当多个进程同时准备就绪时，操作系统的调度程序必须决定下一个运行哪一个，这个选择对系统整体性能有巨大影响。本练习将通过一个精心设计的思想实验，让你直观地看到一个经典调度陷阱——“护航效应”。通过对比先来先服务（FCFS）和更优的最短剩余时间优先（SRT）算法的性能，你将理解调度策略的重要性 [@problem_id:3623594]。", "problem": "考虑一个单处理器操作系统，它使用先到先服务（FCFS）或最短剩余时间（SRT）算法来调度进程。系统没有上下文切换开销，处理器非空闲，并且每个进程都由一个单独的、无阻塞、无输入/输出的中央处理器（CPU）执行期组成。该工作负载被特意构造成在 $FCFS$ 算法下引发护航效应：一个长进程 $J_{0}$ 在时间 $t=0$ 到达，需要 $100$ 毫秒的CPU执行时间；以及 $10$ 个短进程 $J_{1},J_{2},\\dots,J_{10}$ 分别在时间 $t=1,2,\\dots,10$ 到达，每个进程需要 $1$ 毫秒的CPU执行时间。\n\n使用以下基本定义：进程 $J_{i}$ 的完成时间 $C_{i}$ 是其CPU执行期结束的时间，到达时间为 $A_{i}$，周转时间为 $T_{i}=C_{i}-A_{i}$。平均周转时间是工作负载中所有进程的 $T_{i}$ 的算术平均值。\n\n(a) 在 $FCFS$ 算法下，确定所有进程的完成时间并计算平均周转时间。\n\n(b) 在 $SRT$ 算法下，确定所有进程的完成时间并计算平均周转时间。假设当一个剩余时间严格更短的进程到达时，立即发生抢占；并且当在某个进程到达的精确时刻做出调度决策时，平局将优先选择最新到达的较短作业。\n\n(c) 定义改进因子为比率\n$$I=\\frac{\\text{FCFS下的平均周转时间}}{\\text{SRT下的平均周转时间}}。$$\n计算此工作负载下的 $I$。将最终的改进因子表示为一个纯数（无量纲），并将您的答案四舍五入到四位有效数字。", "solution": "系统中有一个长进程 $J_{0}$，其到达时间 $A_{0}=0$，CPU执行时间为 $100$；还有十个短进程 $J_{k}$，其到达时间 $A_{k}=k$（其中 $k\\in\\{1,2,\\dots,10\\}$），CPU执行时间为 $1$。\n\n我们从定义开始：完成时间 $C_{i}$ 是进程完成其CPU执行期的时间，周转时间为 $T_{i}=C_{i}-A_{i}$。平均周转时间为 $\\frac{1}{n}\\sum_{i=0}^{10}T_{i}$，其中 $n=11$ 是进程总数。\n\n(a)部分：$FCFS$ 是非抢占式的，它调度就绪队列头部的最早到达的进程，直到该进程完成。由于 $J_{0}$ 在 $t=0$ 到达，它立即开始并不间断地运行 $100$ 毫秒。因此，\n- $J_{0}$ 从 $t=0$ 运行到 $t=100$，所以 $C_{0}=100$ 且 $T_{0}=100-0=100$。\n\n所有短进程 $J_{k}$ 都在时间间隔 $t\\in[1,10]$ 内到达，但在 $FCFS$ 算法下它们不能抢占 $J_{0}$。它们在 $J_{0}$ 后面排队，并在 $J_{0}$ 完成后按到达顺序得到服务。在 $t=100$ 之后，进程 $J_{1},J_{2},\\dots,J_{10}$ 每个需要 $1$ 毫秒，并按到达顺序执行。因此，它们的完成时间是：\n- $J_{1}$：$C_{1}=100+1=101$，所以 $T_{1}=101-1=100$，\n- $J_{2}$：$C_{2}=102$，所以 $T_{2}=102-2=100$，\n- $\\dots$\n- $J_{10}$：$C_{10}=110$，所以 $T_{10}=110-10=100$。\n\n在 $FCFS$ 算法下，对于此工作负载中的每一个进程，其周转时间恰好都是 $100$。$FCFS$ 下的平均周转时间是\n$$\\overline{T}_{\\text{FCFS}}=\\frac{1}{11}\\sum_{i=0}^{10}T_{i}=\\frac{1}{11}\\cdot 11\\cdot 100=100。$$\n这体现了护航效应：头部的单个长进程导致所有后续的短进程等待，从而增加了它们的周转时间。\n\n(b)部分：$SRT$ 是抢占式的，并且总是运行剩余时间最短的进程。在 $t=0$ 时，$J_{0}$ 是唯一就绪的进程，因此它开始运行。在 $t=1$ 时，$J_{1}$ 到达，其剩余时间为 $1$，严格小于 $J_{0}$ 的剩余时间（$99$），所以 $J_{0}$ 被抢占，$J_{1}$ 开始运行。\n\n我们追踪调度过程：\n- 从 $t=0$ 到 $t=1$，$J_{0}$ 运行了 $1$ 毫秒，剩余 $99$ 毫秒。\n- 在 $t=1$ 时，$J_{1}$ 到达并从 $t=1$ 运行到 $t=2$，在 $C_{1}=2$ 时完成。其周转时间为 $T_{1}=2-1=1$。\n- 在 $t=2$ 时，$J_{2}$ 恰好在 $J_{1}$ 完成时到达。根据所述的平局打破规则，$J_{2}$ 从 $t=2$ 运行到 $t=3$，在 $C_{2}=3$ 时完成。其周转时间为 $T_{2}=3-2=1$。\n- 这个模式继续下去：对于每个 $k\\in\\{3,4,\\dots,10\\}$，$J_{k}$ 在 $t=k$ 时到达并立即运行 $1$ 毫秒，在 $C_{k}=k+1$ 时完成，周转时间为 $T_{k}=(k+1)-k=1$。\n\n在各进程到达的间隔期间，没有空闲时间，因为每个短进程都恰好在下一个短进程到达的下一个整数时间点完成，所以 $J_{0}$ 在 $t=1$ 和 $t=11$ 之间没有取得进展。在 $J_{10}$ 于 $t=11$ 完成后，$J_{0}$ 带着剩余的 $99$ 毫秒恢复运行，并不间断地运行直到在 $t=11+99=110$ 完成。因此，\n- $C_{0}=110$ 且 $T_{0}=110-0=110$。\n\n汇总 $SRT$ 算法下的周转时间：\n- 对于 $J_{0}$：$T_{0}=110$，\n- 对于每个 $J_{k}$（其中 $k\\in\\{1,2,\\dots,10\\}$）：$T_{k}=1$。\n\n$SRT$ 下的平均周转时间是\n$$\\overline{T}_{\\text{SRT}}=\\frac{1}{11}\\left(T_{0}+\\sum_{k=1}^{10}T_{k}\\right)=\\frac{1}{11}\\left(110+10\\cdot 1\\right)=\\frac{120}{11}。$$\n\n(c)部分：改进因子定义为\n$$I=\\frac{\\overline{T}_{\\text{FCFS}}}{\\overline{T}_{\\text{SRT}}}=\\frac{100}{120/11}=\\frac{100\\cdot 11}{120}=\\frac{1100}{120}=\\frac{110}{12}=\\frac{55}{6}。$$\n数值上，$\\frac{55}{6} \\approx 9.1666\\dots$。四舍五入到四位有效数字得到 $I\\approx 9.167$。", "answer": "$$\\boxed{9.167}$$", "id": "3623594"}, {"introduction": "对于为交互式用户设计的时间共享系统而言，响应时间是一个关键的性能指标，它直接影响用户体验。本练习将让你扮演系统管理员的角色，来“调节”一个采用轮转（Round-Robin）调度算法的系统。你需要计算出在保证特定响应时间目标的前提下，系统所能设置的最大时间片 $q$ 值，从而在系统吞吐量和用户感知的响应速度之间取得平衡 [@problem_id:3623608]。", "problem": "一个分时系统使用轮询（Round-Robin, RR）调度器，其具有固定的时间片 $q$ 和每次切换的非重叠上下文切换时间 $s$。有 $N$ 个后台就绪进程，每个进程在阻塞等待输入/输出或完成之前，最多需要 $c_i$ 的中央处理器（CPU）服务时间，其中 $i \\in \\{1,\\dots,N\\}$。一个新到达的交互式进程产生一个回显事件，该事件需要 $e$ 的CPU时间来产生字符回显，然后阻塞。假设调度是在就绪队列上严格执行RR，该交互式进程在最坏的情况下到达（即，它被附加到所有 $N$ 个后台进程之后的就绪队列尾部），并且每次抢占或进程完成时（包括切换到该交互式进程）都会产生 $s$ 的上下文切换开销。\n\n根据分时和RR调度的基本原理，确定最大时间片 $q_{\\max}$（以毫秒为单位），该时间片仍能保证最坏情况下的回显响应时间 $R_{\\text{echo}}$（从交互式进程到达至回显完成）不超过 $100$ 毫秒。使用以下参数和进程CPU需求：\n- $s = 1$ 毫秒,\n- $N = 8$,\n- $e = 2$ 毫秒,\n- $(c_1,\\dots,c_8) = (22,\\ 25,\\ 19,\\ 30,\\ 24,\\ 21,\\ 27,\\ 23)$ 毫秒。\n\n请以毫秒为单位，用一个单独的数值表示 $q_{\\max}$ 的最终答案。最终答案中不要包含单位。不需要四舍五入；请提供精确值。", "solution": "为了确定最坏情况下的响应时间 $R_{\\text{echo}}$，我们分析当交互式进程到达时，被放置在就绪队列末尾的场景。此时，队列中已有全部 $N$ 个后台进程。$R_{\\text{echo}}$ 是指从交互式进程到达直到其需要 $e$ 毫秒的 CPU 工作完成所经过的总时间。分析的关键在于比较所需的回显时间 $e$ 与时间片 $q$ 的大小。\n\n**情况1：$q \\ge e$**\n\n在这种情况下，交互式进程将在一个时间片内完成其长度为 $e$ 的CPU执行，并且不会被抢占。响应时间 $R_{\\text{echo}}$ 由两部分组成：1) 等待队列中领先的 $N$ 个后台进程接收它们的时间片的时间；2) 交互式进程本身的执行时间 $e$。\n\n对于 $N$ 个后台进程中的每一个，调度器将为其运行 $\\min(c_i, q)$ 的时长。在每个进程的时间片之后，会发生一次持续时间为 $s$ 的上下文切换。交互式进程开始之前的总等待时间是所有 $N$ 个进程的这些执行时间和上下文切换时间之和。\n$$T_{\\text{wait}} = \\sum_{i=1}^{N} \\left( \\min(c_i, q) + s \\right) = \\left( \\sum_{i=1}^{N} \\min(c_i, q) \\right) + Ns$$\n总响应时间是等待时间加上回显执行时间 $e$：\n$$R_{\\text{echo}}(q) = T_{\\text{wait}} + e = \\left( \\sum_{i=1}^{N} \\min(c_i, q) \\right) + Ns + e$$\n我们已知 $e=2$ 毫秒。后台进程的CPU时间 $c_i$ 都大于或等于 $19$ 毫秒。因此，对于范围 $e \\le q \\le \\min(c_i)$（即 $2 \\le q \\le 19$）内的任何 $q$，对于所有的 $i$，$\\min(c_i, q)$ 项都简化为 $q$。在此范围内，响应时间为：\n$$R_{\\text{echo}}(q) = \\left( \\sum_{i=1}^{N} q \\right) + Ns + e = Nq + Ns + e$$\n代入给定值 $N=8$，$s=1$ 毫秒，和 $e=2$ 毫秒：\n$$R_{\\text{echo}}(q) = 8q + 8(1) + 2 = 8q + 10$$\n问题施加了约束条件 $R_{\\text{echo}} \\le 100$ 毫秒。\n$$8q + 10 \\le 100$$\n$$8q \\le 90$$\n$$q \\le \\frac{90}{8} = \\frac{45}{4} = 11.25$$\n这个结果 $q \\le 11.25$ 与本情况的假设 $2 \\le q \\le 19$ 一致。因此，在区间 $[2, 11.25]$ 内的任何时间片 $q$ 都是一个有效的解。由于 $R_{\\text{echo}}(q)$ 是 $q$ 的增函数，任何大于 $11.25$ 的 $q$ 都将违反约束。因此，这种情况下的最大允许时间片是 $11.25$。\n\n**情况2：$q  e$**\n\n在这种情况下（$q  2$ 毫秒），交互式进程在完成其 $e=2$ 毫秒的工作之前至少会被抢占一次。它将需要 $k = \\lceil e/q \\rceil = \\lceil 2/q \\rceil$ 个时间片。\n\n我们来分析区间 $q \\in (1, 2)$。在此区间，$k=\\lceil 2/q \\rceil = 2$。响应时间的计算如下：\n1.  初始等待 $N$ 个进程轮转一次：$T_{\\text{wait},1} = \\sum_{i=1}^N(\\min(c_i, q) + s) = N(q+s)$。\n2.  交互式进程的第一个CPU执行：时长 $q$。\n3.  上下文切出，并再次等待 $N$ 个进程轮转一次：时长 $s + N(q+s)$。\n4.  第二个（也是最后一个）CPU执行：时长 $e-q = 2-q$。\n\n总响应时间是这些时长的总和：\n$$R_{\\text{echo}}(q) = N(q+s) + q + s + N(q+s) + (e-q)$$\n$$R_{\\text{echo}}(q) = 2N(q+s) + s + e = (2N)q + (2N+1)s + e$$\n代入 $N=8, s=1, e=2$：\n$$R_{\\text{echo}}(q) = 16q + (17)(1) + 2 = 16q + 19$$\n约束条件为 $16q+19 \\le 100$，得出 $16q \\le 81$，或 $q \\le 5.0625$。与本情况的假设 $q \\in (1, 2)$ 的交集是整个区间 $(1, 2)$。此区间内 $R_{\\text{echo}}(q)$ 的最大值出现在 $q \\to 2^-$ 时，为 $16(2)+19 = 51$ 毫秒。由于 $51  100$，所有 $q \\in (1, 2)$ 都是有效的。\n\n将两种情况结合起来，所有有效时间片 $q$ 的集合包含了区间 $(1, 2)$ 和 $[2, 11.25]$。所有有效解的并集是 $(1, 11.25]$。该集合的上确界（最大值）是 $11.25$。\n\n因此，保证最坏情况回显响应时间不超过 $100$ 毫秒的最大时间片 $q_{\\max}$ 是 $11.25$ 毫秒。", "answer": "$$\\boxed{11.25}$$", "id": "3623608"}]}