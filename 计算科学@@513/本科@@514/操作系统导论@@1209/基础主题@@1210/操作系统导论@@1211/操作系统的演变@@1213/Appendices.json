{"hands_on_practices": [{"introduction": "操作系统演进的核心驱动力之一是应对硬件的不可靠性。本练习将我们带回计算的早期时代，那时频繁的电力故障和简陋的存储设备（如磁带）是常态。通过为一个假设的1978年小型计算机设计一个检查点/恢复机制，我们可以亲手感受系统设计师如何利用数学模型在停机时间和计算损失之间做出权衡，从而找到一个最优的策略来保障系统的可靠性 [@problem_id:3639697]。", "problem": "1978年，一所大学的研究实验室部署了一台小型的多用户小型计算机，其唯一可用于批量顺序传输的大容量存储外设是磁带（MT）。由于频繁的电源故障，操作系统团队希望建立一种最小化的、符合时代背景的检查点/恢复机制，该机制仅使用磁带来限制计算损失并减少停机时间。\n\n你需要完成以下任务：\n\n- 提出一个适用于20世纪70年代后期、无虚拟内存的单体内核的合理检查点/恢复设计：\n  1) 检查点操作必须静默用户进程，清空设备队列，并将可恢复的进程状态（寄存器、内存映像、进程控制块、以标识符或路径名形式表示的打开文件表元数据以及待处理信号）序列化到一个专用的检查点磁带上，采用自描述格式，并带有版本化头部和冗余（例如，块校验和）。在检查点窗口期间，系统必须停止所有对磁盘的应用层写入，并在磁带开头记录一个重启意图标记，以支持幂等恢复。\n  2) 恢复操作必须引导一个最小化的恢复监视器，装载并倒带检查点磁带，验证头部，重建进程地址空间和寄存器，通过以一致的模式重新打开路径来重新绑定打开的文件，并将设备驱动程序重新初始化到静默状态。检查点时任何正在进行的设备 I/O 在恢复后都必须被视为未执行。\n\n在你的分析中，假设采用以下定量模型：\n\n- 一个单一作业无限期运行，并以 $\\tau$ 秒为周期进行协同检查点。磁带写入吞吐量为 $b_{w}$（字节/秒），读取吞吐量为 $b_{r}$（字节/秒），每次磁带操作的装载/倒带延迟为 $m$（秒），序列化的检查点映像大小为 $s$（字节）。\n- 写入一个完整检查点的时间为 $C_{w}$，从最近的检查点读取并恢复的时间为 $R_{r}$。你可以假设磁带是顺序行为，因此 $C_{w} = m + s/b_{w}$ 和 $R_{r} = m + s/b_{r}$。\n- 故障遵循速率为 $\\lambda$（次/秒）的泊松过程，且与检查点计划无关。假设 $\\lambda \\tau \\ll 1$，因此在两次检查点之间发生一次以上故障的概率可以忽略不计，并且为进行一阶分析，可以将检查点间隔内的故障点视为在 $[0,\\tau]$ 上均匀分布。\n- 将长期来看非生产性时钟时间的比例 $D(\\tau)$ 定义为因检查点操作、故障后重启以及丢失计算的重新执行而未能取得净正向进展的时间的期望比例。\n- 将数据丢失风险 $L(\\tau)$ 定义为长期来看仅因故障后回滚计算的重新执行而损失的时钟时间的期望比例。\n\n任务：\n\n1) 从上述磁带和故障模型出发，用 $m$、$s$、$b_{w}$ 和 $b_{r}$ 推导出 $C_{w}$ 和 $R_{r}$ 的表达式。\n\n2) 使用更新回报推理和 $\\lambda \\tau \\ll 1$ 近似，用 $\\lambda$、$\\tau$、$C_{w}$ 和 $R_{r}$ 推导出 $D(\\tau)$ 和 $L(\\tau)$。\n\n3) 确定使 $D(\\tau)$ 最小化的检查点间隔 $\\tau^{\\ast}$，然后以闭式解形式计算 $D(\\tau^{\\ast})$ 和 $L(\\tau^{\\ast})$。\n\n将你的最终答案表示为一个二元行矩阵 $\\bigl[D(\\tau^{\\ast}),\\,L(\\tau^{\\ast})\\bigr]$，用 $\\lambda$、$m$、$s$、$b_{w}$ 和 $b_{r}$ 符号化表示。不需要进行数值计算，最终的方框答案中不应包含单位。", "solution": "该问题具有科学依据，提法明确且客观。它提供了一个基于可靠性工程和排队论标准原理的定量模型，适合进行数学分析。所有必需的参数都已定义，目标也明确。因此，我们可以着手求解。\n\n解答根据问题陈述中指定的三个任务进行组织。\n\n### 任务1：$C_{w}$ 和 $R_{r}$ 的表达式\n\n问题陈述提供了一个模型，用于描述使用磁带进行检查点和恢复操作的持续时间。一次磁带操作被建模为包含两个不同阶段：一个机械延迟和一个数据传输周期。\n\n写入一个完整检查点的时间，记为 $C_{w}$，包括装载和倒带延迟 $m$，加上以写入吞吐量 $b_{w}$ 传输大小为 $s$ 的检查点映像所需的时间。假设是顺序写入访问，传输时间为映像大小除以吞吐量，即 $\\frac{s}{b_{w}}$。因此，一次检查点写入操作的总时间为：\n$$C_{w} = m + \\frac{s}{b_{w}}$$\n\n类似地，读取检查点数据并执行系统恢复的时间，记为 $R_{r}$，包括相同的机械延迟 $m$，加上以读取吞吐量 $b_{r}$ 读取大小为 $s$ 的映像所需的时间。读取传输时间为 $\\frac{s}{b_{r}}$。因此，一次恢复操作的总时间为：\n$$R_{r} = m + \\frac{s}{b_{r}}$$\n\n### 任务2：$D(\\tau)$ 和 $L(\\tau)$ 的推导\n\n我们使用基于“检查点间隔内故障罕见”（即 $\\lambda \\tau \\ll 1$）这一假设的一阶分析来推导长期非生产性时间比例 $D(\\tau)$ 和数据丢失风险 $L(\\tau)$。这使我们能够考虑每个非生产性活动所贡献的开销比例。我们在一个任意长的时钟时间 $T_{total}$ 内分析系统。\n\n1.  **用于检查点操作的时间：** 在没有故障的情况下，系统执行有用计算 $\\tau$ 时间，然后花费 $C_{w}$ 的时长进行一次检查点操作。这样一个周期的时长为 $\\tau + C_{w}$。在 $T_{total}$ 期间进行的检查点次数大约为 $\\frac{T_{total}}{\\tau + C_{w}}$。由于假设开销占总时间的一小部分，我们可以用 $\\tau$ 来近似周期长度，所以检查点次数大约为 $\\frac{T_{total}}{\\tau}$。用于检查点操作的总时间是这个次数乘以单次检查点的时长 $C_{w}$。\n    $$T_{checkpoint} \\approx \\frac{T_{total}}{\\tau} C_{w}$$\n    用于检查点操作的时间比例是 $\\frac{T_{checkpoint}}{T_{total}} = \\frac{C_{w}}{\\tau}$。\n\n2.  **用于恢复的时间：** 故障以速率 $\\lambda$ 的泊松过程发生。在 $T_{total}$ 时段内，预期的故障次数为 $\\lambda T_{total}$。每次故障都需要一次恢复操作，耗时 $R_{r}$ 秒。用于恢复操作的总时间是故障次数乘以单次恢复的时长。\n    $$T_{restore} = (\\lambda T_{total}) R_{r}$$\n    用于恢复的时间比例是 $\\frac{T_{restore}}{T_{total}} = \\lambda R_{r}$。\n\n3.  **用于重新执行丢失工作的时间：** 当故障发生时，自上次成功检查点以来执行的计算会丢失，必须重新执行。假设故障发生在 $[0, \\tau]$ 区间内均匀分布的时间 $t_{f}$。因此，丢失的计算时间的期望值为 $E[t_{f}] = \\frac{\\tau}{2}$。用于重新执行丢失工作的总时间是预期的故障次数乘以每次故障丢失的期望时间。\n    $$T_{re-execute} = (\\lambda T_{total}) \\left(\\frac{\\tau}{2}\\right)$$\n    用于重新执行的时间比例是 $\\frac{T_{re-execute}}{T_{total}} = \\frac{\\lambda \\tau}{2}$。\n\n数据丢失风险 $L(\\tau)$ 定义为仅因重新执行而损失的时间比例。根据上述推导，我们有：\n$$L(\\tau) = \\frac{\\lambda \\tau}{2}$$\n\n总的非生产性时间比例 $D(\\tau)$ 是用于所有非生产性活动（检查点、恢复和重新执行）的时间比例之和。\n$$D(\\tau) = \\frac{C_{w}}{\\tau} + \\lambda R_{r} + \\frac{\\lambda \\tau}{2}$$\n这个表达式与各个开销比例的总和一致，代表了一个标准的检查点开销一阶模型。\n\n### 任务3：最优检查点间隔及相关开销\n\n为了找到使总非生产性时间比例 $D(\\tau)$ 最小化的检查点间隔 $\\tau^{\\ast}$，我们必须找到使任务2中推导的表达式最小化的 $\\tau$ 值。\n$$D(\\tau) = \\frac{C_{w}}{\\tau} + \\frac{\\lambda \\tau}{2} + \\lambda R_{r}$$\n$\\lambda R_{r}$ 项相对于 $\\tau$ 是一个常数，所以我们只需要最小化函数中与 $\\tau$ 相关的部分。我们通过求 $D(\\tau)$ 对 $\\tau$ 的导数并将其设为零来找到最小值。\n$$\\frac{dD}{d\\tau} = \\frac{d}{d\\tau} \\left( C_{w}\\tau^{-1} + \\frac{\\lambda}{2}\\tau + \\lambda R_{r} \\right) = -C_{w}\\tau^{-2} + \\frac{\\lambda}{2}$$\n将导数设为零以找到临界点：\n$$-\\frac{C_{w}}{(\\tau^{\\ast})^2} + \\frac{\\lambda}{2} = 0$$\n$$\\frac{\\lambda}{2} = \\frac{C_{w}}{(\\tau^{\\ast})^2}$$\n$$(\\tau^{\\ast})^2 = \\frac{2 C_{w}}{\\lambda}$$\n$$\\tau^{\\ast} = \\sqrt{\\frac{2 C_{w}}{\\lambda}}$$\n为了确认这是一个最小值，我们检查二阶导数：\n$$\\frac{d^2D}{d\\tau^2} = \\frac{d}{d\\tau} \\left(-C_{w}\\tau^{-2}\\right) = 2C_{w}\\tau^{-3} = \\frac{2 C_{w}}{\\tau^3}$$\n因为 $C_{w} > 0$ 且 $\\tau > 0$，二阶导数为正，这确认了 $\\tau^{\\ast}$ 对应一个局部最小值。\n\n现在我们在这个最优间隔处计算 $D(\\tau^{\\ast})$ 和 $L(\\tau^{\\ast})$。\n首先，对于 $L(\\tau^{\\ast})$：\n$$L(\\tau^{\\ast}) = \\frac{\\lambda \\tau^{\\ast}}{2} = \\frac{\\lambda}{2} \\sqrt{\\frac{2 C_{w}}{\\lambda}} = \\frac{1}{2}\\sqrt{\\lambda^2 \\frac{2 C_{w}}{\\lambda}} = \\sqrt{\\frac{2 \\lambda^2 C_{w}}{4\\lambda}} = \\sqrt{\\frac{\\lambda C_{w}}{2}}$$\n\n接下来，对于 $D(\\tau^{\\ast})$：\n$$D(\\tau^{\\ast}) = \\frac{C_{w}}{\\tau^{\\ast}} + \\frac{\\lambda \\tau^{\\ast}}{2} + \\lambda R_{r}$$\n我们将 $\\tau^{\\ast}$ 的表达式代入第一项：\n$$\\frac{C_{w}}{\\tau^{\\ast}} = \\frac{C_{w}}{\\sqrt{\\frac{2 C_{w}}{\\lambda}}} = C_{w}\\sqrt{\\frac{\\lambda}{2 C_{w}}} = \\sqrt{\\frac{C_{w}^2\\lambda}{2 C_{w}}} = \\sqrt{\\frac{\\lambda C_{w}}{2}}$$\n在最优点，$D(\\tau^{\\ast})$ 的前两项相等：$\\frac{C_{w}}{\\tau^{\\ast}} = L(\\tau^{\\ast}) = \\sqrt{\\frac{\\lambda C_{w}}{2}}$。这表明在最优间隔下，因检查点操作损失的时间等于因重新执行损失的时间。\n$$D(\\tau^{\\ast}) = \\sqrt{\\frac{\\lambda C_{w}}{2}} + \\sqrt{\\frac{\\lambda C_{w}}{2}} + \\lambda R_{r} = 2\\sqrt{\\frac{\\lambda C_{w}}{2}} + \\lambda R_{r} = \\sqrt{4\\frac{\\lambda C_{w}}{2}} + \\lambda R_{r} = \\sqrt{2\\lambda C_{w}} + \\lambda R_{r}$$\n\n最后，我们通过代入任务1中 $C_{w}$ 和 $R_{r}$ 的表达式，将这些结果用基本参数 $\\lambda$、$m$、$s$、$b_{w}$ 和 $b_{r}$ 表示。\n$$C_{w} = m + \\frac{s}{b_{w}}$$\n$$R_{r} = m + \\frac{s}{b_{r}}$$\n\n将 $C_{w}$ 代入 $D(\\tau^{\\ast})$ 和 $L(\\tau^{\\ast})$ 的表达式中：\n$$L(\\tau^{\\ast}) = \\sqrt{\\frac{\\lambda}{2} \\left(m + \\frac{s}{b_{w}}\\right)}$$\n\n将 $C_{w}$ 和 $R_{r}$ 都代入 $D(\\tau^{\\ast})$ 的表达式中：\n$$D(\\tau^{\\ast}) = \\sqrt{2\\lambda \\left(m + \\frac{s}{b_{w}}\\right)} + \\lambda \\left(m + \\frac{s}{b_{r}}\\right)$$\n\n最终答案是二元行矩阵 $[D(\\tau^{\\ast}), L(\\tau^{\\ast})]$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\sqrt{2 \\lambda \\left(m + \\frac{s}{b_{w}}\\right)} + \\lambda \\left(m + \\frac{s}{b_{r}}\\right)  \\sqrt{\\frac{\\lambda}{2} \\left(m + \\frac{s}{b_{w}}\\right)}\n\\end{pmatrix}\n}\n$$", "id": "3639697"}, {"introduction": "随着系统可靠性的提升，关注点从简单的“系统能否运行”演变为更深层次的“数据是否可信”。“静默数据损坏”是一种隐蔽但极具破坏性的威胁，它可以在不发出任何警告的情况下破坏存储在磁盘上的信息。本练习通过一个清晰的概率模型，量化对比了传统文件系统与现代采用校验和及数据复制（如RAID 1）的文件系统在应对该问题上的巨大差异，从而揭示了端到端数据完整性设计的压倒性优势 [@problem_id:3639725]。", "problem": "考虑从没有端到端完整性的传统文件系统到现代带校验和的文件系统的历史演变。在传统设计中，操作系统（OS）不维护文件数据的端到端校验和；存储设备返回的任何静默损坏都无法被检测到，损坏的字节会返回给应用程序。在现代设计中，文件系统为每个数据块存储一个强校验和（假设检测完美），并为每个数据块维护两个独立的副本，例如在独立磁盘冗余阵列（RAID）级别 $1$ 镜像中。如果一个数据块的读取在一个副本上校验和验证失败，文件系统会读取另一个副本，并在至少一个副本持有未损坏的拷贝时返回正确的数据。\n\n将静默损坏模型化如下：每个数据块的读取独立地以概率 $p$ 发生静默损坏，且损坏事件在不同数据块之间以及不同副本之间是独立的。设文件大小为 $1$ 吉比字节（GiB），数据块大小为 $4$ 千比字节（KiB）。取每个数据块读取的 $p = 1 \\times 10^{-9}$。将单次完整文件读取的端到端数据丢失定义为以下事件：应用程序由于至少一个数据块未能获得正确数据，原因或为损坏数据未经检测就被返回（传统设计），或为损坏虽被检测到但在两个副本上都无法恢复（带校验和的设计）。\n\n仅从事件独立性、补集法则和基本概率乘法法则的核心定义出发，推导两种设计中单次完整文件读取的端到端数据丢失概率的表达式：\n- 无校验和、无副本的传统文件系统。\n- 具有完美检测和两个独立副本的带校验和的文件系统。\n\n然后根据给定参数计算数值。将两个概率以标准科学记数法的小数形式表示。将您的答案四舍五入到 $4$ 位有效数字。不允许使用百分号；给出不带单位的纯小数值。", "solution": "问题陈述已被评估并被认为是有效的。它具有科学依据，问题提出得当，且客观。所有必要的参数都已提供，该模型虽然简化，但遵循了与计算机系统可靠性相关的逻辑和概率原则。\n\n目标是推导并计算在两种不同文件系统设计下单次完整文件读取的端到端数据丢失概率。我们首先确定文件中的数据块总数。\n\n设一个吉比字节（$1$ GiB）为 $2^{30}$ 字节，一个千比字节（$1$ KiB）为 $2^{10}$ 字节。文件大小为 $1$ GiB，数据块大小为 $4$ KiB。数据块的数量 $N$ 是文件大小与数据块大小的比率：\n$$N = \\frac{\\text{文件大小}}{\\text{数据块大小}} = \\frac{1 \\text{ GiB}}{4 \\text{ KiB}} = \\frac{2^{30} \\text{ bytes}}{4 \\times 2^{10} \\text{ bytes}} = \\frac{2^{30}}{2^2 \\times 2^{10}} = \\frac{2^{30}}{2^{12}} = 2^{18}$$\n计算此值可得：\n$$N = 2^{18} = 262144$$\n\n给定单个数据块读取发生静默损坏事件的概率为 $p = 1 \\times 10^{-9}$。这些事件对于每次数据块读取都是独立的。\n\n**传统文件系统（无校验和，无副本）**\n\n在传统设计中，如果至少有一个数据块在读取时发生静默损坏，就会发生数据丢失。由于没有校验和来检测错误，应用程序会接收到损坏的数据。\n\n设 $P_L$ 为传统系统的端到端数据丢失概率。更直接的方法是首先计算成功读取文件的概率，这是一个互补事件。当且仅当*所有* $N$ 个数据块都被无损坏地读取时，一次完整的文件读取才是成功的。\n\n单个数据块被正确读取（即无损坏）的概率是 $1-p$。\n由于所有数据块的读取事件都是独立的，所有 $N$ 个数据块都被正确读取的概率是它们各自成功概率的乘积：\n$$P(\\text{成功}) = (1-p) \\times (1-p) \\times \\dots \\times (1-p) \\quad (N \\text{ 次})$$\n$$P(\\text{成功}) = (1-p)^N$$\n\n数据丢失事件 $P_L$ 是成功读取的补集。使用补集法则 $P(A) = 1 - P(A^c)$：\n$$P_L = 1 - P(\\text{成功}) = 1 - (1-p)^N$$\n\n代入给定值 $N = 262144$ 和 $p = 1 \\times 10^{-9}$：\n$$P_L = 1 - (1 - 1 \\times 10^{-9})^{262144}$$\n\n对于一个小的 $x$ 值，可以使用二项式近似 $(1-x)^n \\approx 1-nx$。在这里，$p$ 非常小，因此 $Np = (262144)(1 \\times 10^{-9}) = 2.62144 \\times 10^{-4}$ 也很小。这证明了该近似的合理性：\n$$P_L \\approx 1 - (1 - Np) = Np$$\n$$P_L \\approx 262144 \\times (1 \\times 10^{-9}) = 2.62144 \\times 10^{-4}$$\n四舍五入到 $4$ 位有效数字，我们得到：\n$$P_L \\approx 2.621 \\times 10^{-4}$$\n\n**带校验和的文件系统（两个副本）**\n\n在现代设计中，每个数据块有两个独立的副本。只要一个数据块的至少一个副本未损坏，该数据块的数据就能被正确返回。特定数据块的数据丢失仅在读取时该数据块的*两个*副本都已损坏的情况下发生。\n\n设从单个副本读取的损坏概率为 $p$。从两个副本的读取是独立的。单个数据块的两个副本都损坏的概率是：\n$$p_{\\text{数据块丢失}} = p \\times p = p^2$$\n给定数据块可恢复（即不是数据块丢失事件）的概率是其补集：\n$$P(\\text{数据块可恢复}) = 1 - p^2$$\n\n要使一次完整的文件读取成功，所有 $N$ 个数据块都必须是可恢复的。由于损坏事件在不同数据块之间是独立的，一次成功的完整文件读取的概率是 $N$ 个数据块各自可恢复概率的乘积：\n$$P(\\text{成功}) = (1 - p^2) \\times (1 - p^2) \\times \\dots \\times (1 - p^2) \\quad (N \\text{ 次})$$\n$$P(\\text{成功}) = (1 - p^2)^N$$\n\n设 $P_M$ 为现代系统的端到端数据丢失概率。这是成功读取的补集：\n$$P_M = 1 - P(\\text{成功}) = 1 - (1 - p^2)^N$$\n\n代入值 $N = 262144$ 和 $p = 1 \\times 10^{-9}$：\n$$p^2 = (1 \\times 10^{-9})^2 = 1 \\times 10^{-18}$$\n$$P_M = 1 - (1 - 1 \\times 10^{-18})^{262144}$$\n\n$p^2$ 的值极小。我们可以放心地使用二项式近似 $1 - (1-x)^N \\approx Nx$，其中 $x=p^2$：\n$$P_M \\approx N p^2$$\n$$P_M \\approx 262144 \\times (1 \\times 10^{-18}) = 2.62144 \\times 10^5 \\times 10^{-18} = 2.62144 \\times 10^{-13}$$\n四舍五入到 $4$ 位有效数字，可得：\n$$P_M \\approx 2.621 \\times 10^{-13}$$\n\n结果表明，校验和与副本的结合显著提升了数据完整性。数据丢失的概率降低了大约九个数量级。", "answer": "$$\\boxed{\\begin{pmatrix} 2.621 \\times 10^{-4}  2.621 \\times 10^{-13} \\end{pmatrix}}$$", "id": "3639725"}, {"introduction": "进入现代，操作系统的复杂性急剧增加，理解系统内部的动态行为成为了性能优化和故障排查的关键。内核追踪技术（如DTrace和eBPF）应运而生，但它们也带来了新的挑战：如何在获取深刻洞察的同时，将对系统性能的影响降至最低？本练习通过构建一个价值-成本模型来形式化这一权衡，其中可观测性价值 $V(s)$ 随采样率 $s$ 呈递减收益，而探针成本 $\\kappa(s)$ 则非线性增加。通过优化这个模型，我们可以理解现代可观测性工具背后精妙的设计哲学 [@problem_id:3639734]。", "problem": "现代操作系统从粗粒度的事件记录演变为普遍的内核跟踪设施，以在系统行为洞察与运行时开销之间取得平衡。考虑对这种权衡进行建模，以解释 DTrace 和扩展伯克利包过滤器 (eBPF) 等内核跟踪工具的兴起。设可观测性价值是采样率 $s$（单位为样本/秒）的凹函数 $V(s)$，它捕捉了随着探针增多而出现的收益递减现象；设探针成本是凸函数 $\\kappa(s)$，它反映了因争用和缓存效应而增加的开销。具体来说，假设\n$$V(s) = \\alpha \\ln\\!\\big(1 + \\beta s\\big), \\quad \\kappa(s) = \\gamma s + \\delta s^{2},$$\n其中参数为 $\\alpha = 100$，$\\beta = 5 \\times 10^{-3}$ $\\mathrm{s}$，$\\gamma = 0.1$，以及 $\\delta = 1 \\times 10^{-4}$。净收益为 $F(s) = V(s) - \\kappa(s)$。\n\n使用基于微积分的优化基本原理（边际效益等于边际成本）并假设 $s \\ge 0$，确定使 $F(s)$ 最大化的采样率 $s^{\\star}$。将您的答案四舍五入到 $3$ 位有效数字，并以样本/秒为单位表示采样率。", "solution": "向普遍内核跟踪的演变可以通过可观测性与开销之间的形式化权衡来解释：随着探针密度的增加，检测提供的增量洞察会递减，而由于共享资源争用，开销的增长超过线性。捕捉收益递减的典型方法是对数效用，而捕捉开销增加的典型方法是二次成本。我们将净收益形式化为\n$$F(s) = V(s) - \\kappa(s) = \\alpha \\ln\\!\\big(1 + \\beta s\\big) - \\gamma s - \\delta s^{2}.$$\n我们寻求 $s^{\\star} \\ge 0$ 以最大化 $F(s)$。根据可微凹目标的标准一阶最优性条件，最大化者满足\n$$\\frac{d}{ds}F(s) = 0,$$\n并且二阶条件验证了此驻点是最大值。\n\n计算导数：\n$$\\frac{d}{ds}F(s) = \\frac{d}{ds}\\left[\\alpha \\ln\\!\\big(1 + \\beta s\\big)\\right] - \\frac{d}{ds}(\\gamma s) - \\frac{d}{ds}(\\delta s^{2}) = \\frac{\\alpha \\beta}{1 + \\beta s} - \\gamma - 2 \\delta s.$$\n将导数设为零：\n$$\\frac{\\alpha \\beta}{1 + \\beta s} - \\gamma - 2 \\delta s = 0.$$\n重新整理以求解 $s$。两边同乘以 $\\big(1 + \\beta s\\big)$ 以消去分母：\n$$\\alpha \\beta = \\big(\\gamma + 2 \\delta s\\big)\\big(1 + \\beta s\\big).$$\n展开右侧：\n$$\\alpha \\beta = \\gamma + \\gamma \\beta s + 2 \\delta s + 2 \\delta \\beta s^{2}.$$\n合并项以得到关于 $s$ 的二次方程：\n$$2 \\delta \\beta s^{2} + \\big(\\gamma \\beta + 2 \\delta\\big) s + \\gamma - \\alpha \\beta = 0.$$\n使用给定参数 $\\alpha = 100$，$\\beta = 5 \\times 10^{-3}$，$\\gamma = 0.1$ 和 $\\delta = 1 \\times 10^{-4}$，计算系数：\n- $2 \\delta \\beta = 2 \\times \\big(1 \\times 10^{-4}\\big) \\times \\big(5 \\times 10^{-3}\\big) = 1 \\times 10^{-6}$，\n- $\\gamma \\beta + 2 \\delta = 0.1 \\times \\big(5 \\times 10^{-3}\\big) + 2 \\times \\big(1 \\times 10^{-4}\\big) = 5 \\times 10^{-4} + 2 \\times 10^{-4} = 7 \\times 10^{-4}$，\n- $\\gamma - \\alpha \\beta = 0.1 - 100 \\times \\big(5 \\times 10^{-3}\\big) = 0.1 - 0.5 = -0.4$。\n\n因此二次方程为\n$$\\big(1 \\times 10^{-6}\\big) s^{2} + \\big(7 \\times 10^{-4}\\big) s - 0.4 = 0.$$\n使用二次公式求解。设 $a = 1 \\times 10^{-6}$，$b = 7 \\times 10^{-4}$，且 $c = -0.4$。判别式为\n$$\\Delta = b^{2} - 4 a c = \\big(7 \\times 10^{-4}\\big)^{2} - 4 \\times \\big(1 \\times 10^{-6}\\big) \\times \\big(-0.4\\big) = 4.9 \\times 10^{-7} + 1.6 \\times 10^{-6} = 2.09 \\times 10^{-6}.$$\n其平方根为\n$$\\sqrt{\\Delta} = \\sqrt{2.09 \\times 10^{-6}} \\approx 1.446664 \\times 10^{-3}.$$\n根是\n$$s = \\frac{-b \\pm \\sqrt{\\Delta}}{2 a} = \\frac{-7 \\times 10^{-4} \\pm 1.446664 \\times 10^{-3}}{2 \\times 10^{-6}}.$$\n负根不可行 ($s \\ge 0$)，因此取正根：\n$$s^{\\star} = \\frac{-7 \\times 10^{-4} + 1.446664 \\times 10^{-3}}{2 \\times 10^{-6}} = \\frac{7.46664 \\times 10^{-4}}{2 \\times 10^{-6}} \\approx 3.73332 \\times 10^{2}.$$\n验证二阶条件：\n$$\\frac{d^{2}}{ds^{2}}F(s) = -\\frac{\\alpha \\beta^{2}}{\\big(1 + \\beta s\\big)^{2}} - 2 \\delta  0,$$\n对于所有 $s \\ge 0$ 均成立，因为 $\\alpha  0$，$\\beta  0$ 且 $\\delta  0$。因此，该驻点确实是 $s \\ge 0$ 上的全局最大值。\n\n将 $s^{\\star}$ 四舍五入到 $3$ 位有效数字：\n$$s^{\\star} \\approx 373.$$\n在操作系统演变背景下的解释：凹函数 $V(s)$ 模拟了这样一个事实，即探针密度的早期增加（由 DTrace 以及后来的扩展伯克利包过滤器实现）会产生实质性的洞察，但每个额外的探针贡献较少。凸函数 $\\kappa(s)$ 模拟了开销随着探针密度的增加而急剧增长，特别是在使用朴素检测的情况下；诸如扩展伯克利包过滤器之类的进步降低了 $\\gamma$ 和 $\\delta$，从而将最优点移向更高的 $s^{\\star}$，同时保持效率。对于所提供的参数，最佳采样率为 $373$ 样本/秒。", "answer": "$$\\boxed{373}$$", "id": "3639734"}]}