{"hands_on_practices": [{"introduction": "操作系统的一个核心设计目标是高效管理资源以维持系统稳定性。当内存被过度使用时，系统可能会进入“颠簸”（thrashing）状态，此时系统花费在页面交换上的时间远超于执行有效工作的时间。这个练习 [@problem_id:3664899] 提供了一个具体场景，让你应用工作集模型来量化颠簸的发生点，并设计纠正策略，是将理论模型应用于诊断和解决关键性能问题的绝佳实践。", "problem": "一个拥有大小为 $R$ 的随机存取存储器 (RAM) 的多道程序系统正在运行 $n$ 个进程。在工作集模型下，每个进程 $i$ 在最近 $ \\Delta $ 次内存引用的窗口内有一个工作集 $W_i(\\Delta)$；该集合的大小为 $|W_i|$，以页或等效的内存单位计量。抖动（Thrashing）是一种操作状况，此时系统花费了不成比例的大部分时间来处理缺页，而不是执行有效的工作；在实践中，当活动工作集所要求的总驻留内存无法被可用的物理内存满足时，就会观察到这种现象。\n\n从这些原则出发，推导出一个阈值条件，该条件用一个包含 $R$ 和 $\\{|W_i|\\}_{i=1}^{n}$ 的不等式表示，标志着在稳态下工作集模型中抖动的开始，并假设为了维持低缺页率，工作集中的每一页都必须驻留在内存中。然后将此条件应用于以下具体场景，并确定一个与常见操作系统设计目标（例如在防止抖动的同时保持吞吐量）一致的最小纠正措施：\n\n- 物理内存 (RAM): $R = 16$ GiB。\n- 进程数: $n = 7$。\n- 工作集大小 (GiB): $|W_1| = 2.5$, $|W_2| = 3.0$, $|W_3| = 4.5$, $|W_4| = 1.0$, $|W_5| = 5.5$, $|W_6| = 2.0$, $|W_7| = 1.5$。\n- 操作系统采用一种安全余量策略：为降低抖动风险并适应短期波动，其目标是保留 RAM 的一个空闲内存余量分数 $\\beta$，其中 $\\beta = 0.2$。也就是说，它的目标是使活动工作集的总量不大于 $(1 - \\beta) R$。\n\n任务：\n1. 仅使用上述定义，推导出用 $R$ 和 $\\{|W_i|\\}$ 表示的、描述抖动开始的符号阈值不等式。\n2. 对于给定的 $R$ 和 $\\{|W_i|\\}$，计算总工作集需求，并确定系统是否正在发生抖动。\n3. 如果系统正在抖动，确定操作系统必须挂起的最小进程数（选择要挂起的进程以最小化数量），以使剩余活动工作集大小的总和不超过安全目标 $(1 - \\beta) R$。为了用最少的进程数来满足内存削减要求，应优先挂起工作集 $|W_i|$ 最大的进程。\n4. 最终答案仅报告需要挂起的最小进程数。不包括单位。此整数结果无需四舍五入。中间计算的内存量根据需要以 GiB 表示，但最终答案必须是一个纯数字。", "solution": "将通过首先提取所有给定信息，然后评估其科学基础、一致性和完整性来验证该问题。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n-   总 RAM 大小: $R$\n-   进程数: $n$\n-   进程 $i$ 的工作集大小: $|W_i|$\n-   抖动条件：活动工作集所要求的总驻留内存超出了可用的物理内存。\n-   低缺页率的要求：工作集中的每一页都必须驻留在 RAM 中。\n-   具体场景值：\n    -   物理内存 (RAM): $R = 16$ GiB\n    -   进程数: $n = 7$\n    -   工作集大小: $|W_1| = 2.5$ GiB, $|W_2| = 3.0$ GiB, $|W_3| = 4.5$ GiB, $|W_4| = 1.0$ GiB, $|W_5| = 5.5$ GiB, $|W_6| = 2.0$ GiB, $|W_7| = 1.5$ GiB。\n-   操作系统策略：\n    -   维持一个 $\\beta = 0.2$ 的空闲内存余量分数。\n    -   活动工作集总量大小的目标是不超过 $(1 - \\beta)R$。\n-   任务：\n    1.  推导抖动开始的符号阈值不等式。\n    2.  根据其策略确定给定系统是否正在抖动。\n    3.  找出为满足策略目标而需要挂起的最小进程数。挂起策略是最小化进程数量，并优先挂起 $|W_i|$ 较大的进程。\n    4.  报告需要挂起的最小进程数。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n-   **科学性：** 该问题基于公认的程序行为工作集模型和抖动概念，这些是操作系统中的基本主题。定义和关系都是标准的。此标准已满足。\n-   **适定性：** 该问题提供了所有必要的数值和明确、无歧义的纠正措施目标（最小化挂起的进程数）。可以确定唯一的解。此标准已满足。\n-   **客观性：** 该问题使用精确的定量语言陈述。它不含主观或基于意见的断言。此标准已满足。\n-   **缺陷清单：**\n    1.  **科学或事实不健全：** 无。该模型是计算机科学中使用的标准且有效的抽象。\n    2.  **不可形式化或不相关：** 无。该问题是一个可形式化的计算任务，与操作系统资源管理直接相关。\n    3.  **不完整或矛盾的设置：** 无。所有需要的数据和约束都已提供且自洽。\n    4.  **不切实际或不可行：** 无。内存和工作集大小对于现代多道程序系统是现实的。\n    5.  **不适定或结构不良：** 无。该问题导向一个唯一、稳定且有意义的解。\n    6.  **伪深刻、琐碎或同义反复：** 无。该问题需要一个涉及推导、计算和优化的多步逻辑过程，这是非平凡的。\n    7.  **超出科学可验证性范围：** 无。在给定模型内，计算是可验证的。\n\n**步骤 3：结论与行动**\n该问题是有效的。将提供完整的解答。\n\n### 解答\n\n**1. 符号阈值不等式的推导**\n\n问题将抖动定义为系统可用物理内存不足以容纳所有正在运行进程的活动工作集的情况。设 $R$ 为随机存取存储器 (RAM) 的总大小。现有 $n$ 个进程，进程 $i$ 的工作集大小表示为 $|W_i|$。\n\n为了使系统避免频繁的缺页，每个活动进程的工作集都必须驻留在内存中。因此，所有 $n$ 个进程所要求的总内存是它们各自工作集大小的总和。这个总需求 $D_{total}$ 由下式给出：\n$$\nD_{total} = \\sum_{i=1}^{n} |W_i|\n$$\n当这个总需求超过可用物理内存 $R$ 时，抖动开始发生。因此，阈值条件由以下不等式表示：\n$$\n\\sum_{i=1}^{n} |W_i| > R\n$$\n问题进一步指定了一个要求安全余量的操作系统策略。总 RAM 的一部分（比例为 $\\beta$）需保持空闲。这意味着可分配给工作集的内存实际上减少到 $(1 - \\beta)R$。在此策略下，如果总需求超过这个减少了的分配量，系统就被认为处于需要采取纠正措施的状态（一个由策略定义的抖动状态）。此场景下的控制不等式是：\n$$\n\\sum_{i=1}^{n} |W_i| > (1 - \\beta)R\n$$\n这就是我们必须为给定场景评估的条件。\n\n**2. 系统状态分析**\n\n我们有以下给定值：\n-   $R = 16$ GiB\n-   $\\beta = 0.2$\n-   工作集大小的集合是 $\\{2.5, 3.0, 4.5, 1.0, 5.5, 2.0, 1.5\\}$，单位均为 GiB。\n\n首先，我们计算总工作集需求 $D_{total}$：\n$$\nD_{total} = 2.5 + 3.0 + 4.5 + 1.0 + 5.5 + 2.0 + 1.5 = 20.0 \\text{ GiB}\n$$\n接下来，我们根据安全策略计算目标内存容量 $R_{target}$：\n$$\nR_{target} = (1 - \\beta)R = (1 - 0.2) \\times 16 = 0.8 \\times 16 = 12.8 \\text{ GiB}\n$$\n现在，我们检查是否满足策略定义的抖动条件：\n$$\nD_{total} > R_{target}\n$$\n$$\n20.0 \\text{ GiB} > 12.8 \\text{ GiB}\n$$\n该不等式成立。因此，根据其自身的资源管理策略，系统处于抖动状态，必须采取纠正措施。\n\n**3. 确定最小纠正措施**\n\n系统必须挂起一个或多个进程，以将总工作集需求 $D_{total}$ 减少到小于或等于 $R_{target}$ 的值。所需的内存需求减少量 $\\Delta D_{req}$ 是：\n$$\n\\Delta D_{req} = D_{total} - R_{target} = 20.0 - 12.8 = 7.2 \\text{ GiB}\n$$\n为了通过挂起最少数量的进程来释放至少 $7.2$ GiB 内存，我们应该采用贪心策略：首先挂起工作集最大的进程。这种方法对于最小化挂起进程的数量是最佳的。\n\n首先，我们按工作集大小 $|W_i|$ 的降序对进程进行排序：\n1.  进程 5: $|W_5| = 5.5$ GiB\n2.  进程 3: $|W_3| = 4.5$ GiB\n3.  进程 2: $|W_2| = 3.0$ GiB\n4.  进程 1: $|W_1| = 2.5$ GiB\n5.  进程 6: $|W_6| = 2.0$ GiB\n6.  进程 7: $|W_7| = 1.5$ GiB\n7.  进程 4: $|W_4| = 1.0$ GiB\n\n现在，我们累积计算被挂起进程的工作集大小，直到释放的总内存达到或超过 $\\Delta D_{req} = 7.2$ GiB。\n\n-   **挂起第一个进程 (进程 5)：**\n    -   挂起的进程数 = $1$。\n    -   释放的总内存 = $|W_5| = 5.5$ GiB。\n    -   由于 $5.5  7.2$，这还不够。我们必须再挂起一个进程。\n\n-   **挂起第二个进程 (进程 3)：**\n    -   挂起的进程数 = $2$。\n    -   释放的总内存 = $5.5 + |W_3| = 5.5 + 4.5 = 10.0$ GiB。\n    -   由于 $10.0 \\ge 7.2$，已达到所需的减少量。\n\n通过挂起两个进程（工作集大小分别为 $5.5$ GiB 和 $4.5$ GiB 的进程），总内存需求减少了 $10.0$ GiB。新的需求是 $20.0 - 10.0 = 10.0$ GiB，这小于 $12.8$ GiB 的目标。\n\n只挂起一个进程（最大的那个，即 $|W_5|=5.5$ GiB）是不够的。挂起任何其他两个进程将导致比挂起前两个最大的进程更小的内存减少（例如， $|W_3|+|W_2| = 4.5+3.0=7.5$，虽然也满足要求，但规则是优先挂起最大的以确保最优性）。因此，通过选择最大的那些进程可以达到最小的挂起进程数。\n\n因此，操作系统必须挂起的最小进程数是 $2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3664899"}, {"introduction": "虽然最大化吞吐量很重要，但调度器还必须确保公平性，防止高优先级任务无限期地“饿死”低优先级任务。“老化”（Aging）是一种经典技术，通过动态提升等待进程的优先级来解决此问题。通过实现一个带老化机制的优先级调度器的模拟程序 [@problem_id:3664844]，你将亲手体验该机制如何防止饥饿，从而将公平性这一抽象概念与调度器中的具体实现联系起来。", "problem": "您将设计并实现一个离散时间实验，以评估抢占式优先级调度器中的老化现象，并为防止饥饿导出调优指南。该模型有意设计得非常精简，以便隔离老化效应。\n\n基本基础和定义：\n- 时间以离散的时隙推进，索引为 $t \\in \\mathbb{N}$。\n- 每个进程 $i$ 都有一个固定的基本优先级 $P_i \\in \\mathbb{R}$，值越大表示偏好越高。\n- 在时隙 $t$ 开始时，每个就绪但未运行的进程 $i$ 都有一个等待时间 $W_i(t) \\in \\mathbb{N}$，定义为截至 $t$ 时其连续处于就绪但未运行状态的时隙数。当一个进程在某个时隙被调度时，其等待时间在该时隙结束时被设为 $0$。\n- 对于一个全局老化率 $\\alpha \\ge 0$，调度器计算一个动态优先级\n$$\nD_i(t) = P_i + \\alpha \\cdot W_i(t).\n$$\n- 在每个时隙 $t$，调度器选择具有最大 $D_i(t)$ 的就绪进程。平局通过选择较小的进程标识符来打破；具体来说，低优先级进程的标识符为 $0$，高优先级进程的标识符为 $1$。\n- 执行在时隙边界是抢占式的。正在运行的进程执行一个完整的时隙，然后做出下一个决策。当一个进程累积了其所需的服务时隙数时，它就完成了。\n\n封闭双进程实验：\n- 在 $t=0$ 时存在两个进程：\n  - 一个高优先级进程 $H$，其基本优先级为 $P_H$，服务需求实际上是无限的，因此除非在当前时隙被抢占，否则它总是就绪的。\n  - 一个低优先级进程 $L$，其基本优先级为 $P_L$，服务需求为有限的 $S_L \\in \\mathbb{N}$ 个时隙。\n- 没有其他进程到达，并且 $H$ 和 $L$ 在 $L$ 完成之前都始终处于就绪状态。\n- 只有就绪但未运行的进程的等待时间会增加；正在运行的进程在其运行的时隙结束时等待时间为 $0$。\n\n为每个测试用例计算的量：\n- 令 $\\Delta P = P_H - P_L$。\n- 针对 $L$ 的饥饿谓词 $b \\in \\{0,1\\}$：当且仅当在指定的 $\\alpha$ 下，$L$ 在封闭双进程模型中没有得到任何服务时，$b=1$；否则 $b=0$。在此模型中，当且仅当 $\\alpha=0$ 且 $P_H  P_L$ 时，$b=1$。\n- 给定 $L$ 的两个服务时隙之间允许的最大等待时隙数的界限 $B \\in \\mathbb{N}$（将第一次等待解释为直到 $L$ 首次被调度时的等待时隙数），推导出最小老化率\n$$\n\\alpha_{\\min} = \\frac{\\max(0,\\, P_H - P_L)}{B}\n$$\n以保证在上述平局打破规则的封闭双进程模型中，$L$ 的服务间等待时间永远不会超过 $B$。您必须计算并报告此值。\n- 完全按照定义模拟调度器，直到 $L$ 完成（或在适用时声明饥饿），并报告：\n  - 在 $L$ 的整个执行过程中，其最大服务间等待间隙 $g \\in \\mathbb{Z}$，将首次服务前的初始等待计为一个间隙，将后续每个间隙计为 $L$ 的两个连续服务时隙之间的等待时隙数。如果发生饥饿，则设 $g=-1$。\n  - 完成时间 $m \\in \\mathbb{Z}$，即从 $t=0$ 到 $L$ 完成的总时隙数。如果发生饥饿，则设 $m=-1$。\n\n测试套件：\n请精确使用以下四个测试用例。对于每个用例，输入按顺序为 $(P_H, P_L, \\alpha, S_L, B)$。\n\n- 用例 1 (正常路径): $(10, 8, 0.5, 4, 4)$。\n- 用例 2 (边界饥饿): $(7, 1, 0.0, 3, 5)$。\n- 用例 3 (小老化率): $(12, 0, 0.2, 5, 20)$。\n- 用例 4 (大老化率): $(3, 0, 5.0, 2, 1)$。\n\n输出规范：\n- 对于每个测试用例，生成一个列表 $[b, \\alpha_{\\min}, g, m]$，其中 $b$ 是一个整数，$\\alpha_{\\min}$ 是一个四舍五入到六位小数的浮点数，而 $g$ 和 $m$ 是整数。\n- 您的程序应生成单行输出，其中包含这些四元素列表的逗号分隔列表形式的结果，并用方括号括起来，例如：\n\"[[b_1,alpha_min_1,g_1,m_1],[b_2,alpha_min_2,g_2,m_2],[b_3,alpha_min_3,g_3,m_3],[b_4,alpha_min_4,g_4,m_4]]\"。\n- 不应打印任何其他文本。\n\n角度单位不适用。没有物理单位。\n\n您的程序必须是一个完整的、可运行的程序，能够使用指定的测试套件生成所需的单行输出。所有计算必须遵循上述数学定义，所有浮点输出必须四舍五入到六位小数。", "solution": "在提供解决方案之前，对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **时间：** 离散时隙，$t \\in \\mathbb{N}$。\n- **进程：** 每个进程 $i$ 都有一个固定的基本优先级 $P_i \\in \\mathbb{R}$。\n- **等待时间：** 在时隙 $t$ 开始时，一个就绪但未运行的进程 $i$ 有一个等待时间 $W_i(t) \\in \\mathbb{N}$。这是它连续处于就绪但未运行状态的时隙数。当进程 $i$ 被调度时，在那个时隙结束时 $W_i(t)$ 被重置为 $0$。\n- **老化：** 有一个全局老化率 $\\alpha \\ge 0$。\n- **动态优先级：** 动态优先级为 $D_i(t) = P_i + \\alpha \\cdot W_i(t)$。\n- **调度策略：** 在每个时隙 $t$，调度器选择具有最大动态优先级 $D_i(t)$ 的就绪进程。\n- **平局打破规则：** 动态优先级的平局通过选择进程标识符较小的进程来打破。低优先级进程 $L$ 的标识符为 $0$，高优先级进程 $H$ 的标识符为 $1$。\n- **执行：** 在时隙边界是抢占式的。被调度的进程运行一个完整的时隙。\n- **双进程实验设置：**\n    - 进程 $H$（ID $1$）：基本优先级 $P_H$，始终就绪（服务需求无限）。\n    - 进程 $L$（ID $0$）：基本优先级 $P_L$，服务需求为 $S_L \\in \\mathbb{N}$ 个时隙，在完成前始终就绪。\n    - 两个进程都在 $t=0$ 时存在且就绪。\n- **待计算量：**\n    - $\\Delta P = P_H - P_L$。\n    - 进程 $L$ 的饥饿谓词 $b \\in \\{0,1\\}$。给定当且仅当 $\\alpha=0$ 且 $P_H  P_L$ 时 $b=1$。\n    - 最小老化率 $\\alpha_{\\min} = \\frac{\\max(0,\\, P_H - P_L)}{B}$，以保证 $L$ 的服务间等待时间不超过一个界限 $B \\in \\mathbb{N}$。\n    - $L$ 的最大服务间等待间隙 $g \\in \\mathbb{Z}$。初始等待时间算作一个间隙。如果发生饥饿，则 $g=-1$。\n    - 完成时间 $m \\in \\mathbb{Z}$，即 $L$ 完成前的总时隙数。如果发生饥饿，则 $m=-1$。\n- **测试套件：**\n    - 用例 1: $(P_H, P_L, \\alpha, S_L, B) = (10, 8, 0.5, 4, 4)$\n    - 用例 2: $(P_H, P_L, \\alpha, S_L, B) = (7, 1, 0.0, 3, 5)$\n    - 用例 3: $(P_H, P_L, \\alpha, S_L, B) = (12, 0, 0.2, 5, 20)$\n    - 用例 4: $(P_H, P_L, \\alpha, S_L, B) = (3, 0, 5.0, 2, 1)$\n\n### 步骤 2：使用提取的已知条件进行验证\n问题描述了一个优先级老化调度器的确定性模拟，这是操作系统中的一个标准主题。\n- **科学/事实合理性：** 该模型是一个基于既定计算机科学原理的、定义明确的数学构造。饥饿的定义与模型的动态特性一致：如果 $\\alpha=0$，优先级是静态的。如果 $P_H  P_L$，$H$ 将总是被选择优先于 $L$，导致饥饿。\n- **良定性：** 调度、优先级更新和打破平局的规则是明确且确定性的。对于任何给定的参数集，系统的演化是唯一的。解存在且是唯一可计算的。\n- **客观性：** 问题使用精确的数学和算法语言指定，没有主观性。\n- **完整性：** 所有必要的参数 $(P_H, P_L, \\alpha, S_L, B)$ 和初始条件 ($W_L(0)=0$，$W_H(0)=0$) 都已提供或隐含。\n\n问题是自包含的、逻辑一致的、并且是形式化的。它没有违反任何无效标准。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n### 解法推导\n\n解决方案要求为每个测试用例计算四个量：饥饿谓词 $b$、最小老化率 $\\alpha_{\\min}$、最大等待间隙 $g$ 和完成时间 $m$。\n\n**1. 饥饿谓词 ($b$)**\n问题明确定义了饥饿的条件：当且仅当老化因子 $\\alpha=0$ 且进程 $L$ 的基本优先级 $P_L$ 严格小于进程 $H$ 的基本优先级 $P_H$ 时，进程 $L$ 得不到服务。\n$$b = \\begin{cases} 1  \\text{若 } \\alpha = 0 \\text{ 且 } P_H  P_L \\\\ 0  \\text{否则} \\end{cases}$$\n如果 $b=1$，模拟是微不足道的：$L$ 永远不会运行，所以它的最大等待间隙和完成时间实际上是无限的，用 $g=-1$ 和 $m=-1$ 表示。\n\n**2. 最小老化率 ($\\alpha_{\\min}$)**\n目标是找到最小的 $\\alpha$，以确保 $L$ 在服务时隙之间的等待时间永远不会超过 $B$。令 $\\Delta P = P_H - P_L$。\n如果 $\\Delta P \\le 0$，那么 $P_L \\ge P_H$。在任何需要在等待时间相等的 $H$ 和 $L$ 之间做出调度决策时（例如，在 $t=0$ 时），由于其较高或相等的优先级以及平局打破规则（ID $0 $ ID $1$），$L$ 会获胜。$L$ 将运行，而 $H$ 将等待。在下一个时隙中，$W_L=0$ 且 $W_H=1$。要让 $H$ 抢占 $L$，我们需要 $D_H > D_L$，即 $P_H + \\alpha \\cdot 1 > P_L$。这与 $L$ 是否饥饿无关。如果 $P_L \\ge P_H$，$L$ 没有被 $H$ 饥饿的风险，因此任何 $\\alpha \\ge 0$ 都足够。所需的最小速率是 $\\alpha_{\\min}=0$。\n\n如果 $\\Delta P  0$，进程 $H$ 具有较高的基本优先级。在 $L$ 运行后，其等待时间被重置为 $W_L=0$。此时，$H$ 已经等待了至少一个时隙。让我们分析 $L$ 的最坏情况，即当 $H$ 连续运行一系列时隙时。假设 $H$ 连续运行 $k$ 个时隙。在此期间，$W_H=0$ 并且 $W_L$ 从 $0$ 递增到 $k$。动态优先级为 $D_H(t) = P_H$ 和 $D_L(t) = P_L + \\alpha \\cdot W_L(t)$。\n只要 $D_H  D_L$，进程 $H$ 就会继续运行。当进程 $L$ 的动态优先级至少等于 $H$ 的动态优先级时，它最终将被调度。由于平局打破规则，如果 $D_L \\ge D_H$，$L$ 就会运行。\n这种情况发生在：\n$$P_L + \\alpha \\cdot W_L(t) \\ge P_H$$\n设 $k$ 是 $L$ 已经等待的时隙数，所以 $W_L(t) = k$。我们需要找到最小的 $\\alpha$，以保证等待时间 $k$ 不超过 $B$。这意味着等待 $B$ 个时隙后，$L$ 必须被调度。\n$$P_L + \\alpha \\cdot B \\ge P_H$$\n重新整理 $\\alpha$：\n$$\\alpha \\cdot B \\ge P_H - P_L$$\n$$\\alpha \\ge \\frac{P_H - P_L}{B} = \\frac{\\Delta P}{B}$$\n因此，最小老化率为 $\\alpha_{\\min} = \\frac{\\Delta P}{B}$。\n结合两种情况（$\\Delta P  0$ 和 $\\Delta P \\le 0$），我们得到所提供的公式：\n$$\\alpha_{\\min} = \\frac{\\max(0, P_H - P_L)}{B}$$\n\n**3. 模拟最大等待间隙 ($g$) 和完成时间 ($m$)**\n如果 $b=0$，我们必须执行一个离散时间模拟。我们在 $t=0$ 时初始化状态：\n- 时间 $t = 0$。\n- $L$ 的剩余服务, $s_{L, \\text{rem}} = S_L$。\n- 等待时间 $W_L=0, W_H=0$。\n- 到目前为止看到的最大间隙, $g_{\\max}=0$。\n\n模拟在一个循环中进行，每次迭代将 $t$ 推进 $1$，直到 $s_{L, \\text{rem}}=0$。\n在每个时隙 $t$：\n1.  计算动态优先级：\n    $$D_L = P_L + \\alpha \\cdot W_L$$\n    $$D_H = P_H + \\alpha \\cdot W_H$$\n2.  应用调度规则：\n    - 如果 $D_L \\ge D_H$，则调度进程 $L$。这是因为如果 $D_L > D_H$，$L$ 获胜。如果 $D_L = D_H$，平局打破规则（ID $0 $ ID $1$）会选择 $L$。\n    - 否则，如果 $D_H > D_L$，则调度进程 $H$。\n3.  根据被调度的进程更新状态：\n    - **如果 $L$ 运行：** $L$ 的当前等待时间是 $W_L$。这结束了一个等待期。我们更新 $g_{\\max} = \\max(g_{\\max}, W_L)$。然后，我们减少 $L$ 的剩余服务, $s_{L, \\text{rem}} \\leftarrow s_{L, \\text{rem}} - 1$。为下一个时隙更新等待时间：$W_L$ 被重置为 $0$，而 $W_H$ 增加 $1$。\n    - **如果 $H$ 运行：** 进程 $L$ 继续等待，所以 $W_L$ 增加 $1$。$W_H$ 被重置为 $0$。\n\n当 $s_{L, \\text{rem}}$ 达到 $0$ 时，循环终止。最终时间 $t$ 是完成时间 $m$，最终计算出的 $g_{\\max}$ 是最大等待间隙 $g$。\n对于此问题中的所有非饥饿情况，系统会进入一个可预测的周期。$L$ 必须等待的时隙数 $k$ 是满足 $P_L + \\alpha k \\ge P_H$ 的最小整数。这个 $k$ 将是最大等待间隙。总完成时间将是 $S_L$ 乘以一个周期的长度（即 $k$ 个 $L$ 的等待时隙加上 $1$ 个 $L$ 的运行时隙）减去最后一个周期的等待时间。更精确地说，是 $(S_L - 1) \\times (k+1) + k + 1$。", "answer": "[[0,0.500000,4,20],[1,1.200000,-1,-1],[0,0.600000,60,305],[0,3.000000,1,4]]", "id": "3664844"}, {"introduction": "除了性能和公平性，操作系统的一个根本设计原则是隔离：保护进程免受彼此干扰，以及保护内核不受用户进程的影响。这通常通过一个受控接口（如系统调用）来仲裁对系统资源的访问来实现。这个练习 [@problem_id:3664897] 要求你构建一个引用监视器的抽象模型，以强制执行系统调用白名单，从而阐明“最小权限”和“完全仲裁”等原则在构建安全、稳健系统中的实际应用。", "problem": "设计并实现一个自包含程序，通过一个强制执行系统调用允许列表的抽象、确定性引用监控器，来模拟操作系统中的隔离原则。该模型旨在通过完全中介和最小权限来捕获隔离的设计目标，其精神类似于系统调用过滤机制。该程序不得依赖任何操作系统接口；相反，它必须模拟该策略及其对工作负载轨迹的影响。\n\n您的推理应基于以下基本定义，这些定义应被视为推导的唯一允许起点：\n\n- 系统调用是通往内核权限的唯一受控接口；引用监控器中介每个系统调用（完全中介），并通过允许或阻止尝试的系统调用来强制执行安全策略。\n- 在故障即停策略下，当一个尝试的系统调用不在允许的调用列表中时，该进程将立即被终止，并且不会再尝试更多的系统调用。\n- 最小权限原则通过只允许一个大小为 $n$ 的许可系统调用集合（称为允许列表）来体现。\n\n抽象模型和语义：\n\n- 设系统调用的全集由整数索引，并且设 $\\mathcal{A}$ 表示允许的系统调用标识符集合，其大小为 $\\lvert \\mathcal{A} \\rvert = n$。\n- 设 $\\mathcal{H}$ 表示一组被认为是有害的标识符集合。\n- 设 $W = \\langle w_0, w_1, \\dots, w_{L-1} \\rangle$ 表示一个尝试的系统调用的工作负载轨迹，其中每个 $w_i$ 是一个整数标识符。\n- 在该策略下的执行在 $W$ 上从左到右进行，并伴随完全中介。如果 $w_i \\in \\mathcal{A}$，则 $w_i$ 被执行。如果 $w_i \\notin \\mathcal{A}$，则进程在索引 $i$ 处终止（故障即停），并且对于 $j > i$ 的后续 $w_j$ 将不会被执行。\n- 定义有害逃逸指示器 $E$ 如下：如果存在一个索引 $i$ 使得 $w_i \\in \\mathcal{H}$ 并且 $w_i$ 在策略下被执行，则 $E = 1$；否则 $E = 0$。\n- 定义允许执行计数 $C$ 为在终止前（或如果没有发生终止，则为 $W$ 的全部）执行的系统调用的数量。\n- 定义阻塞索引 $B$ 为遇到第一个不允许的调用的索引；如果没有不允许的调用，则设 $B = -1$。\n- 定义遏制成功 $S$ 为：如果 $E = 0$，则 $S = 1$，否则 $S = 0$。\n\n您的任务：\n\n- 实现一个程序，该程序在给定下面指定的固定测试用例的情况下，根据上述语义模拟执行，并为每个测试用例输出四元组 $[S, C, B, E]$。\n- 布尔值必须表示为整数：使用 $1$ 表示真，$0$ 表示假。\n- 不涉及任何物理单位。\n\n测试套件：\n\n为以下测试用例提供结果。对于每个用例，提供了全集大小 $S$ 作为上下文，但只有 $\\mathcal{A}$、$\\mathcal{H}$ 和 $W$ 影响模拟。\n\n- 测试用例 $T_1$：$S = 8$, $n = 3$, $\\mathcal{A} = \\{0, 1, 2\\}$, $\\mathcal{H} = \\{5, 6\\}$, $W = \\langle 0, 1, 5, 3, 6 \\rangle$。\n- 测试用例 $T_2$：$S = 8$, $n = 0$, $\\mathcal{A} = \\varnothing$, $\\mathcal{H} = \\{2, 3\\}$, $W = \\langle 2, 7, 3 \\rangle$。\n- 测试用例 $T_3$：$S = 8$, $n = 4$, $\\mathcal{A} = \\{0, 2, 5, 7\\}$, $\\mathcal{H} = \\{5, 6\\}$, $W = \\langle 0, 5, 2, 7 \\rangle$。\n- 测试用例 $T_4$：$S = 8$, $n = 3$, $\\mathcal{A} = \\{0, 4, 6\\}$, $\\mathcal{H} = \\{6, 7\\}$, $W = \\langle 0, 4, 1, 6, 7 \\rangle$。\n- 测试用例 $T_5$：$S = 8$, $n = 2$, $\\mathcal{A} = \\{1, 3\\}$, $\\mathcal{H} = \\{2\\}$, $W = \\langle \\rangle$（空轨迹）。\n- 测试用例 $T_6$：$S = 8$, $n = 3$, $\\mathcal{A} = \\{1, 5, 7\\}$, $\\mathcal{H} = \\{5\\}$, $W = \\langle 1, 5, 2 \\rangle$。\n\n要求的最终输出格式：\n\n- 您的程序应生成单行输出，其中包含按 $T_1$ 到 $T_6$ 顺序排列的结果，格式为每个测试用例列表的逗号分隔列表，不含空格。例如，要求的格式正是\n$[[S_1,C_1,B_1,E_1],[S_2,C_2,B_2,E_2],\\dots,[S_6,C_6,B_6,E_6]]$ 的形式，\n打印在单行上，无其他内容。\n- 程序必须是自包含的，不得读取任何输入，并且必须根据上面指定的测试套件计算结果。", "solution": "问题陈述是有效的。它提出了一个关于引用监控器的定义明确、自包含且有科学依据的抽象模型，这是操作系统安全中的一个基本概念。\n\n该模型基于完全中介、最小权限和故障即停策略的既定原则。\n\n定义、语义和测试用例清晰、精确且逻辑一致，从而可以推导出一个唯一的、确定性的解决方案。\n\n任务是模拟引用监控器在给定的工作负载轨迹上强制执行安全策略的过程。模拟必须遵循所提供的抽象模型及其确定性语义。核心原则是：\n\n1.  **完全中介**：来自工作负载轨迹的每一次系统调用尝试都必须由引用监控器进行中介。\n2.  **最小权限**：安全策略是一个允许列表，由集合 $\\mathcal{A}$ 表示。进程仅被授予在 $\\mathcal{A}$ 中明确列出的权限（即系统调用）。\n3.  **故障即停**：如果一个进程尝试一个不在 $\\mathcal{A}$ 中的系统调用，其执行将立即被终止。\n\n设系统调用的全集是一个整数集合。策略由两个集合定义：\n-   $\\mathcal{A}$：允许的系统调用标识符集合。\n-   $\\mathcal{H}$：有害的系统调用标识符集合。\n\n一个进程的行为被建模为一个工作负载轨迹 $W = \\langle w_0, w_1, \\dots, w_{L-1} \\rangle$，它是一系列尝试的系统调用标识符。\n\n模拟根据轨迹执行评估四个指标：\n-   $C$：在允许列表 $\\mathcal{A}$ 中的已执行系统调用的计数。\n-   $B$：$W$ 中第一个不在 $\\mathcal{A}$ 内的系统调用的索引。如果 $W$ 中的所有调用都被允许，则 $B = -1$。\n-   $E$：一个二元指示器，如果任何已执行的系统调用也是有害集 $\\mathcal{H}$ 的成员，则 $E = 1$，否则 $E = 0$。一个已执行的调用是指在允许列表 $\\mathcal{A}$ 中的调用。\n-   $S$：遏制成功的二元指示器，定义为如果 $E=0$ 则 $S = 1$，如果 $E=1$ 则 $S = 0$。这等价于 $S = 1 - E$。\n\n对于每个测试用例，模拟算法按以下步骤进行：\n\n1.  初始化状态变量：\n    -   允许执行计数：$C = 0$。\n    -   有害逃逸指示器：$E = 0$。\n    -   阻塞索引：$B = -1$。\n\n2.  从索引 $i=0$ 到 $L-1$ 遍历工作负载轨迹 $W$，其中 $L$ 是轨迹的长度。这实现了**完全中介**的原则，因为每个调用都会被检查。\n\n3.  对于索引 $i$ 处的每个系统调用标识符 $w_i$：\n    a.  检查其是否在允许列表 $\\mathcal{A}$ 中。此步骤强制执行**最小权限**原则。\n    b.  如果 $w_i \\in \\mathcal{A}$：\n        i.  调用被允许。增加执行计数：$C \\leftarrow C + 1$。\n        ii. 检查是否有害。如果 $w_i \\in \\mathcal{H}$，设置有害逃逸指示器：$E \\leftarrow 1$。\n        iii. 继续处理轨迹中的下一个系统调用 $w_{i+1}$。\n    c.  如果 $w_i \\notin \\mathcal{A}$：\n        i.  调用被阻塞。执行**故障即停**策略。\n        ii. 设置阻塞索引：$B \\leftarrow i$。\n        iii. 立即终止当前轨迹的模拟。对于 $j > i$ 的后续调用 $w_j$ 将不被处理。\n\n4.  循环终止后（无论是完成轨迹还是因故障即停）：\n    a.  如果循环完成而没有发生故障即停，则保留初始值 $B=-1$，这正确地表明没有调用被阻塞。\n    b.  计算遏制成功：$S \\leftarrow 1 - E$。\n\n这个确定性算法被应用于六个指定的测试用例中的每一个。实现需要一个辅助函数来检查一个整数是否存在于给定的集合中（表示为数组）。最终输出被构造成单行，包含每个测试用例的四元组 $[S, C, B, E]$ 列表。", "answer": "[[1,2,2,0],[1,0,0,0],[0,4,-1,1],[1,2,2,0],[1,0,-1,0],[0,2,2,1]]", "id": "3664897"}]}