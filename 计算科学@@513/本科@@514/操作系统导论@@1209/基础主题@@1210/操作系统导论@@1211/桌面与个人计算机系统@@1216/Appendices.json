{"hands_on_practices": [{"introduction": "现代桌面系统需要同时运行多个应用程序，例如后台备份、视频通话和代码编辑，它们共同竞争着有限的系统资源。操作系统必须通过有效的资源调度来平衡这些需求，以确保系统的响应性和稳定性。本练习 [@problem_id:3633834] 将引导你通过一个基于模型的分析，来判断一组给定的混合工作负载是否能够在具有特定 CPU、磁盘 I/O 和网络容量的系统上可行地运行，从而让你掌握识别和分析资源瓶颈的核心技能。", "problem": "要求您对一个混合桌面工作负载进行稳态资源划分分析的形式化与实现，该工作负载包含一个备份进程、一个交互式视频通话和一个交互式编码会话。该桌面环境运行在单台个人计算机系统上。请使用以下基本定义作为您推理的基础。\n\n比例份额调度器通过将资源划分为多个分数来分配给不同任务。对于总容量为 $C_r$ 的资源以及由 $t$ 索引的任务，每个任务 $t$ 被分配一个非负份额 $s_{r,t}$。调度器为任务 $t$ 提供一个等于 $f_{r,t} \\cdot C_r$ 的实现服务速率，其中 $f_{r,t} = \\dfrac{s_{r,t}}{\\sum_j s_{r,j}}$ 是该任务所占的资源分数。在稳态下，当且仅当 $f_{r,t} \\cdot C_r \\ge R_{t,r}$ 时，要求资源 $r$ 最低服务速率为 $R_{t,r}$ 的任务 $t$ 得到满足。中央处理器 (CPU)、磁盘输入/输出 (I/O) 和网络被视为独立的资源。备份是一个面向吞吐量的任务，具有非平凡的磁盘I/O和网络需求，以及少量的CPU开销；视频通话是一个延迟敏感型工作负载，具有非平凡的CPU和网络需求，以及可忽略的磁盘I/O；编码会话是交互式的，具有非平凡的CPU和少量的磁盘I/O需求。\n\n任务：\n- 对于每个测试用例，您必须确定是否存在一个静态资源划分设计，其份额向量为 $s_{\\text{cpu}} = [s_{\\text{cpu},B}, s_{\\text{cpu},V}, s_{\\text{cpu},C}]$, $s_{\\text{io}} = [s_{\\text{io},B}, s_{\\text{io},V}, s_{\\text{io},C}]$, 和 $s_{\\text{net}} = [s_{\\text{net},B}, s_{\\text{net},V}, s_{\\text{net},C}]$，使得在上述定义的比例份额调度器下，实现的服务速率能够同时满足所有三个任务在所有三个资源上的最低要求。您的设计必须采用基于基本定义的份额分配方法，不得依赖未经证明的捷径。\n\n假设与单位：\n- 资源容量：CPU容量 $C_{\\text{cpu}}$ 单位为吉指令/秒 (GIPS)，磁盘I/O容量 $C_{\\text{io}}$ 单位为兆字节/秒 (MB/s)，网络容量 $C_{\\text{net}}$ 单位为兆比特/秒 (Mb/s)。\n- 每个任务在每种资源上的最低需求速率 $R_{t,r}$ 与对应的 $C_r$ 使用相同单位。\n- 三个任务分别是 $B$ (备份)、$V$ (视频通话) 和 $C$ (编码)。\n- 浮点数比较应将小于或等于容量的总和视为可行，并使用 $\\varepsilon = 10^{-9}$ 的绝对容差来防止数值舍入误差；也就是说，将 $x \\le y + \\varepsilon$ 视为满足条件。\n\n您必须实现的内容：\n- 对每个测试用例，判断是否存在一个可行的静态份额分配方案 $s_{\\text{cpu}}$、$s_{\\text{io}}$ 和 $s_{\\text{net}}$，使得在比例份额调度下，所有三个任务在所有三个资源上都得到满足。您的算法必须能通过给定的定义得到合理解释。\n- 您可以在内部计算任何中间份额向量，但您的程序对每个测试用例最终报告的结果必须仅为一个布尔可行性指标。\n\n测试套件：\n为以下五个案例提供结果。每个案例指定了 $(C_{\\text{cpu}}, C_{\\text{io}}, C_{\\text{net}})$ 和九个需求 $\\{R_{t,r}\\}$，其中 $t \\in \\{B,V,C\\}$ 且 $r \\in \\{\\text{cpu}, \\text{io}, \\text{net}\\}$。\n\n- 案例1（典型桌面资源，中等需求）：\n  - 容量：$C_{\\text{cpu}} = 50$ GIPS, $C_{\\text{io}} = 500$ MB/s, $C_{\\text{net}} = 1000$ Mb/s。\n  - 备份：$R_{B,\\text{cpu}} = 1$, $R_{B,\\text{io}} = 200$, $R_{B,\\text{net}} = 500$。\n  - 视频：$R_{V,\\text{cpu}} = 5$, $R_{V,\\text{io}} = 0.5$, $R_{V,\\text{net}} = 8$。\n  - 编码：$R_{C,\\text{cpu}} = 8$, $R_{C,\\text{io}} = 5$, $R_{C,\\text{net}} = 1$。\n\n- 案例2（CPU恰好被需求饱和，其他资源充足）：\n  - 容量：$C_{\\text{cpu}} = 14$, $C_{\\text{io}} = 1000$, $C_{\\text{net}} = 2000$。\n  - 需求与案例1相同。\n\n- 案例3（网络瓶颈）：\n  - 容量：$C_{\\text{cpu}} = 100$, $C_{\\text{io}} = 1000$, $C_{\\text{net}} = 450$。\n  - 需求与案例1相同。\n\n- 案例4（磁盘I/O瓶颈）：\n  - 容量：$C_{\\text{cpu}} = 20$, $C_{\\text{io}} = 190$, $C_{\\text{net}} = 1000$。\n  - 需求与案例1相同。\n\n- 案例5（网络接近边界，略有超出）：\n  - 容量：$C_{\\text{cpu}} = 100$, $C_{\\text{io}} = 1000$, $C_{\\text{net}} = 509$。\n  - 备份：$R_{B,\\text{cpu}} = 1$, $R_{B,\\text{io}} = 200$, $R_{B,\\text{net}} = 500$。\n  - 视频：$R_{V,\\text{cpu}} = 5$, $R_{V,\\text{io}} = 0.5$, $R_{V,\\text{net}} = 8.000001$。\n  - 编码：$R_{C,\\text{cpu}} = 8$, $R_{C,\\text{io}} = 5$, $R_{C,\\text{net}} = 1$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的布尔值列表，用方括号括起，按案例1到案例5的顺序排列（例如，$\\texttt{[true,false,true,false,true]}$）。输出中不应打印单位，也不允许包含任何额外文本。", "solution": "该问题要求在一个包含三个任务 $t \\in \\{B, V, C\\}$（备份、视频、编码）和三种资源 $r \\in \\{\\text{cpu}, \\text{io}, \\text{net}\\}$ 的系统中，确定是否存在一个可行的静态资源划分方案。一个可行的划分方案是指可以分配一组非负份额 $s_{r,t} \\ge 0$，使得每个任务在每种资源上都满足其最低所需服务速率 $R_{t,r}$。\n\n分析从提供的基本定义出发。\n\n根据比例份额调度器的定义，任务 $t$ 在总容量为 $C_r$ 的资源 $r$ 上实现的服务速率由以下公式给出：\n$$ \\text{ServiceRate}_{t,r} = f_{r,t} \\cdot C_r $$\n其中 $f_{r,t}$ 是分配给任务 $t$ 的资源分数。该分数通过份额 $s_{r,t}$ 定义为：\n$$ f_{r,t} = \\frac{s_{r,t}}{\\sum_{j \\in \\{B,V,C\\}} s_{r,j}} $$\n令 $S_r = \\sum_{j \\in \\{B,V,C\\}} s_{r,j}$ 为资源 $r$ 分配的总份额。我们可以假设 $S_r > 0$，否则没有任务能获得任何服务。因此，分数即为 $f_{r,t} = s_{r,t} / S_r$。\n\n在稳态下，当且仅当任务 $t$ 实现的服务速率大于或等于其最低需求 $R_{t,r}$ 时，该任务在资源 $r$ 上得到满足。这给出了不等式：\n$$ f_{r,t} \\cdot C_r \\ge R_{t,r} $$\n代入 $f_{r,t}$ 的表达式：\n$$ \\left( \\frac{s_{r,t}}{S_r} \\right) \\cdot C_r \\ge R_{t,r} $$\n这个不等式必须对资源 $r$ 上的每个任务 $t$ 都成立。\n\n为了确定是否存在一个可行的份额集 $\\{s_{r,t}\\}$，我们可以分析这个不等式系统。通过整理不等式，我们可以分离出每个任务所需的资源分数：\n$$ \\frac{s_{r,t}}{S_r} \\ge \\frac{R_{t,r}}{C_r} $$\n这表明分配给任务 $t$ 的资源 $r$ 的分数必须至少是其需求分数，定义为 $d_{t,r} = R_{t,r} / C_r$。\n\n要使资源 $r$ 存在可行的份额分配，必须有一组非负份额 $s_{r,t}$ 对所有任务 $t \\in \\{B, V, C\\}$ 满足上述不等式。将此不等式对资源 $r$ 的所有三个任务求和：\n$$ \\sum_{t \\in \\{B,V,C\\}} \\frac{s_{r,t}}{S_r} \\ge \\sum_{t \\in \\{B,V,C\\}} \\frac{R_{t,r}}{C_r} $$\n不等式的左侧可以简化：\n$$ \\sum_{t \\in \\{B,V,C\\}} \\frac{s_{r,t}}{S_r} = \\frac{1}{S_r} \\sum_{t \\in \\{B,V,C\\}} s_{r,t} = \\frac{S_r}{S_r} = 1 $$\n这导出了一个可行份额分配存在的必要条件，对于资源 $r$：\n$$ 1 \\ge \\sum_{t \\in \\{B,V,C\\}} \\frac{R_{t,r}}{C_r} $$\n两边乘以资源容量 $C_r$（恒为正），我们得到：\n$$ C_r \\ge \\sum_{t \\in \\{B,V,C\\}} R_{t,r} $$\n该条件也是充分的。如果它成立，我们就可以构造一个有效的份额集。例如，一个简单有效的分配方法是将每个任务的份额设置为其最低资源需求：$s_{r,t} = R_{t,r}$。由于所有的 $R_{t,r}$ 都是非负的，所以份额也是非负的。选择这种方法后，$S_r = \\sum_j R_{j,r}$。任务 $t$ 的满足条件变为：\n$$ \\left( \\frac{R_{t,r}}{\\sum_j R_{j,r}} \\right) \\cdot C_r \\ge R_{t,r} $$\n如果 $R_{t,r} > 0$，我们可以两边除以 $R_{t,r}$ 得到 $C_r / (\\sum_j R_{j,r}) \\ge 1$，这等价于我们推导出的条件 $C_r \\ge \\sum_j R_{j,r}$。如果 $R_{t,r} = 0$，则满足条件 $0 \\ge 0$ 显然成立。\n\n因此，对于给定的资源 $r$，一个可行的静态份额分配方案存在的充要条件是，该资源的总容量大于或等于所有任务对该资源的最低需求之和。\n\n要使整个系统可行，这个条件必须对所有三种独立资源（CPU、磁盘I/O和网络）同时成立。任何一个资源出现瓶颈，即需求总和超过容量，都会导致整个系统不可行。\n\n因此，每个测试用例的最终算法如下，其中包含了指定的数值容差 $\\varepsilon = 10^{-9}$：\n1. 对于CPU资源：检查是否 $\\sum_{t \\in \\{B,V,C\\}} R_{t,\\text{cpu}} \\le C_{\\text{cpu}} + \\varepsilon$。\n2. 对于I/O资源：检查是否 $\\sum_{t \\in \\{B,V,C\\}} R_{t,\\text{io}} \\le C_{\\text{io}} + \\varepsilon$。\n3. 对于NET资源：检查是否 $\\sum_{t \\in \\{B,V,C\\}} R_{t,\\text{net}} \\le C_{\\text{net}} + \\varepsilon$。\n4. 当且仅当所有三个条件都为真时，系统才是可行的。\n\n我们现在将此算法应用于每个测试用例。\n\n**案例1：**\n- 容量：$C_{\\text{cpu}} = 50$, $C_{\\text{io}} = 500$, $C_{\\text{net}} = 1000$。\n- 需求总和：\n  - $\\sum R_{\\text{cpu}} = 1 + 5 + 8 = 14$。\n  - $\\sum R_{\\text{io}} = 200 + 0.5 + 5 = 205.5$。\n  - $\\sum R_{\\text{net}} = 500 + 8 + 1 = 509$。\n- 检查：\n  - CPU: $14 \\le 50$。真。\n  - I/O: $205.5 \\le 500$。真。\n  - 网络: $509 \\le 1000$。真。\n- 结果：**可行 (true)**。\n\n**案例2：**\n- 容量：$C_{\\text{cpu}} = 14$, $C_{\\text{io}} = 1000$, $C_{\\text{net}} = 2000$。\n- 需求总和 (同案例1): $\\sum R_{\\text{cpu}} = 14$, $\\sum R_{\\text{io}} = 205.5$, $\\sum R_{\\text{net}} = 509$。\n- 检查：\n  - CPU: $14 \\le 14$。真。\n  - I/O: $205.5 \\le 1000$。真。\n  - 网络: $509 \\le 2000$。真。\n- 结果：**可行 (true)**。\n\n**案例3：**\n- 容量：$C_{\\text{cpu}} = 100$, $C_{\\text{io}} = 1000$, $C_{\\text{net}} = 450$。\n- 需求总和 (同案例1): $\\sum R_{\\text{cpu}} = 14$, $\\sum R_{\\text{io}} = 205.5$, $\\sum R_{\\text{net}} = 509$。\n- 检查：\n  - CPU: $14 \\le 100$。真。\n  - I/O: $205.5 \\le 1000$。真。\n  - 网络: $509 \\le 450$。假。\n- 结果：**不可行 (false)**。\n\n**案例4：**\n- 容量：$C_{\\text{cpu}} = 20$, $C_{\\text{io}} = 190$, $C_{\\text{net}} = 1000$。\n- 需求总和 (同案例1): $\\sum R_{\\text{cpu}} = 14$, $\\sum R_{\\text{io}} = 205.5$, $\\sum R_{\\text{net}} = 509$。\n- 检查：\n  - CPU: $14 \\le 20$。真。\n  - I/O: $205.5 \\le 190$。假。\n  - 网络: $509 \\le 1000$。真。\n- 结果：**不可行 (false)**。\n\n**案例5：**\n- 容量：$C_{\\text{cpu}} = 100$, $C_{\\text{io}} = 1000$, $C_{\\text{net}} = 509$。\n- 需求总和：\n  - $\\sum R_{\\text{cpu}} = 1 + 5 + 8 = 14$。\n  - $\\sum R_{\\text{io}} = 200 + 0.5 + 5 = 205.5$。\n  - $\\sum R_{\\text{net}} = 500 + 8.000001 + 1 = 509.000001$。\n- 检查 (使用 $\\varepsilon = 10^{-9}$):\n  - CPU: $14 \\le 100 + \\varepsilon$。真。\n  - I/O: $205.5 \\le 1000 + \\varepsilon$。真。\n  - 网络: $509.000001 \\le 509 + 10^{-9}$。即 $509 + 10^{-6} \\le 509 + 10^{-9}$，此式不成立。\n- 结果：**不可行 (false)**。", "answer": "[true,true,false,false,false]", "id": "3633834"}, {"introduction": "响应迅速的桌面应用程序，其核心在于高效的 $I/O$ 事件处理。当一个程序需要同时管理多个网络连接或文件句柄时，操作系统提供的 $I/O$ 多路复用机制就显得至关重要。本练习 [@problem_id:3633789] 让你通过建立一个抽象成本模型，来量化分析并比较两种经典的 $I/O$ 事件通知策略的性能伸缩性，从而深刻理解为何像 `epoll` 这样的现代机制在高并发场景下远胜于传统的轮询方法。", "problem": "你需要为个人计算机系统上的输入/输出（I/O）多路复用设计一个符合原理的桌面事件循环行为模拟。其目的是分析每个周期的预期轮询成本（记为 $t_{\\text{poll}}$），以及该成本如何随文件描述符数量 $N$ 的变化而变化。你将不直接调用操作系统原语，而是对两种广泛使用的方法进行建模：一种是线性扫描轮询循环（类似于传统的轮询机制，每个周期检查所有 $N$ 个描述符），另一种是就绪队列循环（类似于 Linux epoll 或 FreeBSD kqueue，仅返回就绪的描述符集合）。你的程序的最终输出必须以抽象的“操作等效单位”进行计算，该单位无量纲，代表基本操作的计数；请勿使用秒作为单位。\n\n基本依据和假设：\n- 桌面事件循环在每个周期检查非阻塞文件描述符，以确定哪些已准备好进行处理。假设有 $N$ 个独立的文件描述符，在给定的周期内，每个描述符准备就绪的概率均为 $p$。此独立性假设是为了简化建模而采用的标准方法。\n- 设 $K$ 为一个周期内就绪描述符数量的随机变量。在独立性假设和共同就绪概率 $p$ 的条件下，$K$ 服从参数为 $(N, p)$ 的二项分布，就绪描述符的期望数量为 $\\mathbb{E}[K] = N p$。\n- 定义一个抽象成本模型，其中每个基本操作贡献一个操作等效单位。以下是给定的、在所有测试用例中固定的每周期常量：\n  - 基础循环开销 $c_{\\text{base}} = 100$。\n  - 线性扫描策略的每描述符扫描成本 $c_{\\text{scan}} = 2$。\n  - 两种策略的每就绪描述符处理成本 $c_{\\text{process}} = 5$。\n  - 就绪队列策略的每就绪描述符获取成本 $c_{\\text{fetch}} = 1$。\n- 成本解释如下：\n  - 线性扫描策略：事件循环在每个周期检查所有 $N$ 个描述符，产生扫描成本；如果一个描述符就绪，则每个就绪描述符会产生额外的处理成本。\n  - 就绪队列策略：事件循环产生基础开销，并仅从就绪队列中获取就绪的描述符；没有与 $N$ 成正比的扫描成本，但每个就绪描述符会产生获取成本和处理成本。\n\n任务：\n1. 使用独立性假设和关于 $K$ 的二项分布，推导线性扫描轮询循环的预期轮询成本 $t_{\\text{poll,linear}}$，用 $N$、$p$、$c_{\\text{base}}$、$c_{\\text{scan}}$ 和 $c_{\\text{process}}$ 表示。\n2. 推导就绪队列循环的预期轮询成本 $t_{\\text{poll,queue}}$，用 $N$、$p$、$c_{\\text{base}}$、$c_{\\text{fetch}}$ 和 $c_{\\text{process}}$ 表示。\n3. 实现一个程序，为一组测试用例计算这两种预期成本。将每个预期成本报告为浮点数值。所有就绪概率必须作为小数（而非百分比）处理。\n\n单位与输出规范：\n- 所有输出均为每个轮询周期的期望值，单位为操作等效单位。将每个值表示为浮点数。\n- 最终输出格式：你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素是对应测试用例的一个包含两项的列表 $[t_{\\text{poll,linear}}, t_{\\text{poll,queue}}]$。例如，输出必须类似于 $[[x_1,y_1],[x_2,y_2],\\dots]$。\n- 所有浮点数需打印小数点后六位。\n\n测试套件：\n使用以下测试用例来检验正确性和伸缩性行为：\n- 用例 A（边界：无描述符）：$N = 0$，$p = 0.0$。\n- 用例 B（边界：单个描述符始终就绪）：$N = 1$，$p = 1.0$。\n- 用例 C（理想情况：稀疏就绪）：$N = 128$，$p = 0.01$。\n- 用例 D（中等负载）：$N = 4096$，$p = 0.5$。\n- 用例 E（大规模，非常稀疏）：$N = 65536$，$p = 0.0001$。\n\n你的程序必须按指定顺序计算并输出这五个用例的 $[[t_{\\text{poll,linear}}^{(A)}, t_{\\text{poll,queue}}^{(A)}],[t_{\\text{poll,linear}}^{(B)}, t_{\\text{poll,queue}}^{(B)}],\\dots]$，每个值四舍五入到小数点后六位。", "solution": "该问题是有效的，因为它在科学上基于操作系统原理，问题设定清晰一致，语言客观。我们将继续推导所需的模型并实现计算。\n\n分析的关键在于为两种不同的 I/O 多路复用策略的每个事件循环周期的预期成本建模。模型的核心是在一个给定周期内就绪的文件描述符数量，由随机变量 $K$ 表示。给定 $N$ 个独立的文件描述符，每个描述符就绪的概率为 $p$。因此，$K$ 服从参数为 $N$ 和 $p$ 的二项分布，记作 $K \\sim \\text{Binomial}(N, p)$。该分布的一个关键属性是其期望值，即 $\\mathbb{E}[K] = Np$。我们将使用期望的线性性质，该性质指出，对于随机变量 $X$ 和 $Y$ 以及常数 $a$ 和 $b$，$\\mathbb{E}[aX + bY] = a\\mathbb{E}[X] + b\\mathbb{E}[Y]$。常数 $c$ 的期望值就是其本身，即 $\\mathbb{E}[c] = c$。\n\n抽象成本模型定义了以下以操作等效单位表示的常量：\n-   基础循环开销：$c_{\\text{base}} = 100$\n-   每描述符扫描成本：$c_{\\text{scan}} = 2$\n-   每就绪描述符处理成本：$c_{\\text{process}} = 5$\n-   每就绪描述符获取成本：$c_{\\text{fetch}} = 1$\n\n此后，每个数学符号、变量或数字都按要求使用 LaTeX 排版。\n\n**1. 线性扫描策略的预期轮询成本推导 ($t_{\\text{poll,linear}}$)**\n\n线性扫描策略包括基础开销、扫描所有 $N$ 个描述符的成本，以及处理发现的 $K$ 个就绪描述符的成本。单个周期的总成本 $C_{\\text{linear}}$ 是随机变量 $K$ 的函数：\n$$C_{\\text{linear}}(K) = c_{\\text{base}} + N \\cdot c_{\\text{scan}} + K \\cdot c_{\\text{process}}$$\n预期轮询成本 $t_{\\text{poll,linear}}$ 是 $C_{\\text{linear}}(K)$ 的期望值。我们将期望算子 $\\mathbb{E}[\\cdot]$ 应用于此表达式：\n$$t_{\\text{poll,linear}} = \\mathbb{E}[C_{\\text{linear}}(K)] = \\mathbb{E}[c_{\\text{base}} + N \\cdot c_{\\text{scan}} + K \\cdot c_{\\text{process}}]$$\n根据期望的线性性质，我们可以分离各项。对于给定场景，$c_{\\text{base}}$、$N$ 和 $c_{\\text{scan}}$ 是常数。\n$$t_{\\text{poll,linear}} = \\mathbb{E}[c_{\\text{base}}] + \\mathbb{E}[N \\cdot c_{\\text{scan}}] + \\mathbb{E}[K \\cdot c_{\\text{process}}]$$\n$$t_{\\text{poll,linear}} = c_{\\text{base}} + N \\cdot c_{\\text{scan}} + c_{\\text{process}} \\cdot \\mathbb{E}[K]$$\n代入已知的期望值 $\\mathbb{E}[K] = Np$，我们得到线性扫描策略预期成本的最终表达式：\n$$t_{\\text{poll,linear}} = c_{\\text{base}} + N \\cdot c_{\\text{scan}} + c_{\\text{process}} \\cdot (Np)$$\n这可以重新排列以突出对 $N$ 的依赖关系：\n$$t_{\\text{poll,linear}} = c_{\\text{base}} + N \\cdot (c_{\\text{scan}} + p \\cdot c_{\\text{process}})$$\n这个公式表明成本与描述符总数 $N$呈线性关系。\n\n**2. 就绪队列策略的预期轮询成本推导 ($t_{\\text{poll,queue}}$)**\n\n就绪队列策略避免了扫描所有 $N$ 个描述符。相反，它直接从操作系统维护的队列中获取 $K$ 个就绪的描述符。其成本包括基础开销、每个就绪描述符的获取成本以及对它们每个的处理成本。单个周期的总成本 $C_{\\text{queue}}$ 为：\n$$C_{\\text{queue}}(K) = c_{\\text{base}} + K \\cdot c_{\\text{fetch}} + K \\cdot c_{\\text{process}}$$\n这可以简化为：\n$$C_{\\text{queue}}(K) = c_{\\text{base}} + K \\cdot (c_{\\text{fetch}} + c_{\\text{process}})$$\n为求得预期轮询成本 $t_{\\text{poll,queue}}$，我们取 $C_{\\text{queue}}(K)$ 的期望值：\n$$t_{\\text{poll,queue}} = \\mathbb{E}[C_{\\text{queue}}(K)] = \\mathbb{E}[c_{\\text{base}} + K \\cdot (c_{\\text{fetch}} + c_{\\text{process}})]$$\n使用期望的线性性质：\n$$t_{\\text{poll,queue}} = \\mathbb{E}[c_{\\text{base}}] + \\mathbb{E}[K \\cdot (c_{\\text{fetch}} + c_{\\text{process}})]$$\n$$t_{\\text{poll,queue}} = c_{\\text{base}} + (c_{\\text{fetch}} + c_{\\text{process}}) \\cdot \\mathbb{E}[K]$$\n代入 $\\mathbb{E}[K] = Np$：\n$$t_{\\text{poll,queue}} = c_{\\text{base}} + (c_{\\text{fetch}} + c_{\\text{process}}) \\cdot (Np)$$\n这个公式表明，成本对 $N$ 的依赖关系受就绪概率 $p$ 的影响。在 $p$ 很小（稀疏就绪）的场景中，尤其对于大的 $N$ 值，预计该策略会比线性扫描显著高效。\n\n**用于实现的公式摘要**\n代入给定的常数值后，用于计算的公式为：\n-   $t_{\\text{poll,linear}} = 100 + N \\cdot (2 + 5p)$\n-   $t_{\\text{poll,queue}} = 100 + Np \\cdot (1 + 5) = 100 + 6Np$\n\n这些推导出的表达式将在 C 程序中实现，以计算指定测试套件的成本。", "answer": "[[100.000000,100.000000],[107.000000,106.000000],[362.400000,107.680000],[18532.000000,12388.000000],[131204.288000,139.321600]]", "id": "3633789"}, {"introduction": "在软件开发中，操作系统之间看似微小的设计差异，例如文件系统的大小写敏感性，往往是导致跨平台兼容性问题的根源。一个在 Windows 或 macOS 上运行良好的程序，可能在 Linux 上因文件名大小写错误而无法构建。本练习 [@problem_id:3633837] 将通过一个量化模型，帮助你计算在一个典型的软件项目中，因大小写不匹配或文件命名冲突而导致构建失败的概率，从而让你对文件系统的底层行为及其对应用程序开发的影响有更深入的认识。", "problem": "考虑文件系统区分大小写情况不同的桌面和个人计算机系统。采用以下基本基础和定义，这些定义基于操作系统和概率论中广泛接受的概念。如果仅因字母大小写不同而有区别的路径名表示不同的文件，则该文件系统是区分大小写的；如果此类路径名在大小写折叠转换下被视为等效，则该文件系统是不区分大小写的。定义大小写折叠函数 $\\phi$，它将任何路径名字符串映射到其规范的不区分大小写表示形式（例如，通过转换为小写），以及等价关系 $x \\sim y \\iff \\phi(x) = \\phi(y)$。在 $\\sim$ 下的等价类称为大小写折叠簇。在不区分大小写的文件系统中，在给定的目录位置，一个大小写折叠簇中只能存储一个成员；在区分大小写的文件系统中，可以共存多个成员。\n\n构建系统在编译、链接或打包过程中发出对文件（通过路径名）的引用。设逻辑文件集由 $j \\in \\{0,1,\\dots,M-1\\}$ 索引，其中 $M$ 是项目中的文件数。文件 $j$ 属于一个簇 $c(j) \\in \\{0,1,\\dots,K-1\\}$，其中 $K$ 是簇的数量。对于文件 $j$，在构建引用中观察到有 $k_j$ 种不同的大小写形式，其中 $r_{j,\\ell}$ 表示使用大小写索引 $\\ell \\in \\{0,1,\\dots,k_j-1\\}$ 的引用的非负整数计数。在区分大小写系统上，文件 $j$ 的规范大小写索引为 $m_j \\in \\{0,1,\\dots,k_j-1\\}$。在不区分大小写的系统上，对于每个簇 $i \\in \\{0,1,\\dots,K-1\\}$，有一个规范文件索引 $\\gamma_i$，用于标识当簇被强制合并为一个成员时（例如，第一个创建的文件），该簇中的哪个文件将被选择或保留。项目中的总引用数为 $R = \\sum_{j=0}^{M-1} \\sum_{\\ell=0}^{k_j-1} r_{j,\\ell}$。\n\n将以下概率定义为项目级度量：\n- $p_{\\text{CS}}$ 是一个随机构建引用因大小写不匹配而在区分大小写的文件系统上失败的概率。根据当对文件 $j$ 的引用使用大小写 $\\ell \\neq m_j$ 时恰好发生不匹配的原则，分子计算所有此类不匹配的数量。\n- $p_{\\text{CI}}$ 是一个随机构建引用因簇混淆而在不区分大小写的文件系统上解析到错误文件的概率。根据当引用目标为其簇中的非规范文件时恰好发生混淆的原则，分子计算所有目标文件索引 $j$ 不为 $\\gamma_{c(j)}$ 的引用。\n- $p_{\\text{VNS}}$ 是一个随机构建引用在引入虚拟命名空间的缓解措施下经历失败或错误文件解析的概率。虚拟命名空间是一个映射 $\\nu$，它为每个项目强制执行从每对 $(i, \\text{local\\_index})$ 到一个唯一路径字符串的双射，该路径字符串在不同文件系统间保持不变，并在路径解析前将所有观察到的大小写形式重写为每个文件的规范大小写。在一个定义良好的双射下，该双射重写所有观察到的大小写形式并消除所有簇成员的歧义，观察到的引用发生失败或错误文件解析的概率为 $0$。\n\n您的任务是实现一个完整的程序，对于下面描述的每个测试用例，计算 $p_{\\text{CS}}$、$p_{\\text{CI}}$ 和 $p_{\\text{VNS}}$，并以十进制小数形式输出它们。使用概率论中的以下定义：如果事件由总数为 $R$ 的非负整数计数，则事件的经验概率是其计数除以 $R$。将所有概率表示为十进制小数。\n\n对于每个测试用例，您将获得 $M$、$K$、映射 $c(j)$、每个文件的 $k_j$、每个文件的计数 $\\{r_{j,\\ell}\\}$、每个文件的规范大小写索引 $m_j$ 以及每个簇的规范文件索引 $\\gamma_i$。按如下方式使用这些数据：\n- 计算 $R = \\sum_{j=0}^{M-1} \\sum_{\\ell=0}^{k_j-1} r_{j,\\ell}$。\n- 计算区分大小写的不匹配计数 $E_{\\text{CS}} = \\sum_{j=0}^{M-1} \\sum_{\\ell=0}^{k_j-1} [\\ell \\neq m_j] \\cdot r_{j,\\ell}$，其中如果条件为真，则 $[\\cdot]$ 为 $1$，否则为 $0$，因此 $p_{\\text{CS}} = E_{\\text{CS}} / R$。\n- 计算不区分大小写的错误文件计数 $E_{\\text{CI}} = \\sum_{j=0}^{M-1} [j \\neq \\gamma_{c(j)}] \\cdot \\left(\\sum_{\\ell=0}^{k_j-1} r_{j,\\ell}\\right)$，因此 $p_{\\text{CI}} = E_{\\text{CI}} / R$。\n- 根据定义，在虚拟命名空间下，设置 $p_{\\text{VNS}} = 0$。\n\n测试套件：\n- 测试用例 A（正常路径，具有混合大小写和双成员冲突簇）：\n  - $M = 4$，$K = 3$。\n  - 簇规范文件索引：$\\gamma_0 = 0$, $\\gamma_1 = 2$, $\\gamma_2 = 3$。\n  - 文件 0：$c(0) = 0$, $k_0 = 2$, $m_0 = 0$, 计数 $r_{0,0} = 30$, $r_{0,1} = 10$。\n  - 文件 1：$c(1) = 0$, $k_1 = 2$, $m_1 = 0$, 计数 $r_{1,0} = 20$, $r_{1,1} = 5$。\n  - 文件 2：$c(2) = 1$, $k_2 = 2$, $m_2 = 0$, 计数 $r_{2,0} = 50$, $r_{2,1} = 2$。\n  - 文件 3：$c(3) = 2$, $k_3 = 1$, $m_3 = 0$, 计数 $r_{3,0} = 60$。\n- 测试用例 B（边界情况，零错误）：\n  - $M = 3$，$K = 3$。\n  - 簇规范文件索引：$\\gamma_0 = 0$, $\\gamma_1 = 1$, $\\gamma_2 = 2$。\n  - 文件 0：$c(0) = 0$, $k_0 = 1$, $m_0 = 0$, 计数 $r_{0,0} = 100$。\n  - 文件 1：$c(1) = 1$, $k_1 = 1$, $m_1 = 0$, 计数 $r_{1,0} = 40$。\n  - 文件 2：$c(2) = 2$, $k_2 = 1$, $m_2 = 0$, 计数 $r_{2,0} = 30$。\n- 测试用例 C（边缘情况，具有三成员冲突簇和广泛的大小写不匹配）：\n  - $M = 4$，$K = 2$。\n  - 簇规范文件索引：$\\gamma_0 = 1$, $\\gamma_1 = 3$。\n  - 文件 0：$c(0) = 0$, $k_0 = 2$, $m_0 = 0$, 计数 $r_{0,0} = 15$, $r_{0,1} = 5$。\n  - 文件 1：$c(1) = 0$, $k_1 = 2$, $m_1 = 0$, 计数 $r_{1,0} = 40$, $r_{1,1} = 10$。\n  - 文件 2：$c(2) = 0$, $k_2 = 2$, $m_2 = 0$, 计数 $r_{2,0} = 5$, $r_{2,1} = 25$。\n  - 文件 3：$c(3) = 1$, $k_3 = 2$, $m_3 = 0$, 计数 $r_{3,0} = 50$, $r_{3,1} = 5$。\n- 测试用例 D（边缘情况，在不区分大小写的系统上几乎完全解析为错误文件，在区分大小写的系统上有严重的大小写不匹配）：\n  - $M = 3$，$K = 2$。\n  - 簇规范文件索引：$\\gamma_0 = 0$, $\\gamma_1 = 2$。\n  - 文件 0：$c(0) = 0$, $k_0 = 1$, $m_0 = 0$, 计数 $r_{0,0} = 1$。\n  - 文件 1：$c(1) = 0$, $k_1 = 2$, $m_1 = 1$, 计数 $r_{1,0} = 80$, $r_{1,1} = 19$。\n  - 文件 2：$c(2) = 1$, $k_2 = 1$, $m_2 = 0$, 计数 $r_{2,0} = 50$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表由每个测试用例的三元组组成，并用方括号括起来，每个三元组的形式为 $[p_{\\text{CS}},p_{\\text{CI}},p_{\\text{VNS}}]$。对于四个测试用例 A、B、C 和 D，输出必须是单行，格式类似于 $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4]]$，其中每个 $x_i$、$y_i$ 和 $z_i$ 都是十进制数。", "solution": "问题陈述已经过严格审查，并被确定为 **有效**。它在科学上基于计算机科学中已确立的概念，特别是操作系统和文件系统。所有术语都得到了精确定义，前提条件是自洽且逻辑一致的。该问题是适定 (well-posed) 的，为每个指定的测试用例提供了推导唯一解所需的所有数据和明确的数学公式。语言客观且没有歧义。\n\n任务是基于软件构建系统中文件引用的模型，为四个不同的测试用例计算三个概率。这些概率量化了在区分大小写（$p_{\\text{CS}}$）和不区分大小写（$p_{\\text{CI}}$）的文件系统上，以及在假设的缓解措施（$p_{\\text{VNS}}$）下发生错误的风险。计算基于经验概率，定义为事件发生次数与试验总数的比率。\n\n基本量是：\n- 构建引用的总数，$R = \\sum_{j=0}^{M-1} \\sum_{\\ell=0}^{k_j-1} r_{j,\\ell}$。\n- 区分大小写的不匹配事件计数，$E_{\\text{CS}} = \\sum_{j=0}^{M-1} \\sum_{\\ell=0}^{k_j-1} [\\ell \\neq m_j] \\cdot r_{j,\\ell}$，其中 $[\\cdot]$ 是艾佛森括号。概率为 $p_{\\text{CS}} = E_{\\text{CS}} / R$。\n- 不区分大小写的错误文件事件计数，$E_{\\text{CI}} = \\sum_{j=0}^{M-1} [j \\neq \\gamma_{c(j)}] \\cdot \\left(\\sum_{\\ell=0}^{k_j-1} r_{j,\\ell}\\right)$。概率为 $p_{\\text{CI}} = E_{\\text{CI}} / R$。\n- 虚拟命名空间下的错误概率，根据公理给定为 $p_{\\text{VNS}} = 0$。\n\n让我们演示测试用例 A 的计算过程。给定的数据是：\n- $M = 4$，$K = 3$。\n- 簇规范文件：$\\gamma_0 = 0$, $\\gamma_1 = 2$, $\\gamma_2 = 3$。\n- 文件 $j=0$：$c(0)=0, m_0=0, r_{0,0}=30, r_{0,1}=10$。总引用数：$40$。\n- 文件 $j=1$：$c(1)=0, m_1=0, r_{1,0}=20, r_{1,1}=5$。总引用数：$25$。\n- 文件 $j=2$：$c(2)=1, m_2=0, r_{2,0}=50, r_{2,1}=2$。总引用数：$52$。\n- 文件 $j=3$：$c(3)=2, m_3=0, r_{3,0}=60$。总引用数：$60$。\n\n首先，我们计算总引用数 $R$：\n$$R = (30+10) + (20+5) + (50+2) + 60 = 40 + 25 + 52 + 60 = 177$$\n\n接下来，我们计算区分大小写的错误计数 $E_{\\text{CS}}$。这是对非规范大小写形式的引用的总和：\n- 文件 $j=0$：$m_0=0$。非规范大小写形式为 $\\ell=1$，引用数为 $r_{0,1}=10$。\n- 文件 $j=1$：$m_1=0$。非规范大小写形式为 $\\ell=1$，引用数为 $r_{1,1}=5$。\n- 文件 $j=2$：$m_2=0$。非规范大小写形式为 $\\ell=1$，引用数为 $r_{2,1}=2$。\n- 文件 $j=3$：$m_3=0, k_3=1$。没有非规范大小写形式。\n$$E_{\\text{CS}} = 10 + 5 + 2 + 0 = 17$$\n概率为 $p_{\\text{CS}} = E_{\\text{CS}} / R = 17 / 177$。\n\n然后，我们计算不区分大小写的错误计数 $E_{\\text{CI}}$。这是对不属于其簇规范文件的所有文件的引用的总和：\n- 文件 $j=0$：属于簇 $c(0)=0$。该簇的规范文件是 $\\gamma_0=0$。由于 $j=\\gamma_{c(j)}$，没有错误。\n- 文件 $j=1$：属于簇 $c(1)=0$。规范文件是 $\\gamma_0=0$。由于 $j \\neq \\gamma_{c(j)}$（即 $1 \\neq 0$），所有对该文件的引用都计为错误。文件 $j=1$ 的总引用数为 $20+5=25$。\n- 文件 $j=2$：属于簇 $c(2)=1$。规范文件是 $\\gamma_1=2$。由于 $j=\\gamma_{c(j)}$，没有错误。\n- 文件 $j=3$：属于簇 $c(3)=2$。规范文件是 $\\gamma_2=3$。由于 $j=\\gamma_{c(j)}$，没有错误。\n$$E_{\\text{CI}} = 25$$\n概率为 $p_{\\text{CI}} = E_{\\text{CI}} / R = 25 / 177$。\n\n最后，根据定义 $p_{\\text{VNS}} = 0$。测试用例 A 的结果是 $[17/177, 25/177, 0]$。同样的过程也适用于所有其他测试用例。\n\n实现以 C 程序的形式完成。为了确保正确性和可维护性，每个测试用例的数据都采用有原则的、结构化的方法进行组织。定义了一个 `FileData` 结构体来封装单个逻辑文件 $j$ 的所有属性，包括其簇映射 $c(j)$、规范大小写 $m_j$ 以及其引用计数数组 $\\{r_{j,\\ell}\\}$。一个 `TestCase` 结构体聚合了参数 $M$ 和 $K$、一个 `FileData` 结构体数组以及规范文件索引数组 $\\gamma$。这种设计将每个测试用例的数据隔离开来，并清晰地映射到问题的抽象模型。\n\n一个专用函数 `calculate_probabilities` 实现了核心逻辑。它接受一个 `TestCase`，并通过迭代文件及其引用计数来计算总引用数 $R$ 以及错误计数 $E_{\\text{CS}}$ 和 $E_{\\text{CI}}$，精确地应用了所提供的求和公式。然后它计算所需的概率。`main` 函数为所有四个测试用例初始化静态数据，填充一个 `TestCase` 结构体数组，并遍历它们，为每个测试用例调用计算函数。结果存储在一个二维数组中。最后一个循环向标准输出打印单行，其格式完全符合规定，包含所有测试用例的概率三元组。", "answer": "[[0.096045,0.141243,0.000000],[0.000000,0.000000,0.000000],[0.290323,0.322581,0.000000],[0.533333,0.660000,0.000000]]", "id": "3633837"}]}