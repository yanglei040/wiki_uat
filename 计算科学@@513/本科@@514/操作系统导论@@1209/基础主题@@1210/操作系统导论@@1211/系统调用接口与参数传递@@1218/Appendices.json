{"hands_on_practices": [{"introduction": "系统调用并非总是能一次性完成所有请求的工作，尤其是在处理流式数据（如管道或套接字）时。这个练习模拟了一个常见场景：`write` 系统调用只成功写入了部分数据。通过这个练习，你将实践如何正确解读系统调用的返回值，并相应地调整后续调用的参数，以确保数据的完整传输，这是编写健壮的系统级程序的基本功。[@problem_id:3686250]", "problem": "一个符合可移植操作系统接口（POSIX）的系统上的用户空间程序，发出 write 系统调用，将内存缓冲区中的连续消息传输到文件描述符。在一个广泛使用的64位架构上，其通行的应用程序二进制接口（ABI）上的系统调用接口传递参数的方式是，将缓冲区指针和字节数分别作为第二个和第三个参数提供。操作系统内核可以合法地完成比请求少的字节数，并返回实际写入的字节数作为一个非负值。\n\n从以下核心定义出发：(i) write 系统调用返回实际写入的字节数；(ii) 对元素类型为字符的字节可寻址缓冲区进行指针算术运算时，每增加一个单位，指针前进一个字节。推导在部分成功的情况下，如何调整下一次 write 系统调用的参数，以避免重新发送已写入的字节。\n\n具体来说，假设程序最初传递缓冲区指针 $p = 0x7\\mathrm{fff}00001000$ 和长度 $n = 4096$ 字节给 write，内核返回 $k = 1723$，$0  k  n$。对于旨在仅传输剩余字节的后续 write 系统调用，计算应分别放入缓冲区指针寄存器和长度寄存器的两个参数值，表示为精确整数。将你的最终答案以单行矩阵的形式给出，其中包含更新后的缓冲区指针和更新后的长度，两个条目都需精确写出。最终答案中不需要四舍五入，也不需要单位。", "solution": "用户空间程序的目标是从起始地址为 $p$ 的内存缓冲区中写入总共 $n$ 个字节。`write` 系统调用使用这些参数被调用。系统调用返回一个值 $k$，表示缓冲区中只有前 $k$ 个字节被成功写入。这种情况，$0 \\le k  n$，被称为部分写入或短写入，是该系统调用的一个标准、有文档记载的行为，尤其是在向管道、套接字或空间有限的磁盘等实体写入时。\n\n为完成数据传输，程序必须发出一个或多个后续的 `write` 调用来传输剩余的数据。问题要求的是紧接着下一次调用的正确参数，该调用应尝试发送第一次尝试中未发送的数据部分。\n\n设初始缓冲区指针为 $p$，初始要写入的字节数为 $n$。给定值为：\n- $p = 0x7\\mathrm{fff}00001000$（一个用十六进制表示的64位内存地址）\n- $n = 4096$ 字节\n系统调用返回 $k = 1723$，表示写入了 $1723$ 个字节。由于 $0  1723  4096$，这是一次部分写入。\n\n缓冲区的前 $k$ 个字节，位于内存地址从 $p$ 到 $p + k - 1$ 的范围内，已被成功传输。剩余数据由从偏移量 $k$ 开始到原始缓冲区末尾的字节组成。\n\n任务是确定后续 `write` 调用的新缓冲区指针 $p'$ 和新长度 $n'$。\n\n1.  **计算新的缓冲区指针 ($p'$)**：\n    剩余数据段紧接着已写入的前 $k$ 个字节开始。因此，该段的起始地址距离原始起始地址 $p$ 有一个 $k$ 字节的偏移量。\n    问题陈述中提到“对字节可寻址缓冲区进行指针算术运算时...每增加一个单位，指针前进一个字节”。这正式化了类C语言中对字符类型指针（例如 `char*`）或空指针 (`void*`）进行指针算术运算的标准行为，这些指针通常用于原始内存缓冲区。将一个整数 $k$ 加到这样一个指针上，会得到一个在内存中偏移了 $k$ 个字节的新指针。\n    因此，新的缓冲区指针 $p'$ 计算如下：\n    $$p' = p + k$$\n    给定 $p = 0x7\\mathrm{fff}00001000$ 和 $k = 1723$。必须执行加法运算。在系统编程中，通常用十六进制表示内存地址并在此基数上进行算术运算。为此，我们首先将十进制整数 $k$ 转换为其十六进制等价值。\n    - $1723 \\div 16 = 107$，余数为 $11$（即 $\\mathrm{B}_{16}$）。\n    - $107 \\div 16 = 6$，余数为 $11$（即 $\\mathrm{B}_{16}$）。\n    - $6 \\div 16 = 0$，余数为 $6$。\n    按计算的逆序读取余数，得到 $1723_{10} = 6\\mathrm{BB}_{16}$。\n    现在，我们执行十六进制加法：\n    $$p' = 0x7\\mathrm{fff}00001000_{16} + 6\\mathrm{BB}_{16} = 0x7\\mathrm{fff}000016\\mathrm{BB}_{16}$$\n    所以，更新后的缓冲区指针参数是 $0x7\\mathrm{fff}000016\\mathrm{BB}$。\n\n2.  **计算新的长度 ($n'$)**：\n    原始请求是写入 $n$ 个字节。由于已经写入了 $k$ 个字节，剩余待写入的字节数是原始总量减去已完成的数量。\n    因此，新的长度 $n'$ 是：\n    $$n' = n - k$$\n    代入给定值：\n    $$n' = 4096 - 1723 = 2373$$\n    更新后的长度参数是 $2373$ 字节。\n\n总之，为了后续调用 `write` 来传输消息的剩余部分，程序应使用缓冲区指针 $p' = 0x7\\mathrm{fff}000016\\mathrm{BB}$ 和长度 $n' = 2373$。这两个值将根据系统的ABI放入相应的寄存器中。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0x7\\mathrm{fff}000016\\mathrm{BB}  2373\n\\end{pmatrix}\n}\n$$", "id": "3686250"}, {"introduction": "操作系统内核必须将用户空间视为不可信的环境，并对所有传入的参数进行严格的验证。这个练习聚焦于一个核心的安全问题：如何验证用户提供的内存地址和长度，以防止整数溢出攻击。这种攻击可能导致内核访问非预期的内存区域，从而引发严重的安全漏洞。通过分析不同的验证策略，你将深入理解内核在保护自身时所采用的防御性编程原则。[@problem_id:3686254]", "problem": "一个操作系统内核实现了一个系统调用，该调用接受一个用户空间指针和一个长度，表示为数对 $\\big(addr, len\\big)$。内核必须在调用诸如 copyin 之类的用户到内核复制例程之前验证参数，以确保整个半开区间 $\\big[addr, addr + len\\big)$ 位于允许的用户空间区域内。假设以下基本前提：\n\n- 地址和长度表示为无符号 $n$ 位整数，算术运算在模 $2^n$ 下进行。\n- 允许的用户空间区域是半开区间 $\\big[0, L\\big)$，其中 $L$ 是一个实现定义的限制，满足 $0  L \\le 2^n$。\n- 内核必须拒绝任何使得 $\\big[addr, addr + len\\big)$ 不为 $\\big[0, L\\big)$ 子集的输入，包括 $addr + len$ 在模 $2^n$ 下发生回绕的情况。\n\n考虑一个场景，在一个 $n = 64$ 的架构上，$L$ 是 $[0, 2^{64})$ 的一个真子集，一个恶意用户传递了一个接近 $2^{64} - 1$ 的 $addr$ 和一个非零的 $len$，使得计算出的 $addr + len$ 在模 $2^{64}$ 下回绕成一个较小的值。内核寻求一种可证明为健全的验证策略：它必须在调用 copyin 之前检测到计算 $addr + len$ 时的任何整数溢出，并拒绝任何超出用户空间边界的区间。\n\n在所述模型下，以下哪种验证策略是健全的？选择所有适用的选项。\n\nA. 如果 $addr  L$ 且 $len \\le L - addr$，则接受。\n\nB. 如果 $addr  L$ 且 $(addr + len) \\le L$，则接受，其中加法是在无符号 $n$ 位算术（模 $2^n$）下计算的。\n\nC. 如果 $addr  L$，则以无符号 $n$ 位算术（模 $2^n$）计算 $end = addr + len$；若 $end  addr$ 则拒绝；否则，当且仅当 $end \\le L$ 时接受。\n\nD. 将 $addr$ 和 $len$ 转换为有符号 $n$ 位整数，如果使用有符号算术运算满足 $(addr + len) \\ge addr$ 且 $(addr + len) \\le L$，则接受。\n\nE. 将 $addr$ 和 $len$ 提升为宽度为 $n' \\ge n + 1$ 位的更宽的无符号整数类型，在该更宽的类型中计算 $end = addr + len$（无回绕），并且仅当 $addr  L$ 且 $end \\le L$ 时接受。", "solution": "问题的核心是设计一种验证策略，以确保用户提供的由起始地址 `addr` 和长度 `len` 表示的内存区间完全包含在允许的用户空间内存区域内。该区域是半开区间 $\\big[0, L\\big)$，其中 $L$ 是一个预定义的限制。`addr` 和 `len` 都是无符号 $n$ 位整数，其算术运算在模 $2^n$ 下进行。验证必须对整数溢出具有鲁棒性，当恶意用户提供一个大的 `addr` 和一个 `len`，导致其和 `addr + len` 在 $n$ 位地址空间中“回绕”时，就可能发生整数溢出。\n\n一个健全的验证策略必须确保区间 $\\big[addr, addr + len\\big)$ 是 $\\big[0, L\\big)$ 的子集。考虑到 `addr` 和 `len` 是非负的，这可以分解为三个充分必要条件：\n1.  区间的起始点必须在有效区域内：$addr \\ge 0$ 且 $addr  L$。由于 `addr` 是一个无符号整数，第一部分（$addr \\ge 0$）恒为真。因此，该条件为 $addr  L$。\n2.  区间终点 $addr + len$ 的计算不得导致整数溢出（回绕）。在 $n$ 位无符号算术中，这意味着数学和必须小于 $2^n$。一个等效的检查是，$n$ 位加法的结果不小于起始地址，即 $addr + len \\ge addr$（对于非零的 $len$）。如果 $len=0$，该条件也成立。\n3.  区间的末端不得超过边界 $L$。该区间是 $\\big[addr, addr + len\\big)$，因此访问的最高内存地址是 $addr + len - 1$。为使其小于 $L$，我们必须有 $addr + len \\le L$。\n\n综合这些条件，一个健全的策略必须正确验证：\n- $addr  L$\n- 和 $addr + len$ 没有溢出\n- $addr + len \\le L$\n\n现在我们将根据这些原则评估每个选项。让 `+_n` 表示无符号 $n$ 位加法。\n\nA. **如果 $addr  L$ 且 $len \\le L - addr$，则接受。**\n该策略包含两个检查。\n- 第一个检查 $addr  L$ 正确地验证了起始地址在允许的用户区域内。\n- 第二个检查是 $len \\le L - addr$。这个数学不等式是使用 $n$ 位无符号算术执行的。第一个检查 $addr  L$ 确保了减法 $L - addr$ 不会下溢（或“借位”）。因此，$L - addr$ 的机器计算得出正确的数学结果。\n不等式 $len \\le L - addr$ 在数学上等价于 $addr + len \\le L$。这一个检查巧妙地结合了溢出检查和边界检查。\n让我们分析为什么它能正确检测到溢出。如果发生溢出，那么数学和 $addr + len \\ge 2^n$。问题陈述 `L` 是 $n=64$ 时的一个真子集的一部分，所以 $L  2^n$。在一般情况下，$L \\le 2^n$。如果发生溢出，则真实和 $addr+len \\ge 2^n$。因为 $L \\le 2^n$，这意味着对于任何小的 epsilon，$addr + len > L - \\epsilon$，除非 $L=2^n$ 且 $addr+len=2^n$。\n更正式地：如果发生溢出，真实和 $addr+len \\ge 2^n$。这意味着 $len \\ge 2^n - addr$。被检查的条件是 $len \\le L - addr$。我们知道 $L \\le 2^n$，因此 $L - addr \\le 2^n - addr$。如果 $L  2^n$，那么 $L - addr  2^n - addr$。在这种情况下，溢出意味着 $len \\ge 2^n - addr > L-addr$，所以检查 $len \\le L-addr$ 将会失败。如果 $L=2^n$，溢出意味着 $len \\ge 2^n-addr$。检查是 $len \\le 2^n-addr$。所以如果 $len > 2^n-addr$，它会失败。如果 $len = 2^n-addr$，检查通过，`end` 地址是 $2^n$，区间 $\\big[addr, 2^n\\big)$ 在 $\\big[0, 2^n\\big)$ 内是有效的。这种方法是健全的。它通过重新整理表达式来避免计算可能溢出的和 $addr + len$。\n结论：**正确**。\n\nB. **如果 $addr  L$ 且 $(addr + len) \\le L$，则接受，其中加法是在无符号 $n$ 位算术（模 $2^n$）下计算的。**\n这是一个不健全检查的典型例子。\n- 检查 $addr  L$ 是正确的。\n- 检查 $(addr +_n len) \\le L$ 是有缺陷的。\n让我们使用问题描述中的恶意用户场景。对于 $n=64$，设 $L = 2^{64}-5$，这是一个有效的限制。让用户提供 $addr = 2^{64} - 10$ 和 $len = 20$。\n1.  检查 $addr  L$：$2^{64} - 10  2^{64} - 5$。这为真。\n2.  计算和：$(2^{64} - 10) +_n 20$。数学和是 $2^{64} + 10$。模 $2^{64}$ 后，它回绕为值 $10$。\n3.  检查 $(addr +_n len) \\le L$：$10 \\le 2^{64} - 5$。这也为真。\n该策略接受了输入。然而，实际请求的内存范围从 $addr$ 延伸到地址空间的末尾，并回绕到开头：$\\big[2^{64}-10, 2^{64}\\big) \\cup \\big[0, 10\\big)$。这个范围不是 $\\big[0, L\\big)=\\big[0, 2^{64}-5\\big)$ 的子集，因为它包含了像 $2^{64}-1$ 这样的地址。该策略未能检测到溢出。\n结论：**不正确**。\n\nC. **如果 $addr  L$，则以无符号 $n$ 位算术（模 $2^n$）计算 $end = addr + len$；若 $end  addr$ 则拒绝；否则，当且仅当 $end \\le L$ 时接受。**\n该策略使用一个多步骤过程。\n1.  检查 $addr  L$：这正确地验证了区间的起始点。\n2.  计算 $end = addr +_n len$。\n3.  检查溢出：`如果 end  addr 则拒绝`。这是检测无符号加法溢出的标准且正确的方法。如果 $len$ 是正数，和 $addr+len$ 必须大于 `addr`，除非发生溢出，这会使结果变小。如果 $len=0$，$end=addr$，所以 $end  addr$ 为假，检查正确通过。\n4.  如果没有溢出（即 $end \\ge addr$），`end` 的值就是真实的数学和 `addr + len`。该策略接着检查 $end \\le L$。\n这一系列检查在逻辑上是健全的。它验证了起始点（$addr  L$），然后明确地验证了没有溢出，最后验证了未溢出的终点在允许的边界内（$addr + len \\le L$）。这些条件共同正确地确保了 $\\big[addr, addr + len\\big) \\subseteq \\big[0, L\\big)$。\n让我们重新评估恶意情况：$addr = 2^{64} - 10$, $len = 20$, $L = 2^{64}-5$。\n1.  $addr  L$：真。\n2.  $end = (2^{64} - 10) +_n 20 = 10$。\n3.  如果 $end  addr$ 则拒绝：$10  2^{64} - 10$。这是真的。该条件触发拒绝。\n该策略正确地拒绝了恶意输入。\n结论：**正确**。\n\nD. **将 `addr` 和 `len` 转换为有符号 $n$ 位整数，如果使用有符号算术运算满足 $(addr + len) \\ge addr$ 且 $(addr + len) \\le L$，则接受。**\n这种方法根本上是有缺陷的。内存地址和长度本质上是无符号实体。将它们转换为有符号类型会引入歧义和实现定义的行为。\n- 一个在范围 $\\big[2^{n-1}, 2^n - 1\\big]$ 内的无符号 $n$ 位整数 `addr` 在转换为有符号 $n$ 位整数时会变成一个负数。这使得所有后续的比较变得复杂。\n- 像 C/C++ 这样的语言标准不保证有符号整数溢出的行为（它是未定义行为），尽管大多数处理器实现了二进制补码回绕。一个“可证明为健全”的策略不能依赖于未定义行为。\n- 检查 $(addr + len) \\ge addr$ 对于有符号数来说不是一个可靠的溢出检测器。例如，如果 `addr` 是一个大的正数，`len` 是一个小的正数，它们的和可能会溢出并成为一个大的负数，此时 `sum  addr` 为真，正确地检测到溢出。但是，如果 `addr` 是一个负数，`len` 也是一个负数，它们的和可能会下溢并变成正数，此时 `sum > addr` 为真，未能检测到下溢。\n- 该策略缺少关键的初始检查 $addr  L$。\n该策略不可移植、复杂且不正确。\n结论：**不正确**。\n\nE. **将 `addr` 和 `len` 提升为宽度为 $n' \\ge n + 1$ 位的更宽的无符号整数类型，在该更宽的类型中计算 $end = addr + len$（无回绕），并且仅当 $addr  L$ 且 $end \\le L$ 时接受。**\n这是一个鲁棒且被广泛使用的策略。\n- 一个 $n$ 位无符号整数的最大值为 $2^n - 1$。两个这样的整数的最大可能和是 $(2^n - 1) + (2^n - 1) = 2^{n+1} - 2$。\n- 这个和可以在宽度为 $n+1$ 位或更宽的无符号整数类型中无损或无溢出地表示（该类型可以覆盖高达 $2^{n+1}-1$ 的值）。问题指定了宽度 $n' \\ge n+1$，这是足够的。\n- 通过将 `addr` 和 `len` 提升到这个更宽的类型，计算 $end = addr + len$ 会产生真实的数学和，完全避免了回绕问题。\n- 该策略然后执行两个简单的比较：\n    1.  $addr  L$：正确检查起始边界。\n    2.  $end \\le L$：将真实的数学终点与限制进行比较。这一个比较就能正确地检查溢出（如果真实和 `end` 超过 $2^n-1$，它肯定会大于 $L$，因为 $L \\le 2^n$）和边界条件。\n让我们检查恶意情况：$addr = 2^{64} - 10$, $len = 20$, $L = 2^{64}-5$。\n1.  将 `addr` 和 `len` 提升为 128 位无符号类型。\n2.  计算 $end = (2^{64} - 10) + 20 = 2^{64} + 10$。这是精确的和。\n3.  检查 $addr  L$：$2^{64} - 10  2^{64} - 5$。真。\n4.  检查 $end \\le L$：$2^{64} + 10 \\le 2^{64} - 5$。这为假。\n输入被正确拒绝。这个策略是可证明为健全的。\n结论：**正确**。", "answer": "$$\\boxed{ACE}$$", "id": "3686254"}, {"introduction": "在多线程环境中，系统调用的参数验证变得更加复杂。仅仅在检查时确认参数有效是不够的，因为在检查和使用之间，另一个线程可能已经改变了相关的内核状态。这个练习探讨了经典的“检查时-使用时”（Time-of-Check-to-Time-of-Use, TOCTOU）竞态条件问题，并要求你设计同步协议来原子性地获取和锁定资源。这有助于你理解在并发环境下确保系统调用接口安全性和正确性的高级技术。[@problem_id:3686201]", "problem": "一个多线程进程使用一个进程级的文件描述符表，该表将整数描述符 $fd$ 映射到一个内核文件对象 $F$。操作系统为每个文件对象维护一个引用计数 $ref(F)$。一个表示为 $\\mathrm{do\\_op}(fd,\\ldots)$ 的系统调用，首先检查 $fd$ 是否在有效范围内并且存在于调用者的描述符表中，然后使用相应的文件对象 $F$ 来执行操作。同一进程中的另一个线程可能会并发调用 $\\mathrm{close}(fd)$，该调用会移除 $fd \\rightarrow F$ 映射并递减 $ref(F)$；当 $ref(F)$ 达到 $0$ 时，$F$ 变为可回收状态。\n\n考虑经典的“检查时到使用时”（time-of-check-to-time-of-use）窗口：线程 $T_1$ 进入 $\\mathrm{do\\_op}(fd,\\ldots)$ 并验证 $fd$，而线程 $T_2$ 同时执行 $\\mathrm{close}(fd)$。在验证和首次使用 $F$ 之间，$T_2$ 可能会移除该映射，并可能允许 $fd$ 被重用于一个不同的文件对象 $F'$，从而造成“释放后使用”（use-after-free）或“错误对象”（wrong-object）的风险。\n\n从以下候选设计中，选择所有实现了文件描述符引用获取协议的方案，该协议在系统调用入口处相对于 $\\mathrm{close}(fd)$ 是原子的，满足正确性属性：“若入口时 $fd$ 无效，则失败并返回错误；否则，返回一个对入口时所映射的文件对象 $F$ 的稳定引用，并阻止其在释放前被回收”，并且通过保持最小的临界区和不串行化不相关的系统调用来保持可伸缩性。\n\nA. 在系统调用入口处，获取进程的文件描述符表锁，验证 $0 \\le fd  N$ 且表项指向一个非空的文件对象 $F$，在仍持有锁的情况下增加 $ref(F)$，然后释放锁。使用 $F$ 继续执行系统调用，并在完成后递减 $ref(F)$。如果表项为空，则返回一个错误（例如 $-EBADF$）。\n\nB. 在验证 $fd$ 和获取 $F$ 时，在调用方的中央处理器（CPU）上禁用抢占和中断，然后在-使用 $F$ 之前重新启用它们。假设阻止上下文切换会使时间窗口小到可以忽略。\n\nC. 在系统调用入口处，将整数 $fd$ 从用户空间复制到内核内存，并验证其范围。之后访问描述符表时使用这个内核副本，无需任何进一步的同步，因为内核副本不能被用户空间修改。\n\nD. 对描述符表使用“读取-复制-更新”（Read-Copy-Update, RCU）：进入一个 RCU 读端临界区，读取表项以获取指针 $F$ 和每个表项的生成计数器 $g$，然后尝试原子地增加 $ref(F)$（例如，通过对 $ref(F)$ 进行“比较并交换”操作）来“钉住”$F$。在增加成功后，重新读取生成计数器为 $g'$，并检查 $g' = g$。如果相等，则退出 RCU 读端临界区并继续使用 $F$；如果不相等，则放弃对 $F$ 的引用，并在采用表锁的慢速路径上重试。如果表项为空，则返回错误。当系统调用完成时，递减 $ref(F)$。\n\nE. 通过在每个使用 $fd$ 的系统调用（从入口到完成）的整个持续时间内，以及对每个 $\\mathrm{close}(fd)$ 调用，都获取一个单一的全局互斥锁，来串行化描述符操作。在该互斥锁内，验证并获取 $F$，然后执行操作；最后释放互斥锁。\n\n选择所有正确的选项。", "solution": "问题描述了在多线程进程中文件描述符管理上下文下的一个经典的“检查时到使用时”（TOCTOU）竞争条件。目标是找出能够原子地查找文件描述符 $fd$、获取对底层文件对象 $F$ 的稳定引用、并防止其被过早回收的同步协议，同时还要保持系统的可伸缩性。一个有效的解决方案必须满足两个主要属性：\n1.  **正确性：** 操作必须相对于并发的 $\\mathrm{close}(fd)$ 是原子的。如果调用时 $fd$ 无效，它必须能干净地失败；或者，它必须能安全地获取到在当时映射的正确文件对象 $F$ 的引用，并确保 $F$ 在系统调用期间不被回收。\n2.  **可伸缩性：** 临界区必须是最小的，并且解决方案不能不必要地串行化不相关的系统调用，否则会造成性能瓶颈。\n\n我们现在将根据这些标准评估每个候选设计。\n\n### 选项 A 评估\n该选项建议使用锁来保护文件描述符表。操作顺序是：\n1.  获取进程文件描述符表的锁。\n2.  验证 $fd$ 并查找相应的文件对象 $F$。\n3.  如果有效，则增加引用计数 $ref(F)$。\n4.  释放锁。\n5.  使用 $F$ 继续操作。\n6.  完成后递减 $ref(F)$。\n\n**正确性：** 此设计正确地解决了竞争条件。锁确保了验证 $fd$、检索指向 $F$ 的指针以及增加 $ref(F)$ 这一系列操作相对于任何其他修改文件描述符表的操作（例如 $\\mathrm{close}(fd)$）是原子的。如果线程 $T_1$（执行 $\\mathrm{do\\_op}$）先获取了锁，它将在释放锁之前增加 $ref(F)$。随后线程 $T_2$ 执行的 $\\mathrm{close}(fd)$ 将移除 $fd \\rightarrow F$ 映射并递减 $ref(F)$，但由于 $T_1$ 持有一个引用，$ref(F)$ 不会降到 $0$，对象 $F$ 也不会被回收。如果 $T_2$ 先获取了锁，它将移除映射。当 $T_1$ 随后获取锁时，它会发现 $fd$ 无效，并正确地返回一个错误（例如 $-EBADF$）。这满足了正确性属性。\n\n**可伸缩性：** 锁的持有时间非常短——仅够执行范围检查、表查找和引用计数增加。这是一个最小的临界区。该锁是特定于单个进程的文件描述符表的，因此不会串行化来自不同进程的系统调用。虽然它确实会串行化同一进程内的并发文件描述符操作，但这通常是一个可接受的权衡，并且远优于全局锁。因此，该设计在合理程度上保持了可伸缩性。\n\n**结论：** **正确**。这是一个标准、健壮且被广泛使用的解决方案。\n\n### 选项 B 评估\n该选项建议在调用方的 CPU 上禁用抢占和中断，以创建一个类似原子的区域。\n\n**正确性：** 这种方法在多处理器环境中存在根本性缺陷。在单个 CPU 核心（例如 CPU$_0$）上禁用抢占和中断，仅能阻止其他线程在 CPU$_0$ 上被调度。它完全无法阻止另一个线程 $T_2$ 在不同的核心（例如 CPU$_1$）上并发运行、获取 $\\mathrm{close}$ 操作所需的任何锁、修改共享的文件描述符表，并导致我们试图防止的竞争条件。假设这样做能使时间窗口“小到可以忽略”，是依赖于时序的危险做法，而不是正确性的保证，并且在任何现代多核系统上都是不成立的。\n\n**可伸缩性：** 由于该方法不正确，可伸缩性在此无关紧要。\n\n**结论：** **不正确**。它无法在当今标准的多处理器系统上提供所需的原子性。\n\n### 选项 C 评估\n该选项建议将整数 $fd$ 从用户空间复制到内核空间，然后使用这个内核副本。\n\n**正确性：** 这个提议误解了 TOCTOU 漏洞的本质。问题不在于用户空间程序可能在内核读取文件描述符编号后恶意更改持有该值的变量。问题在于，在线程 $T_1$ 检查表和它使用该检查结果之间，*共享的内核数据结构*（文件描述符表）的状态可以被另一个内核级执行线程（例如运行 $\\mathrm{close}(fd)$ 的 $T_2$）改变。将整数 $fd$ 复制到内核内存，对于同步访问文件描述符表本身没有任何作用。线程 $T_1$ 可以读取 $fd$ 的内核副本并验证它，但在它可以使用相关的文件对象 $F$ 之前，线程 $T_2$ 就可以关闭该 $fd$，从而导致“释放后使用”或“错误对象使用”的 bug。\n\n**可伸缩性：** 由于该方法不正确，可伸缩性在此无关紧要。\n\n**结论：** **不正确**。它未能解决实际的并发问题。\n\n### 选项 D 评估\n该选项描述了一种使用“读取-复制-更新”（RCU）和生成计数器的无锁乐观方法。\n\n**正确性：** 这是一个复杂且正确的设计。\n1.  进入 RCU 读端临界区可以防止文件描述符表结构本身在读者遍历时被释放。\n2.  读者获取指向 $F$ 的指针和一个生成计数器 $g$。任何修改此特定表项的写入者（一个 $\\mathrm{close}$ 或 `dup2` 操作）都会增加这个生成计数器。\n3.  读者尝试通过原子地增加其引用计数 $ref(F)$ 来“钉住”该文件对象。\n4.  关键步骤是重新读取生成计数器为 $g'$，并验证 $g' = g$。如果它们相等，则意味着在初始读取和成功钉住 $F$ 之间，没有写入者修改过这个特定的 $fd$ 表项。读者已经获取了对正确对象的稳定引用，可以继续进行。\n5.  如果 $g' \\neq g$，说明与写入者发生了竞争。读者的引用可能指向一个过时的对象，所以它必须撤销其操作（递减 $ref(F)$）并重试，通常是通过使用传统锁的“慢速路径”（如选项 A 中所述）。\n这个协议正确地确保了读者要么获得对调用入口时存在的对象的稳定引用，要么安全地检测到竞争并重试。\n\n**可伸缩性：** 这个设计具有很高的可伸缩性。读者的快速路径不涉及锁，只涉及 RCU 原语和原子操作，这些都非常高效。这允许多个并发的系统调用（`do_op`）并行执行而不会相互阻塞。写入者（$\\mathrm{close}$）需要获取锁来更新表和生成计数器，但在许多工作负载中，读操作远比写操作频繁，这使其成为一个出色的优化。该设计明确地最小化了临界区，并避免了串行化不相关的调用。\n\n**结论：** **正确**。这是一个有效的、高性能的解决方案，被用于高级操作系统中。\n\n### 选项 E 评估\n该选项建议使用一个在调用整个期间持有的单一全局互斥锁，来串行化所有与文件描述符相关的系统调用。\n\n**正确性：** 这确实可以防止竞争条件。通过串行化所有接触文件描述符的操作，它消除了所有并发性，因此 TOCTOU 风险不会发生。$fd$ 的验证和 $F$ 的使用都将在全局互斥锁的独占保护下进行。\n\n**可伸缩性：** 这个解决方案的可伸缩性极差。它不仅串行化了一个进程内的相关操作，而且串行化了*整个系统*中*所有*的文件描述符操作。一个进程中的线程在管道上执行一个长时间阻塞的 $\\mathrm{read()}$ 操作，会阻止一个完全不相关的进程中的线程打开一个新文件。这直接违反了“通过保持最小的临界区和不串行化不相关的系统调用来保持可伸缩性”的要求。在可能阻塞的 I/O 操作的整个持续时间内持有锁，是内核开发中的一个重大设计缺陷。\n\n**结论：** **不正确**。它以最极端的方式未能满足可伸缩性要求。", "answer": "$$\\boxed{AD}$$", "id": "3686201"}]}