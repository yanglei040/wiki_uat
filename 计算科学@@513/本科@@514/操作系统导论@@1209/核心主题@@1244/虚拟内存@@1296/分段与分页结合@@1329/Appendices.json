{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节的第一个练习将带你分析一个非常常见的场景：程序栈的动态增长。在段页式内存管理系统中，当一个程序需要更多栈空间时，操作系统是如何按需分配物理内存的？通过计算这个过程中触发的缺页中断次数[@problem_id:3680814]，你将亲手实践从线性地址到页号的转换，并深刻理解请求分页机制的运作原理。", "problem": "一个用户进程运行在一个结合了分段与分页的系统上。栈段向较低的线性地址方向增长。设栈段的基地址为 $B$，当前逻辑栈顶指针的偏移量为 $s_{0}$，因此经过分段转换后，当前栈顶的线性地址为 $A_{0} = B + s_{0}$。之后，分页机制将线性内存划分为大小为 $P$ 字节的固定大小的页，这些页在 $P$ 的倍数地址上对齐。当首次访问任何尚未映射的线性页时，会发生页错误；操作系统 (OS) 会在发生错误时按需分配这样一个页，并恢复执行导致错误的指令。\n\n假设存在以下具体场景：\n- 栈段基地址为 $B = 0$，因此当前栈顶线性地址为 $A_{0} = s_{0}$。\n- 当前栈顶线性地址为 $A_{0} = 32780$。\n- 页面大小为 $P = 4096$ 字节。\n- 当前为栈精确地映射了一个页：包含 $A_{0}$ 的那个页。栈区域中所有更低的线性页都是未映射的。\n- 程序通过将栈指针减小 $\\Delta = 10000$ 字节来分配一个新的栈帧，并初始化该帧，从而确保在此次帧扩展所产生的线性地址区间相交的每个页中都至少写入一个字节。具体来说，指令序列会至少一次访问闭区间 $\\left[A_{0} - \\Delta + 1,\\, A_{0}\\right]$ 中的每个线性地址，从而触及该区间所覆盖的每一个页。\n- 栈段的界限足够大，因此该操作不会违反段边界。\n\n从核心定义出发——即 (i) 分段机制产生线性地址 $A = B + s$ 并执行边界检查，以及 (ii) 分页机制将线性地址空间划分为大小为 $P$ 的页，页索引由 $\\left\\lfloor A / P \\right\\rfloor$ 给出——请从第一性原理推导出当栈指针从 $A_{0}$ 减小 $\\Delta$ 时所触及的不同新页数量的表达式，并用它来计算在此场景下请求分页机制所产生的页错误数量。请以单个整数（无单位）形式提供您的最终答案。无需进行四舍五入。", "solution": "问题要求计算当程序扩展栈时产生的页错误数量。该系统使用分段与分页结合的内存管理。我们必须首先推导出一个触及的新页数量的通用表达式，然后计算给定场景下的具体页错误数量。\n\n核心原理是将逻辑地址映射到线性地址（分段）以及将线性地址映射到物理地址（分页）的函数。题目通过设置段基址 $B=0$ 简化了分段部分，因此逻辑偏移量 $s$ 直接对应于线性地址 $A=s$。\n\n分页机制将线性地址空间划分为大小为 $P$ 的固定大小的页。一个线性地址 $A$ 位于索引为 $p$ 的页上，该索引由以下表达式给出：\n$$ p = \\left\\lfloor \\frac{A}{P} \\right\\rfloor $$\n其中 $\\lfloor \\cdot \\rfloor$ 是向下取整函数。任何在范围 $p \\times P \\le A' \\le (p+1) \\times P - 1$ 内的地址 $A'$ 都属于同一个页 $p$。\n\n题目指出栈向低地址方向增长。当前栈顶线性地址为 $A_{0} = 32780$。通过将栈指针减小 $\\Delta = 10000$ 字节来扩展栈。题目明确指出，此操作会访问闭区间 $[A_{0} - \\Delta + 1, A_{0}]$ 中的每一个线性地址。\n\n让我们定义被访问的线性地址范围的边界：\n访问的最高地址是 $A_{high} = A_{0}$。\n访问的最低地址是 $A_{low} = A_{0} - \\Delta + 1$。\n\n使用给定的值：\n$A_{high} = 32780$。\n$A_{low} = 32780 - 10000 + 1 = 22781$。\n\n被访问的线性地址集合是区间 $[22781, 32780]$。为了找到触及的不同页的数量，我们需要找出与 $A_{low}$ 和 $A_{high}$ 对应的页索引。给定的页面大小为 $P = 4096$ 字节。\n\n最高地址 $A_{high}$ 的页索引是：\n$$ p_{high} = \\left\\lfloor \\frac{A_{high}}{P} \\right\\rfloor = \\left\\lfloor \\frac{A_{0}}{P} \\right\\rfloor $$\n最低地址 $A_{low}$ 的页索引是：\n$$ p_{low} = \\left\\lfloor \\frac{A_{low}}{P} \\right\\rfloor = \\left\\lfloor \\frac{A_{0} - \\Delta + 1}{P} \\right\\rfloor $$\n由于内存访问在区间 $[A_{low}, A_{high}]$ 上是连续的，所有索引从 $p_{low}$ 到 $p_{high}$ 的页都会被触及。触及的不同页的总数是：\n$$ N_{touched} = p_{high} - p_{low} + 1 $$\n对于每个被触及但当前未映射到内存中的页，都会发生一次页错误。题目说明，初始时，“当前为栈精确地映射了一个页：包含 $A_{0}$ 的那个页”。这个页的索引是 $p_{high}$。所有其他的页，特别是那些索引低于 $p_{high}$ 的页（因为栈是向下增长的），都是未映射的。\n\n所有被触及的页索引的集合是 $\\{p_{low}, p_{low} + 1, \\dots, p_{high}\\}$。\n（在该区域内）初始映射的页的集合是 $\\{p_{high}\\}$。\n将导致错误的页的集合是那些被触及但不在初始映射集中的页：\n$$ \\{p_{low}, p_{low} + 1, \\dots, p_{high}\\} \\setminus \\{p_{high}\\} = \\{p_{low}, p_{low} + 1, \\dots, p_{high} - 1\\} $$\n页错误数量 $N_{faults}$ 是这个集合的基数，即 $(p_{high} - 1) - p_{low} + 1 = p_{high} - p_{low}$。\n\n这就给出了计算页错误数量的通用表达式：\n$$ N_{faults} = \\left\\lfloor \\frac{A_{0}}{P} \\right\\rfloor - \\left\\lfloor \\frac{A_{0} - \\Delta + 1}{P} \\right\\rfloor $$\n现在我们将题目中的具体数值代入这个表达式：\n$A_{0} = 32780$\n$\\Delta = 10000$\n$P = 4096$\n\n首先，我们计算 $p_{high}$：\n$$ p_{high} = \\left\\lfloor \\frac{32780}{4096} \\right\\rfloor = \\lfloor 8.002929... \\rfloor = 8 $$\n所以，初始的栈顶位于第 $8$ 页。这个页是已经被映射的。\n\n接着，我们计算 $p_{low}$：\n$$ p_{low} = \\left\\lfloor \\frac{32780 - 10000 + 1}{4096} \\right\\rfloor = \\left\\lfloor \\frac{22781}{4096} \\right\\rfloor = \\lfloor 5.561767... \\rfloor = 5 $$\n访问的最低地址位于第 $5$ 页。\n\n被触及的页是第 $5, 6, 7$ 和 $8$ 页。由于第 $8$ 页已经被映射，所以在首次访问第 $5, 6$ 和 $7$ 页时会发生页错误。\n\n使用我们推导出的错误数量公式：\n$$ N_{faults} = p_{high} - p_{low} = 8 - 5 = 3 $$\n因此，总共会产生 $3$ 次页错误。", "answer": "$$\\boxed{3}$$", "id": "3680814"}, {"introduction": "理解了按需分配内存的基本原理后，我们来探讨一个与性能优化密切相关的问题。顺序读取文件是计算机中一种极为常见的I/O模式，而操作系统通常会采用预取（read-ahead）策略来减少缺页中断，从而加速数据访问。这个练习[@problem_id:3680807]要求你推导在一个包含预取策略的系统中，顺序读取一个大文件所产生的缺页中断总数。通过这个计算，你将学会如何量化分析系统策略对I/O性能的影响。", "problem": "考虑一个实现段页式内存管理的操作系统（OS）：每个逻辑段被划分为大小为 $P$ 字节的固定大小页面，段通过段表引用，段表指向该段的页表。一个进程将一个大小为 $m$ 字节的文件映射到一个单独的段中，从段内偏移量 $0$ 开始，然后从头到尾对整个映射区域进行一次顺序读取。在时间 $t=0$ 时，该段的所有页面都未驻留在物理内存中；操作系统使用请求分页，因此引用一个未驻留的页面会触发页面错误（缺页中断）。假设如下：\n- 发生页面错误时，操作系统通过从二级存储中读取出错页面来处理该错误，并作为一种预读（read-ahead prefetch）策略，还会读取同一段中接下来的 $r$ 个连续页面（如果它们存在于 $m$ 字节的范围内）。这些预取的页面作为处理错误的一部分被调入内存。\n- 物理内存和页面置换策略确保一旦一个页面（无论是出错调入还是预取调入）被调入内存，它就会一直驻留，直到在这次顺序读取中被访问；在此次单遍读取中，没有预取的页面在其被使用前被置换出去。\n- 只计算那些导致I/O操作从二级存储调入页面的主页面错误（major page fault）；对已驻留页面的访问不会产生错误。快表（Translation Lookaside Buffer, TLB）的行为与本问题无关。\n\n仅使用段页式管理和请求分页行为的核心定义，推导在单次顺序遍历 $m$ 字节期间所产生的总页面错误次数的闭式表达式，该表达式是关于 $m$、$P$ 和 $r$ 的函数。请将最终答案表示为单个解析表达式。无需进行四舍五入。", "solution": "问题要求推导在单次顺序遍历一个大小为 $m$ 字节、映射到单个段的文件期间所产生的总页面错误次数的闭式表达式。该系统使用段页式内存管理，页面大小为 $P$ 字节。关键机制是请求分页和预读策略。\n\n首先，我们确定该段所需的总页面数。一个大小为 $m$ 字节的文件从偏移量 $0$ 开始映射，将占用从偏移量 $0$ 到 $m-1$ 的字节。在页面大小为 $P$ 字节的情况下，所需页面数是总大小除以页面大小，并向上取整，因为即使是部分使用的页面也必须被分配。设 $N_{pages}$ 为总页面数。\n$$N_{pages} = \\left\\lceil \\frac{m}{P} \\right\\rceil$$\n这些页面可以从 $0$ 到 $N_{pages}-1$ 进行索引。\n\n接下来，我们分析进程顺序读取文件时发生的一系列事件。最初，在时间 $t=0$ 时，没有页面驻留在物理内存中。操作系统使用请求分页，因此只有在访问页面时才会加载它们。\n\n顺序读取从偏移量 $0$ 开始，这位于页面 $0$ 内。由于页面 $0$ 不在内存中，这次访问会触发第一次页面错误。\n根据指定的预取策略，当发生页面错误时，操作系统会加载出错的页面，并预取该段内接下来的 $r$ 个连续页面。因此，第一次错误（在页面 $0$ 上）导致操作系统加载一个页面块。这个块包括页面 $0$ 以及（如果存在的话）页面 $1, 2, \\dots, r$。总共，由于这一次错误，最多会有 $1+r$ 个页面被调入内存。\n\n第一次错误处理完毕后，页面 $0, 1, \\dots, r$（如果段小于 $r+1$ 个页面，则数量会更少）就驻留在内存中了。进程继续顺序读取这些页面。由于它们都已驻留，在此阶段不会发生页面错误。\n\n只有当进程试图访问一个不在前一次I/O操作中加载的页面中的字节时，才会发生后续的页面错误。第一个加载的页面块结束于页面 $r$。因此，下一次导致错误的访问将发生在页面 $r+1$ 上。这将触发第二次页面错误。\n\n处理页面 $r+1$ 上的第二次错误会导致操作系统加载另一个页面块：出错页面 $r+1$ 和接下来的 $r$ 个页面，即页面 $r+2, \\dots, (r+1)+r = 2r+1$。\n\n这建立了一个清晰的模式。每当顺序访问进入一个其索引是 $(r+1)$ 的倍数的页面时，就会触发一次页面错误。将导致错误的页面索引是 $0, (r+1), 2(r+1), 3(r+1)$, 以此类推。\n\n为了找出总的页面错误次数，我们需要确定在所有 $N_{pages}$ 个页面都被加载到内存之前，发生了多少次这样的错误触发事件。由于每次错误会调入一个包含 $1+r$ 个页面的块，因此总错误次数是总页面数 $N_{pages}$ 除以每次错误加载的页面数 $1+r$。我们必须使用向上取整函数（ceiling function）来处理最后一个可能不完整的页面块。\n\n设 $F$ 为总页面错误次数。\n$$F = \\left\\lceil \\frac{N_{pages}}{r+1} \\right\\rceil$$\n\n代入 $N_{pages}$ 的表达式：\n$$F = \\left\\lceil \\frac{\\left\\lceil \\frac{m}{P} \\right\\rceil}{r+1} \\right\\rceil$$\n\n这个表达式可以使用数学恒等式 $\\lceil \\frac{\\lceil x \\rceil}{n} \\rceil = \\lceil \\frac{x}{n} \\rceil$ 进行简化，该恒等式对任何实数 $x$ 和任何正整数 $n$ 都成立。在我们的情况下，$x = m/P$ 且 $n = r+1$。由于预取的页面数 $r$ 是一个非负整数（$r \\ge 0$），因此 $n = r+1$ 是一个正整数。应用此恒等式，我们得到总页面错误次数的最终简化闭式表达式：\n$$F = \\left\\lceil \\frac{m/P}{r+1} \\right\\rceil = \\left\\lceil \\frac{m}{P(r+1)} \\right\\rceil$$\n该表达式在给定条件下准确地量化了将整个文件调入内存所需的I/O操作次数。", "answer": "$$\\boxed{\\left\\lceil \\frac{m}{P(r+1)} \\right\\rceil}$$", "id": "3680807"}, {"introduction": "一个优秀的内存管理系统不仅要高效，更必须安全。段页式管理的核心优势之一就是其提供的精细化保护机制。本节的最后一个练习将引导你深入探讨这一机制的安全性核心。我们通过分析一个假设的硬件实现缺陷——即错误地将页表检查置于段限长检查之前——来揭示保护逻辑顺序的重要性。通过计算这种错误设计可能导致的未授权内存访问次数[@problem_id:3680741]，你将体会到系统设计中“魔鬼在细节”的道理，并理解为何内存保护必须做到万无一失。", "problem": "一个计算机系统实现了段页式内存管理。每个虚拟地址由一个段选择子 $s$ 和一个偏移量 $o$ 组成。对于段 $s$，其段描述符包含一个基址 $\\text{base}_s$ 和一个以字节为单位的界限 $\\text{limit}_s$。该段的页面大小固定为 $P$ 字节，其页表有 $\\lceil \\text{limit}_s / P \\rceil$ 个条目。地址转换将偏移量 $o$ 分解为一个页索引 $p = \\lfloor o / P \\rfloor$ 和一个页内位移 $d = o \\bmod P$。正确的硬件检查顺序由段页式内存管理的保护语义定义：偏移量必须满足 $o  \\text{limit}_s$（以确保字节地址位于段内），只有这样，页索引 $p$ 才能被验证并用于查询该段的页表。在实践中，对 $p$ 的验证和对快表（TLB, Translation Lookaside Buffer）的使用，决不能在确认 $o  \\text{limit}_s$ 之前允许内存访问发生，特别是当最后一个有效页面仅被该段部分填充时。\n\n考虑一个段 $s$，其页面大小 $P = 4096$ 字节，段界限 $\\text{limit}_s = 100000$ 字节。一个工作负载产生了 $N = 10^{6}$ 次内存引用，其字节偏移量 $o$ 在区间 $[0, M)$ 内均匀分布，其中 $M = 120000$。该段的页表有 $\\lceil \\text{limit}_s / P \\rceil$ 个条目。包含该段逻辑末尾的最后一页存在于内存中，并在整个工作负载期间常驻于TLB中。在一个有缺陷的实现中，硬件在执行 $o  \\text{limit}_s$ 检查之前，错误地先执行了 $p$ 的边界检查，并在TLB命中时发出内存访问；$o  \\text{limit}_s$ 的检查稍后完成，但为时已晚，无法阻止该次访问。\n\n仅从上述定义和“一个字节地址有效当且仅当 $o  \\text{limit}_s$”这一保护要求出发，推导出正确的检查顺序，并解释为什么先检查 $p$ 的方法无法强制执行最后一页的部分有效性。然后，计算在这 $N$ 次引用中，仅仅因为这种错误的检查顺序而发生的未授权内存访问的期望次数。将最终答案表示为一个数字；不要包含单位。无需进行四舍五入。", "solution": "该问题被验证为科学上合理、定义明确、客观且自洽。它描述了使用段页式内存管理的计算机体系结构中一个经典的保护问题，并提出了一个貌似合理的实现缺陷。定量分析所需的所有参数均已提供。\n\n解答分为两部分：首先，解释正确的保护逻辑和所述实现中的缺陷；其次，计算未授权内存访问的期望次数。\n\n**第一部分：正确的检查顺序与缺陷分析**\n\n基于段的内存保护的基本原则是，一个由段选择子 $s$ 和偏移量 $o$ 指定的虚拟地址，当且仅当偏移量 $o$ 落在该段的边界内时才有效。也就是说，必须满足条件 $0 \\le o  \\text{limit}_s$。此检查确保进程只访问在该段内分配给它的内存。\n\n在分段机制下使用分页是一种内存管理技术，用于处理段数据的物理存放。偏移量 $o$ 被分解为页索引 $p = \\lfloor o / P \\rfloor$ 和页内位移 $d = o \\bmod P$。页索引 $p$ 用于查找页框的物理地址，$d$ 用于在该页框内定位特定字节。这个地址转换过程次于主要的保护检查。只有当偏移量为 $o$ 的字节在逻辑上是该段的一部分时，内存访问才被授权。\n\n因此，正确且安全的硬件检查顺序必须是：\n1.  根据段界限验证偏移量：检查是否满足 $o  \\text{limit}_s$。如果此检查失败，必须触发段违例（保护故障），并中止访问。\n2.  只有在第一个检查通过后，才继续进行地址转换：计算 $p = \\lfloor o / P \\rfloor$，检查 $p$ 对于该段的页表是否是有效索引，然后使用页表（或作为缓存的TLB）执行内存访问。\n\n问题描述了一个有缺陷的实现，其中对页索引 $p$ 的检查以及随后的TLB访问发生在决定性的 $o  \\text{limit}_s$ 检查之前。这个顺序是不安全的，因为页索引的有效性并不能保证映射到它的每个字节偏移量的有效性。对于段的最后一页尤其如此，因为它通常只是部分填充的。\n\n让我们针对给定的段 $s$ 进行分析，其页面大小 $P = 4096$ 字节，界限 $\\text{limit}_s = 100000$ 字节。\n该段所需的页表条目数为：\n$$ N_p = \\lceil \\frac{\\text{limit}_s}{P} \\rceil = \\lceil \\frac{100000}{4096} \\rceil = \\lceil 24.414... \\rceil = 25 $$\n因此，有效的页索引为 $p \\in \\{0, 1, 2, ..., 24\\}$。最后一个有效的页索引是 $p_{\\text{last}} = 24$。\n\n这个索引为 $p=24$ 的最后一页，对应于满足 $\\lfloor o / 4096 \\rfloor = 24$ 的字节偏移量 $o$。此不等式对以下范围内的所有偏移量 $o$ 均成立：\n$$ 24 \\times 4096 \\le o  25 \\times 4096 $$\n$$ 98304 \\le o  102400 $$\n然而，段本身仅对偏移量 $o  \\text{limit}_s = 100000$ 有效。虽然索引为 $p=24$ 的页面覆盖了直到字节 $102399$ 的地址范围，但该段在此页面上的合法地址在字节 $99999$ 处结束。范围 $[100000, 102400)$ 内的偏移量超出了段界限，但它们映射到一个被有缺陷的硬件认为是有效的页索引 $p=24$。\n\n有缺陷的检查首先验证 $p$。如果生成的偏移量 $o$ 落入范围 $[100000, 102400)$，硬件会计算出 $p = \\lfloor o/4096 \\rfloor = 24$。由于 $p=24$ 是一个有效的页索引，且问题指出此页在TLB中，硬件将会找到一个TLB命中并发出内存访问。这次访问是未授权的，因为 $o \\ge \\text{limit}_s$。对 $p$ 的检查实际上错误地使整个最后一页都可访问，未能强制执行精确段界限所要求的部分有效性。\n\n**第二部分：期望未授权访问次数的计算**\n\n在有缺陷的实现下，如果生成的偏移量 $o$ 满足两个条件，就会发生未授权的内存访问：\n1.  相对于段界限，该访问是无效的：$o \\ge \\text{limit}_s$。\n2.  该访问被有缺陷的检查逻辑错误地允许：页索引 $p=\\lfloor o/P \\rfloor$ 是该段的一个有效页索引。\n\n根据第一部分，有效页索引的集合是 $p \\in \\{0, 1, ..., 24\\}$。这意味着有缺陷的逻辑允许任何满足 $\\lfloor o/P \\rfloor \\le 24$ 的访问。这意味着 $o/P  25$，即 $o  25 \\times P$。当 $P = 4096$ 时，此条件为 $o  25 \\times 4096 = 102400$。\n\n生成的内存引用的偏移量 $o$ 在区间 $[0, M)$ 内均匀分布，其中 $M = 120000$。\n段界限为 $\\text{limit}_s = 100000$。\n\n对于一个生成的偏移量 $o$，如果它满足以下所有条件，就会发生一次未授权访问：\n- $o \\in [0, 120000)$ (它是由工作负载生成的)\n- $o \\ge 100000$ (它是真正无效的)\n- $o  102400$ (它被有缺陷的检查错误地允许了)\n\n这些条件的交集定义了导致未授权访问的偏移量区间：\n$$ o \\in [100000, 102400) $$\n这个区间的长度是 $102400 - 100000 = 2400$。\n\n生成的偏移量的总范围是 $[0, 120000)$，其长度为 $M = 120000$。\n由于偏移量是均匀分布的，单次内存引用导致未授权访问的概率 $P_{\\text{unauth}}$ 是“未授权”区间的长度与总区间长度的比值：\n$$ P_{\\text{unauth}} = \\frac{102400 - 100000}{120000} = \\frac{2400}{120000} = \\frac{24}{1200} = \\frac{1}{50} = 0.02 $$\n内存引用的总次数是 $N = 10^6$。未授权访问的期望次数 $E$ 是总引用次数乘以单次引用未授权的概率：\n$$ E = N \\times P_{\\text{unauth}} = 10^6 \\times 0.02 = 1000000 \\times \\frac{2}{100} = 20000 $$\n因此，由于错误的检查顺序，我们预期会发生 $20000$ 次未授权的内存访问。", "answer": "$$\n\\boxed{20000}\n$$", "id": "3680741"}]}