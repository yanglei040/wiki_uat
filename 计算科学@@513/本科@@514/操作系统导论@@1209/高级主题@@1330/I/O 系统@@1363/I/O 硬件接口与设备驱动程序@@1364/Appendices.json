{"hands_on_practices": [{"introduction": "一个健壮的设备驱动程序必须保证即使在硬件事件（如中断）丢失的情况下也能可靠运行。本练习将探讨驱动程序与硬件之间的一个关键竞态条件，要求您设计一种安全的恢复机制 [@problem_id:3648104]。通过分析不同的轮询策略，您将学到一种用于处理异步硬件事件的基本模式，以确保系统的安全性和活性。", "problem": "一个直接内存映射输入/输出设备暴露一个状态寄存器 $S$，其比特位具有以下语义：比特 $C$ 表示“设备的完成队列中至少有一个待处理的完成”，比特 $E$ 表示“检测到错误”，而比特 $I$ 表示“中断已启用”。该设备使用电平触发中断：当 $I=1$ 且 $C=1$ 时，设备会持续断言其中断线，直到软件排空所有待处理的完成，并通过对 $S.C$ 的“写1清零”操作来清除 $C$。设备保证任何新的完成都会将 $C=1$，直到驱动程序排空队列并清除 $C$。\n\n假设一个注入的故障会导致偶尔的中断丢失：当 $C=1$ 时设备会断言中断线，但处理器有时无法将中断传递给驱动程序。驱动程序必须在不改变硬件的情况下保证向前进展和有界的检测延迟。提出的恢复方案是混合式的：保持 $I=1$（中断启用），并在计时器中每隔 $\\Delta$ 秒增加对 $S$ 的周期性轮询。\n\n假设以下经过充分验证的事实和定义：\n- 在内存映射输入/输出模型中，对设备寄存器的写操作可能会被提交，并相对于后续的加载和存储操作进行重排序，除非强制执行显式排序（例如，在写操作后对同一设备发出读操作，这起到完成栅栏的作用）。\n- 一个“写1清零”位只能通过向该位写入值$1$来清除；对整个寄存器的读-修改-写操作必须保留此语义。\n- 只要电平条件（$I=1$ 且 $C=1$）成立，电平触发中断就会被重新断言，这与边沿无关。\n\n设计驱动程序的恢复路径，以便在中断丢失的情况下，没有完成被遗漏或重复计数，并且额外的检测延迟以 $\\Delta$ 为界。考虑以下用于轮询例程的候选策略。鉴于上述语义，哪种策略同时满足安全性（在与新到达事件并发的情况下，没有完成被遗漏或重复计数）和活性（有界检测时间 $\\le \\Delta$）？\n\nA. 每隔 $\\Delta$ 轮询 $S$。如果 $C=1$ 或 $E=1$，调用与中断路径相同的处理程序来排空完成队列直到其为空。排空后，通过向 $S.C$ 写入 $1$ 来清除 $C$。立即执行一次对 $S$ 的读取，如果该次读取时 $C=1$，则循环以排空更多；否则退出。全程保持 $I=1$。\n\nB. 在轮询例程中，如果 $C=1$，首先通过向 $S.C$ 写入 $1$ 来清除 $C$，然后排空队列。依赖后续的中断来信号通知在排空期间可能到达的任何新完成。\n\nC. 在启用中断后仅轮询 $S$ 一次；如果在该初始轮询中 $C=0$，则假设设备将始终传递中断并省略进一步的轮询。\n\nD. 在每个轮询周期中，临时向 $S.I$ 写入 $0$ 以禁用中断，排空完成队列，向 $S.C$ 写入 $1$ 以清除，然后向 $S.I$ 写入 $1$ 以重新启用中断并退出，清除后不回读 $S$。\n\nE. 每隔 $\\Delta$ 安排一个计时器；当它触发时，如果 $C=1$，则排空完成队列，然后向 $S.C$ 写入 $1$ 并读取一个不相关的门铃寄存器 $D$ 以强制排序，然后退出而不重新检查 $S$。\n\n选择满足所述安全性和活性要求的唯一最佳策略。", "solution": "首先对问题陈述进行验证，以确保其科学上合理、定义明确且客观。\n\n### 步骤 1：提取已知条件\n\n-   **设备：** 直接内存映射输入/输出。\n-   **状态寄存器 `$S$`：**\n    -   比特 `$C$`：表示至少有一个完成待处理。\n    -   比特 `$E$`：表示检测到错误。\n    -   比特 `$I$`：表示中断已启用。\n-   **中断机制：** 电平触发。\n    -   条件：`$I=1$` 且 `$C=1$`。\n    -   行为：持续断言中断线，直到完成队列被排空且 `$C$` 被清除。\n-   **清除 `$C$`：** `$C$` 是一个“写1清零”位。向 `$S.C$` 写入 `$1$` 会清除它。\n-   **设备保证：** 一个新的完成会将 `$C=1$`，并且它会保持设置状态，直到驱动程序排空队列并清除 `$C$`。\n-   **故障模型：** 偶尔的中断丢失（处理器无法将硬件断言的中断传递给软件驱动程序）。\n-   **目标：** 驱动程序必须在不修改硬件的情况下，保证向前进展和对完成的有界检测延迟。\n-   **提出的恢复方案：** 使用中断和周期性轮询的混合模型。\n    -   中断保持启用 (`$I=1$`)。\n    -   每隔 `$\\Delta$` 秒对 `$S$` 进行周期性轮询。\n-   **假设的事实：**\n    1.  内存映射I/O的写操作可以被提交，并相对于后续的加载/存储操作进行重排序，除非使用排序栅栏（例如，在写操作后对同一设备进行读操作）。\n    2.  必须保留“写1清零”语义。\n    3.  只要条件（`$I=1 \\land C=1$`）满足，电平触发中断就会被重新断言。\n-   **问题：** 确定轮询例程的策略，以确保安全性（没有遗漏或重复计数的完成）和活性（检测延迟 `$\\le \\Delta$`）。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据：** 该问题牢固地植根于计算机体系结构和操作系统设计的既定原则。内存映射I/O、状态寄存器、电平触发中断、完成队列、“写1清零”位、中断丢失和内存排序都是设备驱动程序设计中的标准、真实世界的概念。\n-   **定义明确性：** 问题定义明确。它指定了硬件行为、一个故障模型以及明确的正确性标准（安全性和活性）。它要求评估特定的软件算法以满足这些标准。该设置允许通过对并发和竞争条件的逻辑分析来确定唯一的最佳解决方案。\n-   **客观性：** 问题以精确、客观的技术语言陈述。设备语义和正确性要求定义明确，没有歧义或主观性。\n\n-   **缺陷清单评估：**\n    1.  **科学/事实不健全：** 无。该模型是I/O硬件的标准表示。\n    2.  **无法形式化/不相关：** 无。该问题是指定主题内的经典并发控制问题。\n    3.  **不完整/矛盾的设置：** 无。提供的信息足以分析竞争条件。\n    4.  **不切实际/不可行：** 无。中断丢失是一种已知的（尽管不常见）故障模式，而混合中断/轮询驱动程序是一种标准的缓解策略。\n    5.  **定义不善/结构不良：** 无。问题结构导致可以确定一个正确的答案。\n    6.  **伪深刻/琐碎：** 无。硬件事件、软件操作和内存排序之间的交互提出了一个不平凡的推理挑战。\n    7.  **超出科学可验证性：** 无。每个策略的正确性可以通过逻辑推导和状态空间分析来验证。\n\n### 步骤 3：结论和行动\n\n问题陈述是有效的。分析将继续进行以推导出解决方案。\n\n### 解决方案推导\n\n这个问题的核心挑战是管理两个并发参与者之间的竞争条件：硬件设备，它可以随时添加新的完成（异步地将 `$C$` 设置为$1$），以及软件驱动程序的轮询例程，它为完成队列提供服务。如果驱动程序观察队列，处理它，然后清除状态位 `$C$`，而在此过程中一个新完成在一个特定的窗口期内到达，就可能发生完成丢失。\n\n让我们分析这个关键的竞争条件：\n1.  轮询例程读取 `$S$` 并看到 `$C=1$`。\n2.  例程排空设备队列中当前所有的完成。队列现在为空。\n3.  **关键窗口开始：** 一个新完成从硬件到达。设备将其添加到队列并将 `$C$` 设置为$1$。根据故障模型，我们假设相关的中断丢失了。\n4.  驱动程序不知道新到达的完成，执行对 `$S.C$` 的“写1清零”操作。此操作清除了 `$C$` 位。\n5.  **关键窗口结束。**\n\n最终的状态是完成队列非空，但状态位 `$C$` 为 `$0$`。由于 `$C=0$`，电平触发中断条件（`$I=1 \\land C=1$`）不满足，因此不会产生中断。新的完成现在“搁浅”了，直到下一个轮询间隔，即 `$\\Delta$` 秒后才会被检测到。为了完全健壮，驱动程序必须关闭这个竞争窗口。\n\n处理这种竞争的标准且正确的方法是在采取可能与事件发生竞争的操作*之后*重新检查状态。具体来说，在清除状态位 `$C$` 之后，驱动程序必须立即再次读取 `$S$`。如果发现 `$C$` 为 `$1$`，这意味着在服务例程执行期间有一个完成到达了。驱动程序必须接着循环并重新处理队列。给出的显式内存排序事实——即在写操作后对同一设备进行读操作会起到栅栏作用——是至关重要的。重新读取 `$S$` 不仅获取了最新的状态，还确保了之前清除 `$C$` 的写操作已经完成。\n\n### 逐项分析\n\n**A. 每隔 `$\\Delta$` 轮询 `$S$`。如果 `$C=1$` 或 `$E=1$`，调用与中断路径相同的处理程序来排空完成队列直到其为空。排空后，通过向 `$S.C$` 写入 `$1$` 来清除 `$C$`。立即执行一次对 `$S$` 的读取，如果该次读取时 `$C=1$`，则循环以排空更多；否则退出。全程保持 `$I=1$`。**\n\n该策略实现了正确的“检查-行动-再检查”逻辑。\n1.  `排空完成队列`：处理工作。\n2.  `通过向 S.C 写入 $1$ 来清除 C`：与新硬件事件发生竞争的操作。\n3.  `立即执行一次对 S 的读取`：这有两个目的。首先，它充当内存栅栏，确保对 `$S.C$` 的写操作在驱动程序继续之前对设备可见。其次，它获取 `$C$` 的新状态。\n4.  `如果该次读取时 C=1，则循环以排空更多`：这是检测和处理在关键窗口期间到达的完成的关键步骤。它关闭了竞争条件。\n\n该策略正确地保证了安全性和活性（由于循环，没有完成被遗漏）和活性（由于周期性轮询，延迟有界 `$\\le \\Delta$`）。\n\n**结论：正确。**\n\n**B. 在轮询例程中，如果 `$C=1$`，首先通过向 `$S.C$` 写入 `$1$` 来清除 `$C$`，然后排空队列。依赖后续的中断来信号通知在排空期间可能到达的任何新完成。**\n\n该策略在其顺序上存在致命缺陷。通过在排空队列*之前*清除 `$C$`，它打开了一个窗口，使得系统状态不一致：有待处理的完成，但指示这一点的状态位却是假的。如果在 `$C$` 位被清除后有一个新的完成到达，并且其中断丢失，那么它将被搁浅。该策略的前提“依赖后续的中断”直接与问题中的故障模型相矛盾，该模型指出中断可能会丢失。\n\n**结论：不正确。**\n\n**C. 在启用中断后仅轮询 `$S$` 一次；如果在该初始轮询中 `$C=0$`，则假设设备将始终传递中断并省略进一步的轮询。**\n\n该策略基于一个逻辑上无效的假设。问题明确指出中断是“偶尔”丢失的。在某个时间点上没有待处理的完成（初始轮询时 `$C=0$`）并不能提供关于未来中断传递可靠性的任何信息。如果后续的中断丢失，就没有恢复机制，该完成将被无限期搁浅，违反了对有界检测延迟的活性要求。\n\n**结论：不正确。**\n\n**D. 在每个轮询周期中，临时向 `$S.I$` 写入 `$0$` 以禁用中断，排空完成队列，向 `$S.C$` 写入 `$1$` 以清除，然后向 `$S.I$` 写入 `$1$` 以重新启用中断并退出，清除后不回读 `$S$`。**\n\n通过 `$S.I=0$` 禁用中断只会阻止设备*断言中断线*。它不会阻止设备向其队列添加新完成并将 `$C$` 设置为1。同样的竞争条件依然存在：一个完成可能在队列被排空之后但在 `$C$` 被清除之前到达。因为该策略明确指出“清除后不回读 `$S$`”，所以它无法检测到此类事件。该完成将在 `$C=0$` 和 `$I=1$` 的情况下搁浅，直到下一次轮询才可见。\n\n**结论：不正确。**\n\n**E. 每隔 `$\\Delta$` 安排一个计时器；当它触发时，如果 `$C=1$`，则排空完成队列，然后向 `$S.C$` 写入 `$1$` 并读取一个不相关的门铃寄存器 `$D$` 以强制排序，然后退出而不重新检查 `$S$`。**\n\n该策略与策略D有同样的基本缺陷。虽然读取同一设备上的寄存器 `$D$` *可能*会强制对 `$S.C$` 的写操作进行排序，但该策略明确指出“退出而不重新检查 `$S$`”。这意味着驱动程序对于在排空和清除 `$C$` 之间的关键窗口内到达的完成仍然是盲目的。该策略未能收集必要的状态信息来关闭竞争条件。\n\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3648104"}, {"introduction": "在正确性之外，性能是 I/O 设备的一个关键考量，尤其是在像 PCIe 这样的高速总线上。本问题要求您对硬件规格和驱动程序级优化对数据吞吐量的影响进行建模和量化 [@problem_id:3648064]。您将计算硬件链路速度、通道数量以及一种名为“批处理”（batching）的软件技术如何共同作用，从而显著提升整体性能。", "problem": "一个用于快速外设组件互连 (PCIe) 设备的操作系统设备驱动程序会将多个小的应用程序 I/O 请求聚合到单个事务层数据包 (TLP) 中，以便将每个数据包的固定开销分摊到更多的有效载荷上，这种技术通常称为批处理。每个单独的请求为 TLP 贡献大小为 $S = 512$ 字节的有效载荷。每个 TLP 在事务层和数据链路层合计产生 $O = 28$ 字节的固定非有效载荷开销。假设最大有效载荷大小足够大，所有批处理的有效载荷都能装入一个 TLP 中，并且稳态的数据链路层确认和流控制流量可以忽略不计。假定通道聚合随通道数线性扩展。\n\n使用以下关于 PCIe 链路的广为接受的物理事实：\n- 每通道符号率（也称为每秒传输次数）分别为 $t_{\\text{Gen1}} = 2.5 \\times 10^9$、$t_{\\text{Gen2}} = 5.0 \\times 10^9$、$t_{\\text{Gen3}} = 8.0 \\times 10^9$ 和 $t_{\\text{Gen4}} = 16.0 \\times 10^9$ 次/秒。每次传输移动 $1$ 个串行位。\n- 由于 $8\\text{b}/10\\text{b}$ 编码，第 1 代和第 2 代的物理层线路编码效率为 $0.8$；由于 $128\\text{b}/130\\text{b}$ 编码，第 3 代和第 4 代的物理层线路编码效率为 $128/130$。\n\n从第一性原理出发，将稳态有效载荷吞吐量（以比特/秒为单位）建模为有效原始链路比特率与每个 TLP 中有效载荷占传输比特的比例的乘积，其中有效载荷比例等于有效载荷字节数除以有效载荷与每个 TLP 固定开销字节数之和。令 $k$ 表示批处理进一个 TLP 的请求数量，因此 TLP 有效载荷为 $kS$ 字节，有效载荷比例为 $kS/(kS + O)$。\n\n测试了两种配置：\n- 配置 A：第 $1$ 代，通道数 $x1$，批处理因子 $k = 1$。\n- 配置 B：第 $4$ 代，通道数 $x4$，批处理因子 $k = 8$。\n\n计算已实现的稳态有效载荷吞吐量之比，定义为 $\\rho = T_{\\text{B}}/T_{\\text{A}}$。将最终结果表示为一个无单位的十进制值，并四舍五入到四位有效数字。", "solution": "用户提供的问题已经过分析并被认为是有效的。它科学地基于计算机硬件接口的原理，特别是 PCI Express 标准。该问题提法明确，提供了一个清晰的模型、所有必要的参数和一个单一、可确定的问题。其语言客观，设定自洽且一致。\n\n该问题要求计算两种不同 PCIe 配置的有效载荷吞吐量之比 $\\rho = T_{\\text{B}}/T_{\\text{A}}$。稳态有效载荷吞吐量 $T$ 的模型，被定义为有效原始链路比特率 $R_{\\text{eff}}$ 与传输比特中有效载荷比例 $F_{\\text{payload}}$ 的乘积。\n\n首先，我们形式化吞吐量 $T$ 的表达式。有效原始链路比特率 $R_{\\text{eff}}$ 是通道数 $L$、每通道符号率 $t$（以比特/秒为单位，因为 1 次传输 = 1 比特）和线路编码效率 $\\eta$ 的乘积。\n$$\nR_{\\text{eff}} = L \\times t \\times \\eta\n$$\n对于批处理因子为 $k$ 个请求，每个请求的有效载荷大小为 $S$，每个事务层数据包 (TLP) 的固定开销为 $O$ 的情况，有效载荷比例 $F_{\\text{payload}}$ 给出如下：\n$$\nF_{\\text{payload}}(k, S, O) = \\frac{kS}{kS + O}\n$$\n将这些结合起来，得到有效载荷吞吐量的通用模型：\n$$\nT(L, t, \\eta, k, S, O) = (L \\times t \\times \\eta) \\left( \\frac{kS}{kS + O} \\right)\n$$\n给定两种配置：\n\n配置 A：\n- 通道数：$L_{\\text{A}} = 1$\n- PCIe 代数：$1$，因此符号率为 $t_{\\text{A}} = t_{\\text{Gen1}} = 2.5 \\times 10^9 \\text{ s}^{-1}$\n- 编码：$8\\text{b}/10\\text{b}$，因此效率为 $\\eta_{\\text{A}} = 0.8$\n- 批处理因子：$k_{\\text{A}} = 1$\n\n配置 B：\n- 通道数：$L_{\\text{B}} = 4$\n- PCIe 代数：$4$，因此符号率为 $t_{\\text{B}} = t_{\\text{Gen4}} = 16.0 \\times 10^9 \\text{ s}^{-1}$\n- 编码：$128\\text{b}/130\\text{b}$，因此效率为 $\\eta_{\\text{B}} = 128/130$\n- 批处理因子：$k_{\\text{B}} = 8$\n\n共享参数：\n- 每个请求的有效载荷大小：$S = 512$ 字节\n- 固定的 TLP 开销：$O = 28$ 字节\n\n配置 A 的吞吐量 $T_{\\text{A}}$ 为：\n$$\nT_{\\text{A}} = (L_{\\text{A}} t_{\\text{A}} \\eta_{\\text{A}}) \\left( \\frac{k_{\\text{A}}S}{k_{\\text{A}}S + O} \\right)\n$$\n配置 B 的吞吐量 $T_{\\text{B}}$ 为：\n$$\nT_{\\text{B}} = (L_{\\text{B}} t_{\\text{B}} \\eta_{\\text{B}}) \\left( \\frac{k_{\\text{B}}S}{k_{\\text{B}}S + O} \\right)\n$$\n我们需要计算比率 $\\rho = T_{\\text{B}}/T_{\\text{A}}$：\n$$\n\\rho = \\frac{T_{\\text{B}}}{T_{\\text{A}}} = \\frac{(L_{\\text{B}} t_{\\text{B}} \\eta_{\\text{B}}) \\left( \\frac{k_{\\text{B}}S}{k_{\\text{B}}S + O} \\right)}{(L_{\\text{A}} t_{\\text{A}} \\eta_{\\text{A}}) \\left( \\frac{k_{\\text{A}}S}{k_{\\text{A}}S + O} \\right)}\n$$\n这个比率可以分解为两个部分：有效链路速率之比 $\\rho_{\\text{link}}$ 和有效载荷比例之比 $\\rho_{\\text{payload}}$。\n$$\n\\rho = \\left( \\frac{L_{\\text{B}} t_{\\text{B}} \\eta_{\\text{B}}}{L_{\\text{A}} t_{\\text{A}} \\eta_{\\text{A}}} \\right) \\times \\left( \\frac{ \\frac{k_{\\text{B}}S}{k_{\\text{B}}S + O} }{ \\frac{k_{\\text{A}}S}{k_{\\text{A}}S + O} } \\right) = \\rho_{\\text{link}} \\times \\rho_{\\text{payload}}\n$$\n首先，我们计算 $\\rho_{\\text{link}}$：\n$$\n\\rho_{\\text{link}} = \\frac{4 \\times (16.0 \\times 10^9) \\times \\frac{128}{130}}{1 \\times (2.5 \\times 10^9) \\times 0.8}\n$$\n分子和分母中的因子 $10^9$ 被约去。\n$$\n\\rho_{\\text{link}} = \\frac{4 \\times 16.0 \\times \\frac{128}{130}}{1 \\times 2.5 \\times 0.8} = \\frac{64 \\times \\frac{128}{130}}{2.0} = 32 \\times \\frac{128}{130} = 32 \\times \\frac{64}{65} = \\frac{2048}{65}\n$$\n接下来，我们计算 $\\rho_{\\text{payload}}$。我们首先为每种配置评估有效载荷项。\n对于配置 A ($k_{\\text{A}}=1$)：\n- 有效载荷：$k_{\\text{A}}S = 1 \\times 512 = 512$ 字节\n- 总 TLP 大小：$k_{\\text{A}}S + O = 512 + 28 = 540$ 字节\n- 有效载荷比例：$F_{\\text{A}} = \\frac{512}{540}$\n\n对于配置 B ($k_{\\text{B}}=8$)：\n- 有效载荷：$k_{\\text{B}}S = 8 \\times 512 = 4096$ 字节\n- 总 TLP 大小：$k_{\\text{B}}S + O = 4096 + 28 = 4124$ 字节\n- 有效载荷比例：$F_{\\text{B}} = \\frac{4096}{4124}$\n\n现在我们计算比率 $\\rho_{\\text{payload}} = F_{\\text{B}} / F_{\\text{A}}$：\n$$\n\\rho_{\\text{payload}} = \\frac{\\frac{4096}{4124}}{\\frac{512}{540}} = \\frac{4096}{4124} \\times \\frac{540}{512}\n$$\n我们可以重新整理和简化这个表达式：\n$$\n\\rho_{\\text{payload}} = \\frac{4096}{512} \\times \\frac{540}{4124} = 8 \\times \\frac{540}{4124}\n$$\n540 和 4124 都能被 4 整除：$540 = 4 \\times 135$ 且 $4124 = 4 \\times 1031$。\n$$\n\\rho_{\\text{payload}} = 8 \\times \\frac{135}{1031} = \\frac{1080}{1031}\n$$\n最后，我们通过将两个部分相乘来计算总比率 $\\rho$：\n$$\n\\rho = \\rho_{\\text{link}} \\times \\rho_{\\text{payload}} = \\frac{2048}{65} \\times \\frac{1080}{1031} = \\frac{2211840}{67015}\n$$\n执行除法运算得到数值：\n$$\n\\rho \\approx 33.005148...\n$$\n问题要求结果四舍五入到四位有效数字。\n$$\n\\rho \\approx 33.01\n$$\n这个最终值表示配置 B 的有效载荷吞吐量超过配置 A 的因子。这种增长是由于更快的物理链路（更高代数、更多通道）和将更多数据批处理到单个数据包中带来的协议效率提高（这减少了固定开销的比例影响）的组合所致。", "answer": "$$\\boxed{33.01}$$", "id": "3648064"}, {"introduction": "驱动程序设计常常涉及在相互竞争的目标之间取得平衡，例如性能与功耗。本练习将您置于一个能量受限的嵌入式系统情境中，您必须为一个传感器确定最佳的轮询频率 [@problem_id:3648008]。您将运用一个数学模型，在因唤醒设备而产生的能耗与应用程序所用数据的“陈旧度”之间找到最佳平衡点。", "problem": "一个由电池供电的嵌入式节点使用一个由设备驱动程序管理的内存映射输入/输出（I/O）传感器来采样一个物理量。该设备和中央处理器（CPU）都支持深度睡眠状态。为了读取传感器，驱动程序以间隔 $I$ 定期轮询它，通过向内存映射寄存器发出读取请求，这会导致传感器和CPU转换到活动状态，执行读取，然后返回睡眠。每个轮询周期都会产生一个固定的能量开销 $E_{w}$，该开销汇总了传感器唤醒、总线事务、CPU服务和返回睡眠的成本。在两次轮询之间，应用程序对最新的传感器值使用零阶保持，因此随着真实物理量的持续演变，所提供的值会变得陈旧。\n\n假设以下适用于该情境的基准：\n- 轮询速率为 $1/I$，因此由轮询唤醒贡献的平均能量速率是每次轮询的能量乘以轮询速率。\n- 在两次轮询之间，底层信号以斜率大小 $\\sigma$（单位/秒）近似线性漂移，因此在一次轮询后的时间 $s \\in [0, I]$，陈旧度大小约为 $\\sigma s$。在一个区间内，陈旧度平方的时间平均值是 $\\sigma^{2} s^{2}$ 在 $s \\in [0, I]$ 上的平均值。\n- 应用程序指定一个惩罚权重 $\\gamma$，它将时间平均的陈旧度平方转换为等效能量的成本速率，单位为焦耳/($\\text{unit}^{2}\\cdot\\text{s}$)。\n\n仅使用这些基准，通过对轮询唤醒引起的平均能量速率和陈旧度惩罚速率求和，从第一性原理推导出总稳态成本速率 $C(I)$ 作为轮询间隔 $I$ 的函数表达式。然后，确定使 $C(I)$ 最小化的 $I$ 值。\n\n使用以下参数值：\n- $E_{w} = 6.0 \\times 10^{-4}$ 焦耳/次轮询，\n- $\\sigma = 0.50$ 单位/秒，\n- $\\gamma = 2.0 \\times 10^{-3}$ 焦耳/($\\text{unit}^{2}\\cdot\\text{s}$)。\n\n以秒为单位表示最终的最优轮询间隔，并将答案四舍五入到 $4$ 位有效数字。", "solution": "用户提供了一个问题陈述，在尝试解决之前需要进行验证。\n\n### 第1步：提取已知条件\n- 轮询间隔：$I$\n- 每个轮询周期的固定能量开销：$E_w$\n- 轮询速率：$1/I$\n- 由轮询唤醒引起的平均能量速率：每次轮询的能量（$E_w$）乘以轮询速率（$1/I$）。\n- 信号漂移模型：在轮询之间近似线性。\n- 信号漂移的斜率大小：$\\sigma$（单位/秒）。\n- 一次轮询后时间 $s \\in [0, I]$ 时的陈旧度大小：$\\sigma s$。\n- 一个区间内陈旧度平方的时间平均值：$\\sigma^2 s^2$ 在 $s \\in [0, I]$ 上的平均值。\n- 惩罚权重：$\\gamma$（焦耳/($\\text{unit}^2 \\cdot \\text{s}$)）。\n- 总稳态成本速率 $C(I)$：由轮询唤醒引起的平均能量速率和陈旧度惩罚速率之和。\n- 参数值：\n  - $E_w = 6.0 \\times 10^{-4}$ 焦耳/次轮询\n  - $\\sigma = 0.50$ 单位/秒\n  - $\\gamma = 2.0 \\times 10^{-3}$ 焦耳/($\\text{unit}^2 \\cdot \\text{s}$)\n- 目标：推导 $C(I)$ 的表达式并确定使其最小化的 $I$ 值。最终的 $I$ 数值答案应以秒为单位并四舍五入到4位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n根据验证标准评估问题陈述。\n\n- **科学依据：** 该问题描述了嵌入式系统设计中功耗与数据质量（新鲜度）之间的标准优化权衡。该模型虽然简化（线性漂移、固定成本），但是一种公认的、科学合理的一阶分析方法。单位一致且具有物理意义。该问题基于工程学和微积分原理。\n- **适定性：** 该问题提供了构建成本函数并找到其最小值所需的所有必要定义、关系和参数。成本函数的结构（与 $I^{-1}$ 和 $I^2$ 成正比的项之和）已知具有唯一的正最小值，表明这是一个适定的优化问题。\n- **客观性：** 问题陈述使用了精确、技术性和无偏见的语言。\n\n问题没有表现出验证标准中列出的任何缺陷。它是科学合理的、可形式化的、完整的、可行的和适定的。\n\n### 第3步：结论与行动\n问题是**有效的**。将推导解决方案。\n\n总稳态成本速率 $C(I)$ 是两个组成部分之和：轮询引起的平均能量速率 $C_p(I)$ 和陈旧度惩罚速率 $C_s(I)$。\n$$C(I) = C_p(I) + C_s(I)$$\n\n首先，我们推导轮询引起的平均能量速率 $C_p(I)$ 的表达式。问题陈述指出，这是每次轮询的能量 $E_w$ 乘以轮询速率 $1/I$。\n$$C_p(I) = E_w \\cdot \\frac{1}{I} = \\frac{E_w}{I}$$\n单位是焦耳/秒，即瓦特，这是一个能量消耗的速率（功率）。\n\n接下来，我们推导陈旧度惩罚速率 $C_s(I)$ 的表达式。这被定义为惩罚权重 $\\gamma$ 乘以一个轮询区间内陈旧度平方的时间平均值。在一次轮询后，时间为 $s$（其中 $s \\in [0, I]$）时的陈旧度为 $\\sigma s$。陈旧度的平方是 $(\\sigma s)^2 = \\sigma^2 s^2$。\n\n在区间 $[0, I]$ 上陈旧度平方的时间平均值是陈旧度平方函数在该区间上的积分除以区间时长 $I$。\n$$\\langle S^2 \\rangle = \\frac{1}{I} \\int_{0}^{I} (\\sigma s)^2 \\, ds = \\frac{\\sigma^2}{I} \\int_{0}^{I} s^2 \\, ds$$\n我们计算这个积分：\n$$\\int_{0}^{I} s^2 \\, ds = \\left[ \\frac{s^3}{3} \\right]_{0}^{I} = \\frac{I^3}{3} - 0 = \\frac{I^3}{3}$$\n将此结果代回到平均值的表达式中：\n$$\\langle S^2 \\rangle = \\frac{\\sigma^2}{I} \\left( \\frac{I^3}{3} \\right) = \\frac{\\sigma^2 I^2}{3}$$\n那么，陈旧度惩罚速率为：\n$$C_s(I) = \\gamma \\cdot \\langle S^2 \\rangle = \\gamma \\frac{\\sigma^2 I^2}{3}$$\n\n结合这两个组成部分，我们得到总成本速率函数 $C(I)$：\n$$C(I) = \\frac{E_w}{I} + \\frac{\\gamma \\sigma^2 I^2}{3}$$\n\n为了找到使 $C(I)$ 最小化的轮询间隔 $I$，我们必须通过求 $C(I)$ 对 $I$ 的一阶导数并将其设为零来找到临界点。\n$$\\frac{dC}{dI} = \\frac{d}{dI} \\left( E_w I^{-1} + \\frac{\\gamma \\sigma^2}{3} I^2 \\right)$$\n$$\\frac{dC}{dI} = -E_w I^{-2} + \\frac{\\gamma \\sigma^2}{3} (2I) = -\\frac{E_w}{I^2} + \\frac{2 \\gamma \\sigma^2 I}{3}$$\n将导数设为零：\n$$-\\frac{E_w}{I^2} + \\frac{2 \\gamma \\sigma^2 I}{3} = 0$$\n$$\\frac{2 \\gamma \\sigma^2 I}{3} = \\frac{E_w}{I^2}$$\n为了解出 $I$，我们重新整理方程：\n$$I^3 = \\frac{3 E_w}{2 \\gamma \\sigma^2}$$\n$$I_{opt} = \\left( \\frac{3 E_w}{2 \\gamma \\sigma^2} \\right)^{1/3}$$\n\n为了确认这个 $I$ 值对应一个最小值，我们检查 $C(I)$ 的二阶导数：\n$$\\frac{d^2C}{dI^2} = \\frac{d}{dI} \\left( -E_w I^{-2} + \\frac{2 \\gamma \\sigma^2}{3} I \\right) = 2 E_w I^{-3} + \\frac{2 \\gamma \\sigma^2}{3} = \\frac{2 E_w}{I^3} + \\frac{2 \\gamma \\sigma^2}{3}$$\n由于 $E_w$、$\\gamma$ 和 $\\sigma$ 是正的物理常数，且轮询间隔 $I$ 必须为正，所以二阶导数中的两项都是正的。因此，$\\frac{d^2C}{dI^2} > 0$，这证实了 $C(I)$ 是凸函数，我们计算出的 $I_{opt}$ 是一个全局最小值。\n\n现在，我们将给定的数值代入 $I_{opt}$ 的表达式中：\n$E_w = 6.0 \\times 10^{-4}$ J\n$\\sigma = 0.50$ 单位/秒\n$\\gamma = 2.0 \\times 10^{-3}$ J/($\\text{unit}^2 \\cdot \\text{s}$)\n\n$$I_{opt} = \\left( \\frac{3 \\cdot (6.0 \\times 10^{-4})}{2 \\cdot (2.0 \\times 10^{-3}) \\cdot (0.50)^2} \\right)^{1/3}$$\n$$I_{opt} = \\left( \\frac{1.8 \\times 10^{-3}}{2 \\cdot (2.0 \\times 10^{-3}) \\cdot 0.25} \\right)^{1/3}$$\n$$I_{opt} = \\left( \\frac{1.8 \\times 10^{-3}}{1.0 \\times 10^{-3}} \\right)^{1/3}$$\n$$I_{opt} = (1.8)^{1/3}$$\n计算数值：\n$$I_{opt} \\approx 1.21644039 \\text{ s}$$\n根据问题陈述要求，四舍五入到4位有效数字：\n$$I_{opt} \\approx 1.216 \\text{ s}$$", "answer": "$$\\boxed{1.216}$$", "id": "3648008"}]}