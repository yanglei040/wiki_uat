{"hands_on_practices": [{"introduction": "要理解I/O操作的性能，首先需要剖析其完整路径。第一个练习将引导你追踪一个同步读请求，看它如何穿过操作系统的核心层次——从系统调用接口直至硬件。通过确定正确的测量点，你将学会如何分解端到端总延迟，这是系统性能分析师必备的一项基础技能 [@problem_id:3648623]。", "problem": "在一个类 Linux 操作系统中，一个单线程应用程序发起了一个同步文件读取系统调用。该请求按顺序穿过以下软件和硬件层：系统调用边界、文件系统层、块 I/O 层、设备驱动程序和存储设备。为便于分析，假设此路径仅发生一次，没有重试，并且各层按顺序执行，没有重叠。你可以在内核和驱动程序边界放置跟踪探针。你的目标是设计测量点，并使用提供的跟踪数据来计算端到端延迟。\n\n任务：\n- 提出具体的测量点，在 I/O 路径上每个相邻层之间的边界以及设备完成信号处各设置一个，以便将每个层所花费的时间捕获为不重叠的时间间隔，并且各层时间之和等于从系统调用入口到返回用户空间的总时间。简要说明为什么你选择的点使各层持续时间具有可加性和不相交性。\n- 一次内核跟踪捕获了这样一个 I/O 的以下时间戳（按时间顺序排列）。所有时间戳都以微秒为单位，相对于一个任意的参考点。设有序点为 $P_{0}, P_{1}, P_{2}, P_{3}, P_{4}, P_{5}, P_{6}, P_{7}, P_{8}, P_{9}$，其数值为：\n  - $P_{0} = 0$\n  - $P_{1} = 8$\n  - $P_{2} = 33$\n  - $P_{3} = 73$\n  - $P_{4} = 85$\n  - $P_{5} = 285$\n  - $P_{6} = 300$\n  - $P_{7} = 310$\n  - $P_{8} = 319$\n  - $P_{9} = 325$\n  - 假设 $P_{0}$ 对应于系统调用进入内核的时刻，$P_{9}$ 对应于系统调用返回用户空间的时刻。中间点对应于内部层边界和设备完成，与你所提出的良好插桩的 I/O 路径一致。\n- 使用你提出的测量点映射到给定的 $P_{i}$ 序列，计算从系统调用入口到返回的端到端延迟。\n\n以微秒表示最终延迟，并将你的答案四舍五入到四位有效数字。", "solution": "首先对问题陈述进行严格的验证过程。\n\n### 步骤 1：提取给定信息\n- **应用程序**：一个单线程应用程序发起了一个同步文件读取系统调用。\n- **操作系统**：一个类 Linux 操作系统。\n- **I/O 路径层**：该请求按顺序穿过：系统调用边界、文件系统层、块 I/O 层、设备驱动程序和存储设备。\n- **执行模型**：各层按顺序执行，没有重叠；路径发生一次，没有重试。\n- **测量任务**：在每个边界提出具体的测量点，以捕获每个层所花费的时间作为不重叠的时间间隔，使得它们的总和等于总时间。\n- **跟踪数据**：一个按时间顺序排列的时间戳序列 $P_{0}, P_{1}, \\dots, P_{9}$，单位为微秒 ($\\mu s$)。\n  - $P_{0} = 0$\n  - $P_{1} = 8$\n  - $P_{2} = 33$\n  - $P_{3} = 73$\n  - $P_{4} = 85$\n  - $P_{5} = 285$\n  - $P_{6} = 300$\n  - $P_{7} = 310$\n  - $P_{8} = 319$\n  - $P_{9} = 325$\n- **时间戳映射**：\n  - $P_{0}$ 对应于系统调用进入内核。\n  - $P_{9}$ 对应于系统调用返回用户空间。\n  - 中间点 $P_1, \\dots, P_8$ 对应于内部层边界和设备完成。\n- **计算任务**：计算从系统调用入口到返回的端到端延迟。\n- **输出要求**：以微秒表示最终延迟，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的给定信息进行验证\n根据既定的验证标准对问题进行评估。\n- **科学依据**：问题描述了 I/O 请求处理路径，这是操作系统中的一个基本概念，也是计算机科学与工程的核心学科。指定的层（文件系统、块 I/O、设备驱动程序）以及使用探针进行跟踪的概念都是标准的且符合事实。\n- **适定性**：问题是适定的。它要求对测量点进行概念设计，并进行一项具体计算，而所有必要的数据（$P_0$ 和 $P_9$）都已明确提供。\n- **客观性**：问题以精确、技术性的语言陈述，没有主观性或歧义。\n- **缺陷分析**：\n  1.  **科学或事實上的不健全**：无。该模型是用于分析的有效简化。所提供的时间戳对于像 SSD 这样的快速存储设备是合理的。\n  2.  **不可形式化或不相关**：问题是可形式化的，并且与其所述主题——*操作系统入门*中的*I/O 请求处理路径*——直接相关。\n  3.  **不完整或矛盾的设置**：无。问题提供了计算端到端延迟所需的所有信息。定义测量点的概念性任务是自洽的，并且与计算不冲突。\n  4.  **不切实际或不可行**：无。物理模型和数据与现代硬件的实际情况一致。\n  5.  **不适定或结构不良**：无。问题清晰，并允许一个唯一的、稳定的解。\n  6.  **故作高深、琐碎或同义反复**：最终的计算非常直接，因为它直接从提供的开始和结束时间戳导出。然而，这被嵌入到一个需要操作系统 I/O 栈概念知识的任务中。这种结构同时考验了仔细阅读和领域知识，不应被视为缺陷，而是一种有效的教学方法。整个问题并非微不足道。\n  7.  **超出科学可验证性范围**：无。概念和计算都是可验证的。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。将提供一个合理的解决方案。\n\n---\n\n### 解决方案\n\n问题要求完成两项主要任务：首先，提出一组测量点，将总 I/O 延迟划分为与 I/O 栈不同层相对应的、不相交且可相加的分量；其次，使用提供的跟踪数据计算端到端延迟。\n\n#### 任务 1：提出测量点\n\n一个同步 I/O 请求包括一个请求路径（从软件栈向下到硬件）和一个完成路径（从硬件向上返回到用户进程）。为了捕获在每个不同阶段花费的时间，我们必须在每个层的入口和出口点为两个路径都放置探针。设测量点用 $M_i$ 表示。\n\n1.  $M_0$: **系统调用入口**。执行上下文从用户模式切换到内核模式以处理读系统调用的时刻。这对应于给定的 $P_0$。\n2.  $M_1$: **文件系统入口（请求路径）**。通用系统调用处理程序已将请求分派给虚拟文件系统 (VFS) 层。区间 $[M_0, M_1]$ 代表系统调用前端开销。\n3.  $M_2$: **块 I/O 层入口（请求路径）**。文件系统已完成其任务（例如，路径解析、权限检查、将文件偏移量转换为逻辑块地址）并向块 I/O 层发出请求。区间 $[M_1, M_2]$ 是在请求路径上文件系统中所花费的时间。\n4.  $M_3$: **设备驱动程序入口（请求路径）**。块 I/O 层已处理请求（例如，I/O 调度、请求合并）并将其分派给相应的设备驱动程序。区间 $[M_2, M_3]$ 是在块 I/O 层中花费的时间。\n5.  $M_4$: **向硬件发出请求**。设备驱动程序已使用 I/O 命令对硬件控制器进行编程。此时，当设备忙碌时，CPU可以被调度到另一个任务。区间 $[M_3, M_4]$ 是在请求路径上驱动程序中花费的时间。\n6.  $M_5$: **设备完成中断**。存储设备已完成读取操作，并通过中断向 CPU 发出信号。区间 $[M_4, M_5]$ 代表硬件服务时间，包括任何设备上的排队时间。\n7.  $M_6$: **通知块 I/O 层（完成路径）**。设备驱动程序的中断处理程序已完成其工作（例如，检查状态、确认中断）并将完成信号向上传播到块 I/O 层。区间 $[M_5, M_6]$ 是驱动程序内的中断处理时间。\n8.  $M_7$: **通知文件系统（完成路径）**。块 I/O 层已完成其后处理（例如，唤醒等待的进程、处理请求队列更新）并通知文件系统。区间 $[M_6, M_7]$ 是块 I/O 层的完成处理时间。\n9.  $M_8$: **系统调用终结**。文件系统已完成其最终任务（例如，将读取的数据从内核缓冲区复制到用户空间缓冲区、更新文件元数据如访问时间）。系统调用现在准备返回。区间 $[M_7, M_8]$ 是文件系统的完成处理时间。\n10. $M_9$: **系统调用返回**。内核完成系统调用执行，上下文切换回用户模式，解除应用程序的阻塞。这对应于给定的 $P_9$。区间 $[M_8, M_9]$ 代表系统调用后端和上下文切换开销。\n\n这十个测量点 $M_0$ 到 $M_9$ 定义了九个连续的、不重叠的时间间隔。每个阶段 $k$ 的持续时间为 $T_k = M_k - M_{k-1}$，其中 $k \\in \\{1, 2, \\dots, 9\\}$。总的端到端延迟是这些持续时间的总和：\n$$ \\text{Total Latency} = \\sum_{k=1}^{9} (M_k - M_{k-1}) $$\n这形成了一个伸缩求和：\n$$ (M_1 - M_0) + (M_2 - M_1) + \\dots + (M_9 - M_8) = M_9 - M_0 $$\n因此，这些不相交区间的持续时间之和恰好等于从系统调用入口（$M_0$）到系统调用返回（$M_9$）所经过的总时间，满足了问题的要求。\n\n#### 任务 2：计算端到端延迟\n\n问题要求计算从系统调用入口到返回的端到端延迟。根据定义，这是这两个事件之间经过的总时间。\n\n给定的跟踪数据包括：\n- $P_0 = 0 \\, \\mu s$：系统调用入口的时间戳。\n- $P_9 = 325 \\, \\mu s$：系统调用返回的时间戳。\n\n中间点 $P_1$ 到 $P_8$ 对应于上面提出的内部测量点 $M_1$ 到 $M_8$。虽然这些点对于分析单个层的性能是必要的，但计算*总端到端延迟*并不需要它们。\n\n端到端延迟 $L$ 直接计算为最终和初始时间戳之间的差值：\n$$ L = P_9 - P_0 $$\n代入给定值：\n$$ L = 325 \\, \\mu s - 0 \\, \\mu s = 325 \\, \\mu s $$\n问题要求答案四舍五入到四位有效数字。数字 $325$ 有三位有效数字。要用四位有效数字表示这个值，我们将其写为 $325.0$。\n\n因此，端到端延迟为 $325.0 \\, \\mu s$。", "answer": "$$\n\\boxed{325.0}\n$$", "id": "3648623"}, {"introduction": "并非所有I/O请求的成本都相同；通过避免访问缓慢的存储设备，许多请求可以被更快地处理。本练习将介绍页缓存这一关键的操作系统优化，并使用概率论来建模其对性能的影响。你将通过区分缓存命中和缓存未命中这两种不同结果，来推导单次读请求的期望延迟 $E[L]$，从而掌握一个用于分析平均性能的强大而简洁的模型 [@problem_id:3648639]。", "problem": "一个通用操作系统上的进程发出针对固定大小页面的同步读取请求。该操作系统采用页面缓存：对于每次读取，所请求的页面要么已在内存中（缓存命中），要么必须从存储设备中获取（缓存未命中）。考虑单次读取的输入/输出（I/O）请求处理路径如下：\n- 缓存命中时，路径为：应用程序 $\\rightarrow$ 内核页面缓存 $\\rightarrow$ 内存复制到用户空间。端到端延迟为一个恒定的 $L_{\\text{cache}}$。\n- 缓存未命中时，路径为：应用程序 $\\rightarrow$ 虚拟文件系统层 $\\rightarrow$ 文件系统 $\\rightarrow$ 块层 $\\rightarrow$ 设备驱动程序 $\\rightarrow$ 存储设备 $\\rightarrow$ 通过内核返回完成并进行内存复制。端到端延迟为一个恒定的 $L_{\\text{device}}$。\n\n为进行高级分析，我们采用以下科学上合理且常用的建模假设：\n- 每次读取独立地具有缓存命中概率 $\\Pr(\\text{hit}) = p$ 和缓存未命中概率 $\\Pr(\\text{miss}) = 1 - p$。\n- 延迟 $L_{\\text{cache}}$ 和 $L_{\\text{device}}$ 分别是各自路径的确定性常数。\n- 不存在排队重叠或并发；孤立地分析单次读取。\n\n从概率论中期望的公理化定义和全期望定律出发，推导单次读取的期望延迟 $E[L]$ 关于 $p$、$L_{\\text{cache}}$ 和 $L_{\\text{device}}$ 的通用表达式。然后，使用参数 $p = 0.93$、$L_{\\text{cache}} = 0.12$ 毫秒和 $L_{\\text{device}} = 7.4$ 毫秒，对您的表达式进行数值计算。将最终数值答案四舍五入到四位有效数字。以毫秒为单位表示最终延迟。", "solution": "问题陈述具有科学依据，提法恰当，客观，并包含得出唯一解所需的所有信息。所描述的模型是计算机操作系统中I/O延迟的标准简化表示，给定的参数是现实的。因此，该问题是有效的，我们可以继续求解。\n\n设 $L$ 为表示单次读取请求端到端延迟的随机变量。问题描述了这次读取的两个互斥且穷尽的结果：缓存命中或缓存未命中。设 $H$ 表示缓存命中的事件，$M$ 表示缓存未命中的事件。事件集合 $\\{H, M\\}$ 构成了样本空间的一个划分。\n\n根据问题陈述，这些事件的概率如下：\n- 缓存命中的概率为 $\\Pr(H) = p$。\n- 缓存未命中的概率为 $\\Pr(M) = 1 - p$。\n\n读取的延迟是取决于发生哪个事件的确定性常数：\n- 如果发生缓存命中（事件 $H$），延迟为 $L | H = L_{\\text{cache}}$。\n- 如果发生缓存未命中（事件 $M$），延迟为 $L | M = L_{\\text{device}}$。\n\n我们的任务是从基本原理出发，特别是全期望定律，推导期望延迟 $E[L]$。全期望定律指出，对于任意随机变量 $X$ 和样本空间的一个划分 $\\{A_i\\}$，$X$ 的期望值由下式给出：\n$$E[X] = \\sum_i E[X | A_i] \\Pr(A_i)$$\n\n将此定律应用于我们的随机变量 $L$ 和划分 $\\{H, M\\}$，我们可以将期望延迟写为：\n$$E[L] = E[L | H] \\Pr(H) + E[L | M] \\Pr(M)$$\n\n接下来，我们必须计算条件期望 $E[L | H]$ 和 $E[L | M]$。一个以概率 $1$ 取单个值 $c$ 的离散随机变量 $Y$ 的期望的公理化定义是 $E[Y] = c \\cdot 1 = c$。\n在我们的情况下，随机变量‘给定缓存命中时的延迟’($L|H$) 只取唯一的常数值 $L_{\\text{cache}}$。因此，其期望值为：\n$$E[L | H] = L_{\\text{cache}}$$\n类似地，随机变量‘给定缓存未命中时的延迟’($L|M$) 只取唯一的常数值 $L_{\\text{device}}$。其期望值为：\n$$E[L | M] = L_{\\text{device}}$$\n\n将这些条件期望和给定的概率代入 $E[L]$ 的表达式中：\n$$E[L] = (L_{\\text{cache}}) \\cdot \\Pr(H) + (L_{\\text{device}}) \\cdot \\Pr(M)$$\n这就得出了期望延迟的通用表达式：\n$$E[L] = p \\cdot L_{\\text{cache}} + (1 - p) \\cdot L_{\\text{device}}$$\n\n现在，我们使用提供的参数对此表达式进行数值计算：\n- $p = 0.93$\n- $L_{\\text{cache}} = 0.12$ 毫秒\n- $L_{\\text{device}} = 7.4$ 毫秒\n\n将这些值代入我们推导出的公式中：\n$$E[L] = (0.93) \\cdot (0.12) + (1 - 0.93) \\cdot (7.4)$$\n$$E[L] = (0.93) \\cdot (0.12) + (0.07) \\cdot (7.4)$$\n\n我们分别计算每一项：\n- 缓存命中的贡献：$(0.93) \\cdot (0.12) = 0.1116$ 毫秒。\n- 缓存未命中的贡献：$(0.07) \\cdot (7.4) = 0.518$ 毫秒。\n\n将两项贡献相加，得到总期望延迟：\n$$E[L] = 0.1116 + 0.518 = 0.6296 \\text{ milliseconds}$$\n\n问题要求将最终答案四舍五入到四位有效数字。计算出的值 $0.6296$ 已经恰好有四位有效数字（数字 $6$、$2$、$9$、$6$），因此無需進一步四舍五入。", "answer": "$$\\boxed{0.6296}$$", "id": "3648639"}, {"introduction": "我们在上一个模型中使用的缓存命中率并非一成不变的常数，它是由访问模式和缓存替换策略共同决定的动态结果。这个动手模拟练习要求你实现经典的“最近最少使用”（LRU）策略，以观察缓存性能如何动态变化。通过模拟与缓存容量匹配良好以及超出容量的工作负载，你将对“颠簸”（thrashing）这一破坏性现象获得具体理解——在这种状态下，系统将大部分时间用于处理缓存未命中，而非执行有效工作 [@problem_id:3648676]。", "problem": "您需要实现一个完整的仿真，模拟在使用最近最少使用（LRU）驱逐策略的页面缓存下，输入/输出（I/O）请求的处理路径。其目的是探究页面缓存的驱逐决策如何影响未来的 I/O 路径，特别是为了展示和量化“颠簸”现象，即重复的驱逐操作导致 I/O 未命中和更长的 I/O 路径。\n\n本问题的基本依据包括以下来自操作系统的经过充分检验的事实和定义：\n- 页面缓存持有一组有限的内存页面，每个页面由一个非负整数标识。容量以页面数量衡量，表示为 $C$。\n- 当必须将一个新页面插入已满的缓存时，最近最少使用（LRU）策略会驱逐最长时间未被使用的页面。\n- 对于页面 $p$ 的 I/O 请求，当 $p$ 存在于缓存中（缓存命中）时，遵循一条较短的内存路径；当 $p$ 不在缓存中（缓存未命中）时，则遵循一条到磁盘的较长存储路径。我们用抽象时间单位来模拟每次请求的成本：缓存命中产生 $t_h$ 的成本，缓存未命中产生 $t_m$ 的成本，且 $t_m \\gt t_h$。\n- 颠簸（Thrashing）是指工作集暂时或持续性地超过容量，导致驱逐频繁发生，从而引起重复的未命中。\n\n您必须编写一个程序，该程序：\n- 使用 LRU 策略，对一个页面读取 I/O 请求序列 $S$ 模拟一个容量为 $C$ 的页面缓存。\n- 对于 $S$ 中的每个请求，判断它是缓存命中还是未命中，相应地更新 LRU 状态，并且在缓存已满的情况下发生未命中时，执行一次驱逐。\n- 计算以下指标：\n  - 总时间 $T$，以抽象时间单位计，为所有单次请求成本之和。\n  - 命中率 $H$，以小数形式表示，定义为 $H = \\frac{h}{L}$，其中 $h$ 是命中次数，$L$ 是 $S$ 的长度。\n  - 未命中率 $M$，以小数形式表示，定义为 $M = \\frac{m}{L}$，其中 $m$ 是未命中次数，$L$ 是 $S$ 的长度。\n  - 总驱逐次数 $E$，即在缓存已满时发生未命中且必须驱逐一个页面的次数。\n\n以上所有量都必须严格通过仿真计算得出；不允许使用任何捷径。\n\n请使用以下参数值的测试套件，它们探究了 LRU 策略下 I/O 路径的不同方面：\n- 测试用例 1（理想路径，工作集能装入缓存）：\n  - 缓存容量 $C = 4$，命中成本 $t_h = 1$，未命中成本 $t_m = 10$。\n  - 序列 $S_1$ 长度为 $L_1 = 20$，是模式 $[0, 1, 2, 3]$ 重复 $5$ 个周期的结果。\n- 测试用例 2（边界颠簸：循环工作集刚好大于缓存）：\n  - 缓存容量 $C = 4$，命中成本 $t_h = 1$，未命中成本 $t_m = 10$。\n  - 序列 $S_2$ 长度为 $L_2 = 20$，是模式 $[0, 1, 2, 3, 4]$ 重复 $4$ 个周期的结果。\n- 测试用例 3（局部性突发然后中断再恢复）：\n  - 缓存容量 $C = 4$，命中成本 $t_h = 1$，未命中成本 $t_m = 10$。\n  - 序列 $S_3$ 长度为 $L_3 = 38$，由三个阶段组成：\n    - 阶段 A：重复 $[10, 11, 12]$ 共 $6$ 个周期（长度 $18$）。\n    - 阶段 B：序列 $[100, 101, 102, 103, 100, 101, 102, 103]$（长度 $8$）。\n    - 阶段 C：重复 $[10, 11, 12]$ 共 $4$ 个周期（长度 $12$）。\n- 测试用例 4（边缘情况：最小容量，交替请求）：\n  - 缓存容量 $C = 1$，命中成本 $t_h = 1$，未命中成本 $t_m = 10$。\n  - 序列 $S_4$ 长度为 $L_4 = 20$，是模式 $[0, 1]$ 重复 $10$ 个周期的结果。\n\n输出要求：\n- 您的程序必须生成单行输出，包含一个类 JSON 的列表的列表。对于每个测试用例 $i \\in \\{1, 2, 3, 4\\}$，按顺序输出列表 $[T_i, H_i, M_i, E_i]$，其中：\n  - $T_i$ 是一个浮点数，四舍五入到三位小数。\n  - $H_i$ 和 $M_i$ 是浮点数，四舍五入到六位小数。\n  - $E_i$ 是一个整数。\n- 整体输出必须是单行形式：$[[T_1,H_1,M_1,E_1],[T_2,H_2,M_2,E_2],[T_3,H_3,M_3,E_3],[T_4,H_4,M_4,E_4]]$，不含空格。", "solution": "### LRU 仿真原理\n本问题要求模拟一个采用最近最少使用（LRU）策略的页面缓存。LRU 的核心思想是，当缓存需要腾出空间时，应驱逐最长时间未被访问过的页面。为了实现这一点，我们需要追踪缓存中每个页面的使用顺序。\n\n我们将使用一个列表或动态数组来表示缓存，其中列表的头部（索引0）代表最近使用的（MRU）页面，尾部代表最近最少使用的（LRU）页面。\n\n对于请求序列中的每个页面 `p`，算法如下：\n1.  **查找**: 检查 `p` 是否已在缓存列表中。\n2.  **命中**: 如果找到 `p`，这是一个缓存命中。\n    -   增加命中计数，并将命中成本 `t_h` 加入总时间。\n    -   将页面 `p` 从其当前位置移动到列表的头部，以标记其为最近使用的。\n3.  **未命中**: 如果未找到 `p`，这是一个缓存未命中。\n    -   增加未命中计数，并将未命中成本 `t_m` 加入总时间。\n    -   **如果缓存已满** (列表大小等于容量 `C`)：\n        -   增加驱逐计数。\n        -   移除列表尾部的页面（LRU 页面）。\n    -   **将新页面 `p` 插入**到列表的头部。\n\n在处理完整个序列后，根据总命中数 `h`、总未命中数 `m` 和序列总长度 `L` 计算命中率 `H = h/L` 和未命中率 `M = m/L`。\n\n### 详细仿真与计算\n\n#### 测试用例 1\n- $C = 4$, $t_h = 1$, $t_m = 10$\n- $S_1 = [0, 1, 2, 3, 0, 1, 2, 3, \\dots]$ ($L_1 = 20$)\n- **仿真**:\n  - `req 0`: 未命中。缓存: `[0]`。\n  - `req 1`: 未命中。缓存: `[1, 0]`。\n  - `req 2`: 未命中。缓存: `[2, 1, 0]`。\n  - `req 3`: 未命中。缓存: `[3, 2, 1, 0]`。\n  - `req 0`: 命中。缓存: `[0, 3, 2, 1]`。\n  - `req 1`: 命中。缓存: `[1, 0, 3, 2]`。\n  - 随后的16次请求都是命中，因为工作集（页面0,1,2,3）完全装入缓存。\n- **指标**:\n  - 未命中数 $m_1 = 4$ (初始冷启动)。\n  - 命中数 $h_1 = 16$。\n  - 驱逐数 $E_1 = 0$。\n  - 总时间 $T_1 = 4 \\times 10 + 16 \\times 1 = 56$。\n  - 命中率 $H_1 = 16 / 20 = 0.8$。\n  - 未命中率 $M_1 = 4 / 20 = 0.2$。\n- **结果**: $[56.000, 0.800000, 0.200000, 0]$\n\n#### 测试用例 2\n- $C = 4$, $t_h = 1$, $t_m = 10$\n- $S_2 = [0, 1, 2, 3, 4, 0, 1, 2, 3, 4, \\dots]$ ($L_2 = 20$)\n- **仿真 (颠簸)**: 工作集大小为5，大于缓存容量4。\n  - 前4次请求 (0, 1, 2, 3) 是未命中，填满缓存: `[3, 2, 1, 0]`。\n  - `req 4`: 未命中，驱逐 `0`。缓存: `[4, 3, 2, 1]`。\n  - `req 0`: 未命中，驱逐 `1`。缓存: `[0, 4, 3, 2]`。\n  - 此模式持续，每个请求都是未命中，因为它要访问的页面总是在上一个周期被驱逐。\n- **指标**:\n  - 未命中数 $m_2 = 20$。\n  - 命中数 $h_2 = 0$。\n  - 驱逐数 $E_2 = 16$ (前4次未命中不产生驱逐)。\n  - 总时间 $T_2 = 20 \\times 10 = 200$。\n  - 命中率 $H_2 = 0 / 20 = 0.0$。\n  - 未命中率 $M_2 = 20 / 20 = 1.0$。\n- **结果**: $[200.000, 0.000000, 1.000000, 16]$\n\n#### 测试用例 3\n- $C = 4$, $t_h = 1$, $t_m = 10$\n- $S_3$ 长度为 38。\n- **阶段 A (18次访问, `[10,11,12]`重复6次)**:\n  - 前3次请求 (10, 11, 12) 是未命中。\n  - 之后15次都是命中。\n  - A阶段: 3次未命中, 15次命中, 0次驱逐。时间: $3 \\times 10 + 15 \\times 1 = 45$。\n  - 结束时缓存: `[12, 11, 10]`。\n- **阶段 B (8次访问, `[100,101,102,103,100,101,102,103]`)**:\n  - 缓存: `[12, 11, 10]`。\n  - `req 100`: 未命中。缓存: `[100, 12, 11, 10]`。\n  - `req 101`: 未命中，驱逐`10`。缓存: `[101, 100, 12, 11]`。(E=1)\n  - `req 102`: 未命中，驱逐`11`。缓存: `[102, 101, 100, 12]`。(E=2)\n  - `req 103`: 未命中，驱逐`12`。缓存: `[103, 102, 101, 100]`。(E=3)\n  - 之后4次请求 (100, 101, 102, 103) 都是命中。\n  - B阶段: 4次未命中, 4次命中, 3次驱逐。时间: $4 \\times 10 + 4 \\times 1 = 44$。\n  - 结束时缓存: `[103, 102, 101, 100]`。\n- **阶段 C (12次访问, `[10,11,12]`重复4次)**:\n  - 缓存: `[103, 102, 101, 100]`。\n  - 前3次请求 (10, 11, 12) 都是未命中，分别驱逐 100, 101, 102。(E=3+3=6)\n  - 之后9次都是命中。\n  - C阶段: 3次未命中, 9次命中, 3次驱逐。时间: $3 \\times 10 + 9 \\times 1 = 39$。\n- **总指标**:\n  - $h_3 = 15 + 4 + 9 = 28$\n  - $m_3 = 3 + 4 + 3 = 10$\n  - $E_3 = 0 + 3 + 3 = 6$\n  - $T_3 = 45 + 44 + 39 = 128$\n  - $H_3 = 28 / 38 \\approx 0.736842$\n  - $M_3 = 10 / 38 \\approx 0.263158$\n- **结果**: $[128.000, 0.736842, 0.263158, 6]$\n\n#### 测试用例 4\n- $C = 1$, $t_h = 1$, $t_m = 10$\n- $S_4 = [0, 1, 0, 1, \\dots]$ ($L_4 = 20$)\n- **仿真**: 缓存容量只有1。\n  - `req 0`: 未命中。缓存: `[0]`。\n  - `req 1`: 未命中，驱逐`0`。缓存: `[1]`。\n  - `req 0`: 未命中，驱逐`1`。缓存: `[0]`。\n  - 每个请求都会导致未命中并驱逐前一个页面。\n- **指标**:\n  - 未命中数 $m_4 = 20$。\n  - 命中数 $h_4 = 0$。\n  - 驱逐数 $E_4 = 19$ (第一次未命中不产生驱逐)。\n  - 总时间 $T_4 = 20 \\times 10 = 200$。\n  - 命中率 $H_4 = 0 / 20 = 0.0$。\n  - 未命中率 $M_4 = 20 / 20 = 1.0$。\n- **结果**: $[200.000, 0.000000, 1.000000, 19]$\n\n### 结果汇总\n根据上述仿真，四个测试用例的结果如下：\n1.  $[56.000, 0.800000, 0.200000, 0]$\n2.  $[200.000, 0.000000, 1.000000, 16]$\n3.  $[128.000, 0.736842, 0.263158, 6]$\n4.  $[200.000, 0.000000, 1.000000, 19]$", "answer": "[[56.000,0.800000,0.200000,0],[200.000,0.000000,1.000000,16],[128.000,0.736842,0.263158,6],[200.000,0.000000,1.000000,19]]", "id": "3648676"}]}