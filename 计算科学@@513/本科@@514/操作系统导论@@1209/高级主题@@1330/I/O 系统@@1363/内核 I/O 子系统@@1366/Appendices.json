{"hands_on_practices": [{"introduction": "理论知识与实际编程之间往往存在鸿沟。本练习旨在通过剖析一个经典的I/O场景来弥合这一差距：当一个`read()`系统调用被信号中断时会发生什么？通过分析这个在POSIX系统中无处不在的边缘情况，你将深入理解内核与用户空间之间的交互契约，并学会如何编写能够优雅处理“短读”和`EINTR`错误的健壮代码。", "problem": "一个类 Unix 操作系统中的进程使用可移植操作系统接口 (POSIX) 内核输入/输出子系统从一个阻塞管道中读取数据。该进程使用`sigaction()`为`SIGALRM`安装了一个信号处理程序，但没有设置`SA_RESTART`标志，并启动一个间隔计时器，在 $t=5$ 毫秒后发送`SIGALRM`信号。然后，该进程在一个管道`fd`上调用`read(fd, buf, n)`，其中 $n=4096$ 字节，而该管道的内核管道缓冲区当前存有 $k=2500$ 字节的未读数据。当消费者正在读取时，生产者进程继续向管道中写入任意大小的记录。假设没有文件结束条件，并且管道随时间推移保持可读。\n\n基本事实与定义：\n- 可移植操作系统接口 (POSIX) 对`read()`的定义规定，内核尝试传输最多 $n$ 个字节，并返回 $r \\ge 0$（实际传输的字节数），或者在出错时返回 -1 并设置`errno`。如果在任何字节被传输之前，一个信号被递送并中断了`read()`调用，则`read()`返回 -1 并将`errno`设置为`EINTR`。如果在信号中断之前已经传输了一些字节，则`read()`返回已传输的字节数，并且不设置`errno`。\n- `SA_RESTART`标志请求在某些被中断的系统调用被已处理的信号中断时自动重启它们，通常仅在尚未传输任何数据的情况下；重启并不能保证在重启的调用中恰好会传递 $n$ 个字节。\n- 在非阻塞模式 (`O_NONBLOCK`) 下，如果没有数据立即可用，`read()`可能会返回 -1 并将`errno`设置为`EAGAIN`；如果在任何传输开始前发生中断，信号中断仍然可能导致`errno` = `EINTR`。\n- 由`select()`或`poll()`指示的可读性意味着至少有一个字节可以在不阻塞的情况下被读取，但并不保证后续的`read()`调用将返回特定数量的字节。\n\n一个常见的用户空间重试模式是循环直到读取到目标字节数：重复调用`read()`并累加总和直到其等于 $n$，并在`errno` = `EINTR`时重试。考虑信号、可变大小记录和非阻塞模式与此重试模式相互作用的边缘情况。\n\n关于内核对所述短读的处理以及重试语义中潜在的用户空间错误的以下陈述中，哪些是正确的？\n\nA. 如果未设置`SA_RESTART`并且在内核已将一些字节从管道复制到`buf`后递送了`SIGALRM`信号，那么`read()`返回已复制的字节数（例如，如果复制了 $k=2500$ 字节，则 $r=2500$），而不设置`errno`，并且管道的读取指针前进 $r$ 字节。\n\nB. 当设置了`SA_RESTART`时，被中断的`read()`将被透明地重启，直到返回所请求的全部 $n$ 字节（除非遇到文件末尾），因此用户空间可以假设只要使用了`SA_RESTART`，$r$ 就等于 $n$。\n\nC. 对于面向流的描述符，如管道和传输控制协议 (TCP) 套接字，一个将 $r$ 累加直到等于 $n$ 的重试循环在语义上总是安全的，不会引入微妙的错误，因为内核会保留顺序，并且没有可被破坏的消息边界。\n\nD. 在`O_NONBLOCK`模式下，如果在任何字节被复制之前`read()`被信号中断，即使有可读字节，它也可能返回 -1 并将`errno`设置为`EINTR`；在重试循环中将`EINTR`视为致命条件可能导致用户空间丢弃本可以读取的数据。\n\nE. 在每次`read()`之前使用`select()`或`poll()`等待可读性可保证后续的`read(fd, buf, n)`调用将至少返回 $n$ 字节，除非到达文件末尾，因此在检查就绪状态时，重试到 $n$ 的循环是不必要的。", "solution": "问题陈述已经过验证，并且是合理的。这是一个关于类 Unix 操作系统中 POSIX 输入/输出子系统行为的、定义明确、有科学依据且客观的问题，这是操作系统入门课程中的一个标准主题。所描述的场景是现实的，提供的定义是对 POSIX 标准的准确表述。\n\n问题的核心涉及对一个阻塞管道的`read()`系统调用，该调用被一个信号中断。关键变量是请求的字节数 $n=4096$ 和管道中初始可用的字节数 $k=2500$。信号处理程序在安装时没有设置`SA_RESTART`标志。我们将根据所提供的设置和基本事实来分析每个选项。\n\n### 选项 A 分析\n\n该选项描述了当一个信号在一些数据已经传输后中断`read()`调用时的结果。\n问题陈述指出，进程在一个包含 $k=2500$ 字节的阻塞管道上调用`read(fd, buf, 4096)`。由于请求的数量 $n=4096$ 大于可用的数量 $k=2500$，内核将首先将这 $2500$ 个可用字节从管道缓冲区复制到用户空间缓冲区 `buf` 中。在这次部分传输之后，因为文件描述符是一个阻塞管道，系统调用将会阻塞，等待生产者写入更多数据。\n\n问题指明，一个`SIGALRM`信号在 $t=5$ 毫秒后被递送，并且信号处理程序安装时没有设置`SA_RESTART`标志。这个信号将在系统调用阻塞时中断它。被中断的`read()`的行为取决于中断相对于数据传输发生的时间。\n\n“基本事实”部分阐明了这种行为：“如果在信号中断之前已经传输了一些字节，则 `read()` 返回已传输的字节数，并且不设置 `errno`。”\n\n在这种情况下，调用被中断之前已经传输了 $2500$ 个字节。因此，`read()`调用不会被重启（因为没有设置`SA_RESTART`），也不会返回错误。相反，它将成功完成，返回实际读取的字节数。返回值将是 $r = 2500$。从`read()`返回的非负值表示成功，因此`errno`不会被设置。从管道成功读取 $r$ 字节的后果是这些字节被消耗，并且管道的内部读取指针前进 $r$。\n\n选项 A 中的陈述正确地描述了这整个事件序列。\n\n**结论：正确。**\n\n### 选项 B 分析\n\n这个选项对`SA_RESTART`标志提供的保证做出了一个强有力的声明。它暗示设置`SA_RESTART`能确保被中断的`read()`最终将返回所请求的全部字节数 $n$。\n\n这是一个常见的误解。“基本事实”明确指出：“重启并不能保证在重启的调用中恰好会传递 $n$ 个字节。” `SA_RESTART`标志指示内核在系统调用被信号中断时透明地重新发出该调用，通常仅在没有数据被传输的情况下。然而，重启的`read()`调用仍然受制于流式 I/O 的正常语义。对于像管道或TCP套接字这样的面向流的描述符，如果内核缓冲区中当前只有较少的数据可用，那么`read()`调用被允许返回比请求的少的字节（即“短读”）。`SA_RESTART`自动处理`EINTR`，但它不会将一个面向流的`read()`转换成一个会阻塞直到整个缓冲区被填满的调用。健壮的用户空间代码必须总是准备好通过循环来处理短读，不管是否使用了`SA_RESTART`。\n\n**结论：不正确。**\n\n### 选项 C 分析\n\n该选项声称，对于面向流的描述符，一个累积字节直到达到目标计数 $n$ 的用户空间重试循环“在语义上总是安全的”，因为内核保留了字节流的顺序。\n\n虽然内核确实保留了流中的字节顺序，但这个说法是错误的，因为它忽略了应用层语义。问题提到“生产者进程继续向管道中写入任意大小的记录”。如果构建在流之上的应用协议是面向消息的（例如，带有头部的记录，或长度前缀的消息），那么读取一个固定的、任意数量的字节 $n$ 在语义上是不正确的。这样的读取很可能会跨越消息边界，导致消费者读取到部分记录或多个记录的混合体，从而破坏应用程序的状态。\n\n该重试循环正确地实现了“从流中精确读取 $n$ 字节”的逻辑。然而，这种逻辑的应用并非“在语义上总是安全的”。其安全性完全取决于在应用程序的协议中，读取一个 $n$ 字节的原始数据块是否是一个有意义的操作。声称这种模式“不会引入微妙的错误”是一个强硬且错误的说法；这是网络和 IPC 编程中一个非常常见的错误来源。\n\n**结论：不正确。**\n\n### 选项 D 分析\n\n该选项描述了在`O_NONBLOCK`模式下的行为，根据“基本事实”，这是对问题上下文的一个有效扩展。它指出，即使有数据可用，被中断的`read()`也可能返回-1并将`errno`设置为`EINTR`，并且将`EINTR`视为致命错误是一个程序错误。\n\n这完全正确。在信号的递送和内核为`read()`系统调用开始数据传输之间存在一个竞争条件。即使管道的缓冲区中有可用数据，如果有一个信号正在等待该进程，内核也可能在有机会复制任何字节之前递送该信号并中断系统调用。\n\n根据“基本事实”：“如果在任何字节被传输之前，一个信号被递送并中断了 `read()` 调用，则 `read()` 返回 -1 并将 `errno` 设置为 `EINTR`。” 这点无论数据是否可用都适用。\n\n声明的第二部分阐述了对用户空间的影响。`EINTR`错误码仅仅意味着系统调用被中断了，应该重试。如果用户空间代码没有检查`EINTR`，而是将返回的-1视为一个致命的、不可恢复的 I/O 错误，它将过早地终止其读取循环。管道中可用的数据将留在那里，未被进程读取。这是一个典型的用户空间错误，会导致数据从应用程序的角度看被有效地丢弃或丢失。\n\n**结论：正确。**\n\n### 选项 E 分析\n\n该选项声称，使用`select()`或`poll()`检查可读性可保证后续的`read()`将返回至少 $n$ 字节。\n\n这从根本上是错误的。`select()`和`poll()`的目的是允许一个进程监视多个文件描述符，并等待其中一个或多个准备好进行 I/O，而不会在任何单个描述符上阻塞。当`select()`或`poll()`指示一个文件描述符可读时，它只保证至少有一个字节可以不阻塞地被读取。\n\n“基本事实”证实了这一点：“由`select()`或`poll()`指示的可读性意味着至少有一个字节可以在不阻塞的情况下被读取，但并不保证后续的`read()`调用将返回特定数量的字节。” 后续的`read(fd, buf, n)`调用将返回当前可用的字节数，最多为 $n$。这可能是任何值 $r$，使得 $1 \\le r \\le n$。因此，重试循环是“不必要的”这一结论是错误的。从流中读取精确数量的字节仍然需要一个重试循环。\n\n**结论：不正确。**", "answer": "$$\\boxed{AD}$$", "id": "3651817"}, {"introduction": "在I/O子系统中，效率至关重要，而“读放大”是衡量效率的一个关键指标。本练习将引导你对一个基于“区段”(extent)的现代文件系统进行性能建模，推导出文件碎片化如何导致额外的元数据读取，从而量化其对性能的影响。通过建立这个模型，你将学会从第一性原理出发，分析文件系统内部结构如何直接影响存储性能。", "problem": "一个服务器使用基于 extent 的文件系统，该系统使用 extent 树来表示每个文件的物理布局。内核输入/输出子系统（包括页面缓存和块 I/O 层）对一个大小为 $S$ 字节的文件进行冷缓存顺序读取。该文件系统将每个文件的 extents 组织成一个两级树：inode（根节点）指向一组叶节点，每个叶节点最多包含 $c$ 个 extent 描述符。每个叶节点在磁盘上占用 $m$ 字节。inode 在磁盘上的结构占用 $i$ 字节，并且初始时未被缓存。假设所有的元数据和数据读取都是通过来自冷缓存的同步磁盘 I/O 完成的，并且一旦一个元数据块被读取，它在本次读取的剩余时间内将保持缓存状态。设备和内核不会在元数据或数据请求的字节数之外执行任何隐式的超额读取，读取操作没有校验和或日志读取，并且逻辑文件数据与交付给应用程序的数据内容完全相同。\n\n定义文件的碎片化程度为构成该文件的不连续物理 extents 的数量 $N$（因此平均 extent 大小为 $S/N$）。对文件的顺序读取将按顺序遍历 extent 树，导致内核根据需要读取叶节点以解析 extents 的物理地址。对于一次冷缓存遍历，假设读取任何叶节点都会产生一次 $m$ 字节的元数据读取，并且单个叶节点足以处理多达 $c$ 个连续的 extents，然后才需要获取下一个叶节点。inode 被精确读取一次，读取量为 $i$ 字节。\n\n定义读取放大 $A$ 为内核输入/输出子系统读取的总物理字节数（包括数据和元数据）与返回给应用程序的逻辑字节数之比。仅从上述定义以及 extents 和树的标准属性出发，推导出一个关于 $S$、$N$、$m$、$c$ 和 $i$ 的 $A$ 的精确封闭形式表达式。你的最终答案必须是一个单一的解析表达式。不要进行近似或取整。", "solution": "问题要求推导在对文件进行冷缓存顺序读取时，读取放大 $A$ 的精确封闭形式表达式。读取放大 $A$ 定义为内核 I/O 子系统读取的总物理字节数与返回给应用程序的逻辑字节数之比。\n设 $B_{total}$ 为读取的总物理字节数，$B_{logical}$ 为返回的逻辑字节数。读取放大由下式给出：\n$$A = \\frac{B_{total}}{B_{logical}}$$\n\n首先，我们确定返回的逻辑字节数 $B_{logical}$。问题陈述文件大小为 $S$ 字节，并且“逻辑文件数据与交付给应用程序的数据内容完全相同”。因此，返回给应用程序的逻辑字节数量就是文件的大小。\n$$B_{logical} = S$$\n\n接下来，我们确定读取的总物理字节数 $B_{total}$。问题明确指出所有读取都来自冷缓存，并且没有隐式超额读取、校验和或日志读取。读取的总字节数是文件数据内容读取的字节数和其元数据读取的字节数之和。\n$$B_{total} = (\\text{数据读取字节数}) + (\\text{元数据读取字节数})$$\n\n数据读取的字节数对应于文件的实际内容。由于文件大小为 $S$ 字节，一次完整的顺序读取需要精确读取这么多数据。\n$$\\text{数据读取字节数} = S$$\n\n元数据读取的字节数包括对文件 inode 和 extent 树的叶节点的读取。\n$$\\text{元数据读取字节数} = (\\text{inode 读取字节数}) + (\\text{叶节点读取字节数})$$\n\n根据问题描述，“inode 在磁盘上的结构占用 $i$ 字节，并且初始时未被缓存…… inode 被精确读取一次，读取量为 $i$ 字节。”\n$$\\text{inode 读取字节数} = i$$\n\n为了确定为叶节点读取的字节数，我们必须计算访问了多少个叶节点。文件由 $N$ 个不连续的物理 extents 组成。这些 extents 的描述符存储在叶节点中，每个叶节点最多可包含 $c$ 个 extent 描述符。对文件的顺序读取会按顺序遍历这些 extents。问题陈述，“单个叶节点足以处理多达 $c$ 个连续的 extents，然后才需要获取下一个叶节点。”这意味着 $N$ 个 extent 描述符是连续存储在一系列叶节点中的。为了访问所有 $N$ 个 extents 的描述符，系统必须读取一定数量的叶节点。\n\n设 $L$ 为必须读取的叶节点数量。要将 $N$ 个项目存储在每个最多能容纳 $c$ 个项目的容器中，所需的容器数量是比率 $\\frac{N}{c}$ 的上取整。\n$$L = \\left\\lceil \\frac{N}{c} \\right\\rceil$$\n\n问题明确指出“读取任何叶节点都会产生一次 $m$ 字节的元数据读取。”由于元数据块一旦被读取就会保持缓存状态，因此 $L$ 个必要的叶节点中的每一个都只被精确读取一次。因此，为所有叶节点读取的总字节数是叶节点的数量乘以每个叶节点的大小。\n$$\\text{叶节点读取字节数} = L \\times m = m \\left\\lceil \\frac{N}{c} \\right\\rceil$$\n\n现在，我们可以组合出读取的总物理字节数 $B_{total}$ 的表达式：\n$$B_{total} = S + i + m \\left\\lceil \\frac{N}{c} \\right\\rceil$$\n\n最后，我们将 $B_{total}$ 和 $B_{logical}$ 的表达式代入读取放大 $A$ 的定义中：\n$$A = \\frac{S + i + m \\left\\lceil \\frac{N}{c} \\right\\rceil}{S}$$\n\n这个表达式可以通过分离分数来简化：\n$$A = \\frac{S}{S} + \\frac{i + m \\left\\lceil \\frac{N}{c} \\right\\rceil}{S}$$\n$$A = 1 + \\frac{i + m \\left\\lceil \\frac{N}{c} \\right\\rceil}{S}$$\n\n这就是读取放大 $A$ 作为给定参数 $S$、$N$、$m$、$c$ 和 $i$ 的函数的精确封闭形式表达式。", "answer": "$$\n\\boxed{1 + \\frac{i + m \\left\\lceil \\frac{N}{c} \\right\\rceil}{S}}\n$$", "id": "3651902"}, {"introduction": "现代存储设备（如 NVMe）的性能并非越高越好，而是需要在设备利用率和主机CPU开销之间找到一个最佳平衡点。这个练习提供了一个简化的性能模型，要求你运用利特尔法则 (Little's Law) 等基本排队论原理，来确定一个关键的拐点——在哪个队列深度下，系统瓶颈会从设备端转移到CPU端。解决这个问题将锻炼你对I/O性能瓶颈进行定量分析和优化的能力，这是现代系统性能工程中的一项核心技能。", "problem": "考虑一个使用非易失性内存快递（NVMe）的内核输入/输出（I/O）子系统，其中操作系统的 NVMe 驱动程序维护一个深度为 $Q$ 条命令的提交队列。该设备最多可并发执行 $P$ 条命令，每条命令的平均设备服务时间为 $t_{d}$。主机中央处理器（CPU）的预算为每秒 $C$ 个周期，每次 I/O 完成的平均 CPU 开销被建模为队列深度 $Q$ 的函数 $h(Q) = h_{0} + \\beta Q$，该模型捕捉了固定的每次 I/O 成本以及随着队列加深而增加的竞争成本。\n\n仅使用以下基本依据：\n- 称为利特尔法则 (Little's Law) 的稳态关系，该关系指出 $L = \\frac{N}{X}$，其中 $L$ 是系统中的平均延迟，$N$ 是系统中平均的未完成操作数，$X$ 是吞吐量（单位：操作/秒）。\n- 吞吐量的定义，即独立限制速率的最小值；具体而言，即设备限制速率和 CPU 限制速率。\n\n假设使用以下科学上真实的参数：\n- 平均设备服务时间 $t_{d} = 120 \\times 10^{-6}$ 秒。\n- 最大设备并发度 $P = 64$。\n- CPU 预算 $C = 3 \\times 10^{9}$ 周期/秒。\n- 基线 CPU 开销 $h_{0} = 2.0 \\times 10^{4}$ 周期/I/O。\n- 增量竞争成本 $\\beta = 150$ 周期/I/O 每单位 $Q$ 增加。\n\n通过 Little's law 和并发上限 $P$ 所隐含的、考虑并发性的稳态推理，将设备限制的吞吐量定义为 $Q$ 的函数，并通过每次 I/O 的周期预算来定义 CPU 限制的吞吐量。然后，通过令设备限制的吞吐量与 CPU 限制的吞吐量相等，确定最小的实数队列深度 $Q^{\\star}$。当队列深度超过 $Q^{\\star}$ 后，由于 CPU 开销的增加，进一步增加 $Q$ 将产生递减的收益，即实现的吞吐量从受设备限制转变为受 CPU 限制。\n\n将 $Q^{\\star}$ 的数值报告为一个无量纲量。将您的答案四舍五入到四位有效数字。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 提交队列深度：$Q$\n- 最大设备并发度：$P$\n- 平均设备服务时间：$t_{d}$\n- 主机 CPU 预算：$C$ 周期/秒\n- 每次 I/O 完成的平均 CPU 开销：$h(Q) = h_{0} + \\beta Q$\n- 基本依据：Little's law（$L = N/X$）和吞吐量为限制速率的最小值。\n- 参数：\n  - $t_{d} = 120 \\times 10^{-6}$ 秒\n  - $P = 64$\n  - $C = 3 \\times 10^{9}$ 周期/秒\n  - $h_{0} = 2.0 \\times 10^{4}$ 周期/I/O\n  - $\\beta = 150$ 周期/(I/O $\\cdot$ Q)\n- 目标：确定设备限制的吞吐量等于 CPU 限制的吞吐量时的最小实数队列深度 $Q^{\\star}$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据、提法明确且客观。它使用计算机科学和操作系统中的既定原则（如 Little's law、排队论和性能瓶颈）来为 I/O 性能建模。CPU 开销模型 $h(Q)$ 是对竞争效应的一个合理的一阶线性近似。所提供的数值参数对于现代 NVMe SSD 和主机系统是符合实际的。问题是自洽的，提供了推导出唯一解所需的所有信息。语言精确，没有歧义或主观论断。\n\n**结论：** 问题有效。\n\nI/O 子系统的总吞吐量 $X(Q)$ 是设备服务请求的速率与 CPU 处理完成的速率二者中的最小值。这可以表示为：\n$$X(Q) = \\min(X_{\\text{device}}(Q), X_{\\text{cpu}}(Q))$$\n我们必须首先定义设备限制的吞吐量 $X_{\\text{device}}(Q)$ 和 CPU 限制的吞吐量 $X_{\\text{cpu}}(Q)$ 的表达式。\n\nCPU 限制的吞吐量 $X_{\\text{cpu}}(Q)$ 由每秒可用的总 CPU 周期数 $C$ 和处理单个 I/O 完成所需的周期数 $h(Q)$ 决定。CPU 可持续的最大每秒 I/O 操作数（IOPS）为：\n$$X_{\\text{cpu}}(Q) = \\frac{C}{h(Q)} = \\frac{C}{h_{0} + \\beta Q}$$\n此函数表明，随着队列深度 $Q$ 的增加，每次 I/O 的 CPU 开销增加，因此 CPU 限制的吞吐量减少。\n\n设备限制的吞吐量 $X_{\\text{device}}(Q)$ 由设备的内在能力决定。根据利特尔法则，在设备的情境中，单个命令的平均服务时间为 $t_d$。设备同时服务的平均命令数 $N$ 为 $\\min(Q, P)$。应用利特尔法则（$X = N/L$），其中 $L=t_d$ 且 $N=\\min(Q,P)$，可得：\n$$X_{\\text{device}}(Q) = \\frac{\\min(Q, P)}{t_{d}}$$\n此函数随 $Q$ 线性增加，直到 $Q=P$，此时设备达到饱和，吞吐量稳定在其最大值 $P/t_d$。\n\n问题要求的是系统从受设备限制过渡到受 CPU 限制时的队列深度 $Q^{\\star}$。这个过渡点发生在两个限制吞吐量相等的地方：\n$$X_{\\text{device}}(Q^{\\star}) = X_{\\text{cpu}}(Q^{\\star})$$\n对于较小的 $Q$，$X_{\\text{device}}(Q)$ 很小并随 $Q$ 增加，而 $X_{\\text{cpu}}(Q)$ 很大。随着 $Q$ 的增加，$X_{\\text{device}}(Q)$ 上升而 $X_{\\text{cpu}}(Q)$ 下降。因此，交点 $Q^{\\star}$ 必然存在。我们必须确定这个交点是发生在 $Q^{\\star} \\le P$ 还是 $Q^{\\star} > P$ 的区间。我们首先假设交点发生在 $Q^{\\star} \\le P$。在这种情况下，$\\min(Q^{\\star}, P) = Q^{\\star}$。方程变为：\n$$\\frac{Q^{\\star}}{t_{d}} = \\frac{C}{h_{0} + \\beta Q^{\\star}}$$\n整理该方程得到一个关于 $Q^{\\star}$ 的二次方程：\n$$Q^{\\star}(h_{0} + \\beta Q^{\\star}) = C t_{d}$$\n$$\\beta (Q^{\\star})^{2} + h_{0} Q^{\\star} - C t_{d} = 0$$\n使用二次公式 $Q^{\\star} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$，其中 $a=\\beta$, $b=h_0$, $c=-Ct_d$：\n$$Q^{\\star} = \\frac{-h_{0} \\pm \\sqrt{h_{0}^{2} - 4(\\beta)(-C t_{d})}}{2\\beta}$$\n$$Q^{\\star} = \\frac{-h_{0} \\pm \\sqrt{h_{0}^{2} + 4\\beta C t_{d}}}{2\\beta}$$\n由于队列深度必须是非负数，我们取正根：\n$$Q^{\\star} = \\frac{-h_{0} + \\sqrt{h_{0}^{2} + 4\\beta C t_{d}}}{2\\beta}$$\n现在我们代入给定的数值：\n- $h_{0} = 2.0 \\times 10^{4}$\n- $\\beta = 150$\n- $C = 3 \\times 10^{9}$\n- $t_{d} = 120 \\times 10^{-6}$\n\n首先，我们计算平方根下的项：\n$$h_{0}^{2} = (2.0 \\times 10^{4})^{2} = 4.0 \\times 10^{8}$$\n$$4\\beta C t_{d} = 4 \\times 150 \\times (3 \\times 10^{9}) \\times (120 \\times 10^{-6}) = 600 \\times 3 \\times 120 \\times 10^{3} = 216000 \\times 10^{3} = 2.16 \\times 10^{8}$$\n$$h_{0}^{2} + 4\\beta C t_{d} = 4.0 \\times 10^{8} + 2.16 \\times 10^{8} = 6.16 \\times 10^{8}$$\n现在我们可以计算 $Q^{\\star}$：\n$$Q^{\\star} = \\frac{-2.0 \\times 10^{4} + \\sqrt{6.16 \\times 10^{8}}}{2 \\times 150}$$\n$$Q^{\\star} = \\frac{-20000 + 10^{4} \\sqrt{6.16}}{300} \\approx \\frac{-20000 + 24819.347}{300}$$\n$$Q^{\\star} \\approx \\frac{4819.347}{300} \\approx 16.06449$$\n计算出的值为 $Q^{\\star} \\approx 16.06$。这个值满足我们最初的假设 $Q^{\\star} \\le P$，因为 $16.06 \\le 64$。因此，我们使用非饱和设备状态的方程是正确的。\n\n将结果四舍五入到四位有效数字得到 $16.06$。在这个队列深度，设备可实现的吞吐量恰好与 CPU 可持续的吞吐量相匹配。对于任何 $Q > Q^{\\star}$，CPU 将成为瓶颈，并且由于 $X_{\\text{cpu}}(Q)$ 是一个递减函数，整体性能将会下降。", "answer": "$$\\boxed{16.06}$$", "id": "3651867"}]}