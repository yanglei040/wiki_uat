{"hands_on_practices": [{"introduction": "为了从根本上理解写缓冲的性能影响，我们可以构建一个简洁而强大的数学模型。本练习将写缓冲区抽象为一个流体队列，让我们能够基于数据写入速率和刷盘速率，分析其稳定性并预测其何时可能溢出。通过这个模型，你将从第一性原理出发，掌握缓冲区积压和系统稳定性的核心概念 [@problem_id:3690122]。", "problem": "一个操作系统采用写回（write-back）缓存策略，并带有一个驻留内存的写缓冲区。多个生产者线程生成应用程序的写请求，这些请求被附加到缓冲区中，而一个单独的异步刷新线程（flusher thread）将缓冲区的数据排空到存储设备。将该系统建模为一个连续速率（流体）队列，定义如下：\n\n- 令 $Q(t)$ 表示在时间 $t$ 的缓冲数据量。\n- 令 $\\lambda$ 表示写请求的长期平均产生速率（缓冲区到达率）。\n- 令 $\\mu$ 表示刷新器的长期平均持续排空速率（缓冲区服务率）。\n- 假设 $Q(0)=Q_{0} \\ge 0$。\n- 当 $Q(t) > 0$ 时，刷新器可以以速率 $\\mu$ 运行；当 $Q(t)=0$ 时，缓冲区的数据量不能为负。\n- 缓冲区具有有限容量 $C$；当 $Q(t)$ 首次达到 $C$ 时，发生溢出。\n\n仅从基本流量守恒原理出发，即当缓冲区非空时，缓冲数据的瞬时变化率等于输入速率减去输出速率，并且 $Q(t)$ 的下界为 $0$，回答以下问题：\n\n1) 使用上述原理，且不借助任何现成的排队论结果，论证缓冲区占用率在长期运行中的稳定性。陈述在什么条件下关于 $\\lambda$ 和 $\\mu$ 的关系，缓冲区占用率可以随时间保持有界，以及在什么条件下它会发散。\n\n2) 针对 $\\lambda > \\mu$ 且 $Q(0)=Q_{0} \\in (0,C)$ 的情况，推导 $Q(t)$ 在 $0 \\le t  t_{\\text{overflow}}$ 时间范围内的闭式表达式，其中 $t_{\\text{overflow}}$ 是 $Q(t)$ 首次达到 $C$ 的时间。\n\n3) 对于一个具体系统，参数为 $\\lambda = 2.4$ GB/s，$\\mu = 1.8$ GB/s，$C = 12$ GB，以及 $Q_{0} = 1.5$ GB，计算溢出时间 $t_{\\text{overflow}}$（以秒为单位）。以秒表示最终答案，并将答案四舍五入到四位有效数字。", "solution": "该问题要求对一个建模为连续速率流体队列的写缓冲区进行分析。分析必须从流量守恒的第一性原理推导得出。\n\n所提供的基本原理是，缓冲数据量 $\\frac{dQ(t)}{dt}$ 的瞬时变化率等于输入速率减去输出速率。输入速率被给定为一个恒定的平均速率 $\\lambda$。输出速率是一个恒定的平均速率 $\\mu$，但只有在缓冲区非空时（即 $Q(t)  0$）才会发生排空。此外，缓冲区的数据量不能为负，即 $Q(t) \\ge 0$。\n\n这可以被形式化为一个微分方程。对于 $Q(t)  0$ 的任何时间 $t$，动态由以下方程决定：\n$$\n\\frac{dQ(t)}{dt} = \\lambda - \\mu\n$$\n如果 $Q(t) = 0$，数据量不能再减少。因此，变化率必须为非负。这意味着当 $Q(t) = 0$ 时，$\\frac{dQ(t)}{dt} = \\max(0, \\lambda - \\mu)$。\n\n1) 缓冲区占用率的稳定性\n缓冲区占用率 $Q(t)$ 的长期行为（稳定性）完全取决于净速率的符号，即恒定值 $\\lambda - \\mu$。我们分析问题中提出的两种情况。\n\n情况一：有界占用率（稳定系统）\n为了使缓冲区占用率随时间保持有界，它必须没有无限增长的趋势。当缓冲区非空时，如果净变化率为非正，则会发生这种情况。\n如果 $\\lambda  \\mu$，则 $\\lambda - \\mu  0$。在这种情况下，只要 $Q(t)  0$，我们就有 $\\frac{dQ}{dt}  0$，这意味着缓冲区将会排空。如果缓冲区是空的，$Q(t)=0$，只有当有数据到达时它才会开始填充，此时排空速率超过到达速率，将 $Q(t)$ 推回到 $0$。该系统是自我调节的，占用率将保持有界。\n如果 $\\lambda = \\mu$，则 $\\lambda - \\mu = 0$。在这种情况下，只要 $Q(t)  0$，我们就有 $\\frac{dQ}{dt} = 0$。缓冲区水平保持在其当前值不变。如果 $Q(t) = 0$，它将保持在 $0$。占用率不会增长到无穷大；如果 $Q_00$，它将保持在初始水平 $Q_0$。因此，它也是有界的。\n因此，缓冲区占用率随时间保持有界的条件是 $\\lambda \\le \\mu$。\n\n情况二：发散占用率（不稳定系统）\n如果缓冲区占用率有持续增长的趋势，它将会发散。当净变化率为正时，会发生这种情况。\n如果 $\\lambda  \\mu$，则 $\\lambda - \\mu  0$。在这种情况下，只要 $Q(t)  0$，我们就有 $\\frac{dQ}{dt}  0$。缓冲区的数据量将持续增加。即使缓冲区开始时是空的，$Q(0)=0$，$\\frac{dQ}{dt} = \\lambda - \\mu  0$，所以它会立即开始填充并持续增长。在一个容量有限为 $C$ 的系统中，这种增长将持续到缓冲区溢出。在一个无容量限制的系统中，$Q(t)$ 将无限增长。\n因此，缓冲区占用率发散的条件是 $\\lambda  \\mu$。\n\n2) 针对 $\\lambda  \\mu$ 的情况推导 $Q(t)$\n我们给定 $\\lambda  \\mu$ 的特定情况，初始条件为 $Q(0) = Q_{0}$，且 $Q_{0} \\in (0, C)$。由于 $Q_{0}  0$ 且净速率 $\\lambda - \\mu$ 是一个正常数，缓冲区数据量 $Q(t)$ 将从其初始状态线性增加。对于 $t  0$，它永远不会变为 $0$。因此，在整个时间区间 $0 \\le t  t_{\\text{overflow}}$ 内，系统由更简单的微分方程决定：\n$$\n\\frac{dQ}{dt} = \\lambda - \\mu\n$$\n这是一个具有常数系数的一阶常微分方程。我们可以通过对时间从 $t=0$ 到一个通用时间 $t$ 进行积分来求解它，相应的队列数据量为 $Q(0)=Q_{0}$ 和 $Q(t)$：\n$$\n\\int_{Q_{0}}^{Q(t)} dQ' = \\int_{0}^{t} (\\lambda - \\mu) dt'\n$$\n计算积分得到：\n$$\nQ(t) - Q_{0} = (\\lambda - \\mu)t\n$$\n求解 $Q(t)$，我们得到缓冲区数据量作为时间函数的闭式表达式：\n$$\nQ(t) = Q_{0} + (\\lambda - \\mu)t\n$$\n该表达式在 $0 \\le t  t_{\\text{overflow}}$ 内有效。\n\n3) 计算溢出时间 $t_{\\text{overflow}}$\n我们给定的系统参数如下：\n- 到达速率 $\\lambda = 2.4$ GB/s\n- 服务速率 $\\mu = 1.8$ GB/s\n- 缓冲区容量 $C = 12$ GB\n- 初始缓冲数据量 $Q_{0} = 1.5$ GB\n\n溢出时间 $t_{\\text{overflow}}$ 是缓冲区数据量 $Q(t)$ 首次达到容量 $C$ 的时间 $t$。我们使用第 (2) 部分得到的 $Q(t)$ 表达式，并设 $Q(t_{\\text{overflow}}) = C$：\n$$\nC = Q_{0} + (\\lambda - \\mu)t_{\\text{overflow}}\n$$\n现在我们可以求解 $t_{\\text{overflow}}$：\n$$\nC - Q_{0} = (\\lambda - \\mu)t_{\\text{overflow}}\n$$\n$$\nt_{\\text{overflow}} = \\frac{C - Q_{0}}{\\lambda - \\mu}\n$$\n现在，我们将数值代入此方程。单位是一致的：$\\frac{\\text{GB}}{\\text{GB/s}} = \\text{s}$。\n$$\nt_{\\text{overflow}} = \\frac{12 - 1.5}{2.4 - 1.8}\n$$\n$$\nt_{\\text{overflow}} = \\frac{10.5}{0.6}\n$$\n$$\nt_{\\text{overflow}} = 17.5\n$$\n问题要求答案四舍五入到四位有效数字。精确值 $17.5$ 可以表示为 $17.50$ 来满足此要求。结果的单位是秒。", "answer": "$$\n\\boxed{17.50}\n$$", "id": "3690122"}, {"introduction": "在理解了性能动态之后，确保系统崩溃时的正确性至关重要。本练习提出了一个常见的编程任务——原子性地更新一个文件，并挑战你正确使用系统调用来保证数据的完整性。这个过程将促使你深入思考数据和元数据写入顺序的问题，这是构建可靠系统的关键一环 [@problem_id:3690204]。", "problem": "在一个兼容可移植操作系统接口 (POSIX) 的操作系统 (OS) 上，一个应用程序使用两步协议来更新一个配置文件，以避免部分写入。该应用程序将下一版本的配置写入一个临时文件路径 $\\mathrm{config.tmp}$，然后将 $\\mathrm{config.tmp}$ 重命名以覆盖现有的 $\\mathrm{config}$ 路径。存储栈使用一个操作系统页缓存和一个设备写回缓存；这两种缓存都是易失的，在发生崩溃时可能会丢失缓冲的数据，除非被显式地刷写。关闭文件并不意味着持久性。对常规文件调用函数 $\\mathrm{fsync}$ 会强制该文件的数据和 inode 元数据到达稳定存储；对目录调用函数 $\\mathrm{fsync}$ 会强制目录条目（包括添加、删除和重命名）和目录元数据到达稳定存储。一旦持久化，重命名操作对于目录条目是原子的（即，读取者要么看到旧的名称映射，要么看到新的名称映射，但绝不会看到混合状态），然而，除非被强制，文件的数据块和目录元数据可能会以不同的顺序被持久化。\n\n该应用程序的基线序列（省略可选的 $\\mathrm{fsync}$ 调用）如下：\n- 打开 $\\mathrm{config.tmp}$ 用于写入。\n- 将 $N$ 字节的新配置写入 $\\mathrm{config.tmp}$。\n- 关闭 $\\mathrm{config.tmp}$。\n- 将 $\\mathrm{config.tmp}$ 重命名为 $\\mathrm{config}$（在持久化时原子性地替换旧的 $\\mathrm{config}$）。\n\n您必须决定在何处放置 $\\mathrm{fsync}$ 调用，以在以下强崩溃一致性要求下保证原子性：\n\n定义（原子性要求）：对于在更新过程中的任何时间（可能发生在序列中两个相邻的系统调用之间）发生的任何崩溃，恢复后的系统状态必须满足以下两个不变量：\n- 不变量 $\\mathrm{I1}$ （可见时无撕裂内容）：如果恢复后的 $\\mathrm{config}$ 指向新版本，那么其内容必须精确地是应用程序写入的 $N$ 字节（没有截断、零或陈旧的混合内容）。\n- 不变量 $\\mathrm{I2}$ （成功后名称切换的持久性）：在所选序列中应用程序的最后一个调用成功返回后，任何后续的崩溃都不能回滚名称映射；也就是说，恢复后 $\\mathrm{config}$ 继续指向新版本。\n\n假设源路径和目标路径位于同一父目录下。以下哪种 $\\mathrm{fsync}$ 的放置方式能保证上述定义的原子性？\n\nA. 完全不执行 `fsync` 调用。\n\nB. 重命名后，仅对父目录调用 `fsync`；不对文件调用 `fsync`。\n\nC. 重命名之前，对 `config.tmp` 调用 `fsync`；重命名之后，不对父目录调用 `fsync`。\n\nD. 重命名之前，对 `config.tmp` 调用 `fsync`；执行重命名；然后对父目录调用 `fsync`。\n\nE. 首先执行重命名；然后对 `config`（重命名后的文件）调用 `fsync`；最后对父目录调用 `fsync`。", "solution": "用户提供了一个关于在兼容 POSIX 的操作系统上原子文件更新协议的崩溃一致性的问题陈述。我将首先验证该问题陈述，然后进行完整的解答。\n\n### 第 1 步：提取已知条件\n\n-   **系统：** 兼容可移植操作系统接口 (POSIX) 的操作系统 (OS)。\n-   **任务：** 一个应用程序使用两步协议更新配置文件 `config`。\n-   **协议步骤：**\n    1.  将新配置写入临时文件路径 `config.tmp`。\n    2.  将 `config.tmp` 重命名为 `config`，此操作原子性地替换旧的 `config`。\n-   **存储栈属性：**\n    -   操作系统有一个易失性页缓存。\n    -   存储设备有一个易失性写回缓存。\n    -   这些缓存中的缓冲数据在崩溃时会丢失，除非被显式刷写。\n-   **函数语义：**\n    -   `close()`：不保证持久性。\n    -   `fsync(file)`：强制文件的数据及其 inode 元数据到达稳定存储。\n    -   `fsync(directory)`：强制目录条目（包括添加、删除、重命名）和目录元数据到达稳定存储。\n    -   `rename()`：该操作对于*持久化后*的目录条目是原子的。\n-   **顺序约束：** 除非应用程序强制指定顺序，否则文件数据块和其对应的目录元数据的持久化可能以任何顺序发生。\n-   **位置假设：** `config.tmp` 和 `config` 位于同一父目录中。\n-   **基线序列：**\n    1.  打开 `config.tmp` 用于写入。\n    2.  将 $N$ 字节的新配置写入 `config.tmp`。\n    3.  关闭 `config.tmp`。\n    4.  将 `config.tmp` 重命名为 `config`。\n-   **原子性要求定义：**\n    -   **不变量 I1（可见时无撕裂内容）：** 如果从崩溃中恢复后，`config` 指向新版本，其内容必须精确地是应用程序写入的 $N$ 字节。\n    -   **不变量 I2（成功后名称切换的持久性）：** 如果序列中应用程序的最后一个系统调用成功返回，任何后续的崩溃都不能导致 `config` 这个名称在恢复时恢复到旧版本。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n问题陈述描述了系统编程中一个关于持久、原子文件更新的经典且现实的场景。\n\n-   **科学依据：** 该问题牢固地植根于操作系统和文件系统设计的原则。写缓冲、页缓存、写回缓存等概念，以及像 `fsync` 和 `rename` 这样的 POSIX 系统调用的特定语义，都是标准的且被准确地表述。文件数据和目录元数据之间写入顺序可能被重排，这是一个健壮的软件必须处理的真实世界问题。\n-   **问题定义良好：** 这个问题是定义良好的。初始状态、允许的操作、它们定义的语义，以及所需最终状态的精确定义（通过不变量 I1 和 I2）都已提供。这种结构允许通过逻辑推导来确定一个唯一的、正确的操作序列。\n-   **客观性：** 该问题使用精确、客观和技术性的语言陈述。定义是明确的，没有主观解释的余地。\n\n问题陈述没有任何缺陷。这是一个在计算机科学中有效且定义良好的问题。\n\n### 第 3 步：结论和行动\n\n问题是**有效的**。我现在将开始推导解决方案并评估所提供的选项。\n\n### 基于原则的推导\n\n目标是找到一个在所有可能的崩溃场景下都能满足不变量 I1 和不变量 I2 的操作序列。我们用 `dir` 表示父目录。\n\n**不变量 I1 的分析（可见时无撕裂内容）：**\n不变量 I1 指出，如果文件系统上的名称 `config` 指向文件的新版本，那么该文件的内容必须是完整和正确的。使 `config` 指向新版本的操作是 `rename(\"config.tmp\", \"config\")` 调用。操作系统和底层存储系统可以在持久化文件 `config.tmp` 的数据块之前，持久化 `rename` 操作的结果（对父目录 `dir` 的更改）。\n\n为了防止违反 I1，我们必须保证 `config.tmp` 的数据在 `config` 到此数据的链接变得持久化*之前*就已经是持久的。崩溃可能发生在 `rename` 的目录条目被持久化之后，但在 `config.tmp` 的数据被持久化之前。在这种情况下，`config` 会指向一个 inode，其在稳定存储上的数据块是未写入、全零或包含垃圾数据的，这是一种“内容撕裂”故障。\n\n强制实现 `数据持久化 -> 名称更改持久化` 这一顺序的唯一方法是在发起名称更改之前，显式地将数据强制写入稳定存储。实现这一点的调用是 `fsync(config.tmp)`。因此，为了满足 I1，`fsync(config.tmp)` 调用必须在 `rename(\"config.tmp\", \"config\")` 调用*之前*成功完成。\n\n**不变量 I2 的分析（成功后名称切换的持久性）：**\n不变量 I2 指出，一旦应用程序的更新序列成功完成，名称的更改必须是持久的。这意味着，如果应用程序观察到其最终操作成功返回，它就可以假设新的 `config` 已经就位，并且能在崩溃后幸存。\n\n`rename` 操作修改了父目录 `dir`。仅仅调用 `rename()` 不提供持久性保证，因为更改可能只存在于易失性缓存中。在 `rename()` 返回后，但在目录更改被刷写到稳定存储之前发生崩溃，将导致名称更改丢失。如果 `rename()` 是最后一个调用，这将违反 I2。\n\n为了保证目录更改的持久性，我们必须在 `rename` 调用*之后*调用 `fsync(dir)`。当 `fsync(dir)` 成功返回时，可以保证 `rename` 操作已在稳定存储上。因此，为了满足 I2，序列中的最后一个操作必须是 `fsync(dir)`。\n\n**正确序列的综合：**\n结合两个不变量的要求，我们得到以下健壮的序列：\n1.  打开 `config.tmp` 并写入 $N$ 字节的新数据。\n2.  调用 `fsync(config.tmp)`。这通过确保文件内容在以最终名称可见之前是持久的，从而满足了 I1 的先决条件。\n3.  调用 `rename(\"config.tmp\", \"config\")`。这将原子性地切换目录条目。\n4.  调用 `fsync(dir)`。这通过确保名称切换是持久的来满足 I2，并且它的成功标志着整个原子更新的完成。\n\n### 逐项分析\n\n**A. 完全不执行 `fsync` 调用。**\n-   **分析：** 在没有任何 `fsync` 调用的情况下，操作系统可以自由地重排写入顺序。它可以在持久化 `config.tmp` 的数据之前持久化 `rename` 带来的目录更改。此时发生崩溃将导致 `config` 指向一个数据不完整或包含垃圾数据的文件，违反了 **I1**。此外，如果最后一个调用是 `rename`，其成功返回不保证持久性。崩溃可能会回滚名称更改，违反了 **I2**。\n-   **结论：** **不正确**。\n\n**B. 重命名后，仅对父目录调用 `fsync`；不对文件调用 `fsync`。**\n-   **序列：** `...`, `rename(...)`, `fsync(dir)`。\n-   **分析：** 这个序列满足 I2，因为最后的 `fsync(dir)` 调用保证了 `rename` 的持久性。然而，它没有在 `rename` 之前调用 `fsync(config.tmp)`。操作系统可以执行 `rename`，并且 `fsync(dir)` 可以在 `config.tmp` 的数据块被写入之前将目录更改强制刷写到磁盘。此时发生崩溃会导致 `config` 指向一个内容非持久、可能撕裂的文件。这违反了 **I1**。\n-   **结论：** **不正确**。\n\n**C. 重命名之前，对 `config.tmp` 调用 `fsync`；重命名之后，不对父目录调用 `fsync`。**\n-   **序列：** `...`, `fsync(config.tmp)`, `rename(...)`。\n-   **分析：** 这个序列满足 I1。通过在 `rename` 之前调用 `fsync(config.tmp)`，它确保了文件数据在名称切换发生之前是持久的。因此，如果在崩溃后观察到名称切换，相应的数据将是完整的。然而，该序列以 `rename` 结束。`rename` 的成功返回并不保证目录更改已在稳定存储上。随后的崩溃可能导致名称更改丢失。这违反了 **I2**。\n-   **结论：** **不正确**。\n\n**D. 重命名之前，对 `config.tmp` 调用 `fsync`；执行重命名；然后对父目录调用 `fsync`。**\n-   **序列：** `...`, `fsync(config.tmp)`, `rename(...)`, `fsync(dir)`。\n-   **分析：** 这个序列与我们推导出的正确协议相匹配。\n    -   在 `rename` 之前调用 `fsync(config.tmp)` 确保了新内容在通过 `rename` 可见之前已经位于稳定存储上。这满足了 **I1**。\n    -   在 `rename` 之后调用 `fsync(dir)` 确保了名称切换本身被持久化。作为最后一个调用，它的成功保证了整个操作将在崩溃后幸存。这满足了 **I2**。\n-   **结论：** **正确**。\n\n**E. 首先执行重命名；然后对 `config`（重命名后的文件）调用 `fsync`；最后对父目录调用 `fsync`。**\n-   **序列：** `...`, `rename(...)`, `fsync(\"config\")`, `fsync(dir)`。\n-   **分析：** `rename` 在任何 `fsync` 之前执行。这创造了一个漏洞窗口。操作系统可以在写入文件内容之前持久化 `rename` 带来的目录更改。在这个窗口期间发生崩溃将导致 `config` 指向一个不完整的文件，违反了 **I1**。在重命名之后调用 `fsync(\"config\")` 为时已晚；在 `fsync(\"config\")` 调用开始时，不一致的状态（可见的名称，非持久的内容）可能已经被持久化了。\n-   **结论：** **不正确**。", "answer": "$$\\boxed{D}$$", "id": "3690204"}, {"introduction": "真实的操作系统采用比固定速率刷盘更复杂的策略。本练习要求你编写一个程序，模拟一个基于脏页阈值来触发后台和主动刷盘的页面缓存系统。通过实现这个模型，你将具体地理解操作系统如何管理写入压力，并在性能和内存使用之间取得平衡 [@problem_id:3690239]。", "problem": "设计并实现一个完整的可运行程序，该程序模拟操作系统 (OS) 中文件系统页面缓存在写密集型工作负载下的动态过程。该模型使用带有脏页阈值和刷新线程的回写式缓存。目标是预测刷新线程何时启动以及页面缓存是否会饱和。\n\n请从以下基本定义和经过充分测试的事实出发。页面缓存保存最近访问的文件数据，并在进程写入数据时累积脏页，从而延迟回写到二级存储。设缓存容量为 $C$ 页，时间 $t$ 时的脏页数量为 $D(t)$，单位为页。在写密集型工作负载下，$N$ 个进程以恒定速率 $\\{w_i\\}_{i=1}^N$（单位为页/秒）写入，因此总写入速率为 $W = \\sum_{i=1}^N w_i$（单位为页/秒）。回写刷新线程由两个阈值控制，这两个阈值表示为缓存容量的比率：后台脏页阈值 $\\text{dirty\\_bg\\_ratio} = r_{\\text{bg}}$ 和最大脏页阈值 $\\text{dirty\\_ratio} = r_{\\text{max}}$，其中 $0  r_{\\text{bg}}  r_{\\text{max}}  1$。当 $D(t)$ 超过 $r_{\\text{bg}} \\cdot C$ 时，后台刷新以恒定速率 $f_{\\text{bg}}$（单位为页/秒）开始。当 $D(t)$ 超过 $r_{\\text{max}} \\cdot C$ 时，积极刷新以更高的恒定速率 $f_{\\text{max}}$（单位为页/秒）开始。脏页数量 $D(t)$ 受限于 $0 \\le D(t) \\le C$。\n\n程序必须为每个提供的测试用例计算以下量：\n- $t_{\\text{bg}}$：$D(t)$ 首次达到或超过 $r_{\\text{bg}} \\cdot C$ 的时间（秒），此时后台刷新线程启动。\n- $t_{\\text{max}}$：$D(t)$ 首次达到或超过 $r_{\\text{max}} \\cdot C$ 的时间（秒），此时积极刷新线程启动。\n- $t_{\\text{sat}}$：$D(t)$ 首次达到 $C$ 的时间（秒），此时页面缓存饱和。\n\n使用以下分段线性动态模型。设初始脏页数为 $D(0) = D_0$。总写入速率为 $W = \\sum_{i=1}^N w_i$。瞬时回写速率 $f(D)$ 定义为\n$$\nf(D) = \n\\begin{cases}\n0,  \\text{if } D  r_{\\text{bg}} \\cdot C, \\\\\nf_{\\text{bg}},  \\text{if } r_{\\text{bg}} \\cdot C \\le D  r_{\\text{max}} \\cdot C, \\\\\nf_{\\text{max}},  \\text{if } D \\ge r_{\\text{max}} \\cdot C,\n\\end{cases}\n$$\n脏页数量的变化率由经过充分测试的守恒定律给出\n$$\n\\frac{dD}{dt} = W - f(D),\n$$\n并限制在区间 $[0, C]$ 内。\n\n所有时间必须以秒为单位，表示为十进制浮点数。如果某个事件在恒定速率下永远不会发生（例如，没有写入，因此 $W = 0$ 且 $D(t)$ 永远不会增加），则为该量输出 $-1.0$。\n\n测试套件。为以下参数集实现程序。对于每个测试用例，程序必须输出 $[t_{\\text{bg}}, t_{\\text{max}}, t_{\\text{sat}}]$。\n\n- 测试用例 1（通用“理想路径”）：$C = 10000$, $r_{\\text{bg}} = 0.1$, $r_{\\text{max}} = 0.4$, $N = 3$, $\\{w_i\\} = \\{120, 80, 50\\}$, $f_{\\text{bg}} = 200$, $f_{\\text{max}} = 300$, $D_0 = 0$。\n- 测试用例 2（后台刷新恰好与写入相平衡的边界情况）：$C = 5000$, $r_{\\text{bg}} = 0.2$, $r_{\\text{max}} = 0.5$, $N = 2$, $\\{w_i\\} = \\{100, 100\\}$, $f_{\\text{bg}} = 200$, $f_{\\text{max}} = 400$, $D_0 = 0$。\n- 测试用例 3（无写入的边缘情况）：$C = 8000$, $r_{\\text{bg}} = 0.1$, $r_{\\text{max}} = 0.3$, $N = 2$, $\\{w_i\\} = \\{0, 0\\}$, $f_{\\text{bg}} = 100$, $f_{\\text{max}} = 200$, $D_0 = 0$。\n- 测试用例 4（即使积极刷新也无法跟上的饱和情况）：$C = 4000$, $r_{\\text{bg}} = 0.15$, $r_{\\text{max}} = 0.35$, $N = 4$, $\\{w_i\\} = \\{300, 250, 200, 150\\}$, $f_{\\text{bg}} = 500$, $f_{\\text{max}} = 800$, $D_0 = 0$。\n- 测试用例 5（后台刷新器触发但立即减少脏页数的情况）：$C = 12000$, $r_{\\text{bg}} = 0.25$, $r_{\\text{max}} = 0.6$, $N = 1$, $\\{w_i\\} = \\{100\\}$, $f_{\\text{bg}} = 150$, $f_{\\text{max}} = 400$, $D_0 = 0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的子列表，每个子列表的形式为 $[t_{\\text{bg}}, t_{\\text{max}}, t_{\\text{sat}}]$，所有时间均为秒，表示为四舍五入到六位小数的十进制浮点数，并用一对外部方括号括起来。例如：$[[1.000000,2.500000,-1.000000],[\\dots]]$。", "solution": "该问题要求我们基于一个分段线性动态模型，计算页面缓存在不同阶段的关键时间点。我们逐个分析每个测试用例。\n\n模型的关键在于脏页数量的变化率 $\\frac{dD}{dt}$，它取决于当前脏页数 $D(t)$ 所在的区间。\n- **阶段1 ($D  D_{\\text{bg}}$):** 变化率 $R_1 = W$\n- **阶段2 ($D_{\\text{bg}} \\le D  D_{\\text{max}}$):** 变化率 $R_2 = W - f_{\\text{bg}}$\n- **阶段3 ($D \\ge D_{\\text{max}}$):** 变化率 $R_3 = W - f_{\\text{max}}$\n\n其中 $D_{\\text{bg}} = r_{\\text{bg}} \\cdot C$，$D_{\\text{max}} = r_{\\text{max}} \\cdot C$。如果任何阶段的变化率为非正数（$\\le 0$），则脏页数量不会进入下一个更高的阶段。所有用例的初始脏页数 $D_0=0$。\n\n**测试用例 1:**\n- 参数: $C=10000, r_{\\text{bg}}=0.1, r_{\\text{max}}=0.4, W=250, f_{\\text{bg}}=200, f_{\\text{max}}=300$\n- 阈值: $D_{\\text{bg}} = 1000, D_{\\text{max}} = 4000$\n- 阶段1: $R_1 = 250 > 0$。$t_{\\text{bg}} = (1000 - 0) / 250 = 4.0$ 秒。\n- 阶段2: $R_2 = 250 - 200 = 50 > 0$。$\\Delta t = (4000 - 1000) / 50 = 60.0$ 秒。$t_{\\text{max}} = 4.0 + 60.0 = 64.0$ 秒。\n- 阶段3: $R_3 = 250 - 300 = -50 \\le 0$。系统不会饱和。$t_{\\text{sat}} = -1.0$。\n- 结果: $[4.000000, 64.000000, -1.000000]$\n\n**测试用例 2:**\n- 参数: $C=5000, r_{\\text{bg}}=0.2, r_{\\text{max}}=0.5, W=200, f_{\\text{bg}}=200, f_{\\text{max}}=400$\n- 阈值: $D_{\\text{bg}} = 1000, D_{\\text{max}} = 2500$\n- 阶段1: $R_1 = 200 > 0$。$t_{\\text{bg}} = (1000 - 0) / 200 = 5.0$ 秒。\n- 阶段2: $R_2 = 200 - 200 = 0$。脏页数量稳定，不会到达下一阈值。$t_{\\text{max}} = -1.0, t_{\\text{sat}} = -1.0$。\n- 结果: $[5.000000, -1.000000, -1.000000]$\n\n**测试用例 3:**\n- 参数: $C=8000, r_{\\text{bg}}=0.1, r_{\\text{max}}=0.3, W=0$\n- 阶段1: $R_1 = 0$。脏页数量不增加。所有阈值都无法到达。$t_{\\text{bg}} = -1.0, t_{\\text{max}} = -1.0, t_{\\text{sat}} = -1.0$。\n- 结果: $[-1.000000, -1.000000, -1.000000]$\n\n**测试用例 4:**\n- 参数: $C=4000, r_{\\text{bg}}=0.15, r_{\\text{max}}=0.35, W=900, f_{\\text{bg}}=500, f_{\\text{max}}=800$\n- 阈值: $D_{\\text{bg}} = 600, D_{\\text{max}} = 1400$\n- 阶段1: $R_1 = 900 > 0$。$t_{\\text{bg}} = (600 - 0) / 900 \\approx 0.666667$ 秒。\n- 阶段2: $R_2 = 900 - 500 = 400 > 0$。$\\Delta t = (1400 - 600) / 400 = 2.0$ 秒。$t_{\\text{max}} = 0.666667 + 2.0 \\approx 2.666667$ 秒。\n- 阶段3: $R_3 = 900 - 800 = 100 > 0$。$\\Delta t = (4000 - 1400) / 100 = 26.0$ 秒。$t_{\\text{sat}} = 2.666667 + 26.0 \\approx 28.666667$ 秒。\n- 结果: $[0.666667, 2.666667, 28.666667]$\n\n**测试用例 5:**\n- 参数: $C=12000, r_{\\text{bg}}=0.25, r_{\\text{max}}=0.6, W=100, f_{\\text{bg}}=150, f_{\\text{max}}=400$\n- 阈值: $D_{\\text{bg}} = 3000, D_{\\text{max}} = 7200$\n- 阶段1: $R_1 = 100 > 0$。$t_{\\text{bg}} = (3000 - 0) / 100 = 30.0$ 秒。\n- 阶段2: $R_2 = 100 - 150 = -50 \\le 0$。脏页数量会减少，不会到达下一阈值。$t_{\\text{max}} = -1.0, t_{\\text{sat}} = -1.0$。\n- 结果: $[30.000000, -1.000000, -1.000000]$", "answer": "[[4.000000, 64.000000, -1.000000], [5.000000, -1.000000, -1.000000], [-1.000000, -1.000000, -1.000000], [0.666667, 2.666667, 28.666667], [30.000000, -1.000000, -1.000000]]", "id": "3690239"}]}