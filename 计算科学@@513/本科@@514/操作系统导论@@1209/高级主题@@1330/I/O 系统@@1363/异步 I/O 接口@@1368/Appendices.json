{"hands_on_practices": [{"introduction": "要构建高效的系统，我们首先必须理解其基本限制。第一个练习将引导你对一个事件驱动的服务器进行基础分析。通过对服务器的 CPU 分配与每个事件的计算成本之间的关系进行建模，你将推导出其最大可持续吞吐量。这项练习 [@problem_id:3621630] 有助于阐明系统容量是如何由其核心资源决定的。", "problem": "考虑一个围绕异步输入/输出 (I/O) 接口构建的事件驱动服务器。该服务器运行一个单线程事件循环，该循环从一个队列中拉取完成事件，并通过执行一系列有限的用户空间操作和非阻塞系统调用来处理每个完成事件。假设如下：\n\n- 事件循环在单个中央处理器 (CPU) 核心上调度，并受到操作系统调度器强制执行的严格配额限制：在任何长度为 $t$ 秒的挂钟时间间隔内，事件循环最多获得 $B \\cdot t$ 秒的 CPU 时间，其中 $B$ 是一个固定常数，满足 $0  B \\leq 1$。\n- 每个已完成的 I/O 事件一旦出队，在事件循环中需要一个确定的 CPU 处理时间 $c$（秒/事件），之后才被视为完全处理完毕。\n- 完成队列足够大，只有当单位时间内到达事件的长期平均数量超过循环单位时间内可处理事件的长期平均数量时，才会开始丢弃事件。\n- 事件循环本身在事件处理过程中绝不会以让出 CPU 的方式阻塞，并且任何轮询开销都已包含在 $c$ 中。\n\n仅从这些假设和核心定义（即，如果一个队列的长期到达率不大于其长期服务率，则该队列是稳定的）出发，推导出一个闭式表达式，用于表示最大可持续事件到达率 $\\lambda_{\\max}$（事件/秒），使得系统在长期运行中不会丢弃事件。请以“事件/秒”为单位表示您的最终答案。无需进行数值代入；仅用 $B$ 和 $c$ 表示该表达式。", "solution": "问题要求解一个单线程事件驱动服务器的最大可持续事件到达率，记为 $\\lambda_{\\max}$。系统的稳定性取决于长期平均到达率不超过长期平均服务率这一条件。因此，最大可持续到达率等于系统的最大长期平均服务率。我们将服务率（单位为事件/秒）记为 $\\mu$。目标是求出 $\\lambda_{\\max} = \\mu$。\n\n问题提供了以下关键参数和约束条件：\n1.  服务器的事件循环在单个 CPU 核心上调度。\n2.  分配给事件循环的 CPU 时间受配额限制。在任何持续时间为 $t$ 秒的挂钟时间间隔内，事件循环最多被授予 $B \\cdot t$ 秒的 CPU 时间。常数 $B$ 是一个无量纲的分数，代表 CPU 份额，其中 $0  B \\leq 1$。\n3.  每个事件需要固定的 CPU 时间 $c$ 秒进行处理。$c$ 的单位是秒/事件。\n\n我们的目标是确定服务器在单位挂钟时间内可以处理的最大事件数。让我们考虑一个任意的、足够长的挂钟时间间隔 $t$。\n\n在这个 $t$ 秒的时间间隔内，根据定义，事件循环可用的总 CPU 时间最多为 $B \\cdot t$ 秒。我们将这个可用的 CPU 时间称为 $T_{CPU}$。因此，我们有：\n$$T_{CPU} \\leq B \\cdot t$$\n为了找到最大可持续速率，我们必须考虑最大处理能力，这对应于事件循环完全利用其 CPU 配额的情况。因此，我们将可用 CPU 时间精确地设为：\n$$T_{CPU} = B \\cdot t$$\n\n处理单个事件消耗 $c$ 秒的 CPU 时间。设 $N$ 是使用可用 CPU 时间 $T_{CPU}$ 可以处理的总事件数。$N$、$T_{CPU}$ 和 $c$ 之间的关系是：\n$$T_{CPU} = N \\cdot c$$\n\n将 CPU 配额中 $T_{CPU}$ 的表达式代入，我们得到：\n$$B \\cdot t = N \\cdot c$$\n\n现在我们可以求解 $N$，即在挂钟时间间隔 $t$ 内处理的总事件数：\n$$N = \\frac{B \\cdot t}{c}$$\n\n平均服务率 $\\mu$ 定义为单位挂钟时间内处理的事件数。因此，我们可以通过将处理的事件数 $N$ 除以挂钟时间间隔的持续时间 $t$ 来计算 $\\mu$：\n$$\\mu = \\frac{N}{t}$$\n\n代入 $N$ 的表达式：\n$$\\mu = \\frac{\\frac{B \\cdot t}{c}}{t}$$\n\n通过约去分子和分母中的项 $t$ 来简化表达式，得到长期平均服务率：\n$$\\mu = \\frac{B}{c}$$\n\n这个表达式的单位是一致的。参数 $B$ 是无量纲的（每秒挂钟时间的 CPU 时间秒数），而 $c$ 的单位是秒/事件。因此，$\\mu$ 的单位是：\n$$\\frac{[\\text{无量纲}]}{[\\text{秒} / \\text{事件}]} = \\frac{1}{\\text{秒} / \\text{事件}} = \\frac{\\text{事件}}{\\text{秒}}$$\n这证实了我们的表达式代表一个事件率，符合要求。\n\n根据问题的稳定性准则，如果到达率 $\\lambda$ 不大于服务率 $\\mu$，队列将不会无限增长（因此在长期运行中不会丢弃事件）。最大可持续到达率 $\\lambda_{\\max}$ 因此等于系统的最大服务率 $\\mu$。\n$$\\lambda_{\\max} = \\mu$$\n\n因此，最大可持续事件到达率的闭式表达式为：\n$$\\lambda_{\\max} = \\frac{B}{c}$$\n该表达式代表了服务器的基本容量限制，此限制由其 CPU 分配比例和每个事件的处理成本决定。", "answer": "$$\\boxed{\\frac{B}{c}}$$", "id": "3621630"}, {"introduction": "异步 I/O 的一个关键优势是它能够将缓慢的 I/O 操作与有用的计算重叠，从而隐藏延迟。这项练习 [@problem_id:3621649] 挑战你确定在等待 I/O 时，为了保持多核处理器完全利用所需的最佳并发水平。通过应用像利特尔法则这样的基本原理，你将学习如何平衡在途的 I/O 请求与计算能力，这是设计高性能应用程序的核心技能。", "problem": "考虑一个使用异步输入/输出 (AIO) 接口处理独立请求流的应用程序。每个请求遵循一个两阶段流水线：一个 I/O 阶段和一个计算阶段。I/O 阶段包括向 AIO 子系统提交一个读操作并等待其完成；计算阶段包括对数据执行确定性的计算。假设如下：\n- AIO 子系统最多可并发调度 $k$ 个未完成的 I/O 操作，每个操作的延迟是确定性的，为 $l$，并且在此并发水平下没有吞吐量下降或排队延迟。\n- 计算阶段在一台拥有 $m$ 个相同中央处理器 (CPU) 核心的机器上运行，每个核心一次只能处理一个请求。每个请求的计算时间是确定性的，等于 $c$。\n- 除延迟 $l$ 外，调度开销、数据传输带宽限制、内存限制和争用效应均可忽略不计。系统达到稳态，此时到达计算阶段的速率等于 I/O 操作的完成速率。\n\n仅使用操作系统和排队论的第一性原理——具体来说，是吞吐量的基本定义和利特尔法则——推导出一个精确的闭式表达式，该表达式表示最小整数并发级别 $k^{\\*}$，以确保在稳态下 CPU 计算阶段永远不会等待 I/O 完成。换句话说，找到最小的 $k^{\\*}$，使得 I/O 延迟被完全隐藏，并且长期吞吐量受计算阶段而非 I/O 阶段的限制。您的答案必须是用 $m$、$c$ 和 $l$ 表示的符号表达式。最终答案必须是单一的解析表达式；不要提供不等式或方程式。", "solution": "我们的目标是找到最小的整数并发级别 $k^{\\*}$，以确保计算核心始终有工作可做，即 I/O 阶段的吞吐量必须大于或等于计算阶段的吞吐量。\n\n首先，计算计算阶段的最大吞吐量 $\\lambda_{\\text{compute}}$。系统有 $m$ 个核心，每个核心处理一个请求需要 $c$ 时间。因此，总的计算吞吐量为：\n$$\n\\lambda_{\\text{compute}} = \\frac{m}{c}\n$$\n\n接下来，我们使用利特尔法则 ($N = \\lambda T$) 计算 I/O 阶段的吞吐量 $\\lambda_{\\text{I/O}}$。在这里，$N$ 是并发请求数 $k$，$T$ 是 I/O 延迟 $l$。因此：\n$$\nk = \\lambda_{\\text{I/O}} \\cdot l \\implies \\lambda_{\\text{I/O}} = \\frac{k}{l}\n$$\n\n为了使计算核心不空闲，必须满足条件：\n$$\n\\lambda_{\\text{I/O}} \\ge \\lambda_{\\text{compute}}\n$$\n\n将上述表达式代入，得到：\n$$\n\\frac{k}{l} \\ge \\frac{m}{c}\n$$\n\n求解 $k$，我们得到：\n$$\nk \\ge \\frac{m \\cdot l}{c}\n$$\n\n由于 $k$ 必须是整数，我们需要取满足此不等式的最小值，即对右侧表达式向上取整。因此，最小并发级别 $k^{\\*}$ 为：\n$$\nk^{*} = \\left\\lceil \\frac{m \\cdot l}{c} \\right\\rceil\n$$", "answer": "$$\n\\boxed{\\left\\lceil \\frac{m \\cdot l}{c} \\right\\rceil}\n$$", "id": "3621649"}, {"introduction": "虽然性能至关重要，但正确性是第一位的。在复杂的软件中，混合使用不同的 I/O 库是很常见的，但这可能会引入一些微妙而危险的错误。这项练习 [@problem_id:3621602] 探讨了在同一个文件上同时使用用户空间缓冲 I/O（如 C 语言的 `fread`）和异步系统调用所带来的风险。通过分析共享的内核状态如何变得不同步，你将学会识别并防止因这些交互而导致的数据损坏错误。", "problem": "一个程序同时使用 C 标准输入/输出库流和异步接口来操作一个常规文件。该文件通过一次打开操作获得一个单一的打开文件描述，产生一个文件描述符 `fd`，然后通过 `fdopen` 包装成一个 C 标准I/O流 (`FILE*`)。假设以下被广泛接受且经过充分测试的基本事实和定义成立：\n- 操作系统内核为每个打开文件描述维护一个当前文件偏移量 $o$，该偏移量会随着顺序读写而推进。\n- 对一个使用共享文件位置的描述符调用系统调用 `read` 会从当前偏移量 $o$ 读取数据，并将 $o$ 推进实际读取的字节数。\n- 调用系统调用 `pread` 会从一个显式指定的偏移量读取数据，而不会改变 $o$。\n- 函数 `dup` 会产生一个新的文件描述符，它指向同一个打开文件描述，因此共享当前偏移量 $o$。\n- C 标准输入/输出流 (`FILE*`) 维护一个用户空间缓冲区（假设容量为 $B = 8192$ 字节）以分摊系统调用的开销。函数 `fread` 可以通过一次或多次底层的 `read` 调用来填充此缓冲区，然后在缓冲区耗尽前，无需再次请求内核，直接从此缓冲区响应应用程序的读取请求。`FILE*` 对象内部关于下一个要交付字节的概念独立于内核的页缓存，并取决于先前获取的数据和程序后续从流中读取的操作。\n- 在 Linux `io_uring` 中，以偏移量 $-1$ 提交的操作会使用并推进共享文件位置 $o$（文件位置语义）。相比之下，POSIX 异步输入/输出操作（如 `aio_read`）使用一个显式的偏移量（来自 `aiocb->aio_offset`）并且不会改变 $o$。\n- 除非程序强制规定顺序，否则异步操作可能在相对于 `fread` 调用的任何时间完成。\n\n考虑一个大小为 $S = 16384$ 字节的文件，其中包含确定性的字节序列 $b[0..S-1]$。程序使用 `fread` 对该 `FILE*` 流进行顺序读取，但同时也对同一个底层文件提交异步操作。假设 `fread` 最初通过在偏移量 $o = 0$ 处执行一次底层 `read` 操作读取 $4096$ 字节来填充其缓冲区，然后向调用者返回 $2048$ 字节，在用户空间缓冲区中留下 $2048$ 字节未读。在返回那 $2048$ 字节后，程序立即提交一个异步操作。在异步操作完成后，程序再次调用 `fread`，期望接下来的 $2048$ 字节是序列 $b[2048..4095]$。\n\n下列哪种情况可能导致 `fread` 的状态与内核关于文件位置和缓冲数据的概念变得不同步，从而使得随后的 `fread` 调用要么跳过字节，要么重复字节，或者返回一个不等于下一个连续字节序列 $b[2048..4095]$ 的序列？选择所有适用的选项。\n\nA. 程序在 `fd` 上提交一个 `io_uring` 读操作 `IORING_OP_READ`，使用偏移量 $-1$ 读取 $4096$ 字节到一个不相关的内存缓冲区。该异步读取在下一次调用 `fread` 之前完成。\n\nB. 程序在 `fd` 上提交一个 POSIX 异步输入/输出操作 `aio_read`，设置 `aiocb->aio_offset = 4096` 以读取 $4096$ 字节到一个不相关的内存缓冲区。该异步读取在下一次调用 `fread` 之前完成。\n\nC. 程序在 `fd` 上提交一个 `io_uring` 写操作 `IORING_OP_WRITE`，使用偏移量 $-1$ 在当前文件位置 $o$ 写入 $4096$ 字节。写入的数据与 `fread` 接下来要读取的区域重叠。该异步写入在下一次调用 `fread` 之前完成。\n\nD. 程序首先通过 `fd2 = dup(fd)` 复制描述符，然后在 `fd2` 上提交一个 `io_uring` 读操作 `IORING_OP_READ`，使用偏移量 $-1$ 读取 $4096$ 字节。该异步读取在下一次调用 `fread` 之前完成。\n\nE. 程序第二次打开相同路径名，获得一个新的、独立的文件描述符 `fd3`（不是通过 `dup`），然后在 `fd3` 上提交一个等效于 `pread` 的异步读操作，从偏移量 $4096$ 读取 $4096$ 字节。该异步读取在下一次调用 `fread` 之前完成。\n\n请根据上述基本定义和异步完成的并发特性给出你的推理，重点关注在每种情况下，`fread` 的用户空间缓冲区状态与内核的打开文件描述偏移量 $o$ 是如何以及为何会发生偏离的，以及 `fread` 所看到的内核页缓存内容是否会与程序预期的 $b[0..S-1]$ 顺序视图不同。不要依赖于库特定的未文档化行为；请基于所述的标准化语义进行推理。", "solution": "### 问题验证\n\n#### 步骤 1：提取已知条件\n\n问题提供了以下事实、定义和初始条件：\n\n1.  **文件系统实体**：通过一个单一的打开文件描述来操作一个常规文件，该描述与文件描述符 `fd` 和一个由 `fdopen` 创建的 C 标准输入/输出流 `FILE*` 相关联。\n2.  **文件大小**：$S = 16384$ 字节。\n3.  **文件内容**：确定性的字节序列 $b[0..S-1]$。\n4.  **内核文件偏移量**：内核为该打开文件描述维护一个当前文件偏移量 $o$。\n5.  **系统调用语义**：\n    *   `read`：从偏移量 $o$ 读取数据，并将 $o$ 推进读取的字节数。\n    *   `pread`：从一个显式指定的偏移量读取数据，不会改变 $o$。\n    *   `dup`：创建一个新的描述符，共享同一个打开文件描述，因此也共享同一个偏移量 $o$。\n6.  **C 标准 I/O (`FILE*`) 语义**：\n    *   维护一个容量为 $B = 8192$ 字节的用户空间缓冲区。\n    *   `fread` 从此缓冲区响应读取请求。\n    *   当缓冲区耗尽时，`fread` 使用底层的 `read` 系统调用重新填充它，这些调用会推进共享的内核偏移量 $o$。\n7.  **异步 I/O 语义**：\n    *   `io_uring` (Linux)：偏移量为 $-1$ 的操作会使用并推进共享文件位置 $o$。\n    *   `POSIX` `AIO` (`aio_read`)：使用来自 `aiocb->aio_offset` 的显式偏移量，并且不会改变 $o$。\n8.  **初始场景状态**：\n    *   一次初始的 `fread` 调用导致在偏移量 $o=0$ 处进行了一次底层的 `read` 操作，读取了 $4096$ 字节。\n    *   这次初始的 `fread` 向应用程序返回了 $2048$ 字节。\n    *   C 库的用户空间缓冲区现在包含 $2048$ 字节的未读数据，对应于文件内容 $b[2048..4095]$。\n    *   一个异步操作被提交并完成。\n    *   随后的一个 `fread` 调用期望读取接下来的 $2048$ 字节，即 $b[2048..4095]$。\n\n#### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述在科学上基于操作系统的既定原则，特别是类 Unix 环境中文件 I/O 的行为。所提供的关于系统调用（`read`、`pread`、`dup`）、库函数（`fread`）以及现代异步 I/O 机制（`io_uring`、`POSIX` AIO）的定义是准确的，并且与它们在现实世界中的标准化行为一致。该场景是具体的、自包含的并且可形式化的。\n\n问题的措辞存在一个微小的歧义。它问哪种情况会导致“随后的 `fread` [返回] 一个不等于下一个连续字节序列 $b[2048..4095]$ 的序列”。鉴于初始状态，字节 $b[2048..4095]$ 已经存在于 C 库的用户空间缓冲区中。因此，紧接着对 `fread` 请求 $2048$ 字节的调用将直接从该缓冲区得到满足，无需任何内核交互，并且在所有情况下都将正确返回 $b[2048..4095]$。内核文件偏移量 $o$ 的不同步只会在*稍后*的 `fread` 调用中表现为错误，特别是在耗尽用户空间缓冲区并触发下一次底层内核 `read` 以重新填充它时。\n\n然而，问题的核心是识别那些“可能导致 `fread` 的状态与内核关于文件位置和缓冲数据的概念变得不同步”的场景。这种不同步是最终数据损坏的根本原因。将“随后的 `fread`”解释为在状态被破坏后发生的任何 `fread` 调用，而不是字面上的下一个调用，这使得问题变得有意义，并且能正确地测试所述概念。这是对问题意图的合理解释。\n\n#### 步骤 3：结论与行动\n\n在合理的解释下，即问题旨在识别哪些场景会导致文件偏移量不同步，从而导致未来的 `fread` 调用返回不正确的数据，该问题是**有效的**。本解答将基于此解释进行。\n\n### 推导与选项分析\n\n问题的核心在于对单一内核文件偏移量 $o$ 的管理，该偏移量与文件描述符 `fd` 和 `FILE*` 流共享的打开文件描述相关联。如果一个外部操作在 C 标准库不知情的情况下修改了 $o$，就会发生不同步。\n\n**初始状态分析：**\n1.  程序第一次调用 `fread`。`FILE*` 流的缓冲区是空的。\n2.  `FILE*` 流的实现发出一个系统调用 `read(fd, internal_buffer, 4096)`，从初始文件偏移量 $o = 0$ 开始。\n3.  这次 `read` 成功。内核读取了 $4096$ 字节（$b[0..4095]$）并将文件偏移量推进到 $o = 4096$。\n4.  `FILE*` 流的缓冲区现在填充了 $b[0..4095]$。\n5.  `fread` 将前 $2048$ 字节（$b[0..2047]$）复制到应用程序的缓冲区并返回。\n6.  此时，就在提交异步操作之前，状态如下：\n    *   内核文件偏移量：$o = 4096$。\n    *   `FILE*` 流的缓冲区：包含 $b[0..4095]$。\n    *   `FILE*` 流的内部位置：指向其缓冲区中下一个要提供服务的字节，该字节对应于文件内容偏移量 $2048$ 的位置。缓冲区中还剩下 $2048$ 字节（$b[2048..4095]$）。\n    *   `FILE*` 流的预期：它已经处理了直到偏移量 $4095$ 的数据。它期望下一次内核 `read` 将在偏移量 $4096$ 处发生。\n\n问题在于确定以下哪些异步操作，在下一次填充缓冲区的 `read` 之前完成，会改变内核偏移量 $o$，从而违背 `FILE*` 流的预期。\n\n**选项 A: 程序在 `fd` 上提交一个 `io_uring` 读操作 `IORING_OP_READ`，使用偏移量 $-1$ 读取 $4096$ 字节到一个不相关的内存缓冲区。该异步读取在下一次调用 `fread` 之前完成。**\n\n根据所给定义，`offset = -1` 的 `io_uring` 操作会使用并推进共享文件位置 $o$。该操作在 `fd` 上提交，而 `fd` 使用共享的打开文件描述。在此操作之前，$o = 4096$。因此，异步读取将从偏移量 $4096$ 开始，并读取 $4096$ 字节。完成后，它将文件偏移量推进 $4096$。新的内核偏移量将是 $o = 4096 + 4096 = 8192$。`FILE*` 流对此变化毫不知情。当其缓冲区最终耗尽时（在提供了缓冲的 $b[2048..4095]$ 之后），它将发出一个 `read` 系统调用，期望从偏移量 $4096$ 开始获取数据。然而，`read` 将从当前偏移量 $o=8192$ 开始，导致它读取 $b[8192..]$，实际上跳过了字节 $b[4096..8191]$。这是一种导致数据跳过的不同步。\n\n*结论*：**正确**。\n\n**选项 B: 程序在 `fd` 上提交一个 POSIX 异步输入/输出操作 `aio_read`，设置 `aiocb->aio_offset = 4096` 以读取 $4096$ 字节到一个不相关的内存缓冲区。该异步读取在下一次调用 `fread` 之前完成。**\n\n问题指出，`POSIX` `AIO` 操作（如 `aio_read`）使用显式偏移量（此处为 $4096$）并且**不会改变**共享文件偏移量 $o$。这种类型的 I/O 类似于 `pread`。该操作将读取字节 $b[4096..8191]$，但内核文件偏移量 $o$ 将保持在 $4096$ 不变。当 `FILE*` 流稍后发出其填充缓冲区的 `read` 时，它将正确地从 $o=4096$ 开始。文件偏移量没有发生不同步。\n\n*结论*：**不正确**。\n\n**选项 C: 程序在 `fd` 上提交一个 `io_uring` 写操作 `IORING_OP_WRITE`，使用偏移量 $-1$ 在当前文件位置 $o$ 写入 $4096$ 字节。写入的数据与 `fread` 接下来要读取的区域重叠。该异步写入在下一次调用 `fread` 之前完成。**\n\n与读操作类似，`offset = -1` 的 `io_uring` 写操作会使用并推进共享文件位置 $o$。在此操作之前，$o = 4096$。`io_uring` 写操作将从偏移量 $4096$ 开始，并将偏移量推进到 $o = 4096 + 4096 = 8192$。这会导致与选项 A 中相同的文件偏移量不同步，从而导致未来的 `fread` 跳过数据。此外，此操作修改了范围 $[4096, 8191]$ 内的文件内容，这意味着未来 `fread` 最终读取的数据将不来自原始序列 $b$，这是另一种形式的不同步。从跳过字节的意义上说，失败的主要原因是 $o$ 的修改。\n\n*结论*：**正确**。\n\n**选项 D: 程序首先通过 `fd2 = dup(fd)` 复制描述符，然后在 `fd2` 上提交一个 `io_uring` 读操作 `IORING_OP_READ`，使用偏移量 $-1$ 读取 $4096$ 字节。该异步读取在下一次调用 `fread` 之前完成。**\n\n`dup` 的定义指出，新的文件描述符（`fd2`）指向与原始文件描述符（`fd`）**相同的打开文件描述**。这意味着它们共享所有文件状态标志，以及至关重要的当前文件偏移量 $o$。因此，在 `fd2` 上执行一个修改 $o$ 的操作与在 `fd` 上执行该操作是无法区分的。此场景在功能上与选项 A 相同。在 `fd2` 上的 `io_uring` 读操作将从 $o = 4096$ 开始，并将其推进到 $o = 8192$。这会导致不同步，并将导致未来的 `fread` 跳过数据。\n\n*结论*：**正确**。\n\n**选项 E: 程序第二次打开相同路径名，获得一个新的、独立的文件描述符 `fd3`（不是通过 `dup`），然后在 `fd3` 上提交一个等效于 `pread` 的异步读操作，从偏移量 $4096$ 读取 $4096$ 字节。该异步读取在下一次调用 `fread` 之前完成。**\n\n再次使用 `open()` 打开文件路径会创建一个**新的、独立的**打开文件描述。这个新的描述有其自己的文件偏移量，与 `fd` 关联的偏移量 $o$ 完全分离。我们将 `fd3` 的偏移量称为 $o_3$。在 `fd3` 上的操作将使用和修改 $o_3$，但对 $o$ 没有影响。此外，指定的操作是“等效于 `pread`”，它使用一个显式的偏移量（$4096$），并且无论如何都不会修改其自身的文件偏移量（$o_3$）。与 `fd` 关联的内核文件偏移量 $o$ 保持在 $4096$，没有发生不同步。\n\n*结论*：**不正确**。", "answer": "$$\\boxed{ACD}$$", "id": "3621602"}]}