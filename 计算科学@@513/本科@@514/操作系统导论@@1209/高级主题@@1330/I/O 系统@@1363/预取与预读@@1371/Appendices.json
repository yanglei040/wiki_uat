{"hands_on_practices": [{"introduction": "高效预取的核心在于准确预测未来的访问请求。虽然简单的顺序预读很常见，但现实世界中的访问模式可能要复杂得多。本练习引入了一种更强大的技术，使用马尔可夫链来为访问模式建模，并根据概率做出最优的预取决策。通过这个练习，你将学会如何从简单的启发式方法转向数据驱动的预测策略，从而最大化预取命中率。[@problem_id:3670569]", "problem": "一个操作系统（OS）中的存储栈为一个顺序文件实现了预取和预读。实证追踪表明，以当前访问的块为条件，下一个被访问的块可以被建模为一个基于块索引的一阶马尔可夫链。设块索引集合为 $\\{1,2,3,4,5,6\\}$，且马尔可夫链的转移矩阵为 $M \\in \\mathbb{R}^{6 \\times 6}$，其中 $M_{i,j}$ 是在当前块为 $i$ 的条件下，下一个访问的块为 $j$ 的概率。根据经验估计的转移矩阵为\n$$\nM \\;=\\;\n\\begin{pmatrix}\n0.10  0.20  0.10  0.25  0.25  0.10 \\\\\n0.05  0.15  0.40  0.10  0.20  0.10 \\\\\n0.05  0.10  0.20  0.15  0.30  0.20 \\\\\n0.20  0.10  0.10  0.30  0.20  0.10 \\\\\n0.15  0.15  0.20  0.10  0.20  0.20 \\\\\n0.25  0.10  0.15  0.10  0.15  0.25\n\\end{pmatrix}.\n$$\n在时间 $t$，系统刚刚访问了块 $c_t = 3$。预取器可以选择一个预取集 $P_t \\subseteq \\{1,2,3,4,5,6\\}$，其大小 $|P_t| = k$（其中 $k = 3$），以便在下一次请求访问发生之前并行获取。假设一次预取被计为命中，当且仅当在时间 $t+1$ 请求的下一个块属于 $P_t$。设对于一个选定的集合 $P_t$，单步预期预取命中概率被定义为在马尔可夫链的下一状态分布上的期望值。\n\n仅使用一阶马尔可夫链和期望值的核心定义，从第一性原理推导出一个闭式表达式，该表达式表示可实现的最大单步预期预取命中概率，并将其表示为转移矩阵的行 $\\{M_{c_t,1},\\dots,M_{c_t,6}\\}$ 和预算 $k$ 的函数。然后，使用所提供的数据计算此表达式，得出一个表示最大单步预期预取命中概率的单一数值。将您的最终答案表示为一个不带单位的纯数。无需四舍五入。", "solution": "该问题要求推导可实现的最大单步预期预取命中概率的通用表达式，并针对一个具体案例进行求值。系统的行为被建模为一阶马尔可夫链。\n\n首先，我们验证问题陈述的有效性。\n已知条件如下：\n- 块索引集合 $S = \\{1, 2, 3, 4, 5, 6\\}$。\n- 一个具有 $6 \\times 6$ 转移矩阵 $M$ 的一阶马尔可夫链。\n- 具体的矩阵 $M$ 如下所示：\n$$\nM \\;=\\;\n\\begin{pmatrix}\n0.10  0.20  0.10  0.25  0.25  0.10 \\\\\n0.05  0.15  0.40  0.10  0.20  0.10 \\\\\n0.05  0.10  0.20  0.15  0.30  0.20 \\\\\n0.20  0.10  0.10  0.30  0.20  0.10 \\\\\n0.15  0.15  0.20  0.10  0.20  0.20 \\\\\n0.25  0.10  0.15  0.10  0.15  0.25\n\\end{pmatrix}\n$$\n- 时间 $t$ 的当前块是 $c_t = 3$。\n- 选择一个预取集 $P_t \\subseteq S$，其大小为 $|P_t| = k = 3$。\n- 如果下一个请求的块 $c_{t+1}$ 在 $P_t$ 中，则发生预取命中。\n\n该问题具有科学依据，它将概率论中的标准定义（马尔可夫链、期望值）应用于一个常见的计算机科学问题（缓存/预取）。矩阵 $M$ 的所有行之和为 1，且所有元素均为非负数，因此它是一个有效的随机矩阵。该问题是良定的，提供了找到唯一最大值所需的所有数据。其语言客观且精确。因此，该问题是有效的。\n\n我们开始求解。\n\n设系统在时间 $t$ 的状态为当前访问的块 $c_t \\in S$。问题陈述系统刚刚访问了块 $c_t = i$。根据一阶马尔可夫链的定义，下一个访问的块 $c_{t+1}$ 为块 $j$ 的概率由转移概率 $P(c_{t+1} = j | c_t = i) = M_{i,j}$ 给出。\n\n预取集 $P_t$ 是 $S$ 的一个子集，其大小为 $|P_t| = k$。如果下一个请求的块 $c_{t+1}$ 是所选预取集 $P_t$ 的一个元素，则发生预取命中。\n\n设 $H$ 为预取命中的指示随机变量。根据定义，如果 $c_{t+1} \\in P_t$ 则 $H = 1$；如果 $c_{t+1} \\notin P_t$ 则 $H = 0$。\n\n在给定当前状态 $c_t=i$ 和选定的预取集 $P_t$ 的条件下，单步预期预取命中概率是 $H$ 的期望值，记为 $E[H | c_t=i, P_t]$。使用离散随机变量的期望值定义：\n$$ E[H | c_t=i, P_t] = \\sum_{j \\in S} P(c_{t+1} = j | c_t = i) \\cdot I(j \\in P_t) $$\n其中 $I(\\cdot)$ 是指示函数，当其参数为真时值为 $1$，否则为 $0$。\n\n从马尔可夫链模型代入转移概率，我们得到：\n$$ E[H | c_t=i, P_t] = \\sum_{j=1}^{6} M_{i,j} \\cdot I(j \\in P_t) $$\n指示函数确保我们只对包含在预取集 $P_t$ 中的块 $j$ 的概率进行求和。这将表达式简化为：\n$$ E[H | c_t=i, P_t] = \\sum_{j \\in P_t} M_{i,j} $$\n该表达式给出了对于特定选择的 $P_t$ 的预期命中概率。\n\n问题要求我们找到可实现的最大单步预期预取命中概率。这需要在约束条件 $|P_t|=k$ 下，选择能使上述和最大化的集合 $P_t$。\n$$ \\max_{P_t \\subseteq S, |P_t|=k} E[H | c_t=i, P_t] = \\max_{P_t \\subseteq S, |P_t|=k} \\sum_{j \\in P_t} M_{i,j} $$\n为了使这个和最大化，我们必须从概率集合 $\\{M_{i,1}, M_{i,2}, \\dots, M_{i,6}\\}$ 中选择值最大的 $k$ 个元素。这是一种贪婪选择策略，在这种情况下是最优的，因为求和项 $M_{i,j}$ 是非负的，并且在求和中它们是相互独立的。\n\n因此，可实现的最大单步预期预取命中概率的闭式表达式是与当前状态 $c_t$ 对应的转移矩阵行中 $k$ 个最大值的和。这完成了问题的第一部分。\n\n现在，我们用所提供的数据进行计算。\n给定的当前状态是 $c_t = 3$。因此，我们关心的是矩阵 $M$ 的第3行，即：\n$$ M_{3, \\cdot} = (M_{3,1}, M_{3,2}, M_{3,3}, M_{3,4}, M_{3,5}, M_{3,6}) = (0.05, 0.10, 0.20, 0.15, 0.30, 0.20) $$\n预取预算为 $k=3$。我们需要从状态 3 中选择具有最高转移概率的 3 个块。\n这些概率是：\n- $P(c_{t+1}=1 | c_t=3) = M_{3,1} = 0.05$\n- $P(c_{t+1}=2 | c_t=3) = M_{3,2} = 0.10$\n- $P(c_{t+1}=3 | c_t=3) = M_{3,3} = 0.20$\n- $P(c_{t+1}=4 | c_t=3) = M_{3,4} = 0.15$\n- $P(c_{t+1}=5 | c_t=3) = M_{3,5} = 0.30$\n- $P(c_{t+1}=6 | c_t=3) = M_{3,6} = 0.20$\n\n为了找到 $k=3$ 个最大的概率，我们可以将它们按降序排序：\n$0.30$ (对应块 $5$)，$0.20$ (对应块 $3$)，$0.20$ (对应块 $6$)，$0.15$ (对应块 $4$)，$0.10$ (对应块 $2$)，$0.05$ (对应块 $1$)。\n\n三个最大的概率是 $0.30$、$0.20$ 和 $0.20$。\n因此，最优预取集为 $P_t^* = \\{3, 5, 6\\}$。该集合的大小为 $|P_t^*|=3$，与预算 $k$ 相符。\n\n可实现的最大单步预期预取命中概率是这三个最大概率的和：\n$$ \\max E[H] = M_{3,5} + M_{3,3} + M_{3,6} $$\n$$ \\max E[H] = 0.30 + 0.20 + 0.20 = 0.70 $$\n这就是最终的数值。", "answer": "$$\n\\boxed{0.70}\n$$", "id": "3670569"}, {"introduction": "决定了*预取什么*之后，下一个问题是预取的*积极性*应该多高。预取并非没有代价，错误的预测会浪费宝贵的I/O带宽。本练习提供了一个简单而实用的模型来量化这种浪费，并利用它来调整预取速率，这揭示了系统性能工程中的一个基本权衡。这个练习将帮助你理解如何通过控制预取策略来平衡性能收益与资源开销。[@problem_id:3670632]", "problem": "一个文件系统采用顺序预读来减轻输入/输出（I/O）延迟。预读控制器以可控速率 $r$ 发出预取请求，单位为页/秒。每个预取的页面都有 $p_m$ 的概率是错误预测，意味着该页面后续不会被工作负载使用。每次页面传输移动 $c_i$ 兆字节的数据。定义预期浪费带宽 $E[W]$ 为因传输最终未被使用的预取页面而消耗的预期数据速率，单位为兆字节/秒。\n\n仅从期望和速率的定义出发，推导出一个用 $r$、$p_m$ 和 $c_i$ 表示 $E[W]$ 的闭式表达式，然后确定使 $E[W]$ 小于或等于给定容差 $\\gamma$ 的最大 $r$ 值。使用参数 $p_m = 0.27$，$c_i = 0.384$ 兆字节/页，以及 $\\gamma = 12.5$ 兆字节/秒。以页/秒为单位表示最终的 $r$，并将您的答案四舍五入到四位有效数字。", "solution": "用户要求我首先推导预期浪费带宽 $E[W]$ 的闭式表达式，然后使用此表达式找到满足给定容差 $\\gamma$ 的最大预取速率 $r$。\n\n### 第1部分：预期浪费带宽 $E[W]$ 表达式的推导\n\n题目定义了以下量：\n- $r$：预读控制器发出预取请求的速率，单位为页/秒。\n- $p_m$：单个预取页面是错误预测（即未被使用）的概率。\n- $c_i$：单个页面传输的数据量，单位为兆字节/页。\n- $E[W]$：预期浪费带宽，即因未使用的预取页面而消耗的预期数据速率，单位为兆字节/秒。\n\n推导将从速率和期望的定义开始。\n\n让我们考虑一个持续时间为 $t$ 的时间间隔。预取速率为 $r$ 页/秒。我们可以将预取事件建模为一个随机过程。假设该过程是平稳的，在时间间隔 $t$ 内预取的页面的期望数量，记为 $E[N(t)]$，由速率乘以时间间隔的持续时间给出：\n$$E[N(t)] = r \\cdot t$$\n单位是 (页/秒) $\\times$ (秒) = 页。\n\n每个预取的页面是错误预测的独立概率为 $p_m$。设 $M_i$ 是与第 $i$ 个预取页面相关联的伯努利随机变量，如果页面是错误预测，则 $M_i=1$，如果被使用，则 $M_i=0$。$M_i$ 的期望值为：\n$$E[M_i] = 1 \\cdot p_m + 0 \\cdot (1-p_m) = p_m$$\n\n在时间间隔 $t$ 内错误预测的页面总数，我们称之为 $N_m(t)$，是该时间间隔内所有预取页面的这些伯努利变量之和：$N_m(t) = \\sum_{i=1}^{N(t)} M_i$。错误预测页面的期望数量 $E[N_m(t)]$ 可以使用全期望定律（或瓦尔德恒等式，用于随机变量的和）求得：\n$$E[N_m(t)] = E[E[N_m(t) | N(t)]] = E[N(t) \\cdot p_m] = E[N(t)] \\cdot p_m$$\n代入 $E[N(t)]$ 的表达式：\n$$E[N_m(t)] = (r \\cdot t) \\cdot p_m$$\n\n在时间间隔 $t$ 内浪费的总数据量，我们称之为 $D_W(t)$，是错误预测的页面数乘以每页的数据大小 $c_i$：\n$$D_W(t) = N_m(t) \\cdot c_i$$\n因此，预期的浪费数据量为：\n$$E[D_W(t)] = E[N_m(t) \\cdot c_i] = E[N_m(t)] \\cdot c_i = (r \\cdot t \\cdot p_m) \\cdot c_i$$\n\n预期浪费带宽 $E[W]$ 定义为预期浪费数据速率。这是单位时间内的预期浪费数据量：\n$$E[W] = \\frac{E[D_W(t)]}{t}$$\n代入 $E[D_W(t)]$ 的表达式：\n$$E[W] = \\frac{r \\cdot t \\cdot p_m \\cdot c_i}{t}$$\n时间持续 $t$ 被消去，得到预期浪费带宽的闭式表达式：\n$$E[W] = r \\cdot p_m \\cdot c_i$$\n该表达式的单位是 (页/秒) $\\times$ (无量纲) $\\times$ (兆字节/页)，正确地得出兆字节/秒。\n\n### 第2部分：最大预取速率 $r$ 的计算\n\n问题要求找到使预期浪费带宽 $E[W]$ 保持小于或等于给定容差 $\\gamma$ 的最大预取速率 $r$。约束条件是：\n$$E[W] \\le \\gamma$$\n代入推导出的 $E[W]$ 表达式：\n$$r \\cdot p_m \\cdot c_i \\le \\gamma$$\n为了找到满足此条件的最大 $r$，我们对不等式求解 $r$。由于 $p_m$ 和 $c_i$ 是正的物理量，我们可以用它们的乘积除以不等式两边而不改变不等号的方向：\n$$r \\le \\frac{\\gamma}{p_m \\cdot c_i}$$\n因此，$r$ 的最大允许值，我们可以表示为 $r_{max}$，是：\n$$r_{max} = \\frac{\\gamma}{p_m \\cdot c_i}$$\n\n现在，我们将给定的数值代入这个表达式：\n- $\\gamma = 12.5$ 兆字节/秒\n- $p_m = 0.27$\n- $c_i = 0.384$ 兆字节/页\n\n计算如下：\n$$r_{max} = \\frac{12.5}{0.27 \\times 0.384}$$\n首先，我们计算分母中的乘积：\n$$p_m \\cdot c_i = 0.27 \\times 0.384 = 0.10368$$\n现在，我们进行除法：\n$$r_{max} = \\frac{12.5}{0.10368} \\approx 120.563271605...$$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $1$、$2$、$0$ 和 $5$。第五位有效数字是 $6$，大于或等于 $5$，所以我们将第四位有效数字向上取整。\n$$r_{max} \\approx 120.6$$\n单位是 页/秒。\n因此，使预期浪费带宽保持在容差或以下的最高预取速率为 $120.6$ 页/秒。", "answer": "$$\n\\boxed{120.6}\n$$", "id": "3670632"}, {"introduction": "预取并非在真空中运行。在多进程系统中，一个进程的激进预取策略可能会通过独占I/O设备而不公平地损害其他进程。本练习将视角从单个进程的优化转移到系统级的公平性，挑战你思考如何设计调度策略，在享受预取带来的好处的同时，不牺牲公平性。它强调了为资源管理选择正确记账指标（如设备占用时间而非请求数量）的重要性。[@problem_id:3670602]", "problem": "两个长时间运行的进程共享一个磁盘。进程 $P_s$ 对一个大文件执行顺序扫描，按逻辑块号顺序发出块读取请求；进程 $P_r$ 在整个磁盘上发出均匀随机的块读取请求。当操作系统检测到顺序访问时，会通过发出预期的连续读取来为 $P_s$ 提供预读功能。你需要从第一性原理出发，对输入/输出（I/O）调度进行推理。\n\n假设一个简单且广泛使用的磁盘时间模型：单个块的随机读取服务时间是平均寻道时间、平均旋转延迟和传输时间之和。分别将它们表示为 $t_{\\text{seek}}$、$t_{\\text{rot}}$ 和 $t_{\\text{xfer}}$。对于磁盘可以流式传输的一批 $k$ 个连续块，总服务时间可以很好地近似为 $t_{\\text{seek}} + t_{\\text{rot}} + k \\cdot t_{\\text{xfer}}$，因为寻道和旋转开销在这次运行中只产生一次，而传输成本则按块累积。假设 $t_{\\text{seek}} = 8\\,\\text{ms}$，$t_{\\text{rot}} = 4\\,\\text{ms}$，以及 $t_{\\text{xfer}} = 1\\,\\text{ms}$。\n\n调度器的公平性目标是，当两个进程都有积压请求时，给予 $P_s$ 和 $P_r$ 长期均等的磁盘繁忙时间份额，即在长时间间隔内，每个进程都应被计费并获得大约 $1/2$ 的设备时间。同时，调度器应保留顺序访问的好处：当检测到 $P_s$ 是顺序访问时，应允许它通过发出短暂的连续读取突发（有界以避免对 $P_r$ 造成大的队头延迟）来利用连续性。系统提供了每个进程的预读信用 $c_i$，调度器可以维护和消耗这些信用以调节突发读取。\n\n考虑以下具体的运行条件来检验你的推理：在某个瞬间，两个进程都持续有积压请求；$P_s$ 的顺序访问检测器提供了一个 $w_s = 32$ 个连续块的预读窗口准备发出；信用被初始化为相等的值 $c_s = c_r = 20\\,\\text{ms}$；每个进程的信用以每毫秒墙上时钟时间 $\\alpha$ 个信用的恒定速率持续补充，$\\alpha$ 的选择使得当两个进程都有积压时，每个进程平均获得 $1/2$ 的设备时间。\n\n在这些假设下，哪种调度策略在实现公平性目标的同时，最好地保留了上述的顺序访问优势？\n\nA. 为每个进程 $i$ 维护一个时间信用桶 $c_i$（以毫秒设备时间为单位）。在调度进程 $i$ 时，允许最多 $k$ 个连续块的突发读取，条件是 $k \\le w_i$（预测的连续性窗口）且 $t_{\\text{seek}} + t_{\\text{rot}} + k \\cdot t_{\\text{xfer}} \\le \\min(c_i, \\Delta_{\\max})$，其中 $\\Delta_{\\max}$ 是对每次突发的设备时间的固定上限，以限制最坏情况下的延迟。根据突发读取的估计设备时间扣除进程 $i$ 的信用，即从 $c_i$ 中减去 $t_{\\text{seek}} + t_{\\text{rot}} + k \\cdot t_{\\text{xfer}}$，然后在 $c_i$ 不足以读取另一个块时进行切换。以速率 $\\alpha$ 补充每个 $c_i$，以便当两个进程都有积压时，从长远来看，每个进程都能累积获得 $1/2$ 的设备时间。\n\nB. 为每个进程分配每轮 $q$ 个请求的相等配额；合并的或连续的运行无论其大小都算作一个请求。在严格的轮询中交替轮次。以相同的速率为两个进程补充每轮配额，以实现请求数量上的公平。\n\nC. 优先考虑连续性：总是为下一个请求与当前磁头位置连续的进程服务，只要 $P_s$ 的顺序访问检测器保持活动就继续为 $P_s$ 服务，只有在没有连续请求待处理时才切换到 $P_r$。\n\nD. 维护每个进程的块信用 $c_i$（以块为单位）。每完成一个块，所有者的 $c_i$ 减 1，但对于通过预读获得的连续运行，只有运行的第一个块消耗信用，因为其余的块“免除”了寻道/旋转开销。以相同的块速率补充 $c_s$ 和 $c_r$，以便每个进程随时间获得相等数量的计入信用的块。\n\n通过选择最能满足长期均等设备时间公平性、保留顺序访问好处并限制最坏情况延迟的选项来回答。你可以使用提供的数值来对策略进行合理性检查：例如，在 $c_s = 20\\,\\text{ms}$ 和上述模型下，估计选项 A 会在一次突发中授予 $P_s$ 的最大连续块数 $k$，并比较在相同策略下 $P_r$ 在耗尽 $c_r$ 之前可以读取多少个随机块。", "solution": "用户要求对问题陈述进行严格验证，然后从第一性原理推导出解决方案，并对所有提供的选项进行评估。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   进程：$P_s$（顺序文件扫描）和 $P_r$（均匀随机块读取）。\n-   共享资源：一个磁盘。\n-   操作系统特性：为 $P_s$ 提供连续块的预读功能。\n-   磁盘服务时间模型：\n    -   单次随机读取：$t_{\\text{random}} = t_{\\text{seek}} + t_{\\text{rot}} + t_{\\text{xfer}}$。\n    -   $k$ 个连续块的突发读取：$t_{\\text{contiguous}}(k) = t_{\\text{seek}} + t_{\\text{rot}} + k \\cdot t_{\\text{xfer}}$。\n-   模型参数：\n    -   $t_{\\text{seek}} = 8\\,\\text{ms}$\n    -   $t_{\\text{rot}} = 4\\,\\text{ms}$\n    -   $t_{\\text{xfer}} = 1\\,\\text{ms}$\n-   调度器目标：\n    1.  **公平性**：$P_s$ 和 $P_r$ 获得长期均等的磁盘繁忙时间份额（即每个进程获得约 $1/2$ 的总设备时间）。\n    2.  **效率**：通过允许突发读取来保留 $P_s$ 的顺序访问好处。\n    3.  **延迟**：限制每次突发的时间，以避免对 $P_r$ 造成大的队头延迟。\n-   调度器机制：每个进程的预读信用 $c_i$。\n-   具体运行条件：\n    -   $P_s$ 和 $P_r$ 持续有积压请求。\n    -   $P_s$ 预读窗口：$w_s = 32$ 个块。\n    -   初始信用：$c_s = c_r = 20\\,\\text{ms}$。\n    -   信用补充速率：每个进程每毫秒墙上时钟时间 $\\alpha$ 个信用，对两个进程相同。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据指定标准对问题陈述进行评估：\n-   **科学基础：** 该问题基于操作系统中的基本和标准概念，特别是针对磁盘的 I/O 调度。磁盘时间模型是一个被广泛使用和接受的简化模型。顺序与随机访问、预读以及基于信用的资源调度等概念都是该领域的标准内容。数值对于硬盘驱动器是合理的。该问题在科学上是合理的。\n-   **适定性：** 这是一个适定问题。它清晰地定义了系统、进程、性能模型和目标（时间公平性、效率）。它要求确定哪个给定策略最能满足这些目标。这是一个标准的比较分析问题，可以根据所提供的信息得出明确的结论。\n-   **客观性：** 语言技术性强、精确且没有主观性。公平性标准被量化定义为均等的磁盘繁忙时间份额。\n-   **完整性和一致性：** 问题是自洽的，提供了分析所提出策略所需的所有必要信息（参数、模型、目标）。设置中没有矛盾。\n-   **现实性和可行性：** 该场景代表了操作系统设计中的一个经典且实际的问题：管理混合的顺序和随机 I/O 工作负载。所提出的基于信用的调度是一种现实且可实现的技术。\n\n**步骤 3：结论和行动**\n问题陈述是**有效的**。这是一个结构良好、科学合理且清晰的问题，考验了操作系统资源管理的基本原则。我现在将继续进行解决方案的推导。\n\n### 解决方案推导\n\n主要目标是找到一个在**磁盘繁忙时间**方面提供公平性的调度策略。一个次要但重要的目标是允许 $P_s$ 利用其顺序访问模式以实现高效率（吞吐量）。我们首先使用给定的参数计算两种请求的服务时间：$t_{\\text{seek}} = 8\\,\\text{ms}$，$t_{\\text{rot}} = 4\\,\\text{ms}$ 和 $t_{\\text{xfer}} = 1\\,\\text{ms}$。\n\n-   由 $P_r$ 执行的单次随机读取的时间是：\n    $$t_{\\text{random}} = t_{\\text{seek}} + t_{\\text{rot}} + t_{\\text{xfer}} = 8\\,\\text{ms} + 4\\,\\text{ms} + 1\\,\\text{ms} = 13\\,\\text{ms}$$\n-   由 $P_s$ 执行的 $k$ 个连续块的突发读取时间是：\n    $$t_{\\text{contiguous}}(k) = t_{\\text{seek}} + t_{\\text{rot}} + k \\cdot t_{\\text{xfer}} = (12 + k)\\,\\text{ms}$$\n\n公平性目标指出，在很长一段时间内，服务于 $P_s$ 的总时间应等于服务于 $P_r$ 的总时间。这要求调度策略核算并平衡每个进程消耗的*时间*，而不是请求或块的数量。\n\n我们现在将根据这个原则分析每个选项。\n\n**选项 A 评估**\n该策略提出了一个基于时间的信用系统。\n-   **机制**：只要估计的时间成本在其信用余额 $c_i$ 之内，进程就可以发出 I/O 突发。消耗的信用等于估计的设备时间。两个进程的信用以相同的速率 $\\alpha$ 补充。\n-   **公平性分析**：该策略直接实现了期望的公平性目标。通过以时间单位（毫秒）来计价信用，并按估计的服务时间收费，调度器确保了被共享的资源就是磁盘时间本身。由于两个有积压请求的进程以相同的速率赚取信用，从长远来看，它们将有权消耗等量的磁盘时间。例如，如果 $P_s$ 总共消耗了 $T_S$ 毫秒，$P_r$ 总共消耗了 $T_R$ 毫秒，那么它们必须分别花费了大约 $T_S$ 和 $T_R$ 的信用。由于信用是平等获得的，因此必然有 $T_S \\approx T_R$。这个机制在时间上是根本公平的。\n-   **效率分析**：该策略允许 $P_s$ 发出 $k$ 个块的突发，从而利用了连续性。突发的大小受其可用信用和预读窗口 $w_s$ 的限制。使用给定的数字，当 $c_s = 20\\,\\text{ms}$ 时，$P_s$ 可以发出最多 $k$ 个块的突发，使得 $12+k \\le 20$，这意味着 $k \\le 8$。这使得 $P_s$ 可以用 $20\\,\\text{ms}$ 的磁盘时间读取 $8$ 个块（平均 $2.5\\,\\text{ms}$/块）。相比之下，$P_r$ 用 $c_r = 20\\,\\text{ms}$ 的信用可以执行一次随机读取，耗时 $13\\,\\text{ms}$，获得 $1$ 个块。该策略成功地实现了顺序 I/O 的高效率。\n-   **延迟限制**：该策略明确包含一个上限 $\\Delta_{\\max}$，以防止过长的突发，从而解决了队头阻塞问题。\n-   **结论**：**正确**。该策略的机制与实现基于时间的公平性和效率目标完全一致。\n\n**选项 B 评估**\n该策略提出了基于请求数量的公平性。\n-   **机制**：每个进程每轮获得 $q$ 个请求的配额。一个连续的运行算作一个请求。\n-   **公平性分析**：这个策略在 I/O *请求*数量上是公平的，但在*时间*上不公平。来自 $P_s$ 的一个请求可能是一次 $k=8$ 个块的突发，耗时 $t_{\\text{contiguous}}(8) = 20\\,\\text{ms}$。来自 $P_r$ 的一个请求耗时 $t_{\\text{random}} = 13\\,\\text{ms}$。如果它们以 $q=1$ 交替轮次，磁盘时间的比例是 $20:13$，这不相等。如果允许 $P_s$ 发出更大的突发（例如，最多 $w_s=32$ 个块，耗时 $44\\,\\text{ms}$），时间差距会变得更大。这个策略未能达到主要的公平性目标。\n-   **结论**：**不正确**。\n\n**选项 C 评估**\n该策略优先考虑连续性。\n-   **机制**：如果存在连续请求，调度器总是为其服务。只要检测到顺序访问，它就为 $P_s$ 服务。\n-   **公平性分析**：问题陈述指出 $P_s$ 正在对一个*大文件*进行扫描，并且持续有积压请求。这意味着 $P_s$ 几乎总是有一个准备好的连续请求。因此，该策略几乎会独占地将磁盘授予 $P_s$，导致 $P_r$ 的有效饿死。这是对公平性目标的最大违反。它也违反了限制队头延迟的既定目标。\n-   **结论**：**不正确**。\n\n**选项 D 评估**\n该策略提出了一种特殊的基于块信用的公平性。\n-   **机制**：信用以块为单位。一次随机读取耗费 $1$ 个信用。对于一次连续运行，只有第一个块耗费 $1$ 个信用，其余的都是“免费的”。两个进程的信用以相同的速率（以块为单位）补充。\n-   **公平性分析**：这是另一种不与设备时间挂钩的记账形式。假设每个进程累积了 $1$ 个信用。$P_r$ 可以用它来读取 $1$ 个块，消耗 $13\\,\\text{ms}$ 的磁盘时间。$P_s$ 可以用它的 $1$ 个信用读取一个 $k$ 块的突发（例如，$k=8$），消耗 $(12+k)\\,\\text{ms} = 20\\,\\text{ms}$ 的磁盘时间。在相同的信用成本下，$P_s$ 使用的磁盘时间明显多于 $P_r$。这个策略在设备时间方面是不公平的。它实际上等同于选项 B，其中记账单位是“计入信用的 I/O 操作”而不是时间。\n-   **结论**：**不正确**。\n\n### 结论\n实现资源公平性的基本原则是度量和分配该特定资源。这里要公平共享的资源是“磁盘繁忙时间”。选项 A 是唯一使用基于时间的信用机制的策略，该机制直接度量和分配磁盘时间。其他选项度量的是请求或块，这在混合 I/O 工作负载中是时间的糟糕替代品，因此未能实现公平性目标。选项 A 正确地为磁盘时间实现了一个比例份额调度器，满足了所有既定目标。", "answer": "$$\\boxed{A}$$", "id": "3670602"}]}