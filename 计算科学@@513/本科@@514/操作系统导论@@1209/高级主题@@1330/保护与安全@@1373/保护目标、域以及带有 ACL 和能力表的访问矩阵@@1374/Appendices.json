{"hands_on_practices": [{"introduction": "访问控制列表（Access Control Lists, ACLs）是保护操作系统中资源的一种常见方法，但其有效性取决于精确的评估规则。本练习将探讨访问控制条目（Access Control Entries, ACEs）的顺序如何极大地改变访问请求的结果，强调了非规范化列表与规范化列表之间的关键差异。通过解决这个问题 [@problem_id:3674094]，您将具体理解为何“拒绝优先”不仅仅是一个概念，更是一个具有重大安全影响的实现细节。", "problem": "考虑一个受自主访问控制列表 (DACL) 保护的对象 $O$，DACL 是某些操作系统中对象的一种特殊访问控制列表 (ACL)。DACL 由访问控制条目 (ACE) 组成，每个条目都将一个主体与一组允许或拒绝的权限相关联。假设用户 $u$ 是组 $g$ 的成员。对象 $O$ 上的 DACL 具有以下非规范顺序的显式 ACE（按从上到下列出的顺序）：\n\n$1.$ 允许 $u$ 进行 $W$。\n$2.$ 允许 $g$ 进行 $R$。\n$3.$ 拒绝 $g$ 进行 $W$。\n$4.$ 拒绝 $u$ 进行 $R$。\n\n假设此系统的规范 ACL 排序将所有显式拒绝 ACE 排在所有显式允许 ACE 之前，并将继承的 ACE 放在显式 ACE 之后。在此场景中没有继承的 ACE。权限是标准的读 $R$ 和写 $W$。\n\n从访问矩阵模型中的核心访问控制概念出发，将 DACL 转换为其规范顺序，并推断当 $u$ 仅请求 $R$、仅请求 $W$ 时的有效访问权限，以及 ACE 排序对访问检查的影响。然后，比较在基于能力（capability-based）的系统中，拒绝是如何表达的。这类系统将权限表示为不可伪造的令牌，而不是每个对象上的 ACL。\n\n下列哪个陈述是正确的？\n\nA. 在上述给定的非规范 ACE 顺序下，$u$ 仅请求 $W$ 会成功，$u$ 仅请求 $R$ 也会成功；在规范顺序下，两者都会失败，因为拒绝 ACE 会被首先评估。\n\nB. 在规范 ACL 中，即使用户 $u \\in g$，针对 $u$ 的特定允许 ACE 也会覆盖针对 $g$ 的拒绝 ACE，因此尽管存在组拒绝，$u$ 仍然可以写入 $O$，且这与 ACE 顺序无关。\n\nC. 在基于能力的系统中，访问检查时没有原生的“拒绝”操作；为了在一个能力（capability）分发后阻止 $W$ 操作，常见的模式是避免颁发 $W$ 能力，或使用到可撤销引用的间接方式，从而实现撤销，而无需跨主体组合“拒绝”条目。\n\nD. 规范化不会改变有效访问权限，因为系统会计算所有允许权限的并集减去所有拒绝权限的并集，而不管 ACE 的顺序如何。\n\nE. 规范化通过将多个主体折叠到单个 ACE 中来降低访问矩阵的维度，这就是它改变有效访问权限的原因。\n\n选择所有适用的选项。", "solution": "问题陈述描述了自主访问控制 (DAC) 中的一个场景，涉及一个对象 $O$、一个用户 $u$ 和一个组 $g$，其中 $u$ 是 $g$ 的成员（表示为 $u \\in g$）。访问权限由自主访问控制列表 (DACL) 控制，基本任务是确定用户 $u$ 在两种不同的访问控制条目 (ACE) 排序下的有效权限，并将 ACL 模型与基于能力的系统进行比较。\n\n### 步骤 1：提取已知条件\n\n-   对象：$O$\n-   用户：$u$\n-   组：$g$\n-   成员关系：$u \\in g$\n-   权限：读 ($R$) 和写 ($W$)\n-   $O$ 上的非规范 DACL：\n    $1.$ 允许 $u$ 进行 $W$。\n    $2.$ 允许 $g$ 进行 $R$。\n    $3.$ 拒绝 $g$ 进行 $W$。\n    $4.$ 拒绝 $u$ 进行 $R$。\n-   规范排序规则：所有显式拒绝 ACE 排在所有显式允许 ACE 之前。\n-   继承的 ACE：无。\n-   访问检查模型：问题暗示了对 ACE 的顺序评估，其中访问检查算法在遇到第一个确定所请求访问权限结果的 ACE 时停止。这是像 Windows NT 这类系统的标准行为，该模型即源于此。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题基于操作系统安全领域的核心、公认概念，特别是访问矩阵模型及其实际实现：访问控制列表 (ACL) 和能力 (capabilities)。所描述的 DACL 行为、规范排序以及“拒绝优先于允许”的原则是真实操作系统中的标准特性。该问题牢固地植根于计算机科学原理。\n-   **问题定义良好**：问题提供了一整套规则和初始条件。给定的 ACE、用户-组关系以及规范排序的规则足以推导出用户 $u$ 的唯一有效权限集。\n-   **客观性**：问题使用了计算机安全领域的精确、标准术语。没有主观或模棱两可的陈述。\n\n问题陈述是有效的。这是一个在操作系统安全领域中形式良好的概念性问题。\n\n### 步骤 3：推导与分析\n\n**非规范 ACE 顺序分析**\n\n系统按指定顺序评估 ACE：$1, 2, 3, 4$。当用户 $u$ 请求访问时，系统会检查直接与 $u$ 相关的 ACE，以及与 $u$ 所属的任何组（在本例中为 $g$）相关的 ACE。\n\n1.  **用户 $u$ 请求写 ($W$) 访问：**\n    系统扫描 ACL：\n    -   ACE $1$：`允许 W 给 u`。此 ACE 明确匹配用户 $u$ 和请求的权限 $W$。访问被授予。评估过程终止。\n    -   **结果：**对 $W$ 访问的请求被**授予**。\n\n2.  **用户 $u$ 请求读 ($R$) 访问：**\n    系统扫描 ACL：\n    -   ACE $1$：`允许 W 给 u`。这与请求的权限 $R$ 不匹配。扫描继续。\n    -   ACE $2$：`允许 R 给 g`。由于 $u \\in g$，此 ACE 匹配用户的组成员身份和请求的权限 $R$。访问被授予。评估过程终止。\n    -   **结果：**对 $R$ 访问的请求被**授予**。\n\n总而言之，在非规范排序下，用户 $u$ 被授予对对象 $O$ 的 $R$ 和 $W$ 访问权限。\n\n**规范 ACE 顺序分析**\n\n规范化规则要求将所有拒绝 ACE 放在所有允许 ACE 之前。\n-   拒绝 ACE：`3. 拒绝 g 进行 W` 和 `4. 拒绝 u 进行 R`。\n-   允许 ACE：`1. 允许 u 进行 W` 和 `2. 允许 g 进行 R`。\n\n规范的 DACL 变为（在本例中，拒绝和允许块内部的子排序不影响结果）：\n$1'.$ `拒绝 g 进行 W` (来自原始的 $3$)\n$2'.$ `拒绝 u 进行 R` (来自原始的 $4$)\n$3'.$ `允许 u 进行 W` (来自原始的 $1$)\n$4'.$ `允许 g 进行 R` (来自原始的 $2$)\n\n现在，我们根据这个规范列表重新评估用户 $u$ 的访问请求。\n\n1.  **用户 $u$ 请求写 ($W$) 访问：**\n    系统扫描规范 ACL：\n    -   ACE $1'$：`拒绝 W 给 g`。由于 $u \\in g$，此 ACE 匹配用户的组和请求的权限 $W$。访问被拒绝。评估过程终止。\n    -   **结果：**对 $W$ 访问的请求被**拒绝**。\n\n2.  **用户 $u$ 请求读 ($R$) 访问：**\n    系统扫描规范 ACL：\n    -   ACE $1'$：`拒绝 W 给 g`。这与请求的权限 $R$ 不匹配。扫描继续。\n    -   ACE $2'$：`拒绝 R 给 u`。此 ACE 明确匹配用户 $u$ 和请求的权限 $R$。访问被拒绝。评估过程终止。\n    -   **结果：**对 $R$ 访问的请求被**拒绝**。\n\n总而言之，在规范排序下，用户 $u$ 的 $R$ 和 $W$ 访问都被拒绝。这种排序强制执行了“拒绝优先于允许”的策略。\n\n**选项评估**\n\n**A. 在上述给定的非规范 ACE 顺序下，$u$ 仅请求 $W$ 会成功，$u$ 仅请求 $R$ 也会成功；在规范顺序下，两者都会失败，因为拒绝 ACE 会被首先评估。**\n-   如上推导，在非规范顺序下，对 $W$ 的请求因 ACE $1$ 而成功，对 $R$ 的请求因 ACE $2$ 而成功。\n-   如上推导，在规范顺序下，对 $W$ 的请求因 `拒绝 W 给 g` 的 ACE 而失败，对 $R$ 的请求因 `拒绝 R 给 u` 的 ACE 而失败。两者都失败是因为在允许 ACE 之前遇到并处理了拒绝 ACE。\n-   该陈述与我们的分析完全一致。\n-   **结论：正确**\n\n**B. 在规范 ACL 中，即使用户 $u \\in g$，针对 $u$ 的特定允许 ACE 也会覆盖针对 $g$ 的拒绝 ACE，因此尽管存在组拒绝，$u$ 仍然可以写入 $O$，且这与 ACE 顺序无关。**\n-   这个陈述有两个不正确的论点。首先，它暗示特异性（针对 $u$ 的 ACE vs. 针对 $g$ 的 ACE）是主导规则。然而，问题陈述指出规范排序规则是基于访问类型（拒绝 vs. 允许）的。在我们对 $W$ 权限的规范评估中，`拒绝 W 给 g` 在 `允许 W 给 u` 之前被评估，导致访问被拒绝。针对 $u$ 的特定允许*并不*覆盖针对 $g$ 的组拒绝。其次，它声称这“与 ACE 顺序无关”，这显然是错误的；我们的分析表明，顺序正是改变结果的原因。\n-   **结论：错误**\n\n**C. 在基于能力的系统中，访问检查时没有原生的“拒绝”操作；为了在一个能力（capability）分发后阻止 $W$ 操作，常见的模式是避免颁发 $W$ 能力，或使用到可撤销引用的间接方式，从而实现撤销，而无需跨主体组合“拒绝”条目。**\n-   该陈述准确地描述了基于能力的安全性（capability-based security）的一个基本方面。访问权限是基于持有不可伪造的令牌（能力），该令牌以密码学方式将主体与具有特定权限的对象绑定。如果一个主体不具备允许某个操作的能力，则访问是不可能的。对象上没有单独的“拒绝”列表的概念。撤销（收回已授予的权限）问题是能力系统中的一个经典挑战，该陈述正确地指出了两个主要解决方案：谨慎的初始分发（最小权限原则）和通过代理对象使用间接引用，这允许集中撤销权限。\n-   **结论：正确**\n\n**D. 规范化不会改变有效访问权限，因为系统会计算所有允许权限的并集减去所有拒绝权限的并集，而不管 ACE 的顺序如何。**\n-   该陈述描述了一种不同的、基于集合的访问评估模型。如果使用此模型，权限将被计算为：（来自 `允许 W 给 u` 的权限 $\\cup$ 来自 `允许 R 给 g` 的权限）$-$（来自 `拒绝 W 给 g` 的权限 $\\cup$ 来自 `拒绝 R 给 u` 的权限）。对于用户 $u$，这将是 $(\\{W\\} \\cup \\{R\\}) - (\\{W\\} \\cup \\{R\\}) = \\emptyset$。该模型将导致 $u$ 没有任何权限。然而，我们对非规范、顺序评估的分析表明 $u$ *确实*获得了权限。由于规范化明显改变了问题所描述模型中的有效访问权限（从 $\\{R, W\\}$ 到 $\\emptyset$），该陈述的前提是错误的。\n-   **结论：错误**\n\n**E. 规范化通过将多个主体折叠到单个 ACE 中来降低访问矩阵的维度，这就是它改变有效访问权限的原因。**\n-   这个陈述在概念上是有缺陷的。规范化是一个应用于 ACL 中 ACE 集合的*排序*过程；它不会“折叠”主体或 ACE。访问矩阵是一个具有维度（主体，对象）的理论模型；ACL 是该矩阵中的一列。重新排列列中的条目不会改变矩阵的维度。规范化改变有效访问权限的原因是评估算法的顺序性，而不是因为访问矩阵本身的基础结构发生了任何变化。\n-   **结论：错误**", "answer": "$$\\boxed{AC}$$", "id": "3674094"}, {"introduction": "在静态策略评估的基础上，本实践深入探讨了动态系统的复杂性，在这些系统中，授权随时可能发生变化。它引入了经典的“检查时-使用时”（Time-Of-Check-To-Time-Of-Use, TOCTTOU）漏洞，这是一个微妙但至关重要的安全缺陷。这个练习 [@problem_id:3674083] 挑战您像系统设计师一样思考，评估不同的架构策略，以确保访问决策从检查的那一刻到使用的那一刻都保持有效。", "problem": "一个多用户操作系统使用访问矩阵模型实现访问控制，其中访问矩阵 $M$ 将一个主体 $s$ 和一个客体 $o$ 映射到一个权限集合 $R = M[s,o]$。客体带有访问控制列表（ACLs），主体可以是组的成员。客体 $o$ 的ACL为一组主体（用户和组）授予对 $o$ 的权限。组成员关系由一个动态组成员服务提供，该服务维护一个函数 $G(s,t)$，给出主体 $s$ 在时间 $t$ 所属的组集合。系统在时间 $t$ 的授权规则是：主体 $s$ 可以对客体 $o$ 行使权限 $r$ 当且仅当 $G(s,t) \\cap \\text{ACL}_o(r)$ 的交集非空。\n\n保护目标是维护授权决策的完整性并强制执行立即撤销：如果主体 $s$ 在时间 $t_r$ 从一个授权组中被移除，那么 $s$ 在时间 $t_r$ 之前尚未提交的任何操作都不得基于已被撤销的成员关系成功。考虑一个典型的“检查时-使用时”（TOCTTOU）竞争：一个用户级进程在时间 $t_c$ 发起一个操作；内核使用 $G(s,t_c)$ 和 $\\text{ACL}_o$ 检查授权；在该操作于时间 $t_u$ 提交之前，组服务在时间 $t_r$ 更新了 $G(s,t)$，其中 $t_c  t_r  t_u$。\n\n在保持系统科学现实性的前提下，选择所有能在动态组成员关系下消除授权的TOCTTOU竞争并实现立即撤销的设计选项。在每种情况下，假设内核可以访问ACL和组成员关系的权威状态。\n\nA) 在单次内核进入中执行授权和资源操作，同时对相关策略状态持有一致性原语：内核读取一个覆盖 $\\text{ACL}_o$ 和 $G$ 中相关组的版本 $v$，进行授权，执行操作，然后在提交前重新检查版本是否仍为 $v$；策略更新（ACL编辑或组成员关系变更）将版本号原子地加1。如果版本已更改，则中止操作并在内核内作为单个操作重试。\n\nB) 将授权和使用分为两个独立的系统调用：第一个调用在用户空间检查成员关系并返回一个布尔值，如果布尔值为真，则第二个调用执行操作。依赖调度器来避免在两次调用之间发生抢占。\n\nC) 在用户空间缓存肯定的授权结果，并设置一个生存时间 $\\tau$：如果操作在缓存的检查结果产生后的时间 $\\tau$ 内开始，则跳过重新授权；否则，重新授权。\n\nD) 维护每个客体的ACL生成计数器 $g_o$，以及可选的每个主体的组成员关系生成计数器 $g_s$。当内核为主体 $s$ 授权对客体 $o$ 的操作时，它将观察到的 $(g_o, g_s)$ 绑定到生成的操作句柄或进行中操作描述符上。每次使用时都验证当前的生成计数器值是否与绑定的值相等；任何对 $o$ 的ACL编辑或对 $s$ 的组成员关系变更都会将相应的生成计数器原子地加1，从而使过时的句柄失效，并在使用前强制重新授权。\n\n选择所有适用的选项。", "solution": "问题陈述描述了操作系统访问控制机制中一个典型的“检查时-使用时”（TOCTTOU）竞争条件。由于存在一个动态的组成员服务 $G(s,t)$，系统状态是动态的。授权检查在时间 $t_c$ 执行，但底层的授权状态（组成员关系）在操作于时间 $t_u$ 完成之前，于时间 $t_r$ 发生了变化，其中 $t_c  t_r  t_u$。安全目标是强制执行“立即撤销”，这意味着如果操作的授权基础在时间 $t_r$ 已失效，则该操作在时间 $t_u$ 必须不能成功。\n\n首先，对问题陈述进行验证。\n**步骤1：提取已知条件**\n- 访问矩阵：$M$，其中 $M[s,o] = R$ 代表主体 $s$、客体 $o$ 和权限集合 $R$。\n- 实现方式：客体拥有访问控制列表（ACL）。主体拥有组成员关系。\n- 组成员关系：一个函数 $G(s,t)$ 给出主体 $s$ 在时间 $t$ 所属的组集合。\n- 授权规则：主体 $s$ 在时间 $t$ 对客体 $o$ 拥有权限 $r$ 当且仅当 $G(s,t) \\cap \\text{ACL}_o(r)$ 的交集非空，其中 $\\text{ACL}_o(r)$ 是被授权在 $o$ 上拥有权限 $r$ 的主体集合。\n- 保护目标：立即撤销。如果主体 $s$ 在时间 $t_r$ 从一个组中被移除，则 $s$ 在 $t_r$ 之前开始的任何未提交操作，若其授权依赖于该组成员关系，则必须失败。\n- 场景：一个TOCTTOU竞争，其中授权检查发生在 $t_c$，撤销发生在 $t_r$，资源使用发生在 $t_u$，时间顺序为 $t_c  t_r  t_u$。\n\n**步骤2：使用提取的已知条件进行验证**\n问题陈述在科学上基础扎实、阐述清晰且客观。它在动态访问控制策略的背景下，形式化了一个众所周知d的安全漏洞（TOCTTOU），这是操作系统安全领域的一个标准课题。所使用的概念（ACL、组成员关系、访问矩阵、原子性）都是标准的。问题是自包含的，不包含矛盾或事实错误。\n\n**步骤3：结论和行动**\n问题是有效的。我将继续分析每个提议的解决方案。核心挑战是确保在 $t_c$ 进行授权决策时所使用的系统状态，在操作于 $t_u$ 完成之前始终保持有效。对该状态的任何更改（例如在 $t_r$ 的撤销）都必须被检测到，并导致操作失败。\n\n**逐项分析**\n\n**A) 在单次内核进入中执行授权和资源操作，同时对相关策略状态持有一致性原语：内核读取一个覆盖 $\\text{ACL}_o$ 和 $G$ 中相关组的版本 $v$，进行授权，执行操作，然后在提交前重新检查版本是否仍为 $v$；策略更新（ACL编辑或组成员关系变更）将版本号原子地加1。如果版本已更改，则中止操作并在内核内作为单个操作重试。**\n\n此选项描述了一种乐观并发控制（OCC）机制。整个临界区，从检查到使用，都在一个表现为原子的块内执行。其原子性不是通过加锁实现的，而是通过版本控制和验证。\n1. 在操作开始时（$t_c$ 之前），内核读取策略状态的当前版本 $v$。\n2. 基于此版本执行授权检查。\n3. 试探性地对资源执行操作。\n4. 在时间 $t_r$，发生策略更新，这会原子地将版本从 $v$ 增加到 $v+1$。\n5. 在提交操作结果之前（在时间 $t_u$），内核通过比较其最初读取的版本 $v$ 和当前版本 $v+1$ 来重新验证。\n6. 由于 $v \\neq v+1$，验证失败，操作被中止。\n\n这个序列正确地防止了操作基于过时的授权成功，从而满足了立即撤销的要求。在单次内核进入中使用原子版本计数器和检查-执行-验证模式是解决竞争条件的一种标准的、科学上现实的技术。\n\n**结论：正确**\n\n**B) 将授权和使用分为两个独立的系统调用：第一个调用在用户空间检查成员关系并返回一个布尔值，如果布尔值为真，则第二个调用执行操作。依赖调度器来避免在两次调用之间发生抢占。**\n\n这个设计存在根本性缺陷。\n1. **暴露竞争窗口：** 将检查和使用分为两个独立的系统调用，并在其间返回到用户空间，是创建TOCTTOU漏洞的典型结构。第一个调用返回和第二个调用执行之间的时间*就是*竞争窗口。\n2. **不可靠的缓解措施：** “依赖调度器”不是一种安全机制。调度器的行为是复杂的，从用户程序的角度来看是不确定的，并且其设计目的不是为了强制执行安全策略。在一个多处理器系统上，策略变更可能在另一个CPU核心上发生，而无需抢占主体的进程。因此，即使禁用抢占也不是一个充分的缓解措施。\n3. **违反完全中介原则：** 该设计违反了完全中介的安全原则，该原则要求对每个客体的每次访问都必须检查授权。第二个系统调用（“使用”）将在没有及时授权检查的情况下进行，而是基于从用户空间传递的一个过时的结果。\n\n这个选项描述的是问题本身，而不是解决方案。\n\n**结论：不正确**\n\n**C) 在用户空间缓存肯定的授权结果，并设置一个生存时间 $\\tau$：如果操作在缓存的检查结果产生后的时间 $\\tau$ 内开始，则跳过重新授权；否则，重新授权。**\n\n这个选项未能满足“立即撤销”的要求。\n1. **基于时间的撤销 vs. 基于事件的撤销：** 生存时间（TTL）机制提供的是最终一致性，而非立即撤销。假设在 $t_c$ 执行检查并缓存结果。在 $t_r$ 发生撤销。如果在一个时间 $t_{op}$ 尝试操作，且 $t_c   t_r  t_{op}  t_c + \\tau$，那么缓存的肯定结果将被视为有效。操作将被允许继续进行，这直接违反了在 $t_r$ 的撤销必须立即生效的要求。从 $t_r$ 到 $t_c + \\tau$ 的时间段构成了一个漏洞窗口。\n2. **用户空间缓存：** 将像授权缓存这样对安全至关重要的信息放在用户空间是不安全的。一个恶意的或有问题的用户进程可以操纵这个缓存以获取未授权的访问。\n\n虽然缓存是一种有效的性能优化手段，但它代表了一种权衡，即牺牲了撤销的即时性。因此，对于有严格立即撤销目标的系统来说，这不是一个解决方案。\n\n**结论：不正确**\n\n**D) 维护每个客体的ACL生成计数器 $g_o$，以及可选的每个主体的组成员关系生成计数器 $g_s$。当内核为主体 $s$ 授权对客体 $o$ 的操作时，它将观察到的 $(g_o, g_s)$ 绑定到生成的操作句柄或进行中操作描述符上。每次使用时都验证当前的生成计数器值是否与绑定的值相等；任何对 $o$ 的ACL编辑或对 $s$ 的组成员关系变更都会将相应的生成计数器原子地加1，从而使过时的句柄失效，并在使用前强制重新授权。**\n\n这个选项描述了一种稳健且灵活的版本控制机制。\n1. **状态版本化：** 使用原子递增的生成计数器（$g_o$ 和 $g_s$）对相关的策略状态（ACL和组成员关系）进行版本化。\n2. **在检查时绑定：** 在初始授权检查时（例如，在 $t_c$ 的 `open()` 调用期间），内核记录计数器的当前值 $(g_o, g_s)$ 并将其与返回的句柄（例如，文件描述符）关联。\n3. **通过更新使其失效：** 在时间 $t_r$，当主体 $s$ 的组成员关系被撤销时，计数器 $g_s$ 被原子地增加。\n4. **在使用时验证：** 对于后续使用该句柄的每个操作（例如，在 $t_u$ 的 `read()` 调用），内核首先将存储在句柄中的计数器值与当前的全局计数器值进行比较。在我们的场景中，它会发现存储的 $g_s$ 与当前的全局 $g_s$ 不匹配。这种不匹配表明授权基础可能已发生变化。内核随后会拒绝该操作，并可以要求进程重新授权。\n\n该机制在使用于 $t_u$ 执行之前，正确地检测到在 $t_r$ 发生的策略变化，从而强制执行立即撤销。它有效地关闭了TOCTTOU窗口。这是安全操作系统中一种科学上现实且常见的设计模式，因为它允许将检查（如 `open`）与使用（如 `read`、`write`）分离，同时保持安全性。\n\n**结论：正确**\n\n总而言之，选项A和D都描述了消除指定的TOCTTOU竞争条件并强制执行立即撤销的有效的、科学上合理的方法。", "answer": "$$\\boxed{AD}$$", "id": "3674083"}, {"introduction": "最后的这个实践将从访问控制列表（ACLs）转向基于能力（capability-based）的安全性，探讨保护原则如何与核心操作系统优化机制相互作用。具体来说，它研究了能力与进程创建期间使用的写时复制（Copy-on-Write, COW）机制之间的相互影响。这个场景 [@problem_id:3674060] 迫使我们更深入地思考最小权限原则，要求您设计一个能够正确削弱权限的系统，以在一个复杂且状态不断变化的操作中防止非预期的权限提升。", "problem": "一个操作系统对内存帧使用基于能力（capability-based）的保护。每个受保护的对象是一个由对象标识符标识的物理帧，每个域（进程）持有一组能力。一个能力是形式为 $\\langle o, R, \\tau \\rangle$ 的不可伪造的令牌，其中 $o$ 是一个对象标识符，$R \\subseteq \\{r, w, x, g\\}$ 是权限集合，允许读（$r$）、写（$w$）、执行（$x$）和授予（$g$）权限，$\\tau \\in \\{\\text{normal}, \\text{cow}\\}$ 是一个标签，指示该映射是标准映射还是写时复制（copy-on-write）映射。操作系统通过一个访问矩阵 $A$ 来实施保护，其概念性条目 $A[d, o]$ 是域 $d$ 对对象 $o$ 拥有的权限集，并通过每个域的能力列表来实现这一点。该系统通过写时复制来复制地址空间以实现进程创建：最初，父进程和子进程共享帧，当任何一方首次写入时，写入者会收到一个私有副本。\n\n保护目标是维护完整性（共享帧不被意外修改）和最小权限（任何域都不会获得其本不应有的写权限）。考虑一个进程 $P$ fork 出一个子进程 $C$ 的情况，其中父进程最初对帧 $o$ 拥有一个能力 $\\langle o, \\{r, w\\}, \\text{normal} \\rangle$。fork 之后，两个进程都以写时复制的方式映射 $o$。内核本身对所有帧都拥有完全的权限。写时复制机制必须确保，如果 $C$ 对共享帧只有读权限，那么 $C$ 不会意外获得对 $o$ 的写权限，也不会导致任何派生页面继承超出预期的 $w$ 权限。\n\n就访问矩阵模型和能力语义而言，哪种设计最正确地强制执行了由写时复制创建的派生页面不会继承意外的 $w$ 权限，同时仍然允许正确且高效的写时复制行为？\n\nA. 在 fork 时削弱能力，将 $P$ 和 $C$ 中的任何 $\\langle o, R, \\text{normal} \\rangle$ 映射替换为一个派生的能力 $\\langle o, R \\cap \\{r, x\\}, \\text{cow} \\rangle$，该能力缺少 $w$ 和 $g$ 权限。当域 $d \\in \\{P, C\\}$ 对 $o$ 发生写故障时，内核分配一个新帧 $o'$，将 $o$ 的内容复制到 $o'$，通过向 $d$ 提供一个新能力 $\\langle o', \\{r, w\\}, \\text{normal} \\rangle$ 来更新 $A[d, o']$ 以包含 $\\{r, w\\}$，并保持所有其他域对 $o$ 的能力不变，仍为 $\\langle o, R \\cap \\{r, x\\}, \\text{cow} \\rangle$。\n\nB. fork后保留原始能力。当域 $d$ 对 $o$ 发生写故障时，内核临时增强 $d$ 的能力为 $\\langle o, \\{r, w\\}, \\text{normal} \\rangle$，以便 $d$ 可以在用户空间将数据从 $o$ 复制到一个新帧 $o'$，然后撤销对 $o$ 的临时 $w$ 权限，并最终给予 $d$ 一个能力 $\\langle o', \\{r, w\\}, \\text{normal} \\rangle$。\n\nC. 确保 $P$ 和 $C$ 在 fork 后都保留 $\\langle o, \\{r, w\\}, \\text{normal} \\rangle$，但将页表标记为只读以引发写时复制故障。当域 $d$ 对 $o$ 发生写故障时，内核利用 $d$ 对 $o$ 拥有 $w$ 权限这一事实来授权该操作，然后复制到一个新帧 $o'$，并向 $d$ 返回 $\\langle o', \\{r, w\\}, \\text{normal} \\rangle$。\n\nD. 将能力替换为在 $o$ 上的访问控制列表，其中列出 $P$ 和 $C$ 仅有 $r$ 权限。当域 $d$ 发生写故障时，在访问控制列表中临时为 $d$ 在 $o$ 上添加 $w$ 权限，允许 $d$ 将数据复制到一个新帧 $o'$，然后移除 $d$ 在 $o$ 上的 $w$ 权限，并授予 $d$ 在 $o'$ 上的完全权限。\n\n选择最佳选项。通过引用访问矩阵、能力削弱和写时复制语义的定义，并分析每个备选方案如何影响 $A[d, o]$ 以及派生对象 $o'$ 的权限传播（关于机密性和完整性目标），来证明你的选择。", "solution": "我们从定义和保护目标开始。在访问矩阵 $A$ 中，每个域 $d$ 对每个对象 $o$ 都拥有一组权限 $A[d, o]$。基于能力的保护通过给予每个域 $d$ 不可伪造的能力 $\\langle o, R, \\tau \\rangle$ 来实现 $A$，使得 $R = A[d, o]$，并且内核强制规定，对对象 $o$ 需要 $r$ 或 $w$ 权限的请求，只有在 $r \\in R$ 或 $w \\in R$ 时才被授权。这里的保护目标是完整性（防止对共享帧 $o$ 的未经授权的修改）和最小权限（确保没有域会获得除非明确意图之外的 $w$ 权限）。写时复制旨在允许两个域共享数据的不可变视图，直到其中一个域意图修改它为止，此时会创建一个新对象 $o'$，并且只给予写入者对 $o'$ 的写权限。\n\n能力系统支持权限削弱：可以给予一个域一个具有权限子集（例如，移除 $w$）和附加元数据（例如，写时复制标签）的能力，而这些附加元数据本身不授予额外权力。一个关键原则是，能力是不可伪造的，并且一个域在没有拥有适当的授予权限（$g$）或没有一个受信任的内核以独立于该域的权力行事的情况下，不能增加其对对象 $o$ 的权限。对于写时复制，内核必须执行复制操作，因为复制一个帧需要从 $o$ 读取并写入 $o'$，或者临时获得对 $o$ 的 $w$ 权限来准备复制，如果控制不当，这有违反完整性的风险。\n\n我们根据每个选项对 $A[d, o]$ 和权限传播的影响来分析它们。\n\n选项 A：此设计在 fork 时明确削弱了权限。对于每个域 $d \\in \\{P, C\\}$，对 $o$ 的映射变为 $\\langle o, R_d \\cap \\{r, x\\}, \\text{cow} \\rangle$，其中 $R_d$ 是原始权限集（对于 $P$，$R_P = \\{r, w\\}$；根据构造，对于 $C$，$R_C = \\{r\\}$）。移除 $w$ 权限确保了 $A[P, o] \\subseteq \\{r, x\\}$ 和 $A[C, o] \\subseteq \\{r, x\\}$，因此两个域都不能写入共享帧 $o$，从而保护了完整性。缺少 $g$ 权限确保了没有域可以铸造一个对 $o$ 具有 $w$ 权限的能力或委托此类权限。写时复制标签 $\\tau = \\text{cow}$ 是一个被削弱的引用：它授权内核执行写时复制故障处理程序，但其本身并不授予对 $o$ 的 $w$ 权限。当域 $d$ 发生写故障时，拥有分配帧权限的内核会创建一个新对象 $o'$，并通过只向 $d$ 分发 $\\langle o', \\{r, w\\}, \\text{normal} \\rangle$ 来设置 $A[d, o'] = \\{r, w\\}$。所有其他域只保留对原始 $o$ 的读权限，并且不会获得对 $o'$ 的任何权限。因此，派生页面 $o'$ 不会自动从 $o$ 继承权限；它是一个新对象，其权限仅在需要时被授予。机密性得以保持，因为没有添加额外的读取者；完整性也得以保持，因为没有意外的 $w$ 权限传播到 $o$ 或其他域。这与能力削弱以及访问矩阵更新是由内核控制的操作相一致。因此，选项 A 正确地强制执行了目标。\n\n选项 B：此选项建议临时增强 $A[d, o]$ 以包含 $w$ 权限，以便 $d$ 可以在用户空间执行复制，然后撤销 $w$。这存在多个问题。首先，临时设置 $A[d, o] \\supseteq \\{w\\}$ 在该时间窗口内违反了最小权限原则，造成了“检查时到使用时”（time-of-check-to-time-of-use）的风险：$d$ 可以在权限被撤销前写入 $o$，或者如果它持有 $g$ 权限，则可以将 $w$ 权限委托给其他进程。即使内核先剥离 $g$ 权限，原地更改能力也违反了能力从域的角度看是不可伪造和不可变的属性；追溯性撤销是复杂且容易出错的。其次，将复制操作委托给用户空间需要授予原本不持有的权限，任何撤销中的错误都会导致永久性的权限提升。因此，这种机制存在对 $o$ 产生意外 $w$ 权限的风险，并且不能可靠地确保没有派生页面 $o'$ 继承意外的权限，因为临时权限提升违反了最小权限原则。因此，选项 B 是不正确的。\n\n选项 C：在这里，两个域都保留了 $\\langle o, \\{r, w\\}, \\text{normal} \\rangle$，但页表被标记为只读以使写入操作产生故障。从概念上讲，在访问矩阵中，$A[P, o]$ 和 $A[C, o]$ 都包含 $w$ 权限。尽管页表在内核介入之前阻止写入，但 $A$ 中拥有 $w$ 权限本身就是对修改 $o$ 的一种授权。这违反了用于安全推理的访问矩阵语义：该权限存在，并可能因配置错误或程序错误而被激活。它也违反了最小权限原则，因为 $C$ 被授予了它不需要也绝不能行使的对 $o$ 的 $w$ 权限。此外，如果存在 $g$ 权限，保留 $w$ 权限会使得意外的权限委托成为可能。此设计将页表级别的强制执行与访问矩阵级别的授权混为一谈，因此不能确保派生页面避免继承意外的 $w$ 权限。选项 C 是不正确的。\n\n选项 D：切换到在 $o$ 上使用访问控制列表并临时授予 $w$ 权限，同样引入了一个 $A[d, o]$ 包含 $w$ 权限的时间窗口。尽管该机制使用访问控制列表而不是能力，但根本问题依然存在：临时将 $A[d, o]$ 提升至包含对原始共享对象 $o$ 的 $w$ 权限，这违反了最小权限原则，并在该窗口期间危及完整性。此外，设计描述没有指定仅由内核进行复制；如果复制由 $d$ 完成，则会产生与选项 B 中相同的委托和滥用风险。即使内核执行复制，对 $A[d, o]$ 的临时修改也是不必要且不安全的；内核可以使用自己的权限读取 $o$，而无需授予 $d$ 对 $o$ 的 $w$ 权限。因此，选项 D 不满足防止在 $o$ 或派生页面上出现意外 $w$ 权限的要求。选项 D 是不正确的。\n\n通过诉诸访问矩阵语义和能力削弱，只有选项 A 在新对象 $o'$ 创建之前，为所有非内核域保持了 $A[d, o] \\subseteq \\{r, x\\}$。当新对象创建时，只有发生故障的域的 $A[d, o']$ 包含 $\\{r, w\\}$。没有意外的 $w$ 权限传播到 $o$ 或其他域，派生对象只接收预期的权限。因此，选项 A 是正确的设计。", "answer": "$$\\boxed{A}$$", "id": "3674060"}]}