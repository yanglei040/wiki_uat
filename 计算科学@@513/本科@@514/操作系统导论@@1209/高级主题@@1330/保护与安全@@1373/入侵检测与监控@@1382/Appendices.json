{"hands_on_practices": [{"introduction": "异常检测是现代入侵检测系统的基石。在我们能够发现入侵者之前，我们必须首先了解“正常”是什么样子的。这个练习 [@problem_id:3650732] 将指导你掌握一项基本技术：为系统资源使用建立统计基线，并利用它来检测可能预示着恶意活动的显著偏差。你将学习如何调整检测策略以控制误报率，这是任何现实世界监控系统中都至关重要的权衡。", "problem": "一个操作系统团队使用 Linux 控制组 (cgroups) 来监控某个面向网络的单一服务的资源使用情况。系统以 $\\Delta = 5\\,\\text{s}$ 的固定采样间隔，为该服务记录两个样本指标：中央处理器 (CPU) 利用率分数和以 $\\text{MB}/\\text{s}$ 为单位的输入/输出 (I/O) 吞吐量。系统维护一个长度为 $W$ 的近期样本滑动窗口（其中 $W$ 足够大以保证稳定估计），用于计算每个指标的经验均值 $\\hat{\\mu}$ 和经验标准差 $\\hat{\\sigma}$。在每个采样时间 $t$，系统会计算 CPU 和 I/O 的标准化分数（即所谓的 $z$-分数），公式为 $z_{\\text{cpu},t} = (x_{\\text{cpu},t} - \\hat{\\mu}_{\\text{cpu}})/\\hat{\\sigma}_{\\text{cpu}}$ 和 $z_{\\text{io},t} = (x_{\\text{io},t} - \\hat{\\mu}_{\\text{io}})/\\hat{\\sigma}_{\\text{io}}$。如果任一指标表现出持续超过 $3$ 个标准差的偏差，异常策略就会发出警报，这意味着在至少 $K$ 个连续样本中，每个样本都满足 $|z_{\\text{cpu},t}| > 3$ 或 $|z_{\\text{io},t}| > 3$。\n\n假设在良性（非攻击）操作下存在以下条件：\n- 由于窗口大小 $W$ 足够大，每个指标的标准化分数在时间上是独立同分布的，并且可以很好地用标准正态分布 $\\mathcal{N}(0,1)$ 来建模。\n- 在给定的采样时间，CPU 和 I/O 的标准化分数是相互独立的。\n- 对于罕见事件，可以忽略连续运行之间的重叠效应，因此在任何给定样本处开始的连续 $K$ 次阈值超出的运行概率，可以很好地用单一样本超出概率的 $K$ 次方来近似。\n\n仅使用这些假设，设计持续偏差长度 $K$，使得在 $30$ 天的良性监控期内，预期误报次数最多为 $0.5$。将你的最终答案表示为达到此目标的最小整数 $K$。你的答案必须是单个整数（无单位）。", "solution": "用户希望我为一个异常检测系统确定持续偏差长度（表示为 $K$）的最小整数值。设计约束是在 $30$ 天的监控期内，预期的误报次数不得超过 $0.5$。\n\n### 步骤 1：问题验证\n我将首先验证问题陈述。\n\n**从问题陈述中提取的已知条件：**\n-   采样间隔：$\\Delta = 5\\,\\text{s}$。\n-   指标：CPU 利用率和 I/O 吞吐量。\n-   在每个采样时间 $t$ 计算标准化分数 (z-分数)：$z_{\\text{cpu},t}$ 和 $z_{\\text{io},t}$。\n-   警报条件：持续偏差至少 $K$ 个连续样本，其中序列中的每个样本都满足 $|z_{\\text{cpu},t}| > 3$ 或 $|z_{\\text{io},t}| > 3$。\n-   良性（非攻击）操作的假设：\n    1.  每个指标的标准化分数 $z_{\\text{cpu},t}$ 和 $z_{\\text{io},t}$ 在时间上是独立同分布 (i.i.d.) 的。\n    2.  两者都可以很好地用标准正态分布 $\\mathcal{N}(0,1)$ 建模。\n    3.  在任何给定时间 $t$，$z_{\\text{cpu},t}$ 和 $z_{\\text{io},t}$ 是相互独立的。\n    4.  从一个样本开始的连续 $K$ 次超出的运行概率，可以用单一样本超出概率的 $K$ 次方来近似。\n-   目标约束：在 $30$ 天的良性监控期内，预期的误报次数最多为 $0.5$。\n-   目标：找到满足此约束的最小整数 $K$。\n\n**根据标准进行验证：**\n1.  **科学或事实不健全性**：该问题基于标准的统计建模（正态分布、z-分数、独立事件概率），并应用于一个现实的计算机科学问题（用于异常检测的资源监控）。诸如数据服从正态分布和事件独立同分布等假设，是此类模型中常见且明确说明的简化假设。没有违反科学原理。\n2.  **不可形式化或不相关**：该问题在数学上定义明确，并且与操作系统主题相关，特别是在性能监控和入侵检测的背景下，这些是该领域的高级主题。\n3.  **设置不完整或矛盾**：该问题提供了得出唯一解所需的所有数据和约束。假设在内部是一致的。\n4.  **不切实际或不可行**：该场景是一个真实世界系统的简化但合理的模型。所有数值都在现实范围内。\n5.  **不适定或结构不良**：该问题是适定的。存在一个唯一的、稳定的、有意义的整数解 $K$。\n6.  **伪深刻、琐碎或同义反复**：该问题需要涉及概率论和对数的多步定量分析。它并非微不足道。\n7.  **超出科学可验证性**：该问题是一个基于给定模型的数学练习，可以根据数学和概率的规则来解决和验证。\n\n**结论：** 该问题是 **有效的**。我将继续进行求解。\n\n### 步骤 2：求解推导\n目标是找到最小的整数 $K$，以确保在 $30$ 天的周期内，预期的误报次数不超过 $0.5$。\n\n首先，我们计算监控期内的总样本数 $N$。\n监控期为 $T = 30$ 天。采样间隔为 $\\Delta = 5 \\text{ s}$。\n我们将周期 $T$ 转换为秒：\n$$ T = 30 \\text{ days} \\times 24 \\frac{\\text{hours}}{\\text{day}} \\times 60 \\frac{\\text{minutes}}{\\text{hour}} \\times 60 \\frac{\\text{seconds}}{\\text{minute}} = 2,592,000 \\text{ s} $$\n总样本数为：\n$$ N = \\frac{T}{\\Delta} = \\frac{2,592,000 \\text{ s}}{5 \\text{ s}} = 518,400 $$\n\n接下来，我们确定单一样本被标记为异常的概率。设此概率为 $p$。如果在单一样本时间 $t$ 满足 $|z_{\\text{cpu},t}| > 3$ 或 $|z_{\\text{io},t}| > 3$，则会触发警报。\n设 $A_{\\text{cpu}}$ 为事件 $|z_{\\text{cpu},t}| > 3$，$A_{\\text{io}}$ 为事件 $|z_{\\text{io},t}| > 3$。单一样本异常事件为 $A = A_{\\text{cpu}} \\cup A_{\\text{io}}$。\n概率 $p$ 由容斥原理给出：\n$$ p = P(A_{\\text{cpu}} \\cup A_{\\text{io}}) = P(A_{\\text{cpu}}) + P(A_{\\text{io}}) - P(A_{\\text{cpu}} \\cap A_{\\text{io}}) $$\n根据问题的假设，$z_{\\text{cpu},t}$ 和 $z_{\\text{io},t}$ 是独立的。因此，事件 $A_{\\text{cpu}}$ 和 $A_{\\text{io}}$ 是独立的，这意味着 $P(A_{\\text{cpu}} \\cap A_{\\text{io}}) = P(A_{\\text{cpu}}) P(A_{\\text{io}})$。\n\n设 $p_{\\text{metric}}$ 为单个指标的标准化分数超过阈值 $3$ 的概率。由于两个分数都由标准正态分布 $Z \\sim \\mathcal{N}(0,1)$ 建模，我们有：\n$$ p_{\\text{metric}} = P(|Z| > 3) $$\n这个概率可以从标准正态分布的累积分布函数 (CDF) $\\Phi(z)$ 计算得出。\n$$ p_{\\text{metric}} = P(Z > 3) + P(Z  -3) $$\n根据正态分布的对称性，$P(Z  -3) = P(Z > 3) = 1 - \\Phi(3)$。\n$$ p_{\\text{metric}} = 2(1 - \\Phi(3)) $$\n使用著名的正态分布“68-95-99.7 法则”，一个值落在均值 $3$ 个标准差范围内的概率约为 $0.9973$。因此，落在此范围之外的概率是：\n$$ p_{\\text{metric}} \\approx 1 - 0.9973 = 0.0027 $$\n使用这个值，我们得到 $P(A_{\\text{cpu}}) = P(A_{\\text{io}}) = p_{\\text{metric}} \\approx 0.0027$。\n现在我们可以计算 $p$：\n$$ p = 2p_{\\text{metric}} - p_{\\text{metric}}^2 \\approx 2(0.0027) - (0.0027)^2 = 0.0054 - 0.00000729 = 0.00539271 $$\n\n如果一个样本连续 $K$ 次异常，则会发出警报。根据问题假设，在任何给定样本处开始的长度为 $K$ 的警报序列的概率是 $p^K$。\n整个时期内的预期误报次数 $E[\\text{alerts}]$ 是样本数 $N$ 乘以在任何样本处开始警报序列的概率。我们忽略了末端效应（即，我们假设对于长度为 $K$ 的序列有 $N$ 个潜在的开始时间），这对于大的 $N$ 是一个合理的近似。\n$$ E[\\text{alerts}] = N \\times p^K $$\n问题要求这个期望值最多为 $0.5$：\n$$ N p^K \\le 0.5 $$\n我们需要求解满足此不等式的最小整数 $K$。\n$$ 518,400 \\times (0.00539271)^K \\le 0.5 $$\n让我们分离出含有 $K$ 的项：\n$$ (0.00539271)^K \\le \\frac{0.5}{518,400} = \\frac{1}{1,036,800} $$\n为了求解 $K$，我们对两边取自然对数。\n$$ \\ln\\left((0.00539271)^K\\right) \\le \\ln\\left(\\frac{1}{1,036,800}\\right) $$\n$$ K \\ln(0.00539271) \\le -\\ln(1,036,800) $$\n由于 $0.00539271  1$，其自然对数为负。当我们除以这个负数时，必须反转不等号。\n$$ K \\ge \\frac{-\\ln(1,036,800)}{\\ln(0.00539271)} $$\n现在，我们计算对数值：\n$$ \\ln(1,036,800) \\approx 13.8516 $$\n$$ \\ln(0.00539271) \\approx -5.2233 $$\n将这些值代回关于 $K$ 的不等式中：\n$$ K \\ge \\frac{-13.8516}{-5.2233} \\approx 2.6517 $$\n由于 $K$ 必须是整数，满足此条件的最小整数值 $K$ 为 $3$。\n\n为了验证，我们检查一下 $K=2$ 和 $K=3$ 时的预期警报次数。\n对于 $K=2$：\n$$ E[\\text{alerts}] = 518,400 \\times (0.00539271)^2 \\approx 518,400 \\times (2.9081 \\times 10^{-5}) \\approx 15.07 $$\n该值大于 $0.5$。\n对于 $K=3$：\n$$ E[\\text{alerts}] = 518,400 \\times (0.00539271)^3 \\approx 518,400 \\times (1.5684 \\times 10^{-7}) \\approx 0.0813 $$\n该值小于 $0.5$。\n因此，满足所需设计约束的最小整数 $K$ 是 $3$。", "answer": "$$\\boxed{3}$$", "id": "3650732"}, {"introduction": "虽然统计异常可以揭示简单的攻击，但老练的攻击者通常将其行为隐藏在看似合法的系统操作中。为了识破他们，我们必须超越简单的指标，并融入丰富的上下文信息。这个练习 [@problem_id:3650735] 挑战你像安全架构师一样思考，评估不同的检测策略，以发现从受损服务中启动命令解释器的攻击者。你将亲身体会到为什么上下文——例如进程亲缘关系、相对于系统启动的时间以及服务配置——对于创建既能灵敏捕捉威胁又能有效抵抗误报的规则至关重要。", "problem": "一个操作系统监控代理检测系统调用 (syscall) $execve$ 并发出结构化事件。每个事件被建模为一个元组 $E = \\langle \\text{pid}, \\text{ppid}, \\text{name}, \\text{argv}, \\text{env}, \\text{tty}, \\text{cgroup}, \\text{path}, \\text{unit}, t \\rangle$，其中 $t$ 是事件时间，$\\text{name}$ 是所执行程序的基名，$\\text{tty}$ 表示控制终端（如果没有则为 $\\emptyset$），$\\text{cgroup}$ 是控制组路径，而 $\\text{unit}$ 是已知的关联服务单元名称。您的目标是建立一个运行时策略，当一个非交互式服务通过 $execve$ 意外执行解释器（例如，启动 $bash$ 或 $python$）时发出警报，同时最大限度地减少来自合法初始化脚本的误报。\n\n从以下源于操作系统和检测理论的核心定义与事实出发：\n\n- 当且仅当 $\\text{tty} = \\emptyset$ 时，一个没有控制终端的进程是非交互式的。\n- 在使用系统和服务管理器单元的系统中，长期运行的服务通常位于匹配诸如 $\\text{cgroup} \\in \\mathcal{C}$ 模式的控制组下，其中 $\\mathcal{C}$ 包括像 $\\text{system.slice}$ 这样的条目和单元范围的子路径；一次性初始化任务（init 脚本）与类型为 oneshot 的单元或标记为 pre/post 的阶段相关联（例如，$\\text{ExecStartPre}$、$\\text{ExecStartPost}$）。\n- 系统调用 $execve$ 会替换当前进程映像；当解释器以服务的权限运行时，调用解释器会增加攻击面，尤其是在系统启动后。\n- 解释器构成一个集合 $\\mathcal{I}$，例如 $\\mathcal{I} = \\{\\text{bash}, \\text{sh}, \\text{zsh}, \\text{python}, \\text{perl}, \\text{ruby}, \\text{node}\\}$。\n- 当针对预期的合法行为发出警报时，就会发生误报。初始化脚本在早期启动和单元的 pre/post 阶段被合法地允许运行解释器。\n- 设 $T_{\\text{boot}}$ 为上次系统启动时间。定义一个早期启动窗口 $\\Delta$ 秒，选择 $\\Delta$ 以覆盖典型的初始化活动。对于本问题，假设 $\\Delta = 300$。\n\n已知所关注的对抗性活动涉及一个长期运行的服务（例如，数据库或 Web 服务器进程），在系统启动很久之后，由于被利用而通过 $execve$ 执行一个解释器，而合法的 init 脚本通常在 $t \\in [T_{\\text{boot}}, T_{\\text{boot}} + \\Delta]$ 时间段内和/或作为 oneshot 或 pre/post 阶段运行。您必须选择一个单一的策略谓词 $D(E)$，当且仅当 $D(E)$ 的值为真时，它才会对事件 $E$ 发出警报。\n\n以下哪个策略在检测非交互式服务意外通过 $execve$ 执行解释器的同时，能最有效地将来自合法 init 脚本的误报降至最低？请选择最佳选项。\n\nA. 如果 $\\text{tty} = \\emptyset$、$\\text{cgroup} \\in \\mathcal{C}$ 且 $\\text{name} \\in \\mathcal{I}$，则发出警报。\n\nB. 如果 $\\text{tty} = \\emptyset$、$\\text{cgroup} \\in \\mathcal{C}$ 且 $\\text{name} \\in \\mathcal{I}$，则发出警报，但在 $t - T_{\\text{boot}} \\le \\Delta$ 时，或当 $\\text{unit}$ 的类型为 oneshot 或阶段为 pre/post 时抑制警报；此外，当 $\\text{ppid}$ 映射到白名单 $\\mathcal{W}$ 中的已知 init 包装器（例如，$\\text{/etc/init.d}$ 和 $\\text{/lib/systemd}$ 下的路径）时也抑制警报。\n\nC. 仅当 $\\text{tty} = \\emptyset$、$\\text{name} \\in \\mathcal{I}$，并且根据监控代理的观察，进程在 $execve$ 后的 2 秒内打开一个传输控制协议 (TCP) 套接字时，才发出警报。\n\nD. 如果在 60 分钟的窗口内，从任何非交互式进程观察到的、满足 $\\text{name} \\in \\mathcal{I}$ 的 $execve$ 事件计数超过 10，则发出警报，无论服务单元、启动时间或阶段如何。\n\n通过选择唯一的最佳选项来回答问题。请使用给定的定义和事实来论证您的推理，仔细考虑如何在不漏掉所述对抗性行为的情况下减少来自 init 脚本的误报。除了提供的事件字段和陈述的事实之外，不要假设任何未说明的功能或数据。", "solution": "用户希望我选择用于检测入侵的最佳策略。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n-   事件是一个元组 $E = \\langle \\text{pid}, \\text{ppid}, \\text{name}, \\text{argv}, \\text{env}, \\text{tty}, \\text{cgroup}, \\text{path}, \\text{unit}, t \\rangle$。\n-   $t$ 是事件时间。\n-   $\\text{name}$ 是所执行程序的基名。\n-   $\\text{tty}$ 是控制终端，如果没有则为 $\\emptyset$。\n-   $\\text{cgroup}$ 是控制组路径。\n-   $\\text{unit}$ 是关联的服务单元名称。\n-   当且仅当 $\\text{tty} = \\emptyset$ 时，一个进程是非交互式的。\n-   长期运行的服务位于控制组 $\\text{cgroup} \\in \\mathcal{C}$ 下，其中 $\\mathcal{C}$ 包括像 $\\text{system.slice}$ 这样的路径。\n-   初始化脚本与类型为 $\\text{oneshot}$ 的单元或像 $\\text{ExecStartPre}$/$\\text{ExecStartPost}$ 这样的阶段相关联。\n-   关注的系统调用是 $execve$。\n-   解释器的集合是 $\\mathcal{I} = \\{\\text{bash}, \\text{sh}, \\text{zsh}, \\text{python}, \\text{perl}, \\text{ruby}, \\text{node}\\}$。\n-   误报是针对合法行为（特别是来自初始化脚本的行为）发出的警报。\n-   $T_{\\text{boot}}$ 是上次系统启动时间。\n-   $\\Delta$ 是早期启动窗口，给定为 $300$ 秒。\n-   对抗性目标：检测一个长期运行的服务在启动很久之后通过 $execve$ 执行解释器。\n-   要忽略的合法行为：在 $t \\in [T_{\\text{boot}}, T_{\\text{boot}} + \\Delta]$ 期间和/或作为 $\\text{oneshot}$ 或 pre/post 阶段的一部分运行解释器的 Init 脚本。\n-   任务：选择最佳的策略谓词 $D(E)$ 来发出警报。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n-   **科学依据：** 该问题牢固地植根于操作系统（特别是进程管理、系统调用以及像 Linux/systemd 中的 cgroups 等资源管理功能）和计算机安全（入侵检测、威胁建模和端点监控）的原理。所有概念（$execve$、TTY、cgroups、systemd 单元）都是标准且事实正确的。\n-   **问题定义良好：** 这是一个定义良好的问题。它提供了一个明确的目标（检测特定的攻击模式）、一个明确的约束（最小化特定类型的误报）、一个定义好的数据模型（事件元组 $E$），以及一组候选解决方案（策略 A-D）以根据目标和约束进行评估。它要求选择“最佳”选项，这可以通过分析每个策略所做的权衡来确定。\n-   **客观性：** 问题陈述使用了精确的技术语言。为关键术语（例如，“非交互式”）提供了定义。场景的描述没有主观或偏颇的措辞。\n\n**第 3 步：结论与行动**\n\n问题陈述是有效的。它在科学上是合理的，定义良好且客观。不存在会妨碍严谨分析的矛盾、歧义或缺失信息。我将继续推导解决方案。\n\n### 解决方案推导\n\n核心任务是制定一个检测规则 $D(E)$，该规则在两个相互竞争的目标之间取得平衡：最大化检测特定威胁的真阳性率，以及最小化来自已知的、合法系统活动的假阳性率。\n\n威胁被定义为一个非交互式的、长期运行的服务执行一个解释器。这转化为对一个事件 $E$ 的以下条件：\n1.  $\\text{tty} = \\emptyset$ (非交互式)\n2.  $\\text{cgroup} \\in \\mathcal{C}$ (长期运行的服务)\n3.  $\\text{name} \\in \\mathcal{I}$ (解释器执行)\n\n要忽略的合法活动（以最小化误报）主要来自初始化脚本，其特征如下：\n1.  在早期启动窗口内运行：$t - T_{\\text{boot}} \\le \\Delta$。\n2.  与特定的 systemd 单元类型 ($\\text{oneshot}$) 或阶段 ($\\text{pre/post}$) 相关联。\n\n现在，我将评估每个提议的策略谓词。\n\n**选项 A 的分析**\n\n策略 A：如果 $\\text{tty} = \\emptyset$、$\\text{cgroup} \\in \\mathcal{C}$ 且 $\\text{name} \\in \\mathcal{I}$，则发出警报。\n\n该策略直接实现了表征可疑活动的三个条件。它正确地识别了一个看起来像服务 ($\\text{cgroup} \\in \\mathcal{C}$) 且非交互式 ($\\text{tty} = \\emptyset$) 的进程执行了解释器 ($\\text{name} \\in \\mathcal{I}$)。然而，问题陈述明确指出，合法的初始化脚本也可能在这些条件下运行，尤其是在系统启动期间。例如，一个服务单元可能有一个 $\\text{ExecStartPre}$ 指令，该指令运行一个 shell 脚本来设置权限或配置。这个脚本将以 $\\text{tty} = \\emptyset$ 的方式执行，位于服务的 cgroup 内（因此 $\\text{cgroup} \\in \\mathcal{C}$），并且其名称（例如，$\\text{sh}$）将在 $\\mathcal{I}$ 中。该策略没有机制来区分这种合法活动和攻击，导致高误报率，尤其是在启动时。它未能满足最小化约束。\n\n结论：**不正确**。\n\n**选项 B 的分析**\n\n策略 B：如果 $\\text{tty} = \\emptyset$、$\\text{cgroup} \\in \\mathcal{C}$ 且 $\\text{name} \\in \\mathcal{I}$，则发出警报，但在 $t - T_{\\text{boot}} \\le \\Delta$ 时，或当 $\\text{unit}$ 的类型为 oneshot 或阶段为 pre/post 时抑制警报；此外，当 $\\text{ppid}$ 映射到白名单 $\\mathcal{W}$ 中的已知 init 包装器时也抑制警报。\n\n该策略从与策略 A 相同的强大检测核心开始。然后，它增加了一系列抑制条件（例外情况），旨在过滤掉合法行为。让我们分析这些抑制条件：\n-   `在 $t - T_{\\text{boot}} \\le \\Delta$ 时抑制`：这直接解决了在早期启动窗口期间的合法执行，使用了给定的参数 $T_{\\text{boot}}$ 和 $\\Delta = 300$。\n-   `当 unit 的类型为 oneshot 或阶段为 pre/post 时抑制`：这使用事件元组中的 $\\text{unit}$ 字段来识别合法的、短暂的任务或服务设置/拆卸脚本，这些脚本可能在任何时候（而不仅仅是启动时）运行解释器。这是区分攻击与正常操作的关键上下文信息。\n-   `当 ppid 映射到白名单 W 中的已知 init 包装器时抑制`：这增加了另一层复杂性，使用进程父级 ($\\text{ppid}$) 来识别那些是受信任系统组件（例如，systemd 本身，或 `/etc/init.d` 中的脚本）子进程的执行。\n\n这个策略是一个多层过滤器。它检测感兴趣的一般模式，然后有条不紊地排除问题陈述中确定的合法行为的特定情况。这种方法直接解决了最小化来自 init 脚本的误报的要求，同时对目标对抗活动（一个已在运行的服务在启动很久之后且在设置阶段之外意外执行解释器）保持高灵敏度。它很好地利用了事件元组 $E$ 中的可用字段。\n\n结论：**正确**。\n\n**选项 C 的分析**\n\n策略 C：仅当 $\\text{tty} = \\emptyset$、$\\text{name} \\in \\mathcal{I}$，并且进程在 $execve$ 后的 2 秒内打开一个传输控制协议 (TCP) 套接字时，才发出警报。\n\n该策略有几个缺陷。首先，通过省略 $\\text{cgroup} \\in \\mathcal{C}$ 条件，它失去了对“长期运行的服务”的关注，并且会对任何非交互式解释器执行触发警报，可能包括不属于该策略目标的合法后台作业（例如，cron 作业）。其次，也是更关键的是，它使检测依赖于后续的网络活动（打开 TCP 套接字）。获得解释器访问权限的攻击者可能会执行许多不立即涉及打开新 TCP 套接字的恶意操作，例如本地侦察、文件操纵或权限提升。该策略将无法检测到此类攻击，导致高漏报率。目标是检测未经授权的解释器执行本身，而不仅仅是特定的利用后操作。最后，该策略假设监控代理可以将一个 $execve$ 事件与未来的、不同的系统调用事件（`socket` 或 `connect`）关联起来，而问题陈述并未保证此能力，它只定义了 $execve$ 事件 $E$ 的内容。\n\n结论：**不正确**。\n\n**选项 D 的分析**\n\n策略 D：如果在 60 分钟的窗口内，从任何非交互式进程观察到的、满足 $\\text{name} \\in \\mathcal{I}$ 的 $execve$ 事件计数超过 10，则发出警报。\n\n该策略使用基于阈值的方法。其主要弱点是无法检测到单次、蓄意的入侵。所描述的威胁是一个服务派生一个解释器，这可能只发生一次。一个要求超过 10 个此类事件的策略将完全错过这个单一的、高影响的事件，导致一个关键的漏报。此外，10 次的阈值和 60 分钟的窗口是任意的，可能与攻击者行为不符。相反，一个合法但复杂的维护脚本或一系列 cron 作业可能在一小时内轻松触发超过 10 次解释器执行，导致误报。该策略丢弃了事件元组中几乎所有有价值的上下文，如 $\\text{cgroup}$、$\\text{unit}$ 和相对于启动的精确时间，使其成为一个对于这个特定检测问题来说非常粗糙且无效的工具。\n\n结论：**不正确**。\n\n**结论**\n\n策略 B 明显优于所有其他选项。它制定了一个精确的规则来检测恶意模式，然后结合了特定的、上下文感知的例外情况，这些例外情况直接对应于问题陈述中描述的合法行为来源。这种分层方法是有效检测策略的标志，成功地平衡了灵敏度（真阳性）和特异性（低误报）。", "answer": "$$\\boxed{B}$$", "id": "3650735"}, {"introduction": "每一条检测规则都涉及在捕获攻击者和产生误报之间的权衡。当我们能够用概率来为合法行为和恶意行为建模时，我们就可以找到一个数学上的最优平衡点。这个高级实践 [@problem_id:3650774] 探讨了如何应用贝叶斯决策理论，为一个常见的隐匿技术——运行一个已从文件系统中删除的可执行文件——设置完美的检测阈值。你将计算出能够最小化总错误率的贝叶斯最优阈值，这提供了一个强有力的例子，说明了如何运用形式化方法来加固入侵检测系统。", "problem": "一个基于主机的入侵检测系统 (HIDS) 部署在类 Unix 操作系统上，用于监控那些在其路径从文件系统中被解除链接后仍继续执行二进制文件的进程。在此类系统中，核心定义和事实是：解除路径名链接会移除一个目录条目，但任何持有指向该 inode (索引节点) 的打开文件描述符的进程都将保留访问权限，直到最后一个描述符被关闭；该 inode 会一直存在，直到所有对它的引用都被丢弃。监控机制检查进程文件系统下的进程标识符 (PID) 命名空间，并检测这样一种情况：一个进程正在执行一个其 inode 链接计数为 $0$ 的二进制文件（其路径通常以“(deleted)”标记结尾），而其可执行文件描述符仍然保持打开状态。检测策略是，如果一个进程持续处于这种“已删除但可执行文件仍打开”状态的时间超过一个阈值 $T$，就将其标记为可疑。\n\n在操作上，合法的软件更新（例如，使用重命名-解除链接模式的滚动二进制文件替换）会导致短暂的时期，在此期间，一个长时间运行的服务会在新版本准备就绪时短暂地执行一个“已删除”的二进制文件。根据经验，合法情况下此状态的持续时间 $X$ 可以很好地用一个率参数为 $\\lambda$ 的指数分布来建模，这反映了无记忆的重启行为和重启的独立调度：$X \\sim \\mathrm{Exp}(\\lambda)$。对抗性持久化，即入侵者为了规避基于文件的扫描器而故意执行一个“已删除”的二进制文件，往往会使这种状态持续更长时间；攻击情况下的持续时间 $Y$ 用一个更小的率参数 $\\mu$ 的指数分布来建模：$Y \\sim \\mathrm{Exp}(\\mu)$，且 $\\mu  \\lambda$。假设合法情况和攻击情况的错分成本相等，其先验概率分别为 $\\pi_{\\ell}$ 和 $\\pi_{a}$，且 $\\pi_{\\ell} + \\pi_{a} = 1$。\n\n您必须选择一个由 HIDS 使用的单一阈值 $T$，如果观测到的持续时间超过 $T$ 则判定为“攻击”，否则判定为“合法”。仅使用上述核心定义以及指数分布和 Bayes 决策的成熟性质，为以下参数值确定 Bayes 最优阈值 $T$：\n- $\\lambda = \\dfrac{1}{300}\\,\\mathrm{s}^{-1}$,\n- $\\mu = \\dfrac{1}{3600}\\,\\mathrm{s}^{-1}$,\n- $\\pi_{\\ell} = 0.99$,\n- $\\pi_{a} = 0.01$.\n\n哪个选项对 $T$ 的选择是正确的？\n\nA. $T \\approx 2320\\,\\text{秒}$\n\nB. $T \\approx 1188\\,\\text{秒}$\n\nC. $T \\approx 1800\\,\\text{秒}$\n\nD. $T \\approx 3600\\,\\text{秒}$", "solution": "### 第1步：提取已知信息\n\n-   **系统**：一个部署在类 Unix 操作系统上的基于主机的入侵检测系统 (HIDS)。\n-   **监控条件**：一个进程正在执行一个其 inode 链接计数为 $0$ 的二进制文件（路径显示为“...(deleted)”）。\n-   **检测策略**：如果一个进程在此状态下持续的时间超过阈值 $T$，则将其标记为可疑。\n-   **合法情况持续时间**：合法软件更新情况下此状态的持续时间 $X$ 服从指数分布，$X \\sim \\mathrm{Exp}(\\lambda)$。\n-   **攻击情况持续时间**：对抗性持久化情况下此状态的持续时间 $Y$ 服从指数分布，$Y \\sim \\mathrm{Exp}(\\mu)$。\n-   **参数关系**：$\\mu  \\lambda$。\n-   **错分成本**：假定两种类型的错误（假阳性和假阴性）成本相等。\n-   **先验概率**：\n    -   合法情况的先验概率：$\\pi_{\\ell}$。\n    -   攻击情况的先验概率：$\\pi_{a}$。\n    -   约束条件：$\\pi_{\\ell} + \\pi_{a} = 1$。\n-   **具体参数值**：\n    -   $\\lambda = \\dfrac{1}{300}\\,\\mathrm{s}^{-1}$\n    -   $\\mu = \\dfrac{1}{3600}\\,\\mathrm{s}^{-1}$\n    -   $\\pi_{\\ell} = 0.99$\n    -   $\\pi_{a} = 0.01$\n-   **决策规则**：\n    -   如果观测到的持续时间 $z > T$，则判定为“攻击”。\n    -   如果观测到的持续时间 $z \\le T$，则判定为“合法”。\n-   **目标**：确定 Bayes 最优阈值 $T$。\n\n### 第2步：使用提取的已知信息进行验证\n\n-   **科学依据**：该问题基于标准的 Bayes 决策理论，这是统计分析和机器学习的核心部分。使用指数分布来为事件持续时间（如故障或服务时间）建模，在可靠性工程和排队论等相关领域是一种常见且成熟的做法。所描述的操作系统概念（解除链接、文件描述符、inode、进程文件系统）准确地反映了类 Unix 系统的运作方式。\n-   **适定性**：该问题是适定的。它要求基于一个明确定义的优化准则（最小化 Bayes 风险）来求解一个单一的最优值 ($T$)。所有必要的参数（$\\lambda$、$\\mu$、$\\pi_{\\ell}$、$\\pi_{a}$）以及概率分布的函数形式都已给出。错分成本相等的条件恰当地约束了成本函数。\n-   **客观性**：该问题以精确、客观的语言陈述。它使用了数学模型，并避免了任何主观或模糊的术语。\n\n问题陈述是有效的。这是一个标准的 Bayes 二元假设检验的应用。\n\n### 第3步：推导 Bayes 最优阈值\n\n目标是找到使总错误概率（由这些错误的成本加权）最小化的阈值 $T$。这个最小值被称为 Bayes 风险。\n\n设 $H_{\\ell}$ 为观测来自合法进程的假设，而 $H_{a}$ 为观测来自攻击的假设。设 $z$ 为观测到的持续时间。在每种假设下，持续时间的概率密度函数 (PDF) 分别为：\n-   合法情况，$H_{\\ell}$：$f(z|H_{\\ell}) = f_X(z) = \\lambda e^{-\\lambda z}$，其中 $z \\ge 0$。\n-   攻击情况，$H_{a}$：$f(z|H_{a}) = f_Y(z) = \\mu e^{-\\mu z}$，其中 $z \\ge 0$。\n\n决策规则是：如果 $z > T$ 则分类为“攻击”，如果 $z \\le T$ 则分类为“合法”。\n\n总 Bayes 风险 $R(T)$ 是错分预期成本的总和：\n$$R(T) = \\pi_{\\ell} C_{FP} P(\\text{decide } H_a | H_{\\ell}) + \\pi_{a} C_{FN} P(\\text{decide } H_{\\ell} | H_{a})$$\n其中 $C_{FP}$ 是假阳性（将合法情况分类为攻击）的成本，而 $C_{FN}$ 是假阴性（将攻击情况分类为合法）的成本。问题陈述这些成本相等，因此设 $C_{FP} = C_{FN} = C$。\n\n错分概率为：\n-   $P(\\text{decide } H_a | H_{\\ell}) = P(X > T) = \\int_T^\\infty \\lambda e^{-\\lambda x} dx = e^{-\\lambda T}$。这是一个假阳性。\n-   $P(\\text{decide } H_{\\ell} | H_{a}) = P(Y \\le T) = \\int_0^T \\mu e^{-\\mu y} dy = 1 - e^{-\\mu T}$。这是一个假阴性。\n\n将这些代入风险方程：\n$$R(T) = C \\left[ \\pi_{\\ell} e^{-\\lambda T} + \\pi_{a} (1 - e^{-\\mu T}) \\right]$$\n\n为了找到使 $R(T)$ 最小化的最优阈值 $T$，我们计算 $R(T)$ 关于 $T$ 的导数，并将其设为零：\n$$\\frac{dR(T)}{dT} = C \\left[ \\pi_{\\ell} (-\\lambda e^{-\\lambda T}) - \\pi_{a} (-\\mu e^{-\\mu T}) \\right] = 0$$\n由于 $C > 0$，我们可以将其约去：\n$$-\\pi_{\\ell} \\lambda e^{-\\lambda T} + \\pi_{a} \\mu e^{-\\mu T} = 0$$\n$$\\pi_{a} \\mu e^{-\\mu T} = \\pi_{\\ell} \\lambda e^{-\\lambda T}$$\n为了解出 $T$，我们重新整理方程：\n$$\\frac{e^{-\\mu T}}{e^{-\\lambda T}} = \\frac{\\pi_{\\ell} \\lambda}{\\pi_{a} \\mu}$$\n$$e^{(\\lambda - \\mu)T} = \\frac{\\pi_{\\ell} \\lambda}{\\pi_{a} \\mu}$$\n对两边取自然对数：\n$$(\\lambda - \\mu)T = \\ln\\left(\\frac{\\pi_{\\ell} \\lambda}{\\pi_{a} \\mu}\\right)$$\n最优阈值为：\n$$T = \\frac{1}{\\lambda - \\mu} \\ln\\left(\\frac{\\pi_{\\ell} \\lambda}{\\pi_{a} \\mu}\\right)$$\n\n现在，我们代入给定的参数值：\n-   $\\lambda = \\dfrac{1}{300}\\,\\mathrm{s}^{-1}$\n-   $\\mu = \\dfrac{1}{3600}\\,\\mathrm{s}^{-1}$\n-   $\\pi_{\\ell} = 0.99$\n-   $\\pi_{a} = 0.01$\n\n首先，计算公式中的各项：\n-   $\\lambda - \\mu = \\dfrac{1}{300} - \\dfrac{1}{3600} = \\dfrac{12-1}{3600} = \\dfrac{11}{3600}\\,\\mathrm{s}^{-1}$。\n-   对数内的比值为 $\\dfrac{\\pi_{\\ell} \\lambda}{\\pi_{a} \\mu} = \\left(\\dfrac{\\pi_{\\ell}}{\\pi_{a}}\\right) \\left(\\dfrac{\\lambda}{\\mu}\\right)$。\n    -   $\\dfrac{\\pi_{\\ell}}{\\pi_{a}} = \\dfrac{0.99}{0.01} = 99$。\n    -   $\\dfrac{\\lambda}{\\mu} = \\dfrac{1/300}{1/3600} = \\dfrac{3600}{300} = 12$。\n    -   因此，$\\dfrac{\\pi_{\\ell} \\lambda}{\\pi_{a} \\mu} = 99 \\times 12 = 1188$。\n\n将这些值代回 $T$ 的方程中：\n$$T = \\frac{1}{11/3600} \\ln(1188) = \\frac{3600}{11} \\ln(1188)$$\n现在，我们计算数值：\n$$\\ln(1188) \\approx 7.079969$$\n$$T \\approx \\frac{3600}{11} \\times 7.079969 \\approx 327.2727... \\times 7.079969$$\n$$T \\approx 2316.89\\, \\mathrm{s}$$\n\n这个值约等于 $2317\\,\\mathrm{s}$。\n\n### 逐项分析\n\n-   **A. $T \\approx 2320\\,\\text{秒}$**：我们计算出的 Bayes 最优阈值是 $T \\approx 2317\\,\\text{s}$。该选项提供了一个四舍五入到最接近 $10\\,\\text{s}$ 的值，这是对我们严谨计算结果的一个极好的近似。\n    **结论：正确**\n\n-   **B. $T \\approx 1188\\,\\text{秒}$**：值 $1188$ 是我们公式中自然对数的自变量，即 $\\frac{\\pi_{\\ell} \\lambda}{\\pi_{a} \\mu}$。这是计算过程中的一个中间量，而不是最终的阈值 $T$。一个常见的错误是误解了公式的各个部分。\n    **结论：错误**\n\n-   **C. $T \\approx 1800\\,\\text{秒}$**：这个值是 $3600\\,\\text{s}$ 的一半。值 $3600\\,\\text{s}$ 是攻击分布的平均时间 ($1/\\mu$)。从 Bayes 决策理论来看，选择其中一个分布的平均值的一半作为最优阈值是没有理论依据的。\n    **结论：错误**\n\n-   **D. $T \\approx 3600\\,\\text{秒}$**：这个值是攻击的平均持续时间，$1/\\mu = 3600\\,\\text{s}$。选择攻击分布的平均值作为阈值是一种可能的启发式方法，但它不是 Bayes 最优阈值，因为它忽略了先验概率和合法分布的参数。\n    **结论：错误**", "answer": "$$\\boxed{A}$$", "id": "3650774"}]}