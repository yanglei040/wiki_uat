{"hands_on_practices": [{"introduction": "地址空间布局随机化（ASLR）是现代操作系统中一种核心的概率性防御手段。它的基本思想是通过随机化内存布局，使得攻击者难以预测关键数据和代码的位置。此练习旨在通过建立一个数学模型来量化ASLR的有效性，让你从第一性原理出发，推导暴力破解攻击成功所需的期望时间。通过这个实践[@problem_id:3657054]，你将深刻理解熵（$b$）的增加如何指数级地提升安全性，并认识到系统的崩溃处理效率（$\\lambda$）如何影响攻击的现实可行性。", "problem": "一个操作系统采用地址空间布局随机化（ASLR）技术，在每次进程重启时，将一个关键代码指针的基地址在一个由 $2^{b}$ 个不同可能性构成的地址池中进行均匀随机化。攻击者尝试进行暴力覆写攻击：每次猜测独立地针对一个候选地址；如果猜测错误，进程会崩溃并由系统自动重启。由于崩溃处理和重启的开销，观测到的稳态尝试速率为每秒 $\\lambda$ 次，并且每次尝试都是独立的，单次猜测的成功概率相同。假设在 $2^{b}$ 个地址中的选择在每次重启时都是均匀且独立的，并且猜测与随机化过程无关。\n\n从独立伯努利试验和几何分布的核心定义出发，推导首次成功覆写所需的期望物理时钟时间关于 $b$ 和 $\\lambda$ 的函数表达式。然后，对于 $b=16$ 和 $b=32$ 的情况，计算 $b=32$ 时的期望时间与 $b=16$ 时的期望时间之比 $R$。给出 $R$ 的精确值，该值应为一个无量纲的数。此外，请用文字解释 $\\lambda$ 如何影响攻击的实际可行性，但解释中不得使用任何数值。最终答案只应报告比率 $R$，且该值必须是无量纲的精确值。", "solution": "在进行解答之前，首先对问题陈述进行严格验证。\n\n### 步骤1：提取已知条件\n- 关键代码指针基地址的不同可能性的数量为 $2^b$。\n- 每次进程重启时，在这些 $2^b$ 种可能性上进行均匀随机化。\n- 攻击者尝试进行暴力覆写。\n- 每次猜测独立地针对一个候选地址。\n- 错误的猜测导致进程崩溃和自动重启。\n- 稳态尝试速率为每秒 $\\lambda$ 次。\n- 每次尝试都是独立的，且单次猜测的成功概率相同。\n- 地址的选择在每次重启时都是均匀且独立的。\n- 猜测与随机化过程无关。\n- 第一个任务是从核心定义出发，推导首次成功覆写所需的期望物理时钟时间关于 $b$ 和 $\\lambda$ 的函数表达式。\n- 第二个任务是计算 $b=32$ 时的期望时间与 $b=16$ 时的期望时间之比 $R$。\n- 最终答案必须是 $R$ 的无量纲精确值。\n- 还需要对 $\\lambda$ 如何影响实际可行性进行文字解释，且不含数值。\n\n### 步骤2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估。\n- **科学基础**：该问题在计算机安全和概率论原理方面有坚实的基础。地址空间布局随机化（ASLR）是现代操作系统中的一种标准防御机制。将暴力攻击建模为一系列独立试验是安全分析中的一种标准且有效的方法。均匀概率分布、伯努利试验和几何分布的概念是数学和统计学的基础。\n- **适定性**：该问题提供了推导所求表达式和计算比率所需的所有必要信息。参数 $b$ 和 $\\lambda$ 均已定义，概率模型也已明确。可以确定一个唯一且稳定的解。\n- **客观性**：该问题使用科学和工程学科中常见的精确、客观的语言进行陈述。它不含主观或基于观点的陈述。\n\n该问题不存在任何使其无效的缺陷。它在科学上是合理的，可直接形式化，是完整的，科学上可信，是适定的，并且是核心原理的非平凡应用。\n\n### 步骤3：结论与行动\n问题有效。将提供解答。\n\n### 期望时间的推导\n\n令 $N$ 为实现首次成功覆写所需尝试次数的随机变量。问题陈述，基地址是从一个包含 $2^b$ 个不同可能性的集合中均匀选择的。攻击者进行一次独立的猜测。因此，任何单次尝试的成功概率（记为 $p$）为：\n$$p = \\frac{1}{2^b}$$\n每次猜测都是一次独立试验，因为每次失败并随之重启后，地址都会被重新随机化。这种情况描述了一个独立伯努利试验序列，每次试验的成功概率为 $p$。获得首次成功所需的试验次数 $N$ 服从几何分布。\n\n几何分布的概率质量函数为 $P(N=k) = (1-p)^{k-1}p$，其中 $k = 1, 2, 3, \\dots$。服从几何分布的随机变量的期望值是成功概率的倒数。因此，首次成功所需尝试次数的期望值 $E[N]$ 为：\n$$E[N] = \\frac{1}{p}$$\n代入 $p$ 的表达式：\n$$E[N] = \\frac{1}{1/2^b} = 2^b$$\n这给出了成功前所需尝试（或等效地，崩溃）的期望次数。\n\n问题要求的是首次成功所需的期望*物理时钟时间*，我们记为 $E[T]$。已知稳态尝试速率为每秒 $\\lambda$ 次。该速率包含了所有开销，包括崩溃处理和进程重启。每次尝试的平均耗时是该速率的倒数，即每次尝试 $\\frac{1}{\\lambda}$ 秒。\n\n总物理时钟时间 $T$ 是尝试次数 $N$ 与每次尝试时间的乘积。根据期望的线性性质，总期望时间是期望尝试次数乘以平均每次尝试的时间。\n$$E[T] = E[N] \\times (\\text{每次尝试的时间})$$\n$$E[T] = 2^b \\times \\frac{1}{\\lambda} = \\frac{2^b}{\\lambda}$$\n这就是首次成功覆写所需的期望物理时钟时间关于 $b$ 和 $\\lambda$ 的函数表达式。\n\n### 比率 $R$ 的计算\n\n问题要求计算熵为 $b=32$ 位时的期望时间与熵为 $b=16$ 位时的期望时间之比 $R$。令 $E[T_{32}]$ 表示 $b=32$ 时的期望时间，令 $E[T_{16}]$ 表示 $b=16$ 时的期望时间。\n\n使用推导出的 $E[T]$ 公式：\n$$E[T_{32}] = \\frac{2^{32}}{\\lambda}$$\n$$E[T_{16}] = \\frac{2^{16}}{\\lambda}$$\n比率 $R$ 定义为：\n$$R = \\frac{E[T_{32}]}{E[T_{16}]}$$\n代入表达式：\n$$R = \\frac{2^{32}/\\lambda}{2^{16}/\\lambda} = \\frac{2^{32}}{2^{16}}$$\n使用指数性质 $x^a / x^c = x^{a-c}$：\n$$R = 2^{32-16} = 2^{16}$$\n现在，我们计算 $2^{16}$ 的精确数值：\n$$2^{16} = (2^8)^2 = 256^2 = 65536$$\n或者，$2^{16} = 2^6 \\times 2^{10} = 64 \\times 1024 = 65536$。\n\n比率 $R$ 精确等于 $65536$。\n\n### $\\lambda$ 对实际可行性的影响\n\n成功攻击的期望时间 $E[T] = \\frac{2^b}{\\lambda}$ 与尝试速率 $\\lambda$ 成反比。参数 $\\lambda$ 量化了攻击者执行猜测的实际速度，该速度考虑了所有系统级开销，如进程创建、崩溃检测和日志记录。较高的 $\\lambda$ 值意味着攻击更高效，连续尝试之间的时间间隔很短。这减少了攻破系统的总期望时间，使得暴力攻击在给定时间范围内更具可行性。相反，较低的 $\\lambda$ 值表示每次尝试的开销很大，从而延长了猜测之间的时间间隔。这增加了成功所需的总期望时间，因此降低了攻击的实际可行性，并增强了ASLR机制所提供的有效安全性。因此，系统处理崩溃的性能是决定ASLR在对抗暴力攻击时的实际安全性的一个关键因素。", "answer": "$$\\boxed{65536}$$", "id": "3657054"}, {"introduction": "栈金丝雀（Stack Canary）作为一种缓冲区溢出检测机制，其作用类似于在关键数据旁埋设的一根“绊线”。虽然其概念直观，但在实际工程设计中，我们必须在安全性和兼容性之间做出权衡。例如，为了避免金丝雀值干扰字符串处理函数，有时需要禁用某些特殊字节（如 $0x00$）。本练习[@problem_id:3657006]将引导你运用信息论的知识，精确计算这种为兼容性而做的设计妥协所带来的熵损失，并量化其对意外覆写被忽略概率的影响，从而让你学会如何在现实约束下评估安全决策。", "problem": "一个系统部署了栈金丝雀（stack canary）来检测内存损坏。在无约束的设计中，金丝雀是 $m$ 个独立的字节，从所有 $256$ 个字节值的集合中均匀随机选取，产生完整的 $8m$ 比特熵。为了减少与文本处理错误的交互，一位工程师提议对金丝雀进行编码，使得每个金丝雀字节都避开 $0x00$ 和 $0x0A$ 这两个字节值。你需要对该设计进行形式化，并量化其安全属性。\n\n采用以下基于标准概率论和信息论的模型。每个金丝雀字节都是通过拒绝采样法从一个理想的、独立的、均匀的 8 位值源中生成的：从 $\\{0,1,\\dots,255\\}$ 中均匀抽取一个字节，如果它等于 $0x00$ 或 $0x0A$，则丢弃并重新抽取，直到它落入大小为 $256-2=254$ 的允许字母表中。这样就得到了 $m$ 个在大小为 $254$ 的字母表上独立均匀分布的符号。使用 Shannon 熵的定义 $H(X) = - \\sum_{x} \\Pr[X=x] \\log_{2} \\Pr[X=x]$，其中独立性意味着乘积分布的熵具有可加性。\n\n假设 $m=8$。令 $\\Delta b$ 表示与无约束的 8 字节金丝雀相比的熵损失（以比特为单位）。接下来，考虑一次意外覆写，它将 $m$ 个独立的字节（每个字节从所有 $256$ 个值中均匀随机选取）写入金丝雀的内存区域。如果写入后，金丝雀检查仍然与最初存储的金丝雀完全匹配，则该覆写是不可见的。令 $p$ 表示在此模型下这种意外覆写不可见的概率。\n\n计算 $m=8$ 时的 $\\Delta b$ 和 $p$，并将数值结果四舍五入到四位有效数字。熵损失以比特表示；概率以小数表示（而非百分比）。以单行两个条目的形式提供你的最终答案，顺序为 $\\Delta b$，然后是 $p$。", "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于概率论和信息论，问题定义明确，有足够的信息得出唯一解，并且形式上是客观的。我们可以开始求解。\n\n问题要求计算两个量：受约束金丝雀设计中的熵损失 $\\Delta b$ 和意外覆写未被检测到的概率 $p$。我们已知金丝雀的大小为 $m=8$ 字节。\n\n首先，我们计算熵损失 $\\Delta b$。\n随机变量 $X$ 的熵由 Shannon 公式给出 $H(X) = - \\sum_{x} \\Pr[X=x] \\log_{2} \\Pr[X=x]$。对于一个在大小为 $N$ 的集合上均匀分布的变量，任何单个结果的概率是 $\\frac{1}{N}$，因此熵简化为 $H = - \\sum_{i=1}^{N} \\frac{1}{N} \\log_{2}\\left(\\frac{1}{N}\\right) = -N \\left(\\frac{1}{N}\\right) (-\\log_{2} N) = \\log_{2} N$。\n\n无约束的金丝雀由 $m$ 个独立的字节组成，每个字节从大小为 $N_{unc} = 256$ 的字母表中均匀选取。由于其独立性，总熵 $H_{unc}$ 是单个字节熵的总和：\n$$H_{unc} = m \\times \\log_{2}(256)$$\n由于 $\\log_{2}(256) = \\log_{2}(2^{8}) = 8$，熵为：\n$$H_{unc} = 8m \\text{ 比特}$$\n\n受约束的金丝雀也由 $m$ 个独立的字节组成，但每个字节是从一个允许值的字母表中均匀选取的。问题陈述指出，两个字节值 $0x00$ 和 $0x0A$ 是被禁止的。这留下了一个大小为 $N_{con} = 256 - 2 = 254$ 的字母表。受约束金丝雀的总熵 $H_{con}$ 是：\n$$H_{con} = m \\times \\log_{2}(254)$$\n\n熵损失 $\\Delta b$ 是无约束设计和受约束设计熵之间的差值：\n$$\\Delta b = H_{unc} - H_{con} = 8m - m \\log_{2}(254)$$\n提取公因数 $m$ 并利用对数的性质：\n$$\\Delta b = m (8 - \\log_{2}(254)) = m (\\log_{2}(256) - \\log_{2}(254)) = m \\log_{2}\\left(\\frac{256}{254}\\right)$$\n代入给定值 $m=8$：\n$$\\Delta b = 8 \\log_{2}\\left(\\frac{256}{254}\\right) = 8 \\log_{2}\\left(\\frac{128}{127}\\right)$$\n为了计算数值，我们使用换底公式 $\\log_{2}(x) = \\frac{\\ln(x)}{\\ln(2)}$：\n$$\\Delta b = 8 \\frac{\\ln(256/254)}{\\ln(2)} \\approx 8 \\frac{\\ln(1.007874)}{\\ln(2)} \\approx 8 \\frac{0.0078431}{0.693147} \\approx 8 \\times 0.011315 \\approx 0.09052016$$\n四舍五入到四位有效数字，熵损失为 $\\Delta b \\approx 0.09052$ 比特。\n\n接下来，我们计算意外覆写不可见的概率 $p$。\n令 $C = (C_1, C_2, \\dots, C_m)$ 为表示最初存储的金丝雀的随机向量。每个分量 $C_i$ 是一个独立的随机变量，在允许的字节集合 $\\mathcal{A}$ 上均匀分布，其中 $|\\mathcal{A}| = 254$。因此，对于任何字节值 $k \\in \\mathcal{A}$，$\\Pr[C_i=k] = \\frac{1}{254}$。\n\n令 $W = (W_1, W_2, \\dots, W_m)$ 为表示由覆写写入的字节的随机向量。每个分量 $W_i$ 是一个独立的随机变量，在所有可能的字节值集合 $\\mathcal{B}$ 上均匀分布，其中 $|\\mathcal{B}| = 256$。因此，对于任何字节值 $k \\in \\mathcal{B}$，$\\Pr[W_i=k] = \\frac{1}{256}$。\n\n如果写入的金丝雀 $W$ 与原始金丝雀 $C$ 完全相同，则覆写是不可见的。我们需要计算 $p = \\Pr[W=C]$。向量 $C$ 和 $W$ 是独立的。由于每个向量内部单个字节的独立性，完全匹配的概率是每个字节匹配概率的乘积：\n$$p = \\Pr[W_1 = C_1, W_2 = C_2, \\dots, W_m = C_m] = \\prod_{i=1}^{m} \\Pr[W_i = C_i]$$\n我们来计算单字节匹配的概率 $\\Pr[W_i = C_i]$。我们可以通过对所有可能的匹配值求和来找到这个概率。只有当值在允许的集合 $\\mathcal{A}$ 中时，才可能发生匹配。\n$$\\Pr[W_i = C_i] = \\sum_{k \\in \\mathcal{A}} \\Pr[W_i = k \\text{ and } C_i = k]$$\n由于 $W_i$ 和 $C_i$ 是独立的：\n$$\\Pr[W_i = C_i] = \\sum_{k \\in \\mathcal{A}} \\Pr[W_i = k] \\Pr[C_i = k]$$\n代入概率：\n$$\\Pr[W_i = C_i] = \\sum_{k \\in \\mathcal{A}} \\left(\\frac{1}{256}\\right) \\left(\\frac{1}{254}\\right)$$\n求和号内的项对于所有 $k \\in \\mathcal{A}$ 都是常数。集合 $\\mathcal{A}$ 的大小是 $254$。\n$$\\Pr[W_i = C_i] = |\\mathcal{A}| \\times \\left(\\frac{1}{256} \\times \\frac{1}{254}\\right) = 254 \\times \\frac{1}{256 \\times 254} = \\frac{1}{256}$$\n单字节匹配的概率是 $\\frac{1}{256}$。因此，一个 $m$ 字节匹配的概率是：\n$$p = \\left(\\frac{1}{256}\\right)^m$$\n代入 $m=8$：\n$$p = \\left(\\frac{1}{256}\\right)^8 = (256)^{-8} = (2^8)^{-8} = 2^{-64}$$\n其数值为：\n$$p = \\frac{1}{18,446,744,073,709,551,616} \\approx 5.42101086 \\times 10^{-20}$$\n四舍五入到四位有效数字，概率为 $p \\approx 5.421 \\times 10^{-20}$。\n\n我们已经计算出两个所需的值。\n$\\Delta b \\approx 0.09052$。\n$p \\approx 5.421 \\times 10^{-20}$。", "answer": "$$\\boxed{0.09052, 5.421 \\times 10^{-20}}$$", "id": "3657006"}, {"introduction": "除了编译器和程序层面的防御，操作系统本身也利用虚拟内存系统来构筑防线，栈保护页（Stack Guard Pages）便是典型例子。它在栈的末端设置一个“警戒区”，任何对该区域的访问都会触发页面错误，从而使操作系统有机会介入并安全地扩展栈或终止异常进程。本练习[@problem_id:3657047]要求你构建一个计算模型来模拟这一动态过程，将虚拟内存管理的抽象规则转化为一个关于递归深度的可预测模型。这不仅能加深你对核心操作系统机制的理解，还能让你亲身体会这些机制是如何被巧妙地用于内存安全防护的。", "problem": "你将构建一个关于递归增长下栈保护页行为的纯计算模型，以量化由保护页引发的页错误数量与递归深度的函数关系。其目标是模拟操作系统的保护页机制如何通过防止不受检查的栈增长来为内存损坏防御做出贡献。你的任务是推导并实现一个函数 $F(d)$，该函数在给定一组系统参数的情况下，输出执行 $d$ 次递归调用时所发生的成功保护页错误次数。将此实验视为一次基于以下关于虚拟内存和保护页的、经过充分检验的事实和核心定义的模拟：\n\n- 虚拟内存被划分为大小固定为 $P$ 字节的页。\n- 进程栈初始时有 $S_0$ 字节被映射且可访问。\n- 一个大小为 $P$ 字节的单一保护页被放置在已映射栈的紧邻位置，沿着栈增长的方向。当程序的栈试图增长到保护页区域时，访问会触发一个页错误。操作系统处理此错误的方式是精确映射一个额外的栈页面（如果在允许的限制内），并在新映射的页面之后重新建立一个新的保护页。在限制范围内，此过程会重复。\n- 总共映射的栈大小最多被限制为 $S_{\\max}$ 字节。试图增长超过此限制将导致一个终结性错误，该错误不会映射额外的页面。为了本模型的目的，终结性错误不计入 $F(d)$。\n- 每次递归调用消耗 $s$ 字节的栈帧。对于深度为 $d$ 的递归，所需的总栈字节数是帧大小与深度的乘积。\n\n仅根据这些原则，定义并计算在上述模型下，将栈增长到深度 $d$ 所引起的成功保护页错误次数 $F(d)$。你必须从第一性原理出发推导 $F(d)$，不假设任何预先给定的快捷公式。你的程序应确定性地实现此模型，并为指定的测试套件生成结果。\n\n假设和单位：\n- 所有大小 $P$、$S_0$、$S_{\\max}$ 和 $s$ 的单位都是字节。\n- 结果 $F(d)$ 是一个非负整数。\n\n测试套件：\n为以下每一组参数计算 $F(d)$。每个项目符号表示一个独立的测试用例，参数为 $(P, S_0, S_{\\max}, s, d)$：\n\n- 情况 A: $(P = 4096, S_0 = 16384, S_{\\max} = 65536, s = 1024, d = 20)$。\n- 情况 B: $(P = 4096, S_0 = 20480, S_{\\max} = 40960, s = 100, d = 100)$。\n- 情况 C: $(P = 4096, S_0 = 8192, S_{\\max} = 24576, s = 4096, d = 6)$。\n- 情况 D: $(P = 4096, S_0 = 4096, S_{\\max} = 12288, s = 3000, d = 5)$。\n- 情况 E: $(P = 1024, S_0 = 2048, S_{\\max} = 5120, s = 600, d = 7)$。\n- 情况 F: $(P = 4096, S_0 = 8192, S_{\\max} = 40960, s = 512, d = 0)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与上述情况相同。例如，一个有效的输出形如 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_i$ 是对应情况下 $F(d)$ 的整数值。", "solution": "用户请求一个问题的解决方案，该问题模拟虚拟内存系统中栈的增长和由保护页引发的页错误。问题要求推导并实现一个函数 $F(d)$，用于计算深度为 $d$ 的递归所产生的成功保护页错误次数。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- 虚拟内存页大小：$P$ 字节。\n- 初始映射的栈大小：$S_0$ 字节。\n- 保护页大小：$P$ 字节。\n- 最大总映射栈大小：$S_{\\max}$ 字节。\n- 每次递归调用的栈帧大小：$s$ 字节。\n- 递归深度：$d$。\n- 待计算的成功保护页错误次数：$F(d)$。一次成功的错误是指导致新页面被映射的错误，不包括终结性错误。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它模拟了现代操作系统中用于栈管理的简化但标准的机制（保护页）。这是一个定义明确的问题，所有必需的参数都已定义，且栈增长的规则是确定性的，从而导向唯一的解。语言是客观和定量的。该问题与其所述的操作系统内存损坏防御主题直接相关。它没有违反任何无效性标准。\n\n**第 3 步：结论与行动**\n该问题被判定为**有效**。将推导并实现一个解决方案。\n\n### 函数 $F(d)$ 的推导\n\n函数 $F(d)$ 的推导从问题陈述中概述的基本原理出发。\n\n1.  **所需总栈大小**：对于深度为 $d$ 的递归，其中每次调用消耗 $s$ 字节的栈帧，所需的总栈大小是这两个量的乘积。我们将其表示为 $S_{req}$：\n    $$S_{req} = d \\times s$$\n\n2.  **栈增长的条件**：初始栈大小为 $S_0$。如果所需的栈大小 $S_{req}$ 小于或等于初始大小 $S_0$，则不需要栈增长。因此，保护页永远不会被访问，也不会发生错误。\n    $$ \\text{如果 } S_{req} \\le S_0, \\text{ 那么 } F(d) = 0 $$\n    如果 $S_{req}  S_0$，则必须扩展栈以容纳额外的内存。所需的额外总字节数为 $S_{req} - S_0$。\n\n3.  **所需错误次数**：栈以页大小 $P$ 的离散增量进行扩展。每次扩展对应一次成功的保护页错误。为了确定满足总内存需求 $S_{req}$ 所需的错误次数，我们必须计算需要向初始栈 $S_0$ 添加多少个页面。设 $N_{needed}$ 为所需的错误次数。在发生 $N_{needed}$ 次错误后，新的栈大小将是 $S_0 + N_{needed} \\times P$。这个新大小必须至少与 $S_{req}$ 一样大：\n    $$ S_0 + N_{needed} \\times P \\ge S_{req} $$\n    当 $S_{req}  S_0$ 时，求解 $N_{needed}$：\n    $$ N_{needed} \\times P \\ge S_{req} - S_0 $$\n    $$ N_{needed} \\ge \\frac{S_{req} - S_0}{P} $$\n    由于 $N_{needed}$ 必须是表示离散错误事件计数的整数，因此它必须是满足此不等式的最小整数。这是上取整函数的定义：\n    $$ N_{needed} = \\left\\lceil \\frac{S_{req} - S_0}{P} \\right\\rceil, \\quad \\text{对于 } S_{req}  S_0 $$\n    我们可以使用 $\\max$ 函数为 $N_{needed}$ 写出一个涵盖两种情况（$S_{req}  S_0$ 和 $S_{req} \\le S_0$）的单一表达式：\n    $$ N_{needed} = \\left\\lceil \\frac{\\max(0, S_{req} - S_0)}{P} \\right\\rceil $$\n    如果 $S_{req} \\le S_0$，则分子为 $0$，且 $\\lceil 0/P \\rceil = 0$，这是正确的。\n\n4.  **最大可能错误次数**：栈的增长受到最大栈大小 $S_{\\max}$ 的约束。一次保护页错误只有在它导致分配一个新页面，并且总栈大小不超过 $S_{\\max}$ 的情况下才算成功。设 $k$ 为已经发生的成功错误次数。当前的栈大小是 $S_0 + k \\times P$。为了使第 $(k+1)$ 次错误成功，产生的栈大小必须在限制之内：\n    $$ S_0 + (k+1) \\times P \\le S_{\\max} $$\n    求解错误次数 $k+1$：\n    $$ (k+1) \\times P \\le S_{\\max} - S_0 $$\n    $$ k+1 \\le \\frac{S_{\\max} - S_0}{P} $$\n    由于 $k+1$ 是一个整数，我们表示为 $N_{max}$ 的最大成功错误次数受此表达式的下取整的限制。如果 $S_{\\max} \\le S_0$，则不可能增长，所以 $N_{max}=0$。这可以通过以下公式表示：\n    $$ N_{max} = \\left\\lfloor \\frac{\\max(0, S_{\\max} - S_0)}{P} \\right\\rfloor $$\n\n5.  **$F(d)$ 的最终公式**：实际的成功保护页错误次数 $F(d)$ 是既能满足内存需求又在系统限制内可能的错误次数。因此，$F(d)$ 是所需错误次数和最大可能错误次数的最小值：\n    $$ F(d) = \\min(N_{needed}, N_{max}) $$\n    代入上面推导出的表达式，我们得到 $F(d)$ 的完整公式：\n    $$ F(d) = \\min\\left( \\left\\lceil \\frac{\\max(0, d \\cdot s - S_0)}{P} \\right\\rceil, \\left\\lfloor \\frac{\\max(0, S_{\\max} - S_0)}{P} \\right\\rfloor \\right) $$\n    该公式可以使用整数算术来实现。对于非负整数 $a$ 和正整数 $b$，$\\lceil a/b \\rceil$ 可以计算为 $(a + b - 1) / b$，而 $\\lfloor a/b \\rfloor$ 就是简单的整数除法 $a / b$。这样可以避免浮点数的不精确性，并且计算效率高。\n\n这就完成了从第一性原理推导函数 $F(d)$ 的过程。实现部分将把此逻辑应用于所提供的测试套件。", "answer": "$$\\boxed{[1, 0, 4, 2, 3, 0]}$$", "id": "3657047"}]}