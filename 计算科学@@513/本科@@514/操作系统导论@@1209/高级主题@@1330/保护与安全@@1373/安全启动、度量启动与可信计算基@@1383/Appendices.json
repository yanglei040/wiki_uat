{"hands_on_practices": [{"introduction": "要真正理解可信计算，我们首先要掌握其核心机制——度量启动。这个练习 [@problem_id:3679559] 通过一个简化的“玩具”哈希函数，让您亲手计算平台配置寄存器 (PCR) 的值是如何通过一系列度量逐步构建的。通过这个计算，您将直观地感受到 PCR 值如何像一个防篡改的日志一样，忠实地记录下启动过程的每一步。", "problem": "您正在分析一个计算机系统中的度量启动序列，该系统使用可信平台模块 (TPM) 和平台配置寄存器 (PCR) 来记录可信计算基 (TCB) 的完整性。在度量启动中，每个组件的度量值都通过递归关系 $S' = H(S \\Vert d)$ 扩展到一个PCR中，其中 $S$ 是当前的PCR状态，$d$ 是下一个度量值，$H$ 是一个哈希函数。为了本次练习的目的，请使用以下玩具函数替换真实的密码学哈希函数，以便进行精确计算：\n$$H(u \\Vert v) = (11u + 7v + 13) \\bmod 101.$$\n假设单个PCR被建模为一个状态机，其初始状态为 $S_0 = 0$。一项启动策略按照固定顺序度量和扩展恰好 $3$ 个TCB组件：引导加载程序、内核，然后是初始内存盘。清单列出引导加载程序的度量值为 $m_b = 23$，内核的度量值为 $m_k = 57$，初始内存盘的度量值为一个未知值 $x$。启动后，TPM报告的最终PCR状态为 $S_f = 88$。\n\n仅使用度量启动递归关系 $S' = H(S \\Vert d)$ 和上述玩具哈希函数 $H$，确定 $x \\in \\{0,1,\\ldots,100\\}$ 的唯一值，使得一个恰好包含3次扩展的序列，按照给定顺序，从 $S_0$ 生成 $S_f$。\n\n请以模101的整数形式提供您的答案。无需四舍五入，最终答案中不应包含任何单位。", "solution": "用户要求我在一个模拟的度量启动序列中，找到未知度量值 $x$ 的值。\n\n### 第1步：提取已知条件\n- 度量启动的递归关系为 $S' = H(S \\Vert d)$，其中 $S$ 是当前状态，$d$ 是度量值。\n- 玩具哈希函数定义为 $H(u \\Vert v) = (11u + 7v + 13) \\bmod 101$。\n- 平台配置寄存器 (PCR) 的初始状态为 $S_0 = 0$。\n- 按固定顺序进行恰好 $3$ 次度量。\n- 第一次度量是引导加载程序，$m_b = 23$。\n- 第二次度量是内核，$m_k = 57$。\n- 第三次度量是初始内存盘，其值为未知的 $x$。\n- $x$ 的定义域是 $\\{0, 1, \\ldots, 100\\}$。\n- 3次度量后的最终PCR状态是 $S_f = 88$。\n\n### 第2步：使用提取的已知条件进行验证\n这个问题是有科学依据的，因为它使用了一个简化但数学上明确定义的模型来阐明“度量启动”这一现实世界中的概念，这是操作系统安全领域的一个核心主题。使用“玩具”函数是一种公认的教学工具。这个问题是适定的，提供了所有必要的信息（$S_0$、递归关系、函数$H$、三个输入中的两个，以及最终输出$S_f$），以唯一地确定第三个输入 $x$。计算涉及模运算，这是一种标准的数学工具。这个问题是客观的，没有模糊或主观的术语。它没有违反任何无效性标准。所有提供的值都是整数，且运算在模101的整数上是封闭的。因此，该问题是有效的。\n\n### 第3步：求解\n该问题要求我们通过顺序应用度量扩展过程来确定第三个度量值 $x$ 的值。该过程包括三个步骤，从初始状态 $S_0$ 开始。\n\n设 $S_0$、$S_1$、$S_2$ 和 $S_3$ 为PCR的状态。已知 $S_0 = 0$。最终状态为 $S_3 = S_f = 88$。\n\n**第一次扩展（引导加载程序）：**\n第一次度量是引导加载程序的度量值，$d_1 = m_b = 23$。状态从 $S_0$ 转换到 $S_1$。\n$$S_1 = H(S_0 \\Vert m_b)$$\n使用给定的值，$S_0 = 0$ 和 $m_b = 23$：\n$$S_1 = H(0 \\Vert 23) = (11 \\cdot 0 + 7 \\cdot 23 + 13) \\bmod 101$$\n$$S_1 = (0 + 161 + 13) \\bmod 101$$\n$$S_1 = 174 \\bmod 101$$\n为了求余数，我们进行除法运算：$174 = 1 \\cdot 101 + 73$。\n$$S_1 = 73$$\n\n**第二次扩展（内核）：**\n第二次度量是内核的度量值，$d_2 = m_k = 57$。状态从 $S_1$ 转换到 $S_2$。\n$$S_2 = H(S_1 \\Vert m_k)$$\n使用计算出的值 $S_1 = 73$ 和给定的 $m_k = 57$：\n$$S_2 = H(73 \\Vert 57) = (11 \\cdot 73 + 7 \\cdot 57 + 13) \\bmod 101$$\n首先，计算乘积：\n$$11 \\cdot 73 = 803$$\n$$7 \\cdot 57 = 399$$\n现在将这些值代回表达式中：\n$$S_2 = (803 + 399 + 13) \\bmod 101$$\n$$S_2 = 1215 \\bmod 101$$\n为了求余数，我们进行除法运算：$1215 = 12 \\cdot 101 + 3$。\n$$S_2 = 3$$\n\n**第三次扩展（初始内存盘）：**\n第三次也是最后一次度量是初始内存盘的值，$d_3 = x$。状态从 $S_2$ 转换到 $S_3$。已知最终状态为 $S_3 = S_f = 88$。\n$$S_3 = H(S_2 \\Vert x)$$\n使用计算出的值 $S_2 = 3$ 和最终状态 $S_3 = 88$：\n$$88 = H(3 \\Vert x) = (11 \\cdot 3 + 7 \\cdot x + 13) \\bmod 101$$\n这给了我们一个关于 $x$ 的线性同余方程：\n$$88 \\equiv (33 + 7x + 13) \\pmod{101}$$\n$$88 \\equiv (46 + 7x) \\pmod{101}$$\n为了解出 $x$，我们首先分离含有 $x$ 的项：\n$$88 - 46 \\equiv 7x \\pmod{101}$$\n$$42 \\equiv 7x \\pmod{101}$$\n模数101是一个质数。由于 $\\gcd(7, 101) = 1$，7 模 101 存在唯一的乘法逆元，我们可以将同余式两边同时“除以”7。在这种情况下，这个除法在整数上是精确的。\n$$x \\equiv \\frac{42}{7} \\pmod{101}$$\n$$x \\equiv 6 \\pmod{101}$$\n题目说明 $x \\in \\{0, 1, \\ldots, 100\\}$。在此范围内，唯一一个与6模101同余的整数是6。\n因此，初始内存盘度量值的唯一值是 $x=6$。", "answer": "$$\n\\boxed{6}\n$$", "id": "3679559"}, {"introduction": "在上一个练习的基础上，我们现在转向一个更真实的场景，探索度量顺序的重要性。这个练习 [@problem_id:3679592] 表明，PCR 的最终值不仅取决于启动了哪些组件，还严格依赖于它们的度量顺序。通过对比预期值与实际报告值，您将学会如何像一个安全分析师一样，从 PCR 的值中发现启动过程中的异常，例如组件加载顺序的改变。", "problem": "一个系统使用可信平台模块（TPM）实现度量启动。平台配置寄存器（PCR）的扩展操作由基本规则定义：从全零值 $PCR^{(0)} = 0^{256}$ 开始，每个新的度量摘要 $d$ 通过更新操作 $PCR \\leftarrow \\mathcal{H}(PCR \\,\\|\\, d)$ 被并入，其中 $\\mathcal{H}$ 是一个抗碰撞的密码学哈希函数（例如，安全哈希算法 256 位（SHA-256）），而 $\\|$ 表示串联。启动时度量的可信计算基（TCB）组件是三个软件组件 $A$、$B$ 和 $C$，清单（manifest）中按 $(A,B,C)$ 的顺序列出它们及相应的摘要：\n- $d_{A} = \\mathrm{a3c1d2e4f50617293b4c5d6e7f8091a2b3c4d5e6f718293a4b5c6d7e8f9012ab}$，\n- $d_{B} = \\mathrm{0f1e2d3c4b5a69788796a5b4c3d2e1f0ffeeddccbbaa99887766554433221100}$，\n- $d_{C} = \\mathrm{ffffffff00000000aaaaaaaa55555555cccccccc33333333dddddddd22222222}$。\n\n为了进行分析，我们提供了在两种相关部分顺序下的第一次和第二次扩展的预计算哈希链输出，以及在两种候选完整顺序下的第三次扩展结果：\n- $\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) = \\mathrm{1111111122222222333333334444444455555555666666667777777788888888}$，\n- $\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) = \\mathrm{0123456789abcdeffedcba98765432100123456789abcdeffedcba9876543210}$，\n- $\\mathcal{H}(0^{256} \\,\\|\\, d_{C}) = \\mathrm{abcdef0123456780abcdef0123456780abcdef0123456780abcdef0123456780}$，\n- $\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B}) = \\mathrm{2222222233333333444444445555555566666666777777778888888899999999}$，\n- $\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) \\,\\|\\, d_{A}) = \\mathrm{33333333444444445555555566666666777777778888888899999999aaaaaaaa}$。\n\n对这些链继续进行第三次度量，产生以下结果：\n- $\\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B}) \\,\\|\\, d_{C}) = \\mathrm{3adf1c0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba012}$，\n- $\\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) \\,\\|\\, d_{A}) \\,\\|\\, d_{C}) = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$。\n\n一份 TPM 报价（quote）报告了 $PCR_{0}$ 的证明值为\n$Q = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$。\n\n任务：\n1. 仅使用扩展规则 $PCR \\leftarrow \\mathcal{H}(PCR \\,\\|\\, d)$ 和提供的预计算结果，重建在遵循清单顺序 $(A,B,C)$ 的情况下的预期序列 $\\{PCR_{0}^{(1)}, PCR_{0}^{(2)}, PCR_{0}^{(3)}\\}$，并将最终的预期 $PCR_{0}^{(3)}$ 写成一个 256 位的十六进制字符串。\n2. 根据扩展操作的基本原理和给定数据，判断预期最终值与报价 $Q$ 之间的差异是否可以纯粹由组件顺序不同来解释。使用提供的预计算结果，确定一个与 $Q$ 一致的顺序，并解释为什么顺序在度量启动中至关重要。\n3. 通过计算预期最终 $PCR_{0}^{(3)}$（对于清单顺序 $(A,B,C)$）与报价 $Q$ 之间的汉明距离 $d_{H}$ 来量化差异。汉明距离 $d_{H}$ 是两个 256 位值在不同比特位的数量。仅提供 $d_{H}$ 的值作为最终数值答案。无需四舍五入。", "solution": "该问题要求对一个涉及可信平台模块（TPM）及其平台配置寄存器（PCRs）的度量启动过程进行三部分分析。该过程的核心是 PCR 扩展操作，定义为 $PCR \\leftarrow \\mathcal{H}(PCR \\,\\|\\, d)$，其中 $\\mathcal{H}$ 是一个密码学哈希函数，$PCR$ 是当前的寄存器值，$d$ 是新的度量摘要，$\\|$ 表示串联。我们被给予了初始状态 $PCR^{(0)} = 0^{256}$，三个组件的摘要 $d_A$、$d_B$、$d_C$，以及针对不同度量顺序的几个预计算哈希值。\n\n**任务1：重建预期的 PCR 序列**\n\n第一个任务是重建在按清单顺序 $(A, B, C)$ 度量组件时产生的 PCR 值序列 $\\{PCR_{0}^{(1)}, PCR_{0}^{(2)}, PCR_{0}^{(3)}\\}$。我们从 $PCR_{0}^{(0)} = 0^{256}$ 开始，并使用提供的预计算哈希值顺序应用扩展规则。\n\n1.  **第一次度量（组件 A）：** 第一次 PCR 更新度量组件 $A$。\n    $$PCR_{0}^{(1)} = \\mathcal{H}(PCR_{0}^{(0)} \\,\\|\\, d_{A}) = \\mathcal{H}(0^{256} \\,\\|\\, d_{A})$$\n    该值在问题陈述中已提供：\n    $$PCR_{0}^{(1)} = \\mathrm{1111111122222222333333334444444455555555666666667777777788888888}$$\n\n2.  **第二次度量（组件 B）：** 第二次更新用组件 $B$ 的摘要扩展新的 $PCR_{0}^{(1)}$。\n    $$PCR_{0}^{(2)} = \\mathcal{H}(PCR_{0}^{(1)} \\,\\|\\, d_{B}) = \\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B})$$\n    该值也已提供：\n    $$PCR_{0}^{(2)} = \\mathrm{2222222233333333444444445555555566666666777777778888888899999999}$$\n\n3.  **第三次度量（组件 C）：** 最后一次更新用组件 $C$ 的摘要扩展 $PCR_{0}^{(2)}$。这给出了最终的预期 PCR 值。\n    $$PCR_{0}^{(3)} = \\mathcal{H}(PCR_{0}^{(2)} \\,\\|\\, d_{C}) = \\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B}) \\,\\|\\, d_{C})$$\n    问题提供了序列 $(A, B, C)$ 的这个最终值：\n    $$PCR_{0}^{(3)} = \\mathrm{3adf1c0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba012}$$\n如果启动过程严格遵循清单顺序 $(A, B, C)$，这就是预期的最终 PCR 值。\n\n**任务2：差异和顺序分析**\n\n第二个任务是分析上面计算的预期最终 PCR 值与报价 $Q$ 之间的差异，其中 $Q$ 给出如下：\n$$Q = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$$\n将其与顺序 $(A, B, C)$ 的预期值 $PCR_{0}^{(3)}$ 进行比较，我们发现它们不相同。\n$PCR_{0}^{(3)} = \\mathrm{3adf...012}$\n$Q = \\mathrm{3bcf...092}$\n存在差异。问题询问这是否可以由不同的组件顺序来解释。提供的数据包括了度量顺序 $(B, A, C)$ 的最终 PCR 值：\n$$\\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) \\,\\|\\, d_{A}) \\,\\|\\, d_{C}) = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$$\n该值与报价 $Q$ 完全匹配。因此，这种差异可以解释为系统按 $(B, A, C)$ 的顺序度量了组件，而不是指定的清单顺序 $(A, B, C)$。\n\n顺序之所以重要，是度量启动安全保证的基础。PCR 扩展操作 $PCR_{new} = \\mathcal{H}(PCR_{old} \\,\\|\\, d)$ 是一个密码学链。在每一步中，前一个 PCR 值的整个状态都被用作计算下一个状态的哈希函数的输入的一部分。密码学哈希函数是确定性的，但对于其串联的输入而言是不可交换的。也就是说，对于两个不同的输入 $x$ 和 $y$，$\\mathcal{H}(x \\,\\|\\, y) \\neq \\mathcal{H}(y \\,\\|\\, x)$ 的可能性极高。因此，最终的 PCR 值不仅是被度量组件的唯一密码学摘要，也是它们被度量的精确顺序的摘要。验证者通过将最终的 PCR 报价与他们基于清单计算出的值进行比较，可以检测到启动过程中的任何偏差，包括组件的替换和启动顺序的改变。正是这一特性使得 PCR 能够充当启动过程中不可变且对顺序敏感的日志。\n\n**任务3：量化差异**\n\n最后一个任务是通过计算预期最终 PCR 值（对于顺序 $(A,B,C)$）与报价 $Q$ 之间的汉明距离 $d_H$ 来量化差异。汉明距离是两个二进制字符串在不同比特位的数量。\n\n需要比较的两个 256 位值是：\n- 预期值, $E = PCR_{0}^{(3)} = \\mathrm{3adf1c0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba012}$\n- 报价, $Q = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$\n\n我们逐个字符（每个字符代表一个 4 位的半字节）比较这些字符串，并对不同的半字节的汉明距离求和。\n\n- 位置 2（半字节 2）：$E$ 为 `a`，$Q$ 为 `b`。\n  - `a` (十六进制) = $1010_2$\n  - `b` (十六进制) = $1011_2$\n  - 按位异或：$1010_2 \\oplus 1011_2 = 0001_2$。置位（set bits）的数量（population count）是 1。距离 = 1。\n\n- 位置 3（半字节 3）：$E$ 为 `d`，$Q$ 为 `c`。\n  - `d` (十六进制) = $1101_2$\n  - `c` (十六进制) = $1100_2$\n  - 按位异或：$1101_2 \\oplus 1100_2 = 0001_2$。置位数量是 1。距离 = 1。\n\n- 位置 6（半字节 6）：$E$ 为 `c`，$Q$ 为 `d`。\n  - `c` (十六进制) = $1100_2$\n  - `d` (十六进制) = $1101_2$\n  - 按位异或：$1100_2 \\oplus 1101_2 = 0001_2$。置位数量是 1。距离 = 1。\n\n- 位置 63（半字节 63）：$E$ 为 `1`，$Q$ 为 `9`。\n  - `1` (十六进制) = $0001_2$\n  - `9` (十六进制) = $1001_2$\n  - 按位异或：$0001_2 \\oplus 1001_2 = 1000_2$。置位数量是 1。距离 = 1。\n\n所有其他位置（1, 4, 5, 7-62, 和 64）的十六进制字符都是相同的。总汉明距离是不同位置上距离的总和。\n\n$$d_H(E, Q) = 1 + 1 + 1 + 1 = 4$$\n\n预期和报价的 PCR 值之间的总汉明距离为 4。", "answer": "$$\n\\boxed{4}\n$$", "id": "3679592"}, {"introduction": "掌握了 PCR 机制后，我们将视野扩展到整个系统的安全架构。这个案例研究 [@problem_id:3679582] 探讨了一个常见但关键的安全漏洞：即使安全启动成功验证了内核，不安全的内核配置仍然可能破坏整个信任链。通过分析这个攻击场景，您将理解为什么建立一个从固件到正在运行的操作系统的端到端信任链是至关重要的，以及如何加固系统以防范此类威胁。", "problem": "一个工作站配置为启用统一可扩展固件接口 (UEFI) Secure Boot。平台密钥 ($PK$) 和签名数据库 ($db$) 包含操作系统供应商的证书。启动流程为固件 $\\rightarrow$ 第一阶段加载程序 $\\rightarrow$ 引导加载程序 $\\rightarrow$ 内核映像 $K$，其中每个操作系统前组件都由有效签名授权。内核 $K$ 在启动时被合法签名和验证。内核配置为允许基于设备别名自动加载内核模块，并允许加载未签名的模块。系统中存在一个可信平台模块 (TPM)，但没有配置完整性度量架构 (IMA) 策略，也没有将任何密钥密封到平台配置寄存器 (PCR) 值。未使用全盘加密。\n\n一个具有短暂物理访问权限的攻击者离线修改根文件系统，植入一个与自动加载别名匹配的未签名内核模块 $M$，并确保相应的设备在启动时存在，从而导致内核自动请求并加载 $M$。\n\n仅使用以下基本定义：\n- 可信计算基 (TCB) 的定义：为了安全必须信任的所有组件的集合；任何一个组件的妥协都可能违反系统的安全策略。\n- UEFI Secure Boot 的定义：通过在控制权转移前验证数字签名，强制只执行经授权、已签名的操作系统前组件。\n- 使用可信平台模块 (TPM) 的度量启动的定义：通过扩展操作 $PCR_i \\leftarrow H(PCR_i \\parallel m)$，使用单向压缩函数 $H(\\cdot)$ 将组件和事件顺序地哈希到 PCR 中；度量本身不强制执行策略，但与密封或评估策略结合使用时，能够实现检测和有条件的秘密释放。\n\n推理在上述条件下机器启动时会发生什么，并选择所有正确的陈述。重点关注 Secure Boot 如何对 $M$ 做出反应，对可信计算基的影响，以及必须锁定哪些内容才能恢复端到端的代码完整性。\n\nA. 因为 UEFI Secure Boot 已启用，且攻击者向文件系统中添加了一个未签名的内核模块 $M$，所以固件将拒绝启动。系统无需任何进一步更改即受到保护。\n\nB. UEFI Secure Boot 将成功验证已签名的内核 $K$ 并完成启动。如果内核配置为允许，它随后可能会加载未签名的 $M$，从而将可信计算基扩展到包含未经检验的代码，并破坏了超越 $K$ 的信任链。为了锁定系统，需要在 Secure Boot 激活时要求内核内模块签名验证和锁定（例如，强制执行 `CONFIG_MODULE_SIG_FORCE` 和内核锁定），或禁用未签名模块的自动加载。\n\nC. 度量启动将阻止 $M$ 的加载，因为当 $M$ 存在时 TPM PCR 会发生变化，所以不需要额外的防御措施。\n\nD. 将 $M$ 的哈希或证书添加到 UEFI 签名数据库 $db$ 将导致 Secure Boot 将 $M$ 视为已授权，从而在不更改内核模块加载策略的情况下防止此攻击。\n\nE. 在“评估”(appraise)策略中使用完整性度量架构 (IMA) 来要求内核模块具有有效签名，并将关键秘密（例如，磁盘解密密钥）密封到特定的 PCR 值，可确保离线篡改（如添加 $M$）要么导致模块加载失败，要么阻止解封。这与 Secure Boot 对 $K$ 的验证相结合，恢复了进入运行中内核代码路径的端到端信任链。\n\n选择所有适用的选项。", "solution": "首先将验证问题陈述的科学性和逻辑完整性。\n\n### 第一步：提取已知条件\n\n- 系统配置：一个工作站，启用了统一可扩展固件接口 (UEFI) Secure Boot。\n- 加密材料：平台密钥 ($PK$) 和签名数据库 ($db$) 包含操作系统供应商的证书。\n- 启动序列：固件 $\\rightarrow$ 第一阶段加载程序 $\\rightarrow$ 引导加载程序 $\\rightarrow$ 内核映像 $K$。\n- 操作系统前完整性：启动序列中内核之前的每个组件都由有效签名授权。\n- 内核完整性：内核映像 $K$ 在启动时被合法签名和验证。\n- 内核配置：\n    - 启用基于设备别名的内核模块自动加载。\n    - 允许加载未签名的内核模块。\n- 可信平台模块 (TPM) 配置：\n    - 存在 TPM。\n    - 未配置完整性度量架构 (IMA) 策略。\n    - 没有密钥被密封到平台配置寄存器 (PCR) 值。\n- 磁盘加密：未使用全盘加密。\n- 攻击者行为：具有短暂物理访问权限的攻击者离线修改根文件系统。\n- 攻击载荷：一个未签名的内核模块 $M$ 被放置在文件系统中，匹配一个在启动时存在的设备的自动加载别名。\n- 基本定义：\n    - 可信计算基 (TCB) 的定义：其妥协可能违反系统安全策略的所有组件的集合。\n    - UEFI Secure Boot 的定义：在执行前验证操作系统前组件的数字签名。\n    - 使用 TPM 的度量启动的定义：通过 $PCR_i \\leftarrow H(PCR_i \\parallel m)$ 将组件顺序地哈希到 PCR 中，这提供了记录，但本身不强制执行策略。\n\n### 第二步：使用提取的已知条件进行验证\n\n对问题陈述的有效性进行分析。\n\n- **科学依据**：该问题在计算机和操作系统安全原则方面有充分的依据。UEFI Secure Boot、可信平台模块 (TPM)、度量启动、内核模块加载和可信计算基 (TCB) 的概念是该领域的标准主题。所描述的场景——在已验证的内核和随后加载的未验证代码之间存在信任链缺口——是一个经典且现实的安全挑战。\n- **定义明确**：该问题定义明确。系统的初始状态已清晰定义，攻击者的行为是具体的，问题要求基于所提供的定义对系统状态和潜在的缓解措施进行逻辑推导。可以得出一组唯一的正确结论。\n- **客观性**：语言精确且技术化。它避免了主观或模糊的术语。\n- **完整性**：问题提供了所有必要的信息。它明确说明了 Secure Boot 的状态、内核关于模块签名的配置以及 TPM 的配置（存在但未用于强制执行）。这种详细程度足以推理出结果。\n- **一致性**：没有内部矛盾。组件及其配置的描述是一致的。\n\n### 第三步：结论与行动\n\n该问题是有效的。它描述了系统安全中一个连贯且可分析的场景。可以进行解决方案推导。\n\n### 解决方案推导\n\n分析将遵循启动过程以及内核的后续操作，基于所提供的定义和系统状态。\n\n1.  **UEFI Secure Boot 阶段**：机器上电。固件作为验证的信任根，开始 Secure Boot 过程。它使用其签名数据库 ($db$) 中的证书验证第一阶段加载程序的签名。签名有效，因此控制权传递给加载程序。加载程序接着验证引导加载程序，然后引导加载程序验证内核映像 $K$。由于所有这些组件都已签名并授权，UEFI Secure Boot 成功完成其任务，并将控制权传递给内核 $K$。在此阶段，系统启动没有任何错误。UEFI Secure Boot 不知道根文件系统的内容，例如恶意模块 $M$，因为其范围仅限于验证它直接加载的组件（EFI 二进制文件）。\n\n2.  **内核执行阶段**：已验证的内核 $K$ 开始执行。其任务之一是发现硬件并加载必要的驱动程序，这些驱动程序通常实现为内核模块。问题陈述中说明，内核配置为自动加载模块并允许加载*未签名*的模块。当内核检测到一个其驱动程序别名与恶意模块 $M$ 匹配的设备时，它将尝试从文件系统加载 $M$。因为配置明确允许未签名的模块，所以内核不执行签名检查。加载操作成功，模块 $M$ 中的代码被加载到内核空间并以最高系统权限执行。\n\n3.  **对可信计算基 (TCB) 的影响**：TCB 是必须信任的所有硬件和软件组件的集合。最初，TCB 由 Secure Boot 固件、已验证的加载程序和已验证的内核 $K$ 组成。这建立了一条“信任链”。然而，当内核 $K$ 加载未经验证的恶意模块 $M$ 时，$M$ 的代码成为运行中内核的一部分。因此，TCB 被扩展以包含 $M$。由于 $M$ 是不受信任的，它被包含在 TCB 中意味着系统的安全策略被违反。由 Secure Boot 建立的信任链在内核从执行其自身已验证的代码过渡到执行来自 $M$ 的未验证代码时被破坏。\n\n4.  **度量启动/TPM 的作用**：问题陈述中说明存在一个 TPM，但没有配置 IMA 策略，也没有密封任何秘密。根据定义，度量启动是向 TPM 的 PCR 中记录组件的度量（哈希）的过程。虽然固件和引导加载程序可能会将自身和内核度量到 PCR 中，但这种度量行为仅仅是一种日志记录形式。没有相应的强制执行机制（IMA“评估”策略、远程证明或本地解封秘密），PCR 值的变化对系统的操作没有影响。启动过程不会被中止，$M$ 的加载也不会被阻止。仅度量提供了检测能力，但没有提供预防能力。\n\n### 逐项分析\n\n**A. 因为 UEFI Secure Boot 已启用，且攻击者向文件系统中添加了一个未签名的内核模块 $M$，所以固件将拒绝启动。系统无需任何进一步更改即受到保护。**\n\n- **分析**：这个说法是不正确的。UEFI Secure Boot 验证它作为 EFI 二进制文件加载的操作系统前组件（引导加载程序、内核）。它不检查操作系统稍后将使用的文件系统内容。恶意模块 $M$ 不是由固件加载的，而是由内核加载的，这发生在 Secure Boot 过程成功完成并转移控制权之后很久。因此，固件将成功启动已签名的内核 $K$，并且不会检测或阻止 $M$ 的存在。\n- **结论**：不正确。\n\n**B. UEFI Secure Boot 将成功验证已签名的内核 $K$ 并完成启动。如果内核配置为允许，它随后可能会加载未签名的 $M$，从而将可信计算基扩展到包含未经检验的代码，并破坏了超越 $K$ 的信任链。为了锁定系统，需要在 Secure Boot 激活时要求内核内模块签名验证和锁定（例如，强制执行 `CONFIG_MODULE_SIG_FORCE` 和内核锁定），或禁用未签名模块的自动加载。**\n\n- **分析**：这个说法是对情况的精确和准确描述。它正确地指出 Secure Boot 的责任在内核验证后结束。它正确地解释了内核的不安全配置是允许加载未签名模块 $M$ 的漏洞，从而用不受信任的代码扩展了 TCB。最后，它提出了正确且相关的对策：强制执行内核模块签名验证（例如，通过内核配置选项 `CONFIG_MODULE_SIG_FORCE`）和使用通常随 Secure Boot 自动激活的内核锁定功能，以防止此类不安全操作。禁用模块自动加载也是一个有效但可能灵活性较低的缓解措施。\n- **结论**：正确。\n\n**C. 度量启动将阻止 $M$ 的加载，因为当 $M$ 存在时 TPM PCR 会发生变化，所以不需要额外的防御措施。**\n\n- **分析**：这个说法是不正确的。它将度量与强制执行混为一谈。如问题中所定义，度量启动只是将加密哈希记录在 PCR 中。问题明确指出没有使用强制执行机制，如 IMA 策略或密钥密封。因此，虽然加载 $M$ *会*改变 PCR 值（如果一个 IMA 度量策略是激活的），但在所描述的配置中，这种变化不会触发任何阻止操作。系统不会“检查”PCR 来决定是否启动或加载模块。\n- **结论**：不正确。\n\n**D. 将 $M$ 的哈希或证书添加到 UEFI 签名数据库 $db$ 将导致 Secure Boot 将 $M$ 视为已授权，从而在不更改内核模块加载策略的情况下防止此攻击。**\n\n- **分析**：这个说法是不正确的。UEFI 签名数据库 ($db$) 被 UEFI 固件用来验证 EFI 应用程序（如引导加载程序和操作系统内核本身）。操作系统内核在加载自己的模块时不会查阅它。内核维护自己独立的密钥环和验证模块签名的机制。此外，这个问题中的内核被配置为*根本不检查签名*，所以即使 $M$ 的签名在正确的内核密钥环中，它也会被忽略。将哈希放入 UEFI $db$ 与内核的模块加载器无关。\n- **结论**：不正确。\n\n**E. 在“评估”(appraise)策略中使用完整性度量架构 (IMA) 来要求内核模块具有有效签名，并将关键秘密（例如，磁盘解密密钥）密封到特定的 PCR 值，可确保离线篡改（如添加 $M$）要么导致模块加载失败，要么阻止解封。这与 Secure Boot 对 $K$ 的验证相结合，恢复了进入运行中内核代码路径的端到端信任链。**\n\n- **分析**：这个说法正确地描述了一个强大的解决方案，它扩展了由 Secure Boot 建立的信任链。可以配置一个 IMA“评估”策略来在运行时强制执行规则，例如要求所有加载的可执行内容（包括内核模块）都具有有效的数字签名。这将直接阻止未签名的模块 $M$ 被加载。关于密封秘密的部分是 TPM 和度量启动的另一个有效用途；如果系统的状态（包括新模块 $M$）偏离了“黄金”PCR 值，像磁盘加密密钥这样的秘密将不会被解封，从而有效地阻止受损系统访问敏感数据。这种将 Secure Boot 用于操作系统前完整性和 IMA/TPM 用于运行时完整性的组合，确实创建了一条端到端的信任链。\n- **结论**：正确。", "answer": "$$\\boxed{\\text{B, E}}$$", "id": "3679582"}]}