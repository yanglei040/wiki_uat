{"hands_on_practices": [{"introduction": "整数溢出是软件中最常见也最危险的漏洞之一，它可能导致资源滥用甚至更严重的安全问题。本练习将通过一个资源计数的假想场景，让你直观地对比一个传统的32位回绕计数器和一个更安全的64位饱和计数器。通过计算触发两种不同行为所需的事件次数，你将深刻理解整数溢出的风险以及如何通过改进计数器设计来有效缓解这种风险 [@problem_id:3687968]。", "problem": "在一个操作系统的资源核算中，假设系统为遗留代码路径使用一个无符号 $32$-位计数器来跟踪以微秒为单位的累积中央处理器（CPU）时间。在每次进程创建事件（例如，fork）中，该进程执行的工作会消耗固定的 CPU 时间，其值为 $u$ 微秒，并且计数器会增加此数值。由于该计数器是无符号且为 $32$ 位宽，它遵循模 $2^{32}$ 的算术运算，因此在超过 $2^{32}-1$ 时会回绕到零。如果计数器接近其最大值，攻击者可以尝试利用回绕来规避基于阈值的强制执行。\n\n作为一种缓解措施，考虑一种设计，它使用一个 $64$-位单调饱和计数器，该计数器在一个可配置的警报阈值 $\\theta$ 处饱和，并在累积 CPU 使用量首次达到 $\\theta$ 时精确触发一次。具体来说，$64$-位计数器 $S$ 从 $S_0=0$ 开始，并在每次 fork 时按 $S_{k+1}=\\min(\\theta, S_k+u)$ 更新；警报在使得 $S_n=\\theta$ 的第一个步骤 $n$ 触发。\n\n假设以下具体参数值：\n- 每次 fork 的 CPU 使用量为 $u=123{,}457$ 微秒。\n- $32$-位计数器的当前存储值为 $C_0=c_0=3{,}500{,}000{,}000$ 微秒。\n- $64$-位饱和计数器的警报阈值为 $\\theta=600{,}000{,}000$ 微秒。\n\n定义 $n_{\\text{wrap}}$ 为最小的非负整数 $n$，使得 $32$-位计数器在模 $2^{32}$ 加法下从 $C_0$ 开始经过 $n$ 次 fork 更新后至少回绕一次。定义 $n_{\\text{alert}}$ 为最小的非负整数 $n$，使得 $64$-位饱和计数器从 $0$ 开始，在应用 $n$ 次大小为 $u$ 的更新后达到警报阈值 $\\theta$。计算单个量\n$\nD = n_{\\text{wrap}} - n_{\\text{alert}}.\n$\n请以 fork 次数的整数形式提供您的答案。无需四舍五入。", "solution": "该问题已经过验证，并被确定为计算科学领域中一个有效且适定的问题。它在科学上基于操作系统中常见的整数算术和计数器行为原理，内容自洽，提供了所有必要数据，并且表述客观。因此，我们可以开始求解。\n\n问题要求计算量 $D = n_{\\text{wrap}} - n_{\\text{alert}}$，它是在遗留的 $32$ 位系统中触发计数器回绕所需的 fork 事件次数与在经过缓解措施的 $64$ 位系统中触发警报所需的事件次数之差。\n\n首先，我们分析 $32$ 位无符号计数器。一个无符号 $32$ 位整数计数器的容量由其位宽决定。它可以表示的值范围从 $0$ 到 $2^{32}-1$。状态总数为 $2^{32}$。算术运算以模 $2^{32}$ 进行。计数器的最大值是 $2^{32}-1$，其总范围对应于数值 $2^{32}$。\n$2^{32}$ 的值是 $4,294,967,296$。\n\n问题将 $n_{\\text{wrap}}$ 定义为使得 $32$ 位计数器至少回绕一次的最小非负整数 $n$。该计数器的初始值给定为 $C_0 = c_0 = 3,500,000,000$。每次 fork 事件增加 $u = 123,457$ 微秒的 CPU 使用量。经过 $n$ 次 fork 后，总累积时间为 $n \\cdot u$。计数器的新概念值为 $C_0 + n \\cdot u$。\n当这个概念值达到或超过模数 $2^{32}$ 时，就会发生回绕。因此，我们必须找到满足以下不等式的最小非负整数 $n$：\n$$c_0 + n \\cdot u \\ge 2^{32}$$\n重新整理不等式以求解 $n$：\n$$n \\cdot u \\ge 2^{32} - c_0$$\n$$n \\ge \\frac{2^{32} - c_0}{u}$$\n由于 $n$ 必须是整数，$n_{\\text{wrap}}$ 是满足此条件的最小整数，可通过对右侧表达式取上取整（ceiling）得到。\n$$n_{\\text{wrap}} = \\left\\lceil \\frac{2^{32} - c_0}{u} \\right\\rceil$$\n代入给定值：$c_0 = 3,500,000,000$ 和 $u = 123,457$。\n$$n_{\\text{wrap}} = \\left\\lceil \\frac{4,294,967,296 - 3,500,000,000}{123,457} \\right\\rceil$$\n$$n_{\\text{wrap}} = \\left\\lceil \\frac{794,967,296}{123,457} \\right\\rceil$$\n进行除法运算：\n$$\\frac{794,967,296}{123,457} \\approx 6440.003386$$\n该值的上取整是下一个整数：\n$$n_{\\text{wrap}} = 6441$$\n\n接下来，我们分析 $64$ 位饱和计数器。该计数器从 $S_0 = 0$ 开始，并根据规则 $S_{k+1} = \\min(\\theta, S_k + u)$ 更新，其中 $\\theta = 600,000,000$ 是警报阈值。\n量 $n_{\\text{alert}}$ 被定义为使计数器达到阈值 $\\theta$ 的最小非负整数 $n$。在饱和之前，经过 $n$ 步后计数器的值就是增量的累积和，即 $n \\cdot u$。警报在累积和首次大于或等于 $\\theta$ 的步骤 $n$ 触发。这给出了以下不等式：\n$$n \\cdot u \\ge \\theta$$\n求解 $n$：\n$$n \\ge \\frac{\\theta}{u}$$\n如前所述，由于 $n$ 必须是整数，$n_{\\text{alert}}$ 是满足此条件的最小整数，可通过取上取整得到：\n$$n_{\\text{alert}} = \\left\\lceil \\frac{\\theta}{u} \\right\\rceil$$\n代入给定值：$\\theta = 600,000,000$ 和 $u = 123,457$。\n$$n_{\\text{alert}} = \\left\\lceil \\frac{600,000,000}{123,457} \\right\\rceil$$\n进行除法运算：\n$$\\frac{600,000,000}{123,457} \\approx 4860.103536$$\n该值的上取整是下一个整数：\n$$n_{\\text{alert}} = 4861$$\n\n最后，我们计算所需的量 $D = n_{\\text{wrap}} - n_{\\text{alert}}$。\n使用我们为 $n_{\\text{wrap}}$ 和 $n_{\\text{alert}}$ 计算出的值：\n$$D = 6441 - 4861$$\n$$D = 1580$$\n该结果表示在两个计数器系统中触发各自事件所需的 fork 次数之差。", "answer": "$$\\boxed{1580}$$", "id": "3687968"}, {"introduction": "现代操作系统不再依赖单一的防御措施，而是采用多层、纵深的防御策略。地址空间布局随机化（ASLR）和栈金丝雀（stack canaries）就是其中的关键技术，它们通过引入随机性来大幅增加攻击者成功利用内存错误的难度。本练习要求你从基本概率论出发，建立一个数学模型来量化这些防御机制共同作用下的攻击成功率，从而将抽象的安全理念转化为精确的数学表达 [@problem_id:3687953]。", "problem": "一个操作系统进程采用了地址空间布局随机化（ASLR）、非执行位（NX）和栈金丝雀（stack canaries）。一个攻击者试图在该系统上运行时，通过覆盖栈上的返回地址来进行返回导向libc（ret2libc）的控制流劫持攻击。要求您仅根据以下基本事实和定义，并且不使用任何预先推导的攻击概率公式，来为攻击者最终成功的残余概率建模。\n\n基本依据和假设：\n1. 在ASLR下，共享库的基地址是从一个包含 $2^{H}$ 个可能基址槽的离散集合中均匀随机选择的，其中 $H$ 是熵的位数。由于实践中库地址的重用，在多次运行中，这些槽中只有一部分（比例为 $r \\in (0,1]$）被实际使用，并且这些被使用的槽以近似均匀的概率被使用。因此，有效的不重复基地址结果数为 $r \\cdot 2^{H}$。\n2. 非执行位（NX）阻止攻击者提供的代码注入到数据段；因此，控制流劫持必须重用已加载库中的现有代码（例如，函数入口或短的可重用序列）。攻击者知道 $K$ 个有效的可重用入口点（例如，当前加载的库中 $K$ 个不同的函数入口点），这些入口点在其库内的相对偏移量是已知且固定的。\n3. 栈金丝雀是一个均匀随机的 $b$ 位值，每次进程启动时都会独立改变。为了在函数尾声避免被检测，攻击者必须精确猜中该金丝雀；在没有信息泄漏的情况下，单次尝试猜中的成功概率为 $2^{-b}$。\n4. 每次攻击尝试都是针对一个新重启的进程，因此金丝雀和库基地址的随机选择在多次尝试之间是独立的。攻击者进行 $T \\in \\mathbb{N}$ 次独立尝试，每次都将一个返回地址设置为其选择的单个绝对值。\n5. 在一部分比例为 $q \\in [0,1]$ 的部署中，应用程序二进制接口（ABI）强制要求使用控制流强制技术（CET）：返回操作会与硬件影子栈进行核对，并且间接分支目标必须以一个有效的控制流着陆序列开始。在此类强制执行CET的部署中，返回地址覆盖不会导致攻击者控制的重定向。\n6. 在 $K \\le r \\cdot 2^{H}$ 的条件下进行分析，以确保概率值保持在 $[0,1]$ 区间内，无需进一步截断，并如上所述假设独立性。\n\n任务：\na) 仅从上述定义和独立伯努利试验的基本概率法则出发，推导出一个封闭形式的表达式 $P(H,b,K,r,T,q)$，表示攻击者在 $T$ 次尝试中至少成功进行一次 ret2libc 攻击的概率，该表达式用 $H$、$b$、$K$、$r$、$T$ 和 $q$ 表示。\nb) 提出一个强制执行CET的最小ABI规则，使得返回地址覆盖不能将控制权转移到任意位置，并定性解释此规则如何改变您在(a)部分构建的模型。您在(a)部分的推导应已包含如上定义的参数 $q$。\n\n您最终报告的答案必须是(a)部分得到的 $P(H,b,K,r,T,q)$ 的单一简化封闭形式表达式。不要包含单位。不要提供不等式。不要计算数值近似值。仅以单个解析表达式的形式表达最终答案。", "solution": "该问题要求推导在一组特定安全缓解措施下，控制流劫持攻击成功的概率，并对其中一种缓解措施进行定性讨论。问题陈述具有科学依据，表述清晰，且内部一致。它使用标准概率论，对计算机安全领域一个现实（尽管简化了）的场景进行建模。所有术语都有明确定义，假设也已明确说明。因此，该问题被认为是有效的。\n\na) 至少一次成功攻击的概率 $P(H,b,K,r,T,q)$ 的推导。\n\n设 $S$ 为单次尝试中攻击成功的事件。一次成功的攻击需要三个独立条件同时发生：\n1.  系统范围的部署不能是强制要求控制流强制技术（CET）的那部分（比例为 $q$）。设该事件为 $E_{noCET}$。其概率为 $P(E_{noCET}) = 1 - q$。如果CET处于活动状态，则成功概率为 $0$。\n2.  攻击者必须正确猜中 $b$ 位的栈金丝雀。设该事件为 $E_{canary}$。由于金丝雀是一个均匀随机的 $b$ 位值，单次尝试猜中的概率为 $P(E_{canary}) = 2^{-b}$。\n3.  攻击者必须成功猜中一个对应于有效的、可重用代码入口点的地址。设该事件为 $E_{addr}$。\n\n为了确定 $P(E_{addr})$，我们分析地址空间布局随机化（ASLR）的效果。共享库的基地址是从一个有效大小为 $N_{eff} = r \\cdot 2^{H}$ 的可能地址集合中选择的，其中 $r$ 是实现比例， $H$ 是熵的位数。攻击者知道 $K$ 个有用的函数入口点（gadgets）在其各自库内的相对偏移量。\n\n在单次尝试中，攻击者用一个选定的绝对地址 $A_{guess}$ 覆盖栈上的一个返回地址。要使这次猜测成功， $A_{guess}$ 必须等于 $K$ 个gadget中某一个的绝对地址。gadget $k$ 的绝对地址是 $B + \\delta_k$，其中 $B$ 是随机化的库基地址， $\\delta_k$ 是gadget $k$ 的已知固定偏移量。\n\n因此，要使攻击者选择的地址 $A_{guess}$ 正确，未知的库基地址 $B$ 必须取值为 $B = A_{guess} - \\delta_k$（对于某个 $k \\in \\{1, 2, ..., K\\}$）。攻击者实际上是在赌随机选择的基地址 $B$ 将是集合 $\\{A_{guess} - \\delta_1, A_{guess} - \\delta_2, ..., A_{guess} - \\delta_K\\}$ 中的 $K$ 个值之一。\n\n由于库基地址是从 $r \\cdot 2^{H}$ 种可能性中均匀随机选择的，它匹配这 $K$ 个特定目标值之一的概率是目标数量除以总可能性数量。问题说明了 $K \\le r \\cdot 2^{H}$，确保了不需要考虑重复计数或其他复杂情况。\n$$\nP(E_{addr}) = \\frac{K}{r \\cdot 2^{H}}\n$$\n当且仅当所有三个独立事件（$E_{noCET}$、$E_{canary}$ 和 $E_{addr}$）都发生时，单次尝试才算成功。单次尝试的成功概率 $p_{single}$ 是它们概率的乘积：\n$$\np_{single} = P(S) = P(E_{noCET}) \\cdot P(E_{canary}) \\cdot P(E_{addr})\n$$\n$$\np_{single} = (1 - q) \\cdot 2^{-b} \\cdot \\frac{K}{r \\cdot 2^{H}}\n$$\n$$\np_{single} = \\frac{K(1 - q)}{r \\cdot 2^{H} \\cdot 2^{b}} = \\frac{K(1 - q)}{r \\cdot 2^{H+b}}\n$$\n攻击者进行 $T$ 次独立尝试。问题要求计算这 $T$ 次尝试中至少有一次成功的概率。这等于所有 $T$ 次尝试都失败这一事件的补集。设 $F$ 为单次尝试失败的事件。\n$$\nP(F) = 1 - p_{single} = 1 - \\frac{K(1 - q)}{r \\cdot 2^{H+b}}\n$$\n由于每次尝试都是独立的，所有 $T$ 次尝试都失败的概率是 $(P(F))^T$。\n$$\nP(\\text{all T attempts fail}) = \\left(1 - \\frac{K(1 - q)}{r \\cdot 2^{H+b}}\\right)^T\n$$\n因此，至少有一次成功的概率 $P(H,b,K,r,T,q)$ 是：\n$$\nP(H,b,K,r,T,q) = 1 - P(\\text{all T attempts fail})\n$$\n$$\nP(H,b,K,r,T,q) = 1 - \\left(1 - \\frac{K(1 - q)}{r \\cdot 2^{H+b}}\\right)^T\n$$\n这就是至少一次成功攻击概率的最终封闭形式表达式。\n\nb) CET的最小ABI规则及定性解释。\n\n一个用于强制执行CET并挫败返回地址覆盖攻击的最小应用程序二进制接口（ABI）规则是：**ABI必须强制要求所有函数调用和返回都使用硬件管理的影子栈。**\n\n定性解释：\n该规则要求编译器生成利用CPU影子栈特性的代码。其机制如下：\n1.  在执行 `CALL` 指令时：CPU将返回地址同时压入常规数据栈（易受缓冲区溢出攻击）和一个独立的、用户空间代码不可写的受保护影子栈。\n2.  在执行 `RET` 指令时：CPU从常规数据栈中弹出返回地址。然后，它从影子栈中弹出相应的地址并进行比较。\n\n如果攻击者覆盖了常规栈上的返回地址，其值将与存储在影子栈上的原始、受保护的值不匹配。在执行 `RET` 指令时，CPU会检测到这种不匹配，并触发一个控制保护故障，导致进程终止。\n\n这种机制直接改变了返回地址覆盖攻击的结果。没有CET时，成功的覆盖会将控制流重定向到攻击者选择的地址。有了CET，同样的覆盖会导致检测到完整性违规并终止进程。攻击在能够劫持控制流之前就被化解了。\n\n在(a)部分模型的背景下，这个规则是参数 $q$ 存在的根本原因。在那部分比例为 $q$ 的、强制执行此ABI规则的部署中，`ret2libc` 类型的返回地址覆盖攻击的成功概率为 $0$。攻击无法成功，不是因为地址错误，而是因为使用被覆盖地址这一行为本身被检测到并被阻止。模型通过使总成功概率与 $(1-q)$ 成正比来正确地捕捉到这一点，$(1-q)$ 是系统属于*没有*此保护性ABI规则的部署的概率。因此，所提出的规则为推导出的概率公式的结构提供了依据。", "answer": "$$\n\\boxed{1 - \\left(1 - \\frac{K(1 - q)}{r \\cdot 2^{H+b}}\\right)^T}\n$$", "id": "3687953"}, {"introduction": "除了内存错误，并发执行引入的竞争条件是另一大类严重的安全漏洞，其中“检查时-使用时”（Time-Of-Check To Time-Of-Use, TOCTTOU）漏洞尤为典型。本练习将引导你分析一种旨在消除TOCTTOU漏洞的授权机制——基于令牌的访问控制。你需要评估该设计的安全性、权衡其利弊，并识别其安全运行所必需的关键前提，从而锻炼你作为系统设计者的批判性思维能力 [@problem_id:3687966]。", "problem": "考虑一个多用户操作系统，其中设备 $D$ 的设备驱动程序使用访问控制列表（ACL）来授权操作。一个进程 $P$ 在时间 $t_0$ 对设备 $D$ 执行 `open` 系统调用，并在稍后的时间 $t_1, t_2, \\ldots$ 发出输入/输出（I/O）操作。管理员可以随时修改 ACL，包括在 $t_0$ 和后续的 I/O 操作之间的时间段。当授权检查和后续使用在存在对共享授权状态的并发更改时非原子地进行时，就会出现“检查时-使用时”（TOCTTOU）漏洞。\n\n请你从第一性原理出发，对一项提议的缓解措施进行推理：当进程 $P$ 在时间 $t_0$ 打开设备 $D$ 时，内核颁发一个与该 `open` 操作绑定的原子权限令牌 $T$。该令牌 $T$ 与进程 $P$ 的身份、目标设备 $D$ 以及在 $t_0$ 时由 ACL 决定的一组权限 $R$ 相关联。对于之后在 $D$ 上的每个 I/O 操作，$P$ 都向内核出示 $T$，内核在执行设备操作的同一个系统调用内验证 $T$ 并相应地授权该操作。\n\n在所描述的威胁场景下，选择所有关于此设计的安全属性和权衡的正确陈述。\n\nA. 如果 $T$ 是不可伪造的，并且在执行设备操作前由内核立即验证，期间不将控制权交还给非受信代码，那么对于那些需要 $T$ 的操作，授权和使用之间的 TOCTTOU 时间窗口就被消除了。\n\nB. 令牌方法无法在不重新引入 TOCTTOU 的情况下支持权限撤销，因此绝对劣于在每个设备操作的整个持续时间内对 ACL 加锁的方法。\n\nC. 引入一个按设备的撤销版本计数器 $v$，内核在每次操作时都将该计数器与嵌入在 $T$ 中的版本进行比较，这种方法支持即时撤销，同时将检查和使用保持在单个原子内核路径内，其代价是每次操作增加一次额外的检查。\n\nD. 因为 $T$ 是在打开时绑定的，所以任何后续授予 $P$ 额外权限的 ACL 更改，在 $P$ 使用 $T$ 时都会自动反映出来，这保留了最小权限原则。\n\nE. 如果 $T$ 存储在用户空间并在每次调用时提供，那么在没有内核强制的完整性机制使其不可伪造的情况下，恶意进程可能会修改 $T$ 来提升权限；因此，$T$ 的不可伪造性和完整性是确保该设计安全的必要条件。\n\n选择所有适用的选项。", "solution": "步骤 1：提取已知条件\n- 系统：多用户操作系统。\n- 设备：$D$。\n- 授权：设备 $D$ 的设备驱动程序使用访问控制列表（ACL）。\n- 进程：$P$。\n- 事件：\n    - 在时间 $t_0$，进程 $P$ 对 $D$ 执行 `open` 系统调用。\n    - 在时间 $t_1, t_2, \\ldots$，进程 $P$ 发出输入/输出（I/O）操作。\n- 并发性：管理员可以随时修改 ACL。\n- 漏洞背景：“检查时-使用时”（TOCTTOU）漏洞源于对共享授权状态的非原子性检查和使用操作。\n- 提议的缓解措施：\n    - 在时间 $t_0$，内核颁发一个与 `open` 操作绑定的原子权限令牌 $T$。\n    - 令牌 $T$ 与以下内容相关联：$P$ 的身份、目标设备 $D$ 以及在 $t_0$ 时由 ACL 决定的一组权限 $R$。\n    - 对于后续在 $D$ 上的 I/O 操作，$P$ 向内核出示 $T$。\n    - 内核在执行设备操作的同一个系统调用内验证 $T$ 并授权该操作。\n\n步骤 2：使用提取的已知条件进行验证\n- **科学性（关键）**：该问题坚实地建立在操作系统安全的既定概念之上，包括 ACL、系统调用（`open`）、竞争条件，特别是 TOCTTOU 类漏洞。所提议的基于令牌的缓解措施是计算机安全中的一种标准模式，通常称为能力或持有者令牌模型。该场景在科学上是合理的且现实的。\n- **定义明确**：该问题对一个安全机制提供了清晰而详细的描述。它要求评估此设计的特定属性和权衡。该问题的结构良好，可以在选项中找到一组明确的正确答案。\n- **客观性（关键）**：该问题使用精确、无歧义的技术语言进行描述（例如，“原子权限令牌”、“绑定到 open 操作”、“在同一个系统调用内”）。它不包含主观或基于意见的陈述。\n\n步骤 3：结论与行动\n问题陈述是有效的。它在科学上是合理的、定义明确的、客观的，并且对于所需分析来说是完整的。\n\n问题描述了从直接的 ACL 检查模型到用于 `open` 调用后的 I/O 操作的基于令牌（或基于能力）的授权模型的转变。在 `open` 时刻 ($t_0$)，进程 $P$ 对设备 $D$ 的权限 $R$ 基于 ACL 进行评估，并“冻结”到一个令牌 $T$ 中。对于后续操作，持有有效的令牌 $T$ 就被授予了权限 $R$。关键的安全特性是检查（验证 $T$）和使用（执行 I/O）是在单次内核模式转换中原子地完成的。我们现在将基于这些原则来分析每个陈述。\n\n**A. 如果 $T$ 是不可伪造的，并且在执行设备操作前由内核立即验证，期间不将控制权交还给非受信代码，那么对于那些需要 $T$ 的操作，授权和使用之间的 TOCTTOU 时间窗口就被消除了。**\n\n这个陈述描述了所提议设计的核心优点。当攻击者能够在授权检查和资源使用之间的时间间隔内影响系统时，TOCTTOU 漏洞就存在了。该设计指出，内核在“同一个系统调用内”验证令牌 $T$ 并执行设备操作。这意味着从任何用户空间代码的角度来看，这是一个原子执行序列。内核在检查和使用之间不会将控制权交还给非受信环境。因此，对于由 $T$ 授权的 I/O 操作，竞争条件被消除了。$T$ 不可伪造并由内核验证是使检查有意义的必要条件。这个陈述是对原子性“检查后使用”序列的安全属性的正确描述。\n\n**正确**\n\n**B. 令牌方法无法在不重新引入 TOCTTOU 的情况下支持权限撤销，因此绝对劣于在每个设备操作的整个持续时间内对 ACL 加锁的方法。**\n\n这个陈述提出了两个主张。\n1. “令牌方法无法在不重新引入 TOCTTOU 的情况下支持权限撤销”。这是不正确的。撤销可以以一种与此设计兼容且不会产生新的 TOCTTOU 漏洞的方式实现。例如，内核可以维护一个撤销列表（例如，无效令牌标识符的黑名单）或使用版本号（如选项 C 所述）。对撤销的检查可以整合到验证令牌和执行 I/O 的同一个原子内核操作中。\n2. “...因此绝对劣于...”。这个结论是有缺陷的，不仅因为前提是错误的，还因为它忽略了性能上的权衡。在一个可能很长的 I/O 操作的整个持续时间内，对像 ACL 这样的共享资源持有锁，会造成严重的性能瓶颈，使访问串行化并降低系统吞吐量。基于令牌的方法通常性能更好，因为它需要一个快速的验证步骤，而不是一个长时间持有的锁。因此，它并非“绝对劣于”；它代表了一组不同的设计权衡。\n\n**错误**\n\n**C. 引入一个按设备的撤销版本计数器 $v$，内核在每次操作时都将该计数器与嵌入在 $T$ 中的版本进行比较，这种方法支持即时撤销，同时将检查和使用保持在单个原子内核路径内，其代价是每次操作增加一次额外的检查。**\n\n这个陈述提出了一种在类能力系统中处理撤销的具体的、众所周知的机制。\n- 当令牌 $T$ 在时间 $t_0$ 创建时，设备 ACL 的当前版本计数器 $v_D$ 被嵌入到 $T$ 中。\n- 如果管理员修改了 ACL，内核会递增 $v_D$。\n- 在后续的 I/O 操作期间，内核原子地执行三个步骤：\n    1. 它验证令牌 $T$ 的完整性。\n    2. 它将令牌中的版本 $v_T$ 与当前设备版本 $v_D$ 进行比较。如果 $v_T  v_D$，则令牌已过时，操作被拒绝。\n    3. 如果检查通过，它就执行 I/O 操作。\n这整个序列发生在单个系统调用内，保持了防止 TOCTTOU 的原子性。它提供了“即时”撤销，即在计数器递增后尝试的任何操作都将失败。代价是微小的：每次操作多一次整数比较。这个陈述准确地描述了对基础设计的一个有效且高效的扩展。\n\n**正确**\n\n**D. 因为 $T$ 是在打开时绑定的，所以任何后续授予 $P$ 额外权限的 ACL 更改，在 $P$ 使用 $T$ 时都会自动反映出来，这保留了最小权限原则。**\n\n这个陈述包含一个事实性错误。问题陈述指出，令牌 $T$ 与在“$t_0$ 时的 ACL 决定”的一组权限 $R$ 相关联。这意味着权限在令牌颁发时就被固定了。任何后续对 ACL 的更改，无论是授予还是撤销权限，都不会自动反映在现有的令牌 $T$ 中。要获取新权限，进程 $P$ 需要关闭其设备句柄并重新打开以获取新令牌。该陈述关于权限会自动更新的前提是错误的。此外，其逻辑的后半部分是颠倒的：权限*不*会自动提升这一事实，有助于在令牌所代表的会话生命周期内强制执行最小权限原则。\n\n**错误**\n\n**E. 如果 $T$ 存储在用户空间并在每次调用时提供，那么在没有内核强制的完整性机制使其不可伪造的情况下，恶意进程可能会修改 $T$ 来提升权限；因此，$T$ 的不可伪造性和完整性是确保该设计安全的必要条件。**\n\n进程 $P$ “向内核出示 $T$” 的模型意味着令牌（或其表示）是保存在用户空间中的。如果这个编码了授权权限的令牌作为普通数据存储在进程的内存中，进程就可以修改它。恶意进程可以轻易地更改令牌内的权限字段 $R$，以授予自己本没有的权限。这将完全颠覆安全机制。为防止这种情况，必须使令牌防篡改。这可以通过内核强制的完整性来实现，例如，使用只有内核知道的密钥，为令牌数据附加一个加密的消息认证码（MAC）。因此，令牌的不可伪造性和完整性不是可选特性，而是整个设计安全的必要前提条件。\n\n**正确**", "answer": "$$\\boxed{ACE}$$", "id": "3687966"}]}