{"hands_on_practices": [{"introduction": "在网络通信中，一个常见的威胁是“重放攻击”，攻击者截获合法数据包并重新发送，以欺骗接收方重复执行某个操作。为了抵御此类攻击，安全协议（如IPsec和DTLS）采用了一种名为“反重放窗口”的关键机制。这项实践将指导你实现一个基于滑动窗口的反重放机制，让你亲身体验保护数据流完整性的核心算法，并分析其在服务器处理百万级连接时对内存的消耗。[@problem_id:3631435]", "problem": "您需要设计并分析一个适用于操作系统（OS）内核网络栈中类传输层安全性（TLS）协议的、基于每个套接字的抗重放窗口机制。其密码学目标是通过使用单调递增的记录序列号来强制记录的新鲜性，从而防止重放攻击。根据密码学协议中新鲜性和抗重放性的基本定义，序列号必须非递减，并且每个唯一的序列号最多只能被处理一次。您的实现必须实现一个滑动窗口，该窗口根据传入记录的整数序列号来跟踪其接受或拒绝状态。\n\n此任务的基本基础：\n- 密码学协议的抗重放窗口在一个近期序列号的窗口上维护接受状态。\n- 每个类TLS记录都带有一个单调递增的序列号 $s \\in \\mathbb{N}$。\n- 该窗口由一个以比特为单位的大小 $W \\in \\mathbb{N}$ 参数化。其状态必须跟踪所见过的最高序列号 $H \\in \\mathbb{N}$ 以及一个长度为 $W$ 的位掩码，该位掩码指示在最后 $W$ 个位置内的序列号是否已被接收。\n- 一个序列号为 $s$ 的记录被接受，条件是 $s > H$（窗口前移），或者 $H - s < W$ 且窗口中对应的比特位尚未被设置。否则，它将作为重放或过旧的记录而被拒绝。\n\n程序要求：\n1. 实现一个为每个套接字设计的抗重放窗口，该窗口维护：\n   - 迄今为止观察到的最高序列号 $H$。\n   - 一个 $W$ 位的位图，其中比特位索引 $i$ 对应于序列号 $H - i$ 是否已被接收（索引 $i = 0$ 对应于 $H$ 本身）。\n   - 当接收到一个 $s > H$ 的新记录时，窗口必须向前滑动距离 $\\Delta = s - H$，丢弃滑出窗口的比特位，并将新引入的前导位置清零。如果 $\\Delta \\geq W$，则整个位图将被清零。\n2. 对于下面的每个测试用例，模拟处理给定的整数序列，并为每个序列号输出一个整数决策：$1$ 表示接受，$0$ 表示拒绝。\n3. 分析每个套接字状态的内存开销。假设一个套接字精确地维护 $W$ 位位图加上固定的每个套接字元数据开销 $M$ 字节（用于记账，如计数器和锁定状态）。计算：\n   - 每个套接字的内存（字节）：$m_{\\text{socket}} = \\lceil W/8 \\rceil + M$。\n   - $n$ 个套接字的总内存（字节）：$m_{\\text{total}} = n \\cdot m_{\\text{socket}}$。\n   以整数形式报告 $m_{\\text{socket}}$ 和 $m_{\\text{total}}$ 的值，单位为字节。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。结果必须按以下顺序在所有测试用例中展平：对于按顺序列出的每个测试用例，首先输出该测试用例中所有序列号的接受决策，然后输出 $m_{\\text{socket}}$，最后输出 $m_{\\text{total}}$。\n\n不涉及角度单位。所有内存量必须以字节为单位表示为整数。\n\n测试套件：\n- 测试用例 $1$：$W = 64$, $M = 24$, $n = 10^6$，序列 $\\{1, 2, 3, 2, 70, 69\\}$。\n- 测试用例 $2$：$W = 8$, $M = 16$, $n = 10^6$，序列 $\\{5, 5, 12, 4, 12, 20, 13\\}$。\n- 测试用例 $3$：$W = 128$, $M = 32$, $n = 10^6$，序列 $\\{1000, 900, 1000, 1128, 1127, 1128\\}$。\n- 测试用例 $4$：$W = 4096$, $M = 40$, $n = 10^6$，序列 $\\{1, 4097, 1\\}$。\n\n科学真实性和一致性说明：\n- 抗重放窗口是互联网协议安全（IPsec）和类TLS结构中广泛使用的抗重放机制，对于处理加密传输的内核级网络栈是必需的。\n- 规模 $n = 10^6$ 模拟了拥有约一百万个套接字的大规模服务器部署，这对于高并发下的内存规划是现实的。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[result1, result2, \\dots]$）。", "solution": "问题陈述被评估为**有效**。它具有科学依据、问题定义良好、客观，并为设计和分析抗重放窗口机制提供了一套完整且一致的需求。指定的机制是IPsec和DTLS等密码学协议中用于防止重放攻击的标准技术。其参数和规模对于现代服务器环境是现实的。\n\n解决方案的核心是为每个套接字实现一个有状态的抗重放窗口。该窗口的状态由两个组件定义：\n1.  $H$：迄今为止收到的最高序列号，一个初始化为 $0$ 的无符号整数。\n2.  一个大小为 $W$ 位的位图，我们可以表示为 $B$。此映射的第 $i$ 位（从右到左，即索引 $0$ 是最低有效位）对应于序列号 $H-i$。比特值为 $1$ 表示已收到相应的序列号；$0$ 表示尚未收到。该位图初始化为全零。\n\n当一个序列号为 $s$ 的记录到达时，应用以下逻辑：\n\n1.  **情况 1：$s > H$（最新记录）**\n    *   该记录被无条件接受（决策：$1$）。\n    *   窗口必须向前滑动以容纳新的最高序列号。滑动距离为 $\\Delta = s - H$。\n    *   如果 $\\Delta \\ge W$，新窗口与旧窗口不重叠，因此整个位图 $B$ 被重置为全零。\n    *   如果 $\\Delta < W$，位图 $B$ 在逻辑上左移 $\\Delta$ 位。这会丢弃最旧的 $\\Delta$ 个序列号的状态，并为 $\\Delta$ 个新序列号腾出空间。\n    *   最高序列号更新为：$H \\leftarrow s$。\n    *   位图 $B$ 中对应于新 $H$ 的比特位（索引 $0$）被设置为 $1$，以标记其已被接收。\n\n2.  **情况 2：$s \\le H$（可能是旧记录或重放记录）**\n    *   计算 $s$ 相对于 $H$ 的位置：$d = H - s$。\n    *   如果 $d \\ge W$，序列号 $s$ 比窗口能跟踪的最旧记录还要旧。它因过旧而被拒绝（决策：$0$）。\n    *   如果 $d < W$，序列号落在当前窗口内。我们检查位图 $B$ 的第 $d$ 位。\n        *   如果第 $d$ 位为 $1$，则该记录是重复的（一次重放）。它被拒绝（决策：$0$）。\n        *   如果第 $d$ 位为 $0$，则该记录是新的并且在窗口内。它被接受（决策：$1$）。然后通过将位图 $B$ 的第 $d$ 位设置为 $1$ 来更新状态。\n\n一个套接字的内存开销是位图的大小加上任何固定的元数据。位图需要 $\\lceil W/8 \\rceil$ 字节。因此，$m_{\\text{socket}} = \\lceil W/8 \\rceil + M$ 字节。$n$ 个套接字的总内存为 $m_{\\text{total}} = n \\cdot m_{\\text{socket}}$。\n\n我们现在将此逻辑应用于每个测试用例。\n\n**测试用例 1：** $W = 64$, $M = 24$, $n = 10^6$，序列 $\\{1, 2, 3, 2, 70, 69\\}$。\n初始状态：$(H=0, B=0x0)$。\n- $s=1$：$s>H$。接受 ($1$)。$\\Delta = 1$。$B \\leftarrow (B \\ll 1) | 1 = 0x1$。$H \\leftarrow 1$。状态：$(H=1, B=0x1)$。\n- $s=2$：$s>H$。接受 ($1$)。$\\Delta = 1$。$B \\leftarrow (B \\ll 1) | 1 = 0x3$。$H \\leftarrow 2$。状态：$(H=2, B=0x3)$。\n- $s=3$：$s>H$。接受 ($1$)。$\\Delta = 1$。$B \\leftarrow (B \\ll 1) | 1 = 0x7$。$H \\leftarrow 3$。状态：$(H=3, B=0x7)$。\n- $s=2$：$s \\le H$。$d = H-s = 1$。由于 $d < W=64$，我们检查 $B$ 的第 $1$ 位。在 $0x7$ 中第 $1$ 位已设置。拒绝 ($0$)。状态未变。\n- $s=70$：$s>H$。接受 ($1$)。$\\Delta = 70-3 = 67$。由于 $\\Delta \\ge W=64$，重置 $B \\leftarrow 0$。然后设置第 $0$ 位，所以 $B \\leftarrow 0x1$。$H \\leftarrow 70$。状态：$(H=70, B=0x1)$。\n- $s=69$：$s \\le H$。$d = H-s = 1$。由于 $d < W=64$，我们检查 $B$ 的第 $1$ 位。在 $0x1$ 中第 $1$ 位未设置。接受 ($1$)。设置第 $1$ 位：$B \\leftarrow B | (1 \\ll 1) = 0x3$。状态：$(H=70, B=0x3)$。\n决策：$1, 1, 1, 0, 1, 1$。\n内存：$m_{\\text{socket}} = \\lceil 64/8 \\rceil + 24 = 8 + 24 = 32$ 字节。$m_{\\text{total}} = 10^6 \\cdot 32 = 32000000$ 字节。\n\n**测试用例 2：** $W = 8$, $M = 16$, $n = 10^6$，序列 $\\{5, 5, 12, 4, 12, 20, 13\\}$。\n初始状态：$(H=0, B=0x0)$。\n- $s=5$：$s>H$。接受 ($1$)。$\\Delta = 5$。$B \\leftarrow (B \\ll 5) | 1 = 0x1$。$H \\leftarrow 5$。状态：$(H=5, B=0b00000001)$。\n- $s=5$：$s \\le H$。$d = H-s = 0$。由于 $d < W=8$，我们检查第 $0$ 位。第 $0$ 位已设置。拒绝 ($0$)。\n- $s=12$：$s>H$。接受 ($1$)。$\\Delta = 7$。$B \\leftarrow (B \\ll 7) | 1 = 0b10000001$。$H \\leftarrow 12$。状态：$(H=12, B=0b10000001)$。\n- $s=4$：$s \\le H$。$d = H-s = 8$。由于 $d \\ge W=8$，它过旧。拒绝 ($0$)。\n- $s=12$：$s \\le H$。$d = H-s = 0$。由于 $d < W=8$，我们检查第 $0$ 位。第 $0$ 位已设置。拒绝 ($0$)。\n- $s=20$：$s>H$。接受 ($1$)。$\\Delta = 8$。由于 $\\Delta \\ge W=8$，重置 $B \\leftarrow 0$。然后设置第 $0$ 位，$B \\leftarrow 0x1$。$H \\leftarrow 20$。状态：$(H=20, B=0b00000001)$。\n- $s=13$：$s \\le H$。$d = H-s = 7$。由于 $d < W=8$，我们检查第 $7$ 位。第 $7$ 位未设置。接受 ($1$)。设置第 $7$ 位：$B \\leftarrow B | (1 \\ll 7) = 0b10000001$。状态：$(H=20, B=0b10000001)$。\n决策：$1, 0, 1, 0, 0, 1, 1$。\n内存：$m_{\\text{socket}} = \\lceil 8/8 \\rceil + 16 = 1 + 16 = 17$ 字节。$m_{\\text{total}} = 10^6 \\cdot 17 = 17000000$ 字节。\n\n**测试用例 3：** $W = 128$, $M = 32$, $n = 10^6$，序列 $\\{1000, 900, 1000, 1128, 1127, 1128\\}$。\n初始状态：$(H=0, B=\\{0x0, 0x0\\})$。我们使用两个 $64$ 位整数表示 $128$ 位位图。\n- $s=1000$：$s>H$。接受 ($1$)。$\\Delta = 1000 \\ge W=128$。重置 $B$。$H \\leftarrow 1000$。设置第 $0$ 位。状态：$(H=1000, \\text{第 } 0 \\text{ 位已设置})$。\n- $s=900$：$s \\le H$。$d = H-s = 100$。由于 $d < W=128$，检查第 $100$ 位。未设置。接受 ($1$)。设置第 $100$ 位。状态：$(H=1000, \\text{第 } 0, 100 \\text{ 位已设置})$。\n- $s=1000$：$s \\le H$。$d = H-s = 0$。由于 $d < W=128$，检查第 $0$ 位。第 $0$ 位已设置。拒绝 ($0$)。\n- $s=1128$：$s>H$。接受 ($1$)。$\\Delta = 128$。由于 $\\Delta \\ge W=128$，重置 $B$。$H \\leftarrow 1128$。设置第 $0$ 位。状态：$(H=1128, \\text{第 } 0 \\text{ 位已设置})$。\n- $s=1127$：$s \\le H$。$d = H-s = 1$。由于 $d < W=128$，检查第 $1$ 位。未设置。接受 ($1$)。设置第 $1$ 位。状态：$(H=1128, \\text{第 } 0, 1 \\text{ 位已设置})$。\n- $s=1128$：$s \\le H$。$d = H-s = 0$。由于 $d < W=128$，检查第 $0$ 位。第 $0$ 位已设置。拒绝 ($0$)。\n决策：$1, 1, 0, 1, 1, 0$。\n内存：$m_{\\text{socket}} = \\lceil 128/8 \\rceil + 32 = 16 + 32 = 48$ 字节。$m_{\\text{total}} = 10^6 \\cdot 48 = 48000000$ 字节。\n\n**测试用例 4：** $W = 4096$, $M = 40$, $n = 10^6$，序列 $\\{1, 4097, 1\\}$。\n初始状态：$(H=0, B=\\text{全零})$。\n- $s=1$：$s>H$。接受 ($1$)。$\\Delta = 1 < W=4096$。将 $B$ 左移 $1$ 位。$H \\leftarrow 1$。设置第 $0$ 位。状态：$(H=1, \\text{第 } 0 \\text{ 位已设置})$。\n- $s=4097$：$s>H$。接受 ($1$)。$\\Delta = 4096$。由于 $\\Delta \\ge W=4096$，重置 $B$。$H \\leftarrow 4097$。设置第 $0$ 位。状态：$(H=4097, \\text{第 } 0 \\text{ 位已设置})$。\n- $s=1$：$s \\le H$。$d = H-s = 4096$。由于 $d \\ge W=4096$，它过旧。拒绝 ($0$)。\n决策：$1, 1, 0$。\n内存：$m_{\\text{socket}} = \\lceil 4096/8 \\rceil + 40 = 512 + 40 = 552$ 字节。$m_{\\text{total}} = 10^6 \\cdot 552 = 552000000$ 字节。\n\n最终的展平结果列表是通过按顺序连接每个案例的决策序列和内存计算来形成的。", "answer": "[1, 1, 1, 0, 1, 1, 32, 32000000, 1, 0, 1, 0, 0, 1, 1, 17, 17000000, 1, 1, 0, 1, 1, 0, 48, 48000000, 1, 1, 0, 552, 552000000]", "id": "3631435"}, {"introduction": "将目光从网络转向主机内部，操作系统常常需要在内存中管理敏感的临时秘密信息，如加密密钥或会话令牌。一个强大的安全技术是“加密封装”，它使用从进程上下文（如用户ID和程序标识）派生的密钥来加密秘密，从而将其“绑定”到特定的执行环境。本练习要求你构建一个安全的秘密保险库模型，模拟操作系统核心事件（如进程创建 $fork()$ 和程序替换 $exec()$）如何影响这些加密封装的有效性，从而深入理解密码学与操作系统进程生命周期管理的精妙互动。[@problem_id:3631353]", "problem": "您的任务是设计并分析一个操作系统安全共享密钥保管库的模型，该模型使用临时文件系统 (tmpfs) 和加密封印密钥。该模型必须实现为一个完整的、可运行的程序。目标是探究进程创建和替换，以及线程生命周期事件，如何影响对内存中密钥的访问控制和清理。您的程序必须计算并输出指定测试套件的结果。\n\n安全保管库存放在临时文件系统上的易失性内存中。此内存旨在作为临时存储，并在特定条件下被清除。通过从不变的进程属性中派生出解封密钥，保管库条目被视为已对某个进程封印。该模型必须遵循以下基本事实和定义，并避免使用未经验证的捷径：\n\n- 封印密钥由伪随机函数 (PRF) 和密钥派生函数 (KDF) 派生而来，这两者是广泛使用的密码学原语。PRF 将输入 $(\\text{key}, \\text{data})$ 确定性地映射到一个输出，对于没有密钥的攻击者来说，该输出与随机数无法区分。KDF 从输入密钥和上下文计算出一个派生密钥，以将秘密信息绑定到特定属性。PRF/KDF 的构造细节留给解决方案实现，但在模型内部，对于不同的上下文，它们必须是确定性的和抗碰撞的。\n- 在操作系统进程模型中，基本语义包括：\n  - 通过 $fork$ 创建进程：创建一个子进程，作为父进程的近乎精确的副本，继承内存映射和内容、用户标识符 $(u)$、组标识符 $(g)$ 以及当前的程序纪元 $(e)$，直到发生进一步更改。\n  - 通过 $exec$ 替换程序：进程映像被替换；进程标识符 $(u, g)$ 保持不变，而程序纪元 $(e)$ 则被认为更改为一个新值。根据策略，用户空间清理处理程序可能在替换之前或期间运行。内存映射通常会被替换，但共享的 tmpfs 区域可以在文件系统级别上持久存在，除非被显式清理。\n  - 线程取消：当一个线程收到取消请求时，已注册的清理处理程序会运行，这些程序必须安全地擦除内存中的秘密信息，以防止敏感数据残留。\n- 临时文件系统 (tmpfs) 的内容取决于挂载纪元 $(m)$，当挂载纪元改变时，驻留在 tmpfs 中的秘密信息被视为已清除。重新挂载或卸载会增加 $(m)$ 的值，并使先前的内容失效。\n\n需要实现的模型要求：\n- 用一个从属性 $(K, u, g, e, m)$ 派生的封印绑定器来表示每个保管库条目，其中 $K$ 是用于封印的操作系统主密钥， $u$ 是用户标识符， $g$ 是组标识符， $e$ 是程序纪元， $m$ 是挂载纪元。保管库条目应包含一个存在标志，用以指示秘密信息是否存在于内存中。\n- 实现一个基于 PRF 的确定性 KDF 来计算绑定器。在模型层面，该 PRF 必须充当一个确定性的混合函数，其行为与伪随机函数的核心属性一致。\n- 定义访问语义：一个进程当且仅当从当前 $(K, u, g, e, m)$ 计算出的派生密钥与存储的绑定器相等，并且保管库条目存在时，才能解封一个秘密信息。\n- 定义清理语义：\n  - 在线程取消时，通过擦除其内存，立即清除保管库条目，并将存在标志设置为 false。\n  - 在 $exec$ 时，程序纪元 $(e)$ 更改为一个新值；可选策略可能会触发清理，从而清除保管库条目。\n  - 在挂载纪元变化 $(m \\rightarrow m')$ 时，tmpfs 内容被清除，使得保管库条目变为不存在且无法解封。\n\n需要模拟的状态转换模型：\n- 一个父进程在 $(K, u, g, e, m)$ 条件下创建一个封印的保管库条目，然后通过 $fork$ 创建一个子进程。\n- 子进程可以执行 $exec$ 来使 $(e \\rightarrow e')$ 转换。\n- 线程取消可能在子进程尝试访问之前或之后发生。\n- 挂载纪元可能在场景的某个特定点发生变化 $(m \\rightarrow m')$。\n\n参数定义：\n- $K$ 是一个表示主密钥的 $64$ 位无符号整数。\n- $u$ 和 $g$ 是表示用户和组标识符的无符号整数。\n- $e$ 和 $m$ 是表示程序纪元和挂载纪元的非负整数。\n- 策略包括用于在 $exec$ 时进行清理的布尔标志。\n\n测试套件：\n您的程序必须评估以下六个测试用例，每个用例都按指定参数化。对于每个用例，模拟事件序列并确定子进程是否可以访问秘密信息，以及在序列结束后保管库是否为空。布尔值必须以整数形式输出：$1$ 表示 true，$0$ 表示 false。\n\n- 测试用例 1 (成功路径，访问后清理):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1001$, $e = 1$, $m = 1$。\n  - 子进程不执行 $exec$；$exec$ 时清理策略为 $0$。\n  - 取消发生在子进程尝试访问之后。\n- 测试用例 2 ($exec$ 与清理策略):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1001$, $e = 1$, $m = 1$。\n  - 子进程执行 $exec$ 并将纪元更改为 $e' = 2$；$exec$ 时清理策略为 $1$。\n  - $exec$ 之外没有取消操作。\n- 测试用例 3 (访问前取消):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1002$, $g = 1002$, $e = 1$, $m = 1$。\n  - 无 $exec$；$exec$ 时清理策略为 $0$。\n  - 取消发生在子进程尝试访问之前。\n- 测试用例 4 (挂载纪元变化清除 tmpfs):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1002$, $e = 1$, $m$ 在子进程访问前从 $1$ 变为 $2$。\n  - 无 $exec$；$exec$ 时清理策略为 $0$。\n  - 无取消操作。\n- 测试用例 5 (子进程中组标识符更改，访问后清理):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, 在 $fork$ 之后、访问之前，子进程中的 $g$ 从 $1005$ 变为 $1006$, $e = 1$, $m = 1$。\n  - 无 $exec$；$exec$ 时清理策略为 $0$。\n  - 取消发生在子进程尝试访问之后。\n- 测试用例 6 ($exec$ 无清理策略，显示残留密钥风险):\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1001$, $e = 1$, $m = 1$。\n  - 子进程执行 $exec$ 并将纪元更改为 $e' = 2$；$exec$ 时清理策略为 $0$。\n  - 无取消操作。\n\n对于每个测试用例，您的程序必须计算两个输出：\n- 访问结果：子进程在序列结束后是否能解封秘密信息，以整数 $0$ 或 $1$ 表示。\n- 保管库空闲状态：序列结束后保管库是否为空，以整数 $0$ 或 $1$ 表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个包含六个对的列表，每个测试用例一对，其中每对是按 $(\\text{访问}, \\text{空闲})$ 顺序排列的上述两个整数。该列表必须以逗号分隔，并用方括号括起来，其中每对本身也是一个用方括号括起来的逗号分隔列表。例如：$[[1, 0], [0, 1], \\dots]$。", "solution": "该问题要求设计并实现一个操作系统中安全密钥保管库的计算模型。该模型必须模拟访问控制如何受到进程生命周期事件（如 $fork()$ 和 $exec()$）、线程取消以及系统状态变化（如临时文件系统 (tmpfs) 的重新挂载）的影响。该解决方案基于操作系统和密码学的既定原则。\n\n**1. 基本原则**\n\n该模型建立在三个核心领域之上：操作系统进程模型、临时文件系统语义和密码学密钥派生。\n\n- **进程和线程模型**：在类 UNIX 系统中，新进程由 $fork()$ 创建，它会生成一个与父进程几乎完全相同的子进程。子进程继承父进程的内存、凭证（用户标识符 $u$、组标识符 $g$）和程序代码。$exec()$ 系统调用会用新程序替换当前进程的内存和代码，但关键是，$u$ 和 $g$ 等凭证会被保留。我们用“程序纪元” $e$ 来为程序身份建模，它在 $fork()$ 时被继承，但在 $exec()$ 时会改变。线程取消是终止一个线程的机制，它应该触发清理处理程序以安全地擦除内存中的敏感数据。\n\n- **临时文件系统 (tmpfs)**：tmpfs 是一个易失性的内存文件系统。其内容是短暂的，并且仅在挂载的生命周期内存在。我们通过将 tmpfs 与一个“挂载纪元” $m$ 相关联来对此进行建模。任何使挂载失效的事件（例如，卸载或重新挂载）都被建模为 $m$ 的增加，这被定义为清除 tmpfs 的所有内容。\n\n- **密码学绑定**：一个秘密信息可以被密码学地“封印”或“绑定”到特定的上下文。这通过使用密钥派生函数 (KDF) 来实现，该函数通常由伪随机函数 (PRF) 构建。KDF 接受一个主密钥和一组上下文属性（例如，进程凭证、程序身份），并确定性地生成一个派生密钥。只有当当前上下文能够重现完全相同的派生密钥时，秘密信息才能被“解封”。这确保了秘密信息仅在预期的条件下才能被访问。\n\n**2. 算法设计与状态建模**\n\n基于这些原则，我们构建了一个确定性的仿真模型。\n\n- **状态表示**：\n  - **保管库条目**：一个保管库条目由两个组件表示：一个 `binder` 和一个 `presence flag`。\n    - `binder` 是一个 `unsigned long long` 类型的值，表示由 KDF 计算出的派生密钥。它根据上下文 $(K, u, g, e, m)$ 计算得出，其中 $K$ 是系统的主密钥，$(u, g)$ 是进程凭证，$e$ 是程序纪元，$m$ 是 tmpfs 挂载纪元。\n    - `presence flag` 是一个布尔值（表示为整数，$1$ 为 true，$0$ 为 false），指示秘密信息是否物理上存在于内存中（即在 tmpfs 上）。\n  - **进程上下文**：一个进程由其当前属性 $(u, g, e)$ 定义。\n  - **系统上下文**：相关的系统范围状态是挂载纪元 $m$ 和主密钥 $K$。\n\n- **密钥派生函数 (KDF)**：\n为了对密码学绑定进行建模，我们实现了一个确定性函数 `compute_binder(K, u, g, e, m)`。此函数必须是一个强混合函数，为每一组唯一的输入生成唯一的输出，从而满足基于 PRF 的 KDF 的概念性要求。对于此模型，我们采用了一个在原理上类似于 FNV-1a 哈希算法的函数。它通过一系列与大素数的异或和乘法操作，将输入 $(K, u, g, e, m)$ 组合起来，生成一个 $64$ 位的 `binder` 值。\n$$ \\text{binder} = \\text{KDF}(K, u, g, e, m) $$\n\n- **访问语义**：\n一个进程当且仅当同时满足两个条件时，才能成功访问（解封）秘密信息：\n$1$. 保管库条目的 `presence flag` 必须为 true。\n$2$. 从进程当前上下文 $(K, u, g, e, m)$ 计算出的 `binder` 必须与保管库条目中存储的 `binder` 完全匹配。\n$$ \\text{Access} = (\\text{is\\_present} = \\text{true}) \\land (\\text{KDF}(K, u_{\\text{current}}, g_{\\text{current}}, e_{\\text{current}}, m_{\\text{current}}) = \\text{binder}_{\\text{stored}}) $$\n\n- **状态转换逻辑**：\n每个测试用例的模拟都遵循严格的事件序列，并相应地更新状态变量：\n$1$. **初始化**：一个具有上下文 $(u, g, e)$ 的父进程存在于一个拥有主密钥 $K$ 和挂载纪元 $m$ 的系统中。\n$2$. **保管库创建**：父进程创建一个保管库条目。使用初始上下文 $(K, u, g, e, m)$ 计算 `binder`，并将其 `presence flag` 设置为 true ($1$)。\n$3$. **Fork**：创建一个子进程。它继承父进程的上下文，因此其初始状态也是 $(u, g, e)$。保管库条目在共享的 tmpfs 中持久存在。\n$4$. **访问前事件**：测试用例场景规定了在子进程尝试访问保管库之前发生的事件。这些事件会修改子进程的上下文或保管库的状态：\n    - **组ID更改**：子进程的 $g$ 值被更新。\n    - **挂载纪元变化**：系统的 $m$ 更新为 $m'$，保管库的 `presence flag` 设置为 false ($0$)，模拟 tmpfs 被清除。\n    - **$exec()$**：子进程的程序纪元 $e$ 变为 $e'$。如果 `cleanup_on_exec` 策略激活，则 `presence flag` 设置为 false ($0$)。\n    - **访问前取消**：由于清理处理程序，`presence flag` 设置为 false ($0$)。\n$5$. **访问尝试**：子进程根据其*当前*上下文计算一个密钥，并按照上面定义的访问语义尝试访问保管库。结果（访问成功或失败）被记录下来。\n$6$. **访问后事件**：像线程取消这样的事件可能在访问尝试之后发生，这会将 `presence flag` 设置为 false ($0$)。\n$7$. **最终状态**：`presence flag` 的最终状态决定了保管库是否为空。\n\n**3. 测试用例分析**\n\n该逻辑应用于每个测试用例。作为示例，我们来分析两个对比鲜明的案例：\n\n- **测试用例 1 (成功访问与清理)**：\n  - 父进程使用上下文 $(K, u=1001, g=1001, e=1, m=1)$ 创建保管库。保管库存在。\n  - 子进程 fork，继承相同的上下文。没有访问前事件发生。\n  - 子进程尝试访问。其上下文 $(1001, 1001, 1)$ 与用于创建 `binder` 的上下文匹配，且保管库存在。因此，访问被授予。结果：**access = 1**。\n  - 在访问*之后*发生取消。这会触发清理，将 `presence flag` 设置为 false。\n  - 最终保管库状态为空。结果：**empty = 1**。\n\n- **测试用例 6 (因 `exec` 未清理导致的访问失败)**：\n  - 父进程使用上下文 $(K, u=1001, g=1001, e=1, m=1)$ 创建保管库。保管库存在。\n  - 子进程 fork，继承上下文。\n  - 子进程执行 $exec()$，将其程序纪元更改为 $e'=2$。`cleanup_on_exec` 策略为 false，因此保管库条目的 `presence flag` 保持为 true。\n  - 子进程尝试访问。其上下文现在是 $(1001, 1001, 2)$。它用 $e=2$ 计算出的 `binder` 与用 $e=1$ 创建的存储 `binder` 不匹配。访问被拒绝。结果：**access = 0**。\n  - 没有进一步的清理事件发生。`presence flag` 保持为 true。\n  - 最终保管库状态不为空，这代表了残留密钥风险。结果：**empty = 0**。\n\n这种在 C 程序中实现的系统化模拟，能够精确评估模型所定义的每种场景的安全影响。", "answer": "[[1, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 0]]", "id": "3631353"}, {"introduction": "在零信任安全模型中，一个根本性的问题是：我们如何远程验证一台计算机的软件环境是否真实可信，未被篡改？“远程证明”协议为此提供了解决方案，它允许系统借助硬件信任根（如可信平台模块TPM）向远程验证者证明其自身软件栈的完整性。这项综合性实践将引导你从零开始构建一个完整的远程证明协议，包括计算软件哈希、使用HMAC保证消息的真实性以及利用Nonce确保信息的新鲜度，从而将多个密码学工具组合成一个强大的、可验证的信任链。[@problem_id:3631438]", "problem": "您的任务是从操作系统的角度设计并验证一个远程证明协议，使用密码学作为安全工具。其目标是允许一个进程使用可信平台模块（TPM）作为信任锚，向远程客户端证明其当前执行的二进制文件和已加载模块的完整性。您必须实现一个完整的、可运行的程序，该程序模拟证明过程并在多种测试条件下进行验证。该协议必须使用 nonce 挑战来保证新鲜性，并使用密钥散列消息认证码来保证真实性。\n\n使用的基本定义和事实如下：\n- 一个密码学散列函数 $H$ 将任意长度的输入映射到固定长度的输出，并且必须满足抗原像性、抗第二原像性和抗碰撞性。对于此问题，请使用等效于安全散列算法 256 位（SHA-256）的实例，该实例生成 $256$ 位输出，并在 $64$ 字节的块大小上运行。\n- 使用底层散列函数 $H$ 的密钥散列消息认证码（HMAC）定义为 $$\\operatorname{HMAC}_K(m) = H\\left((K \\oplus \\text{opad}) \\parallel H\\left((K \\oplus \\text{ipad}) \\parallel m\\right)\\right),$$ 其中 $K$ 是密钥，$m$ 是消息，$\\oplus$ 是按位异或，$\\parallel$ 表示串联，$\\text{opad}$ 和 $\\text{ipad}$ 是为所选的 $H$（块大小 $b = 64$ 字节）按标准定义的外部和内部填充。\n- nonce 是一次性使用的数字；当响应方在其认证响应中包含来自挑战方的 nonce 时，它能提供新鲜性保证。\n\n需要实现的协议描述：\n- 定义一个度量过程，其中一个进程有一个二进制映像 $B$ 和一个已加载模块列表 $\\{(N_i, M_i)\\}_{i=1}^k$，其中 $N_i$ 是模块名称，$M_i$ 是其内容。计算二进制文件哈希值 $h_{\\text{bin}} = H(B)$ 和每个模块的哈希值 $h_i = H(M_i)$。\n- 序列化一个证明消息 $\\mathcal{S}$，其中包含 $h_{\\text{bin}}$、模块数量 $k$、每对 $(N_i, h_i)$ 以及挑战方提供的新鲜性 nonce $n$。TPM 生成一个证明标签 $t = \\operatorname{HMAC}_K(\\mathcal{S})$，其中 $K$ 是一个驻留在 TPM 中的证明密钥。在实际场景中，$K$ 将是非对称的（用于数字签名）；在本练习中，将 TPM 建模为持有一个用于 $\\operatorname{HMAC}$ 的对称密钥，以便专注于完整性和新鲜性属性。\n- 验证方检查：(i) 提供的标签 $t$ 是否等于 $\\operatorname{HMAC}_{K_{\\text{ver}}}(\\mathcal{S})$，其中 $K_{\\text{ver}}$ 是其拥有的证明密钥副本（或以其他方式安全建立的共享秘密），(ii) 证明消息中的 nonce 是否与其挑战值 $n_{\\text{challenge}}$ 匹配，以及 (iii) $h_{\\text{bin}}$ 和 $\\{h_i\\}$ 是否与一个包含已知良好度量值的白名单匹配。当且仅当所有三个条件都满足时，裁决结果为真。\n\n需要在您的实现逻辑中分析和编码的操作系统角色：\n- 操作系统必须仲裁度量过程，以防止用户空间任意伪造 $\\mathcal{S}$。在实践中，度量源自内核或可信加载器，并且 TPM 密钥 $K$ 必须受到保护，使用户空间除非通过可信路径，否则无法计算 $\\operatorname{HMAC}_K$。操作系统还通过其动态加载器管理模块加载，并可以枚举已加载的模块，以确保度量日志反映实际状态。\n- 您的程序应通过在结构上区分一个可以访问 $K$ 的“TPM 证明”函数和一个验证方函数，并通过检查验证方维护的白名单来模拟这种分离。您还必须包含测试用例，以演示欺骗攻击以及操作系统在检测这些攻击中的作用（例如，被篡改的模块、不正确的密钥或错误的 nonce 挑战）。\n\n测试套件规范：\n使用以下五个测试用例来检验正确性、覆盖率和边界条件。字符串代表字节数组，应按原样使用。\n- 用例 1（正常路径）：二进制文件 $B = \\text{\"APP\\_A v1.0\"}$，模块 $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.0\"}), (\\text{\"libbeta\"}, \\text{\"libbeta v1.0\"})\\}$，TPM 签名密钥 $K = \\text{\"K\\_AIK\"}$，证明 nonce $n = \\text{\"N1\"}$，验证方挑战 $n_{\\text{challenge}} = \\text{\"N1\"}$。白名单精确包含 $B$ 和两个模块的内容。\n- 用例 2（篡改的模块内容，真实的标签）：二进制文件 $B = \\text{\"APP\\_A v1.0\"}$，模块 $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.1\"}), (\\text{\"libbeta\"}, \\text{\"libbeta v1.0\"})\\}$，TPM 签名密钥 $K = \\text{\"K\\_AIK\"}$，证明 nonce $n = \\text{\"N1\"}$，验证方挑战 $n_{\\text{challenge}} = \\text{\"N1\"}$。白名单期望 $\\text{\"libalpha v1.0\"}$ 和 $\\text{\"libbeta v1.0\"}$；证明标签有效，但度量值与白名单不匹配。\n- 用例 3（错误的 HMAC 密钥）：二进制文件 $B = \\text{\"APP\\_A v1.0\"}$，模块 $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.0\"})\\}$，TPM 签名密钥 $K = \\text{\"K\\_AIK\\_BAD\"}$，证明 nonce $n = \\text{\"N2\"}$，验证方挑战 $n_{\\text{challenge}} = \\text{\"N2\"}$。验证方使用 $K_{\\text{ver}} = \\text{\"K\\_AIK\"}$；因此标签验证失败。\n- 用例 4（错误的 nonce）：二进制文件 $B = \\text{\"APP\\_A v1.0\"}$，模块 $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.0\"})\\}$，TPM 签名密钥 $K = \\text{\"K\\_AIK\"}$，证明 nonce $n = \\text{\"N3\"}$，验证方挑战 $n_{\\text{challenge}} = \\text{\"N4\"}$。标签在 $K$ 下有效，但由于 nonce 不匹配，新鲜性检查失败。\n- 用例 5（边界情况，零模块）：二进制文件 $B = \\text{\"APP\\_MIN\"}$，模块 $\\{\\}$（空集，$k = 0$），TPM 签名密钥 $K = \\text{\"K\\_AIK\"}$，证明 nonce $n = \\text{\"N5\"}$，验证方挑战 $n_{\\text{challenge}} = \\text{\"N5\"}$。白名单只包含 $B$ 并期望零模块。\n\n您的程序必须：\n- 实现等效于 SHA-256 的 $H$ 和如上文定义的 $\\operatorname{HMAC}$，块大小 $b = 64$ 字节。\n- 将证明消息 $\\mathcal{S}$ 计算为一个字符串，该字符串包含 $h_{\\text{bin}}$ 的十六进制表示、模块数量 $k$、每对 $(N_i, h_i)$（其中 $h_i$ 为十六进制）以及 nonce $n$。标签 $t$ 是基于此精确的序列化结果计算的。\n- 对于每个测试用例，使用 TPM 签名密钥 $K$ 计算标签 $t$，然后使用验证方的密钥 $K_{\\text{ver}}$、挑战 nonce $n_{\\text{challenge}}$ 和预期的白名单内容执行验证。当且仅当标签验证、nonce 相等性验证和白名单匹配性验证全部通过时，布尔结果为真。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试套件的五个布尔结果，形式为用方括号括起来的逗号分隔列表，例如：$[true, false, true, false, true]$。布尔值必须是小写的英文单词。\n\n此问题不涉及物理单位或角度单位；不使用百分比。所有数值量必须表示为如上所示的、用 LaTeX 美元符号括起来的数字。", "solution": "用户提供的问题已经过分析，并被确定为有效。它在科学上基于密码学和操作系统安全的既定原则，定义明确，具有清晰的目标和确定性的测试用例，并且与指定领域相关。尽管证明消息 $\\mathcal{S}$ 的确切序列化格式没有被严格定义，但这种轻微的模糊性并不妨碍创建唯一且正确的解决方案，因为可以为证明生成和验证阶段建立并实现一个合理且一致的格式。我将继续提供完整的解决方案。\n\n该问题要求模拟一个远程证明协议，这是一种基本的安全机制，它允许远程验证方获取关于目标系统（称为证明方）软件状态的可信信息。该协议的安全性依赖于三个核心密码学原则：\n\n1.  **完整性**：使用一个密码学散列函数，指定为 $H$ (SHA-256)，为二进制文件 ($B$) 和每个已加载的模块 ($M_i$) 创建一个简洁且唯一的指纹（摘要）。对二进制文件或模块的任何修改，无论多么微小，都将导致一个截然不同的哈希值。这使得验证方可以通过将接收到的哈希值与已知良好值的白名单进行比较来检测篡改。\n\n2.  **真实性**：使用密钥散列消息认证码 $\\operatorname{HMAC}_K(\\cdot)$ 来证明证明度量是由持有密钥 $K$ 的一方生成的。在此模型中，密钥驻留在可信平台模块（TPM）这一硬件安全锚中。持有相同密钥副本（$K_{\\text{ver}}$）的验证方可以对接收到的消息重新计算 HMAC，并检查其是否与提供的标签匹配。匹配即证明了消息的来源，确保其来自可信的 TPM 而非冒充者。HMAC 公式如下：\n    $$\n    \\operatorname{HMAC}_K(m) = H\\left((K \\oplus \\text{opad}) \\parallel H\\left((K \\oplus \\text{ipad}) \\parallel m\\right)\\right)\n    $$\n    其中 $K$ 是密钥，$m$ 是消息，$\\oplus$ 是按位异或操作，$\\parallel$ 表示串联，$\\text{ipad}$ 和 $\\text{opad}$ 是根据散列函数的块大小（对于 SHA-256 是 $b=64$ 字节）衍生的标准化填充常量。\n\n3.  **新鲜性**：使用 nonce ($n$)，即“一次性使用的数字”，来防止重放攻击。验证方（挑战方）生成一个随机的 nonce，$n_{\\text{challenge}}$，并将其发送给证明方。证明方必须在其签名的证明报告中包含这个确切的 nonce。当验证方收到报告时，它会检查其中嵌入的 nonce $n$ 是否与其原始挑战 $n_{\\text{challenge}}$ 匹配。这证实了该证明是最近生成的，而不是一个过去、可能已被攻破状态的记录。\n\n该实现将按照所述的角色和约束进行结构化模拟。\n\n**密码学原语实现**：\nC 程序将包含一个符合 FIPS PUB 180-4 标准的、自包含的 SHA-256 散列算法实现。这涉及到用于初始化散列状态、处理 $64$ 字节块的输入数据以及完成计算以生成 $256$ 位（$32$ 字节）摘要的函数。随后，将根据提供的公式实现一个 `hmac_sha256` 函数，使用 SHA-256 实现作为其底层散列函数 $H$。\n\n**协议和数据结构实现**：\n- **度量和证明**：一组函数将模拟证明方侧的操作。该过程首先计算主应用程序二进制文件的 SHA-256 哈希值（$h_{\\text{bin}} = H(B)$）和每个已加载模块的哈希值（$h_i = H(M_i)$）。\n- **证明序列化 ($\\mathcal{S}$)**：将生成的度量值序列化为单个字符串 $\\mathcal{S}$，用于 HMAC 计算。为此序列化选择的格式是一个空格分隔的字符串：`[h_bin_hex] [k] [N1]:[h1_hex] [N2]:[h2_hex] ... [Nk]:[hk_hex] [nonce]`。每个 $32$ 字节哈希摘要的十六进制表示将是一个 $64$ 字符的字符串。此格式没有歧义，并包含所有必需的信息。\n- **TPM 模拟**：一个函数将通过计算证明标签 $t = \\operatorname{HMAC}_K(\\mathcal{S})$ 来模拟 TPM 的可信操作，该函数以证明方的密钥 $K$ 作为输入。\n- **验证**：一个独立的验证函数模拟远程客户端。此函数将执行三个关键检查：\n    1.  **标签验证**：它使用验证方的密钥 $K_{\\text{ver}}$ 对接收到的证明字符串 $\\mathcal{S}$ 重新计算 HMAC，并将其与接收到的标签 $t$ 进行比较。\n    2.  **Nonce 验证**：它从字符串 $\\mathcal{S}$ 中解析出 nonce $n$，并将其与内部持有的挑战 nonce $n_{\\text{challenge}}$ 进行比较。\n    3.  **白名单验证**：它从 $\\mathcal{S}$ 中解析出二进制文件哈希 $h_{\\text{bin}}$ 和所有模块哈希 $\\{h_i\\}$，并将它们与预定义的已知良好哈希值白名单进行比较。\n\n当且仅当所有三个验证步骤都成功时，一个测试用例才算通过。程序将执行五个指定的测试用例，每个用例都旨在探查协议安全性的一个不同方面：成功的证明（用例 1）、检测篡改内容（用例 2）、检测无效签名密钥（用例 3）、检测重放或不正确的 nonce（用例 4），以及正确处理无模块的边界情况（用例 5）。最终输出将是一个反映每个测试结果的布尔数组。", "answer": "[true, false, false, false, true]", "id": "3631438"}]}