{"hands_on_practices": [{"introduction": "操作系统中的文件系统权限是抵御程序威胁的第一道防线。本练习将探讨一个常见但关键的场景：在多用户共享的工作区（如 `/tmp` 或 `/shared` 目录）中，如何既允许所有用户创建文件，又防止他们恶意删除或重命名不属于自己的文件。通过分析 `sticky bit`（粘滞位）这一特殊权限位的作用，您将深入理解 POSIX 权限模型的精妙之处，并学会区分对目录的操作权限和对文件内容的操作权限，这是保障系统安全的基本功。[@problem_id:3673293]", "problem": "一个遵循可移植操作系统接口 (POSIX) 的操作系统 (OS) 运行着一个多用户服务器，学生们在该服务器上共享项目文件夹。考虑同一文件系统上的两个目录：一个共享工作区目录 $D_s = \\text{/shared}$，其模式为 $1777$（即，全局可写且设置了粘滞位），所有者为用户 $u_0$（管理员）；以及一个开放的临时目录 $D_o = \\text{/scratch}$，其模式为 $0777$（全局可写，无粘滞位），所有者也为用户 $u_0$。两个用户 $u_A$ 和 $u_B$ 协作开展项目。在 $D_s$ 中，用户 $u_A$ 创建了一个普通文件 $f_A = \\text{/shared/report.txt}$，其模式为 $0644$（所有者读写，同组用户只读，其他用户只读）。用户 $u_B$ 在没有提升权限的情况下运行了一个恶意软件样本 $M_B$，并试图在 $D_s$ 和 $D_o$ 中执行典型的恶意操作：批量删除其他用户的文件、通过重命名进行替换、修改内容、符号链接重定向以及目录条目操作。\n\n基于 POSIX 目录和粘滞位的基础语义，以下哪些陈述正确地指出了 $D_s$ 和 $D_o$ 如何缓解或允许 $M_B$ 的行为？选择所有适用项。\n\nA. 在模式为 $1777$ 的 $D_s$ 中，$u_B$ 的进程无法 `unlink` 或 `rename` $f_A$，除非 $u_B$ 是 $f_A$ 的所有者、$D_s$ 的所有者，或拥有超级用户权限；因此，粘滞位直接缓解了对其他用户文件的大规模删除行为。\n\nB. $D_s$ 上的粘滞位不限制对 $f_A$ 内容的读或写操作；因此，如果 $f_A$ 对 $u_B$ 是可写的，那么尽管存在粘滞位，$M_B$ 仍然可能修改其内容。\n\nC. 在模式为 $0777$ 的 $D_o$ 中，只要 $u_B$ 对 $D_o$ 具有写和执行权限，就允许 $u_B$ `unlink` $f_A$，而与 $f_A$ 自身的文件模式位无关；因此，在 $D_o$ 中，仅基于 $f_A$ 权限的删除保护是无效的。\n\nD. $D_s$ 上的粘滞位阻止 $u_B$ 在 $D_s$ 中创建指向其他敏感路径的符号链接；因此，符号链接重定向攻击被粘滞位所阻止。\n\nE. `unlink` $f_A$ 的权限检查是针对 $f_A$ 的模式位执行的；因此，如果 $f_A$ 对 $u_B$ 不可写，那么即使在一个全局可写的目录中，$u_B$ 也无法 `unlink` 它。", "solution": "问题要求评估关于 POSIX 兼容操作系统中文件系统权限的几个陈述，特别是对比设置了粘滞位的全局可写目录 ($D_s$) 与未设置粘滞位的目录 ($D_o$)。为了验证这些陈述，我们必须首先确定 POSIX 中管理文件和目录操作的基本原则。\n\n**基本原则：**\n1.  **访问文件内容（读/写）：** 读取或写入文件数据的权限由文件自身的模式位，结合用户的ID和组成员关系来决定。要执行这些操作，用户还必须对包含该文件的目录及其所有父目录拥有执行（`x`）权限，以便能够遍历路径到达文件的 inode。\n2.  **修改目录内容（创建/删除/重命名）：** 在目录中创建、删除（`unlink`）或重命名文件的能力由**目录本身**的权限决定。具体来说，用户必须对该目录同时拥有写（`w`）和执行（`x`）权限才能修改其内容。对于此操作，系统不会检查被删除或重命名的文件的权限。\n3.  **目录上的粘滞位（模式 `t`）：** 当在一个全局可写的目录（例如，模式 $1777$）上设置了粘滞位时，它为删除和重命名规则增加了一个关键限制。一个进程只有在以下情况之一才能在该目录中 `unlink` 或 `rename` 文件，即该进程的有效用户ID是：\n    *   文件的所有者。\n    *   目录的所有者。\n    *   超级用户（root）。\n    此规则是在目录需要写和执行权限的标准要求*之外*应用的。粘滞位不影响文件创建或对文件内容的操作。\n\n**问题设置分析：**\n*   目录 $D_s$：路径 `/shared`，模式 $1777$。这是一个全局可写、全局可执行且设置了粘滞位的目录。其所有者是 $u_0$。\n*   目录 $D_o$：路径 `/scratch`，模式 $0777$。这是一个全局可写、全局可执行但未设置粘滞位的目录。其所有者也是 $u_0$。\n*   文件 $f_A$：路径 `/shared/report.txt`，所有者为用户 $u_A$，模式 $0644$。这意味着所有者 $u_A$ 拥有读/写权限，而同组用户和其他用户（包括用户 $u_B$）只有只读权限。\n*   用户 $u_B$：一个非特权用户，他不是 $u_A$ 也不是 $u_0$。$u_B$ 通过恶意软件 $M_B$ 尝试进行操作。\n\n我们现在将基于这些原则评估每个陈述。\n\n**A. 在模式为 $1777$ 的 $D_s$ 中，$u_B$ 的进程无法 `unlink` 或 `rename` $f_A$，除非 $u_B$ 是 $f_A$ 的所有者、$D_s$ 的所有者，或拥有超级用户权限；因此，粘滞位直接缓解了对其他用户文件的大规模删除行为。**\n该陈述直接应用了粘滞位的规则。用户 $u_B$ 试图 `unlink` 或 `rename` 由 $u_A$ 拥有的文件 $f_A$。\n1.  $u_B$ 是否对 $D_s$ 拥有写和执行权限？是的，模式为 $1777$。\n2.  $D_s$ 上是否设置了粘滞位？是的。\n3.  因此，附加的检查规则适用。$u_B$ 是否拥有文件 $f_A$？不，所有者是 $u_A$。$u_B$ 是否拥有目录 $D_s$？不，所有者是 $u_0$。$u_B$ 是超级用户吗？不，问题说明没有提升的权限。\n由于绕过粘滞位保护的条件无一满足，$u_B$ 无法 `unlink` 或 `rename` $f_A$。“因此”子句正确地得出结论，该机制阻止用户在共享目录中删除其他用户的文件，从而缓解了大规模删除攻击。该陈述是对粘滞位目的和效果的正确而精确的描述。\n**结论：正确。**\n\n**B. $D_s$ 上的粘滞位不限制对 $f_A$ 内容的读或写操作；因此，如果 $f_A$ 对 $u_B$ 是可写的，那么尽管存在粘滞位，$M_B$ 仍然可能修改其内容。**\n粘滞位是目录的一个属性，用于管理目录条目的操作（`unlink`、`rename`）。它对与文件内容相关的权限没有影响。读写文件内容的能力由文件自身的模式位决定。该陈述正确地断言了这种关注点分离。如果 $f_A$ 的模式是 $0666$ 之类的，授予“其他用户”写权限，那么 $u_B$ 将能够修改其内容，因为对于 `write()` 系统调用，系统不会检查父目录 $D_s$ 上的粘滞位。该陈述正确地指出了粘滞位保护的范围和局限性。\n**结论：正确。**\n\n**C. 在模式为 $0777$ 的 $D_o$ 中，只要 $u_B$ 对 $D_o$ 具有写和执行权限，就允许 $u_B$ `unlink` $f_A$，而与 $f_A$ 自身的文件模式位无关；因此，在 $D_o$ 中，仅基于 $f_A$ 权限的删除保护是无效的。**\n该陈述分析了目录 $D_o$ 中的行为，其模式为 $0777$（全局可写，无粘滞位）。要 `unlink` 一个文件，内核只检查用户是否对包含该文件的目录拥有写和执行权限。\n1.  $u_B$ 是否对 $D_o$ 拥有写和执行权限？是的，根据模式 $0777$。\n2.  是否设置了粘滞位？没有。\n因此，不会进行进一步的检查。$u_B$ 可以 `unlink` $D_o$ 内的任何文件，无论谁拥有该文件或该文件自身的权限是什么。该陈述中“与 $f_A$ 自身的文件模式位无关”是 POSIX 权限的一个基本原则。其结论是，在全局可写目录（没有粘滞位）中，仅靠文件权限不足以提供删除保护，这是准确的。这正是粘滞位被设计出来要修复的漏洞。\n**结论：正确。**\n\n**D. $D_s$ 上的粘滞位阻止 $u_B$ 在 $D_s$ 中创建指向其他敏感路径的符号链接；因此，符号链接重定向攻击被粘滞位所阻止。**\n该陈述不正确。在目录中创建任何类型的文件（包括普通文件、目录和符号链接）仅需要对该目录的写和执行权限。粘滞位只限制对非用户所有的现有条目的删除和重命名。由于 $D_s$ 的模式是 $1777$，用户 $u_B$ 拥有创建新条目所必需的 `w` 和 `x` 权限。粘滞位对此创建行为没有任何限制。因此，$u_B$ 可以在 $D_s$ 中自由创建符号链接，粘滞位并不能阻止这种形式的攻击。\n**结论：不正确。**\n\n**E. `unlink` $f_A$ 的权限检查是针对 $f_A$ 的模式位执行的；因此，如果 $f_A$ 对 $u_B$ 不可写，那么即使在一个全局可写的目录中，$u_B$ 也无法 `unlink` 它。**\n该陈述描述了一种常见但错误的对 POSIX 权限的理解。`unlink` 系统调用从目录中移除一个名称到 inode 的链接；它是对目录的操作，而不是对文件内容或元数据的操作。因此，`unlink` 的权限检查是针对目录的权限（需要 `w` 和 `x`）执行的，而不是文件的权限。文件自身的权限是无关紧要的。粘滞位的全部目的就是为了在共享目录中弥补这一事实。如果没有粘滞位，就像在 $D_o$ 中一样，$u_B$ 确实可以 `unlink` $f_A$（如果它在 $D_o$ 中的话），尽管 $f_A$ 本身对 $u_B$ 是不可写的。\n**结论：不正确。**", "answer": "$$\\boxed{ABC}$$", "id": "3673293"}, {"introduction": "一旦恶意软件开始执行，其首要任务之一就是“隐身”，即伪装成正常的系统活动以逃避检测。本练习引导您从静态的文件保护转向对动态进程行为的分析，像一名数字取证专家一样思考。您将学习如何审查进程树中的微妙异常——例如，不寻常的父子关系、长期存在的僵尸进程、或伪装成内核线程的用户进程——并利用如控制组（cgroups）等现代操作系统特性提供的上下文信息，来精确区分合法的复杂系统行为与恶意的欺骗手段。[@problem_id:3673363]", "problem": "一个多租户类 Linux 操作系统 (OS) 的管理员正在调查一种试图隐藏在进程树中的隐蔽恶意软件。请考虑在数小时内从一台主机上收集到的以下观察结果，其中每条进程记录包含进程标识符 (PID)、父进程标识符 (PPID)、命令名称、可执行文件路径和基本元数据（用户标识符、cgroup 和进程状态）。下面所有的时间和标识符都是代表性的，并且在内部与典型的 POSIX 进程语义保持一致。\n\n- 观察 $1$：一些短暂存在的编译器或 shell 辅助进程偶尔会因为其父进程繁忙（例如，由于高输入/输出）而以僵尸进程的形式出现大约 $0.02$ 秒。它们会立即被回收。这些情况罕见且短暂。\n- 观察 $2$：一个容器内（例如，“tini”）PID 为 $2600$ 的轻量级 init 进程通过父进程设置（使用进程控制标志）被配置为一个子收割者（subreaper），以便该容器内的孤儿进程由这个子收割者收养，而不是由主机的 init 进程收养。此容器中的所有进程都属于该容器专用的控制组 (cgroup) 层次结构（例如，某个容器 slice 下的一个路径）。\n- 观察 $3$：一个名为 “daemonX” 的受监控服务通过主机服务管理器启动，并使用双 fork 模式。祖父进程是服务管理器，在父进程退出后，最终的守护进程的 PPID 为 $1$，但它被标记并归属于正确的系统服务单元 cgroup。\n- 观察 $4$：一个名为 “ksoftirqd/0” 的用户空间进程以 PPID $1$ 运行了 $2$ 小时，所有者是一个非特权用户。其可执行文件路径显示为“(deleted)”，其内存映射表明一个用户空间可执行文件已从文件系统中取消链接但仍保持加载状态。它不属于任何已知的服务单元 cgroup，也不在任何容器 cgroup 内。\n- 观察 $5$：一个用户启动的 “python” 进程（PID 为 $5000$）未能对其几个子进程调用 wait 系列的系统调用。这些子进程作为僵尸进程持续存在超过 $5$ 分钟，并随着负载增加而累积。父进程继续运行但不回收它们。\n\n您必须决定哪种审计策略最有效地突显出真正可疑的、指示隐蔽行为的进程树异常（例如持久性僵尸进程和被滥用于隐藏的不寻常父子关系），同时最大限度地减少来自预期行为（例如短暂的僵尸进程、合法的守护进程化和容器子收割者）的不必要噪音。\n\n请仅使用以下关于进程管理和审计的基础事实作为您的出发点：\n\n- 进程创建和替换：子进程通过类似 fork 或 clone 的机制创建，并随后可能通过执行系统调用替换其地址空间；父子链接通过 PPID 记录。\n- 进程终止和回收：当一个进程终止时，其退出状态与其 PID 保持关联，直到父进程通过 wait 系列的系统调用收集它；在此期间，该进程是一个僵尸进程。\n- 孤儿进程收养：如果父进程在子进程之前终止，子进程就成为孤儿进程，并由 PID 为 $1$ 的进程或指定的子收割者收养；这对于双 fork 的守护进程以及配置了子收割者的容器上下文是预期的行为。\n- 内核线程没有用户空间可执行文件；模仿内核线程命名（例如，类似方括号的名称或已知内核线程的名称）但具有用户空间可执行文件映射的用户空间进程，如果没有被监控程序或容器上下文另外解释，则是可疑的。\n\n以下哪个选项实施的审计方法能够将观察 $4$ 和观察 $5$ 标记为可疑，同时抑制来自观察 $1$、观察 $2$ 和观察 $3$ 的噪音？\n\nA. 配置 Linux 审计子系统 (AUDIT) 以记录系统范围内所有的 fork、clone、执行和退出调用，不加过滤器。对任何时候观察到的任何僵尸进程、任何 PPID 等于 $1$ 的孤儿进程以及任何名称与内核线程名称相似的进程触发警报。不排除来自容器或受监控服务的事件。\n\nB. 使用附加到内核跟踪点（用于执行和退出）的扩展伯克利包过滤器 (eBPF) 程序来维护一个包含时间戳、用户标识符和 cgroup 成员关系的实时父子关系图。仅在以下情况触发警报：\n   - 一个进程名称匹配类似内核线程的模式或已知的内核线程名称，但该进程具有用户空间可执行文件映射或可执行文件路径（即使是“(deleted)”），持续时间超过阈值（例如，超过 $60$ 秒），并且不属于已知的服务单元 cgroup 或容器 cgroup。\n   - 一个僵尸进程持续时间超过阈值（例如，超过 $60$ 秒），并且其父进程仍然存活但未调用 wait，或者僵尸进程在短时间内累积超过一个小的计数阈值。抑制父进程是在高负载下已知的短暂构建者或辅助进程的事件。\n   - 对于不属于预期服务管理器 cgroup 且不属于容器子收割者 cgroup 的进程，发生了父进程重设为 PID $1$ 的情况。当收养父进程是指定的子收割者或当进程属于受监控的服务 cgroup 时，明确抑制重设父进程事件。\n\nC. 以 $5$ 分钟为间隔定期抽样进程列表，并标记任何名称包含字母“k”或“d”的进程、任何僵尸进程（无论存在时间长短）以及任何被 PID $1$ 收养的进程。为减少开销，不查阅 cgroup 或容器元数据。\n\nD. 仅审计与网络相关的系统调用和低编号端口绑定。当一个进程既绑定了低于 $1024$ 的端口又其 PPID 为 $1$ 时发出警报，前提是认为隐蔽进程通过特权网络服务寻求持久性。忽略进程生命周期事件以避免性能影响。\n\n选择唯一最佳选项。", "solution": "### 问题验证\n\n**步骤 1：提取已知信息**\n\n问题陈述提供了以下信息：\n\n*   **系统上下文：** 一个多租户类 Linux 操作系统 (OS)。\n*   **目标：** 调查隐藏在进程树中的隐蔽恶意软件。\n*   **数据源：** 进程记录，包含进程标识符 (PID)、父进程标识符 (PPID)、命令名称、可执行文件路径、用户标识符、控制组 (cgroup) 和进程状态。\n*   **观察 $1$：** 短暂存在（约 $0.02$ 秒）的僵尸进程（编译器/shell 辅助进程），源于繁忙的父进程，它们会立即被回收。被描述为罕见和瞬态。\n*   **观察 $2$：** 一个容器 init 进程（`tini`，PID $2600$）作为子收割者，收养其专用容器 cgroup 内的孤儿进程。\n*   **观察 $3$：** 一个受监控的服务（`daemonX`）使用双 fork 模式，导致最终的守护进程 PPID 为 1。该进程被正确关联到其系统服务单元 cgroup。\n*   **观察 $4$：** 一个名为 `ksoftirqd/0` 的用户空间进程以 PPID 1 运行了 $2$ 小时，所有者为非特权用户。其可执行文件路径为 `(deleted)`，其内存映射表明存在一个用户空间可执行文件。它不在任何已知的服务或容器 cgroup 中。\n*   **观察 $5$：** 一个 `python` 进程（PID $5000$）没有回收其子进程，导致它们作为僵尸进程持续存在超过 $5$ 分钟。\n*   **任务：** 识别能够将观察 $4$ 和 $5$ 标记为可疑，同时抑制来自观察 $1$、$2$ 和 $3$ 的噪音的审计策略。\n*   **基础事实：**\n    1.  进程创建涉及 `fork`/`clone` 和 `exec`；PPID 记录父子链接。\n    2.  终止的进程成为僵尸进程，直到其父进程通过 `wait` 系统调用回收它。\n    3.  孤儿进程由 PID 1 或指定的子收割者收养。这对于双 fork 的守护进程和容器上下文是预期的。\n    4.  内核线程没有用户空间可执行文件。一个伪装成内核线程的用户空间进程，如果没有被监控程序或容器上下文解释，就是可疑的。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n根据所需标准对问题陈述进行评估：\n\n*   **科学依据：** 该问题牢固地植根于 POSIX 兼容操作系统（如 Linux）的进程管理基本原则。PID、PPID、父子关系、僵尸进程、孤儿进程收养、init 进程 (PID 1)、子收割者、cgroups 和内核线程等概念都是现代操作系统理论和实践中的标准和明确定义的组成部分。所描述的场景是良性系统行为和潜在恶意软件技术（伪装、资源泄露、无文件执行）的现实表示。该问题在科学和技术上是合理的。\n*   **问题定义明確：** 问题结构清晰。它提出了一组五个不同的观察结果和一个清晰、明确的目标：找到一个审计策略，能正确地将这些观察结果分为两类（可疑：$4, 5$；良性：$1, 2, 3$）。是否存在解决方案取决于所提供的选项中是否有任何一个能够实现这种特定分类的逻辑。任务定义明确，并允许逻辑求解。\n*   **客观性：** 问题使用精确的技术术语（例如，`PPID`、`cgroup`、`subreaper`、`zombie`）进行描述。观察结果以事实数据点的形式呈现，没有主观解释或情感语言。问题是对不同技术策略功效的客观评估。\n*   **完整性和一致性：** 提供的信息是自包含的，足以评估选项。 “基础事实”提供了必要的理论框架，“观察”提供了具体的测试案例。提供的信息内部没有矛盾。\n*   **现实性和可行性：** 这些场景在 Linux 系统的系统管理和安全取证背景下非常现实。合法的守护进程化、容器化模式、瞬态系统负载问题以及恶意软件规避技术都是合理的。指定的审计方法（Linux 审计子系统、eBPF、定期抽样、网络调用审计）都是真实世界的工具和技术。\n\n**步骤 3：结论和行动**\n\n问题陈述是**有效的**。它具有科学依据，问题定义明确，客观且完整。我将继续推导解决方案。\n\n### 解决方案推导\n\n核心任务是设计一套规则，能够区分恶意或异常的进程行为与合法的、复杂的系统行为。一个成功的策略必须是细致入微的，利用上下文信息，而不是依赖于简单、绝对的规则。\n\n让我们分析正确分类每个观察结果需要什么：\n\n*   要抑制**观察 $1$**（瞬态僵尸进程）同时标记**观察 $5$**（持久性僵尸进程），策略必须包含一个**时间阈值**。存在时间少于几秒的僵尸进程应被忽略，而持续数分钟的僵尸进程应触发警报。\n*   要抑制**观察 $2$**（容器子收割者），策略必须认识到孤儿进程收养并非总是由 PID 1 执行。它需要了解子收割者机制，并且理想情况下，使用 **cgroup 成员关系**来确认父进程重设被限制在合法的容器上下文中。\n*   要抑制**观察 $3$**（合法守护进程），策略必须理解双 fork 模式，即进程被 PID 1 合法收养。关键的区别在于上下文，特别是该进程属于一个已知的、受监控的**系统服务 cgroup**。\n*   要标记**观察 $4$**（伪装进程），策略必须结合多个可疑指标。像“PPID 是 1”或“名称看起来像内核线程”这样的简单规则是不够的。一个健壮的规则应该是：`(名称匹配内核模式) AND (是用户空间进程) AND (不在合法的服务或容器 cgroup 中)`。`(deleted)` 的可执行文件路径是无文件恶意软件的另一个强烈指标。\n*   要标记**观察 $5$**（僵尸进程累积），策略必须如上所述，使用一个**时间阈值**来检测那些未被其父进程回收的僵尸进程。\n\n总之，理想的策略是状态化的（随时间跟踪进程）、上下文感知的（使用 cgroup 和用户元数据），并且基于多条件逻辑而非单一、嘈杂的指标。\n\n### 逐项分析选项\n\n**A. 配置 Linux 审计子系统 (AUDIT) 以记录系统范围内所有的 fork、clone、执行和退出调用，不加过滤器。对任何时候观察到的任何僵尸进程、任何 PPID 等于 $1$ 的孤儿进程以及任何名称与内核线程名称相似的进程触发警报。不排除来自容器或受监控服务的事件。**\n\n*   这个策略过于嘈杂，缺乏必要的复杂性。\n*   `“对任何时候观察到的任何僵尸进程触发警报”`：这条规则会错误地标记来自**观察 $1$** 的良性瞬态僵尸进程。\n*   `“任何 PPID 等于 $1$ 的孤儿进程”`：这条规则会错误地标记来自**观察 $3$** 的合法 `daemonX`。\n*   `“不排除来自容器或受监控服务的事件”`：这明确拒绝使用 cgroup 和其他上下文信息，而这些信息对于区分观察 $2$ 和 $3$ 中的良性和可疑行为至关重要。\n*   虽然此策略可能会标记观察 $4$ 和 $5$，但它会在来自观察 $1$ 和 $3$ 的大量误报中这样做，使其无效。\n*   **结论：错误**\n\n**B. 使用附加到内核跟踪点（用于执行和退出）的扩展伯克利包过滤器 (eBPF) 程序来维护一个包含时间戳、用户标识符和 cgroup 成员关系的实时父子关系图。仅在以下情况触发警报： ...**\n\n*   此策略使用强大、低开销的内核跟踪机制 (eBPF) 来收集所需的丰富上下文数据。让我们分析其规则：\n    *   **规则 1 (针对伪装)：** `一个进程名称匹配类似内核线程的模式 ... 但该进程具有用户空间可执行文件映射 ... 并且不属于已知的服务单元 cgroup 或容器 cgroup。` 这条规则是精确检测**观察 $4$** 中异常情况同时避免误报的公式。它正确地结合了名称、进程类型（用户空间 vs. 内核）和 cgroup 上下文。\n    *   **规则 2 (针对僵尸进程)：** `一个僵尸进程持续时间超过阈值（例如，超过 $60$ 秒）...` 这条规则使用时间阈值来正确标记**观察 $5$** 中的持久性僵尸进程，并正确忽略**观察 $1$** 中的瞬态僵尸进程。\n    *   **规则 3 (针对父进程重设)：** `对于不属于预期服务管理器 cgroup 且不属于容器子收割者 cgroup 的进程，发生了父进程重设为 PID $1$ 的情况。当收养父进程是指定的子收割者或当进程属于受监控的服务 cgroup 时，明确抑制重设父进程事件。` 这个逻辑精确地过滤掉了来自**观察 $2$** (子收割者) 和**观察 $3$** (`daemonX` 在服务 cgroup 中) 的合法父进程重设事件，确保只有可疑的父进程重设 (如**观察 $4$** 中) 被标记。\n*   这种方法满足了推导中确定的所有要求。它正确地标记了观察 $4$ 和 $5$，同时正确地抑制了观察 $1$、$2$ 和 $3$。\n*   **结论：正确**\n\n**C. 以 $5$ 分钟为间隔定期抽样进程列表，并标记任何名称包含字母“k”或“d”的进程、任何僵尸进程（无论存在时间长短）以及任何被 PID $1$ 收养的进程。为减少开销，不查阅 cgroup 或容器元数据。**\n\n*   这个策略粗糙且无效。\n*   `$5$` 分钟的抽样间隔太长，可能会错过重要事件。\n*   规则 `“名称包含字母'k'或'd'”` 荒谬地宽泛，会产生大量误报（例如 `systemd`、`dockerd`、`worker` 等），包括错误标记来自**观察 $3$** 的良性 `daemonX`。\n*   规则 `“任何僵尸进程（无论存在时间长短）”` 是有缺陷的，因为它不区分瞬态状态和持久性问题。如果抽样恰好与 $0.02$ 秒的窗口重合，它会错误地标记**观察 $1$**。\n*   规则 `“任何被 PID $1$ 收养的进程”` 太宽泛，会错误地标记**观察 $3$** 中的合法守护进程。\n*   明确决定 `“不查阅 cgroup 或容器元数据”` 表明未能使用必要的上下文，这保证了高误报率。\n*   **结论：错误**\n\n**D. 仅审计与网络相关的系统调用和低编号端口绑定。当一个进程既绑定了低于 $1024$ 的端口又其 PPID 为 $1$ 时发出警报，前提是认为隐蔽进程通过特权网络服务寻求持久性。忽略进程生命周期事件以避免性能影响。**\n\n*   这个策略完全与问题定义不符。\n*   问题描述的是**进程生命周期**中的异常（僵尸进程、父子关系、伪装）。此选项提议 `“忽略进程生命周期事件”`，使其从根本上无法检测指定的现象。\n*   它做出了一个未经证实的假设，即恶意软件是面向网络的。**观察 $4$** 中的恶意软件或**观察 $5$** 中的错误可能根本没有网络活动。因此，该策略将无法检测到它们。这种方法是在寻找另一类威胁，与提供的信息无关。\n*   **结论：错误**", "answer": "$$\\boxed{B}$$", "id": "3673363"}, {"introduction": "实时防护是操作系统安全的重要组成部分，但在与恶意软件的对抗中，时机就是一切。本练习聚焦于一种被称为“检查时-使用时”（Time Of Check To Time Of Use, TOCTTOU）的竞态条件漏洞，即恶意软件在文件被安全软件扫描之后、被合法程序使用之前对其进行篡改。通过评估多种操作系统内核级别的设计方案，例如写时复制（copy-on-write）快照和内容哈希验证，您将探索如何从架构上弥合这一关键的安全窗口，确保安全防御机制本身的完整性。[@problem_id:3673324]", "problem": "一个操作系统 (OS) 实现了访问时反病毒扫描，即当一个进程尝试读取或执行文件内容时，操作系统会通知一个反病毒守护进程，该守护进程在允许读取或执行操作继续之前扫描内容。当反病毒程序在时间 $t_c$ 扫描内容，而进程在之后的时间 $t_u$ ($t_c  t_u$) 使用内容时，就会出现“检查时到使用时”(TOCTTOU) 竞态问题。在此期间，并发修改或路径操纵可能导致使用的字节与扫描的字节不同。考虑一个支持原子重命名、硬链接、并发写入、共享页面缓存和内存映射 I/O 的文件系统。设文件在时间 $t$ 的内容表示为 $C(t)$，并设 $H(\\cdot)$ 为一个抗碰撞的密码学哈希函数。当反病毒程序的决策基于 $C(t_c)$，但进程使用的是 $C(t_u)$ 且 $C(t_u) \\neq C(t_c)$ 时，就会发生“扫描过时内容”的情况。操作系统旨在通过在适当的内核边界添加钩子或约束来减少或消除此类扫描过时内容的情况，而不假设用户空间的完美协作。\n\n下列哪种操作系统级设计能最有效地确保进程使用的字节与反病毒程序扫描的字节相同，或在使用时得到重新验证，并且能抵御路径别名和并发写入？\n\nA. 通过写时复制 (copy-on-write)，为反病毒程序提供一个由内核颁发的、针对已打开对象的不可变快照句柄，并用内容版本标识符 $v$ 进行标记。进程随后的读取或执行操作在内核中被绑定到同一个快照（如果内容发生偏离则拒绝操作），因此进程使用的字节与反病毒程序扫描的字节完全相同。\n\nB. 按路径名和粗粒度修改时间戳为键来缓存扫描批准，在打开文件前按路径进行扫描。如果路径名和时间戳未改变，则允许读取或执行，无需进一步检查。\n\nC. 将批准绑定到密码学内容哈希：操作系统在扫描时向反病毒程序暴露 $H(C(t_c))$，并在使用时重新计算并比较 $H(C(t_u))$。如果 $H(C(t_u)) \\neq H(C(t_c))$，操作系统在使用前会阻止操作或重新扫描。\n\nD. 添加一个用户空间写通知钩子：当任何进程向文件写入时，内核异步通知反病毒程序重新扫描，但并不因为该重扫而阻止读取或执行操作，也不阻止扫描期间的并发写入或路径交换。\n\nE. 密封页面缓存中的页面：操作系统确保进程映射和读取的页面与反病毒程序先前为同一文件描述符检查过的页面缓存中的页面完全相同。如果有任何写入会弄脏一个已检查的页面，操作系统会使该映射无效，并强制在进程继续读取或执行这些字节之前进行重新验证。\n\n选择所有适用项。", "solution": "### 问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n#### 步骤 1：提取已知信息\n\n问题提供了以下信息和定义：\n-   一个操作系统 (OS) 实现了访问时反病毒扫描。\n-   当一个进程尝试从文件中读取或执行内容时，会通知一个反病毒守护进程在操作继续前扫描内容。\n-   “检查时到使用时”(TOCTTOU) 竞态是一个问题。\n-   反病毒程序在时间 $t_c$ 扫描内容。\n-   进程在时间 $t_u$ 使用内容，其中 $t_c  t_u$。\n-   并发修改或路径操纵可能导致使用的字节与扫描的字节不同。\n-   文件系统支持：原子重命名、硬链接、并发写入、共享页面缓存和内存映射 I/O。\n-   $C(t)$ 是文件在时间 $t$ 的内容。\n-   $H(\\cdot)$ 是一个抗碰撞的密码学哈希函数。\n-   如果反病毒程序的决策基于 $C(t_c)$，但进程消费的是 $C(t_u)$ 且 $C(t_u) \\neq C(t_c)$，则发生“扫描过时内容”。\n-   目标是让操作系统通过内核级钩子或约束来减少或消除扫描过时内容的情况，而不假设用户空间的完美协作。\n-   问题询问哪种设计能最有效地确保进程使用的字节与扫描的字节相同，或在使用时得到重新验证，并且能有效抵御路径别名和并发写入。\n\n#### 步骤 2：使用提取的已知信息进行验证\n\n-   **科学性：**该问题牢固地植根于既定的计算机科学原理，特别是操作系统安全。TOCTTOU 是一类有充分文档记录的竞态条件漏洞。所提及的文件系统特性和操作系统组件（页面缓存、内存映射 I/O、硬链接、反病毒钩子）都是标准且现实的。该问题是一个真实世界安全工程挑战的形式化表示。\n-   **适定性：**问题定义清晰。它建立了一个明确的安全目标（防止使用与扫描内容不符的内容）和约束条件（操作系统级解决方案，对特定攻击的鲁棒性）。它要求根据此目标评估提议的设计，这是一项适定的任务。通过分析可以得出有意义的解决方案。\n-   **客观性：**语言精确且技术性强，使用的术语如“原子重命名”、“抗碰撞的密码学哈希函数”和“页面缓存”都具有其在计算机科学中的标准含义。评估标准是客观的：即一个设计在维持已检查状态和已使用状态之间一致性方面的有效性。\n\n#### 步骤 3：结论与行动\n\n问题陈述是有效的。它具有科学性、适定性和客观性。我将继续推导解决方案。\n\n### 解决方案推导\n\n问题的核心是设计一种操作系统级的机制，以关闭检查（在 $t_c$ 扫描）和使用（在 $t_u$ 读取/执行）之间的时间窗口。一个有效的解决方案必须防止进程消费与反病毒程序验证过的内容 $C(t_c)$ 不同的文件内容 $C(t_u)$。即使存在对文件数据的并发写入和对文件路径的操纵（通过 `rename` 或 `hard links` 进行路径别名），此保证也必须成立。该解决方案必须由内核强制执行，因为用户空间的行为者是不可信的。\n\n现在我将分析每个提议的设计。\n\n#### A. 通过写时复制 (copy-on-write)，为反病毒程序提供一个由内核颁发的、针对已打开对象的不可变快照句柄，并用内容版本标识符 $v$ 进行标记。进程随后的读取或执行操作在内核中被绑定到同一个快照（如果内容发生偏离则拒绝操作），因此进程使用的字节与反病毒程序扫描的字节完全相同。\n\n**分析：**该方法通过使检查对象从消费进程的角度看是不可变的，从而直接解决了问题。\n1.  **绑定：**检查是针对特定的文件对象，而不是路径。在时间 $t_c$ 创建一个不可变句柄（例如，基于与特定 inode 和版本绑定的文件描述符）。这种绑定对路径别名是鲁棒的；重命名路径不会影响一个已经打开的文件对象。\n2.  **不可变性：**使用写时复制（COW）快照确保了在快照创建后（在 $t_c$）任何对文件的写入尝试都会导致新数据块的创建。绑定到快照句柄的原始进程将继续从 $t_c$ 时刻读取原始的、未修改的、已扫描的数据块。所使用的内容 $C(t_u)$ 被保证与扫描的内容 $C(t_c)$ 完全相同。\n3.  **内核强制执行：**整个机制——创建快照、将进程绑定到快照、以及管理 COW 逻辑——都由内核处理，满足了对操作系统级解决方案的要求。\n\n**结论：正确**。这是一个在概念上清晰且高效的设计，用于消除此场景下的 TOCTTOU 漏洞。\n\n#### B. 按路径名和粗粒度修改时间戳为键来缓存扫描批准，在打开文件前按路径进行扫描。如果路径名和时间戳未改变，则允许读取或执行，无需进一步检查。\n\n**分析：**这个设计有两个根本性的缺陷。\n1.  **基于路径而非对象：**将批准与*路径名*挂钩使其易受路径别名攻击。恶意行为者可以将在 `/path/to/target` 的良性文件进行扫描并获得批准。然后，在检查和使用之间，攻击者可以使用 `atomic rename` 将 `/path/to/target` 替换为恶意文件。受害进程打开 `/path/to/target`，操作系统看到该路径名的批准已被缓存，从而错误地允许访问新的恶意内容。\n2.  **粗粒度检查：**“粗粒度修改时间戳”是不够的。一个快速的攻击者可以在检查和使用之间修改文件并恢复旧的时间戳。即使没有时间戳操纵，检查时间戳和随后的使用也不是一个原子操作，为并发写入更改内容留下了竞态窗口。\n\n**结论：不正确**。这是一个教科书级别的易受 TOCTTOU 攻击的实现。\n\n#### C. 将批准绑定到密码学内容哈希：操作系统在扫描时向反病毒程序暴露 $H(C(t_c))$，并在使用时重新计算并比较 $H(C(t_u))$。如果 $H(C(t_u)) \\neq H(C(t_c))$，操作系统在使用前会阻止操作或重新扫描。\n\n**分析：**该设计利用密码学原语来验证内容完整性。\n1.  **完整性保证：**一个抗碰撞的哈希函数 $H(\\cdot)$ 确保对内容 $C$ 的任何更改都将以极高的概率产生不同的哈希值。通过在检查时计算哈希值（$H(C(t_c)))$ 并在使用前重新计算它（$H(C(t_u))$），内核可以验证内容是否未被更改。如果 $C(t_u) \\neq C(t_c)$，那么 $H(C(t_u)) \\neq H(C(t_c))$ 将被检测到。\n2.  **鲁棒性：**此检查是在要使用的实际内容上执行的，而不是在路径或时间戳等元数据上。因此，它能免疫路径别名攻击并检测任何并发写入。\n3.  **内核强制执行：**操作系统内核负责在 $t_u$ 时计算哈希值，并将其与来自 $t_c$ 的已批准哈希值进行比较。这是一种操作系统级机制。主要挑战是性能，因为每次读取都对文件进行哈希计算可能会很慢。然而，该设计在功能上是有效的。例如，操作系统可以在数据读入内存时按页进行哈希和检查，这使其更具实用性。\n\n**结论：正确**。这是一个非常强大且有效的设计，确保了数据在检查和使用之间的完整性。\n\n#### D. 添加一个用户空间写通知钩子：当任何进程向文件写入时，内核异步通知反病毒程序重新扫描，但并不因为该重扫而阻止读取或执行操作，也不阻止扫描期间的并发写入或路径交换。\n\n**分析：**这个设计提供了信息但没有强制执行。\n1.  **异步通知：**对反病毒程序的通知是异步的。请求读取/执行的进程不会被阻塞以等待重新扫描。\n2.  **竞态条件：**一个恶意的写入可能发生，紧接着另一个进程进行读取或执行。内核发送一个通知，但读取/执行操作是并发进行的。恶意内容的“使用”发生在“检查”（重新扫描）完成甚至开始之前。问题陈述明确指出操作系统“并不因为该重扫而阻止读取或执行操作”，这意味着竞态窗口仍然大开。\n\n**结论：不正确**。该机制未能解决 TOCTTOU 问题，因为它没有在数据的使用与其验证状态之间建立绑定依赖关系。\n\n#### E. 密封页面缓存中的页面：操作系统确保进程映射和读取的页面与反病毒程序先前为同一文件描述符检查过的页面缓存中的页面完全相同。如果有任何写入会弄脏一个已检查的页面，操作系统会使该映射无效，并强制在进程继续读取或执行这些字节之前进行重新验证。\n\n**分析：**该设计在内存管理层面操作，这是一个执行此类安全策略的非常有效的地方。\n1.  **细粒度强制执行：**强制执行的单位是内存页面，这是 I/O 和内存映射的基本单位。检查（扫描）是在操作系统的共享页面缓存中的页面上执行的。\n2.  **在使用点绑定：**进程对文件数据的访问（通过 `read()` 或内存映射 I/O）是由页面缓存介导的。通过“密封”一个已批准的页面，内核保证进程正在访问的正是被扫描过的确切物理内存。\n3.  **写入时失效：**该设计的关键部分是内核拦截任何试图修改“密封”页面的写操作。一旦发生此类尝试，内核会破坏密封，使进程对该页面的访问无效，并强制进行重新验证（重新扫描）。这将数据的修改与其安全批准的失效原子性地联系起来，从而关闭了 TOCTTOU 窗口。这对并发写入是鲁棒的。\n4.  **对路径别名的鲁棒性：**该机制作用于文件描述符及其相关的内核数据结构（如底层文件对象的页面缓存条目），而不是路径名。因此，它不易受路径别名攻击。\n\n**结论：正确**。这是一个实用且高效的内核级设计，通过在页面级别、直接在使用点强制执行验证状态，正确地解决了问题。", "answer": "$$\\boxed{ACE}$$", "id": "3673324"}]}