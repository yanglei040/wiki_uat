{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式就是实践。本节的第一个练习将带你回到最基础也最常见的场景：一个类似 Unix 的系统中的自主访问控制（DAC）。通过这个思想实验，你将实践权限撤销的核心原则——即访问权限是在操作发生的瞬间根据用户当前的凭证动态检查的，而不是一个一成不变的属性。这个练习将帮助你澄清关于用户组身份变更如何即时影响其文件访问能力的常见误解。[@problem_id:3619218]", "problem": "一个操作系统实现了自主访问控制 (DAC)、强制访问控制 (MAC) 和基于角色的访问控制 (RBAC)。在典型的类 Unix 系统上，自主访问控制 (DAC) 使用所有者、组和其他人权限位，而目录上的设置组ID (SGID) 位会导致在该目录中创建的新文件继承该目录的组。在 DAC 下，进程对文件系统对象的有效访问权限是通过将进程的凭证（用户标识符和组标识符集）与对象的所有权字段进行比较，然后应用适当的权限类别来确定的：如果进程的用户标识符等于所有者，则使用所有者位；如果进程的任何组标识符等于文件的组，则使用组位；否则使用其他人位。此外，系统使用进程创建掩码 (umask) 在文件创建时清除某些权限位。强制访问控制 (MAC) 可以根据标签和策略进一步限制访问，而基于角色的访问控制 (RBAC) 按角色而不是身份或组来分配权限；然而，对于本实验，假设 MAC 没有强制执行任何额外的约束，并且 RBAC 没有配置为覆盖 DAC。\n\n设计并评估以下受控实验，旨在演示当 SGID 目录导致新文件继承组时，撤销组成员资格如何影响有效权利。\n\n设置：\n- 有两个用户，$u_{alice}$ 和 $u_{bob}$，以及一个组 $G_{dev}$。\n- 目录 $D = \\text{/proj/dev}$ 的所有者是 $u_{alice}$，组是 $G_{dev}$，其模式为 `2775`（前导的 `2` 在目录上设置了 SGID 位，因此模式为 `rwxrwxr-x`）。除了模式位之外，不存在访问控制列表 (ACL) 条目。两个用户的进程的 umask 均为 `002`。\n- 在时间 $t_1$，$u_{bob}$ 是 $G_{dev}$ 的成员，并进行身份验证以获取反映当前组成员资格的最新凭证。\n- 在时间 $t_1$，$u_{alice}$ 通过调用 $\\text{open}(\\text{\"}f_1\\text{\"}, O\\_CREAT)$ 并在请求模式为 `0666` 的情况下，在目录 $D$ 内创建文件 $f_1$。由于 umask 为 `002`，实际模式变为 `0664`；因为 $D$ 设置了 SGID，所以 $f_1$ 的组变为 $G_{dev}$，$f_1$ 的所有者是 $u_{alice}$。\n- 在 $t_1$ 之后，$u_{bob}$ 没有打开到 $f_1$ 的文件描述符，并且除了标准凭证外没有缓存任何能力。\n- 在时间 $t_2$，管理员撤销了 $u_{bob}$ 在 $G_{dev}$ 中的成员资格，并强制 $u_{bob}$ 重新进行身份验证，以确保其进程凭证反映了此次撤销。\n- 在时间 $t_3 > t_2$，$u_{alice}$ 在目录 $D$ 内创建文件 $f_2$，请求模式为 `0666`；由于 umask 为 `002`，实际模式为 `0664`，并且由于 $D$ 上的 SGID， $f_2$ 的组是 $G_{dev}$，所有者是 $u_{alice}$。\n- 在时间 $t_4 > t_3$，$u_{bob}$ 尝试以下操作：写入 $f_1$，写入 $f_2$，以及在 $D$ 中以请求模式 `0666` 创建一个新文件 $f_3$。\n\n假设：\n- 没有活动的强制访问控制 (MAC) 标签或策略会超出 DAC 的范围来拒绝或允许访问。\n- 没有对 $u_{bob}$ 生效的、会覆盖 DAC 结果的基于角色的访问控制 (RBAC) 角色。\n- 在 $D$、$f_1$ 或 $f_2$ 上没有设置超出标准模式位的 POSIX ACL。\n- 所有访问检查都在每次操作时发生；特别是，$u_{bob}$ 在 $t_2$ 之前没有为写入而打开 $f_1$。\n\n在时间 $t_4$ 观察到的下列哪组结果，正确地展示了在这些条件下撤销 $u_{bob}$ 在 $G_{dev}$ 中成员资格的效果？\n\nA. 在 $t_1$ 撤销之前，$u_{bob}$ 可以通过 $G_{dev}$ 组写入 $f_1$；在 $t_2$ 撤销并重新认证后，$u_{bob}$ 不能写入 $f_1$，不能写入 $f_2$，也不能在 $D$ 中创建 $f_3$。\n\nB. $u_{bob}$ 在撤销后仍然可以写入 $f_1$，因为 SGID 位将组写权限“固定”到 $D$ 中的文件上；$u_{bob}$ 不能写入 $f_2$，但可以创建 $f_3$，因为 SGID 无论组成员资格如何都授予创建权限。\n\nC. 撤销只影响未来的文件：$u_{bob}$ 保留对 $f_1$ 的写访问权限，但失去对 $f_2$ 的写访问权限；创建 $f_3$ 仍然被允许，因为 $u_{bob}$ 在 $t_1$ 时曾是 $G_{dev}$ 的成员。\n\nD. 即使没有配置基于角色的访问控制 (RBAC) 来覆盖 DAC，在 $t_2$ 撤销 $u_{bob}$ 在 $G_{dev}$ 中的成员资格也不会因 SGID 而影响对 $f_1$ 或 $f_2$ 的 DAC 结果；$u_{bob}$ 可以写入 $f_1$ 和 $f_2$，并可以在 $D$ 中创建 $f_3$。", "solution": "问题描述了一个在类 Unix 操作系统上进行的受控实验，旨在测试在自主访问控制 (DAC) 策略下，组成员资格的撤销对文件访问权限的影响。分析需要精确应用 DAC 规则、目录上的设置组ID (SGID) 位以及进程创建掩码 (umask)。\n\n### 问题验证\n对提供的问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- **用户**: $u_{alice}$, $u_{bob}$\n- **组**: $G_{dev}$\n- **目录**: $D = \\text{/proj/dev}$\n    - 所有者: $u_{alice}$\n    - 组: $G_{dev}$\n    - 模式: `2775` (八进制)，即 $rwxrwxr-x$ 并设置了 SGID 位。\n- **Umask**: `002` (八进制)，对两个用户均适用。\n- **时间线和事件**:\n    - **$t_1$**: $u_{bob}$ 是 $G_{dev}$ 的成员，并拥有反映此成员资格的凭证。$u_{alice}$ 在 $D$ 中创建文件 $f_1$，请求模式为 `0666`。由于 umask 为 `002`，最终文件模式为 `0664`，所有者为 $u_{alice}$，组为 $G_{dev}$（因 $D$ 上的 SGID）。$u_{bob}$ 没有持有到 $f_1$ 的打开文件描述符。\n    - **$t_2$**: $u_{bob}$ 在 $G_{dev}$ 中的成员资格被撤销。$u_{bob}$ 重新进行身份验证以更新其凭证。\n    - **$t_3$**: $u_{alice}$ 在 $D$ 中创建文件 $f_2$，请求模式为 `0666`。最终文件所有者为 $u_{alice}$，组为 $G_{dev}$，模式为 `0664`。\n    - **$t_4$**: $u_{bob}$ 尝试三个操作：写入 $f_1$，写入 $f_2$，在 $D$ 中创建 $f_3$。\n- **假设**: 没有覆盖性的 MAC 或 RBAC 策略，没有 POSIX ACL，访问检查在操作时执行。\n\n**步骤2：使用提取的已知条件进行验证**\n问题陈述具有科学依据，提法恰当且客观。它描述了操作系统安全中一个基于符合 POSIX 标准的文件系统语义的标准、可验证的场景。\n- 对 DAC、目录上的 SGID 和 umask 功能的描述是准确的，并与 Linux 等操作系统的既定原则相符。\n- 设置是自成一体的，提供了所有必要信息（用户、组、权限、操作）以推导出唯一的结果。\n- 问题没有矛盾。例如，根据请求模式和 umask 计算最终文件模式是正确的：有效权限为 `(requested_mode)  (~umask)`。对于请求模式 `0666` 和 umask `002`，计算为 $0666_8 \\text{  } (\\sim 0002_8) = 0666_8 \\text{  } 0775_8 = 0664_8$。\n- 语言精确且专业。\n\n**步骤3：结论和行动**\n问题陈述是**有效的**。可以推导出解决方案。\n\n### 解决方案的推导\n解决方案是通过分析每个文件系统对象的权限以及用户 $u_{bob}$ 在尝试访问时的凭证来推导出来的。\n\n**1. 对象权限分析**\n- **目录 $D = \\text{/proj/dev}$**:\n    - 权限：模式 `2775`。这给予所有者 ($u_{alice}$) $rwx$ 权限，组 ($G_{dev}$) $rwx$ 权限，其他人 $r-x$ 权限。前导的 `2` 设置了 SGID 位。在一个目录内创建文件，进程需要对该目录同时拥有写 ($w$) 和执行 ($x$) 权限。\n- **文件 $f_1$ (在 $t_1$ 创建)**:\n    - 所有者: $u_{alice}$\n    - 组: $G_{dev}$ (因 $D$ 的 SGID 而继承)\n    - 模式: `0664` ($rw-rw-r--$)。这给予所有者读/写 ($rw-$) 权限，组读/写 ($rw-$) 权限，以及其他人只读 ($r--$) 权限。\n- **文件 $f_2$ (在 $t_3$ 创建)**:\n    - 所有者: $u_{alice}$\n    - 组: $G_{dev}$\n    - 模式: `0664` ($rw-rw-r--$)。权限与 $f_1$ 相同。\n\n**2. 时间 $t_1$ 的访问分析 (撤销前)**\n在时间 $t_1$，$u_{bob}$ 的进程凭证包括 $G_{dev}$ 的成员资格。当访问 $f_1$ 时：\n- 进程 UID ($u_{bob}$) 与文件的所有者 UID ($u_{alice}$) 不匹配。\n- 一个进程 GID ($G_{dev}$) 与文件的组 GID ($G_{dev}$) 匹配。\n- 因此，使用组权限。对于 $f_1$，组权限是 $rw-$。\n- 结论：在 $t_1$ 时，$u_{bob}$ 可以读写 $f_1$。\n\n**3. 时间 $t_4$ 的访问分析 (撤销后)**\n在时间 $t_2$，$u_{bob}$ 在 $G_{dev}$ 中的成员资格被撤销，并且他重新进行了身份验证。在时间 $t_4$，由 $u_{bob}$ 运行的任何新进程都将拥有不包含 $G_{dev}$ 的凭证。访问检查在操作时 ($t_4$) 使用这些新凭证进行。\n\n- **尝试 1：写入文件 $f_1$**\n    - 目标: $f_1$ (所有者: $u_{alice}$, 组: $G_{dev}$, 模式: $rw-rw-r--$)\n    - $u_{bob}$ 的凭证：UID 是 $u_{bob}$，GIDs **不**包括 $G_{dev}$。\n    - 访问检查：\n        1. UID 匹配？否 ($u_{bob} \\neq u_{alice}$)。\n        2. GID 匹配？否 ($G_{dev}$ 不在 $u_{bob}$ 的 GID 集合中)。\n        3. 默认使用“其他人”权限。\n    - $f_1$ 的“其他人”权限是 $r--$。这不授予写权限。\n    - **结果**：写操作被拒绝。\n\n- **尝试 2：写入文件 $f_2$**\n    - 目标: $f_2$ (所有者: $u_{alice}$, 组: $G_{dev}$, 模式: $rw-rw-r--$)\n    - 访问检查与对 $f_1$ 的检查相同。$u_{bob}$ 不是所有者，也不在文件的组中，因此应用“其他人”权限。\n    - “其他人”权限是 $r--$。\n    - **结果**：写操作被拒绝。\n\n- **尝试 3：在目录 $D$ 中创建文件 $f_3$**\n    - 目标: $D$ (所有者: $u_{alice}$, 组: $G_{dev}$, 模式: $rwxrwxr-x$)\n    - 操作：创建文件需要对所在目录有写 ($w$) 和执行 ($x$) 权限。\n    - $u_{bob}$ 的凭证：不是所有者，不在组中。\n    - 访问检查：“其他人”权限适用。\n    - $D$ 的“其他人”权限是 $r-x$。这授予读和执行/搜索权限，但**不**授予写权限。\n    - **结果**：文件创建被拒绝。\n\n**结果总结：** 在 $t_4$ 时，$u_{bob}$ 不能写入 $f_1$，不能写入 $f_2$，也不能在 $D$ 中创建 $f_3$。撤销组成员资格，加上重新身份验证，有效且立即地移除了所有依赖于该组成员资格的访问权限。\n\n### 逐项分析选项\n\n- **A. 在 $t_1$ 撤销之前，$u_{bob}$ 可以通过 $G_{dev}$ 组写入 $f_1$；在 $t_2$ 撤销并重新认证后，$u_{bob}$ 不能写入 $f_1$，不能写入 $f_2$，也不能在 $D$ 中创建 $f_3$。**\n    - 第一部分是正确的，正如对时间 $t_1$ 的分析所示。\n    - 第二部分列出了在 $t_4$ 的结果，与我们的推导完全匹配：所有三个尝试的操作都失败了。\n    - **结论：正确。**\n\n- **B. $u_{bob}$ 在撤销后仍然可以写入 $f_1$，因为 SGID 位将组写权限“固定”到 $D$ 中的文件上；$u_{bob}$ 不能写入 $f_2$，但可以创建 $f_3$，因为 SGID 无论组成员资格如何都授予创建权限。**\n    - 这个选项基于对 SGID 的误解。目录上的 SGID 影响新文件的组所有权，它不会“固定”权限或覆盖基于当前凭证的标准 DAC 评估。根据推导，$u_{bob}$ 不能写入 $f_1$ 或创建 $f_3$。\n    - **结论：不正确。**\n\n- **C. 撤销只影响未来的文件：$u_{bob}$ 保留对 $f_1$ 的写访问权限，但失去对 $f_2$ 的写访问权限；创建 $f_3$ 仍然被允许，因为 $u_{bob}$ 在 $t_1$ 时曾是 $G_{dev}$ 的成员。**\n    - 这是不正确的。DAC 中的访问控制是动态的；它不依赖于文件的创建时间或历史上的组成员资格。权限在访问时进行检查。$u_{bob}$ 失去了对他所有依赖于 $G_{dev}$ 权限的文件的访问权，包括 $f_1$。他也不能创建 $f_3$。\n    - **结论：不正确。**\n\n- **D. 即使没有配置基于角色的访问控制 (RBAC) 来覆盖 DAC，在 $t_2$ 撤销 $u_{bob}$ 在 $G_{dev}$ 中的成员资格也不会因 SGID 而影响对 $f_1$ 或 $f_2$ 的 DAC 结果；$u_{bob}$ 可以写入 $f_1$ 和 $f_2$，并可以在 $D$ 中创建 $f_3$。**\n    - 这个选项声称撤销是无效的，这与事实恰恰相反。问题明确指出 $u_{bob}$ 重新进行了身份验证，这意味着他的凭证已更新。DAC 使用这些更新后的凭证。SGID 位与此访问检查无关。此选项中预测的三个结果都是错误的。\n    - **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3619218"}, {"introduction": "在掌握了基础的 DAC 模型后，我们来探讨一个更真实、更复杂的场景。这个练习引入了访问控制列表（ACLs），一种比传统权限位更灵活但也更复杂的机制。它揭示了一个在实际工作中很微妙但重要的问题：继承的默认 ACLs 如何在无意中破坏权限撤销的努力。通过解决这个问题，你将学会从目录级别进行整体策略设计，而不仅仅是针对单个文件进行操作，从而确保撤销的有效性。[@problem_id:3619191]", "problem": "在一个遵循可移植操作系统接口（POSIX）草案访问控制列表（ACL）语义的类 Unix 系统中，考虑一个项目目录，其中自主访问控制（DAC）管理着谁可以访问对象。该目录旨在允许项目组成员之间进行协作，同时排除一位特定的前协作者。您被告知以下事实。\n\n- 该目录名为 `/share`，具有用于组继承的设置组标识符（setgid）语义，其模式为 `2770`（即 `rwxrws---`）。其所属组为 `team`。用户 Bob 不是 `team` 组的成员。\n- `/share` 目录有一个默认访问控制列表（ACL），包含以下条目（概念性书写，非确切命令语法）：\n  - `default:user::rwx`\n  - `default:group::r-x`\n  - `default:other::---`\n  - `default:mask:r-x`\n  - `default:user:bob:r--`\n- Alice，一名 `team` 成员，其用户文件创建模式掩码（umask）为 `022`。她在 `/share` 中创建常规文件时请求的模式为 `0666`，创建目录时请求的模式为 `0777`，遵循通常的应用程序默认设置。\n- Alice 希望撤销 Bob 的访问权限。她通过执行一条命令，删除了现有文件 `old.txt` 中针对 `user:bob` 的单文件条目，从而明确地将 Bob 从该文件的 ACL 中移除。然后在同一次会话中，她在 `/share` 目录里创建了一个新文件 `new.txt`。\n\n基本原理：在 POSIX-like ACL 模型中的自主访问控制（DAC）下，目录的默认 ACL 会被新创建的文件和目录继承为其访问 ACL。文件上指定用户和组的有效权限受该文件的 ACL 掩码条目限制。如果父目录有默认掩码，则新文件的掩码会从该默认掩码继承；否则，掩码将从应用 umask 到请求模式后产生的文件模式的组类别中派生。umask 直接约束从请求模式计算出的基本权限位，但不会移除继承的指定用户或指定组 ACL 条目；这些条目受掩码的约束。\n\n问题：哪个选项既能正确解释为什么在对 `old.txt` 进行单文件权限撤销后，Bob 仍然可以读取新文件 `new.txt`，又能提出一个仅使用用户文件创建模式掩码（umask）和重新设计目录默认 ACL 的最小充分修复方案，使得未来的权限撤销对新创建的文件有效，且不破坏预期的团队访问权限？\n\nA. 解释：目录的默认 ACL 包含 `default:user:bob:r--`，因此每个新创建的文件都会继承一个 `user:bob` 条目，而继承的 `default:mask:r-x` 允许该读取权限，无论在别处进行的单文件权限撤销如何。修复：从 `/share` 中移除 Bob 的默认 ACL 条目，并确保默认 ACL 掩码只允许预期的组访问（例如，保留 `default:group::r-x` 和 `default:mask:r-x`，但没有 `default:user:bob`），并将 Alice 的 umask 收紧到 `027`。这样，在没有默认 ACL 的目录中，新创建文件的模式不会比所有者 `rw`、组 `r`、其他 `none` 更宽松（文件大约为 `0640`；目录大约为 `0750`），从而在保留团队访问权限的同时，防止 Bob 和其他非团队用户重新获得读取权限。\n\nB. 解释：`022` 的 umask 直接授予了 Bob 对新文件的读取权限。修复：将 umask 更改为 `077`，并保持目录的默认 ACL 不变。\n\nC. 解释：权限撤销失败是因为目录缺少粘滞位（sticky bit），该位允许其他用户绕过单文件 ACL 进行读取。修复：在 `/share` 上设置粘滞位，并移除 setgid 位。\n\nD. 解释：因为 DAC 是自主的，所以无法对未来的对象强制执行权限撤销。修复：用基于角色的访问控制（RBAC）或强制访问控制（MAC）替换 DAC，这样系统无论目录默认设置如何都会阻止 Bob。\n\nE. 解释：Bob 通过 `team` 组继承重新获得了访问权限。修复：将 Bob 从 `team` 组中移除；目录的 ACL 可以保持不变。\n\n选择唯一最佳选项。", "solution": "我们从自主访问控制（DAC）结合 POSIX-like 访问控制列表（ACL）、默认 ACL 继承以及用户文件创建模式掩码（umask）行为的基本原理出发。\n\n1) 定义与主导语义。\n\n- 在自主访问控制（DAC）下，对象的所有者可以自行决定授予或撤销访问权限，通常通过权限位和访问控制列表（ACL）来实现。\n- 目录可以拥有一个默认 ACL。当在该目录中创建新文件时，文件的访问 ACL 源自目录的默认 ACL。所有默认条目（default:user, default:group, default:mask, default:other, 以及任何 default:named-user 或 default:named-group）都会被新对象继承为其访问 ACL 条目，同时 default:mask 会被复制为文件的掩码。\n- ACL 掩码限制了授予任何指定用户条目（所有者除外）、所属组以及指定组的有效权限。因此，像 `user:bob:r--` 这样的条目会进一步受到掩码的限制；如果掩码是 `r-x`，Bob 的有效权限是 `r--` 和 `r-x` 的交集，结果仍然是 `r--`。\n- 值为 $u$ 的用户文件创建模式掩码（umask）将请求的模式 $m$ 转换为新文件或目录的基本权限模式 $(m \\text{  } (\\sim u))$。如果没有默认 ACL，这也决定了文件的组类别，并因此决定了掩码。如果存在默认 ACL 并指定了 `default:mask`，新文件将继承该掩码；umask 不会移除指定的 ACL 条目，也不会覆盖一个明确的默认 ACL 掩码。\n\n2) 将语义应用于该场景。\n\n- `/share` 目录具有 setgid 和模式 `2770` (`rwxrws---`)，属组为 `team`，并且其默认 ACL 包含 `default:user:bob:r--` 和 `default:mask:r-x`。Bob 不在 `team` 组中。\n- Alice 以请求模式 `0666` 和 umask `022` 创建了一个常规文件 `new.txt`，产生的基础模式为 $(0666 \\text{  } (\\sim 022)) = 0644$。然而，由于父目录有默认 ACL，新文件会继承该默认 ACL 作为其访问 ACL 条目。具体来说：\n  - 它继承了 `user:bob:r--`。\n  - 它继承了 `mask:r-x`。\n  - Bob 的有效权限是其指定用户条目与掩码的交集，即 $r-- \\wedge r-x = r--$。因此，Bob 可以读取 `new.txt`。\n- Alice 之前通过删除单文件 ACL 条目 `user:bob` 将 Bob 从 `old.txt` 的权限中移除了。该撤销操作仅对 `old.txt` 生效。在 `/share` 中创建的新文件将继续继承 Bob 的默认 ACL 条目，因此该撤销对新对象不具持久性。这是带有默认 ACL 的 DAC 的一个典型陷阱：撤销单个文件的 ACL 不会改变父目录的默认 ACL，因此新文件可能会重新授予访问权限。\n\n3) 使用 umask 和目录 ACL 重新设计进行修正。\n\n- 为防止 Bob 在 `/share` 中新创建的文件上重新获得访问权限，必须更改父目录的默认 ACL，使其不再授予 `user:bob` 任何权限。从 `/share` 中移除 `default:user:bob` 可以确保新文件不会继承该条目。保留 `default:group::r-x` 和 `default:mask:r-x` 可以维持预期的团队访问权限，同时继续将任何指定条目的有效权限限制在最多 `r-x`；由于没有为 Bob 设置指定条目，且他不在 `team` 组中，他将无法通过组或指定用户条目获得访问权限，而 `other::---` 则拒绝了通过其他用户的访问。\n- 为了在默认 ACL 之外或不存在默认 ACL 的情况下加强最小权限原则，Alice 还应将其 umask 从 `022` 调整到 `027`。对于文件，请求模式为 `0666` 时，$0666 \\text{  } (\\sim 027) = 0640$，给予所有者 `rw`、组 `r`、其他 `none` 的权限；对于目录，请求模式为 `0777` 时，$0777 \\text{  } (\\sim 027) = 0750$，给予所有者 `rwx`、组 `rx`、其他 `none` 的权限。这与团队的意图一致：团队成员（组）可以根据需要读取目录和文件，而非团队用户（包括 Bob）则不能读取。请注意，umask 不会覆盖明确的默认 ACL 掩码，但它能确保在没有默认 ACL 的目录中，或对于 Alice 创建的新目录，基本权限不会泄露给其他用户。\n\n4) 逐项分析选项。\n\n- 选项 A：此选项正确地指出了根本原因：目录的默认 ACL 包含 `default:user:bob:r--`，因此新文件继承了一个 `user:bob` 条目；`default:mask:r-x` 允许 Bob 的读取权限。它还提出了最小充分的 DAC 修复方案：移除 Bob 的默认条目，并保留一个能维持团队访问权限的默认 ACL 掩码和组条目；此外，将 umask 调整为 `027`，以便在缺少默认 ACL 的地方，创建的文件和目录具有限制性的基本权限。这仅使用了 umask 和目录 ACL 重新设计，并实现了既定目标。结论：正确。\n\n- 选项 B：此选项将问题归因于 umask `022`，并建议仅将 umask 更改为 `077` 而不改变默认 ACL。这是不够的。在存在包含 `default:user:bob` 和明确的 `default:mask` 的默认 ACL 的情况下，新文件会继承这两者，而与 umask 无关。umask 不会移除继承的指定用户条目，也不会覆盖明确的默认掩码；Bob 仍然会通过继承的 ACL 获得读取权限。结论：不正确。\n\n- 选项 C：此选项归咎于缺少粘滞位，并建议设置粘滞位并移除 setgid。粘滞位管理目录中的删除/重命名操作，而不是读取权限。移除 setgid 会改变组继承，但不会移除为 Bob 继承的指定用户 ACL 条目。这既不能解释观察到的读取行为，也不能修复它。结论：不正确。\n\n- 选项 D：此选项声称 DAC 无法对未来的对象强制执行权限撤销，并推荐使用基于角色的访问控制（RBAC）或强制访问控制（MAC）。虽然 MAC 可以取代 DAC 并可用于执行策略，但 DAC 在此无法强制执行撤销的前提是错误的；问题源于配置错误的默认 ACL，而非 DAC 的内在局限。该问题可以在 DAC 框架内通过重新设计默认 ACL 和调整 umask 来解决，如选项 A 所述。结论：不正确。\n\n- 选项 E：此选项断言 Bob 通过 `team` 组重新获得访问权限，并建议将 Bob 从该组中移除。场景中说明 Bob 不是 `team` 组的成员。他的访问权限来自 `default:named-user` 条目。这既不能解释该行为，也未提供相关修复方案。结论：不正确。\n\n因此，正确的选择是移除 Bob 的 `default:named-user` 条目，保留一个合适的默认掩码和组条目以维持团队访问，并收紧 umask 以避免在其他地方产生意外权限，即选项 A。", "answer": "$$\\boxed{A}$$", "id": "3619191"}, {"introduction": "现在，让我们将视角从自主访问控制（DAC）转向强制访问控制（MAC）。这个编码练习要求你基于著名的 Bell-LaPadula 模型来模拟一个安全系统，并探索权限撤销在现实中的复杂性。你将看到，系统实现的一些细节，例如异步 I/O 操作，可能会在权限撤销策略之外创建隐蔽的信道，导致信息泄露。这项实践强调了一个关键点：系统的安全性不仅取决于访问控制模型本身，更依赖于其严谨细致的实现。[@problem_id:3619227]", "problem": "考虑一个强制执行安全增强型 Linux (Security-Enhanced Linux, SELinux) 强制访问控制 (Mandatory Access Control, MAC) 的云虚拟机。将系统建模为一个具有三个有序级别 $L_1 \\le L_2 \\le L_3$ 的保密格。主体 (容器) 和客体 (挂载卷) 被标记为 $L_1$、$L_2$ 或 $L_3$ 三个级别之一。操作系统强制执行 Bell–LaPadula 保密规则：级别为 $\\ell_s$ 的主体仅在 $\\ell_s \\ge \\ell_o$ (不上读) 时才能读取级别为 $\\ell_o$ 的客体，并且仅在 $\\ell_s \\le \\ell_o$ (不下写) 时才能写入客体。假设卷可以以只读或读写方式挂载，并且对只读挂载的写入尝试，无论标签如何，都将被拒绝。\n\n假设在时间 $T_r$ 应用了一项管理撤销，该撤销立即拒绝整个系统中由级别为 $L_2$ 的主体发起的所有写入操作。读取操作仍受原始 Bell–LaPadula 规则的管辖，并且不是本任务的重点。考虑到写入系统调用可能会在数据持久化之前在内存中进行缓冲，并且挂载卷可以选择性地具有“不安全的异步刷新”属性。如果刷新是由不安全的异步机制发起的，缓冲的写入可能会在时间 $T_r$ 之后被持久化，而无需查询当前主体的权限。相反，由主体发起的标准刷新被视为一次写入操作，必须遵守 Bell–LaPadula 规则和撤销策略。\n\n对以下操作语义进行建模：\n- 在时间 $t$，从主体 $s$ 到客体 $o$ 的写入事件（数据单元为 $d$）仅在挂载为读写模式且写入操作在时间 $t$ 被 Bell–LaPadula 规则允许时，才会将每个主体-客体对的缓冲区增加 $d$；此外，如果由于撤销导致 $t \\ge T_r$ 且 $\\ell_s = L_2$，则写入失败。\n- 在时间 $t$，针对主体 $s$ 和客体 $o$ 的刷新事件会将 $\\langle s,o\\rangle$ 的全部缓冲量提交到客体，并将缓冲区清零。标准刷新必须在时间 $t$ 满足 Bell–LaPadula 写入规则，此外，如果 $t \\ge T_r$ 且 $\\ell_s = L_2$，则刷新失败。不安全的异步刷新会忽略当前权限；它会在时间 $t$ 提交缓冲区，而不考虑撤销策略和 Bell–LaPadula 规则。\n- 将泄露状态定义为由于在时间 $t \\ge T_r$ 发生且可归因于级别为 $L_2$ 的主体的刷新事件而持久化的总数据单元。形式上，令 $B_{s,o}(t)$ 为在时间 $t$ 刷新前一刻 $\\langle s,o\\rangle$ 的缓冲区，令 $\\mathrm{commit}(s,o,t)$ 为如果在时间 $t$ 的刷新持久化了缓冲区，则其值为 $B_{s,o}(t)$，否则为 $0$。一次追踪的泄露量为 $$\\mathrm{Leak} = \\sum_{\\text{flush events }(s,o,t)} \\left[ \\mathbf{1}(t \\ge T_r) \\cdot \\mathbf{1}(\\ell_s = L_2) \\cdot \\mathrm{commit}(s,o,t) \\right],$$ 其中 $\\mathbf{1}(\\cdot)$ 是指示函数。\n\n你的程序必须模拟以下测试套件。在所有情况下，都恰好有三个标签分别为 $\\ell(C_1)=L_1$、$\\ell(C_2)=L_2$、$\\ell(C_3)=L_3$ 的容器，以及三个标签分别为 $\\ell(V_1)=L_1$、$\\ell(V_2)=L_2$、$\\ell(V_3)=L_3$ 的卷。时间是离散的，以整数步长 $t \\in \\mathbb{Z}_{\\ge 0}$ 计量，$T_r$ 是一个整数。未明确提及的挂载对主体不可用（在写入检查时被视为只读）。\n\n测试用例 1 (正常路径，安全挂载，无泄露)：\n- 撤销时间：$T_r = 3$。\n- $C_2$ (即 $L_2$ 容器) 的挂载：$V_1$ 读写且安全，$V_2$ 读写且安全，$V_3$ 读写且安全。\n- 按时间顺序的事件：\n  - 在 $t=1$ 时，$C_2$ 向 $V_2$ 写入 $d=10$ 个数据单元。\n  - 在 $t=2$ 时，$C_2$ 对 $V_2$ 执行标准刷新。\n  - 在 $t=4$ 时，$C_2$ 尝试向 $V_3$ 写入 $d=5$ 个数据单元。\n  - 在 $t=5$ 时，$C_2$ 对 $V_3$ 执行标准刷新。\n- 预期行为是：在撤销前（$t=1$ 和 $t=2$）的写入和刷新成功，而在 $t \\ge T_r$ 时针对 $C_2$ 的操作被拒绝，产生 $\\mathrm{Leak} = 0$。\n\n测试用例 2 (不安全的异步刷新导致泄露)：\n- 撤销时间：$T_r = 3$。\n- $C_2$ 的挂载：$V_2$ 读写且不安全异步；$C_2$ 的其他挂载缺失。\n- 按时间顺序的事件：\n  - 在 $t=1$ 时，$C_2$ 向 $V_2$ 写入 $d=8$ 个数据单元。\n  - 在 $t=4$ 时，对 $C_2$ 的 $V_2$ 发生一次不安全的异步刷新。\n- 预期行为是：在 $t=1$ 时的写入被缓冲，而在 $t=4$ 时的不安全异步刷新会提交缓冲区（尽管已被撤销），产生 $\\mathrm{Leak} = 8$。\n\n测试用例 3 (边界情况：下写被拒绝，撤销后刷新被拒绝，无泄露)：\n- 撤销时间：$T_r = 3$。\n- $C_2$ 的挂载：$V_1$ 读写且安全，$V_3$ 读写且安全。\n- 按时间顺序的事件：\n  - 在 $t=1$ 时，$C_2$ 尝试向 $V_1$ 写入 $d=4$ 个数据单元。\n  - 在 $t=2$ 时，$C_2$ 向 $V_3$ 写入 $d=7$ 个数据单元。\n  - 在 $t=4$ 时，$C_2$ 对 $V_3$ 执行标准刷新。\n- 预期行为是：在 $t=1$ 时的下写操作被 Bell–LaPadula 规则拒绝，在 $t=2$ 时的上写操作被缓冲，而在 $t=4$ 时的撤销后刷新被拒绝，产生 $\\mathrm{Leak} = 0$。\n\n你的任务是实现一个完整的程序，模拟这三个测试用例，并根据上述规则计算每个用例的泄露值 $\\mathrm{Leak}$。你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 $[\\mathrm{Leak}_1,\\mathrm{Leak}_2,\\mathrm{Leak}_3]$，其中 $\\mathrm{Leak}_i$ 是为测试用例 $i$ 计算出的泄露值。不涉及物理单位；所有量（如时间和数据单元）均为整数。输出必须与指定格式完全匹配。", "solution": "该问题要求模拟一个由 Bell–LaPadula 强制访问控制 (MAC) 模型管理的系统，该系统增加了特定的管理撤销策略和两种类型的数据刷新机制。我们必须为三个不同的测试场景计算总数据泄露量。泄露被定义为在撤销期间或之后，由安全级别为 $L_2$ 的主体持久化的总数据单元。\n\n首先，我们为抽象的安全级别建立一个具体的表示：让有序级别 $L_1 \\le L_2 \\le L_3$ 分别由整数 $1$、$2$ 和 $3$ 表示。因此，对于容器 (主体) 有 $\\ell(C_1)=1$、$\\ell(C_2)=2$、$\\ell(C_3)=3$，对于卷 (客体) 有 $\\ell(V_1)=1$、$\\ell(V_2)=2$、$\\ell(V_3)=3$。\n\n系统的状态由一组缓冲区中的数据量定义，每个主体-客体对 $\\langle s,o \\rangle$ 都有一个缓冲区，记为 $B_{s,o}$。当数据在泄露公式中列出的特定条件下从缓冲区提交到持久存储时，就会发生泄露：\n$$\n\\mathrm{Leak} = \\sum_{\\text{flush events }(s,o,t)} \\left[ \\mathbf{1}(t \\ge T_r) \\cdot \\mathbf{1}(\\ell_s = L_2) \\cdot \\mathrm{commit}(s,o,t) \\right]\n$$\n该公式仅在刷新事件的时间 $t$ 大于或等于撤销时间 $T_r$ 且主体 $s$ 的安全级别 $\\ell_s = L_2$ 时，才累积提交的数据 $\\mathrm{commit}(s,o,t)$。\n\n我们通过逐个事件模拟每个测试用例，并应用给定的操作语义。\n\n**访问控制规则分析**\n\n1.  **写入操作许可：** 在时间 $t$ 从主体 $s$ 到客体 $o$ 的写入操作仅在满足以下所有条件时才被允许：\n    *   挂载为读写模式。\n    *   满足 Bell–LaPadula “不下写”规则：$\\ell_s \\le \\ell_o$。\n    *   未触发撤销规则：即并非 ($t \\ge T_r$ 且 $\\ell_s = L_2$)。\n\n2.  **标准刷新操作许可：** 标准刷新被视为一次写入操作。它仅在时间 $t$ 满足以下所有条件时才被允许：\n    *   挂载为读写模式。\n    *   满足 Bell–LaPadula “不下写”规则：$\\ell_s \\le \\ell_o$。\n    *   未触发撤销规则：即并非 ($t \\ge T_r$ 且 $\\ell_s = L_2$)。\n\n3.  **不安全的异步刷新操作：** 这种刷新类型“忽略当前权限”，并总能成功提交缓冲区的内容。\n\n**测试用例 1 模拟**\n\n*   **设置：** $T_r = 3$。容器 $C_2$ (级别 $\\ell(C_2)=2$) 对 $V_1$ (级别 $\\ell(V_1)=1$)、$V_2$ (级别 $\\ell(V_2)=2$) 和 $V_3$ (级别 $\\ell(V_3)=3$) 具有读写、安全的挂载。所有缓冲区初始为零。\n*   **$t=1$：** $C_2$ 向 $V_2$ 写入 $d=10$。\n    *   检查权限：挂载为读写模式。Bell–LaPadula 规则 $\\ell(C_2) \\le \\ell(V_2)$ 变为 $2 \\le 2$，为真。时间 $t=1  T_r=3$，因此撤销不适用。\n    *   **结果：** 写入被**允许**。缓冲区 $B_{C_2, V_2}$ 变为 $10$。\n*   **$t=2$：** $C_2$ 对 $V_2$ 执行标准刷新。\n    *   检查权限：挂载为读写模式。规则 $2 \\le 2$ 为真。时间 $t=2  T_r=3$，因此撤销不适用。\n    *   **结果：** 刷新被**允许**。$\\mathrm{commit}(C_2, V_2, 2) = 10$。缓冲区 $B_{C_2, V_2}$ 被重置为 $0$。\n    *   泄露检查：事件时间 $t=2$ 在 $T_r=3$ 之前，因此指示函数 $\\mathbf{1}(t \\ge T_r)$ 为 $0$。对泄露的贡献为 $0$。\n*   **$t=4$：** $C_2$ 尝试向 $V_3$ 写入 $d=5$。\n    *   检查权限：挂载为读写模式。规则 $\\ell(C_2) \\le \\ell(V_3)$ 变为 $2 \\le 3$，为真。但是，时间 $t=4 \\ge T_r=3$ 且主体级别为 $\\ell(C_2)=2$。撤销规则适用。\n    *   **结果：** 写入被**拒绝**。缓冲区 $B_{C_2, V_3}$ 保持为 $0$。\n*   **$t=5$：** $C_2$ 对 $V_3$ 执行标准刷新。\n    *   检查权限：时间 $t=5 \\ge T_r=3$ 且 $\\ell(C_2)=2$。撤销规则适用。\n    *   **结果：** 刷新被**拒绝**。$\\mathrm{commit}(C_2, V_3, 5) = 0$。\n    *   泄露检查：由于提交量为 $0$，对泄露的贡献为 $0$。\n*   **用例 1 的最终泄露量：** $\\mathrm{Leak}_1 = 0$。\n\n**测试用例 2 模拟**\n\n*   **设置：** $T_r = 3$。容器 $C_2$ (级别 $\\ell(C_2)=2$) 有一个挂载：$V_2$ (级别 $\\ell(V_2)=2$)，读写且不安全异步。所有缓冲区初始为零。\n*   **$t=1$：** $C_2$ 向 $V_2$ 写入 $d=8$。\n    *   检查权限：挂载为读写模式。规则 $2 \\le 2$ 为真。时间 $t=1  T_r=3$。\n    *   **结果：** 写入被**允许**。缓冲区 $B_{C_2, V_2}$ 变为 $8$。\n*   **$t=4$：** 对 $C_2$ 的 $V_2$ 发生一次不安全的异步刷新。\n    *   检查权限：不安全的刷新忽略所有权限，总是成功。\n    *   **结果：** 刷新被**允许**。$\\mathrm{commit}(C_2, V_2, 4) = 8$。缓冲区 $B_{C_2, V_2}$ 被重置为 $0$。\n    *   泄露检查：事件时间 $t=4 \\ge T_r=3$，因此 $\\mathbf{1}(t \\ge T_r) = 1$。主体是 $C_2$，其级别为 $\\ell(C_2)=2$，因此 $\\mathbf{1}(\\ell_s = L_2) = 1$。提交量为 $8$。对泄露的贡献是 $1 \\cdot 1 \\cdot 8 = 8$。\n*   **用例 2 的最终泄露量：** $\\mathrm{Leak}_2 = 8$。\n\n**测试用例 3 模拟**\n\n*   **设置：** $T_r = 3$。容器 $C_2$ (级别 $\\ell(C_2)=2$) 对 $V_1$ (级别 $\\ell(V_1)=1$) 和 $V_3$ (级别 $\\ell(V_3)=3$) 具有读写、安全的挂载。所有缓冲区初始为零。\n*   **$t=1$：** $C_2$ 尝试向 $V_1$ 写入 $d=4$。\n    *   检查权限：挂载为读写模式。Bell–LaPadula “不下写”规则 $\\ell(C_2) \\le \\ell(V_1)$ 变为 $2 \\le 1$，为假。\n    *   **结果：** 写入被**拒绝**。缓冲区 $B_{C_2, V_1}$ 保持为 $0$。\n*   **$t=2$：** $C_2$ 向 $V_3$ 写入 $d=7$。\n    *   检查权限：挂载为读写模式。规则 $\\ell(C_2) \\le \\ell(V_3)$ 变为 $2 \\le 3$，为真。时间 $t=2  T_r=3$。\n    *   **结果：** 写入被**允许**。缓冲区 $B_{C_2, V_3}$ 变为 $7$。\n*   **$t=4$：** $C_2$ 对 $V_3$ 执行标准刷新。\n    *   检查权限：时间 $t=4 \\ge T_r=3$ 且主体级别为 $\\ell(C_2)=2$。撤销规则适用。\n    *   **结果：** 刷新被**拒绝**。$\\mathrm{commit}(C_2, V_3, 4) = 0$。缓冲区 $B_{C_2, V_3}$ 保持为 $7$。\n    *   泄露检查：由于提交量为 $0$，对泄露的贡献为 $0$。\n*   **用例 3 的最终泄露量：** $\\mathrm{Leak}_3 = 0$。\n\n**结果总结**\n三个测试用例计算出的泄露值如下：\n*   测试用例 1: $\\mathrm{Leak}_1 = 0$\n*   测试用例 2: $\\mathrm{Leak}_2 = 8$\n*   测试用例 3: $\\mathrm{Leak}_3 = 0$\n这些值将格式化为逗号分隔的列表 $[0,8,0]$。", "answer": "$$\\boxed{[0,8,0]}$$", "id": "3619227"}]}