{"hands_on_practices": [{"introduction": "在基于块的存储系统中，内部碎片是一个重要的考量因素，它源于为数据分配的存储空间大于其实际大小。通过本练习，你将运用基本原理来量化两级目录系统中的这种空间开销，从而深入理解目录大小如何影响存储效率。[@problem_id:3689414]", "problem": "考虑一个操作系统（OS）中的2级目录系统，其中根目录正好包含 $U$ 个用户条目，每个用户目录正好包含 $F$ 个文件条目。目录内容存储在大小为 $B$ 字节的固定大小磁盘块中，目录条目由一个可变长度的名称和固定的元数据组成。可变长度名称的平均长度为 $L$ 字节，每个条目的固定元数据占用 $s$ 字节，因此为了估算，平均条目大小可以建模为 $L+s$ 字节。所有目录条目都连续打包，除了每个目录最后一个分配块中未使用的尾随字节外，没有其他间隙。每个目录占用整数个完整的块。\n\n使用基本定义，即基于块的存储对象中的内部碎片等于总分配容量与实际占用内容大小之差，并且存储 $S$ 字节内容所需的块数为 $\\lceil S/B \\rceil$，请从第一性原理出发，推导出一个封闭形式的解析表达式，用于表示根目录的内部碎片与单个用户目录的内部碎片之差，该表达式纯粹用 $B$、$L$、$s$、$U$ 和 $F$ 表示。请以最简封闭形式提供最终表达式。无需数值代入，也无需四舍五入。", "solution": "首先将根据所需标准对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- 系统类型：一个2级目录系统。\n- 根目录内容：正好 $U$ 个用户条目。\n- 用户目录内容：每个用户目录正好 $F$ 个文件条目。\n- 存储块大小：$B$ 字节。\n- 目录条目名称平均长度：$L$ 字节。\n- 每个条目的固定元数据大小：$s$ 字节。\n- 目录条目的平均总大小（模型）：$L+s$ 字节。\n- 分配规则：每个目录占用整数个完整的块。\n- 内部碎片的定义：总分配容量减去实际占用的内容大小。\n- 存储 $S$ 字节所需的块数公式：$\\lceil S/B \\rceil$。\n- 目标：推导根目录内部碎片与单个用户目录内部碎片之差的封闭形式解析表达式。\n- 表达式变量：$B$、$L$、$s$、$U$ 和 $F$。\n\n### 第 2 步：使用提取的已知条件进行验证\n对问题的有效性进行评估。\n- **科学依据**：该问题很好地基于操作系统设计的基本原理，特别是文件系统实现。多级目录、基于块的存储和内部碎片等概念是计算机科学中的标准主题。该模型虽然使用了平均条目大小进行了简化，但对于此类分析来说是一种常见且有效的方法。\n- **适定性**：该问题是适定的。它提供了所有必要的变量（$U$、$F$、$B$、$L$、$s$）以及计算空间需求（连续打包）和碎片的明确定义。目标陈述清晰，可以从给定信息中推导出唯一的解析解。\n- **客观性**：问题以客观、技术性的语言陈述，没有歧义或主观论断。\n\n该问题没有验证清单中列出的任何缺陷。它在科学上是合理的、可形式化的、完整的且结构良好。\n\n### 第 3 步：结论与行动\n问题有效。将从第一性原理推导解决方案。\n\n### 解题推导\n\n设 $\\text{Frag}(S, B)$ 表示大小为 $S$ 的数据对象存储在大小为 $B$ 的块中所产生的内部碎片。问题将分配的块数定义为 $N = \\lceil S/B \\rceil$。因此，总分配容量为 $N \\times B$。内部碎片是分配容量与实际内容大小之间的差值。\n\n$$ \\text{Frag}(S, B) = \\left( \\lceil \\frac{S}{B} \\rceil \\times B \\right) - S $$\n\n我们将把这个基本公式应用于根目录和单个用户目录。\n\n**1. 根目录的内部碎片**\n\n根目录包含 $U$ 个用户条目。每个条目的平均大小为 $L+s$ 字节。由于条目是连续打包的，根目录中内容的总大小 $S_{\\text{root}}$ 是条目数与每个条目平均大小的乘积。\n\n$$ S_{\\text{root}} = U (L+s) $$\n\n使用通用的碎片计算公式，根目录的内部碎片 $\\text{Frag}_{\\text{root}}$ 为：\n\n$$ \\text{Frag}_{\\text{root}} = \\left( \\lceil \\frac{S_{\\text{root}}}{B} \\rceil \\times B \\right) - S_{\\text{root}} $$\n$$ \\text{Frag}_{\\text{root}} = \\left( \\lceil \\frac{U(L+s)}{B} \\rceil \\times B \\right) - U(L+s) $$\n\n**2. 单个用户目录的内部碎片**\n\n同样，每个用户目录包含 $F$ 个文件条目。每个条目的平均大小相同，为 $L+s$ 字节。单个用户目录中内容的总大小 $S_{\\text{user}}$ 为：\n\n$$ S_{\\text{user}} = F (L+s) $$\n\n单个用户目录的内部碎片 $\\text{Frag}_{\\text{user}}$ 为：\n\n$$ \\text{Frag}_{\\text{user}} = \\left( \\lceil \\frac{S_{\\text{user}}}{B} \\rceil \\times B \\right) - S_{\\text{user}} $$\n$$ \\text{Frag}_{\\text{user}} = \\left( \\lceil \\frac{F(L+s)}{B} \\rceil \\times B \\right) - F(L+s) $$\n\n**3. 内部碎片的差值**\n\n问题要求推导根目录的内部碎片与单个用户目录的内部碎片之差，我们将其表示为 $\\Delta \\text{Frag}$。\n\n$$ \\Delta \\text{Frag} = \\text{Frag}_{\\text{root}} - \\text{Frag}_{\\text{user}} $$\n\n代入上面推导出的表达式：\n\n$$ \\Delta \\text{Frag} = \\left[ \\left( \\lceil \\frac{U(L+s)}{B} \\rceil B \\right) - U(L+s) \\right] - \\left[ \\left( \\lceil \\frac{F(L+s)}{B} \\rceil B \\right) - F(L+s) \\right] $$\n\n为了简化，我们将具有公因数 $B$ 的项和具有公因数 $(L+s)$ 的项组合在一起：\n\n$$ \\Delta \\text{Frag} = \\left( \\lceil \\frac{U(L+s)}{B} \\rceil B - \\lceil \\frac{F(L+s)}{B} \\rceil B \\right) - \\left( U(L+s) - F(L+s) \\right) $$\n\n提取公因数 $B$ 和 $(L+s)$：\n\n$$ \\Delta \\text{Frag} = B \\left( \\lceil \\frac{U(L+s)}{B} \\rceil - \\lceil \\frac{F(L+s)}{B} \\rceil \\right) - (U - F)(L+s) $$\n\n这个表达式就是内部碎片差值的封闭形式解析解，纯粹用给定的变量 $B$、$L$、$s$、$U$ 和 $F$ 表示。在没有对变量施加额外约束的情况下，无法进一步简化。这是最简封闭形式。", "answer": "$$\n\\boxed{B \\left( \\lceil \\frac{U(L+s)}{B} \\rceil - \\lceil \\frac{F(L+s)}{B} \\rceil \\right) - (U-F)(L+s)}\n$$", "id": "3689414"}, {"introduction": "在多进程环境中，确保操作的正确性和安全性至关重要，而“检查时-使用时”（Time Of Check to Time Of Use, TOCTOU）竞态条件是一个典型威胁。本练习将引导你分析一个文件创建过程中的安全漏洞，并思考如何利用原子操作从根本上解决此问题。这有助于你建立设计健壮、安全的系统所必需的思维模式。[@problem_id:3689375]", "problem": "考虑一个两级目录系统，其中根目录为每个用户包含一个目录。对于一个标识符为 $U$ 的用户，将其用户目录表示为 $D_U$，并将要创建的文件命名为 $N$。一个以有效用户标识符 $U$ 运行的程序 $P$ 打算在 $D_U$ 内创建文件 $N$。在当前的实现中，$P$ 执行两个独立的系统调用：首先在时间 $t_1$ 检查 $N$ 是否存在于 $D_U$ 内（使用存在性谓词 $E(D_U,N,t_1)$），然后，如果检查表明不存在，它在时间 $t_2$ 发出创建调用。另一个由攻击者控制的进程 $Q$ 可以在时间间隔 $(t_1,t_2)$ 内并发地修改 $D_U$ 中的目录项，可能会引入符号链接并更改 $N$ 的目标。这就引发了一个“检查时-使用时”(TOCTOU)漏洞：$P$ 基于 $E(D_U,N,t_1)$ 做出的决策在时间 $t_2$ 使用时可能已经失效。\n\n假设操作系统的以下基本定义和事实：\n- 如果一个操作在内核中作为单个不可分割的动作执行，那么该操作是原子的，因此没有其他进程可以在该操作期间观察到中间状态或交错执行冲突的更新。\n- 目录操作由内核的路径解析和访问控制来协调。令 $\\mathrm{owner}(D)$ 为目录 $D$ 的所有者标识符。令 $\\mathrm{perm}(U, D, \\mathrm{op})$ 为一个谓词，表示用户 $U$ 拥有对目录 $D$ 执行操作 $\\mathrm{op}$ 的权限。\n- 存在性谓词 $E(D,N,t)$ 在时间 $t$ 时，如果名为 $N$ 的目录项存在于目录 $D$ 中，则为真；它本身不区分文件类型（普通文件与符号链接）。\n- 符号链接遍历可以将路径解析重定向到 $D_U$ 之外的目标，除非被那些对于路径最后一部分不跟随符号链接的语义明确阻止。\n- 两级目录不变性要求每个用户文件路径的形式都为 $/users/U/N$，并且 $\\mathrm{owner}(D_U)=U$。\n\n您的任务是通过用原子创建语义替换两步的“检查后创建”过程，并指定必要的内核侧检查来消除TOCTOU漏洞，以强制执行两级目录不变性，避免符号链接重定向，并确保存在性测试和创建动作作为一个不可分割的操作发生。\n\n哪个选项最完整、最正确地指定了原子创建语义，并概述了足以在该两级目录系统中防止TOCTOU漏洞的内核侧检查？\n\nA. 通过使用仅目录标志打开 $D_U$ 来获取指向 $D_U$ 的目录文件描述符 $d$，然后使用“仅在文件不存在时才创建”和“禁止跟随作为最后一部分的符号链接”的标志，相对于 $d$ 调用单个原子创建操作来创建名为 $N$ 的文件。在内核中，相对于 $d$ 解析 $N$，验证 $\\mathrm{owner}(D_U)=U$ 和 $\\mathrm{perm}(U,D_U,\\mathrm{create})$，如果在操作的瞬间 $t$，$E(D_U,N,t)$ 为真则拒绝，阻止跟随作为最后一部分的符号链接，并在一个跨越存在性检查和插入的锁的保护下执行将 $N$ 插入 $D_U$ 的操作，如果该名称已存在则返回错误。\n\nB. 在用户空间循环：在时间 $t$ 通过状态调用检查 $E(D_U,N,t)$，如果没有找到条目则发出创建请求；如果因并发更改而失败，则重试。在内核中，仅依赖标准的访问控制列表（ACL）检查，并允许照常进行符号链接遍历。这确保了最终的成功，而无需特殊的原子语义。\n\nC. 在时间 $t_1$ 在 $D_U$ 中创建一个临时文件 $T$，然后在时间 $t_2$ 将 $T$ 原子性地重命名为 $N$。在内核中，允许重命名操作覆盖并发出现的 $N$，因为重命名是原子的。这避免了显式的存在性检查，因此消除了TOCTOU问题。\n\nD. 对绝对路径 $/users/U/N$ 使用单个创建调用，不带排他性创建标志。调用返回后，检查返回的文件描述符的元数据以确保它属于 $D_U$。在内核中，允许跟随路径最后一部分的符号链接，并依赖事后验证来捕捉错误重定向。\n\n选择最佳选项。", "solution": "用户请求对一个关于两级目录系统中“检查时-使用时”(TOCTOU)漏洞的问题进行严谨的分析。任务涉及验证问题陈述的有效性，如果有效，则推导出正确的解决方案并评估给定的选项。\n\n### 问题验证\n\n首先，对问题陈述进行关键性验证。\n\n#### 步骤1：提取已知条件\n\n问题陈述提供了以下信息：\n- **系统**：一个两级目录系统。根目录为每个用户包含一个目录。\n- **实体**：\n    - 用户标识符：$U$\n    - 用户目录：$D_U$（位于根目录下，例如 `/users/U`）\n    - 要创建的文件：$N$\n    - 一个以有效用户标识符 $U$ 运行的程序 $P$。\n    - 一个攻击者进程 $Q$。\n- **易受攻击的程序**：\n    - 在时间 $t_1$，程序 $P$ 使用谓词 $E(D_U,N,t_1)$ 检查 $N$ 在 $D_U$ 中是否存在。\n    - 如果检查表明不存在，$P$ 在时间 $t_2 > t_1$ 发出创建 $N$ 的调用。\n- **攻击者行为**：进程 $Q$ 可以在时间间隔 $(t_1, t_2)$ 内修改 $D_U$ 中的目录项。\n- **漏洞**：“检查时-使用时”(TOCTOU)。\n- **基本定义和事实**：\n    - **原子操作**：在内核中作为单个不可分割的动作执行的操作。\n    - **访问控制**：目录操作由内核协调。\n    - $\\mathrm{owner}(D)$：返回目录 $D$ 的所有者标识符的函数。\n    - $\\mathrm{perm}(U, D, \\mathrm{op})$：一个谓词，如果用户 $U$ 对目录 $D$ 有操作 $\\mathrm{op}$ 的权限，则为真。\n    - $E(D,N,t)$：一个谓词，如果在时间 $t$ 名为 $N$ 的条目存在于目录 $D$ 中，则为真。它不区分文件类型。\n    - **符号链接**：符号链接遍历可以重定向路径解析，除非被明确阻止。\n    - **系统不变性**：所有用户文件路径的形式都为 `/users/U/N$，并且 $\\mathrm{owner}(D_U)=U$。\n- **任务**：通过用原子操作替换两步过程来消除TOCTOU漏洞，指定必要的内核侧检查以强制执行不变性，防止符号链接重定向，并将存在性测试和创建合并为单个不可分割的操作。\n\n#### 步骤2：使用提取的已知条件进行验证\n\n- **科学上成立（关键）**：该问题描述了TOCTOU竞争条件，这是计算机安全中一个经典且根本的漏洞，特别是在操作系统文件管理的背景下。原子操作、权限、符号链接和目录结构等概念都是操作系统领域的标准和公认概念。该场景是用于教授安全编程实践的典型例子。该问题在科学上是合理的。\n- **定义明确**：该问题定义明确。它清楚地定义了初始的不安全状态和期望的安全状态。目标是确定能够正确和完整地实现此安全状态的机制集。基于已建立的操作系统设计原则，存在一个确定的解决方案。\n- **客观性（关键）**：该问题使用形式化和客观的语言陈述（例如，$U, D_U, N, t_1, t_2, E(D,N,t)$）。对系统行为的描述是技术性的，没有主观性或意见。\n- **其他缺陷**：问题陈述是自包含的、一致的，并提供了足够的信息来推断解决方案。它不存在任何列出的无效标准。\n\n#### 步骤3：结论和行动\n问题陈述是**有效的**。可以继续进行分析。\n\n### 解答推导\n\nTOCTOU漏洞的核心在于检查（在 $t_1$）和使用（在 $t_2$）之间的时间间隙。在此时间间隔 $(t_1,t_2)$ 内，攻击者可以改变文件系统的状态，使得“使用”操作所依据的前提失效。\n\n在这个特定场景中，“检查”是 $E(D_U,N,t_1)$ 为假，“使用”是在 $t_2$ 创建文件 $N$。例如，攻击者可以：\n1.  创建一个名为 $N$ 的普通文件。$P$ 随后的创建调用可能会失败或覆盖它，这取决于使用的标志。\n2.  创建一个名为 $N$ 的符号链接，指向一个敏感文件，例如系统配置文件或用户 $U$ 拥有的、程序 $P$ 有权写入的另一个文件。如果在 $t_2$ 的 `create` 操作跟随符号链接并具有覆盖语义（例如 `open(path, O_WRONLY | O_TRUNC)`），程序 $P$ 可能会无意中销毁链接的目标。\n\n为了消除这个漏洞，检查和使用必须被合并成一个由内核执行的单一**原子**操作。这个原子操作必须具备以下属性：\n1.  **原子性**：检查 $N$ 是否存在以及如果不存在则创建它的操作必须是不可分割的。这通常在内核中使用对父目录（$D_U$）数据结构的锁来实现。\n2.  **排他性**：如果条目 $N$ 已存在，操作必须失败。这直接实现了“如果不存在，则创建”的逻辑，并挫败了攻击者创建同名文件的竞争。在 POSIX 系统中，这种语义由 `open()` 系统调用的 `O_EXCL` 标志与 `O_CREAT` 结合提供。\n3.  **符号链接保护**：如果路径的最后一部分（即 $N$）存在符号链接，操作必须不跟随它。这可以防止操作被重定向到非预期位置的攻击。在 POSIX 中，这是通过 `O_NOFOLLOW` 标志实现的。\n4.  **稳定的目录引用**：为防止对目录 $D_U$ 本身的路径（例如，攻击者将 `/users/U` 替换为符号链接）产生竞争条件，最佳实践是首先获取一个指向目录 $D_U$ 的稳定句柄（一个文件描述符），然后相对于该句柄执行文件创建。POSIX 为此提供了 `openat()`。打开目录时应验证它确实是一个目录（例如，使用 `O_DIRECTORY` 标志）。\n5.  **不变性和权限强制**：在单一的原子内核操作中，仍必须执行所有必要的检查。这包括验证用户 $U$ 对目录 $D_U$ 具有创建权限（即 $\\mathrm{perm}(U,D_U,\\mathrm{create})$），以及任何系统特定的不变性（如 $\\mathrm{owner}(D_U)=U$）是否成立。\n\n一个完整且正确的解决方案必须体现所有这些原则。\n\n### 逐个选项分析\n\n现在，我们根据这组推导出的要求来评估每个选项。\n\n**A. 通过使用仅目录标志打开 $D_U$ 来获取指向 $D_U$ 的目录文件描述符 $d$，然后使用“仅在文件不存在时才创建”和“禁止跟随作为最后一部分的符号链接”的标志，相对于 $d$ 调用单个原子创建操作来创建名为 $N$ 的文件。在内核中，相对于 $d$ 解析 $N$，验证 $\\mathrm{owner}(D_U)=U$ 和 $\\mathrm{perm}(U,D_U,\\mathrm{create})$，如果在操作的瞬间 $t$，$E(D_U,N,t)$ 为真则拒绝，阻止跟随作为最后一部分的符号链接，并在一个跨越存在性检查和插入的锁的保护下执行将 $N$ 插入 $D_U$ 的操作，如果该名称已存在则返回错误。**\n\n该选项全面地解决了所有要求。\n- 它使用一个稳定的目录文件描述符 $d$，防止了对 $D_U$ 路径的竞争。\n- 它使用相对于 $d$ 的单个原子创建调用。\n- 它指定了排他性创建（“仅在文件不存在时才创建”）。\n- 它指定了针对符号链接攻击的保护（“禁止跟随作为最后一部分的符号链接”）。\n- 它正确地概述了内核侧的实现：验证所有权（$\\mathrm{owner}(D_U)=U$）和权限（$\\mathrm{perm}(U,D_U,\\mathrm{create})$），在锁的保护下执行存在性检查和创建（确保原子性），并在文件已存在时返回错误。\n这个选项与推导出的解决方案完全匹配。\n**结论：正确**\n\n**B. 在用户空间循环：在时间 $t$ 通过状态调用检查 $E(D_U,N,t)$，如果没有找到条目则发出创建请求；如果因并发更改而失败，则重试。在内核中，仅依赖标准的访问控制列表（ACL）检查，并允许照常进行符号链接遍历。这确保了最终的成功，而无需特殊的原子语义。**\n\n这个选项未能解决问题。\n- 它在一个循环中明确保留了非原子的“检查后行动”序列。漏洞窗口在每一次迭代中都存在。\n- 它没有“消除”漏洞，而是提出了一种恢复策略，如果攻击者是持久的，这可能导致活锁。\n- 关键的是，它声明“允许照常进行符号链接遍历”，这使得最危险的攻击向量敞开。一个带有写入/截断标志的 `open()` 调用仍然会跟随恶意链接并损坏目标文件。\n**结论：不正确**\n\n**C. 在时间 $t_1$ 在 $D_U$ 中创建一个临时文件 $T$，然后在时间 $t_2$ 将 $T$ 原子性地重命名为 $N$。在内核中，允许重命名操作覆盖并发出现的 $N$，因为重命名是原子的。这避免了显式的存在性检查，因此消除了TOCTOU问题。**\n\n这个选项使用了一个原子操作（`rename`），这对于某些原子更新是一个有效的模式。然而，在此上下文中它是有缺陷的。\n- 原始逻辑是“如果不存在，则创建”。这个选项将语义更改为“原子性地替换 $N$ 处的任何东西”。标准的 `rename` 语义规定，如果目标（$N$）存在，它将被解除链接（覆盖）。这与排他性创建是不同的行为。如果攻击者创建了一个合法的 $N$ 文件，这个过程会销毁它，这并非最初的意图。\n- 虽然 `rename` 通常不会在其目标处跟随符号链接（它会替换链接本身），但所提议的逻辑（“允许重命名覆盖 $N$”）与问题要求的*仅在文件不存在时*才创建文件的要求不符。它用一个问题（无条件覆盖）换了另一个问题（TOCTOU）。\n**结论：不正确**\n\n**D. 对绝对路径 $/users/U/N$ 使用单个创建调用，不带排他性创建标志。调用返回后，检查返回的文件描述符的元数据以确保它属于 $D_U$。在内核中，允许跟随路径最后一部分的符号链接，并依赖事后验证来捕捉错误重定向。**\n\n这个选项从根本上是不安全的，并且显示了对TOCTOU问题的误解。\n- 在操作*之后*执行检查（“事后验证”）被称为“使用时-检查时”(TOUTOC)漏洞。破坏性操作可能已经完成。例如，如果 `create` 调用是带有一个截断文件标志（`O_TRUNC`）的 `open()`，恶意符号链接的目标将在检查执行之前被清空。\n- 它通过“允许跟随路径最后一部分的符号链接”明确地允许了该漏洞。\n- 它不使用排他性创建标志，这意味着它会很乐意地打开攻击者植入的文件或链接。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3689375"}]}