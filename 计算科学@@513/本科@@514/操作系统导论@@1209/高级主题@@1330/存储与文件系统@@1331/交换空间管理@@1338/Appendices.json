{"hands_on_practices": [{"introduction": "要真正理解交换空间管理，亲手实现页面替换和交换槽回收算法的运作至关重要。本练习将指导您构建一个小型模拟器，以追踪页面的生命周期，并比较简单的先进先出（FIFO）策略与更智能的、基于优先级的策略。通过实现这些规则，您将对不同策略如何直接影响以页错误数量衡量的系统性能，获得具体而深入的理解。[@problem_id:3685067]", "problem": "您需要实现一个完整的、可运行的程序，该程序模拟一个玩具操作系统的交换空间管理和页面替换行为。该模拟器必须量化管理物理页框和交换槽的队列策略如何影响在给定页面引用轨迹下的磁盘页面换入错误总数。下文精确指定了场景、参数、规则和所需的输出格式。\n\n基本基础包括以下来自操作系统的标准定义和事实：内存访问指向一个虚拟页面；一个物理页框可以容纳一个页面；当引用的页面不存在于物理页框中时，会发生缺页错误，必须从辅助存储中调入该页面；当驻留页面的数量等于页框的数量时，必须选择一个页面进行替换以释放一个页框。模拟器必须实现两种备选的队列策略：先进先出（FIFO）和一种理想化的优先级方案，该方案使用未来使用距离来优先保留将更快被重用的页面。对于轨迹中位置为 $i$ 的页面，其未来使用距离是最小的正整数 $d$，使得同一页面在位置 $i + d$ 再次出现；如果它不再出现，则距离为 $+\\infty$。该优先级方案总是优先驱逐具有最大未来使用距离的驻留页面（平局情况由最早的加载时间确定性地打破），这是用于比较研究的一个明确定义的理想化模型。\n\n您必须为每个测试用例模拟两种配置：\n- 配置 A (FIFO/FIFO)：物理页框作为 FIFO 队列进行替换管理，交换槽在满时作为 FIFO 队列进行回收管理。\n- 配置 B (PRIO/PRIO)：物理页框通过一个优先级规则进行管理，该规则会驱逐具有最大未来使用距离的驻留页面；交换槽在满时通过移除具有最大未来使用距离的换出页面来进行回收。\n\n交换空间管理模型如下。共有 $U$ 个交换槽。当一个页面从内存中被驱逐时，如果有可用空间，它会占用一个交换槽；如果所有 $U$ 个槽都已使用，则必须根据当前配置中的交换队列策略丢弃一个已换出的页面以释放一个槽。如果一个非驻留页面被引用，无论它是否在交换空间中，都会导致一次磁盘页面换入错误。模拟器必须只计算磁盘页面换入错误的数量，即每次引用当前非驻留的页面时计为一次；命中不增加此计数。没有预取，也没有显式的释放事件；唯一的事件是轨迹中的页面引用。\n\n基于这些基本原理，为模拟器实现以下精确规则：\n- 有 $F$ 个物理页框。最初，所有页框都为空，交换空间也为空。\n- 对于轨迹索引 $i$ 处对页面 $p_i$ 的每次引用：\n  - 如果 $p_i$ 驻留在 $F$ 个页框之一中，则为命中，不计错误。\n  - 否则，页面换入错误计数 $+1$。如果驻留页面的数量小于 $F$，则将 $p_i$ 加载到一个空闲页框中。否则，选择一个驻留页面进行驱逐：\n    - 在配置 A 中，驱逐在内存中停留时间最长的驻留页面（基于加载时间的 FIFO）。\n    - 在配置 B 中，驱逐从索引 $i$ 算起其未来使用距离最大的驻留页面；如果多个页面平局，则驱逐其中最早加载的那个。\n  - 驱逐页面时，如果存在空闲交换槽，则将其放入一个交换槽中；否则，通过移除以下页面来回收一个交换槽：\n    - 在配置 A 中，移除在交换空间中停留时间最长的已换出页面（FIFO）。\n    - 在配置 B 中，移除从索引 $i$ 算起其未来使用距离最大的已换出页面；如果多个页面平局，则确定性地移除任何一个。\n  - 如果 $p_i$ 恰好存在于某个交换槽中，在将其加载到内存时，从交换空间中移除它；这不改变错误计数。\n\n您的程序必须精确实现上述逻辑，并为每个测试用例的每种配置生成页面换入错误的总数。\n\n测试套件。使用以下测试用例；对于每个用例，$F$ 是页框数，$U$ 是交换槽数，sequence 是作为整数有序列表的页面引用轨迹。以下所有数字都必须解释为页面或容量，而不是物理单位。\n\n- 测试 $1$：$F = 3$，$U = 2$，序列 $[1,2,3,4,1,2,3,4]$。\n- 测试 $2$：$F = 2$，$U = 1$，序列 $[1,2,1,3,1,2,1,3]$。\n- 测试 $3$：$F = 2$，$U = 2$，序列 $[1,2,1,2,1,2]$。\n- 测试 $4$：$F = 5$，$U = 3$，序列 $[1,2,3,4,1,2,3,4,2,3,1]$。\n- 测试 $5$：$F = 2$，$U = 0$，序列 $[1,2,3,2,1,2,3,2]$。\n\n您的程序必须为每个测试用例计算配置 A 和配置 B 下的错误总数，并按此顺序排列。最终输出格式要求为单行，包含一个整数列表的列表，其中每个内部列表按上述顺序对应一个测试用例，并包含两个整数：$[\\text{faults}_\\text{FIFO}, \\text{faults}_\\text{PRIO}]$。例如，输出格式必须与 \"[ [a,b],[c,d],[e,f],[g,h],[i,j] ]\" 完全一样，除了示例中逗号和括号使用的空格外，不含其他空格。您的程序必须精确地生成这样一行格式，并且不得读取任何输入。", "solution": "该问题要求实现一个模拟器，用于模拟一个玩具操作系统的页面替换和交换空间管理。该模拟必须针对五个测试用例进行，每个用例在两种不同的配置下运行，并且必须报告每次运行的页面换入错误总数。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **核心实体**：虚拟页面、物理页框、交换槽。\n- **每个测试用例的参数**：\n    - $F$：物理页框的数量。\n    - $U$：交换槽的数量。\n    - `sequence`：一个页面引用轨迹（一个整数的有序列表）。\n- **关键定义**：当引用的页面未驻留在物理页框中时，发生一次缺页错误，并计数为 $+1$。\n- **初始状态**：所有 $F$ 个页框和 $U$ 个交换槽都为空。\n- **事件**：在轨迹索引 $i$ 处引用页面 $p_i$。\n- **命中逻辑**：如果 $p_i$ 在一个页框中，则为命中；不计错误。\n- **错误逻辑**：\n    1. 错误计数 $+1$。\n    2. 如果页框未满（驻留页面数 $ F$），将 $p_i$ 加载到一个空闲页框中。\n    3. 如果页框已满，根据配置的替换策略选择一个牺牲页面进行驱逐。\n- **驱逐逻辑**：\n    1. 当一个页面从页框中被驱逐时，它被放入一个交换槽中。\n    2. 如果交换空间已满（已交换的页面数 $= U$），必须根据配置的回收策略从交换空间中丢弃一个页面。\n- **与交换空间的交互**：如果一个被引用的页面 $p_i$（导致了错误）在交换槽中被找到，它在被加载到内存时会从交换空间中移除。这不会改变错误计数。\n- **未来使用距离**：对于轨迹中位置 $i$ 的一个页面，其未来使用距离是最小的正整数 $d$，使得同一页面在位置 $i+d$ 再次出现。如果它永不再次出现，则距离为 $+\\infty$。\n- **配置 A (FIFO/FIFO)**：\n    - 页框替换：驱逐具有最早加载时间（先进先出）的驻留页面。\n    - 交换空间回收：丢弃具有最早换入交换空间时间（FIFO）的已换出页面。\n- **配置 B (PRIO/PRIO)**：\n    - 页框替换：驱逐从当前轨迹索引 $i$ 算起具有最大未来使用距离的驻留页面。平局通过驱逐具有最早加载时间的页面来打破。\n    - 交换空间回收：丢弃从当前轨迹索引 $i$ 算起具有最大未来使用距离的已换出页面。平局情况确定性地打破。\n- **测试套件**：\n    - 测试 $1$：$F = 3$，$U = 2$，序列 $[1,2,3,4,1,2,3,4]$。\n    - 测试 $2$：$F = 2$，$U = 1$，序列 $[1,2,1,3,1,2,1,3]$。\n    - 测试 $3$：$F = 2$，$U = 2$，序列 $[1,2,1,2,1,2]$。\n    - 测试 $4$：$F = 5$，$U = 3$，序列 $[1,2,3,4,1,2,3,4,2,3,1]$。\n    - 测试 $5$：$F = 2$，$U = 0$，序列 $[1,2,3,2,1,2,3,2]$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于操作系统中基本且公认的概念，包括虚拟内存、分页、缺页错误、FIFO 替换、最优替换（此处通过 PRIO 方案理想化）以及交换空间管理。它在科学上是合理的。\n- **定义明确**：该问题定义明确。初始状态、转换规则和终止条件（轨迹结束）都已精确定义。每个测试用例的参数都已提供。平局打破规则确保了每次模拟都有一个唯一的、确定性的结果。\n- **客观性**：问题以精确、正式和客观的语言陈述，没有歧义或主观声明。\n- **完整性与一致性**：所有必要的信息（$F, U$、轨迹、规则）都已提供。规则内部一致，不包含矛盾。例如，缺页错误的定义是明确的，处理命中、错误和驱逐的程序也足够详细，可以算法化实现。\n- **其他标准**：该问题并非微不足道，因为它需要仔细实现状态管理和两种不同的复杂算法。它是可形式化的，并且与其指定的领域直接相关。在模拟的背景下，它并非不切实际或不可行。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将提供一个完整的、有理有据的解决方案。\n\n### 解决方案设计\n\n解决方案的核心是一个模拟引擎，它处理页面引用轨迹并维护系统内存和交换空间的状态。对于每个测试用例，该引擎将运行两次：一次用于配置 A (FIFO/FIFO)，一次用于配置 B (PRIO/PRIO)。\n\n**数据结构**\n为了管理状态，我们需要结构来表示页框和交换槽的内容。`PageEntry` 结构适合此目的，存储：\n- `page_id`：页面的标识符。值为 $-1$ 可表示空槽。\n- `load_time`：页面被加载到页框时的轨迹索引。\n- `swap_time`：页面被移入交换槽时的轨迹索引。\n\n主模拟函数将管理用于页框和交换槽的 `PageEntry` 数组，以及它们当前占用率的计数器。\n\n**模拟算法**\n模拟通过从索引 $i = 0$ 到结束遍历页面引用轨迹来进行。对于对页面 $p_i$ 的每次引用：\n\n1.  **检查命中**：在物理页框中搜索 $p_i$。如果找到，则为命中。状态不发生变化，模拟继续到下一次引用。\n\n2.  **处理缺页错误**：如果在页框中未找到 $p_i$，则发生缺页错误。错误计数增加。采取以下步骤：\n    a. **检查交换空间**：在交换空间中搜索 $p_i$。如果找到，相应的交换槽被标记为空闲，因为该页面现在正被带回主内存。\n    b. **寻找页框**：\n        i. 如果驻留页面的数量小于总页框数 $F$，则使用一个空页框。\n        ii. 如果所有页框都已满，则必须驱逐一个页面。根据活动的替换策略（FIFO 或 PRIO）选择牺牲页。\n    c. **驱逐牺牲页**：被驱逐的页面被移动到交换空间。\n        i. 如果交换空间中的页面数小于总槽数 $U$，则使用一个空槽。\n        ii. 如果交换空间已满，必须从交换空间中丢弃一个页面以腾出空间。要丢弃的页面根据活动的交换空间回收策略（FIFO 或 PRIO）选择。\n    d. **加载页面**：新页面 $p_i$ 被放入现在可用的页框中。其 `load_time` 被记录为当前轨迹索引 $i$。\n\n**特定策略的逻辑**\n\n**配置 A (FIFO/FIFO)**\n- **页框替换**：为了找到 FIFO 牺牲页，我们遍历所有驻留页面，并选择具有最小 `load_time` 的那个。\n- **交换空间回收**：类似地，为了回收交换槽，我们遍历所有已换出的页面，并选择具有最小 `swap_time` 的那个。\n\n**配置 B (PRIO/PRIO)**\n此策略需要计算候选牺牲页的未来使用距离。\n- **页框替换**：在轨迹索引 $i$ 处找到 PRIO 牺牲页：\n    1. 对于每个驻留页面 $p_{res}$，在轨迹中索引 $j > i$ 的位置找到其下一次出现。\n    2. 未来使用距离定义为 $j - i$。如果该页面永不再次出现，其距离被认为是无限大。\n    3. 选择具有最大未来使用距离的页面作为牺牲页。\n    4. 如果多个页面具有相同的最大距离（例如，都是无限大），则通过选择具有最小 `load_time` 的页面来打破平局。\n- **交换空间回收**：逻辑是类似的。对于交换空间中的每个页面，计算其从当前索引 $i$ 开始的未来使用距离。丢弃具有最大距离的页面。指定的平局打破规则是“确定性地选择任何一个”，这可以通过选择找到的第一个具有最大距离的页面来实现。\n\n当为每个配置和测试用例实现这个详细的、分步的过程时，将得出所需的错误计数。", "answer": "[[8,5],[6,5],[2,2],[4,4],[6,5]]", "id": "3685067"}, {"introduction": "在掌握了基本机制之后，下一步便是量化其性能。本练习引入了一种来自性能分析领域的强大工具——排队论——来为交换设备建模。通过将页错误请求视为到达服务队列的事件，您可以推导出系统的基本属性，如平均等待时间（$W$）和稳定性条件（$\\lambda  \\mu$），这为容量规划和性能调优提供了关键的洞察。[@problem_id:3685064]", "problem": "一个操作系统采用单个交换空间设备来满足由缺页中断触发的页面换入输入/输出（I/O）请求。考虑一个由三个独立进程组成的多道程序工作负载；每个进程生成的缺页中断都会产生交换I/O请求。假设每个进程的缺页中断形成一个独立的泊松过程，其速率分别为 $r_{1} = 50~\\mathrm{s}^{-1}$、$r_{2} = 60~\\mathrm{s}^{-1}$ 和 $r_{3} = 80~\\mathrm{s}^{-1}$。该交换设备以先来先服务的顺序一次服务一个请求，服务时间独立且呈指数分布，均值为 $4~\\mathrm{ms}$，因此服务速率为 $\\mu_{\\text{swap}} = 250~\\mathrm{s}^{-1}$。设备繁忙时到达的请求在队列中等待。\n\n将该交换设备建模为 $M/M/1$ 队列。从泊松过程、指数服务时间以及 $M/M/1$ 模型底层的生灭马尔可夫链的基本定义出发，推导请求在系统中停留（从到达至完成）的稳态平均时间（记为 $W$）的解析表达式。然后根据给定参数计算 $W$。此外，从模型的基本原理出发，陈述通用稳定性条件，并确定给定参数是否满足该条件。\n\n将 $W$ 的最终数值以毫秒表示，并四舍五入到四位有效数字。最终的方框答案中不要包含单位；按此处规定使用毫秒。", "solution": "该问题陈述被认为是有效的，因为它在科学上基于排队论，问题设定良好，具有完整且一致的参数集，并且陈述客观。我们将从第一性原理出发进行完整求解。\n\n该问题要求我们将交换设备建模为 $M/M/1$ 队列。第一个'M'表示到达遵循马尔可夫过程，具体来说是泊松过程。第二个'M'表示服务时间是马尔可夫的，即呈指数分布。'$1$'表示单个服务器。\n\n首先，我们必须确定队列的总到达率 $\\lambda$。问题陈述三个独立进程产生缺页中断，每个都遵循泊松过程，速率分别为 $r_{1} = 50~\\mathrm{s}^{-1}$、$r_{2} = 60~\\mathrm{s}^{-1}$ 和 $r_{3} = 80~\\mathrm{s}^{-1}$。泊松过程的一个基本性质是，独立泊松过程的叠加也是一个泊松过程，其速率是各个速率之和。因此，到达交换设备的请求总速率为：\n$$ \\lambda = r_{1} + r_{2} + r_{3} = 50~\\mathrm{s}^{-1} + 60~\\mathrm{s}^{-1} + 80~\\mathrm{s}^{-1} = 190~\\mathrm{s}^{-1} $$\n服务速率给定为 $\\mu = \\mu_{\\text{swap}} = 250~\\mathrm{s}^{-1}$。\n\n我们现在从其底层的生灭马尔可夫链推导这个 $M/M/1$ 队列的稳态性质。令 $N(t)$ 为时刻 $t$ 系统中的请求数（在队列中或正在被服务）。状态空间是非负整数集合 $\\{0, 1, 2, \\ldots\\}$。\n出生率 $\\lambda_n$ 表示从状态 $n$ 转换到 $n+1$ 的速率。由于到达遵循速率为 $\\lambda$ 的泊松过程，出生率是恒定的：\n$$ \\lambda_n = \\lambda \\quad \\text{for } n = 0, 1, 2, \\ldots $$\n死亡率 $\\mu_n$ 表示从状态 $n$ 转换到 $n-1$ 的速率。由于服务时间是速率为 $\\mu$ 的指数分布，且只有一个服务器，只有当系统不为空时才会发生离开。因此，死亡率为：\n$$ \\mu_n = \\begin{cases} \\mu  \\text{if } n \\ge 1 \\\\ 0  \\text{if } n = 0 \\end{cases} $$\n\n在稳态下，处于状态 $n$ 的概率记为 $P_n$。细致平衡原理要求进入一个状态的速率等于离开该状态的速率。这给了我们一组平衡方程：\n对于状态 $n=0$：（离开速率） = （进入速率） $\\implies \\lambda P_0 = \\mu P_1$。\n对于状态 $n \\ge 1$：（离开速率） = （进入速率） $\\implies (\\lambda + \\mu) P_n = \\lambda P_{n-1} + \\mu P_{n+1}$。\n\n我们可以解这个方程组。从第一个方程，我们得到：\n$$ P_1 = \\frac{\\lambda}{\\mu} P_0 $$\n我们定义流量强度 $\\rho = \\frac{\\lambda}{\\mu}$。则 $P_1 = \\rho P_0$。\n使用 $n=1$ 的一般平衡方程：\n$$ (\\lambda + \\mu)P_1 = \\lambda P_0 + \\mu P_2 $$\n代入 $P_1 = \\frac{\\lambda}{\\mu}P_0$：\n$$ (\\lambda + \\mu)\\frac{\\lambda}{\\mu}P_0 = \\lambda P_0 + \\mu P_2 \\implies \\frac{\\lambda^2}{\\mu}P_0 + \\lambda P_0 = \\lambda P_0 + \\mu P_2 $$\n$$ \\implies \\frac{\\lambda^2}{\\mu}P_0 = \\mu P_2 \\implies P_2 = \\frac{\\lambda^2}{\\mu^2}P_0 = \\rho^2 P_0 $$\n通过归纳法，我们可以建立通用关系：\n$$ P_n = \\rho^n P_0 \\quad \\text{for } n \\ge 0 $$\n\n为了使这些稳态概率有效，它们在所有可能状态上的总和必须等于 $1$：\n$$ \\sum_{n=0}^{\\infty} P_n = 1 \\implies \\sum_{n=0}^{\\infty} \\rho^n P_0 = P_0 \\sum_{n=0}^{\\infty} \\rho^n = 1 $$\n该求和是一个几何级数，它收敛当且仅当其公比小于 $1$。由此，我们推导出 $M/M/1$ 队列的基本稳定性条件：\n$$ \\rho  1 \\quad \\text{或等价地} \\quad \\lambda  \\mu $$\n系统仅在到达率严格小于服务率时才稳定。\n\n假设稳定性条件成立，级数的和为 $\\frac{1}{1-\\rho}$。因此：\n$$ P_0 \\left( \\frac{1}{1-\\rho} \\right) = 1 \\implies P_0 = 1 - \\rho $$\n将此代回，得到完整的稳态概率分布：\n$$ P_n = (1-\\rho)\\rho^n \\quad \\text{for } n \\ge 0 $$\n\n接下来，我们推导系统中的平均请求数，记为 $L$。这是顾客数 $n$ 的期望值：\n$$ L = E[N] = \\sum_{n=0}^{\\infty} n P_n = \\sum_{n=1}^{\\infty} n (1-\\rho)\\rho^n = (1-\\rho) \\sum_{n=1}^{\\infty} n \\rho^n $$\n该求和可以使用几何级数的一个已知结果来计算：$\\sum_{n=1}^{\\infty} n x^n = \\frac{x}{(1-x)^2}$。\n$$ L = (1-\\rho) \\frac{\\rho}{(1-\\rho)^2} = \\frac{\\rho}{1-\\rho} $$\n\n最后，我们推导请求在系统中停留的平均时间 $W$。我们使用利特尔法则，这是排队论中的一个基本结果，它指出对于一个稳定系统，$L = \\lambda W$。由此，我们推导出 $W$ 的解析表达式：\n$$ W = \\frac{L}{\\lambda} = \\frac{\\rho/(1-\\rho)}{\\lambda} $$\n代入 $\\rho = \\lambda/\\mu$：\n$$ W = \\frac{(\\lambda/\\mu)/(1-\\lambda/\\mu)}{\\lambda} = \\frac{\\lambda/\\mu}{(\\mu-\\lambda)/\\mu} \\frac{1}{\\lambda} = \\frac{\\lambda}{\\mu} \\frac{\\mu}{\\mu - \\lambda} \\frac{1}{\\lambda} = \\frac{1}{\\mu - \\lambda} $$\n这是在系统中平均停留时间 $W$ 所需的解析表达式。\n\n现在，我们计算给定参数的数值。\n总到达率为 $\\lambda = 190~\\mathrm{s}^{-1}$。\n服务速率为 $\\mu = 250~\\mathrm{s}^{-1}$。\n\n首先，我们检查稳定性条件：$\\lambda  \\mu$。\n$$ 190~\\mathrm{s}^{-1}  250~\\mathrm{s}^{-1} $$\n条件满足，因此系统是稳定的，并且存在稳态。\n\n现在我们使用推导出的公式计算 $W$：\n$$ W = \\frac{1}{\\mu - \\lambda} = \\frac{1}{250~\\mathrm{s}^{-1} - 190~\\mathrm{s}^{-1}} = \\frac{1}{60}~\\mathrm{s} $$\n问题要求答案以毫秒为单位，并四舍五入到四位有效数字。\n$$ W = \\frac{1}{60}~\\mathrm{s} \\times 1000~\\frac{\\mathrm{ms}}{\\mathrm{s}} = \\frac{1000}{60}~\\mathrm{ms} = \\frac{50}{3}~\\mathrm{ms} \\approx 16.666...~\\mathrm{ms} $$\n四舍五入到四位有效数字，我们得到 $W = 16.67~\\mathrm{ms}$。", "answer": "$$\\boxed{16.67}$$", "id": "3685064"}, {"introduction": "现代操作系统常常采用传统磁盘交换之外的替代方案，例如内存压缩（zram/zswap）。这种方法用中央处理器（CPU）周期换取更低的输入/输出（I/O）延迟，但它总是更优的选择吗？这个动手实践问题挑战您对这种权衡进行建模，推导出一个关于压缩率（$r$）的关键阈值（$r^*$），以判断这种现代技术何时真正有益，从而突显出系统设计中无处不在的经济学思维。[@problem_id:3685159]", "problem": "现代操作系统可以通过分页到存储设备，或使用 zram 或 zswap 等机制将交换出的页面压缩保存在主内存中，来实现交换空间管理。考虑一个大小为 $P$ 字节的单个页面。使用存储设备时，每次输入/输出 (I/O) 的延迟模型为固定的每次 I/O 开销 $t_{d0}$ 秒与传输时间之和，传输时间等于数据大小除以设备吞吐量。使用压缩主内存时，延迟模型为压缩和稍后解压缩该页面的中央处理器 (CPU) 时间，加上以内存带宽在内存中传输压缩数据的时间之和。假设如下：\n- 压缩比为 $r$，意味着压缩后的大小为 $P/r$ 字节。\n- 压缩和稍后解压缩该页面的总中央处理器 (CPU) 时间为 $C_{cpu} \\, P$ 秒，其中 $C_{cpu}$ 的单位是秒/字节，并同时计入了压缩和解压缩的时间。\n- 有效持续磁盘吞吐量为 $B_{d}$ 字节/秒，固定的每次 I/O 磁盘开销为 $t_{d0}$ 秒；一次换出（写入）及其后的换入（读取）均产生 $t_{d0}$ 的开销并传输 $P$ 字节。\n- 有效持续主内存带宽为 $B_{m}$ 字节/秒；写入和稍后读取压缩页面均传输 $P/r$ 字节。\n- CPU 时间与传输时间之间，以及不同传输之间没有重叠，并且分页遵循一个稳态的往返模式，即一次换出最终跟随着一次换入。\n\n仅从传输延迟等于数据大小除以吞吐量加上任何固定开销，以及 CPU 处理时间与处理的字节数成线性关系这两个基本定义出发，推导出一个闭式阈值 $r^{*}$，使得当且仅当 $r  r^{*}$ 时，压缩主内存交换产生的总往返延迟严格低于基于磁盘的交换。请将您的最终答案表示为 $r^{*}$ 关于 $P$、$B_{m}$、$B_{d}$、$t_{d0}$ 和 $C_{cpu}$ 的单个解析表达式。不要代入数值，也不要四舍五入。答案是无量纲的。", "solution": "该问题要求推导一个阈值压缩比 $r^{*}$，该值决定了压缩主内存交换是否比传统的基于磁盘的交换性能更好（即具有更低的总往返延迟）。条件是，当且仅当实际压缩比 $r  r^{*}$ 时，压缩交换才严格更优。\n\n令 $L_{disk}$ 表示基于磁盘的交换的总往返延迟，令 $L_{mem}$ 表示压缩主内存交换的总往返延迟。我们必须首先根据所提供的模型为这两种延迟建立表达式。\n\n首先，我们分析基于磁盘的交换。一次往返操作包括一次换出（将页面写入磁盘）和随后的一次换入（从磁盘读回同一页面）。每次操作中传输的数据大小是完整的页面大小，即 $P$ 字节。\n\n单次磁盘 I/O 操作的延迟由固定开销 $t_{d0}$ 和可变传输时间之和给出。传输时间是数据大小除以磁盘吞吐量 $B_d$。\n对于大小为 $P$ 的页面的单次操作（换出或换入）：\n$$ \\text{Latency}_{\\text{one-way disk}} = t_{d0} + \\frac{P}{B_d} $$\n总往返延迟 $L_{disk}$ 是换出和换入延迟的总和。\n$$ L_{disk} = \\left( t_{d0} + \\frac{P}{B_d} \\right) + \\left( t_{d0} + \\frac{P}{B_d} \\right) $$\n$$ L_{disk} = 2 t_{d0} + \\frac{2P}{B_d} $$\n\n接下来，我们分析压缩主内存交换。一次往返操作包括压缩页面、将压缩数据写入主内存的某个区域、稍后读回压缩数据，并将其解压缩以恢复原始页面。\n\n压缩和解压缩的总 CPU 时间为 $C_{cpu} P$。\n压缩比为 $r$，因此压缩页面的大小为 $P/r$ 字节。\n内存传输的延迟是数据大小除以内存带宽 $B_m$。根据问题陈述，内存传输没有固定开销。\n将压缩页面写入内存的延迟为 $\\frac{P/r}{B_m} = \\frac{P}{r B_m}$。\n从内存读取压缩页面的延迟也是 $\\frac{P}{r B_m}$。\n一次往返中内存传输的总时间是写入和读取延迟的总和。\n$$ \\text{Time}_{\\text{memory transfer}} = \\frac{P}{r B_m} + \\frac{P}{r B_m} = \\frac{2P}{r B_m} $$\n基于无重叠的假设，压缩内存交换的总往返延迟 $L_{mem}$ 是总 CPU 时间和总内存传输时间的总和。\n$$ L_{mem} = C_{cpu} P + \\frac{2P}{r B_m} $$\n\n我们正在寻找压缩内存交换的延迟严格低于基于磁盘交换的延迟的条件。这由不等式 $L_{mem}  L_{disk}$ 表示。\n$$ C_{cpu} P + \\frac{2P}{r B_m}  2 t_{d0} + \\frac{2P}{B_d} $$\n我们的目标是解这个关于 $r$ 的不等式。我们可以重新排列各项以分离出包含 $r$ 的项。\n$$ \\frac{2P}{r B_m}  2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P $$\n为了存在一个有意义的阈值 $r^*$，使得性能优势取决于超过它（$r  r^*$），不等式的右侧必须为正。这对应于一个物理条件，即基于磁盘的方法本身速度并非已经快到（或者压缩的 CPU 成本并非高到）使压缩方法永远不可能更好的程度。\n假设右侧为正，我们可以继续解出 $r$。让我们操作不等式，将 $r$ 移到分子位置。\n首先，我们可以取两边的倒数，这会反转不等号的方向。\n$$ \\frac{r B_m}{2P} > \\frac{1}{2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P} $$\n接下来，我们通过两边同乘以 $\\frac{2P}{B_m}$ 来分离出 $r$。由于 $P$ 和 $B_m$ 都是正的物理量，这不会改变不等号的方向。\n$$ r > \\frac{2P}{B_m \\left( 2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P \\right)} $$\n这个不等式给出了压缩内存交换速度更快的条件。右侧的表达式就是阈值 $r^*$。\n$$ r^{*} = \\frac{2P}{B_m \\left( 2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P \\right)} $$\n为了以没有嵌套分数的简化形式呈现，我们可以为分母括号内的各项找到一个公分母。这些项是 $2 t_{d0}$、$\\frac{2P}{B_d}$ 和 $-C_{cpu} P$。公分母是 $B_d$。\n$$ r^{*} = \\frac{2P}{B_m \\left( \\frac{2 t_{d0} B_d}{B_d} + \\frac{2P}{B_d} - \\frac{C_{cpu} P B_d}{B_d} \\right)} $$\n$$ r^{*} = \\frac{2P}{B_m \\left( \\frac{2 t_{d0} B_d + 2P - C_{cpu} P B_d}{B_d} \\right)} $$\n通过将分子和分母同乘以 $B_d$，我们得到了 $r^*$ 的最终闭式表达式：\n$$ r^{*} = \\frac{2P B_d}{B_m (2P + 2 t_{d0} B_d - C_{cpu} P B_d)} $$\n这个表达式代表了临界压缩比。如果实现的压缩比 $r$ 大于这个值 $r^*$，那么使用压缩主内存交换的总延迟将严格小于使用基于磁盘交换的总延迟。", "answer": "$$\\boxed{\\frac{2P B_d}{B_m (2P + 2 t_{d0} B_d - C_{cpu} P B_d)}}$$", "id": "3685159"}]}