{"hands_on_practices": [{"introduction": "本练习将指导你从头开始构建一个简化的虚拟块设备。通过实现一个映射层，将逻辑块地址转换为物理地址，同时跳过有缺陷的块，你将具体理解操作系统如何在不完美的硬件之上提供一个干净、可靠的存储抽象。[@problem_id:3622225]", "problem": "要求您在一个独立的程序中实现一个虚拟块设备，该设备模拟操作系统中的坏块管理与恢复机制。该设备定义在一个有限的物理块集合和一个目标数量的逻辑块之上。任务的核心是实现一个映射层，它将每个逻辑块分配到一个唯一的、当前状态良好的物理块上，跳过已知的坏块，并在可能的情况下于运行时发生故障时进行重映射。\n\n使用的基本原理和定义：\n- 令 $P \\in \\mathbb{N}$ 表示物理块的总数，索引为 $\\{0,1,\\dots,P-1\\}$。\n- 令 $B \\in \\mathbb{N}$ 表示操作系统所需的逻辑块数量，索引为 $\\{0,1,\\dots,B-1\\}$。\n- 令 $S \\in \\mathbb{N}$ 表示块大小（以字节为单位）（此参数为增强真实感而设，不改变映射逻辑）。\n- 令 $G \\subseteq \\{0,1,\\dots,P-1\\}$ 表示初始状态良好的物理块集合， $F \\subseteq \\{0,1,\\dots,P-1\\}$ 表示初始损坏的物理块集合。这两个集合不相交且满足 $G \\cup F = \\{0,1,\\dots,P-1\\}$。\n- 映射是一个偏函数 $M:\\{0,1,\\dots,B-1\\} \\to \\{0,1,\\dots,P-1\\}$，当映射成功时，它是到 $G$ 的一个单射。成功意味着 $|G| \\ge B$，并且存在一个将每个逻辑块分配到唯一良好物理块的单射赋值。在此问题中，您必须实现首次适应策略：按递增顺序扫描物理索引，并将前 $B$ 个当前状态良好的物理块按顺序映射到逻辑索引。\n- 运行时故障注入会将特定物理块的状态从良好翻转为损坏。当物理块 $p$ 发生此种翻转时，必须更新映射：如果 $p$ 当前支持某个逻辑块 $\\ell$，则尝试将 $\\ell$ 重映射到索引最早的、当前良好且未被使用的物理块；如果不存在这样的块，则该设备无法再维持 $B$ 个逻辑块。\n\n用作基础起点的经过充分验证的事实：\n- 初始映射的可行性条件是 $|G| \\ge B$。这源于鸽巢原理：从 $\\{0,1,\\dots,B-1\\}$ 到 $G$ 的单射函数存在的充要条件是 $|G| \\ge B$。\n- 在首次适应映射策略下，备用容量等于 $|G| - B$，即初始未被分配的良好物理块数量。每次因运行时故障而成功的重映射会消耗一个备用良好块。\n\n需实现的恢复模型：\n- 初始映射：通过扫描物理索引 $p=0$ 到 $p=P-1$ 来构建 $M$，跳过 $F$ 中的索引，并将前 $B$ 个良好索引分配给逻辑块 $\\ell=0$ 到 $\\ell=B-1$。\n- 运行时故障注入序列：按顺序应用一个物理索引序列 $(q_0,q_1,\\dots,q_{k-1})$。对于每个注入 $q_i$：\n  - 如果 $q_i$ 已是坏块，则不执行任何操作。\n  - 如果 $q_i$ 是良好且未映射到任何逻辑块的块（备用块），则将其标记为坏块，备用块数量减 1。\n  - 如果 $q_i$ 是良好且已映射到某个逻辑块 $\\ell$ 的块，则将其标记为坏块，然后尝试寻找索引最早的、良好且当前未映射的物理块 $p'$；如果找到，则设置 $M(\\ell) \\leftarrow p'$（这计为一次成功恢复）。如果未找到，则保持 $\\ell$ 未映射状态，设备无法再维持 $B$ 个逻辑块。\n\n程序要求：\n- 您的程序必须为下面给出的一组固定测试用例确定性地实现上述逻辑，无需任何用户输入。\n- 对于每个测试用例，计算四个整数：\n  1. $I$：初始映射成功指示符，如果 $|G|\\ge B$ 则 $I=1$，否则 $I=0$。\n  2. $U$：初始备用良好物理块的数量，如果 $I=1$ 则 $U = |G| - B$，否则 $U=-1$。\n  3. $R$：命中已映射良好物理块并通过使用备用块成功恢复的运行时注入次数，如果 $I=0$ 则 $R=-1$。\n  4. $F_{\\text{final}}$：所有注入操作后最终的可持续性指示符，如果映射仍然覆盖所有 $B$ 个逻辑块则 $F_{\\text{final}}=1$，否则 $F_{\\text{final}}=0$。\n- 最终输出格式必须是单行文本，其中包含一个方括号括起来的、按顺序排列的每个测试用例结果的逗号分隔列表。例如，如果有 $T$ 个测试用例，输出的长度必须为 $4T$，格式为 $[I_0,U_0,R_0,F_0,I_1,U_1,R_1,F_1,\\dots]$。\n\n需实现的测试套件：\n- 测试用例 $\\mathrm{T}_1$（成功路径，备用块耗尽）：\n  - $P=16$, $B=12$, $S=8$.\n  - 初始坏块物理索引 $F=\\{3,9\\}$，因此 $|G|=14$。\n  - 运行时故障注入 $(5,15,7)$。\n- 测试用例 $\\mathrm{T}_2$（边界情况，无初始备用块）：\n  - $P=10$, $B=10$, $S=4$.\n  - 初始坏块物理索引 $F=\\varnothing$，因此 $|G|=10$。\n  - 运行时故障注入 $(2)$。\n- 测试用例 $\\mathrm{T}_3$（初始映射不可能）：\n  - $P=8$, $B=7$, $S=16$.\n  - 初始坏块物理索引 $F=\\{1,3,5\\}$，因此 $|G|=5$。\n  - 运行时故障注入 $(0,2)$。\n- 测试用例 $\\mathrm{T}_4$（备用块在已映射块故障前被破坏）：\n  - $P=12$, $B=10$, $S=32$.\n  - 初始坏块物理索引 $F=\\{10\\}$，因此 $|G|=11$。\n  - 运行时故障注入 $(11,4)$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔结果列表（例如，$[1,2,2,1,0,0,0,0]$）。对于上述从 $\\mathrm{T}_1$ 到 $\\mathrm{T}_4$ 的四个测试用例，请按顺序输出您的实现计算出的扁平化列表 $[I_1,U_1,R_1,F_1,I_2,U_2,R_2,F_2,I_3,U_3,R_3,F_3,I_4,U_4,R_4,F_4]$。", "solution": "该问题要求为一个虚拟块设备的坏块管理系统实现一个确定性模拟。该模拟必须遵循特定的首次适应映射策略和定义的运行时块故障恢复模型。解决方案的设计方法是对系统状态进行建模，并按程序应用初始映射、故障注入和恢复的规则。\n\n模拟的核心是表示块设备的状态。我们使用几个数组来跟踪此信息：\n1.  一个大小为 $P$ 的物理块状态数组 `state`。对于物理块 $p \\in \\{0, 1, \\dots, P-1\\}$，每个元素 `state[p]` 记录该块是坏块、良好且未映射（备用块），还是良好且已映射。\n2.  一个大小为 $B$ 的逻辑到物理映射数组 `log_to_phys`。`log_to_phys[l]` 存储逻辑块 $l \\in \\{0, 1, \\dots, B-1\\}$ 映射到的物理块索引 $p$。一个特殊值（如 $-1$）表示该逻辑块未被映射。\n3.  一个大小为 $P$ 的物理到逻辑映射数组 `phys_to_log`。这是 `log_to_phys` 的逆映射，其中 `phys_to_log[p]` 存储映射到物理块 $p$ 的逻辑块索引 $l$。这种反向映射对于高效处理运行时故障至关重要，因为它允许在物理块发生故障时立即查找哪个逻辑块受到了影响。\n\n每个测试用例的模拟都按四个不同阶段进行：\n\n**1. 初始化**\n首先，初始化物理块状态数组。所有 $P$ 个块暂时标记为良好。然后，我们遍历给定的初始坏块集合 $F$，并将每个相应块的状态更新为`坏块` (bad)。通过从 $P$ 中减去 $F$ 的大小，计算出初始良好块的总数 $|G|$。\n\n**2. 初始映射与验证**\n为所有 $B$ 个逻辑块创建完整映射的可行性取决于鸽巢原理：必须有至少与待映射逻辑块数量相等的良好物理块。这由条件 $|G| \\ge B$ 表示。\n- 如果 $|G|  B$，则初始映射不可能。初始成功指示符 $I$ 设置为 $0$。因此，初始备用块数量 $U$ 和运行时恢复次数 $R$ 设置为失败代码 $-1$，最终可持续性指示符 $F_{\\text{final}}$ 设置为 $0$。此测试用例的模拟终止。\n- 如果 $|G| \\ge B$，则映射是可能的。$I$ 设置为 $1$。初始备用良好块的数量计算为 $U = |G| - B$。运行时恢复计数器 $R$ 初始化为 $0$。然后执行首次适应映射算法：我们从 $0$ 到 $B-1$ 遍历逻辑块索引 $l$，并为每个 $l$ 分配第一个可用的（即索引最小的）良好且未映射的物理块。此过程会填充 `log_to_phys` 和 `phys_to_log` 数组，并将已分配物理块的状态更新为`良好且已映射` (good and mapped)。\n\n**3. 运行时故障注入与恢复**\n模拟过程处理一个给定的运行时故障注入序列 $(q_0, q_1, \\dots, q_{k-1})$。对于序列中的每个物理块索引 $q_i$：\n- 如果 $q_i$ 已被标记为坏块，则不采取任何行动。\n- 如果 $q_i$ 是一个良好且未映射的（备用）块，其状态将变为坏块。这会消耗一个备用块，但不需要重映射。\n- 如果 $q_i$ 是一个良好且已映射的块，则会触发恢复尝试。该块被标记为坏块。先前映射到 $q_i$ 的逻辑块 $\\ell$ 变为未映射状态。然后，算法遵循“最早”规则，为 $\\ell$ 寻找一个新的物理块来支持它：它从 $p' = 0$ 到 $P-1$ 扫描物理块索引，以找到第一个当前良好且未映射的块。\n    - 如果找到了这样的备用块 $p'$，则恢复成功。$\\ell$ 的映射更新为 $p'$，即 $M(\\ell) \\leftarrow p'$。$p'$ 的状态更新为`良好且已映射` (good and mapped)，恢复计数器 $R$ 增加 $1$。\n    - 如果没有找到备用块，则恢复失败。逻辑块 $\\ell$ 将保持未映射状态。\n\n**4. 最终状态评估**\n处理完所有故障注入后，会进行最后一次检查，以确定设备是否仍完全支持所需的 $B$ 个逻辑块。我们遍历 `log_to_phys` 数组。如果所有 $B$ 个条目都指向一个有效的物理块（即不为 $-1$），则认为设备是可持续的，最终指示符 $F_{\\text{final}}$ 设置为 $1$。否则，如果至少有一个逻辑块未映射，则 $F_{\\text{final}}$ 设置为 $0$。\n\n这种结构化的、有状态的模拟正确地实现了指定的逻辑，并为每个提供的测试用例确定性地计算出所需的四个指标（$I, U, R, F_{\\text{final}}$）。", "answer": "```c\n\n```", "id": "3622225"}, {"introduction": "在坏块概念的基础上，本练习模拟了日志文件系统的恢复过程。你将实现一个恢复规划器，它使用校验和与序列号来验证日志条目并对其排序，从而确保即使部分记录因坏块或损坏而丢失，系统也能恢复到一致的状态。此练习揭示了数据完整性和有序重放在保障系统崩溃安全中的关键作用。[@problem_id:3622209]", "problem": "您需要为一个元数据日志系统实现一个崩溃恢复规划器，该规划器使用校验和和单调递增的序列号来检测并跳过坏块，同时按顺序重放操作。考虑一个存储设备，它将日志记录写入从 $0$ 到 $N-1$ 索引的固定大小的块中。已知某些块是坏块，必须跳过。位于块索引 $i$ 的日志记录由一个元组 $(s_i, L_i, P_i, \\text{ck}_i)$ 组成，其中 $s_i$ 是序列号，$L_i$ 是负载长度（负载中整数的数量），$P_i$ 是一个包含 $L_i$ 个整数负载元素的列表，而 $\\text{ck}_i$ 是一个32位校验和。有些块可能不包含任何记录。\n\n基本假设和定义：\n- 校验和用于保证完整性：对于一条记录 $(s, L, P)$，其校验和函数定义为 $$\\text{ck}(s,L,P) = \\left(s + L + \\sum_{j=1}^{L} P_j\\right) \\bmod 2^{32}.$$ 一条记录是有效的，当且仅当该块不是坏块、该块包含一条记录，并且其存储的校验和等于 $\\text{ck}(s,L,P)$。\n- 序列号为重放提供了全序关系。为确保确定性和崩溃安全的恢复，而不依赖外部提交标记，重放必须限制在从最小有效序列号开始的最大连续递增序列。\n\n基于这些定义，恢复规则如下：\n- 令 $S$ 为丢弃坏块和校验和不匹配的记录后所有有效记录的序列号集合。将 $S$ 按升序排序得到 $S_{\\text{sorted}}$。令 $s_{\\min}$ 为 $S_{\\text{sorted}}$ 的最小元素。重放集 $R$ 是最大连续前缀 $\\{s_{\\min}, s_{\\min}+1, \\dots, s_{\\min}+k\\}$，使得此范围内的每个元素都存在于 $S_{\\text{sorted}}$ 中，并在遇到第一个间隙时停止。\n\n您的任务：\n- 实现一个程序，为每个提供的测试用例，根据上述恢复规则计算重放集 $R$，并按升序输出序列号列表。如果不存在有效记录，则为该测试用例输出一个空列表。\n\n约束和说明：\n- 所有整数值均为标准有符号或无符号整数；校验和计算中的溢出根据上述公式由模 $2^{32}$ 定义。\n- 重放集必须是连续的；如果由于坏块或校验和失败而导致任何序列号缺失，重放将在缺失的数字之前停止。\n\n测试套件：\n对于每个测试用例，块索引从 $0$ 开始，未明确列为包含记录的块均无记录。\n\n- 测试用例1：\n  - 块数量 $N = 8$。\n  - 坏块索引：$\\{5\\}$。\n  - 记录：\n    - 块 $0$：$(s=100, L=2, P=[3,5], \\text{ck}=110)$。\n    - 块 $1$：$(s=101, L=1, P=[7], \\text{ck}=109)$。\n    - 块 $2$：$(s=102, L=3, P=[1,1,1], \\text{ck}=108)$。\n    - 块 $3$：$(s=103, L=1, P=[4], \\text{ck}=108)$。\n    - 块 $4$：$(s=104, L=2, P=[0,9], \\text{ck}=115)$。\n    - 块 $5$：$(s=105, L=1, P=[9], \\text{ck}=115)$ 是坏块。\n    - 块 $6$：无记录。\n    - 块 $7$：$(s=106, L=2, P=[5,5], \\text{ck}=118)$。\n\n- 测试用例2：\n  - 块数量 $N = 7$。\n  - 坏块索引：$\\{\\}$。\n  - 记录：\n    - 块 $0$：$(s=200, L=2, P=[10,20], \\text{ck}=232)$。\n    - 块 $1$：$(s=201, L=2, P=[1,1], \\text{ck}=205)$。\n    - 块 $2$：$(s=202, L=1, P=[0], \\text{ck}=203)$。\n    - 块 $3$：$(s=203, L=2, P=[2,3], \\text{ck}=209)$ 存储的校验和已损坏（预期 $\\text{ck}=210$）。\n    - 块 $4$：$(s=204, L=1, P=[1], \\text{ck}=206)$。\n    - 块 $5$：$(s=205, L=1, P=[1], \\text{ck}=207)$。\n    - 块 $6$：无记录。\n\n- 测试用例3：\n  - 块数量 $N = 9$。\n  - 坏块索引：$\\{1\\}$。\n  - 记录：\n    - 块 $0$：$(s=300, L=1, P=[2], \\text{ck}=303)$。\n    - 块 $1$：$(s=301, L=1, P=[3], \\text{ck}=305)$ 是坏块。\n    - 块 $2$：$(s=301, L=1, P=[3], \\text{ck}=305)$ 重复副本。\n    - 块 $3$：$(s=302, L=2, P=[0,0], \\text{ck}=304)$。\n    - 块 $4$：$(s=303, L=1, P=[0], \\text{ck}=304)$。\n    - 块 $5$：$(s=304, L=1, P=[1], \\text{ck}=306)$。\n    - 块 $6$：无记录。\n    - 块 $7$：$(s=305, L=1, P=[1], \\text{ck}=307)$。\n    - 块 $8$：$(s=306, L=1, P=[1], \\text{ck}=308)$。\n\n- 测试用例4：\n  - 块数量 $N = 5$。\n  - 坏块索引：$\\{0,3\\}$。\n  - 记录：\n    - 块 $0$：$(s=400, L=1, P=[1], \\text{ck}=402)$ 是坏块。\n    - 块 $1$：$(s=401, L=2, P=[1,1], \\text{ck}=0)$ 存储的校验和已损坏（预期 $\\text{ck}=405$）。\n    - 块 $2$：无记录。\n    - 块 $3$：$(s=402, L=1, P=[0], \\text{ck}=403)$ 是坏块。\n    - 块 $4$：$(s=403, L=1, P=[1], \\text{ck}=1)$ 存储的校验和已损坏（预期 $\\text{ck}=405$）。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个用方括号括起来的逗号分隔的整数列表。例如，最终输出必须类似于 $[[r\\_{1,1},\\dots],[r\\_{2,1},\\dots],\\dots]$，不含空格。请将此应用于提供的测试套件并打印相应的最终结果。", "solution": "用户提供的问题是有效的。它在科学上基于操作系统中使用的数据存储、日志记录和崩溃恢复的原理。该问题定义明确，具有清晰、客观且无矛盾的定义和规则，可导出一个唯一且有意义的解决方案。这是一个可形式化的算法任务，与指定主题直接相关。所有必要数据均已提供。\n\n任务是为元数据日志确定一个确定性的重放计划。该计划必须考虑数据损坏，损坏通过两种机制检测：一个预定义的已知坏存储块列表和每条日志记录的校验和。此外，重放过程必须遵守严格的操作顺序，该顺序由单调递增的序列号强制执行。\n\n此问题的解决遵循一系列直接从所提供规则推导出的逻辑步骤。\n\n**步骤1：记录验证**\n\n首先，我们必须从存储设备上的原始数据中识别出所有有效的记录。位于块索引 $i$ 的一条记录，表示为元组 $(s_i, L_i, P_i, \\text{ck}_i)$，当且仅当它同时满足三个条件时才被视为有效：\n1.  块索引 $i$ 不得位于已知坏块集合中。\n2.  索引 $i$ 处的块必须包含一条记录。问题陈述提供了哪些块包含记录的明确列表，简化了此项检查。\n3.  存储的32位校验和 $\\text{ck}_i$ 必须与根据记录内容计算出的校验和相匹配。校验和函数定义为：\n    $$ \\text{ck}(s,L,P) = \\left(s + L + \\sum_{j=1}^{L} P_j\\right) \\bmod 2^{32} $$\n    模 $2^{32}$ 运算由标准的32位无符号整数算术自然处理，其中溢出会回绕。我们遍历从 $0$ 到 $N-1$ 的每个包含记录的块，并应用这些检查。任何不满足这些条件的记录都将被丢弃，不予考虑重放。\n\n**步骤2：序列号的收集与排序**\n\n筛选后，我们得到一个有效记录的集合。令 $S$ 为与这些有效记录相对应的序列号 $\\{s_i\\}$ 的集合。使用集合很重要，因为它可以正确处理可能存在多个具有相同序列号的有效记录的情况（例如，在镜像或冗余存储布局中），如测试用例3所示。然后将 $S$ 中不同的有效序列号按升序排序，生成一个列表，我们称之为 $S_{\\text{sorted}}$。\n\n如果在验证步骤后没有发现有效记录，集合 $S$ 将为空。在这种情况下，重放集也为空。\n\n**步骤3：识别最大连续重放集**\n\n最后一步是根据已排序的有效序列号列表 $S_{\\text{sorted}}$ 来构建重放集 $R$。恢复规则强制规定，重放必须是从最小有效序列号开始的连续序列。\n1.  令 $s_{\\min}$ 为非空列表 $S_{\\text{sorted}}$ 的第一个元素。这是我们重放的起点。\n2.  用 $s_{\\min}$ 初始化重放集 $R$。\n3.  从第二个元素开始，遍历 $S_{\\text{sorted}}$ 的其余元素。对于每个元素 $s_k \\in S_{\\text{sorted}}$，将其与添加到 $R$ 中的最后一个元素（我们称之为 $s_{\\text{last}}$）进行比较。\n4.  如果 $s_k = s_{\\text{last}} + 1$，则序列是连续的。将 $s_k$ 添加到 $R$ 并继续。\n5.  如果 $s_k \\neq s_{\\text{last}} + 1$，则检测到序列号中存在间隙。连续性被打破。过程必须在此时终止。到目前为止构建的集合 $R$ 是最大连续前缀，代表最终的重放计划。\n\n让我们对测试用例1追踪此逻辑：\n- 坏块：$\\{5\\}$。\n- 记录被验证：\n  - 块 $0: s=100$。校验和：$100 + 2 + 3 + 5 = 110$。匹配。有效。\n  - 块 $1: s=101$。校验和：$101 + 1 + 7 = 109$。匹配。有效。\n  - 块 $2: s=102$。校验和：$102 + 3 + 1 + 1 + 1 = 108$。匹配。有效。\n  - 块 $3: s=103$。校验和：$103 + 1 + 4 = 108$。匹配。有效。\n  - 块 $4: s=104$。校验和：$104 + 2 + 0 + 9 = 115$。匹配。有效。\n  - 块 $5: s=105$。该块在坏块列表中。无效。\n  - 块 $7: s=106$。校验和：$106 + 2 + 5 + 5 = 118$。匹配。有效。\n- 有效序列号的集合是 $S = \\{100, 101, 102, 103, 104, 106\\}$。\n- 排序后，得到 $S_{\\text{sorted}} = [100, 101, 102, 103, 104, 106]$。\n- 最小值为 $s_{\\min} = 100$。\n- 重放集开始为 $R=\\{100\\}$。\n- 序列继续：$101 = 100+1$, $102 = 101+1$, $103 = 102+1$, $104 = 103+1$。\n- 下一个有效数字是 $106$。由于 $106 \\neq 104+1$，存在一个间隙。重放停止。\n- 最终的重放集是 $R=\\{100, 101, 102, 103, 104\\}$。\n\n此过程应用于每个测试用例以生成最终结果。", "answer": "```c\n\n```", "id": "3622209"}, {"introduction": "最后一个练习深入探讨了坏块管理中的高级挑战：并发性。你将设计并模拟一个线程安全的协议，用于在一个有持续写入操作的活动系统中安全地标记坏块，并使用原子操作来防止竞争条件。此练习让你对稳健的内核级驱动程序开发所必需的同步机制获得至关重要的洞察。[@problem_id:3622191]", "problem": "您需要设计并实现一个块设备驱动程序的并发安全模拟，该模拟提供一个类似`ioctl`（输入/输出控制）的操作，用于在系统经受实时写入流量的同时将块标记为坏块。目标是确保在所有调度情况下，一旦某个块被标记为坏块，就不会有新的写入操作在该块上开始，尽管在标记之前已经开始的写入操作可以被允许完成。您的程序必须以精确的语义对以下抽象进行建模，并从第一性原理出发实现一个满足安全属性的协议。\n\n模型与语义：\n- 设备提供 $B$ 个逻辑块，由整数 $0,1,\\dots,B-1$ 索引。每个块 $i$ 由一个状态变量 $s_i\\in\\{0,1\\}$ 表示，其中 $s_i=0$ 意为“良好”，$s_i=1$ 意为“损坏（停用中）”。\n- 对块 $i$ 的一次写入是一个并发操作，具有一个开始时刻 $t_s$ 和一个结束时刻 $t_f$。安全属性要求，一旦块损坏，就不允许有任何写入开始，形式化地表示为：对于块 $i$ 上的每一次写入操作，都必须满足 $s_i(t_s)=0$。在 $s_i(t_s)=0$ 时开始的写入操作，即使之后 $s_i$ 变为 $1$，也可以完成；这模拟了实际的“在线更新”行为，即允许正在进行中的写入完成。\n- 驱动程序提供一个针对块 $i$ 的类似`ioctl`的标记损坏操作，概念上用函数 $\\mathrm{mark\\_bad}(i)$ 表示。该操作将 $s_i$ 从 $0$ 转换到 $1$，并且只有在确保没有新的写入可以开始，并且所有在转换前开始的在途写入都已完成后，才会返回。\n\n使用的基本原理和约束：\n- 所有共享状态的更新都必须使用遵循顺序一致性（sequential consistency）的原子读-改-写操作来执行。具体来说，应使用具有顺序一致性排序的原子加载、存储和 `fetch-add`/`fetch-sub`，以使操作历史是可线性化的（linearizable）。\n- 互斥和原子性必须从顺序一致性和可线性化的定义中推导出来：存在一个与程序顺序一致的原子操作全序，使得每一次写入预留操作要么在标记损坏转换之前，要么在其之后。\n- 您的代码必须实现一个协议，其中写入者通过检查 $s_i$、增加一个“活动写入者”计数器，并重新检查 $s_i$ 来尝试“预留”对块 $i$ 的写入能力，如果并发的标记损坏操作在此期间介入，则中止操作。标记损坏操作将 $s_i\\leftarrow 1$，然后等待直到“活动写入者”计数器变为 $0$ 后才返回。\n\n需要实现和证明的协议属性：\n- 安全性：对于每个块 $i$，如果在其开始时刻 $t_s$ 时 $s_i=1$，则没有写入操作会开始，也就是说，预留协议必须保证 $s_i(t_s)=0$ 这个条件。\n- 对现有写入的非阻塞性：在标记损坏之前开始的写入者可以完成其操作；标记损坏操作必须通过观察“活动写入者”计数器变为 $0$ 来等待这些在途写入者全部完成。\n- 进展性：一旦 $s_i=1$，如果没有新的写入者尝试开始写入，那么在所有先前活动的写入者完成后，$\\mathrm{mark\\_bad}(i)$ 最终会返回。\n\n实现要求：\n- 实现一个模拟驱动程序，每个块包含原子变量：一个原子标志 $s_i$ 和一个计算活动写入者的原子整数 $a_i$。写入者遵循预留协议：它们检查 $s_i$，增加 $a_i$，重新检查 $s_i$，如果在增加计数器后发现 $s_i$ 为 $1$，则通过减少 $a_i$ 来中止操作。成功的预留执行一次模拟写入，然后减少 $a_i$。$\\mathrm{mark\\_bad}(i)$ 操作将 $s_i\\leftarrow 1$，然后自旋等待直到 $a_i=0$。\n- 使用多线程来模拟并发的写入者和并发的标记损坏调用。\n- 模拟延迟必须实现为具有固定整数迭代次数的纯粹忙等待循环；将这些计数视为没有物理单位的抽象时间量子。\n\n测试套件：\n实现并运行以下四个测试用例。在每个用例中，报告安全违规的次数。安全违规定义为：在块 $i$ 的 $s_i=1$ 时开始对其进行写入的次数（您的预留协议必须防止这种情况发生；如果实现正确，每个用例的预期结果都应为 $0$）。\n\n- 测试用例 1（正常路径）：\n  - 参数：$B=8$，每个块的写入者数 $W=2$，每个写入者的写入次数 $N=500$。\n  - 调度：以每个 $5000$ 次循环迭代的初始标记延迟来标记块 $i=2$ 和 $i=5$。写入者使用 $1000$ 次循环迭代的初始延迟，并在预留之间使用 $10$ 次循环迭代的内部写入延迟。\n\n- 测试用例 2（边界：立即停用）：\n  - 参数：$B=4$, $W=3$, $N=100$。\n  - 调度：立即标记所有块（初始标记延迟为 $0$）。写入者使用 $5000$ 次循环迭代的初始延迟和 $10$ 次循环迭代的内部写入延迟。由于在写入者开始前所有块都已损坏，因此不应有任何写入在任何块上开始。\n\n- 测试用例 3（边缘：高竞争下的首尾块）：\n  - 参数：$B=16$, $W=4$, $N=200$。\n  - 调度：在 $2000$ 次循环迭代后标记块 $i=0$，在 $4000$ 次循环迭代后标记块 $i=15$。写入者使用 $1000$ 次循环迭代的初始延迟和 $5$ 次循环迭代的内部写入延迟。\n\n- 测试用例 4（压力：交错停用）：\n  - 参数：$B=12$, $W=1$, $N=1500$。\n  - 调度：以 $1000\\times i$ 次循环迭代的交错初始延迟来标记所有偶数索引的块 $i\\in\\{0,2,4,6,8,10\\}$。写入者不使用初始延迟，并使用 $1$ 次循环迭代的内部写入延迟。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 1 到 4 的顺序排列结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是在测试用例 $k$ 中观察到的安全违规次数的整数值。不应打印任何其他文本。", "solution": "问题陈述是有效的。它提出了一个在并发编程领域中定义明确且有科学依据的问题，特别是在操作系统上下文中，设计并验证一个用于平滑停用共享资源的协议。该问题是自包含的，提供了所有必要的参数、约束和算法描述。顺序一致性、原子操作和可线性化等基本原理是现代计算机科学的基石。该问题是客观、可形式化且非平凡的，需要正确实现一个特定的并发控制模式。\n\n我们继续进行形式化解决方案。\n\n### **1. 形式化模型**\n\n系统由一组 $B$ 个逻辑块组成，索引为 $i \\in \\{0, 1, \\dots, B-1\\}$。每个块 $i$ 关联两个共享状态变量，其更新必须是原子的：\n\n1.  一个状态标志 $s_i \\in \\{0, 1\\}$，表示块的状态。初始时，$s_i=0$（“良好”）。向 $s_i=1$（“损坏”或“停用中”）的转换是永久性的。我们使用一个原子整数来实现它。\n2.  一个活动写入者计数器 $a_i \\in \\mathbb{N}_0$，跟踪当前正在进行中或正在预留该块的写入操作数量。初始时，$a_i=0$。\n\n核心要求是确保所有写入操作的安全性。对块 $i$ 的一次写入操作由一个开始时间 $t_s$ 和一个结束时间 $t_f$ 来表征。安全属性规定，对于任何写入，在其开始时，块必须处于“良好”状态：\n$$ \\forall \\text{writes on block } i, s_i(t_s) = 0 $$\n尽管有并发的 $\\mathrm{mark\\_bad}(i)$ 操作调用（该调用将 $s_i$ 从 $0$ 转换到 $1$），此属性也必须成立。\n\n### **2. 协议设计**\n\n问题指定了一个基于原子读-改-写操作的协议，以确保顺序一致性。这意味着存在一个跨所有线程的所有原子操作的单一全序（一次线性化），该全序与每个线程内部的程序顺序一致。我们将在此模型下分析协议的正确性。\n\n#### **2.1. 写入者协议**\n\n要在一个块 $i$ 上发起一次写入，写入者线程必须成功获取一个“预留”。预留过程如下：\n\n1.  **初始检查：** 原子地加载状态 $s_i$。如果 $s_i=1$，表示该块已被标记为损坏。写入尝试立即中止。\n2.  **表明意图：** 如果初始检查通过（$s_i=0$），则使用 `fetch-add` 操作原子地增加活动写入者计数器 $a_i$。此操作表明线程的写入意图，并暂时将其包含在活动写入者集合中。\n3.  **最终检查（竞争检测）：** 在增加 $a_i$ *之后*，再次原子地加载状态 $s_i$。\n    -   如果 $s_i$ 仍然为 $0$，则预留成功。写入操作在此时“开始”，并且安全属性 $s_i(t_s)=0$ 得到满足。线程可以继续进行写入。\n    -   如果 $s_i=1$，则表示存在竞争条件：在写入者的初始检查和最终检查之间，一个 $\\mathrm{mark\\_bad}(i)$ 操作已经执行。预留无效。\n4.  **中止（如果需要）：** 如果最终检查失败，线程必须通过使用 `fetch-sub` 操作原子地减少 $a_i$ 来回退，取消其之前的增加操作。写入尝试被中止。\n5.  **完成：** 成功写入后，线程必须减少 $a_i$ 以表明其操作已完成。\n\n#### **2.2. 标记损坏协议**\n\n$\\mathrm{mark\\_bad}(i)$ 操作负责停用块 $i$。其过程如下：\n\n1.  **标记为损坏：** 原子地将值 $1$ 存入 $s_i$。从此刻起，没有新的写入者预留能够成功，因为写入者协议中的初始检查或最终检查都将观察到 $s_i=1$。\n2.  **排空活动写入者：** 进入一个等待循环（自旋），持续轮询 $a_i$ 的值。该操作仅在观察到 $a_i=0$ 时返回。这确保了所有在 $s_i$ 被设为 $1$ *之前* 成功预留该块的写入者都已完成其工作并减少了计数器。\n\n### **3. 正确性证明**\n\n我们现在基于存在一个可线性化的原子操作历史来证明该协议满足所要求的属性。\n\n#### **3.1. 安全性**\n\n安全属性要求，任何在块 $i$ 上开始的写入操作，其开始时间 $t_s$ 必须满足 $s_i(t_s)=0$。\n\n一次写入在其预留被确认的瞬间“开始”，即在写入者协议的第 3 步成功之后。我们将写入者在块 $i$ 上的原子操作表示为 $W_{load1}$（初始检查）、$W_{inc}$（增加 $a_i$）和 $W_{load2}$（最终检查）。将标记者的原子操作表示为 $M_{store}$（将 $s_i$ 设置为 $1$）。由于顺序一致性，这些操作会以某个全序出现。\n\n为了使预留成功，操作 $W_{load2}$ 必须读到值 $0$。这意味着在全序中，$W_{load2}$ 必须在 $M_{store}$ 之前发生：\n$$ \\dots \\rightarrow W_{load2} \\rightarrow \\dots \\rightarrow M_{store} \\rightarrow \\dots $$\n由于写入者线程内的程序顺序决定了 $W_{load1} \\rightarrow W_{inc} \\rightarrow W_{load2}$，一次成功写入的完整序列必须是：\n$$ \\dots \\rightarrow W_{load1} \\rightarrow \\dots \\rightarrow W_{inc} \\rightarrow \\dots \\rightarrow W_{load2} \\rightarrow \\dots \\rightarrow M_{store} \\rightarrow \\dots $$\n“开始时间” $t_s$ 对应于预留被确认的时刻，这发生在 $W_{load2}$ 之后。在这一瞬间，状态 $s_i$ 必须是 $0$，因为在线性化历史中 $M_{store}$ 尚未发生。\n\n现在考虑竞争的情况。如果 $M_{store}$ 发生在写入者的两次检查之间，历史记录看起来像这样：\n$$ \\dots \\rightarrow W_{load1} \\rightarrow \\dots \\rightarrow W_{inc} \\rightarrow \\dots \\rightarrow M_{store} \\rightarrow \\dots \\rightarrow W_{load2} \\rightarrow \\dots $$\n在这种情况下，$W_{load2}$ 将读到 $s_i=1$。写入者协议正确地识别了这种竞争，并通过减少 $a_i$ 来中止写入。因此，没有写入“开始”。安全属性在所有调度中都得到维护。\n\n#### **3.2. 对现有写入的非阻塞性**\n\n$\\mathrm{mark\\_bad}(i)$ 操作在执行 $M_{store}$ 后，等待 $a_i=0$。任何成功预留了该块的写入者，其 $W_{inc}$ 操作必定在 $M_{store}$ 之前执行。这个写入者现在是“在途的”。它只会在完成操作后才会减少 $a_i$。因此，只要有任何这样的在途写入者处于活动状态，$a_i$ 的值就会是非零的。因此，`mark_bad` 操作被迫等待（即被“阻塞”），直到所有这些写入者完成，从而满足了要求。\n\n#### **3.3. 进展性**\n\n一旦针对块 $i$ 的 $M_{store}$ 执行完毕，没有新的写入者能够成功通过其预留协议的第 3 步。虽然新的写入者可能会在第 2 步短暂地增加 $a_i$，但他们会在第 3 步检测到 $s_i=1$，并立即在第 4 步减少 $a_i$。因此，不会有新的、持久性的 $a_i$ 增量。\n\n对非零 $a_i$ 的仅剩贡献来自于在 $M_{store}$ 之前预留该块的有限数量的在途写入者。由于每次模拟写入都是一个有限操作，这些写入者中的每一个最终都会完成并减少 $a_i$。因此，可以保证 $a_i$ 的值最终会回到 $0$。这确保了 $\\mathrm{mark\\_bad}(i)$ 中的等待循环将会终止，从而保证了进展性。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n\n```", "id": "3622191"}]}