{"hands_on_practices": [{"introduction": "要真正掌握基于“盘区”的分配，最有效的方法之一就是亲手模拟分配器的行为。这个练习将引导你跟踪一个文件在磁盘上连续增长时，空闲空间列表的变化情况。通过这个过程，你将具体地理解盘区是如何被分割以满足分配请求，以及在文件删除后，这些碎片化的空间又是如何被合并（coalescing）的。[@problem_id:3640694]", "problem": "一个磁盘被建模为一个由非负整数索引的块的线性数组。一个“extent”（盘区）被定义为一段连续的块，由一个起始索引 $s$ 和一个长度 $\\ell$ 标识，覆盖了块 $s, s+1, \\dots, s+\\ell-1$。磁盘上初始的空闲列表由按 $s$ 升序排列的盘区 $\\{(s=0,\\ell=10),(s=20,\\ell=20),(s=50,\\ell=5)\\}$ 组成。一个文件按顺序以大小为 $[4,16,3,8]$ 个块的四次“burst”（爆发式增长）进行增长。系统使用一个基于盘区的分配器，其策略经过良好测试，如下所示：\n\n1. 空闲列表始终按起始索引 $s$ 的升序排序。\n2. 为满足大小为 $x$ 的爆发式请求，分配器从头开始扫描空闲列表，并贪婪地从当前空闲盘区的前缀中分割。对于一个空闲盘区 $(s,\\ell)$，它从 $s$ 开始分配 $\\min(x,\\ell)$ 个块。如果 $\\ell > \\min(x,\\ell)$，该空闲盘区被其剩余部分 $(s+\\min(x,\\ell),\\,\\ell-\\min(x,\\ell))$ 替换；如果 $\\ell = \\min(x,\\ell)$，该空闲盘区从空闲列表中移除。请求大小 $x$ 会减去已分配的数量，扫描继续进行，直到爆发式请求被完全满足。\n3. 将任何从一个先前空闲的盘区 $(s,\\ell)$ 中分配后留下一个正长度剩余部分 $(s',\\ell')$（其中 $\\ell' > 0$）的分配操作定义为一次“盘区分割”操作；消耗整个空闲盘区（即 $\\ell = \\min(x,\\ell)$）不计为一次分割。\n4. 在所有四次爆发式增长分配完毕后，该文件立即被删除。释放操作将每个已分配的盘区返回到空闲列表。然后空闲列表进行“合并”（coalescing）：任何满足 $s_1+\\ell_1 = s_2$ 的相邻空闲盘区对 $(s_1,\\ell_1)$ 和 $(s_2,\\ell_2)$ 都会被合并成一个单一盘区 $(s_1,\\ell_1+\\ell_2)$。合并过程持续进行，直到没有相邻的盘区对为止。将一次将一个相邻盘区对二元合并成一个盘区的操作定义为一次“合并”操作；一个包含 $k$ 个相邻盘区的链需要 $k-1$ 次合并操作。\n\n根据这些定义，计算在所有四次爆发式增长的分配过程中执行的盘区分割操作总数，加上在释放和随后的合并过程中执行的合并操作总数。请用一个无单位的整数表示您的最终答案。无需四舍五入。", "solution": "用户希望我扮演一位严谨苛刻的STEM领域教授来解决这个问题。我将首先验证问题的有效性，如果问题有效，我将提供一个分步的解决方案。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n-   **磁盘模型**：一个由非负整数索引的块的线性数组。\n-   **盘区（Extent）**：一段连续的块 `(s, l)`，覆盖块 `s, s+1, ..., s+l-1`。\n-   **初始空闲列表**：`{(s=0, l=10), (s=20, l=20), (s=50, l=5)}`，按 `s` 升序排列。\n-   **文件增长**：四次连续的爆发式增长，大小分别为 `[4, 16, 3, 8]` 个块。\n-   **分配策略**：\n    1.  空闲列表按起始索引 `s` 升序排序。\n    2.  对于大小为 `x` 的请求，从头开始扫描空闲列表。从一个空闲盘区 `(s, l)` 中，分配 `min(x, l)` 个块。剩余部分（如果存在）为 `(s + min(x,l), l - min(x,l))`。请求 `x` 的大小会相应减少，扫描继续，直到 `x` 变为零。\n-   **盘区分割定义**：任何留下正长度剩余部分 `(l' > 0)` 的分配操作。消耗整个盘区不算是分割。\n-   **释放与合并**：\n    1.  四次爆发式增长后，所有文件盘区都被返回到空闲列表。\n    2.  空闲列表被合并。满足 `s1 + l1 = s2` 的相邻盘区 `(s1, l1)` 和 `(s2, l2)` 会被合并。\n-   **合并操作定义**：将一个相邻对进行二元合并。一个由 `k` 个相邻盘区组成的链需要 `k-1` 次合并操作。\n-   **目标**：计算盘区分割操作的总数和合并操作的总数之和。\n\n**步骤2：使用提取的已知条件进行验证**\n\n-   **科学或事实上的不健全性**：问题是健全的。它描述了一个简化的、但标准的基于盘区的文件系统分配算法，这是操作系统中的一个核心主题。其逻辑是自洽的，并遵循既定的计算机科学原理。\n-   **无法形式化或不相关**：问题是形式化的并且直接相关。\n-   **不完整或矛盾的设置**：问题是完整的和自包含的。所有必要的数据、定义和算法都已明确提供。\n-   **不切实际或不可行**：该模型是一个简化模型，但其中的数值和操作在该模型内是完全可行的。\n-   **不适定或结构不良**：问题是适定的。分配算法的确定性确确保了状态序列的唯一性和单一的正确最终答案。\n-   **伪深刻、琐碎或同义反复**：问题并非琐碎；它要求根据指定规则对系统状态进行仔细的、一步步的追踪。\n-   **超出科学可验证性**：结果可以通过模拟所描述的过程来验证。\n\n**步骤3：结论与行动**\n\n问题有效。将提供完整的解决方案。\n\n### 解题过程\n\n解决方案要求追踪系统在分配阶段和释放/合并阶段的状态。设 $F$ 为空闲列表，$A$ 为分配给文件的盘区列表，并设 $N_{split}$ 和 $N_{merge}$ 分别为分割和合并操作的计数器。所有盘区都表示为元组 $(s, \\ell)$，其中 $s$ 是起始索引，$\\ell$ 是长度。\n\n**初始状态：**\n初始空闲列表为 $F_0 = \\{(s=0, \\ell=10), (s=20, \\ell=20), (s=50, \\ell=5)\\}$。\n文件的盘区列表为空：$A_0 = \\{\\}$。\n操作计数器初始化为零：$N_{split} = 0$，$N_{merge} = 0$。\n\n**分配阶段**\n\n我们按给定顺序处理四次爆发式分配：$[4, 16, 3, 8]$。\n\n**第1次爆发：请求大小 $x=4$**\n1.  扫描 $F_0$。第一个空闲盘区是 $(0, 10)$。\n2.  请求大小为 $x=4$，盘区长度为 $\\ell=10$。我们分配 $\\min(4, 10) = 4$ 个块。\n3.  一个盘区 $(0, 4)$ 被分配给文件。\n4.  请求被满足（$4-4=0$）。\n5.  空闲盘区 $(0, 10)$ 变为剩余部分 $(0+4, 10-4) = (4, 6)$。由于剩余部分长度 $6 > 0$，这是一次盘区分割。我们将 $N_{split}$ 增加到 $1$。\n第1次爆发后状态：\n-   $F_1 = \\{(4, 6), (20, 20), (50, 5)\\}$\n-   $A_1 = \\{(0, 4)\\}$\n-   $N_{split} = 1$\n\n**第2次爆发：请求大小 $x=16$**\n1.  扫描 $F_1$。第一个空闲盘区是 $(4, 6)$。\n2.  请求大小为 $x=16$，盘区长度为 $\\ell=6$。我们分配 $\\min(16, 6) = 6$ 个块。一个盘区 $(4, 6)$ 被分配。\n3.  请求现在变为 $16 - 6 = 10$。盘区 $(4, 6)$ 被完全消耗并从空闲列表中移除。这不是一次分割。\n4.  请求尚未被满足。继续扫描 $F_1$。下一个空闲盘区是 $(20, 20)$。\n5.  请求大小为 $x=10$，盘区长度为 $\\ell=20$。我们分配 $\\min(10, 20) = 10$ 个块。一个盘区 $(20, 10)$ 被分配。\n6.  请求现在被满足（$10-10=0$）。\n7.  空闲盘区 $(20, 20)$ 变为剩余部分 $(20+10, 20-10) = (30, 10)$。由于剩余部分长度 $10 > 0$，这是一次分割。我们将 $N_{split}$ 增加到 $1+1=2$。\n第2次爆发后状态：\n-   $F_2 = \\{(30, 10), (50, 5)\\}$\n-   $A_2 = \\{(0, 4), (4, 6), (20, 10)\\}$\n-   $N_{split} = 2$\n\n**第3次爆发：请求大小 $x=3$**\n1.  扫描 $F_2$。第一个空闲盘区是 $(30, 10)$。\n2.  请求大小为 $x=3$，盘区长度为 $\\ell=10$。我们分配 $\\min(3, 10) = 3$ 个块。一个盘区 $(30, 3)$ 被分配。\n3.  请求被满足（$3-3=0$）。\n4.  空闲盘区 $(30, 10)$ 变为剩余部分 $(30+3, 10-3) = (33, 7)$。由于剩余部分长度 $7 > 0$，这是一次分割。我们将 $N_{split}$ 增加到 $2+1=3$。\n第3次爆发后状态：\n-   $F_3 = \\{(33, 7), (50, 5)\\}$\n-   $A_3 = \\{(0, 4), (4, 6), (20, 10), (30, 3)\\}$\n-   $N_{split} = 3$\n\n**第4次爆发：请求大小 $x=8$**\n1.  扫描 $F_3$。第一个空闲盘区是 $(33, 7)$。\n2.  请求大小为 $x=8$，盘区长度为 $\\ell=7$。我们分配 $\\min(8, 7) = 7$ 个块。一个盘区 $(33, 7)$ 被分配。\n3.  请求现在变为 $8 - 7 = 1$。盘区 $(33, 7)$ 被完全消耗并从空闲列表中移除。这不是一次分割。\n4.  请求尚未被满足。继续扫描 $F_3$。下一个空闲盘区是 $(50, 5)$。\n5.  请求大小为 $x=1$，盘区长度为 $\\ell=5$。我们分配 $\\min(1, 5) = 1$ 个块。一个盘区 $(50, 1)$ 被分配。\n6.  请求现在被满足（$1-1=0$）。\n7.  空闲盘区 $(50, 5)$ 变为剩余部分 $(50+1, 5-1) = (51, 4)$。由于剩余部分长度 $4 > 0$，这是一次分割。我们将 $N_{split}$ 增加到 $3+1=4$。\n第4次爆发后状态：\n-   $F_4 = \\{(51, 4)\\}$\n-   $A_4 = \\{(0, 4), (4, 6), (20, 10), (30, 3), (33, 7), (50, 1)\\}$\n-   $N_{split} = 4$\n\n分配阶段完成。盘区分割操作的总数为 $N_{split} = 4$。\n\n**释放与合并阶段**\n\n文件被删除，所有在 $A_4$ 中的盘区都被返回到空闲列表。空闲列表必须保持按起始索引 $s$ 排序。\n当前的空闲列表是 $F_4 = \\{(51, 4)\\}$。\n待返回的盘区是 $A_4 = \\{(0, 4), (4, 6), (20, 10), (30, 3), (33, 7), (50, 1)\\}$。\n将这些盘区合并并排序，得到合并前的空闲列表：\n$F_{dealloc} = \\{(0, 4), (4, 6), (20, 10), (30, 3), (33, 7), (50, 1), (51, 4)\\}$.\n\n现在我们通过识别相邻盘区链来进行合并。如果 $s_1 + \\ell_1 = s_2$，则盘区 $(s_1, \\ell_1)$ 与 $(s_2, \\ell_2)$ 相邻。一个由 $k$ 个相邻盘区组成的链需要 $k-1$ 次合并操作。\n\n1.  **链1**：考虑 $(0, 4)$ 和 $(4, 6)$。这里，$s_1=0, \\ell_1=4$，所以 $s_1+\\ell_1 = 4$。这等于 $s_2=4$。它们是相邻的。下一个盘区是 $(20, 10)$，而 $4+6=10 \\ne 20$。所以，这个链是 $\\{(0, 4), (4, 6)\\}$。它有 $k=2$ 个盘区，需要 $k-1=1$ 次合并操作。\n\n2.  **链2**：考虑 $(20, 10)$ 和 $(30, 3)$。这里，$20+10 = 30$。它们是相邻的。现在考虑 $(30, 3)$ 和 $(33, 7)$。这里，$30+3 = 33$。它们也是相邻的。下一个盘区是 $(50, 1)$，而 $33+7=40 \\ne 50$。所以，这个链是 $\\{(20, 10), (30, 3), (33, 7)\\}$。它有 $k=3$ 个盘区，需要 $k-1=2$ 次合并操作。\n\n3.  **链3**：考虑 $(50, 1)$ 和 $(51, 4)$。这里，$50+1 = 51$。它们是相邻的。这是列表的末尾。所以，这个链是 $\\{(50, 1), (51, 4)\\}$。它有 $k=2$ 个盘区，需要 $k-1=1$ 次合并操作。\n\n合并操作的总数是每个链的合并次数之和：\n$N_{merge} = 1 + 2 + 1 = 4$。\n\n合并后的最终空闲列表将是 $\\{(0, 10), (20, 20), (50, 5)\\}$，这与初始空闲列表相同，符合预期。\n\n**最终计算**\n\n问题要求计算盘区分割操作的总数加上合并操作的总数。\n总操作数 = $N_{split} + N_{merge} = 4 + 4 = 8$。", "answer": "$$\\boxed{8}$$", "id": "3640694"}, {"introduction": "理解了碎片化是如何产生的之后，下一步自然是量化其影响。本练习引入了一个假设性但非常直观的碎片化度量指标，它对较小的盘区施加更重的惩罚，这恰好反映了它们在实际系统中更高的性能开销。通过比较同一个文件在两种不同分配结果下的碎片化程度，你将对“好”与“坏”的碎片化有一个定量的认识。[@problem_id:3640701]", "problem": "一个操作系统使用基于盘区的分配方式，其中文件以一系列连续的块（称为盘区）的形式存储。设一个给定文件的盘区长度表示为 $\\ell_{1}, \\ell_{2}, \\dots, \\ell_{k}$，其中每个 $\\ell_{i} \\in \\mathbb{N}$ 且 $\\ell_{i} > 0$。碎片化会降低性能，因为它既增加了每个盘区的元数据开销，也增加了盘区间的寻道操作。为了捕捉“较小的盘区比较大的盘区对每个块的危害更大”这一直觉，考虑为文件定义了以下无量纲的碎片化度量：\n$$F_{w} = \\sum_{i=1}^{k} \\frac{1}{\\ell_{i}}.$$\n两种分配结果存储了同一个包含 $40$ 个块的文件（因此两种情况下都有 $\\sum_{i=1}^{k} \\ell_{i} = 40$），但盘区分布不同：\n- 结果 A：$k = 2$ 个盘区，长度分别为 $\\ell_{1} = 22$ 和 $\\ell_{2} = 18$。\n- 结果 B：$k = 5$ 个盘区，长度分别为 $\\ell_{1} = 15$, $\\ell_{2} = 10$, $\\ell_{3} = 8$, $\\ell_{4} = 4$ 和 $\\ell_{5} = 3$。\n从盘区和碎片化的核心定义出发，解释为什么倒数权重 $\\frac{1}{\\ell_{i}}$ 强调了较小盘区相对于较大盘区的负面影响。然后计算结果 A 和结果 B 的 $F_{w}$。将你的两个数值结果表示为无四舍五入的精确既约分数，并按 $(\\text{A}, \\text{B})$ 的顺序列在一个单行矩阵中。该度量是无量纲的，因此你的答案中不需要物理单位。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于操作系统文件分配的原理，问题设定良好，数据一致且完整，并以客观的语言表述。\n\n问题要求解释一个碎片化度量，并计算两种不同文件分配结果下的该度量值。\n\n首先，我们分析碎片化度量 $F_{w} = \\sum_{i=1}^{k} \\frac{1}{\\ell_{i}}$ 背后的原理。该度量旨在量化将文件存储在多个不连续盘区中导致的性能下降。碎片化是有害的，因为每个盘区都需要自己的元数据（例如，起始块和长度），这增加了存储开销。此外，顺序访问文件可能需要在盘区之间进行寻道操作，这非常耗时。直觉上，对于一个总大小相同的文件，大量的小盘区比少量的大盘区更有害。\n\n该度量通过为每个长度为 $\\ell_i$ 的盘区分配一个等于其倒数 $\\frac{1}{\\ell_i}$ 的惩罚值来捕捉这种直觉。函数 $f(x) = \\frac{1}{x}$ (对于 $x > 0$) 有两个关键属性。\n1. 它是一个单调递减函数。这意味着随着盘区长度 $\\ell_i$ 的增加，其对碎片化分数 $F_w$ 的贡献会减少。例如，长度为 $\\ell_i = 2$ 的盘区贡献的惩罚值为 $\\frac{1}{2}$，而长度为 $\\ell_i = 20$ 的更大盘区贡献的惩罚值要小得多，为 $\\frac{1}{20}$。\n2. 该函数是凸函数，其递减速率对较大的 $x$ 会减小。其导数为 $f'(x) = -\\frac{1}{x^2}$。斜率的绝对值 $|f'(x)| = \\frac{1}{x^2}$ 对于小的 $x$ 非常大，并随着 $x$ 变大而趋近于 $0$。这表明对小盘区的惩罚不成比例地高。分割一个已经很小的盘区对该度量的影响远大于分割一个大盘区。例如，考虑一个 4 个块的段。将其存储为单个盘区对 $F_w$ 的贡献是 $\\frac{1}{4}$。将其存储为两个长度为 2 的盘区，贡献为 $\\frac{1}{2} + \\frac{1}{2} = 1$。将其存储为四个长度为 1 的盘区，贡献为 $\\frac{1}{1} + \\frac{1}{1} + \\frac{1}{1} + \\frac{1}{1} = 4$。对于固定数量的块，随着碎片化程度的增加，惩罚值急剧增加。\n\n因此，倒数权重 $\\frac{1}{\\ell_i}$ 通过为较小的盘区分配不成比例的高惩罚值，有效地强调了它们的负面影响，这与它们在真实系统中带来的性能成本相一致。\n\n接下来，我们为一个包含 40 个块的文件计算两种给定结果下的碎片化度量 $F_w$。\n\n**结果 A：**\n文件被存储在 $k=2$ 个盘区中，长度分别为 $\\ell_{1} = 22$ 和 $\\ell_{2} = 18$。总大小为 $\\ell_1 + \\ell_2 = 22 + 18 = 40$ 个块，这与题设一致。\n碎片化度量 $F_{w,A}$ 为：\n$$F_{w,A} = \\sum_{i=1}^{2} \\frac{1}{\\ell_i} = \\frac{1}{22} + \\frac{1}{18}$$\n为了对这些分数求和，我们找到一个公分母。$22 = 2 \\times 11$ 和 $18 = 2 \\times 3^2$ 的最小公倍数是 $\\text{lcm}(22, 18) = 2 \\times 3^2 \\times 11 = 198$。\n$$F_{w,A} = \\frac{9}{198} + \\frac{11}{198} = \\frac{9+11}{198} = \\frac{20}{198}$$\n这个分数可以通过分子分母同除以它们的最大公约数 2 来化简。\n$$F_{w,A} = \\frac{10}{99}$$\n\n**结果 B：**\n文件被存储在 $k=5$ 个盘区中，长度分别为 $\\ell_{1} = 15$, $\\ell_{2} = 10$, $\\ell_{3} = 8$, $\\ell_{4} = 4$ 和 $\\ell_{5} = 3$。总大小为 $\\ell_1+\\ell_2+\\ell_3+\\ell_4+\\ell_5 = 15+10+8+4+3=40$ 个块，这与题设一致。\n碎片化度量 $F_{w,B}$ 为：\n$$F_{w,B} = \\sum_{i=1}^{5} \\frac{1}{\\ell_i} = \\frac{1}{15} + \\frac{1}{10} + \\frac{1}{8} + \\frac{1}{4} + \\frac{1}{3}$$\n为了对这些分数求和，我们找到分母 $15, 10, 8, 4, 3$ 的最小公倍数。\n它们的质因数分解为：$15=3 \\times 5$，$10=2 \\times 5$，$8=2^3$，$4=2^2$ 和 $3=3$。\n最小公倍数是 $\\text{lcm}(15, 10, 8, 4, 3) = 2^3 \\times 3 \\times 5 = 120$。\n我们将每个分数通分到这个分母：\n$$F_{w,B} = \\frac{8}{120} + \\frac{12}{120} + \\frac{15}{120} + \\frac{30}{120} + \\frac{40}{120}$$\n将分子相加：\n$$F_{w,B} = \\frac{8+12+15+30+40}{120} = \\frac{105}{120}$$\n这个分数可以化简。$105$ 和 $120$ 的最大公约数是 $15$。\n$$F_{w,B} = \\frac{105 \\div 15}{120 \\div 15} = \\frac{7}{8}$$\n\n结果为 $F_{w,A} = \\frac{10}{99} \\approx 0.101$ 和 $F_{w,B} = \\frac{7}{8} = 0.875$。正如预期的那样，碎片化更严重的结果 B 的度量值明显高于结果 A。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{10}{99}  \\frac{7}{8} \\end{pmatrix}}$$", "id": "3640701"}, {"introduction": "即使磁盘总空闲空间充足，外部碎片也可能导致无法为大文件分配连续空间。解决方案是进行“碎片整理”（或称“压缩”），但这并非没有代价。最后一个练习将碎片整理过程构建成一个成本最小化问题：你需要通过移动最少的数据量，来创造一个足够大的连续空闲盘区，以满足新的分配请求。[@problem_id:3640686]", "problem": "一个操作系统的文件系统使用基于盘区（extent）的分配方式，其中文件占据一个或多个称为盘区的连续块序列。当空闲空间被分割成多个不连续的空闲盘区时，就会产生外部碎片。碎片整理（defragmentation）操作可以将整个已分配的盘区重定位到当前的空闲盘区中，以合并空闲空间。移动一个长度为 $L$ 的盘区会产生与 $L$ 成正比的成本，而一个碎片整理计划的总成本是所有被移动盘区长度的总和（以块为单位）。假设：\n- 只能移动整个盘区；已分配的盘区不能被分割。\n- 被移动的盘区必须完全放置在一个长度至少与其相等的当前空闲盘区内；分配到一个空闲盘区后可能会留下一个剩余的空闲碎片。\n- 除了连续性和容量外，没有元数据或对齐约束。\n- 移动后，任何相邻的空闲盘区都会自动合并成一个单一的空闲盘区。\n- 唯一考虑的成本是被移动的总块数；创建或合并空闲盘区没有额外成本。\n\n一个存储区域是从左到右的盘区线性序列，如下所示，其中每个项目列出了盘区类型及其以块为单位的长度：\n- $E_{1}$: 空闲，长度 $10$\n- $E_{2}$: 已分配，长度 $8$\n- $E_{3}$: 空闲，长度 $6$\n- $E_{4}$: 已分配，长度 $12$\n- $E_{5}$: 空闲，长度 $5$\n- $E_{6}$: 已分配，长度 $7$\n- $E_{7}$: 空闲，长度 $14$\n- $E_{8}$: 已分配，长度 $9$\n- $E_{9}$: 空闲，长度 $4$\n- $E_{10}$: 已分配，长度 $11$\n- $E_{11}$: 空闲，长度 $13$\n- $E_{12}$: 已分配，长度 $10$\n- $E_{13}$: 空闲，长度 $11$\n\n一个新文件需要一个大小为 $S = 24$ 个块的单一连续盘区。您需要规划一次手动碎片整理，通过移动已分配的盘区，使得整理后至少存在一个至少为 $S$ 个块的连续空闲区域。\n\n仅根据以上关于基于盘区的分配和碎片的定义和事实，确定为给新文件腾出空间而必须移动的最小总块数。请用一个整数表示所计算的块数。无需四舍五- 入，最终答案应以块为单位（最终方框答案中不包含单位）。", "solution": "问题要求计算创建至少 $S = 24$ 个块的单一连续空闲盘区的最小成本，该成本以移动的总块数来衡量。该文件系统使用基于盘区的分配方式。\n\n首先，我们必须将目标形式化。一个大小为 $S$ 的连续空闲盘区可以通过清空存储介质上的一个连续段来创建。这需要选择一个总长度至少为 $S$ 的相邻盘区序列 $\\{E_i, E_{i+1}, \\dots, E_j\\}$，然后将此序列中所有*已分配*的盘区移动到磁盘上的其他空闲位置。此操作的成本是所有被移动的已分配盘区的长度之和。我们的目标是找到满足长度要求、允许对其已分配盘区进行有效重定位且成本尽可能低的盘区序列。\n\n一个长度为 $L$ 的已分配盘区只有在存在一个长度至少为 $L$ 的“当前空闲的盘区”（即初始配置中的空闲盘区）时才能被移动。如果一个计划需要移动多个已分配的盘区，则必须有一组不同的、足够大的初始空闲盘区来容纳所有这些被移动的盘区。\n\n让我们列出所提供的盘区，记其类型（F代表空闲，A代表已分配）和长度 $L_i$。\n- $E_{1}$: F, $L_1 = 10$\n- $E_{2}$: A, $L_2 = 8$\n- $E_{3}$: F, $L_3 = 6$\n- $E_{4}$: A, $L_4 = 12$\n- $E_{5}$: F, $L_5 = 5$\n- $E_{6}$: A, $L_6 = 7$\n- $E_{7}$: F, $L_7 = 14$\n- $E_{8}$: A, $L_8 = 9$\n- $E_{9}$: F, $L_9 = 4$\n- $E_{10}$: A, $L_{10} = 11$\n- $E_{11}$: F, $L_{11} = 13$\n- $E_{12}$: A, $L_{12} = 10$\n- $E_{13}$: F, $L_{13} = 11$\n\n已分配盘区的长度集合是 $\\{8, 12, 7, 9, 11, 10\\}$。初始空闲盘区的长度集合是 $\\{10, 6, 5, 14, 4, 13, 11\\}$。最长的已分配盘区长度为 $12$，而最长的空闲盘区长度为 $14$ 和 $13$。因此，任何单个已分配盘区都可以被移动。对于需要多次移动的计划，我们将验证是否存在足够的空闲盘区。\n\n我们可以通过考虑所有可能被清空的连续盘区窗口来解决此问题。对于每个可能的起始盘区 $E_i$，我们找到其后总长度至少为 $S=24$ 的最短盘区序列 $E_i, \\dots, E_j$。然后我们计算清空此窗口的成本，即其中已分配盘区的长度之和。我们找到这些成本中的最小值。这种滑动窗口方法保证我们检查了所有最小的候选区域。\n\n让我们计算满足长度要求的每个最小窗口的成本。\n\n1.  从 $E_1$ 开始的窗口：\n    序列 $E_1, E_2, E_3$ 的总长度为 $10 + 8 + 6 = 24$。\n    此窗口中的已分配盘区：$E_2$ (长度 $8$)。\n    成本 = $8$。\n\n2.  从 $E_2$ 开始的窗口：\n    序列 $E_2, E_3, E_4$ 的总长度为 $8 + 6 + 12 = 26$。\n    已分配盘区：$E_2$ (长度 $8$)，$E_4$ (长度 $12$)。\n    成本 = $8 + 12 = 20$。\n\n3.  从 $E_3$ 开始的窗口：\n    序列 $E_3, E_4, E_5, E_6$ 的总长度为 $6 + 12 + 5 + 7 = 30$。\n    已分配盘区：$E_4$ (长度 $12$)，$E_6$ (长度 $7$)。\n    成本 = $12 + 7 = 19$。\n\n4.  从 $E_4$ 开始的窗口：\n    序列 $E_4, E_5, E_6$ 的总长度为 $12 + 5 + 7 = 24$。\n    已分配盘区：$E_4$ (长度 $12$)，$E_6$ (长度 $7$)。\n    成本 = $12 + 7 = 19$。\n\n5.  从 $E_5$ 开始的窗口：\n    序列 $E_5, E_6, E_7$ 的总长度为 $5 + 7 + 14 = 26$。\n    已分配盘区：$E_6$ (长度 $7$)。\n    成本 = $7$。\n\n6.  从 $E_6$ 开始的窗口：\n    序列 $E_6, E_7, E_8$ 的总长度为 $7 + 14 + 9 = 30$。\n    已分配盘区：$E_6$ (长度 $7$)，$E_8$ (长度 $9$)。\n    成本 = $7 + 9 = 16$。\n\n7.  从 $E_7$ 开始的窗口：\n    序列 $E_7, E_8, E_9$ 的总长度为 $14 + 9 + 4 = 27$。\n    已分配盘区：$E_8$ (长度 $9$)。\n    成本 = $9$。\n\n8.  从 $E_8$ 开始的窗口：\n    序列 $E_8, E_9, E_{10}$ 的总长度为 $9 + 4 + 11 = 24$。\n    已分配盘区：$E_8$ (长度 $9$)，$E_{10}$ (长度 $11$)。\n    成本 = $9 + 11 = 20$。\n\n9.  从 $E_9$ 开始的窗口：\n    序列 $E_9, E_{10}, E_{11}$ 的总长度为 $4 + 11 + 13 = 28$。\n    已分配盘区：$E_{10}$ (长度 $11$)。\n    成本 = $11$。\n\n10. 从 $E_{10}$ 开始的窗口：\n    序列 $E_{10}, E_{11}$ 的总长度为 $11 + 13 = 24$。\n    已分配盘区：$E_{10}$ (长度 $11$)。\n    成本 = $11$。\n\n11. 从 $E_{11}$ 开始的窗口：\n    序列 $E_{11}, E_{12}, E_{13}$ 的总长度为 $13 + 10 + 11 = 34$。\n    已分配盘区：$E_{12}$ (长度 $10$)。\n    成本 = $10$。\n\n从 $E_{12}$ 或 $E_{13}$ 开始的其他窗口总长度无法达到 $24$ 个块。\n\n比较计算出的成本：$\\{8, 20, 19, 19, 7, 16, 9, 20, 11, 11, 10\\}$。\n这些成本中的最小值是 $7$。\n\n最后，我们必须验证与最低成本相关的计划是有效的。\n成本为 $7$ 的最低成本方案对应于清空跨越 $E_5, E_6, E_7$ 的窗口。该计划需要移动一个已分配的盘区 $E_6$，其长度为 $7$ 个块。初始空闲盘区的长度为 $\\{10, 6, 5, 14, 4, 13, 11\\}$。有几个初始空闲盘区足够大以容纳 $E_6$，例如 $E_1$ (长度 $10$)、$E_7$ (长度 $14$)、$E_{11}$ (长度 $13$) 和 $E_{13}$ (长度 $11$)。由于被移动的盘区存在有效的目标位置，因此该计划是有效的。\n\n因此，必须移动的最小总块数是 $7$。", "answer": "$$\\boxed{7}$$", "id": "3640686"}]}