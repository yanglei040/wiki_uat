{"hands_on_practices": [{"introduction": "为了确保系统崩溃后能够快速恢复，日志文件系统使用检查点（checkpointing）机制来定期创建一致的磁盘状态。此练习旨在探讨检查点频率和恢复时间之间的基本权衡关系。你将通过建立一个简化模型，推导为满足特定恢复时间目标所需的最低检查点频率，这对于系统设计者来说是一项至关重要的计算。[@problem_id:3630989]", "problem": "您正在为一个操作系统设计一个日志存储子系统，该系统使用预写日志（Write-Ahead Logging, WAL）和定期检查点来确保崩溃一致性。检查点会将截至该时间点的所有更新刷新到主磁盘状态中，以便可以丢弃检查点之前的日志。假设系统承受着持续、稳定的写入负载，其恒定速率为每秒 $r$ 次操作（ops/sec）。系统以固定的频率 $f$（单位为赫兹）定期进行检查点操作，即每 $1/f$ 秒进行一次检查点。如果发生崩溃，恢复过程会重放最近一次检查点之后发生的所有已记录操作。\n\n假设遵循以下基本原则：\n- 根据速率的定义，如果一个进程以每秒 $q$ 次操作的速率执行 $t$ 秒，它将完成 $q \\cdot t$ 次操作；反之，以速率 $q$ 处理 $n$ 次操作所需的时间为 $n/q$ 秒。\n- 在恢复期间，日志重放引擎应用已记录操作的吞吐量与持续写入负载的吞吐量相同，即每秒 $r$ 次操作。这个模型将恢复过程视为受限于同一底层设备的 I/O。\n\n您的设计目标是将崩溃后最坏情况下的日志重放时间限制在最多 $T$ 秒内。在给定的假设和负载下，推导出一个关于 $T$ 和 $r$ 的最小检查点频率 $f$ 的封闭形式表达式，该表达式能在相对于检查点计划的任何崩溃时间下都满足此限制。请用赫兹表示 $f$。请以 $f(T,r)$ 的单个封闭形式解析表达式提供您的最终答案，无需进行数值计算或近似。", "solution": "问题陈述已经过验证，被认为是自洽的、有科学依据且定义明确的。我们可以开始求解。\n\n我们的目标是推导出一个最小检查点频率 $f$ 的表达式，该频率需确保崩溃后最坏情况下的日志重放时间不超过指定的持续时间 $T$。该系统的特点是具有恒定的写入负载速率 $r$ 和同样等于 $r$ 的恢复重放速率。\n\n设检查点频率为 $f$，单位为赫兹。因此，连续检查点之间的时间周期为 $P = \\frac{1}{f}$ 秒。检查点在时间 $t = 0, \\frac{1}{f}, \\frac{2}{f}, \\dots, \\frac{k}{f}, \\dots$ 进行。\n\n崩溃后，恢复过程包括重放自最近一次成功检查点以来记录的所有操作。我们考虑两个检查点之间的时间间隔，从时间 $t_{ckpt}$ 开始。下一个检查点计划在时间 $t_{ckpt} + \\frac{1}{f}$ 进行。\n\n如果崩溃发生在此时间间隔内的某个时间 $t_{crash}$（$t_{ckpt}  t_{crash} \\le t_{ckpt} + \\frac{1}{f}$），则自上一个检查点以来经过的时间为 $\\Delta t = t_{crash} - t_{ckpt}$。\n\n在这段时间 $\\Delta t$ 内，系统承受着每秒 $r$ 次操作的持续写入负载。根据所给出的“操作数是速率和时间的乘积”这一原则，日志中记录的操作数 $N_{logged}$ 为：\n$$N_{logged} = r \\cdot \\Delta t$$\n\n在恢复期间，这 $N_{logged}$ 次操作必须被重放。问题陈述指出，日志重放引擎以相同的速率 $r$ 应用这些已记录的操作。这次重放所需的时间 $T_{replay}$ 是要重放的总操作数除以重放速率：\n$$T_{replay} = \\frac{N_{logged}}{r}$$\n代入 $N_{logged}$ 的表达式，我们得到：\n$$T_{replay} = \\frac{r \\cdot \\Delta t}{r} = \\Delta t$$\n这是一个关键的中间结果：恢复时间恰好等于自上一个检查点完成以来所经过的时间。这是模型假设写入负载速率和恢复重放速率相同的直接结果。\n\n设计目标是限制*最坏情况*下的日志重放时间。为了找到最坏情况下的重放时间 $T_{replay, worst}$，我们必须确定使 $T_{replay}$ 最大化的情景。由于 $T_{replay} = \\Delta t$，这等同于寻找 $\\Delta t$ 的最大可能值。\n\n自上一个检查点以来的时间 $\\Delta t = t_{crash} - t_{ckpt}$，在崩溃发生在下一个检查点完成前的最晚可能时刻时达到最大值。上一个检查点和崩溃之间间隔的最大可能持续时间是完整的检查点周期 $\\frac{1}{f}$。\n因此，$\\Delta t$ 的最大可能值为：\n$$\\Delta t_{max} = \\frac{1}{f}$$\n这导致了最坏情况下的恢复时间：\n$$T_{replay, worst} = \\Delta t_{max} = \\frac{1}{f}$$\n\n问题规定，这个最坏情况下的恢复时间最多为 $T$ 秒。这可以转化为以下不等式：\n$$T_{replay, worst} \\le T$$\n代入我们关于 $T_{replay, worst}$ 的表达式：\n$$\\frac{1}{f} \\le T$$\n我们需要找到满足此条件的*最小*检查点频率 $f$。为此，我们解关于 $f$ 的不等式。鉴于 $f$（频率）和 $T$（时间）都是正的物理量，我们可以操作这个不等式。两边同乘以 $f$ 得到 $1 \\le f \\cdot T$。两边再同除以 $T$ 得到：\n$$f \\ge \\frac{1}{T}$$\n这个不等式表明，为了使恢复时间被限制在 $T$ 以内，检查点频率 $f$ 必须大于或等于 $\\frac{1}{T}$。满足此条件的最小频率位于可接受范围的边界上。\n因此，所需的最小频率为：\n$$f_{min} = \\frac{1}{T}$$\n这个表达式给出了最小检查点频率作为最大允许恢复时间 $T$ 的函数。值得注意的是，这个结果与写入负载速率 $r$ 无关，因为该参数对称地影响了写入的累积和重放的速度，导致它在最终的恢复时间关系式中被抵消了。", "answer": "$$\n\\boxed{\\frac{1}{T}}\n$$", "id": "3630989"}, {"introduction": "虽然日志记录（journaling）提供了崩溃一致性，但它也带来了性能开销，即“写放大”（write amplification）。本实践将通过比较两种常见的策略——仅元数据日志（metadata-only journaling）和全数据日志（full data journaling）——来深入研究如何量化这种开销。通过推导每种模式下的写放大率，你将对不同数据一致性保证的性能影响有一个具体的理解。[@problem_id:3631096]", "problem": "一个存储栈使用日志文件系统来提供崩溃一致性。日志以大小为 $j$ 的固定大小块写入，而应用程序写入的数据块大小为 $b$。考虑一个随机写入工作负载，其中每次逻辑写入都恰好更新一个大小为 $b$ 的数据块，并且由于随机性，无法与其他写入合并到共享的日志事务中。因此，每次逻辑写入都构成其自己的日志事务。系统使用以下两种策略之一：\n- 仅元数据日志记录：在变更被视为已提交之前，仅将描述变更的元数据写入日志；数据块被直接写入其原位置。\n- 全数据日志记录：在提交之前，数据和元数据都写入日志；随后，数据被写回到其原位置。\n\n假设关于日志记录存在以下被广泛接受的事实：\n1. 在两种策略中，每个事务都会写入一条占用一个大小为 $j$ 的日志块的元数据日志记录，以及一条占用一个大小为 $j$ 的日志块的提交记录。\n2. 在全数据日志记录中，大小为 $b$ 的数据负载首先被写入日志，占用 $\\lceil b / j \\rceil$ 个日志块，之后再被写入其原位置一次。\n3. 在仅元数据日志记录中，大小为 $b$ 的数据负载被直接写入其原位置一次，而不会写入日志。\n4. 写入放大定义为每次逻辑写入中写入存储设备的总字节数与该次逻辑写入的应用程序负载字节数之比。\n\n仅使用这些事实和定义，推导在仅元数据日志记录策略下的写入放大 $W_{\\text{meta}}(b,j)$ 和在全数据日志记录策略下的写入放大 $W_{\\text{full}}(b,j)$ 的精确闭式表达式，用 $b$ 和 $j$ 表示。将每种策略的最终答案表示为一个纯数（无量纲）。如果你的表达式需要取整操作，请使用天花板函数 $\\lceil \\cdot \\rceil$；不要进行近似或数值四舍五入。将这两个表达式以单行矩阵的形式给出，其中 $W_{\\text{meta}}(b,j)$ 在前，$W_{\\text{full}}(b,j)$ 在后。", "solution": "我们从写入放大的定义开始。对于一次负载大小为 $b$ 的逻辑写入，写入放大 $W$ 定义为写入设备的总字节数与应用程序写入的负载字节数之比：\n$$\nW \\equiv \\frac{\\text{total device bytes written per logical write}}{\\text{payload bytes per logical write}} = \\frac{\\text{device bytes}}{b}.\n$$\n\n在所述假设下，我们列举每种策略写入的设备字节数。\n\n仅元数据日志记录：\n- 应用程序数据块被写入其原位置一次，贡献了 $b$ 字节。\n- 日志接收一条元数据记录，占用一个大小为 $j$ 的日志块，贡献了 $j$ 字节。\n- 日志接收一条提交记录，占用一个大小为 $j$ 的日志块，又贡献了 $j$ 字节。\n将这些相加，在仅元数据日志记录策略下，每次逻辑写入的总设备字节数为\n$$\nb + j + j = b + 2j.\n$$\n因此，在仅元数据日志记录策略下的写入放大为\n$$\nW_{\\text{meta}}(b,j) = \\frac{b + 2j}{b}.\n$$\n\n全数据日志记录：\n- 大小为 $b$ 的数据负载首先被写入日志，该日志以大小为 $j$ 的块组织。向日志写入 $b$ 字节会消耗 $\\lceil b / j \\rceil$ 个日志块，总计 $\\lceil b / j \\rceil \\cdot j$ 字节。\n- 日志接收一条元数据记录，占用一个大小为 $j$ 的日志块，贡献了 $j$ 字节。\n- 日志接收一条提交记录，占用一个大小为 $j$ 的日志块，又贡献了 $j$ 字节。\n- 提交后，数据被写回到其原位置一次，贡献了 $b$ 字节。\n将这些相加，在全数据日志记录策略下，每次逻辑写入的总设备字节数为\n$$\n\\left\\lceil \\frac{b}{j} \\right\\rceil \\cdot j + j + j + b = \\left\\lceil \\frac{b}{j} \\right\\rceil j + 2j + b.\n$$\n因此，在全数据日志记录策略下的写入放大为\n$$\nW_{\\text{full}}(b,j) = \\frac{\\left\\lceil \\frac{b}{j} \\right\\rceil j + 2j + b}{b}.\n$$\n\n这两个表达式都是无量纲的比率，与写入放大的定义一致。没有执行数值四舍五入；天花板函数 $\\lceil \\cdot \\rceil$ 精确地捕捉了将 $b$ 字节写入日志时的日志块粒度。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{b+2j}{b}  \\frac{\\left\\lceil \\frac{b}{j} \\right\\rceil j + 2j + b}{b}\\end{pmatrix}}$$", "id": "3631096"}, {"introduction": "日志文件系统为实现一致性提供了工具，但应用程序开发者有责任正确使用这些工具来完成复杂的多步更新。此练习将你置于系统程序员的角色，审查一个常见但有缺陷的更新协议。你的挑战是找出由系统崩溃导致的细微错误，并应用正确的`fsync`系统调用序列来保证操作的原子性，这是构建稳健软件的一项关键技能。[@problem_id:3631038]", "problem": "您正在审查一个应用层更新协议，该协议旨在原子地发布一个新的不可变数据对象和一个命名当前对象的小型清单文件。该系统运行在典型的可移植操作系统接口（POSIX）文件系统上。假设以下标准且经过充分测试的语义作为您的基础：`write` 系统调用在数据进入页面缓存后返回，并可以在稍后以任意顺序到达存储设备；`rename` 系统调用相对于目录命名空间是原子的，但若无进一步操作则不一定是持久的；对常规文件执行文件同步系统调用（`fsync`）会将其文件内容和元数据刷新到稳定存储；对目录执行 `fsync` 会刷新目录条目的变更，例如 `create`、`unlink` 和 `rename`。\n\n文件和不变量：\n- 目录包含名为 \"obj.v$k$\" 的不可变内容文件和一个名为 \"manifest\" 的清单文件。\n- 清单文件只包含一行：当前对象文件的基本名称，例如 \"obj.v$17$\"。\n- 不变量：在任何崩溃和随后的重启之后，清单必须仅包含同一目录中一个已存在且已完全写入的对象文件的基本名称。\n\n有吸引力但错误的更新协议 $P$（处处都没有 `fsync` 调用）：\n- 步骤 $1$：创建新对象并将其写入临时文件 \"obj.tmp\"；关闭它。\n- 步骤 $2$：在同一目录中将 \"obj.tmp\" 重命名为最终名称 \"obj.v$k+1$\"。\n- 步骤 $3$：创建 \"manifest.tmp\"，将 ASCII 名称 \"obj.v$k+1$\" 写入其中；关闭它。\n- 步骤 $4$：在同一目录中将 \"manifest.tmp\" 重命名覆盖 \"manifest\"；返回成功。\n\n问题：哪个选项指出了一个在所述语义下违反不变量的具体崩溃交错情况，并给出了修复协议 $P$ 以在任何崩溃下保持不变量的 `fsync` 调用的正确最小化部署？这里的“最小化”是指使用最少的必要 `fsync` 调用来防止不变量被违反，而不引入单独的预写日志或更改文件布局。\n\n选择一项：\n\nA. 没有崩溃交错可以违反不变量，因为 `rename` 是原子的；因此协议 $P$ 已经是正确的。不需要 `fsync` 调用。\n\nB. 崩溃交错：系统在步骤 $4$ 之后立即崩溃；存储已经持久化了 \"manifest.tmp\" 到 \"manifest\" 的重命名，但没有持久化 \"obj.tmp\" 到 \"obj.v$k+1$\" 的重命名。恢复时，\"manifest\" 命名了 \"obj.v$k+1$\"，但该文件不存在。修复：在步骤 $4$ 之后对 \"manifest\" 添加一个 `fsync` 调用；不需要其他 `fsync`。\n\nC. 崩溃交错：系统在步骤 $4$ 之后立即崩溃；由于乱序持久化，步骤 $4$ 中的重命名到达了存储设备，但步骤 $2$ 中的重命名没有。恢复时，\"manifest\" 命名了 \"obj.v$k+1$\"，但该文件缺失。修复（最小化）：在步骤 $2$ 之前对新对象文件的文件描述符执行 `fsync`，使其内容持久化，然后执行步骤 $2$ 并对包含目录执行 `fsync`，使 \"obj.v$k+1$\" 目录条目持久化。接下来，执行步骤 $3$ 并对 \"manifest.tmp\" 文件执行 `fsync`，使其内容在发布前持久化。最后，执行步骤 $4$。步骤 $4$ 之后的最终目录 `fsync` 对于返回值的持久性是可选的，但对于保持不变量不是必需的。\n\nD. 崩溃交错：系统在步骤 $1$ 和 $2$ 之间崩溃。恢复时，不变量被违反，因为 \"manifest\" 可能命名 \"obj.v$k+1$\"，而新对象不存在。修复：在步骤 $1$ 之后对 \"obj.tmp\" 插入一个 `fsync`。\n\nE. 崩溃交错：系统在步骤 $4$ 之后立即崩溃，尽管两个重命名都持久化了，但 \"manifest\" 的内容是空的，因为对 \"manifest.tmp\" 的写入没有被持久化。修复：使用同步写入标志打开 \"obj.tmp\" 和 \"manifest.tmp\"，并省略所有 `fsync` 调用；仅同步写入就足够了。", "solution": "我们从陈述的基本语义开始。`write` 系统调用仅保证数据到达页面缓存；操作系统稍后可能会将脏页推送到存储设备，可能会对不同文件的写入进行重排序。`rename` 系统调用相对于目录命名空间是原子的，因为读者永远不会观察到部分更新的目录条目；然而，`rename` 并不保证新目录条目的持久性，除非对包含目录执行了 `fsync`。对常规文件执行文件同步系统调用（`fsync`）会刷新该文件的数据和元数据到存储设备。要使目录条目（如 `create`、`unlink` 和 `rename`）持久化，必须对包含这些条目的目录执行 `fsync`。最后，为了防止暴露内容尚未持久化的文件，必须在命名空间中发布对它的引用之前，确保文件内容已持久化。\n\n不变量要求在任何崩溃之后，清单仅包含一个已存在且已完全写入的对象文件的基本名称。一个需要寻找的自然故障模式是发布顺序异常：一个引用（清单）在被引用的对象（新对象文件）持久存在之前就变得持久，或者清单本身的内容在 `rename` 使其可见时不是持久的。\n\n逐项分析：\n\n- 选项 A：这声称协议 $P$ 是安全的，因为 `rename` 是原子的。这混淆了原子性和持久性。协议 $P$ 在步骤 $2$ 和 $4$ 中对两个不同的文件执行了两次 `rename`，没有顺序或持久性保证。由于乱序持久化，\"manifest.tmp\" 到 \"manifest\" 的重命名可以到达设备，而 \"obj.tmp\" 到 \"obj.v$k+1$\" 的重命名却没有，在崩溃后留下一个命名了不存在对象的清单。因此，声称没有崩溃可以违反不变量是错误的。结论 — 不正确。\n\n- 选项 B：这种交错是可能的：清单的重命名可以持久化，而对象的重命名却没有，这导致 \"manifest\" 命名了一个缺失的 \"obj.v$k+1$\"。然而，提议的修复方案是在步骤 $4$ 之后仅对 \"manifest\" 添加一个 `fsync` 调用。这没有解决核心风险。对 \"manifest\" 执行 `fsync` 会刷新清单文件的内容及其元数据；除非对包含目录执行 `fsync`，否则它不会使目录条目的变更持久化。更重要的是，它没有做任何事情来确保当清单命名 \"obj.v$k+1$\" 时，该文件要么存在，要么是持久的；清单仍然可能在 \"obj.v$k+1$\" 目录条目在磁盘上存在之前就变得持久。因此，不变量仍然可能被违反。结论 — 不正确。\n\n- 选项 C：所描述的交错情况符合现实中的风险：步骤 $4$ 持久化了，步骤 $2$ 没有。提议的修复方案在最小发布边界处使用了三个 `fsync` 调用：\n  - 在步骤 $2$ 中通过 `rename` 发布新对象文件之前，对其进行 `fsync`。这确保了对象的数据和元数据是持久的。\n  - 在步骤 $2$ 之后，对包含目录执行 `fsync`，以使 \"obj.v$k+1$\" 目录条目持久化。现在，即使清单稍后变得可见，它也将引用一个持久存在的对象。\n  - 在步骤 $4$ 中通过 `rename` 发布新清单之前，对 \"manifest.tmp\" 文件进行 `fsync`，以确保清单的内容（路径名 \"obj.v$k+1$\"）在暴露前是持久的。这可以防止在 `rename` 到达设备后，崩溃导致留下一个零长度或损坏的新清单。\n  - 步骤 $4$ 之后的最终目录 `fsync` 对于保持不变量不是必需的：如果它没有发生而发生崩溃，系统要么将保留旧清单（安全），要么可能已经持久化了新清单，而新清单的内容根据构造是持久的，并且指向一个持久存在的对象（也安全）。只有当应用程序需要保证更新在其返回成功的那一刻是持久的情况下，最终的目录 `fsync` 才是必要的。\n  相对于不变量，这个部署是最小的：省略其中任何一个 `fsync` 调用都可能重新引入一个时间窗口，在此窗口中，一个持久化的清单命名了一个非持久化或缺失的对象，或者一个持久化的 `rename` 操作暴露了一个内容非持久化的清单。结论 — 正确。\n\n- 选项 D：该交错假设在步骤 $1$ 和 $2$ 之间发生崩溃，并声称不变量被违反。在步骤 $1$ 和 $2$ 之间，没有任何东西被发布：旧清单仍然命名 \"obj.v$k$\"，而新对象仅在 \"obj.tmp\" 中。此时的崩溃会使旧状态保持不变。因此，这里不会出现不变量违反。此外，提议的修复（在步骤 $1$ 后 `fsync` \"obj.tmp\"）在那个时候对于正确性是不必要的，因为临时文件还不能通过命名空间访问；它既没有解决正确性上的差距，也没有处理发布边界问题。结论 — 不正确。\n\n- 选项 E：该交错指出了一个关于清单内容的真实风险：如果对 \"manifest.tmp\" 的写入不是持久的，`rename` 可能会暴露一个内容为空或陈旧的清单。然而，提议的修复（使用同步写入标志打开并省略 `fsync`）是不够的。对常规文件的同步写入不会使目录条目变更持久化；因此，目录重命名仍然可能丢失，产生一个命名了缺失对象或尚未持久存在的对象的清单。此外，仅仅依赖同步写入并不能保证对象的内容在通过 `rename` 发布之前是持久的，除非仔细控制了顺序并且同步了目录。因此，这个修复对于所有崩溃交错情况都不能满足不变量。结论 — 不正确。\n\n因此，只有选项 C 既指出了一个具体的违规交错，又提供了一个正确的最小化 `fsync` 部署，该部署根据所述不变量修复了协议 $P$。", "answer": "$$\\boxed{C}$$", "id": "3631038"}]}