{"hands_on_practices": [{"introduction": "在持久内存上构建可靠系统，核心挑战在于如何保证更新操作的原子性——即操作要么完全成功，要么在发生崩溃时完全不留痕迹。本练习将引导你进行一个思想实验，通过分析几种经典的崩溃一致性协议，如“写时复制”（Copy-on-Write）和“预写日志”（Write-Ahead Logging），来深入理解写操作排序、缓存行写回以及内存屏障在防止数据损坏中的关键作用。通过这个练习，你将学会如何在概念层面设计和评估一个持久文件系统的更新策略。[@problem_id:3669193]", "problem": "一个构建在非易失性双列直插式内存模块 (NVDIMM) 上的持久内存 (PMem) 文件系统必须原子地更新一个文件：替换一个 $4\\,\\mathrm{KiB}$ 数据块的内容，并更新存储指向该块的指针和文件长度的 inode 元数据。该机器有一个带有易失性缓存的中央处理器 (CPU)；一次存储操作只有在相应的缓存行被显式地写回到 PMem 并且这些写操作通过一个持久化屏障进行排序后，才能到达持久化状态。假设以下广为接受的原语和事实作为起点基础：\n- 缓存行写回 (CLWB) 或优化缓存行刷新 (CLFLUSHOPT) 会导致指定的缓存行被写回到 PMem，但它本身并不保证与后续存储操作的顺序。\n- 存储屏障 (SFENCE) 对先前的缓存行写回和存储操作与后续的存储操作进行排序，在持久化顺序中创建一个先行发生关系 (happens-before)。\n- 在 $t_c$ 时刻发生崩溃时，持久化状态等于在 $t_c$ 之前到达 PMem 的缓存行写回序列的某个前缀；易失性缓存的状态会丢失。\n- 不要假设多千字节的原子持久性；只假设在写回完成后，在缓存行级别具有失败原子性。\n\n设旧状态由 $(B_{\\text{old}},P_{\\text{old}},L_{\\text{old}})$ 描述，其中 $B_{\\text{old}}$ 是旧数据块内容，$P_{\\text{old}}$ 是 inode 中指向旧块的指针，$L_{\\text{old}}$ 是旧长度。新的目标状态是 $(B_{\\text{new}},P_{\\text{new}},L_{\\text{new}})$，其中 $B_{\\text{new}}$ 是新数据块内容，$P_{\\text{new}}$ 指向新块，$L_{\\text{new}}$ 是新长度。崩溃一致性不变量 $I$ 是：在 $t_c$ 时刻发生任何崩溃后，恢复的文件必须呈现 $(B_{\\text{old}},P_{\\text{old}},L_{\\text{old}})$ 或 $(B_{\\text{new}},P_{\\text{new}},L_{\\text{new}})$ 之一，但绝不能是像 $(B_{\\text{old}},P_{\\text{new}},L_{\\text{new}})$ 或 $(B_{\\text{new}},P_{\\text{old}},L_{\\text{old}})$ 这样的混合状态。\n\n考虑以下候选的更新与恢复设计。每个选项都描述了一种协议以及在元数据和数据更新之间任何时间点发生崩溃时的恢复叙述。选择所有既能强制执行不变量 $I$ 又能陈述从所述基础推导出的准确恢复叙述的选项。\n\nA. 带有序持久化的写时复制。为 $B_{\\text{new}}$ 分配一个新块，将新的有效负载写入其中，对新块的所有缓存行发出 CLWB，然后发出 SFENCE。接下来，将 inode 字段更新为 $(P_{\\text{new}},L_{\\text{new}})$，对 inode 的缓存行发出 CLWB，然后发出 SFENCE。恢复叙述：如果在第一个 SFENCE 完成前发生崩溃，inode 保持在 $(P_{\\text{old}},L_{\\text{old}})$，读取者看到 $B_{\\text{old}}$；如果在第一个 SFENCE 完成后但在第二个 SFENCE 完成前发生崩溃，inode 仍然指向 $P_{\\text{old}}$，因此读取者看到 $B_{\\text{old}}$；如果在第二个 SFENCE 完成后发生崩溃，读取者看到 $(P_{\\text{new}},L_{\\text{new}})$ 和 $B_{\\text{new}}$。在任何情况下，$(P_{\\text{new}},L_{\\text{new}})$ 都不会在 $B_{\\text{new}}$ 未持久化的情况下可见。\n\nB. 元数据优先的就地更新。首先，将 inode 更新为 $(P_{\\text{new}},L_{\\text{new}})$，对 inode 的缓存行发出 CLWB，然后发出 SFENCE。接下来，用 $B_{\\text{new}}$ 覆写旧的数据块，对其缓存行发出 CLWB，然后发出 SFENCE。恢复叙述：如果在第一个 SFENCE 完成后但在第二个 SFENCE 完成前发生崩溃，inode 可能会持久化为 $(P_{\\text{new}},L_{\\text{new}})$，而数据块仍包含 $B_{\\text{old}}$ 或部分数据，因此读取者可能会观察到混合状态。\n\nC. 无中间屏障的写时复制。分配一个新块并将 $B_{\\text{new}}$ 写入其中；对新块的所有缓存行发出 CLWB，但尚不发出屏障。立即将 inode 更新为 $(P_{\\text{new}},L_{\\text{new}})$，对 inode 的缓存行发出 CLWB，然后在末尾发出一个单独的 SFENCE。恢复叙述：因为首先对数据使用了 CLWB，所以持久化顺序得到保证，因此崩溃绝不会在没有 $B_{\\text-new}}$ 的情况下暴露 $(P_{\\text{new}},L_{\\text{new}})$。\n\nD. 带提交的预写重做日志（日志记录）。构造一个包含新有效负载 $B_{\\text{new}}$ 和元数据更改 $(P_{\\text{new}},L_{\\text{new}})$ 以及一个校验和的重做日志记录。将该记录追加到重做日志中，对其所有缓存行发出 CLWB，然后发出 SFENCE。接下来，为该记录追加一个提交标记，对提交标记所在的行发出 CLWB，然后发出 SFENCE。在提交持久化之后，可以在任何后续时间以任何顺序将更改就地应用到数据块和 inode，并为所接触的行发出 CLWB；可以选择将这些操作与稍后的 SFENCE 一起批处理。恢复叙述：崩溃后，系统只重放已提交且校验和有效的日志记录，幂等地同时安装 $B_{\\text{new}}$ 和 $(P_{\\text{new}},L_{\\text{new}})$；未提交的记录被忽略。因此，恢复后，文件要么处于旧状态，要么处于新状态，绝不会是混合状态，即使崩溃发生在安装了一个字段但未安装另一个字段之后。", "solution": "问题陈述在科学上和逻辑上是有效的。它基于计算机体系结构和操作系统的既定原则，特别是关于使用持久内存 (PMem) 的文件系统中的崩溃一致性。所提供的原语——`CLWB`/`CLFLUSHOPT`、`SFENCE` 以及一个明确定义的崩溃模型——准确地反映了在像 x86-64 这样的体系结构上进行真实世界 PMem 编程的一个标准的、简化的模型。目标是确保原子更新，这由不变量 $I$ 定义，该不变量要求文件操作从一个一致的旧状态 $(B_{\\text{old}}, P_{\\text{old}}, L_{\\text{old}})$ 过渡到一个一致的新状态 $(B_{\\text{new}}, P_{\\text{new}}, L_{\\text{new}})$，而在从崩溃中恢复时不会暴露任何中间的、不一致的混合状态。这个问题是适定的，为评估所提议协议的正确性提供了足够的信息。我们现在将对每个选项进行分析。\n\n**选项 A 的分析：带有序持久化的写时复制。**\n协议如下：\n1. 将新数据 $B_{\\text{new}}$ 写入一个新分配的块。\n2. 为 $B_{\\text{new}}$ 的所有缓存行发出 `CLWB`。\n3. 发出 `SFENCE`。\n4. 将 inode 更新为 $(P_{\\text{new}}, L_{\\text{new}})$。\n5. 为 inode 的缓存行发出 `CLWB`。\n6. 发出 `SFENCE`。\n\n该协议实现了写时复制 (CoW) 策略。关键特性是在刷新新数据块之后、更新 inode 指针*之前*使用了 `SFENCE` 指令（步骤3）。根据问题的定义，`SFENCE` 在持久化顺序中创建了一个先行发生关系 (happens-before)。这确保了 $B_{\\text{new}}$ 的所有缓存行写回都在 inode 的后续写回被持久化之前持久化。\n\n让我们分析崩溃的可能性：\n- 如果在第一个 `SFENCE`（步骤3）完成之前的任何时刻发生崩溃，$B_{\\text{new}}$ 新数据块的持久化无法得到保证。但是，inode 的更新尚未被持久化，因此文件系统指针 $P_{\\text{old}}$ 仍然指向旧块 $B_{\\text{old}}$。恢复时，系统看到的是原始状态 $(B_{\\text{old}}, P_{\\text{old}}, L_{\\text{old}})$。新分配的块实际上是不可达的垃圾。\n- 如果在第一个 `SFENCE` 完成之后、第二个 `SFENCE` 完成之前发生崩溃，新数据 $B_{\\text{new}}$ 被保证是完全持久化的。对 $(P_{\\text{new}}, L_{\\text{new}})$ 的 inode 更新可能已经持久化，也可能没有。如果没有，系统将恢复到旧状态 $(B_{\\text{old}}, P_{\\text{old}}, L_{\\text{old}})$。如果 inode 更新*已经*持久化，系统将恢复到新状态 $(B_{\\text{new}}, P_{\\text{new}}, L_{\\text{new}})$。在这种情况下，由于 inode 指向 $P_{\\text{new}}$，该位置的数据 $B_{\\text{new}}$ 已经被保证是持久的。\n在任何情况下，持久化的 inode 都不可能指向一个非持久化或部分持久化的数据块。因此，不变量 $I$ 得以强制执行。\n\n选项中提供的恢复叙述与此分析一致。它正确地指出，如果在最终状态提交前发生崩溃，inode 将指向旧块；并且关键属性是，在没有新数据持久化的情况下，新指针绝不会可见。\n结论：**正确**。\n\n**选项 B 的分析：元数据优先的就地更新。**\n协议如下：\n1. 将 inode 更新为 $(P_{\\text{new}}, L_{\\text{new}})$。\n2. 对 inode 发出 `CLWB`。\n3. 发出 `SFENCE`。\n4. 用 $B_{\\text{new}}$ 覆写数据块。\n5. 对数据块发出 `CLWB`。\n6. 发出 `SFENCE`。\n\n该协议优先持久化元数据更新。在步骤3完成之后、步骤6完成之前发生崩溃会产生一个关键故障。在这个时间窗口内，inode 被持久地更新为 $(P_{\\text{new}}, L_{\\text{new}})$，但数据块（大小为 $4\\,\\mathrm{KiB}$，因此跨越多个缓存行）可能只被部分更新。例如，inode 可能指向一个包含 $B_{\\text{old}}$ 和 $B_{\\text{new}}$ 混合内容的块，这是一种损坏状态。这直接导致一个混合的、不一致的状态，违反了不变量 $I$。\n\n问题要求选择*强制执行不变量 I*的选项。该协议未能做到这一点。尽管其附带的恢复叙述准确地描述了这一失败，但协议本身是有缺陷的，并不代表原子更新问题的有效解决方案。\n结论：**不正确**。\n\n**选项 C 的分析：无中间屏障的写时复制。**\n协议如下：\n1. 将新数据 $B_{\\text{new}}$ 写入一个新块。\n2. 为 $B_{\\text{new}}$ 的所有缓存行发出 `CLWB`。\n3. 将 inode 更新为 $(P_{\\text{new}}, L_{\\text{new}})$。\n4. 为 inode 的缓存行发出 `CLWB`。\n5. 发出 `SFENCE`。\n\n该协议省略了在刷新数据和刷新元数据之间的关键 `SFENCE`。问题陈述中明确指出，`CLWB` “本身并不保证顺序”。内存硬件可以自由地对向 PMem 的写操作进行重排序。如果没有中间的 `SFENCE`，inode 的 `CLWB`（步骤4）可能在数据块 $B_{\\text{new}}$ 的 `CLWB`（步骤2）之前被持久化，即使它是后发出的。\n\n如果在 inode 被持久化之后、但在 $B_{\\text{new}}$ 完全持久化之前发生崩溃，系统将恢复到一个 inode 具有 $(P_{\\text{new}}, L_{\\text{new}})$ 但指向一个部分写入、已损坏的数据块的状态。这违反了不变量 $I$。恢复叙述中“持久化顺序得到保证”的说法，基于问题自身的定义，在事实上是错误的，因为它误解了 `CLWB` 的行为。\n结论：**不正确**。\n\n**选项 D 的分析：带提交的预写重做日志（日志记录）。**\n该协议是一个使用重做日志的标准两阶段提交方案：\n1.  **日志**：将一个包含所有更改（$B_{\\text{new}}$ 和 $(P_{\\text{new}}, L_{\\text{new}})$）的日志记录追加到日志中，并将其持久化（`CLWB` + `SFENCE`）。\n2.  **提交**：为该日志记录追加一个提交标记，并将其持久化（`CLWB` + `SFENCE`）。\n3.  **应用**：提交后，将日志中的更改应用到它们的原始位置。\n\n该协议通过使提交记录的持久化成为原子决策点来实现原子性。\n- **恢复**：恢复过程扫描日志。\n    - 如果找到一个没有相应提交标记的日志记录，它将被忽略。如果崩溃发生在步骤2完成之前，就会发生这种情况。数据和 inode 的原始位置保持不变，因此系统处于状态 $(B_{\\text{old}}, P_{\\text{old}}, L_{\\text{old}})$。\n    - 如果找到一个已提交的日志记录，恢复过程会重放日志中指定的更改，将它们应用到其原始位置。这种重放必须是幂等的，意味着可以安全地重复而不会改变结果。例如，将 $B_{\\text{new}}$ 写入一个块是幂等的。如果在这个“应用”阶段发生崩溃，恢复过程将在下次启动时简单地重新开始并重新应用更改，最终使系统达到完整的新状态 $(B_{\\text{new}}, P_{\\text{new}}, L_{\\text{new}})$。\n\n这种机制确保从恢复后的用户角度来看，文件系统从旧状态原子地过渡到新状态。恢复叙述正确地描述了此过程及其结果。该协议是健全的，并正确地强制执行了不变量 $I$。\n结论：**正确**。", "answer": "$$\\boxed{AD}$$", "id": "3669193"}, {"introduction": "理解了如何实现一致性协议之后，一个优秀的系统工程师还必须考虑其性能成本。本练习要求你从定性概念转向定量分析，通过建立一个简化的性能模型，推导出一个临界点，在该点之上，“写时复制”协议的成本将低于“撤销日志”（Undo Logging）协议。这个练习旨在强调，在系统设计中，理解工作负载特性并进行量化权衡是做出正确技术选型的基础。[@problem_id:3669271]", "problem": "一个操作系统将非易失性内存（NVM）集成到其内存层次结构中。一个简单的持久化键值映射存储为大小为 $S$ 字节的单个连续区域，并通过写时复制或撤销日志实现崩溃一致性。硬件提供的缓存行大小为 $L$ 字节。假设记录大小 $s$ 和区域大小 $S$ 都是 $L$ 的整数倍，即对于某个正整数 $q$ 和 $m$，有 $s = qL$ 和 $S = mL$。该平台提供两种原语：(i) 缓存行持久化操作，使单个缓存行持久化，延迟为 $t_p$；(ii) 存储栅栏，延迟为 $t_{sf}$，用于对先前发出的持久化操作进行排序并等待其完成持久化。所有其他成本（例如，分配和计算）均可忽略不计。假设操作是串行化的，并且持久化延迟没有重叠。\n\n考虑一个执行 $N$ 次更新的事务，每次更新恰好修改一个大小为 $s$ 字节且与缓存行边界对齐的记录。实现了两种更新协议：\n\n- 写时复制（CoW）：系统分配整个映射区域的一个全新副本，复制整个区域，持久化新区域，然后安装一个指向该复制区域的新根指针并持久化该指针。在所有持久化操作之后发出一个存储栅栏，以确保在返回成功之前数据已持久化。\n\n- 撤销日志（Undo Logging）：对于每次更新，系统写入一条包含被覆盖的 $s$ 字节的撤销日志记录，持久化该日志记录以确保其在原地更新之前是持久且有序的，然后执行记录的原地更新并持久化修改后的数据。每次更新都会发出一个存储栅栏，以强制撤销日志在原地数据写入被视为完成之前是持久的，并且在所有更新之后还会发出一个额外的最终存储栅栏，以确保在返回成功之前所有修改的数据都已持久化。\n\n仅使用以下基本事实：\n- 崩溃一致性要求在旧数据被部分持久化时，旧状态必须是可恢复的。这可以通过在安装指针之前持久化一个备用副本（写时复制）或在原地更新之前持久化一个撤销日志来实现。\n- 只有在其持久化操作完成后，一个缓存行才是持久的；跨行的持久化顺序需要一个存储栅栏。\n- 时间成本是所有缓存行持久化延迟与所有存储栅栏延迟的总和，以累加方式计算。\n\n从第一性原理推导出最小整数阈值 $N_{\\text{th}}$ 的闭式表达式，使得对于 $N$ 次更新，撤销日志协议的总持久化成本（持久化延迟加栅栏延迟）大于或等于写时复制协议的总持久化成本，即，写时复制变得不比撤销日志更昂贵的最小 $N$ 值。\n\n用 $S$、$s$、$L$、$t_p$ 和 $t_{sf}$ 的符号形式表示 $N_{\\text{th}}$。您的最终答案必须是单个闭式解析表达式。最终答案中不要包含单位。", "solution": "用户提供了一个有效且定义明确的问题陈述。它描述了操作系统中的一个性能建模场景，该场景基于持久化内存、崩溃一致性协议及其相关成本的标准概念。我将进行严格的推导。\n\n目标是找到最小整数阈值 $N_{\\text{th}}$，使得对于 $N$ 次更新，撤销日志协议的总持久化成本（表示为 $T_{\\text{undo}}$）大于或等于写时复制协议的总持久化成本（表示为 $T_{\\text{CoW}}$）。这可以表示为满足不等式 $T_{\\text{undo}} \\ge T_{\\text{CoW}}$ 的最小整数 $N$。\n\n首先，我将推导写时复制（CoW）协议的总成本 $T_{\\text{CoW}}$ 的表达式。该成本是所有必需的持久化和存储栅栏操作的延迟总和。\n1.  **持久化新区域副本：** 区域大小为 $S$ 字节，缓存行大小为 $L$ 字节。由于 $S$ 是 $L$ 的整数倍，区域中的缓存行数量为 $\\frac{S}{L}$。持久化一个缓存行的延迟是 $t_p$。因此，使整个新区域持久化的成本是 $\\frac{S}{L} t_p$。\n2.  **持久化根指针：** 问题陈述中提到系统“持久化该指针”。基本的硬件原语是缓存行持久化操作。我们假设指针包含在单个缓存行内。因此，持久化指针会产生一次缓存行持久化操作的成本，即 $t_p$。\n3.  **存储栅栏：** 协议在所有持久化操作发出后发出一个存储栅栏。这增加了 $t_{sf}$ 的延迟。\n\n由于操作是串行化的，CoW协议的总成本是这些成本的总和：\n$$T_{\\text{CoW}} = \\frac{S}{L} t_p + t_p + t_{sf} = \\left(\\frac{S}{L} + 1\\right) t_p + t_{sf}$$\n\n接下来，我将推导包含 $N$ 次更新的事务的撤销日志协议的总成本 $T_{\\text{undo}}$ 的表达式。\n该协议规定了为 $N$ 次更新中的每一次执行的一组操作，以及一个最终操作。\n对于 $N$ 次更新中的每一次：\n1.  **持久化撤销日志记录：** 写入一个大小为 $s$ 字节的撤销日志记录。由于 $s$ 是 $L$ 的整数倍，这需要持久化 $\\frac{s}{L}$ 个缓存行。成本为 $\\frac{s}{L} t_p$。\n2.  **存储栅栏：** 发出一个存储栅栏以确保撤销日志在原地更新之前是持久的。成本为 $t_{sf}$。\n3.  **持久化修改后的数据：** 原地更新修改一个大小为 $s$ 的记录，该记录跨越 $\\frac{s}{L}$ 个缓存行。持久化这些修改后的数据行成本为 $\\frac{s}{L} t_p$。\n\n单次更新的成本是这些延迟的总和：$2\\frac{s}{L} t_p + t_{sf}$。\n由于有 $N$ 次这样的更新，所有更新的累积成本是 $N \\left(2\\frac{s}{L} t_p + t_{sf}\\right)$。\n最后，协议在所有更新完成后发出“一个额外的最终存储栅栏”。这增加了 $t_{sf}$ 的成本。\n\n撤销日志协议的总成本是：\n$$T_{\\text{undo}} = N \\left(2\\frac{s}{L} t_p + t_{sf}\\right) + t_{sf}$$\n\n现在，我将建立不等式 $T_{\\text{undo}} \\ge T_{\\text{CoW}}$ 并求解 $N$。\n$$N \\left(2\\frac{s}{L} t_p + t_{sf}\\right) + t_{sf} \\ge \\left(\\frac{S}{L} + 1\\right) t_p + t_{sf}$$\n两边的 $t_{sf}$ 项可以消去：\n$$N \\left(2\\frac{s}{L} t_p + t_{sf}\\right) \\ge \\left(\\frac{S}{L} + 1\\right) t_p$$\n项 $\\left(2\\frac{s}{L} t_p + t_{sf}\\right)$ 是延迟和大小的和，它们都是正量。因此，该项本身是正的，我们可以用它来除不等式两边而不改变不等号的方向。\n$$N \\ge \\frac{\\left(\\frac{S}{L} + 1\\right) t_p}{2\\frac{s}{L} t_p + t_{sf}}$$\n为了简化表达式，我将分子和分母同乘以 $L$：\n$$N \\ge \\frac{L \\left(\\frac{S}{L} + 1\\right) t_p}{L \\left(2\\frac{s}{L} t_p + t_{sf}\\right)}$$\n$$N \\ge \\frac{(S + L) t_p}{2s t_p + L t_{sf}}$$\n问题要求满足此条件的最小*整数*阈值 $N_{\\text{th}}$。这正是对不等式右侧应用向上取整函数的定义。\n因此，$N_{\\text{th}}$ 的表达式是：\n$$N_{\\text{th}} = \\left\\lceil \\frac{(S + L) t_p}{2s t_p + L t_{sf}} \\right\\rceil$$\n这是撤销日志成本达到或超过写时复制成本的最小整数 $N$ 的闭式解析表达式。", "answer": "$$\\boxed{\\left\\lceil \\frac{(S + L) t_p}{2s t_p + L t_{sf}} \\right\\rceil}$$", "id": "3669271"}, {"introduction": "理论必须与实践相结合，现在是时候亲手构建一个真正能在崩溃后恢复的持久数据结构了。本练习将指导你为一个简单的单调计数器实现一个容错更新和恢复算法，该计数器是许多复杂系统中的基础组件。你将使用两阶段更新协议和奇偶校验位来处理持久内存中常见的“撕裂写”问题，从而将抽象的恢复规则转化为具体的、可工作的代码。[@problem_id:3669254]", "problem": "本题要求您形式化并实现一个存储在持久内存 (PMem) 中的单调计数器，该计数器通过采用一种为每个半区设置单个奇偶校验位的两阶段更新协议，来抵抗撕裂写。在此问题中，单调计数器是一个在每次成功更新时仅增加 $1$ 的值。内存模型如下：存在两个不相交的半区，表示为 $S_0$ 和 $S_1$，每个半区存储一个三元组 $(v_i, p_i, ph_i)$，其中 $v_i$ 是无符号计数值，$p_i \\in \\{0,1\\}$ 是一个奇偶校验位，$ph_i \\in \\{0,1\\}$ 是一个在每次成功更新时都会翻转的相位位。假设在一个崩溃故障模型中，崩溃可能在更新过程中的任何时刻发生，可能导致一个半区被部分更新，使得存储的奇偶校验位不再与值匹配。目标是提供数学上合理的恢复步骤，以在崩溃后协调不匹配的半区并选择正确的计数值。\n\n基本依据和假设：\n- 持久内存 (PMem) 是字节可寻址且非易失性的。一次崩溃可能会中断一系列写操作，导致撕裂写状态，即一个半区的某些字段已更新而其他字段未更新。然而，不相交的半区 $S_0$ 和 $S_1$ 是在不同步骤中写入的。\n- 单调计数器每次完整更新增加 $1$，并且根据设计永不减少。\n- 一个简单的数据完整性检查是存储值的奇偶校验：定义奇偶校验函数 $\\pi(v)$ 为 $v$ 的所有比特位之和对 $2$ 取模，即 $$\\pi(v) = \\left( \\sum_{j=0}^{b-1} b_j \\right) \\bmod 2,$$ 其中 $b$ 是 $v$ 的比特宽度（在实现中，使用标准的无符号整数类型），$b_j$ 是 $v$ 在位置 $j$ 的比特值。\n- 两阶段更新协议将新值写入一个半区并将其持久化（包括值、其奇偶校验位和翻转后的相位），然后将相同内容写入另一个半区并持久化。更新操作会将共享的相位位从 $ph$ 翻转为 $ph' = 1 - ph$。\n\n恢复过程必须基于这些基础。设崩溃后观察到的状态为 $(v_0, p_0, ph_0)$ 和 $(v_1, p_1, ph_1)$。通过存储的奇偶校验位是否等于重新计算的奇偶校验位来定义一个半区的有效性，即 $$\\text{valid}_i = \\left[ \\pi(v_i) = p_i \\right].$$ 一个科学合理的恢复例程必须：\n- 优先选择奇偶校验位与值匹配的半区。\n- 如果两个半区都有效，且相位和值均相等，则接受该值。\n- 如果两个半区都有效，但在相位或值上不同，单调性约束意味着恢复的值应为两者中的较大值。\n- 如果只有一个半区有效，则接受其值。\n- 如果两个半区都无效，则返回两者中的较小值，以避免在没有完整性证据的情况下捏造一个未来的值，并将状态标记为已降级。\n\n此外，请提出协调步骤，以便在下一次更新之前将不匹配的半区重新同步回一致状态。对于此问题，将协调计划定义为：\n- 一个布尔标志（表示为整数），用于指示是否需要重新同步，`needs_resync` $\\in \\{0,1\\}$，如果存在任何不匹配（奇偶校验、相位或值），则为 $1$，否则为 $0$。\n- 一个整数，用于指示首先更新哪个半区来修复状态，`first_half_to_update` $\\in \\{0,1\\}$，其中 $0$ 表示首先更新 $S_0$，$1$ 表示首先更新 $S_1$。如果两个半区都有效但存在差异，则首先更新持有较小值的半区。如果只有一个半区无效，则首先更新无效的半区。如果两个半区都无效，则首先更新持有较小值的半区。如果不需要重新同步，则选择 $0$。\n\n您的任务是编写一个完整的程序，该程序在给定嵌入代码中的固定测试套件的情况下，应用恢复算法，并为每个测试用例输出一个三元组 [`v`, `needs_resync`, `first_half_to_update`]，其中 `v` 是恢复的计数值（整数）。程序必须生成单行输出，其中包含这些三元组的列表，格式为用方括号括起来的逗号分隔列表。\n\n测试套件：\n- 情况 1（正常路径，两半区一致）：$S_0: v_0 = 42, p_0 = \\pi(42), ph_0 = 0$；$S_1: v_1 = 42, p_1 = \\pi(42), ph_1 = 0$。\n- 情况 2（在两阶段之间崩溃，左边是新数据，右边是旧数据）：$S_0: v_0 = 43, p_0 = \\pi(43), ph_0 = 1$；$S_1: v_1 = 42, p_1 = \\pi(42), ph_1 = 0$。\n- 情况 3（左半区发生撕裂写，奇偶校验不正确）：$S_0: v_0 = 43, p_0 \\neq \\pi(43)$ 设置为 $p_0 = 1 - \\pi(43), ph_0 = 1$；$S_1: v_1 = 42, p_1 = \\pi(42), ph_1 = 0$。\n- 情况 4（右半区发生撕裂写，奇偶校验不正确）：$S_0: v_0 = 43, p_0 = \\pi(43), ph_0 = 1$；$S_1: v_1 = 43, p_1 \\neq \\pi(43)$ 设置为 $p_1 = 1 - \\pi(43), ph_1 = 1$。\n- 情况 5（两者奇偶校验均有效但值不同，相位相同，属于损坏的边界情况）：$S_0: v_0 = 100, p_0 = \\pi(100), ph_0 = 0$；$S_1: v_1 = 99, p_1 = \\pi(99), ph_1 = 0$。\n- 情况 6（两者奇偶校验均无效）：$S_0: v_0 = 7, p_0 = 0$ 即使 $\\pi(7) = 1$, $ph_0 = 0$；$S_1: v_1 = 8, p_1 = 0$ 即使 $\\pi(8) = 1$, $ph_1 = 0$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含结果，格式为每个测试用例一个三元组 [`v`, `needs_resync`, `first_half_to_update`] 的逗号分隔列表，整个列表用方括号括起来。例如，格式为 [[`v_1`, `needs_1`, `first_1`], [`v_2`, `needs_2`, `first_2`], ...].", "solution": "该问题要求对存储在持久内存 (PMem) 中的容错单调计数器，形式化并实现其恢复与协调算法。计数器的状态在两个不相交的半区 $S_0$ 和 $S_1$ 之间复制，以防止更新过程中的撕裂写导致数据损坏。\n\n每个半区 $S_i$（其中 $i \\in \\{0, 1\\}$）的状态是一个三元组 $(v_i, p_i, ph_i)$，其中 $v_i$ 是计数值，$p_i$ 是其奇偶校验位，$ph_i$ 是一个相位位。解决方案的核心在于一个系统性的、基于原则的程序，用于在崩溃后解释 $S_0$ 和 $S_1$ 可能不一致的状态，并确定计数器的正确当前值以及恢复一致性所需的必要步骤。\n\n恢复过程的基础是由奇偶校验位提供的数据完整性检查。我们定义一个奇偶校验函数 $\\pi(v)$，它计算值 $v$ 的所有比特位之和对 2 取模的结果。如果半区 $S_i$ 存储的奇偶校验位 $p_i$ 与其值 $v_i$ 重新计算出的奇偶校验位相匹配，则该半区被认为是“有效的”。此检查表示为一个布尔条件：$\\text{valid}_i = [\\pi(v_i) = p_i]$。\n\n恢复与协调算法分两个主要阶段进行：状态评估以确定恢复的值，以及规划同步以恢复一致状态。\n\n**1. 状态评估与值恢复**\n\n第一步是为 $S_0$ 和 $S_1$ 的崩溃后状态计算 $\\text{valid}_0$ 和 $\\text{valid}_1$。根据两个半区的有效性，我们应用一套基于单调性和数据完整性原则的规则来确定正确的计数值 $v$。\n\n- **情况 1：两个半区都有效 ($ \\text{valid}_0 \\land \\text{valid}_1 $)。**\n如果两个半区都有正确的奇偶校验，我们就信任它们的值。两阶段更新协议意味着一个半区可能存储旧值，而另一个半区存储新的、已递增的值。由于单调计数器属性（值只增不减），正确的状态是值较大的那个。因此，恢复的值为 $v = \\max(v_0, v_1)$。这条规则也正确地处理了两个半区完全相同（$v_0 = v_1$）的“正常路径”，因为 $\\max(v_0, v_0) = v_0$。\n\n- **情况 2：只有一个半区有效 ($ \\text{valid}_0 \\oplus \\text{valid}_1 $)。**\n如果一个半区具有有效的奇偶校验而另一个没有，则无效的半区被认为因撕裂写而损坏。我们必须丢弃损坏的数据并信任完好的半区。如果 $S_i$ 是有效的半区，则恢复的值为 $v = v_i$。\n\n- **情况 3：两个半区都无效 ($ \\neg \\text{valid}_0 \\land \\neg \\text{valid}_1 $)。**\n这是最严重的故障情况，表明两个半区可能都已损坏。在没有任何完整性证据的情况下，我们无法可靠地确定正确的、最近的值。为避免捏造一个可能从未达到过的未来状态，算法必须采取保守的回退策略。题目要求选择两个值中较小的一个，即 $v = \\min(v_0, v_1)$。这一选择代表回滚到“最安全”的可能状态，并承认系统状态已降级。\n\n**2. 协调计划**\n\n恢复计数值后，系统必须恢复到一个两个半区完全一致的状态。协调计划包括两个部分：一个指示是否需要操作的标志（`needs_resync`），以及一个关于首先更新哪个半区的指令（`first_half_to_update`）。\n\n- **`needs_resync` $\\in \\{0, 1\\}$**：如果两个半区 $S_0$ 和 $S_1$ 不完全相同，则需要重新同步。只有当 $v_0 = v_1$、$p_0 = p_1$ 和 $ph_0 = ph_1$ 时，状态才是一致的，无需重新同步。在所有其他情况下，`needs_resync` 设置为 $1$。\n\n- **`first_half_to_update` $\\in \\{0, 1\\}$**：如果需要重新同步，该值决定操作的顺序。其逻辑源自相同的状态评估：\n    - 如果不需要重新同步，该值按惯例设置为 $0$。\n    - 如果两个半区都有效但存在差异（在值或相位上）：包含较旧（较小）值的半区必须更新以匹配较新（较大）的半区。因此，我们首先更新 $v_i = \\min(v_0, v_1)$ 所在的半区 $S_i$。如果 $v_0 = v_1$ 但相位不同，则必须使用确定性的打破僵局规则；我们选择首先更新 $S_0$。\n    - 如果只有一个半区 $S_i$ 无效：无效的那个半区是需要修复的。我们必须首先更新 $S_i$。\n    - 如果两个半区都无效：两个半区都必须用恢复的状态覆盖。规则是首先更新持有较小值的半区。如果 $v_0=v_1$，我们使用相同的打破僵局规则，首先更新 $S_0$。\n\n这个完整的算法提供了一个严谨且确定性的方法，以确保单调计数器在发生崩溃故障时仍保持可用和一致。最终的实现将此逻辑转化为一个程序，用于处理给定的测试用例。", "answer": "[[42, 0, 0], [43, 1, 1], [42, 1, 0], [43, 1, 1], [100, 1, 1], [7, 1, 0]]", "id": "3669254"}]}