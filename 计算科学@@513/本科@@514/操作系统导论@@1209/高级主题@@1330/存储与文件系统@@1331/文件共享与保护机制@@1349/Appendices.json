{"hands_on_practices": [{"introduction": "在构建复杂的访问控制系统之前，我们必须首先掌握操作系统的基本原理。本练习聚焦于Unix类系统中的一个关键且底层的概念：文件描述符（File Descriptor, FD）。一个打开的文件描述符不仅是指向文件的指针，更是一种“能力凭证”，它代表了执行特定操作的许可。如果在创建新进程（尤其是在 `fork` 后执行 `execve` 的过程中）时对文件描述符处理不当，就可能导致这些“能力凭证”泄漏给非预期的程序，从而完全绕过上层的权限检查。这个思想实验 [@problem_id:3642426] 旨在挑战你像安全分析师一样思考，识别这一常见漏洞的攻击链，并阐明其根本的缓解措施。", "problem": "一个类 Unix 操作系统上的特权文件共享守护进程按如下方式实现。启动时，它会打开一个敏感资源（例如，密码数据库文件或管理套接字），并保留相关的文件描述符（File Descriptor, FD）。该守护进程随后会 fork 并调用可执行文件加载系统调用 execve 来启动一个辅助进程，该进程运行用户提供的插件。该守护进程打算在执行辅助进程之前，通过切换到非特权用户标识符（UID）$1000$ 来限制辅助进程的访问权限。然而，该守护进程在打开时并未在其敏感 FD 上设置 close-on-exec 标志，也未在之后使用文件控制系统调用 fcntl 设置该标志。假设操作系统语义符合可移植操作系统接口（POSIX），包括以下定义：\n- FD 指的是由内核维护的打开文件描述。权限检查在打开路径名时进行；一旦获得 FD，对该 FD 的操作不会重新检查原始路径名的权限。\n- 在 execve 时，没有设置 close-on-exec 标志的 FD 在新的程序映像中保持打开状态。\n- 进程可以通过进程文件系统（例如 /proc/self/fd 下的路径）枚举其 FD，并且如果知道其整数编号，就可以对继承的 FD 执行 I/O 操作。\n\n考虑守护进程在 FD $3$ 上打开了一个敏感文件，在 FD $4$ 上打开了一个特权 Unix 域套接字，然后 fork 并 exec 一个运行不受信任插件代码的辅助进程。\n\n哪些选项既描述了一个利用遗漏 close-on-exec 标志来获得未授权访问的可行利用链，又阐明了基于操作系统 FD 语义的有效缓解步骤？\n\nA. 一个非特权辅助进程继承了指向敏感文件的 FD $3$，因为 `close-on-exec` 标志未被设置。该插件枚举 /proc/self/fd，发现 FD $3$ 指向一个特权文件（例如，密码数据库），并读取其内容，从而绕过了基于路径名的权限检查。有效的缓解措施包括在打开时设置 `close-on-exec` 标志（例如，使用 `O_CLOEXEC` 或带 `FD_CLOEXEC` 的 `fcntl`），采用“默认 close-on-exec”的 API（例如，支持 close-on-exec 的 `pipe2` 和 `dup3` 变体），以及执行预执行关闭过程（例如，`closefrom`）或使用显式关闭或白名单化 FD 的生成例程。\n\nB. 辅助进程无法跨 `execve` 继承任何 FD，因为 `execve` 总是清除所有 FD，无论标志如何。因此，不存在利用链，除了标准的权限降级（例如，`setuid`到 UID $1000$）外，不需要任何缓解措施。\n\nC. 将权限降至 UID $1000$ 可确保辅助进程无法从继承的 FD 读取，因为内核在每次读取操作时都会重新检查路径名权限。因此，即使继承了 FD $3$，后续的读取也会被拒绝。正确的缓解措施只是在 `execve` 之前调用 `setuid`。\n\nD. 辅助进程继承了指向特权 Unix 域套接字的 FD $4$，因为 `close-on-exec` 标志未被设置。该插件通过此套接字发出管理命令，利用已授权的连接来控制守护进程或间接提升权限。有效的缓解措施包括在创建时为所有敏感的套接字和文件标记 `close-on-exec` 标志，通过显式白名单机制（例如，`posix_spawn` 文件操作）确保只有预期的 FD 被继承，以及在 `execve` 之前进行审计以关闭意外的 FD。\n\nE. 仅依靠安全计算伯克利数据包过滤器（`seccomp-BPF`）沙箱在辅助进程中全局阻止 `read` 和 `write` 系统调用；这可以完全防止利用，并且即使对于必需的辅助进程功能，也无需管理 FD 继承或 `close-on-exec` 标志。\n\n选择所有适用项。", "solution": "问题陈述描述了一个场景，其中一个类 Unix 操作系统上的特权守护进程生成一个权限较低的辅助进程。问题的核心在于跨 `fork` 和 `execve` 序列的文件描述符（FD）管理。\n\n**系统行为和漏洞的推导**\n\n事件序列是 `open` -> `fork` -> `setuid` -> `execve`。\n1.  特权守护进程打开敏感文件和套接字，成功通过权限检查，获得 FD $3$ 和 $4$。这些 FD 指向内核中的打开文件描述，授予了读/写访问权限。\n2.  守护进程调用 `fork()`。子进程继承父进程文件描述符表的副本。子进程的 FD $3$ 和 $4$ 与父进程的指向完全相同的打开文件描述。\n3.  子进程调用 `setuid(1000)`。这会更改进程的有效 UID，从而降低其权限。但是，这不会影响已打开文件描述符的能力。\n4.  子进程调用 `execve()` 来加载辅助程序。根据问题描述，没有 `close-on-exec` 标志的 FD 保持打开状态。由于 FD $3$ 和 $4$ 上未设置此标志，辅助程序开始执行时，这些 FD 仍然是打开且有效的。\n5.  辅助程序现在以 UID $1000$ 运行并执行不受信任的代码，它可以访问 FD $3$ 和 $4$。它可以对它们执行 I/O 操作（例如 `read()`、`write()`、`send()`）。内核在收到这些系统调用后，会作用于打开文件描述。它不会根据原始文件路径的权限重新验证进程的 UID ($1000$)，因为该检查已在 `open()` 时通过。\n\n这构成了一个严重漏洞。不受信任的辅助进程可以读取敏感文件并与特权套接字交互，从而有效地绕过了系统的安全控制。\n\n**逐项分析**\n\n**A. 一个非特权辅助进程继承了指向敏感文件的 FD $3$，因为 close-on-exec 标志未被设置。该插件枚举 /proc/self/fd，发现 FD $3$ 指向一个特权文件（例如，密码数据库），并读取其内容，从而绕过了基于路径名的权限检查。有效的缓解措施包括在打开时设置 close-on-exec 标志（例如，使用 O_CLOEXEC 或带 FD_CLOEXEC 的 fcntl），采用“默认 close-on-exec”的 API（例如，支持 close-on-exec 的 pipe2 和 dup3 变体），以及执行预执行关闭过程（例如，closefrom）或使用显式关闭或白名单化 FD 的生成例程。**\n\n- **分析**：所描述的利用链完全正确，遵循了上述针对 FD $3$ 上的敏感文件推导出的逻辑。不受信任的代码可以发现并使用泄漏的 FD。缓解措施列表全面且准确。设置 `close-on-exec` 标志是最直接的解决方案，无论是在创建时原子化地设置（例如，`open()` 使用 `O_CLOEXEC`）还是之后设置（例如，`fcntl()`）。其他方法，如关闭一个范围内的 FD 或使用更现代、更安全的进程生成 API（如带有文件操作的 `posix_spawn()`），也是有效且推荐的做法。\n- **结论**：正确。\n\n**B. 辅助进程无法跨 execve 继承任何 FD，因为 execve 总是清除所有 FD，无论标志如何。因此，不存在利用链，除了标准的权限降级（例如，setuid到 UID $1000$）外，不需要任何缓解措施。**\n\n- **分析**：这个说法在事实上是错误的。它从根本上歪曲了 POSIX 定义和问题陈述中描述的 `execve` 的行为。`execve` 只关闭那些明确标记了 `close-on-exec` 标志的 FD。\n- **结论**：错误。\n\n**C. 将权限降至 UID $1000$ 可确保辅助进程无法从继承的 FD 读取，因为内核在每次读取操作时都会重新检查路径名权限。因此，即使继承了 FD $3$，后续的读取也会被拒绝。正确的缓解措施只是在 execve 之前调用 setuid。**\n\n- **分析**：这个说法在事实上是错误的。它与 Unix 文件访问的一个核心原则相矛盾，该原则在问题中已正确陈述：权限检查在 `open()` 时进行，而不是在对生成的 FD 进行每次 `read()` 或 `write()` 时进行。一个打开的 FD 是一种能力，其权限不受持有该 FD 的进程后续调用 `setuid()` 的影响。通过 `setuid()` 进行权限降级是必要的，但不足以防止此利用。\n- **结论**：错误。\n\n**D. 辅助进程继承了指向特权 Unix 域套接字的 FD $4$，因为 close-on-exec 标志未被设置。该插件通过此套接字发出管理命令，利用已授权的连接来控制守护进程或间接提升权限。有效的缓解措施包括在创建时为所有敏感的套接字和文件标记 close-on-exec 标志，通过显式白名单机制（例如，posix_spawn 文件操作）确保只有预期的 FD 被继承，以及在 execve 之前进行审计以关闭意外的 FD。**\n\n- **分析**：此选项正确描述了相同的漏洞模式，但将其应用于 FD $4$ 上的 Unix 域套接字。一个继承的套接字 FD 是一种强大的能力，因为连接通常被对等方认为是受信任的。不受信任的代码可以滥用这种信任。提出的缓解措施在原则上与选项 A 中的相同，并且对于套接字同样正确和有效（例如，使用 `socket()` 或 `accept4()` 系统调用时配合 `SOCK_CLOEXEC`）。\n- **结论**：正确。\n\n**E. 仅依靠安全计算伯克利数据包过滤器（seccomp-BPF）沙箱在辅助进程中全局阻止 read 和 write 系统调用；这可以完全防止利用，并且即使对于必需的辅助进程功能，也无需管理 FD 继承或 close-on-exec 标志。**\n\n- **分析**：这个提议的解决方案是有缺陷的。首先，全局阻止 `read` 和 `write` 系统调用是一种不切实际、过于宽泛的措施，很可能会使辅助进程无法工作。大多数进程都需要某种形式的 I/O 才能有用。其次，虽然 `seccomp-BPF` 是一个强大的深度防御工具，但将其描述为一种可以“免除”修复底层 FD 泄漏需求的替代方案，是错误的安工程实践。首要的控制应该是从一开始就不要泄漏能力。仅仅依靠 `seccomp-BPF` 会创建一个脆弱的防御，并且没有解决根本原因。\n- **结论**：错误。", "answer": "$$\\boxed{AD}$$", "id": "3642426"}, {"introduction": "掌握了底层的安全机制后，我们可以进一步构建更高级的访问控制策略。现实世界的文件共享系统远比简单的“用户-组-权限”模型复杂，它通常需要支持按项目组织的层级结构、权限的自动继承以及特定情况下的例外规则。本练习 [@problem_id:3642362] 将你置于系统设计师的角色，要求你根据一套精确的形式化规约，实现一个复杂的、基于规则的访问控制逻辑。这是一个将抽象的安全模型转化为具体工作算法的绝佳实践，能够加深你对现代文件系统中权限判决复杂性的理解。", "problem": "您需要形式化并实现一个算法，用于在一个具有嵌套组成员关系和继承例外的分层项目树中计算有效权限。该模型使用操作系统访问控制中的以下基本定义和事实进行规定。\n\n定义：\n- 令 $U$ 为用户集，$G$ 为用户组集，$S = U \\cup G$ 为主体集。\n- 令 $P$ 为项目（节点）集，组织成一个有根树，其父节点关系为 $\\pi: P \\setminus \\{\\text{root}\\} \\to P$。对于 $p \\in P$，从根到 $p$ 的唯一路径表示为 $\\text{path}(p) = \\langle a_0, a_1, \\dots, a_k \\rangle$，其中 $a_0 = \\text{root}$ 且 $a_k = p$。\n- 每个节点 $a \\in P$ 有一个保护标志 $b(a) \\in \\{\\text{false}, \\text{true}\\}$。如果 $b(a)=\\text{true}$，我们称 $a$ 受保护，并中断其祖先的继承。\n- 给定一个组成员关系 $M \\subseteq (U \\cup G) \\times G$。其传递闭包确定了派生的成员关系。对于用户 $u \\in U$，其所属的所有组的集合 $C(u) \\subseteq G$ 是满足以下条件的最小不动点：\n  - 如果 $(u, g) \\in M$ 则 $g \\in C(u)$。\n  - 如果 $g \\in C(u)$ 且 $(g, h) \\in M$ 则 $h \\in C(u)$。\n- 每个节点 $a \\in P$ 包含零个或多个访问控制条目（ACE）。一个 ACE 是一个元组 $(t, s, Q, \\iota)$，其中 $t \\in \\{\\text{ALLOW}, \\text{DENY}\\}$ 是类型，$s \\in S$ 是主体，$Q \\subseteq \\{r,w,x\\}$ 是它提及的有限权限集，$\\iota \\in \\{\\text{false}, \\text{true}\\}$ 是可继承标志，指示该 ACE 是否传播给后代。\n- 采用默认拒绝语义：在没有任何适用的 ACE 提及某权限的情况下，该权限的访问被拒绝。\n\n适用性和继承：\n- 节点 $a_i$ 上的一个 ACE $(t, s, Q, \\iota)$ 适用于用户 $u \\in U$，当且仅当 $s = u$ 或 $s \\in G$ 且 $s \\in C(u)$。\n- 对于路径为 $\\langle a_0,\\dots,a_k\\rangle$ 的目标节点 $p$，确定最深的索引 $j^\\star \\in \\{0,\\dots,k\\}$ 使得 $b(a_{j^\\star}) = \\text{true}$（如果存在）；否则令 $j^\\star = 0$。只有 $j \\in \\{j^\\star,\\dots,k\\}$ 的节点 $a_j$ 中的 ACE 才可被考虑。在这些节点中，对于 $j  k$（$p$ 的真祖先），只考虑 $\\iota = \\text{true}$ 的 ACE；在 $j = k$（目标节点）处，无论 $\\iota$ 为何值，都考虑 ACE。\n\n决策规则：\n- 对于每个权限 $q \\in \\{r,w,x\\}$，在 $j \\in \\{j^\\star,\\dots,k\\}$ 的节点 $a_j$ 中所有提及 $q$ 的适用 ACE 中，处于最大深度 $j_{\\max}$ 的 ACE 优先。如果在深度 $j_{\\max}$ 处至少有一个适用的 ACE 类型为 DENY，则 $q$ 被拒绝；否则，如果在该相同深度至少有一个适用的 ACE 类型为 ALLOW，则 $q$ 被允许；否则，如果没有 ACE 提及 $q$，则默认拒绝。\n\n输出编码：\n- 按如下方式将权限映射到比特位：$r \\mapsto 1$，$w \\mapsto 2$，$x \\mapsto 4$。用户-目标对的有效权限位掩码是所有被允许权限的比特位之和。\n\n本问题的数据：\n- 用户 $U = \\{\\text{Alice}, \\text{Bob}, \\text{Carol}\\}$。\n- 用户组 $G = \\{\\text{G1}, \\text{G2}, \\text{G3}\\}$。\n- 成员关系 $M$ 包含以下配对：\n  - 用户到组：$(\\text{Alice}, \\text{G1})$，$(\\text{Bob}, \\text{G2})$，$(\\text{Carol}, \\text{G3})$。\n  - 组到组（嵌套）：$(\\text{G1}, \\text{G2})$。\n- 项目树 $P$ 及其父节点关系 $\\pi$：\n  - 节点：Root, SubA, SubA1, SubA2, SubB, SubB1。\n  - 父节点映射：$\\pi(\\text{SubA})=\\text{Root}$，$\\pi(\\text{SubA1})=\\text{SubA}$，$\\pi(\\text{SubA2})=\\text{SubA}$，$\\pi(\\text{SubB})=\\text{Root}$，$\\pi(\\text{SubB1})=\\text{SubB}$。\n  - 保护标志：$b(\\text{SubA2})=\\text{true}$；所有其他节点的 $b=\\text{false}$。\n- 各节点上的 ACE：\n  - Root：\n    - $(\\text{ALLOW}, \\text{G2}, \\{r\\}, \\text{true})$，\n    - $(\\text{DENY}, \\text{G3}, \\{x\\}, \\text{true})$，\n    - $(\\text{ALLOW}, \\text{Bob}, \\{w\\}, \\text{false})$。\n  - SubA：\n    - $(\\text{ALLOW}, \\text{G1}, \\{w\\}, \\text{true})$。\n  - SubA1：\n    - $(\\text{DENY}, \\text{G2}, \\{w\\}, \\text{false})$。\n  - SubA2：\n    - $(\\text{ALLOW}, \\text{Alice}, \\{x\\}, \\text{true})$，\n    - $(\\text{DENY}, \\text{G1}, \\{w\\}, \\text{true})$，\n    - $(\\text{ALLOW}, \\text{G2}, \\{w\\}, \\text{true})$。\n  - SubB：\n    - $(\\text{ALLOW}, \\text{Carol}, \\{x\\}, \\text{true})$。\n  - SubB1：\n    - 无 ACE。\n\n任务：\n- 实现一个完整的、可运行的程序，该程序构建上述数据并按此确切顺序计算以下 6 个测试查询 $(u, p)$ 中每一个的有效权限位掩码：\n  $1.$ $(\\text{Alice}, \\text{SubA1})$，\n  $2.$ $(\\text{Alice}, \\text{SubA2})$，\n  $3.$ $(\\text{Alice}, \\text{SubB1})$，\n  $4.$ $(\\text{Bob}, \\text{SubA1})$，\n  $5.$ $(\\text{Carol}, \\text{SubA1})$，\n  $6.$ $(\\text{Bob}, \\text{Root})$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的十进制整数列表（例如，$[\\dots]$）。此行前后不允许有额外的空白或字符。\n\n约束和说明：\n- 您的实现必须是确定性的，并且不得读取任何输入。\n- 严格按照所述决策规则应用：更深的节点优先；在同一深度，如果一个适用的 ALLOW ACE 和一个适用的 DENY ACE 都提及相同权限，则该深度的决策为 DENY。\n- 程序必须使用 $r \\mapsto 1$，$w \\mapsto 2$，$x \\mapsto 4$ 对权限进行编码，并将与允许的权限相对应的比特位相加，以形成每个测试用例的最终整数。", "solution": "**1. 系统模型与静态分析**\n\n令用户集为 $U = \\{\\text{Alice}, \\text{Bob}, \\text{Carol}\\}$，用户组集为 $G = \\{\\text{G1}, \\text{G2}, \\text{G3}\\}$。主体集为 $S = U \\cup G$。项目树 $P$ 和父节点关系 $\\pi$ 已给出。\n\n静态分析的核心是计算组成员关系 $M$ 的传递闭包。给定的直接成员关系为 $M = \\{(\\text{Alice}, \\text{G1}), (\\text{Bob}, \\text{G2}), (\\text{Carol}, \\text{G3}), (\\text{G1}, \\text{G2})\\}$。对于用户 $u \\in U$，我们计算其所属的所有组的集合 $C(u)$。\n\n- **对于 Alice**：Alice 直接属于 G1，即 $(\\text{Alice}, \\text{G1}) \\in M$。该关系还包含一个嵌套成员关系 $(\\text{G1}, \\text{G2}) \\in M$。根据传递性，由于 Alice 属于 G1 且 G1 属于 G2，因此 Alice 也属于 G2。所以，$C(\\text{Alice}) = \\{\\text{G1}, \\text{G2}\\}$。\n- **对于 Bob**：Bob 直接属于 G2，即 $(\\text{Bob}, \\text{G2}) \\in M$。没有由此派生的其他成员关系。因此，$C(\\text{Bob}) = \\{\\text{G2}\\}$。\n- **对于 Carol**：Carol 直接属于 G3，即 $(\\text{Carol}, \\text{G3}) \\in M$。没有由此派生的其他成员关系。因此，$C(\\text{Carol}) = \\{\\text{G3}\\}$。\n\n项目树结构是一个以名为“Root”的节点为根的层次结构。\n- $\\text{path}(\\text{Root}) = \\langle\\text{Root}\\rangle$\n- $\\text{path}(\\text{SubA1}) = \\langle\\text{Root}_0, \\text{SubA}_1, \\text{SubA1}_2\\rangle$\n- $\\text{path}(\\text{SubA2}) = \\langle\\text{Root}_0, \\text{SubA}_1, \\text{SubA2}_2\\rangle$\n- $\\text{path}(\\text{SubB1}) = \\langle\\text{Root}_0, \\text{SubB}_1, \\text{SubB1}_2\\rangle$\n节点 SubA2 的保护标志被设置，$b(\\text{SubA2}) = \\text{true}$。对于所有其他节点 $p$，$b(p) = \\text{false}$。\n\n**2. 权限评估算法**\n\n对于给定的用户 $u$ 和目标项目 $p$ 的查询 $(u, p)$，以及对于每个权限 $q \\in \\{r, w, x\\}$，我们应用以下步骤：\n\n1.  **确定路径和继承范围**：构建从根到 $p$ 的路径，$\\text{path}(p) = \\langle a_0, \\dots, a_k \\rangle$。找到满足 $b(a_{j^\\star}) = \\text{true}$ 的最大索引 $j^\\star \\in \\{0, \\dots, k\\}$。如果不存在这样的节点，则设置 $j^\\star = 0$。需要考虑 ACE 的节点集是 $\\{a_j \\mid j \\in \\{j^\\star, \\dots, k\\}\\}$。\n2.  **收集适用的 ACE**：节点 $a_j$ 上的一个 ACE $(t, s, Q, \\iota)$ 对于用户 $u$ 和权限 $q$ 被认为是适用的，如果：\n    - $q \\in Q$。\n    - 主体 $s$ 与用户匹配：$s = u$ 或 $s \\in C(u)$。\n    - ACE 根据其位置被考虑：如果 $j  k$（即 $a_j$ 是 $p$ 的真祖先），则可继承标志必须为真，$\\iota = \\text{true}$。如果 $j = k$（即 $a_j$ 是目标节点 $p$），则无论 $\\iota$ 为何值都考虑该 ACE。\n3.  **应用决策规则**：\n    - 令 $\\mathcal{A}$ 为上一步中为权限 $q$ 收集的所有适用 ACE 及其节点深度的配对集合。\n    - 如果 $\\mathcal{A}$ 为空，则权限 $q$ 被拒绝（默认拒绝）。\n    - 否则，找到最大深度 $j_{\\max} = \\max \\{j \\mid ((t,s,Q,\\iota), j) \\in \\mathcal{A}\\}$。\n    - 检查深度 $j_{\\max}$ 处的所有适用 ACE。如果其中任何一个的类型为 $t=\\text{DENY}$，则权限 $q$ 被拒绝。\n    - 否则（深度 $j_{\\max}$ 处的所有适用 ACE 的类型均为 $t=\\text{ALLOW}$），则权限 $q$ 被允许。\n4.  **计算位掩码**：最终的权限位掩码是所有被允许权限的值之和，其中 $r \\mapsto 1$，$w \\mapsto 2$，$x \\mapsto 4$。\n\n**3. 测试查询的详细计算**\n\n1.  **$(\\text{Alice}, \\text{SubA1}) \\rightarrow 1$**\n    - **r**: 被 Root 处的 ACE $(\\text{ALLOW}, \\text{G2}, \\{r\\}, \\text{true})$ 允许。\n    - **w**: 被 SubA1 处的 ACE $(\\text{DENY}, \\text{G2}, \\{w\\}, \\text{false})$ 拒绝，因其深度 (2) 大于 SubA 处允许的 ACE (深度 1)。\n    - **x**: 没有适用的 ACE，默认拒绝。\n\n2.  **$(\\text{Alice}, \\text{SubA2}) \\rightarrow 4$**\n    - 由于 SubA2 受保护，继承范围仅为 $\\langle\\text{SubA2}_2\\rangle$。\n    - **r**: 没有适用的 ACE，默认拒绝。\n    - **w**: 在 SubA2 处，$(\\text{DENY}, \\text{G1}, \\{w\\}, \\text{true})$ 适用，因此被拒绝。\n    - **x**: 被 SubA2 处的 ACE $(\\text{ALLOW}, \\text{Alice}, \\{x\\}, \\text{true})$ 允许。\n\n3.  **$(\\text{Alice}, \\text{SubB1}) \\rightarrow 1$**\n    - **r**: 被 Root 处的 ACE $(\\text{ALLOW}, \\text{G2}, \\{r\\}, \\text{true})$ 允许。\n    - **w**: 没有适用的 ACE，默认拒绝。\n    - **x**: 没有适用的 ACE，默认拒绝。\n\n4.  **$(\\text{Bob}, \\text{SubA1}) \\rightarrow 1$**\n    - Bob 属于 {G2}。\n    - **r**: 被 Root 处的 ACE $(\\text{ALLOW}, \\text{G2}, \\{r\\}, \\text{true})$ 允许。\n    - **w**: 被 SubA1 处的 ACE $(\\text{DENY}, \\text{G2}, \\{w\\}, \\text{false})$ 拒绝。\n    - **x**: 没有适用的 ACE，默认拒绝。\n\n5.  **$(\\text{Carol}, \\text{SubA1}) \\rightarrow 0$**\n    - Carol 属于 {G3}。\n    - **r**, **w**: 没有适用的 ACE，默认拒绝。\n    - **x**: 被 Root 处的 ACE $(\\text{DENY}, \\text{G3}, \\{x\\}, \\text{true})$ 拒绝。\n\n6.  **$(\\text{Bob}, \\text{Root}) \\rightarrow 3$**\n    - Bob 属于 {G2}。\n    - **r**: 被 ACE $(\\text{ALLOW}, \\text{G2}, \\{r\\}, \\text{true})$ 允许。\n    - **w**: 被 ACE $(\\text{ALLOW}, \\text{Bob}, \\{w\\}, \\text{false})$ 允许 (目标节点)。\n    - **x**: 没有适用的 ACE，默认拒绝。\n    - **结果**: $1 (r) + 2 (w) = 3$。\n\n最终计算得到的位掩码列表为 `[1, 4, 1, 1, 0, 3]`。", "answer": "[1,4,1,1,0,3]", "id": "3642362"}, {"introduction": "文件保护不仅涉及控制谁可以访问数据（访问控制），还包括确保数据在事后不被篡改（数据完整性）。在许多关键应用中，例如代码提交系统、金融交易记录或安全审计日志，仅仅限制写入权限是不够的；我们还必须能够证明历史记录的真实性和不可否认性。本练习 [@problem_id:3642395] 探索了一种基于密码学的解决方案，通过结合使用哈希链和消息认证码（MAC）来构建一个防篡改的、仅可追加的日志系统。通过这个实践，你将亲手实现保证数据完整性和不可否认性的核心构件。", "problem": "你的任务是设计并实现一个仅追加的共享提交日志机制。该机制允许通过新条目进行修正，同时在不进行原地编辑的情况下验证作者身份和完整性。系统必须使用防篡改哈希链和密钥消息认证码进行建模，并且其逻辑必须实现为一个完整的、可运行的程序，该程序能对指定的测试套件输出验证结果。\n\n需要使用的基本和核心定义：\n- 仅追加语义：如果过去的条目不被修改，并且新条目严格按照时间和索引顺序扩展日志，则该日志是仅追加的。一个操作不变量是，索引严格按 $1$ 递增，时间戳非递减。此不变量确保任何偏差都意味着对仅追加行为的违反。\n- 通过哈希链接实现完整性：通过对每个条目 $i$ 的确定性编码以及前一个摘要 $h_{i-1}$ 进行哈希计算，来定义该条目的摘要 $h_i$。对先前条目的任何更改都会改变 $h_{i-1}$ 并传播到 $h_i$，从而使篡改可被检测。\n- 通过密钥消息认证码（MAC）实现作者身份验证：给定每个作者的密钥 $K_{\\text{author}}$，定义一个确定性函数 $M(K_{\\text{author}}, h_i)$，该函数将作者与摘要绑定。验证过程会重新计算 $M$ 并将其与记录的 MAC 进行比较，以确认作者身份和完整性。\n- 通过新条目进行修正：修正条目会引用一个先前的条目索引，但不会修改任何之前的内容。修正的作者必须与被引用条目的原始作者相匹配。\n\n每个日志条目 $i$ 的规范编码：\n- 每个条目是一个元组 $(i, t_i, a_i, \\tau_i, \\rho_i, m_i)$，其中 $i$ 是索引， $t_i$ 是时间戳， $a_i$ 是作者标识符字符串， $\\tau_i \\in \\{\\text{'N'}, \\text{'C'}\\}$ 表示是新提交还是修正， $\\rho_i$ 是被引用的目标索引（如果不适用则使用 $0$）， $m_i$ 是消息文本。\n- 设 $h_0 = 0$。将规范 ASCII 编码 $S_i$ 定义为由竖线字符分隔的字段的串联，并在末尾附加固定宽度的十六进制表示的前一个摘要，如下所示：\n$$\nS_i = \\text{ASCII}\\big(\\text{format}\\big(i\\;|\\;t_i\\;|\\;a_i\\;|\\;\\tau_i\\;|\\;\\rho_i\\;|\\;m_i\\;|\\;\\text{prev} = \\text{hex}_{16}(h_{i-1})\\big)\\big).\n$$\n- 摘要函数 $H$ 是 $64$ 位 Fowler–Noll–Vo（$\\text{FNV-1a}$）哈希，其偏移基准为 $1469598103934665603$，素数为 $1099511628211$。对于一个字节序列 $(b_j)$，哈希从 $h = 1469598103934665603$ 开始，迭代计算 $h \\leftarrow (h \\oplus b_j) \\times 1099511628211 \\bmod 2^{64}$。\n- 密钥 MAC 定义为：\n$$\nM(K, h) = \\operatorname{rotl}_{64}(h \\oplus K, 13) \\oplus C,\n$$\n其中 $C = 0x9e3779b97f4a7c15$，$ \\operatorname{rotl}_{64}$ 表示 $64$ 位左旋 $13$ 位。\n\n程序必须实现的验证规则：\n- 仅追加顺序：对于所有条目，索引必须满足 $i_l = l$（其中 $l \\in \\{1, 2, \\dots, n\\}$），时间戳必须满足 $t_l \\ge t_{l-1}$（其中 $l \\ge 2$）。\n- 修正约束：如果 $\\tau_i = \\text{'C'}$，那么目标索引必须满足 $1 \\le \\rho_i \\le i-1$，并且作者必须等于被引用的目标条目的作者。\n- 作者身份和完整性验证：对于每个条目 $i$，计算 $h_i = H(S_i)$，并验证记录的 $\\text{mac}_i$ 是否等于 $M(K_{a_i}, h_i)$（给定每个作者的密钥 $K_{a_i}$）。\n\n作者密钥：\n- $K_{\\text{alice}} = 0x0123456789ABCDEF$\n- $K_{\\text{bob}} = 0xFEDCBA9876543210$\n- $K_{\\text{carol}} = 0x0F0F0F0F0F0F0F0F$\n\n测试套件规范：\n- 情况 $1$（有效的正常路径）：\n  - 条目：\n    - $(i=1, t_1=1000, a_1=\\text{\"alice\"}, \\tau_1=\\text{'N'}, \\rho_1=0, m_1=\\text{\"Task A\"})$\n    - $(i=2, t_2=1005, a_2=\\text{\"alice\"}, \\tau_2=\\text{'C'}, \\rho_2=1, m_2=\\text{\"Fix typo\"})$\n    - $(i=3, t_3=1010, a_3=\\text{\"bob\"}, \\tau_3=\\text{'N'}, \\rho_3=0, m_3=\\text{\"Task B\"})$\n    - $(i=4, t_4=1015, a_4=\\text{\"bob\"}, \\tau_4=\\text{'C'}, \\rho_4=3, m_4=\\text{\"Add detail\"})$\n  - 对于此情况，程序使用 $h_0 = 0$ 和链式法则，将每个 $i$ 的 $\\text{mac}_i$ 计算为 $M(K_{a_i}, H(S_i))$。\n- 情况 $2$（原地篡改内容，记录的 MAC 不变）：\n  - 从情况 1 开始。将条目 $i=3$ 的消息替换为 $m_3=\\text{\"Task X\"}$，但保持记录的 $\\text{mac}_3$ 与情况 1 的值相同。所有其他条目（包括其记录的 MAC）与情况 1 保持一致。这模拟了不重新计算 MAC 的原地内容更改，必须将其检测为无效。\n- 情况 $3$（破坏的仅追加索引顺序）：\n  - 条目：\n    - $(i=1, t_1=3000, a_1=\\text{\"alice\"}, \\tau_1=\\text{'N'}, \\rho_1=0, m_1=\\text{\"T1\"})$\n    - $(i=3, t_2=3005, a_2=\\text{\"bob\"}, \\tau_2=\\text{'N'}, \\rho_2=0, m_2=\\text{\"T3\"})$\n    - $(i=4, t_3=3010, a_3=\\text{\"bob\"}, \\tau_3=\\text{'C'}, \\rho_3=3, m_3=\\text{\"C3\"})$\n  - 索引不是以 $1$ 连续的（缺少 $i=2$），必须将其检测为无效。记录的 $\\text{mac}_i$ 值是根据给定的字段和链式法则正常计算的。\n- 情况 $4$（对不存在的未来条目的无效修正引用）：\n  - 条目：\n    - $(i=1, t_1=2000, a_1=\\text{\"carol\"}, \\tau_1=\\text{'N'}, \\rho_1=0, m_1=\\text{\"Report\"})$\n    - $(i=2, t_2=2001, a_2=\\text{\"carol\"}, \\tau_2=\\text{'C'}, \\rho_2=3, m_2=\\text{\"Refine\"})$\n  - 该修正引用了 $\\rho_2=3$，它不存在并且违反了 $1 \\le \\rho_2 \\le i-1$；必须将其检测为无效。记录的 $\\text{mac}_i$ 值是根据给定的字段和链式法则正常计算的。\n\n要求的输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，按四个测试用例的顺序排列：例如，$\\text{[result1,result2,result3,result4]}$，其中每个结果是一个整数 $0$（无效）或 $1$（有效）。不应打印额外的空格或文本。\n\n你的任务：\n- 实现所述的验证机制，并将其完全按照规定应用于四个测试用例，包括情况 2 的构建过程。程序必须按定义计算摘要和 MAC，强制执行所有约束，并以要求的格式打印单行结果。", "solution": "该问题要求为一个仅追加共享日志设计和实现一个验证系统。该系统必须使用哈希链和密钥哈希消息认证码（MAC）来确保日志条目的完整性、作者身份和结构一致性。解决方案以一个 C 程序的形式呈现，该程序根据一组严格定义的规则验证四个不同的测试用例。\n\n逻辑设计分为几个组件：日志条目的数据结构、指定加密原语的实现，以及一个强制执行所有系统规则的综合验证函数。\n\n首先，我们定义一个数据结构 `LogEntry` 来表示日志中的单个条目。此结构封装了规范编码中指定的所有字段：索引 $i$、时间戳 $t_i$、作者标识符 $a_i$、类型 $\\tau_i \\in \\{\\text{'N'}, \\text{'C'}\\}$、引用的索引 $\\rho_i$、消息文本 $m_i$ 以及记录的 MAC $\\text{mac}_i$。作者密钥，例如 $K_{\\text{alice}}$，被定义为 $64$ 位无符号整数常量。一个辅助函数将作者名称字符串映射到其对应的密钥。\n\n完整性机制的核心是哈希链，它依赖于表示为 $H$ 的 $64$ 位 Fowler–Noll–Vo 哈希函数（FNV-1a）。该函数被实现来处理一个字节序列，该序列对应于日志条目的规范字符串表示 $S_i$。FNV-1a 算法使用标准偏移基准 $h = 1469598103934665603$ 进行初始化。对于输入字符串中的每个字节 $b_j$，哈希通过操作 $h \\leftarrow (h \\oplus b_j) \\times 1099511628211$ 进行更新，所有算术运算均在模 $2^{64}$ 下执行。条目 $i$ 的规范字符串 $S_i$ 是通过将其字段用 `|` 字符连接，并在末尾附加前一个条目摘要 $h_{i-1}$ 的十六进制表示来构造的。链从一个初始摘要 $h_0 = 0$ 开始。\n\n作者身份和完整性通过一个自定义的密钥消息认证码 $M(K, h)$ 绑定在一起。该函数接受一个每个作者的密钥 $K$ 和一个摘要 $h$，并将 MAC 计算为 $M(K, h) = \\operatorname{rotl}_{64}(h \\oplus K, 13) \\oplus C$。操作 $\\operatorname{rotl}_{64}(x, n)$ 表示将 $x$ 进行 $64$ 位按位左旋 $n$ 位，实现为 $(x \\ll n) | (x \\gg (64 - n))$。常量 $C$ 被定义为 $0x9e3779b97f4a7c15$。此 MAC 将作者的密钥与条目的内容（通过其摘要）绑定，确保只有密钥的持有者才能为该条目生成有效的 MAC。\n\n主要的验证逻辑被封装在一个函数 `verify_log` 中，该函数遍历给定的日志并按顺序应用所有指定的规则。对于日志中位置为 $l$ 的每个条目（其中 $l$ 从 $1$ 开始）：\n$1$。**仅追加顺序验证**：该函数首先验证结构不变量。它检查条目的索引字段 $i_l$ 是否等于其在日志中的位置 $l$，即 $i_l = l$。它还确保时间戳是非递减的，通过检查对于所有 $l \\ge 2$ 是否有 $t_l \\ge t_{l-1}$。违反这些条件中的任何一个都表示对仅追加属性的破坏，并导致日志立即失效。\n$2$。**修正约束验证**：如果一个条目是修正（$\\tau_l = \\text{'C'}$），该函数会强制执行两个额外规则。被引用的索引 $\\rho_l$ 必须指向一个有效的、已存在的先前条目，满足 $1 \\le \\rho_l \\le i_l-1$。此外，修正的作者 $a_l$ 必须与被引用条目的作者 $a_{\\rho_l}$ 相同。这确保了只有原始作者才能修正他们自己的提交。\n$3$。**作者身份和完整性验证**：这是最后也是最关键的检查。该函数从头开始重新计算整个哈希链。对于每个条目 $l$，它使用当前条目的数据和前一个条目的摘要 $h_{l-1}$ 来构造规范字符串 $S_l$。然后计算摘要 $h_l = H(S_l)$。使用作者的密钥 $K_{a_l}$，它计算预期的 MAC，$M(K_{a_l}, h_l)$。将这个重新计算的 MAC 与条目中存储的记录 $\\text{mac}_l$ 进行比较。不匹配意味着条目内容已被篡改或记录的 MAC 无效，导致整个日志被拒绝。如果 MAC 匹配，计算出的 $h_l$ 将被存储为下一次迭代的新 `prev_hash`。\n\n如果日志中的所有条目都通过了所有这些检查，该函数返回有效状态（$1$）；否则，返回无效状态（$0$）。\n\n`main` 函数系统地构造并评估四个测试用例。\n- **情况 1 (有效)**：按规定定义条目，并首先使用一个辅助函数 `compute_mac_chain`，通过正确计算整个哈希和 MAC 链来填充 `mac` 字段。然后对这个“黄金”日志调用 `verify_log` 函数，预计它将通过所有检查。\n- **情况 2 (被篡改)**：该情况是通过获取情况 1 的有效日志，将条目 3 的消息修改为 `\"Task X\"`，但保留情况 1 中原始的、现在不正确的 MAC 来构建的。预计验证将在条目 3 因 MAC 不匹配而失败。\n- **情况 3 (索引损坏)**：该日志使用非顺序索引（$1, 3, 4$）定义。预计验证将在第二个条目处失败，因为其索引字段 $i_2=3$ 违反了规则 $i_l=l$。\n- **情况 4 (无效修正)**：该日志在索引 2 处定义了一个修正条目，该条目引用了一个索引为 $\\rho_2=3$ 的未来不存在的条目。这违反了规则 $1 \\le \\rho_l \\le i_l-1$，预计验证将失败。\n\n程序计算每个用例的有效性，并以指定的格式 `[1,0,0,0]` 打印结果。", "answer": "[1,0,0,0]", "id": "3642395"}]}