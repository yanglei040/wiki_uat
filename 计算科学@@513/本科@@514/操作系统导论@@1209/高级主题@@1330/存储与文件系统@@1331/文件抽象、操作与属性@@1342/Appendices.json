{"hands_on_practices": [{"introduction": "在任何多用户系统中，控制文件访问对于安全和协作至关重要。POSIX文件权限与用户掩码（$umask$）和`setgid`位等特性相结合，为此提供了一套强大但时而复杂的机制。本练习将挑战你在一个协作场景中精确计算新创建文件的权限，从而巩固你对这些元素如何相互作用以决定访问权限的理解。[@problem_id:3641674]", "problem": "一个协作项目使用一个启用了set-group-ID位的共享目录，以确保所有新对象都继承该项目的组。考虑一个遵循可移植操作系统接口（POSIX）的Linux系统，其权限检查遵循标准的所有者、组和其他语义，且进程创建文件时使用由用户文件创建掩码（通常称为 $umask$）屏蔽的请求模式。项目目录 $/proj$ 的模式为 $2775$（设置了set-group-ID位，所有者和组具有读、写、执行权限，其他人具有读和执行权限）。两个用户，Alice和Bob，都是同一项目组的成员。Alice的 $umask$ 是 $0027$，而Bob的 $umask$ 是 $0002$。\n\n一个构建工具以Alice的身份运行，调用系统调用在 $/proj$ 内创建一个请求模式为 $m_{\\mathrm{req}} = 0666$ 的普通文件 $f$。根据定义，内核计算新创建的普通文件的有效模式如下\n$$\nm_{\\mathrm{eff}} = m_{\\mathrm{req}} \\wedge \\neg m_{u},\n$$\n其中 $m_{u}$ 是进程的 $umask$，$\\wedge$ 表示按位与，$\\neg$ 表示按位取反（限制在通常的权限位掩码内，即所有者、组、其他）。\n\n此外，目录上的set-group-ID位会使在该目录中新创建的文件继承该目录的组身份。它本身不会授予或移除新创建的普通文件上的权限位。\n\nAlice稍后以请求模式 $0777$ 创建了一个子目录 $/proj/alice$。由于共享目录设置了set-group-ID，因此新子目录会继承项目组以及set-group-ID位。然后Bob尝试追加内容到文件 $f$ 中，并在 $/proj/alice$ 内创建一个文件。\n\n仅使用上述核心定义和标准的POSIX权限模型，回答以下问题并在你的工作中定性地解释观察到的行为：计算Alice创建的普通文件 $f$ 的最终有效权限，将其表示为一个十进制整数，该整数等于已设置权限的相应位值之和。其中，常规位值为 $S\\_IRUSR = 256$、$S\\_IWUSR = 128$、$S\\_IXUSR = 64$、$S\\_IRGRP = 32$、$S\\_IWGRP = 16$、$S\\_IXGRP = 8$、$S\\_IROTH = 4$、$S\\_IWOTH = 2$ 和 $S\\_IXOTH = 1$。将你的最终答案表示为一个十进制整数。无需四舍五入。", "solution": "该问题要求在给定请求模式和用户文件创建掩码（$umask$）的情况下，计算在符合POSIX标准的系统上创建的文件的有效权限。此外，还需要对后续文件访问尝试提供定性解释。\n\n核心计算遵循为新创建文件的有效模式 $m_{\\mathrm{eff}}$ 提供的公式：\n$$\nm_{\\mathrm{eff}} = m_{\\mathrm{req}} \\wedge \\neg m_{u}\n$$\n其中 $m_{\\mathrm{req}}$ 是请求的权限模式，$m_{u}$ 是进程的 $umask$，$\\wedge$ 表示按位与，$\\neg$ 表示按位取反。在POSIX文件模式的上下文中，此操作等同于从请求的权限开始，然后移除 $umask$ 中指定的权限。\n\n首先，我们确定用户Alice创建文件 $f$ 的给定值。\n请求模式为 $m_{\\mathrm{req}} = 0666$（八进制）。\nAlice的 $umask$ 为 $m_{u} = 0027$（八进制）。\n\n为了进行按位计算，将这些八进制值表示为二进制是很有帮助的，考虑分别代表所有者、组和其他权限（读、写、执行）的三组三位二进制数。\n请求模式 $m_{\\mathrm{req}} = 0666$ 对应的二进制表示为：\n$$\n\\underbrace{110}_{\\text{所有者: rw-}} \\quad \\underbrace{110}_{\\text{组: rw-}} \\quad \\underbrace{110}_{\\text{其他: rw-}}\n$$\n这授予了所有者、组和其他人读（$r$）和写（$w$）的权限。\n\nAlice的 $umask$，$m_{u} = 0027$，对应的二进制表示为：\n$$\n\\underbrace{000}_{\\text{所有者: ---}} \\quad \\underbrace{010}_{\\text{组: -w-}} \\quad \\underbrace{111}_{\\text{其他: rwx}}\n$$\n此掩码指定了要从请求模式中*移除*哪些权限。该掩码将禁止组写入权限，以及为其他人设置的所有权限（读、写、执行）。\n\n应用公式 $m_{\\mathrm{eff}} = m_{\\mathrm{req}} \\wedge \\neg m_{u}$，我们在请求模式和 $umask$ 的按位取反之间执行按位与操作。\n$$\n\\begin{array}{r@{\\,}c@{\\,}l r}\n  m_{\\mathrm{req}}  =  (110\\;110\\;110)_2  (0666_8) \\\\\n  \\neg m_{u}  =  (111\\;101\\;000)_2  (0750_8) \\\\\n\\hline\n  m_{\\mathrm{eff}}  =  (110\\;100\\;000)_2  (0640_8) \\\\\n\\end{array}\n$$\n文件 $f$ 的最终有效权限是八进制的 $0640$。用符号形式表示为 `rw-r-----`。所有者（Alice）具有读写权限，组具有只读权限，其他人没有任何权限。\n\n问题要求将此权限值表示为基于标准符号常量的十进制整数和。\n授予的权限是：\n\\begin{itemize}\n    \\item 所有者读 (S_IRUSR)：值 256\n    \\item 所有者写 (S_IWUSR)：值 128\n    \\item 组读 (S_IRGRP)：值 32\n\\end{itemize}\n这些值的和是：\n$$\n256 + 128 + 32 = 416\n$$\n\n为完整起见，我们为Bob的后续操作提供所要求的定性解释。\n1.  **Bob尝试向文件 $f$ 追加内容**：向文件追加内容需要写权限。文件 $f$ 是在目录 $/proj$ 中创建的，该目录设置了set-group-ID位。因此，文件 $f$ 继承了 $/proj$ 的组所有权。由于Alice和Bob都是这个项目组的成员，Bob的访问将根据 $f$ 的组权限进行评估。 $f$ 的有效权限是 `rw-r-----`（$0640$）。组权限是只读（`r--`）。由于Bob没有写权限，他向文件追加内容的操作将被操作系统拒绝。\n\n2.  **Bob尝试在 $/proj/alice$ 目录内创建文件**：\n    首先，我们确定子目录 $/proj/alice$ 的权限。Alice以请求模式 $0777$ 创建它。她的 $umask$ 是 $0027$。有效权限为：\n    $$\n    m_{\\mathrm{eff, dir}} = 0777 \\wedge \\neg 0027 = 0750\n    $$\n    这对应于 `rwxr-x---`。目录 $/proj/alice$ 是在设置了set-group-ID的目录 $/proj$ 中创建的，因此它也将设置set-group-ID位，并继承 $/proj$ 的组所有权。所以其有效模式是 $2750$。\n    在一个目录中创建文件，进程需要对该目录同时拥有写（$w$）和执行（$x$）权限。Bob是项目组的成员，因此他对 $/proj/alice$ 的访问受其组权限的约束。$/proj/alice$ 的组权限是 `r-x`（读和执行，但没有写）。由于Bob缺少对该目录的写权限，他尝试在其中创建新文件的操作将被拒绝。", "answer": "$$\\boxed{416}$$", "id": "3641674"}, {"introduction": "一个文件可以有多个名称，但这些名称与底层数据的关系并非总是直观的。POSIX系统为此提供了两种主要方法：硬链接和符号链接，它们各自具有独特的行为和限制，尤其是在跨越不同文件系统时。本实践问题将引导你分析一个跨设备边界创建链接的场景，促使你区分文件名和文件的根本身份（即inode）。[@problem_id:3641681]", "problem": "在可移植操作系统接口 (POSIX) 中，一个文件由序对 $(st\\_dev, st\\_ino)$ 标识，其中 $st\\_dev$ 表示文件 inode 所在文件系统的设备标识符，而 $st\\_ino$ 表示在该设备内唯一的 inode 编号。通过 $link(\\text{oldpath}, \\text{newpath})$ 创建的硬链接会添加一个目录项，该目录项指向与 $\\text{oldpath}$ 相同的底层 inode，并且要求两个名称都指向同一个文件系统设备 $st\\_dev$。通过 $symlink(\\text{target}, \\text{linkpath})$ 创建的符号链接是一个独立的 inode，其内容是路径字符串 $\\text{target}$。调用 $stat(\\text{path})$ 会跟随符号链接，报告最终目标的属性，而 $lstat(\\text{path})$ 则报告符号链接本身的属性。\n\n考虑挂载在 $\\text{/mnt/fsA}$ 和 $\\text{/mnt/fsB}$ 的两个文件系统，它们由具有标识符 $d_A$ 和 $d_B$ 的不同设备支持，且 $d_A \\neq d_B$。一个常规文件存在于 $\\text{/mnt/fsA/alpha}$。您尝试执行以下操作：\n1. $link(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_hard})$。\n2. $symlink(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_soft})$。\n3. $lstat(\\text{/mnt/fsB/alpha\\_soft})$、$stat(\\text{/mnt/fsB/alpha\\_soft})$，然后 $unlink(\\text{/mnt/fsA/alpha})$，再接着 $stat(\\text{/mnt/fsB/alpha\\_soft})$。\n\n仅根据上述基本定义以及一个 inode 不能同时驻留在两个设备上的要求，选择在此场景中所有正确的陈述。\n\nA. $link(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_hard})$ 返回 $-1$ 并将 $errno$ 设置为 $EXDEV$；由于此调用失败，两个文件系统上都没有创建新的目录项。\n\nB. 如果 $link(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_hard})$ 能够成功，$\\text{/mnt/fsB/alpha\\_hard}$ 将报告与 $\\text{/mnt/fsA/alpha}$ 相同的 $st\\_ino$，但 $st\\_dev$ 等于 $d_B$，因为目录决定了新名称的设备。\n\nC. $symlink(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_soft})$ 成功；$lstat(\\text{/mnt/fsB/alpha\\_soft})$ 报告 $st\\_dev = d_B$ 以及一个与 $\\text{/mnt/fsA/alpha}$ 的 $st\\_ino$ 不同的 $st\\_ino$。\n\nD. $stat(\\text{/mnt/fsB/alpha\\_soft})$ 报告的是符号链接本身的属性，而不是目标的属性，因为提供的路径名完全匹配。\n\nE. 通过 $symlink$ 创建 $\\text{/mnt/fsB/alpha\\_soft}$ 会增加 $\\text{/mnt/fsA/alpha}$ 的 $st\\_nlink$，因为它增加了对目标的引用数量。\n\nF. 在使用 $unlink(\\text{/mnt/fsA/alpha})$ 删除目标后，随后的 $stat(\\text{/mnt/fsB/alpha\\_soft})$ 会失败，返回 $-1$ 且 $errno = ENOENT$，因为 $stat$ 跟随符号链接到一个不存在的目标。", "solution": "首先验证问题陈述，以确保其科学上合理、表述清晰且客观。\n\n### 步骤1：提取已知条件\n- 一个文件由序对 $(st\\_dev, st\\_ino)$ 标识。\n- $st\\_dev$：文件系统的设备标识符。\n- $st\\_ino$：inode 编号，在设备内唯一。\n- $link(\\text{oldpath}, \\text{newpath})$：创建一个硬链接，它是一个目录项，指向与 $\\text{oldpath}$ 相同的底层 inode。\n- $link()$ 的要求：$\\text{oldpath}$ 和 $\\text{newpath}$ 必须指向同一个文件系统设备 ($st\\_dev$）。\n- $symlink(\\text{target}, \\text{linkpath})$：创建一个符号链接，它是一个独立的 inode，其内容是路径字符串 $\\text{target}$。\n- $stat(\\text{path})$：跟随符号链接，报告最终目标的属性。\n- $lstat(\\text{path})$：报告符号链接本身的属性。\n- 文件系统 1 挂载在设备 $d_A$ 上的 $\\text{/mnt/fsA}$。\n- 文件系统 2 挂载在设备 $d_B$ 上的 $\\text{/mnt/fsB}$。\n- 已知 $d_A \\neq d_B$。\n- 一个常规文件存在于 $\\text{/mnt/fsA/alpha}$。\n- 给出一个约束：“一个 inode 不能同时驻留在两个设备上”。\n- 尝试的操作序列包括：\n  1. $link(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_hard})$\n  2. $symlink(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_soft})$\n  3. $lstat(\\text{/mnt/fsB/alpha\\_soft})$、$stat(\\text{/mnt/fsB/alpha\\_soft})$，然后 $unlink(\\text{/mnt/fsA/alpha})$，再接着 $stat(\\text{/mnt/fsB/alpha\\_soft})$。\n\n### 步骤2：使用提取的已知条件进行验证\n问题描述了标准 POSIX 文件系统调用（$link$、$symlink$、$stat$、$lstat$）和概念（inode、设备 ID、硬链接、符号链接）的行为。所提供的定义是这些概念在操作系统领域内的准确表述。该场景涉及两个不同的文件系统，这是测试文件系统行为（特别是跨设备操作）的标准配置。问题是客观的，需要将所提供的定义应用于具体场景。该问题以计算机科学原理为科学基础，表述清晰，客观，并且没有内部矛盾或缺失信息。\n\n### 步骤3：结论与行动\n问题是有效的。解决方案通过根据提供的定义和场景评估每个选项来进行。\n\n### 逐项分析\n\n**A. $link(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_hard})$ 返回 $-1$ 并将 $errno$ 设置为 $EXDEV$；由于此调用失败，两个文件系统上都没有创建新的目录项。**\n\n- **推理**：问题陈述了 $link(\\text{oldpath}, \\text{newpath})$ 的一个要求，即两个路径必须指向同一个文件系统设备。路径 $\\text{/mnt/fsA/alpha}$ 位于设备 $d_A$ 上。路径 $\\text{/mnt/fsB/alpha\\_hard}$ 将在挂载于 $\\text{/mnt/fsB}$ 的文件系统上创建，该文件系统位于设备 $d_B$ 上。由于已知 $d_A \\neq d_B$，这是一个创建跨设备硬链接的尝试。POSIX 标准规定此类尝试必须失败。失败的跨设备链接的错误代码是 $EXDEV$（“Cross-device link”）。当一个系统调用失败（返回 $-1$）时，其主要动作不会被执行；因此，不会创建新的目录项。\n- **结论**：**正确**。\n\n**B. 如果 $link(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_hard})$ 能够成功，$\\text{/mnt/fsB/alpha\\_hard}$ 将报告与 $\\text{/mnt/fsA/alpha}$ 相同的 $st\\_ino$，但 $st\\_dev$ 等于 $d_B$，因为目录决定了新名称的设备。**\n\n- **推理**：此选项提出了一个假设性的反事实情景。根据定义，硬链接是指向*完全相同 inode* 的另一个名称。一个 inode 由序对 $(st\\_dev, st\\_ino)$ 唯一标识，并物理上驻留在单个设备上。文件 $\\text{/mnt/fsA/alpha}$ 的 inode 驻留在设备 $d_A$ 上。如果可以从另一个设备为其创建一个硬链接，任何对该 inode 的引用都必须报告其原始设备 ID，即 $d_A$。该陈述声称它将报告 $st\\_dev = d_B$，这与 inode 的基本性质相矛盾，并违反了问题中明确的约束条件“一个 inode 不能同时驻留在两个设备上”。此选项的前提在逻辑和技术上都是不合理的。\n- **结论**：**错误**。\n\n**C. $symlink(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_soft})$ 成功；$lstat(\\text{/mnt/fsB/alpha\\_soft})$ 报告 $st\\_dev = d_B$ 以及一个与 $\\text{/mnt/fsA/alpha}$ 的 $st\\_ino$ 不同的 $st\\_ino$。**\n\n- **推理**：与硬链接不同，符号链接没有跨设备的限制。符号链接是一个独立的文件，其内容是一个路径字符串。调用 $symlink(\\text{/mnt/fsA/alpha}, \\text{/mnt/fsB/alpha\\_soft})$ 会在目录 $\\text{/mnt/fsB}$ 中创建一个名为 $\\text{alpha\\_soft}$ 的新文件。这个新文件是驻留在设备 $d_B$ 上的文件系统中的一个 inode。因此，此调用将成功。根据定义，调用 $lstat(\\text{path})$ 会报告符号链接文件本身的属性。因此，$lstat(\\text{/mnt/fsB/alpha\\_soft})$ 将报告这个新创建文件的属性。它的设备 ID ($st\\_dev$) 将是 $d_B$，其 inode 编号 ($st\\_ino$) 将是在设备 $d_B$ 上分配的一个新的、不同的编号。这个 inode 明确地与驻留在设备 $d_A$ 上的 $\\text{/mnt/fsA/alpha}$ 的 inode 不同。\n- **结论**：**正确**。\n\n**D. $stat(\\text{/mnt/fsB/alpha\\_soft})$ 报告的是符号链接本身的属性，而不是目标的属性，因为提供的路径名完全匹配。**\n\n- **推理**：该陈述直接与问题陈述中提供的定义相矛盾：“$stat(\\text{path})$ 跟随符号链接，报告最终目标的属性”。专门设计用于报告链接本身属性的函数是 $lstat(\\text{path})$。所提供的理由（“因为提供的路径名完全匹配”）在此上下文中毫无意义。$stat$ 的行为由其定义决定，而不是由路径的字符串匹配决定。\n- **结论**：**错误**。\n\n**E. 通过 $symlink$ 创建 $\\text{/mnt/fsB/alpha\\_soft}$ 会增加 $\\text{/mnt/fsA/alpha}$ 的 $st\\_nlink$，因为它增加了对目标的引用数量。**\n\n- **推理**：文件元数据中的 $st\\_nlink$ 字段计算指向其 inode 的硬链接数量。符号链接是一个独立的文件和独立的 inode；它不会创建一个指向目标 inode 的新目录项。因此，创建符号链接不会改变目标文件的硬链接计数（$st\\_nlink$）。只有使用 $link()$ 创建硬链接才会增加 $st\\_nlink$。\n- **结论**：**错误**。\n\n**F. 在使用 $unlink(\\text{/mnt/fsA/alpha})$ 删除目标后，随后的 $stat(\\text{/mnt/fsB/alpha\\_soft})$ 会失败，返回 $-1$ 且 $errno = ENOENT$，因为 $stat$ 跟随符号链接到一个不存在的目标。**\n\n- **推理**：符号链接 $\\text{/mnt/fsB/alpha\\_soft}$ 包含路径字符串“/mnt/fsA/alpha”。调用 $unlink(\\text{/mnt/fsA/alpha})$ 会删除目标文件。符号链接本身仍然存在，但它现在是“悬空”或“损坏”的，因为其目标路径不再解析为现有文件。根据定义，调用 $stat(\\text/mnt/fsB/alpha\\_soft)$ 会跟随符号链接。它将读取路径“/mnt/fsA/alpha”并尝试检索该文件的状态。由于该文件不再存在，路径解析失败，$stat$ 调用返回错误。对于不存在的文件或路径组件，标准错误代码是 $ENOENT$（“No such file or directory”）。因此，该调用将失败，返回值为 $-1$ 并将 $errno$ 设置为 $ENOENT$。\n- **结论**：**正确**。", "answer": "$$\\boxed{ACF}$$", "id": "3641681"}, {"introduction": "当多个进程共享对一个文件的访问权限时，尤其是在`fork()`系统调用之后，用户空间的I/O缓冲区与内核共享的文件偏移量之间的相互作用可能会产生一些反直觉的结果。理解这种分层机制是编写正确且可预测的并发程序的关键。本练习通过一个精心编排的父子进程读写序列，让你能够追踪文件的最终状态，从而揭示数据交错之谜。[@problem_id:3641751]", "problem": "考虑一个实现了经典 Unix 文件抽象的 POSIX（可移植操作系统接口）系统。单个进程打开一个常规文件（初始为空）进行写入，获得一个指向一个打开文件描述 (open file description) 的文件描述符。然后它调用系统调用 `dup` 来获得第二个文件描述符，该描述符指向同一个打开文件描述。每个描述符都被包装进其自己的标准输入/输出 (stdio) 流中（即两个不同的 `FILE*` 对象），两者都被设置为全缓冲模式，以便应用层级的写入在显式刷新 (flush) 前不会到达内核。随后该进程调用 `fork` 创建一个子进程。`fork` 之后，父进程关闭子进程的流，并且只使用自己的流；子进程关闭父进程的流，并且只使用自己的流。因此，两个进程都持有不同的 stdio 缓冲区，但它们的文件描述符仍然指向内核中同一个打开文件描述，并共享一个当前文件偏移量。\n\n假设以下严格执行的操作序列，每一步都在下一步开始前完成（例如，通过使用同步或休眠来强制执行此确切顺序）。设字符串为所示的字面字节序列，并假设对只写流的每次 `fflush` 都会导致对缓冲字节的一次单独的 `write` 系统调用，期间没有重定位操作：\n\n- 步骤 $1$ (父进程): 对其流执行 `fputs(\"AA\")`；不刷新。\n- 步骤 $2$ (子进程): 对其流执行 `fputs(\"cc\")`；然后 `fflush` (强制写入)。\n- 步骤 $3$ (父进程): `fflush` (强制写入先前缓冲的 \"AA\")。\n- 步骤 $4$ (父进程): 对其流执行 `fputs(\"BB\")`；不刷新。\n- 步骤 $5$ (子进程): 对其流执行 `fputs(\"dd\")`；然后 `fflush` (强制写入)。\n- 步骤 $6$ (父进程): `fflush` (强制写入先前缓冲的 \"BB\")。\n- 步骤 $7$ (两者): `close` 它们的流。\n\n假设写入操作成功完成，没有错误。在这些条件下，以下哪项最能描述最终的文件字节序列以及存储在共享的打开文件描述中的最终当前文件偏移量？\n\nA. 文件包含 `ccAAddBB`，最终当前文件偏移量为 $8$。\n\nB. 文件包含 `AAccddBB`，最终当前文件偏移量为 $8$。\n\nC. 文件包含 `ccBBAAdd`，最终当前文件偏移量为 $8$。\n\nD. 由于进程调度和 stdio 缓冲，结果是不确定的；无法预测确定的最终字节序列或偏移量。\n\nE. 文件包含 `ccAAddBB`，但最终当前文件偏移量为 $4$，因为每个流独立于内核跟踪自己的偏移量。", "solution": "用户需要对 POSIX 环境中的一个文件 I/O 问题进行细致的分析，该问题涉及进程派生 (forking)、共享文件状态和库缓冲。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **系统：**一个 POSIX（可移植操作系统接口）系统。\n- **文件抽象：**经典的 Unix 模型。\n- **初始设置：**单个进程打开一个常规的、初始为空的文件进行写入。这会创建一个文件描述符，它指向一个打开文件描述 (OFD)。\n- **复制：**进程调用 `dup`，创建第二个文件描述符。现在两个描述符都指向同一个 OFD。\n- **标准 I/O 流：**两个文件描述符被包装成两个不同的 `FILE*` 对象（stdio 流）。两个流都设置为全缓冲模式。\n- **进程创建：**进程调用 `fork`，创建一个父进程和一个子进程。\n- **`fork`后状态：**\n    - 父进程和子进程各自继承了文件描述符和 `FILE*` 流。\n    - 父进程关闭子进程使用的流，反之亦然。\n    - 每个进程都有自己独立的 stdio 缓冲区。\n    - 两个进程中的底层文件描述符都指向内核中同一个 OFD，该 OFD 维护着一个单一、共享的当前文件偏移量。\n- **严格执行的序列：**\n    1.  父进程：对其流执行 `fputs(\"AA\")`；不刷新。\n    2.  子进程：对其流执行 `fputs(\"cc\")`，然后 `fflush`。\n    3.  父进程：`fflush`。\n    4.  父进程：对其流执行 `fputs(\"BB\")`；不刷新。\n    5.  子进程：对其流执行 `fputs(\"dd\")`，然后 `fflush`。\n    6.  父进程：`fflush`。\n    7.  两者：`close` 它们的流。\n- **假设：**\n    - 字符串 `\"AA\"`、`\"cc\"`、`\"BB\"`、`\"dd\"` 是字面字节序列。\n    - 每次 `fflush` 都会导致一次单独的 `write` 系统调用。\n    - 没有 `lseek` 或其他重定位调用发生。\n    - 所有操作都成功无误。\n- **问题：**文件中最终的字节序列是什么？共享 OFD 中当前文件偏移量的最终值是多少？\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：**该问题基于 POSIX/Unix 操作系统 API 的基本且公认的原则，包括 `open`、`dup`、`fork`、`write` 的行为、标准库缓冲 (`stdio`)，以及文件描述符（每个进程独有）和打开文件描述（系统范围）之间的区别。这些概念是操作系统理论与实践的核心。描述在事实上是合理的。\n- **问题定义良好：**该问题提供了一个清晰的初始状态、一个严格定义的操作序列以及足以消除歧义的假设。严格的调度确保了确定性的结果，从而导向一个唯一且有意义的解决方案。\n- **客观性：**该问题使用精确的技术语言（例如“文件描述符”、“打开文件描述”、“全缓冲模式”、`fflush`）进行陈述。问题是客观的，其答案可以从前提中逻辑推导出来。\n\n**步骤3：结论与行动**\n问题陈述是有效的。它具有科学依据，定义良好且客观。它提供了一个标准的、不简单的对操作系统文件管理理解能力的测试。我将继续进行详细的解答推导。\n\n### 解答推导\n\n这个问题的核心在于跟踪三个不同实体的状态：\n1.  父进程的用户空间 `stdio` 缓冲区。\n2.  子进程的用户空间 `stdio` 缓冲区。\n3.  单一、共享的内核级打开文件描述 (OFD)，其中包含当前文件偏移量。\n\n让我们通过严格执行的序列来追踪状态。文件初始为空，OFD 中的文件偏移量为 $0$。\n\n- **初始状态：**\n  - 文件内容：(空)\n  - 共享文件偏移量：$0$\n  - 父进程的 `stdio` 缓冲区：(空)\n  - 子进程的 `stdio` 缓冲区：(空)\n\n- **步骤 1 (父进程): 对其流执行 `fputs(\"AA\")`；不刷新。**\n  - `fputs` 函数调用将 $2$ 字节的 `\"AA\"` 复制到父进程的用户空间 `stdio` 缓冲区中。\n  - 由于流是全缓冲的且未调用 `fflush`，因此没有对内核进行系统调用。\n  - 文件内容和共享的内核文件偏移量保持不变。\n  - **状态：**\n    - 文件内容：(空)\n    - 共享文件偏移量：$0$\n    - 父进程的 `stdio` 缓冲区：`\"AA\"`\n    - 子进程的 `stdio` 缓冲区：(空)\n\n- **步骤 2 (子进程): 对其流执行 `fputs(\"cc\")`；然后 `fflush`。**\n  - 首先，`fputs(\"cc\")` 将 $2$ 字节的 `\"cc\"` 复制到子进程独立的用户空间 `stdio` 缓冲区中。\n  - 然后，对子进程的流调用 `fflush`。这会触发一次 `write` 系统调用到内核，传输子进程缓冲区的内容。\n  - `write` 操作使用当前的共享文件偏移量，即 $0$。\n  - 字节 `\"cc\"` 被写入文件。\n  - 内核原子性地将共享文件偏移量增加写入的字节数 ($2$)。\n  - 子进程的 `stdio` 缓冲区现在为空。\n  - **状态：**\n    - 文件内容：`\"cc\"`\n    - 共享文件偏移量：$0 + 2 = 2$\n    - 父进程的 `stdio` 缓冲区：`\"AA\"`\n    - 子进程的 `stdio` 缓冲区：(空)\n\n- **步骤 3 (父进程): `fflush`。**\n  - 对父进程流的 `fflush` 调用为其缓冲区中的数据 `\"AA\"` 触发一次 `write` 系统调用。\n  - 这个 `write` 操作使用当前的共享文件偏移量，现在是 $2$。\n  - 字节 `\"AA\"` 被写入文件，紧跟在先前写入的 `\"cc\"` 之后。\n  - 内核将共享文件偏移量增加写入的字节数 ($2$)。\n  - 父进程的 `stdio` 缓冲区现在为空。\n  - **状态：**\n    - 文件内容：`\"ccAA\"`\n    - 共享文件偏移量：$2 + 2 = 4$\n    - 父进程的 `stdio` 缓冲区：(空)\n    - 子进程的 `stdio` 缓冲区：(空)\n\n- **步骤 4 (父进程): 对其流执行 `fputs(\"BB\")`；不刷新。**\n  - 父进程的 `fputs` 调用将 $2$ 字节的 `\"BB\"` 复制到其 `stdio` 缓冲区中。没有进行 `write` 系统调用。\n  - **状态：**\n    - 文件内容：`\"ccAA\"`\n    - 共享文件偏移量：$4$\n    - 父进程的 `stdio` 缓冲区：`\"BB\"`\n    - 子进程的 `stdio` 缓冲区：(空)\n\n- **步骤 5 (子进程): 对其流执行 `fputs(\"dd\")`；然后 `fflush`。**\n  - `fputs(\"dd\")` 将 $2$ 字节的 `\"dd\"` 复制到子进程的缓冲区中。\n  - `fflush` 触发一次 `write` 系统调用。`write` 从当前的共享偏移量 $4$ 开始。\n  - 字节 `\"dd\"` 被写入文件。\n  - 内核将共享偏移量增加 $2$。\n  - 子进程的缓冲区被清空。\n  - **状态：**\n    - 文件内容：`\"ccAAdd\"`\n    - 共享文件偏移量：$4 + 2 = 6$\n    - 父进程的 `stdio` 缓冲区：`\"BB\"`\n    - 子进程的 `stdio` 缓冲区：(空)\n\n- **步骤 6 (父进程): `fflush`。**\n  - 对父进程流的 `fflush` 为其缓冲区的内容 `\"BB\"` 触发一次 `write` 系统调用。\n  - 这个 `write` 从当前的共享偏移量 $6$ 开始。\n  - 字节 `\"BB\"` 被写入文件。\n  - 内核将共享偏移量增加 $2$。\n  - 父进程的缓冲区被清空。\n  - **状态：**\n    - 文件内容：`\"ccAAddBB\"`\n    - 共享文件偏移量：$6 + 2 = 8$\n    - 父进程的 `stdio` 缓冲区：(空)\n    - 子进程的 `stdio` 缓冲区：(空)\n\n- **步骤 7 (两者): `close` 它们的流。**\n  - 关闭流会自动刷新任何剩余的缓冲数据。由于在步骤 $6$ 之后两个缓冲区都为空，所以这对文件内容没有进一步的影响。文件描述符和 OFD 的引用计数被递减，最终导致它们被内核释放。\n\n**推导结论：**\n文件的最终内容是字节序列 `\"ccAAddBB\"`。写入的总字节数是 $2+2+2+2 = 8$。由于写入从偏移量 $0$ 开始，共享当前文件偏移量的最终值为 $8$。\n\n### 逐项分析选项\n\n**A. 文件包含 `ccAAddBB` 且最终当前文件偏移量为 $8$。**\n- 这与分步推导的结果相符。`fflush` 调用的顺序决定了 `write` 系统调用的顺序，而共享的文件偏移量确保了它们是连续写入的。最终偏移量是所有写入块大小的总和。\n- **结论：正确。**\n\n**B. 文件包含 `AAccddBB` 且最终当前文件偏移量为 $8$。**\n- 这个结果要求父进程的第一次写入 (`\"AA\"`) 发生在子进程的第一次写入 (`\"cc\"`) 之前。这直接与问题中严格执行的序列相矛盾，序列中子进程的 `fflush` (步骤 $2$) 发生在父进程的 `fflush` (步骤 $3$) 之前。\n- **结论：不正确。**\n\n**C. 文件包含 `ccBBAAdd` 且最终当前文件偏移量为 $8$。**\n- 这个结果意味着写入顺序是 `\"cc\"`、`\"BB\"`、`\"AA\"`、`\"dd\"` 之类的。这个顺序在多方面违反了指定的序列。例如，它要求 `\"BB\"` 的写入（来自父进程步骤 $6$ 的 `fflush`）发生在 `\"AA\"` 的写入（来自父进程步骤 $3$ 的 `fflush`）之前。\n- **结论：不正确。**\n\n**D. 由于进程调度和 stdio 缓冲，结果是不确定的；无法预测确定的最终字节序列或偏移量。**\n- 这个说法是错误的，因为问题明确指出：“假设以下严格执行的操作序列”。这个约束消除了通常与并发进程执行相关的不确定性，使得结果是可预测的。\n- **结论：不正确。**\n\n**E. 文件包含 `ccAAddBB` 但最终当前文件偏移量为 $4$，因为每个流独立于内核跟踪自己的偏移量。**\n- 文件内容 `\"ccAAddBB\"` 是正确的。然而，关于偏移量的推理存在根本性错误。在 POSIX/Unix 中，文件偏移量是内核的打开文件描述的属性，而不是用户空间的 `FILE*` 流或每个进程的文件描述符的属性。问题明确指出，两个进程的描述符都指向 *同一个* OFD，因此共享 *一个* 文件偏移量。最终偏移量必须是写入的总字节数，即 $8$。\n- **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3641751"}]}