{"hands_on_practices": [{"introduction": "文件系统检查工具 `fsck` 的一项核心任务是解决高层摘要信息与底层“事实”之间的不一致。本练习模拟了这一过程：验证文件系统摘要元数据中的空闲块计数器是否与分配位图中逐块记录的详细信息相符。通过实现这一检查，您将亲身体验文件系统如何检测和纠正因系统崩溃引起的基本记账错误。[@problem_id:3643422]", "problem": "给定一个基于块的文件系统的简化模型，该文件系统被划分为多个块组。每个块组 $g$ 拥有总共 $B_g$ 个块，其中前 $R_g$ 个块为元数据保留，绝不能计入空闲块。该文件系统为每个组维护一个空闲空间位图，其中位值为 $1$ 表示空闲块，位值为 $0$ 表示已分配块。该位图覆盖了组中的所有 $B_g$ 个块。文件系统还存储一个每组摘要计数器 $S_g$，该计数器应当等于该组中空闲数据块的数量。文件系统范围的摘要是所有每组计数器之和。\n\n此处与文件系统一致性检查相关的基本不变量是：\n- 空闲空间位图是关于哪些块当前空闲的权威性逐块记录。根据定义，组 $g$ 的真实空闲计数等于非保留位置中值为 $1$ 的位数，即索引 $i$ 满足 $R_g \\le i \\lt B_g$ 的位置。\n- 保留块不可用于文件数据，因此无论其位图值如何，它们的位都必须被视作已分配。在正确的位图中，保留位为 $0$，但一个健壮的协调过程绝不能将任何保留位置计为空闲。\n- 组摘要 $S_g$ 应等于从位图派生出的空闲数据块计数。文件系统范围的空闲块摘要应为总和 $\\sum_{g=0}^{G-1} S_g$，其中 $G$ 是组的数量。\n\n设计一个类似于文件系统检查器的协调程序，该程序执行以下操作：\n1. 为每个组 $g$ 重新计算校正后的空闲块计数 $C_g$，方法是在位图中计算索引 $i$ 满足 $R_g \\le i \\lt B_g$ 的位置上值为 $1$ 的位数，忽略前 $R_g$ 个作为保留的位。\n2. 将 $C_g$ 与存储的 $S_g$ 进行比较，如果 $C_g \\ne S_g$，则将该组标记为不一致。\n3. 计算校正后的文件系统范围总空闲块数 $T = \\sum_{g=0}^{G-1} C_g$。\n4. 为每个测试用例报告列表 $\\left[C_0, C_1, \\dots, C_{G-1}, T, K\\right]$，其中 $K$ 是 $C_g \\ne S_g$ 的组的数量。\n\n实现一个完整的、可运行的程序，该程序硬编码以下测试套件并计算协调结果：\n\n测试用例 1：\n- $G = 3$\n- 组 0：$B_0 = 16$，$R_0 = 2$，位图字符串是长度为 16 的序列 \"0010110010011001\"，存储的摘要 $S_0 = 5$。\n- 组 1：$B_1 = 8$，$R_1 = 1$，位图字符串是长度为 8 的序列 \"01001001\"，存储的摘要 $S_1 = 6$。\n- 组 2：$B_2 = 10$，$R_2 = 0$，位图字符串是长度为 10 的序列 \"1100000000\"，存储的摘要 $S_2 = 4$。\n\n测试用例 2：\n- $G = 2$\n- 组 0：$B_0 = 5$，$R_0 = 5$，位图字符串是长度为 5 的序列 \"00000\"，存储的摘要 $S_0 = 2$。\n- 组 1：$B_1 = 5$，$R_1 = 0$，位图字符串是长度为 5 的序列 \"10101\"，存储的摘要 $S_1 = 3$。\n\n测试用例 3：\n- $G = 3$\n- 组 0：$B_0 = 4$，$R_0 = 0$，位图字符串是长度为 4 的序列 \"1111\"，存储的摘要 $S_0 = 0$。\n- 组 1：$B_1 = 4$，$R_1 = 2$，位图字符串是长度为 4 的序列 \"0001\"，存储的摘要 $S_1 = 2$。\n- 组 2：$B_2 = 1$，$R_2 = 0$，位图字符串是长度为 1 的序列 \"0\"，存储的摘要 $S_2 = 0$。\n\n你的程序必须：\n- 完全按照规定使用这些硬编码输入。\n- 将任何索引为 $0 \\le i \\lt R_g$ 的保留位置视作非空闲，无论位图中的位值如何。\n- 对于每个测试用例，计算每个组的 $C_g$、总数 $T$ 以及不一致组的数量 $K$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号列表组成的逗号分隔列表，每个测试用例一个，按上述顺序排列。具体来说，输出必须采用以下格式：\n  - $\\left[\\left[C_0^{(1)}, C_1^{(1)}, \\dots, C_{G^{(1)}-1}^{(1)}, T^{(1)}, K^{(1)}\\right], \\left[C_0^{(2)}, \\dots, T^{(2)}, K^{(2)}\\right], \\left[C_0^{(3)}, \\dots, T^{(3)}, K^{(3)}\\right]\\right]$\n  其中上标 $(j)$ 表示测试用例 $j$。\n- 元素 $C_g$、$T$ 和 $K$ 均为整数。\n- 除了该单行方括号内容外，不得有任何额外的文本或空白字符。", "solution": "问题陈述提供了一个基于块的文件系统的简化模型，并要求实现一个类似于文件系统检查器的协调程序，以验证和校正其空闲块核算。该问题在科学上基于操作系统和文件系统设计的原理，定义明确，包含所有必要的数据和清晰的目标，并以客观、正式的语言表述。因此，它被认为是一个有效的问题。\n\n任务的核心是根据每个组的位图重新计算其空闲块数，将此校正后的计数与存储的摘要进行比较，并汇总结果。该过程由一套精确的规则指定。设 $G$ 为文件系统中的块组数量。对于从 $0$ 到 $G-1$ 的每个组 $g$，我们给定：\n- $B_g$：组中的总块数。\n- $R_g$：为元数据保留的初始块数。\n- 长度为 $B_g$ 的位图字符串，其中 '1' 表示空闲块，'0' 表示已分配块。\n- $S_g$：一个存储的摘要值，声称是该组中空闲数据块的数量。\n\n该协调过程涉及为每个测试用例计算三个量：一个校正后的每组空闲块计数的向量 $[C_0, C_1, \\dots]$，一个校正后的文件系统范围总空闲块计数 $T$，以及一个不一致组的计数 $K$。\n\n步骤 1：计算校正后的空闲块计数 $C_g$\n基本不变量是，位图是块分配状态的权威事实来源。然而，一个关键约束是，保留块绝不能被计为空闲，无论其在位图中的对应位值如何。保留块占据索引 $i$ 满足 $0 \\le i  R_g$ 的位置。因此，组 $g$ 中可用于数据存储的块池由索引 $i$ 满足 $R_g \\le i  B_g$ 的块组成。\n\n组 $g$ 的校正后空闲块计数（表示为 $C_g$）是通过遍历该组位图的非保留部分并对值为 $1$ 的位进行求和来确定的。形式上，这表示为：\n$$ C_g = \\sum_{i=R_g}^{B_g - 1} \\mathbf{1}(\\text{bitmap}_g[i] = \\text{'1'}) $$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数，如果其参数为真，则其值为 $1$，否则为 $0$。用于此计算的循环从第一个非保留块索引 $R_g$ 开始，直到（但不包括）总块数 $B_g$。\n\n步骤 2：识别不一致的组并计算 $K$\n如果一个组 $g$ 的存储摘要计数器 $S_g$ 与新计算的权威计数 $C_g$ 不匹配，则该组被标记为不一致。不一致组的总数 $K$ 是满足此条件的所有组的计数。\n$$ K = \\sum_{g=0}^{G-1} \\mathbf{1}(C_g \\neq S_g) $$\n此步骤通过将计算出的 $C_g$ 与为每个组提供的 $S_g$ 进行比较，并为每个检测到的差异增加一个计数器来执行。\n\n步骤 3：计算校正后的文件系统范围总数 $T$\n校正后的文件系统范围总空闲块数 $T$ 就是所有组的校正后空闲块计数之和。\n$$ T = \\sum_{g=0}^{G-1} C_g $$\n该值表示经过协调后整个文件系统中真实空闲数据块的数量。\n\n计算示例（测试用例 1，组 0）：\n- 给定：$B_0 = 16$，$R_0 = 2$，位图 = \"0010110010011001\"，$S_0 = 5$。\n- 我们通过对位图中从索引 $i=2$ 到 $i=15$ 的 '1' 进行求和来计算 $C_0$。\n- 要检查的子字符串是 `10110010011001`。\n- 计算 '1' 的数量：在索引 2, 4, 5, 8, 11, 12, 15。共有 7 个 '1'。\n- 因此，校正后的计数为 $C_0 = 7$。\n- 我们将 $C_0$ 与 $S_0$ 进行比较。由于 $C_0 = 7$ 且 $S_0 = 5$，我们得到 $C_0 \\neq S_0$。该组是不一致的。\n\n此过程被系统地应用于所有测试用例中的所有组，以生成所需的输出向量。每个测试用例的最终报告是一个有序列表，其中包含每组的校正后计数、总校正后计数以及不一致组的数量：$[C_0, C_1, \\dots, C_{G-1}, T, K]$。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3643422"}, {"introduction": "在简单的块计数之上，本练习将探讨单个文件内部的一致性。您将开发一个检查程序，用于验证文件的记录大小是否与其块映射（由盘区表示）一致，这对于现代文件系统至关重要。此实践将教您如何识别诸如“已初始化数据超出官方文件末尾”之类的不一致性，并设计出能够保全用户数据的非破坏性修复策略。[@problem_id:3643409]", "problem": "您将获得一个文件系统的简化模型，该模型将文件存储为一组逻辑区段。每个文件都有一个记录大小和一系列区段，其中每个区段将一个连续的逻辑块范围映射到已初始化（已写入）数据或未写入的预分配空间。您的任务是构建一个一致性检查器，该检查器交叉验证记录的文件大小与已初始化区段所暗示的大小，检测区段之间的逻辑重叠，并提出避免截断任何已初始化数据的非破坏性修复操作。\n\n基本原理和定义：\n\n- 一个文件由以下内容描述：\n  - 块大小 $B$，以字节为单位。\n  - 记录大小 $S$，以字节为单位。\n  - 一个区段列表 $\\{(l_i, n_i, w_i)\\}_{i=1}^N$，其中：\n    - $l_i$ 是逻辑起始块索引（一个满足 $l_i \\ge 0$ 的整数）。\n    - $n_i$ 是区段中的块数（一个满足 $n_i \\ge 0$ 的整数）。\n    - $w_i \\in \\{0,1\\}$ 指示区段是已初始化 ($1$) 还是未写入的预分配空间 ($0$) 。\n\n- 每个区段 $i$ 覆盖逻辑块区间 $I_i = [l_i, l_i + n_i)$（以块为单位）。如果 $\\max(l_i, l_j)  \\min(l_i + n_i, l_j + n_j)$，则两个区段 $i$ 和 $j$ 在逻辑空间上重叠。\n\n- 最大已分配逻辑字节末端是\n  $$M_{\\text{alloc}} = \\max_{1 \\le i \\le N} (l_i + n_i) \\cdot B,$$\n  其中空集合的最大值定义为 $0$。\n\n- 最大初始化逻辑字节末端是\n  $$M_{\\text{init}} = \\max_{1 \\le i \\le N, \\, w_i = 1} (l_i + n_i) \\cdot B,$$\n  其中空集合的最大值定义为 $0$。\n\n- 表示记录大小所需的块数向上取整为\n  $$Q = \\left\\lceil \\frac{S}{B} \\right\\rceil.$$\n\n一致性解释和避免截断已初始化数据的非破坏性修复建议：\n\n- 如果 $S  M_{\\text{init}}$，则一些已初始化数据位于记录的文件末尾之后。一个非破坏性的修正是将记录大小增加到\n  $$S_{\\text{rec}} = M_{\\text{init}}.$$\n\n- 否则，保持记录大小：\n  $$S_{\\text{rec}} = S.$$\n\n- 可以安全地移除文件末尾之外的未写入预分配空间，而不会有数据丢失的风险。定义要从文件末尾之外丢弃的未写入块的总数为\n  $$C = \\sum_{i: w_i = 0} \\max\\left(0,\\,(l_i + n_i) - Q\\right).$$\n  该公式计算每个未写入区段超出文件逻辑末尾（即块 $Q$）的块数。\n\n- 计算重叠区段对的数量\n  $$O = \\#\\left\\{(i,j) \\mid 1 \\le i  j \\le N,\\; \\max(l_i, l_j)  \\min(l_i + n_i, l_j + n_j)\\right\\}.$$\n\n- 定义一个风险指示器\n  $$R = \\begin{cases}\n  1  \\text{if there exists an overlapping pair with } w_i = 1 \\text{ and } w_j = 1,\\\\\n  0  \\text{otherwise.}\n  \\end{cases}$$\n  这表示已初始化区段之间存在重叠，可能由于潜在的数据冲突而需要手动解决。\n\n程序要求：\n\n- 对于每个测试用例，计算元组 $\\left(O, S_{\\text{rec}}, C, R\\right)$，所有四个值均为整数。\n\n- 您的程序必须处理以下七个案例的测试套件。对于每个案例，都提供了块大小 $B$、记录大小 $S$ 和区段列表。每个区段都按上述顺序以三元组 $(l_i, n_i, w_i)$ 的形式给出。\n\n  - 测试用例 1：\n    - $B = 4096$, $S = 12288$。\n    - 区段：$(0, 3, 1)$。\n  - 测试用例 2：\n    - $B = 4096$, $S = 20480$。\n    - 区段：$(0, 2, 1)$。\n  - 测试用例 3：\n    - $B = 4096$, $S = 8192$。\n    - 区段：$(0, 3, 1)$。\n  - 测试用例 4：\n    - $B = 4096$, $S = 4096$。\n    - 区段：$(0, 1, 1)$, $(1, 4, 0)$。\n  - 测试用例 5：\n    - $B = 4096$, $S = 12288$。\n    - 区段：$(0, 3, 1)$, $(2, 2, 1)$。\n  - 测试用例 6：\n    - $B = 4096$, $S = 0$。\n    - 区段：无 (空列表)。\n  - 测试用例 7：\n    - $B = 4096$, $S = 4500$。\n    - 区段：$(0, 1, 1)$, $(1, 1, 0)$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个按 $\\left[O,S_{\\text{rec}},C,R\\right]$ 顺序排列的方括号列表。不使用空格。例如，一个包含两个案例的输出可能看起来像 “$[[1,100,0,0],[0,80,2,1]]$”。对于给定的七个测试用例，按顺序将所有七个结果列表聚合，并只输出一行。", "solution": "该问题提供了一个文件系统的文件表示简化模型，并要求实现一个一致性检查器来计算四个指标：重叠区段的数量 ($O$)、推荐的非破坏性文件大小 ($S_{\\text{rec}}$)、可回收的未写入块数 ($C$)，以及已初始化数据重叠的风险指示器 ($R$)。该问题定义明确，在操作系统原理方面有科学依据，并提供了所有必要的公式和数据。因此，它被认为是一个有效的问题。\n\n我们将对提供的七个测试用例逐一应用给定的定义和公式。\n\n对于任何给定的文件，我们有：\n- 块大小 $B$\n- 记录大小 $S$\n- 一个包含 $N$ 个区段的列表 $\\{(l_i, n_i, w_i)\\}_{i=1}^N$\n\n派生量如下：\n- 记录大小所需的块数向上取整：$Q = \\left\\lceil \\frac{S}{B} \\right\\rceil$。对于非负 $S$ 和正 $B$ 的整数算术，这计算为 $(S + B - 1) / B$。\n- 最大初始化逻辑字节末端：$M_{\\text{init}} = \\max_{i: w_i = 1} (l_i + n_i) \\cdot B$。\n- 推荐大小：$S_{\\text{rec}} = \\max(S, M_{\\text{init}})$。\n- 重叠计数：$O = \\#\\left\\{(i,j) \\mid 1 \\le i  j \\le N,\\; \\max(l_i, l_j)  \\min(l_i + n_i, l_j + n_j)\\right\\}$。\n- 可丢弃的未写入块计数：$C = \\sum_{i: w_i = 0} \\max\\left(0,\\,(l_i + n_i) - Q\\right)$。\n- 风险指示器：如果存在重叠对 $(i,j)$ 且 $w_i=1$ 和 $w_j=1$，则 $R=1$；否则 $R=0$。\n\n我们现在分析每个案例。\n\n**测试用例 1：**\n- 给定：$B = 4096$, $S = 12288$, 区段：$\\{(0, 3, 1)\\}$。\n- $N=1$。单个区段是 $l_1=0, n_1=3, w_1=1$。\n- $Q = \\lceil 12288 / 4096 \\rceil = \\lceil 3 \\rceil = 3$。\n- $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 3) \\cdot 4096 = 12288$。\n- $S = 12288$, $M_{\\text{init}} = 12288$。由于 $S \\not M_{\\text{init}}$，所以 $S_{\\text{rec}} = S = 12288$。\n- $C$：没有未写入的区段 ($w_i=0$)。总和是在一个空集合上进行的，所以 $C = 0$。\n- $O, R$：只有一个区段，没有可检查的对。$O=0, R=0$。\n- 结果：$(0, 12288, 0, 0)$。\n\n**测试用例 2：**\n- 给定：$B = 4096$, $S = 20480$, 区段：$\\{(0, 2, 1)\\}$。\n- $N=1$。单个区段是 $l_1=0, n_1=2, w_1=1$。\n- $Q = \\lceil 20480 / 4096 \\rceil = \\lceil 5 \\rceil = 5$。\n- $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 2) \\cdot 4096 = 8192$。\n- $S = 20480$, $M_{\\text{init}} = 8192$。由于 $S \\ge M_{\\text{init}}$，所以 $S_{\\text{rec}} = S = 20480$。\n- $C$：没有未写入的区段。$C = 0$。\n- $O, R$：没有区段对。$O=0, R=0$。\n- 结果：$(0, 20480, 0, 0)$。\n\n**测试用例 3：**\n- 给定：$B = 4096$, $S = 8192$, 区段：$\\{(0, 3, 1)\\}$。\n- $N=1$。单个区段是 $l_1=0, n_1=3, w_1=1$。\n- $Q = \\lceil 8192 / 4096 \\rceil = \\lceil 2 \\rceil = 2$。\n- $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 3) \\cdot 4096 = 12288$。\n- $S = 8192$, $M_{\\text{init}} = 12288$。由于 $S  M_{\\text{init}}$，所以 $S_{\\text{rec}} = M_{\\text{init}} = 12288$。\n- $C$：没有未写入的区段。$C = 0$。\n- $O, R$：没有区段对。$O=0, R=0$。\n- 结果：$(0, 12288, 0, 0)$。\n\n**测试用例 4：**\n- 给定：$B = 4096$, $S = 4096$, 区段：$e_1=(0, 1, 1)$, $e_2=(1, 4, 0)$。\n- $N=2$。$l_1=0, n_1=1, w_1=1$；$l_2=1, n_2=4, w_2=0$。\n- $Q = \\lceil 4096 / 4096 \\rceil = \\lceil 1 \\rceil = 1$。\n- $M_{\\text{init}}$：只有 $e_1$ 已初始化。$M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 1) \\cdot 4096 = 4096$。\n- $S = 4096$, $M_{\\text{init}} = 4096$。由于 $S \\not M_{\\text{init}}$，所以 $S_{\\text{rec}} = S = 4096$。\n- $C$：只有 $e_2$ 是未写入的。$C = \\max(0, (l_2+n_2) - Q) = \\max(0, (1+4) - 1) = 4$。\n- $O, R$：检查对 $(e_1, e_2)$。区间为 $I_1 = [0, 1)$ 和 $I_2 = [1, 5)$。重叠需要 $\\max(l_1, l_2)  \\min(l_1+n_1, l_2+n_2)$。这里，$\\max(0, 1) = 1$ 且 $\\min(1, 5) = 1$。条件 $1  1$ 为假。没有重叠。$O=0, R=0$。\n- 结果：$(0, 4096, 4, 0)$。\n\n**测试用例 5：**\n- 给定：$B = 4096$, $S = 12288$, 区段：$e_1=(0, 3, 1)$, $e_2=(2, 2, 1)$。\n- $N=2$。$l_1=0, n_1=3, w_1=1$；$l_2=2, n_2=2, w_2=1$。\n- $Q = \\lceil 12288 / 4096 \\rceil = \\lceil 3 \\rceil = 3$。\n- $M_{\\text{init}}$：两个区段都已初始化。末端字节为 $(0+3) \\cdot 4096 = 12288$ 和 $(2+2) \\cdot 4096 = 16384$。$M_{\\text{init}} = \\max(12288, 16384) = 16384$。\n- $S = 12288$, $M_{\\text{init}} = 16384$。由于 $S  M_{\\text{init}}$，所以 $S_{\\text{rec}} = M_{\\text{init}} = 16384$。\n- $C$：没有未写入的区段。$C = 0$。\n- $O, R$：检查对 $(e_1, e_2)$。区间为 $I_1 = [0, 3)$ 和 $I_2 = [2, 4)$。重叠需要 $\\max(l_1, l_2)  \\min(l_1+n_1, l_2+n_2)$。这里，$\\max(0, 2) = 2$ 且 $\\min(3, 4) = 3$。条件 $2  3$ 为真。存在重叠。$O=1$。\n- 由于重叠对的 $w_1=1$ 且 $w_2=1$，所以风险指示器 $R=1$。\n- 结果：$(1, 16384, 0, 1)$。\n\n**测试用例 6：**\n- 给定：$B = 4096$, $S = 0$, 区段：无。\n- $N=0$。\n- $Q = \\lceil 0 / 4096 \\rceil = \\lceil 0 \\rceil = 0$。\n- $M_{\\text{init}}$：已初始化的区段集合为空。根据定义，$M_{\\text{init}} = 0$。\n- $S=0$, $M_{\\text{init}}=0$。由于 $S \\not M_{\\text{init}}$，所以 $S_{\\text{rec}} = S = 0$。\n- $C$：未写入的区段集合为空。$C=0$。\n- $O, R$：没有区段，所以没有对。$O=0, R=0$。\n- 结果：$(0, 0, 0, 0)$。\n\n**测试用例 7：**\n- 给定：$B = 4096$, $S = 4500$, 区段：$e_1=(0, 1, 1)$, $e_2=(1, 1, 0)$。\n- $N=2$。$l_1=0, n_1=1, w_1=1$；$l_2=1, n_2=1, w_2=0$。\n- $Q = \\lceil 4500 / 4096 \\rceil = \\lceil 1.0986... \\rceil = 2$。\n- $M_{\\text{init}}$：只有 $e_1$ 已初始化。$M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 1) \\cdot 4096 = 4096$。\n- $S = 4500$, $M_{\\text{init}} = 4096$。由于 $S \\ge M_{\\text{init}}$，所以 $S_{\\text{rec}} = S = 4500$。\n- $C$：只有 $e_2$ 是未写入的。$C = \\max(0, (l_2+n_2) - Q) = \\max(0, (1+1) - 2) = 0$。\n- $O, R$：检查对 $(e_1, e_2)$。区间为 $I_1=[0, 1)$ 和 $I_2=[1, 2)$。重叠需要 $\\max(l_1, l_2)  \\min(l_1+n_1, l_2+n_2)$。这里，$\\max(0, 1) = 1$ 且 $\\min(1, 2) = 1$。条件 $1  1$ 为假。没有重叠。$O=0, R=0$。\n- 结果：$(0, 4500, 0, 0)$。", "answer": "```c\n#include", "id": "3643409"}, {"introduction": "当不同实体对同一资源提出冲突性声明时，最具挑战性的不一致问题便出现了。这个思想实验将您置于 `fsck` 设计者的角色，面对一个经典难题：两个文件同时声明拥有同一个数据块。通过评估不同的修复策略，您将深入理解文件系统修复的核心原则，例如在强制执行唯一所有权的同时最大限度地保全数据。[@problem_id:3643420]", "problem": "考虑一个基于 extent 的文件系统，其块大小固定为 $b$ 字节，其 inode 中的 extent 映射表记录了连续物理块的范围。在一次崩溃后，文件系统一致性检查 (fsck) 工具发现两个普通文件 $F_1$ 和 $F_2$ 都在其最后的 extent 中声明拥有同一个物理块 $B$，这是由于一个 extent 舍入错误，该错误将每个文件的逻辑末尾字节向上舍入到了一个完整的块。磁盘上的元数据显示，分配位图将 $B$ 标记为已分配，并且两个文件的 inode 都在其最后的 extent 中列出了块 $B$。目录项完好无损，并且记录的文件大小 $s_1$ 和 $s_2$ 满足 $0  s_1 \\bmod b  b$ 和 $0  s_2 \\bmod b  b$。假设在崩溃之前，文件系统的“唯一的块所有权”和“一致的分配元数据”这两个不变量是成立的，并且系统中有可用的空闲空间。\n\n根据基本原则，fsck 必须恢复一个结构良好的文件系统的核心不变量：(i) 每个物理数据块最多只有一个所有者 inode，(ii) 分配位图与 inode 的 extent 声明一致，(iii) 可达的目录项保持一致，以及 (iv) 在不引入原始设计中没有的新语义的前提下，尽可能地保留数据。特别是，fsck 不能为数据块创造新的共享语义（除非文件系统本身支持），并且如果文件系统的块粒度为 $b$，它就不能将单个块物理地分割成更小的可分配单元。\n\n在纠正对块 $B$ 的重复声明错误的同时，哪项操作与这些不变量最一致，并能最大限度地减少数据丢失？\n\nA. 将块 $B$ 只分配给一个 inode（以确定性的方式，例如通过 inode 编号排序），从另一个文件的 extent 中移除 $B$，并将该文件截断到 $B$ 之前的最后一个块。如果需要为被截断的文件抢救尾部内容，则从空闲空间中分配一个新块 $B'$，并将 $B$ 中相应的 $s_i \\bmod b$ 字节复制到 $B'$ 中；如果归属不明确，则将恢复的片段作为一个单独的文件链接到“lost+found”目录下，并更新分配位图以反映唯一的所有权。\n\nB. 让两个文件继续声明拥有块 $B$，在元数据中将 $B$ 标记为“共享”，并依赖于这样一个事实：对每个文件而言，只有 $B$ 的前 $s_i \\bmod b$ 字节是逻辑上可见的，从而在保持两个文件完整的同时避免了数据冲突。\n\nC. 将块 $B$ 清零以移除冲突数据，将 $B$ 保留在两个文件的 extent 列表中以使其大小保持不变，并将 $B$ 标记为已分配；这确保了两个文件都有一致的内容（全为零），并且分配位图保持一致。\n\nD. 将其中一个文件完全删除，在分配位图中将其所有块（包括 $B$）标记为空闲，并保持另一个文件的 extent 映射表不变；这保证了 $B$ 的唯一所有权，但可能导致本可避免的重大数据丢失。\n\nE. 将块 $B$ 分割成两个大小为 $b/2$ 的逻辑半块，将一半分配给 $F_1$，另一半分配给 $F_2$，并更新分配位图以跟踪半块的所有权，从而在不分配新块的情况下保留两个文件的尾部数据。\n\n选择唯一的最佳选项。", "solution": "用户提供了一个关于在基于 extent 的文件系统中进行文件系统一致性检查 (fsck) 的问题。任务是确定当 fsck 发现两个文件 $F_1$ 和 $F_2$ 错误地声明拥有同一个物理数据块 $B$ 时，应采取的最适当的操作。\n\n### 步骤 1：问题验证\n\n我将首先提取给定条件，并根据所需标准验证问题陈述。\n\n**提取的给定条件：**\n\n*   **文件系统类型：** 基于 extent，固定块大小为 $b$ 字节。\n*   **不一致性：** 两个普通文件 $F_1$ 和 $F_2$ 都在其最后的 extent 中声明拥有同一个物理块 $B$。\n*   **元数据状态：**\n    *   分配位图将块 $B$ 标记为已分配。\n    *   $F_1$ 和 $F_2$ 的 inode 都在其最后的 extent 中列出了块 $B$。\n    *   目录项完好无损。\n*   **文件大小：** 记录的文件大小 $s_1$ 和 $s_2$ 满足 $0  s_1 \\bmod b  b$ 和 $0  s_2 \\bmod b  b$。这证实了两个文件都在块 $B$ 中包含数据，但两个文件的逻辑结尾都与块边界不重合。\n*   **假设：**\n    *   文件系统在崩溃前是一致的（唯一的块所有权，一致的位图）。\n    *   有可用的空闲空间。\n*   **fsck 的指导原则：**\n    *   (i) **唯一所有权：** 每个物理数据块最多只有一个所有者 inode。\n    *   (ii) **位图一致性：** 分配位图必须与 inode 的 extent 声明一致。\n    *   (iii) **目录一致性：** 可达的目录项必须保持一致。\n    *   (iv) **数据保留：** 应尽可能保留数据。\n*   **对 fsck 的明确约束：**\n    *   fsck 不能引入文件系统最初不支持的新语义（例如，块共享）。\n    *   fsck 不能改变基本的块粒度（即，它不能分割块 $B$）。\n\n**验证结论：**\n\n问题陈述是**有效的**。\n*   **科学依据充分：** 该场景是现实世界文件系统在崩溃后可能发生的元数据不一致的典型例子。inode、extent、分配位图以及 fsck 的原则是操作系统和文件系统设计的基础概念。\n*   **问题定义良好：** 问题清晰地定义了初始的不一致状态，并提供了一套明确、定义良好的规则和目标（恢复不变量，最小化数据丢失），解决方案必须依据这些进行评判。\n*   **客观性：** 语言是技术性的，没有歧义或主观性陈述。\n\n该问题结构良好，可以通过应用所述的文件系统一致性基本原则来解决。\n\n### 步骤 2：推导正确的操作\n\n核心的不一致性是违反了原则 (i)：块 $B$ 被两个 inode（$F_1$ 和 $F_2$）声明拥有，这违反了唯一所有权不变量。任何正确的解决方案都必须解决这个冲突。\n\n1.  **恢复唯一所有权：** 主要任务是最多将块 $B$ 分配给一个所有者。由于两个文件都提出了声明，并且分配位图显示 $B$ 已被分配，因此将 $B$ 置为空闲而不分配给任何文件，会导致两个文件都丢失数据。因此，fsck 必须选择一个“胜利者”。假设通过一个确定性规则（例如，按 inode 编号排序），选择 $F_1$ 保留块 $B$ 的所有权。\n\n2.  **处理“失败”的文件：** 因此，文件 $F_2$ 必须放弃对块 $B$ 的声明。这需要对 $F_2$ 的元数据进行两项修改：\n    *   必须更新 $F_2$ 的 inode 中的 extent 映射表以移除对块 $B$ 的引用。\n    *   文件大小 $s_2$ 必须被截断到它所拥有的最后一个有效块的末尾（即紧邻 $B$ 之前的那个块）。\n\n3.  **保留数据：** $F_2$ 的截断意味着其位于块 $B$ 中的 $s_2 \\bmod b$ 字节数据现在成了孤立数据。原则 (iv)，即数据保留，要求尽可能保存这些数据。在这种情况下，一个标准的 fsck 程序是：\n    *   分配一个新的、之前空闲的块，我们称之为 $B'$。这是可能的，因为问题陈述中提到有可用空闲空间。\n    *   将孤立的数据片段（块 $B$ 的前 $s_2 \\bmod b$ 字节）复制到 $B'$ 的开头。\n    *   创建一个新的 inode 来表示这些被抢救的数据。这个新 inode 的 extent 映射表将指向 $B'$，其大小将是 $s_2 \\bmod b$。\n    *   将这个新 inode 链接到文件系统中一个指定的位置，用于存放恢复的片段，这个位置通常是 `lost+found` 目录。\n\n4.  **确保最终一致性：** 完成这些步骤后：\n    *   **唯一所有权：** 块 $B$ 仅由 $F_1$ 拥有。新块 $B'$ 仅由新的 `lost+found` 文件拥有。不变量 (i) 得以恢复。\n    *   **位图一致性：** 必须更新分配位图。$B$ 保持已分配状态。$B'$ 现在被标记为已分配。不变量 (ii) 得以满足。\n    *   **目录一致性：** `lost+found` 目录被更新，这是一个一致的操作。不变量 (iii) 得以维持。\n    *   **数据保留：** $F_1$ 的数据被完全保留。$F_2$ 的数据也被保留，尽管与其原始文件断开了连接。这代表了在约束条件下可能的数据丢失/语义变化的最小值。\n    *   **无新语义：** 此过程仅使用现有的文件系统操作（分配块、写入块、创建 inode、创建目录项），并未创造块共享或子块分配等新机制。\n\n这个推导出的过程提供了一个完整且一致的解决方案，它遵守了所有陈述的原则。\n\n### 步骤 3：评估提供的选项\n\n**A. 将块 $B$ 只分配给一个 inode（以确定性的方式，例如通过 inode 编号排序），从另一个文件的 extent 中移除 $B$，并将该文件截断到 $B$ 之前的最后一个块。如果需要为被截断的文件抢救尾部内容，则从空闲空间中分配一个新块 $B'$，并将 $B$ 中相应的 $s_i \\bmod b$ 字节复制到 $B'$ 中；如果归属不明确，则将恢复的片段作为一个单独的文件链接到“lost+found”目录下，并更新分配位图以反映唯一的所有权。**\n*   **分析：** 该选项精确地描述了从基本原则推导出的过程。它恢复了唯一所有权，正确处理了被截断的文件，并采用标准的 `lost+found` 机制来保留孤立数据，从而最大限度地减少了数据丢失。它明确提到了更新分配位图。它遵守了所有约束。\n*   **结论：** **正确**。\n\n**B. 让两个文件继续声明拥有块 $B$，在元数据中将 $B$ 标记为“共享”，并依赖于这样一个事实：对每个文件而言，只有 $B$ 的前 $s_i \\bmod b$ 字节是逻辑上可见的，从而在保持两个文件完整的同时避免了数据冲突。**\n*   **分析：** 这个选项在两个关键点上失败了。首先，它没有解决违反唯一所有权（不变量 i）的问题，因为两个文件将继续声明拥有块 $B$。其次，它提议为块创建一个“共享”状态，这明确违反了 fsck 不能创造文件系统不支持的新语义的约束。\n*   **结论：** **不正确**。\n\n**C. 将块 $B$ 清零以移除冲突数据，将 $B$ 保留在两个文件的 extent 列表中以使其大小保持不变，并将 $B$ 标记为已分配；这确保了两个文件都有一致的内容（全为零），并且分配位图保持一致。**\n*   **分析：** 这个选项存在根本性缺陷。它没有修复唯一所有权的违规（不变量 i），因为它将 $B$ 留在了两个文件的 extent 中。更糟糕的是，它通过“清零”块的方式，以最具破坏性的方式违反了数据保留原则（不变量 iv），导致*两个*文件都明确地丢失数据，而其中至少一个文件的数据本可以被完美保留。\n*   **结论：** **不正确**。\n\n**D. 将其中一个文件完全删除，在分配位图中将其所有块（包括 $B$）标记为空闲，并保持另一个文件的 extent 映射表不变；这保证了 $B$ 的唯一所有权，但可能导致本可避免的重大数据丢失。**\n*   **分析：** 虽然这个选项确实成功地恢复了块 $B$ 的唯一所有权，但它是通过造成最大的、不必要的损害来实现的。当只有一个块存在争议时，它通过删除整个文件的方式违反了最小化数据丢失的原则（不变量 iv）。如选项 A 所示，这个问题可以用远少得多的数据丢失来解决。\n*   **结论：** **不正确**。\n\n**E. 将块 $B$ 分割成两个大小为 $b/2$ 的逻辑半块，将一半分配给 $F_1$，另一半分配给 $F_2$，并更新分配位图以跟踪半块的所有权，从而在不分配新块的情况下保留两个文件的尾部数据。**\n*   **分析：** 这个选项直接违反了 fsck “如果文件系统的块粒度为 $b$，则不能将单个块物理地分割成更小的可分配单元”的明确约束。这将需要对文件系统的分配逻辑进行根本性的改变，这超出了一个一致性检查器的范围和权限。\n*   **结论：** **不正确**。", "answer": "$$\\boxed{A}$$", "id": "3643420"}]}