{"hands_on_practices": [{"introduction": "文件系统的核心功能之一是管理元数据，它描述了文件的属性和数据位置。本练习旨在探讨两种经典的元数据组织设计：固定索引节点（inode）分配和动态分配。通过从第一性原理出发，计算这两种设计下可创建的最大文件数，你将能够量化分析它们在空间利用效率和灵活性上的根本权衡。这个练习有助于你深入理解文件系统设计中关于资源预留与按需分配的策略选择。[@problem_id:3642840]", "problem": "一个存储栈在总大小为 $P$ 字节的单个分区内，于文件组织层实现了两种截然不同的磁盘元数据设计。这可以通过经典的分层模型来理解，其中逻辑文件层使用索引节点 (inode) 来命名和定位文件数据，而目录层则存储将名称绑定到 inode 标识符的目录项。请考虑以下两种设计。\n\n固定 inode 设计。文件系统 (FS) 预分配一个大小为 $I$ 字节的磁盘 inode 表。每个索引节点 (inode) 占用 $i_s$ 字节。其中有 $r$ 个 inode 因被系统对象和根目录保留而永久对用户不可用；其余的 inode（若有）可用于用户创建的普通文件。非 inode 的固定开销（例如，超级块、日志结构和分配位图），不包括 inode 表本身，占用 $F_f$ 字节，并且不随用户文件数量的增加而变化。每个用户创建的普通文件都必须出现在一个目录中；目录层为每个文件存储 $d$ 字节的目录项负载，这些目录项字节与普通文件内容一样，被放置在同一个通用数据区域中。您可以假设，为了最大化不同文件的数量，创建的文件大小为 0 字节，这样除了目录项外不会消耗任何数据块，并且根目录和其他系统对象已在 $r$ 个保留 inode 和 $F_f$ 字节中被计入。\n\n动态 inode 设计。文件系统不预分配固定大小的 inode 表。相反，inode 是根据需要从通用空闲空间区域中划分出来的。每个用户创建的 inode 仍然存储 $i_s$ 字节的 inode 状态，并额外产生一个与用户 inode 数量线性相关的、大小为 $a$ 字节的均摊分配记账成本。此设计的非 inode 固定开销（包括任何预创建的系统对象，如根目录及其元数据）占用 $F_d$ 字节，并且不随用户文件数量的增加而变化。每个文件的目录项成本仍为 $d$ 字节，存储在同一个通用空闲空间区域中。同上，假设所有用户文件的大小均为 0 字节。\n\n请从文件层和目录层的第一性原理出发，不使用任何预设公式，推导出在每种设计下可创建的不同用户普通文件最大数量的最紧可能上界，并需与所述模型一致。然后，定义乘性改进因子 $\\gamma$ 为动态 inode 设计上界与固定 inode 设计上界之比，在需要时仅使用代数运算符以及标准的向下取整和最小值运算符来体现离散性和共享空间耦合。请将您的最终答案表示为关于 $P$, $I$, $i_s$, $r$, $F_f$, $F_d$, $a$ 和 $d$ 的单个闭式解析表达式 $\\gamma$。最终表达式中不要说明单位。假设所有使用的分母非零且边界为正。", "solution": "该问题要求为两种不同的磁盘元数据设计推导出用户可创建文件数量的最紧可能上界，然后计算这些上界的比率。让我们从第一性原理出发，对每种设计进行分析。设 $N$ 表示不同用户普通文件的数量。分析假设创建的文件大小为 0 字节，以通过最小化数据块消耗来最大化文件数量，从而将分析重点放在元数据开销上。\n\n首先，我们分析**固定 inode 设计**。\n在此设计中，有两个主要资源限制了文件数量：预分配 inode 的有限数量和用于目录项的有限空间。文件的最大数量，我们称之为 $N_{fixed}$，将是这两个约束所施加的边界中的最小值。\n\n1.  **Inode 约束**：预分配 inode 表的总大小为 $I$ 字节，每个 inode 占用 $i_s$ 字节。该表中可以存储的 inode 总数是这两个大小之比的整数部分，即 $\\lfloor \\frac{I}{i_s} \\rfloor$。问题指出，其中有 $r$ 个 inode 为系统使用而保留。因此，可用于用户文件的最大 inode 数是 inode 总数减去保留数量。这对 $N_{fixed}$ 施加了一个上界：\n    $$ N_{fixed} \\le \\left\\lfloor \\frac{I}{i_s} \\right\\rfloor - r $$\n\n2.  **空间约束**：分区总大小为 $P$ 字节。固定开销所消耗的空间包括 inode 表本身（$I$ 字节）和其他非 inode 结构（$F_f$ 字节）。剩余空间构成了通用数据区域，可用于存储文件内容和目录项。该区域的大小为 $P - I - F_f$。根据模型， $N_{fixed}$ 个用户文件中的每一个都需要 $d$ 字节用于其目录项，这些目录项存储在此数据区域中。由于我们假设用户文件大小为 0，这些目录项消耗的总空间为 $N_{fixed} \\cdot d$。这个消耗不能超过数据区域中的可用空间。\n    $$ N_{fixed} \\cdot d \\le P - I - F_f $$\n    通过除以 $d$ 并向下取整，可得出 $N_{fixed}$ 的第二个上界，因为文件数量不能为非整数：\n    $$ N_{fixed} \\le \\left\\lfloor \\frac{P - I - F_f}{d} \\right\\rfloor $$\n\n用户文件的数量 $N_{fixed}$ 必须同时满足这两个约束。因此，最紧可能上界是这两个限制中最严格的一个。这可以用最小值运算符表示：\n$$ N_{fixed} = \\min\\left( \\left\\lfloor \\frac{I}{i_s} \\right\\rfloor - r, \\left\\lfloor \\frac{P - I - F_f}{d} \\right\\rfloor \\right) $$\n\n接下来，我们分析**动态 inode 设计**。\n在此设计中，没有预分配的 inode 表。相反，inode 和目录项都从一个单一的通用空闲空间区域中分配。这意味着只有一个主要资源约束：总可用空间。设 $N_{dynamic}$ 为此设计中用户文件的最大数量。\n\n1.  **空间约束**：分区总大小为 $P$ 字节。非 inode 固定开销占用 $F_d$ 字节。剩余空间 $P - F_d$ 是通用空闲空间区域，所有每个文件的元数据都从该区域分配。每创建一个用户文件，都会从此空间池中消耗一定量的空间。每个文件的成本包括：\n    - inode 本身：$i_s$ 字节。\n    - inode 的均摊分配记账成本：$a$ 字节。\n    - 目录项：$d$ 字节。\n    - 文件数据大小为 0 字节。\n    每个用户文件消耗的总空间为 $i_s + a + d$ 字节。对于 $N_{dynamic}$ 个文件，消耗的总空间为 $N_{dynamic} \\cdot (i_s + a + d)$。此总空间不能超过可用的空闲空间。\n    $$ N_{dynamic} \\cdot (i_s + a + d) \\le P - F_d $$\n    对 $N_{dynamic}$ 求解并向下取整以确保文件数量为整数，得出最紧上界：\n    $$ N_{dynamic} = \\left\\lfloor \\frac{P - F_d}{i_s + a + d} \\right\\rfloor $$\n\n最后，我们将乘性改进因子 $\\gamma$ 定义为动态 inode 设计上界与固定 inode 设计上界之比。\n$$ \\gamma = \\frac{N_{dynamic}}{N_{fixed}} $$\n代入推导出的 $N_{dynamic}$ 和 $N_{fixed}$ 的表达式，得到 $\\gamma$ 的最终闭式表达式。\n$$ \\gamma = \\frac{\\left\\lfloor \\frac{P - F_d}{i_s + a + d} \\right\\rfloor}{\\min\\left( \\left\\lfloor \\frac{I}{i_s} \\right\\rfloor - r, \\left\\lfloor \\frac{P - I - F_f}{d} \\right\\rfloor \\right)} $$\n此表达式仅使用给定的参数以及允许的代数、向下取整和最小值运算符构成，满足问题陈述的所有条件。分母非零和边界为正的假设确保了此表达式是良定义的。", "answer": "$$\n\\boxed{\\frac{\\left\\lfloor \\frac{P - F_d}{i_s + a + d} \\right\\rfloor}{\\min\\left( \\left\\lfloor \\frac{I}{i_s} \\right\\rfloor - r, \\left\\lfloor \\frac{P - I - F_f}{d} \\right\\rfloor \\right)}}\n$$", "id": "3642840"}, {"introduction": "在文件系统找到一个文件的元数据（例如其inode）之后，下一步是定位其在磁盘上的实际数据块。本练习将对比两种截然不同的文件映射组织方式：文件分配表（FAT）所使用的链式结构和基于区段（extent）的连续映射。通过推导访问一个随机数据块的期望时间，并考虑缓存命中率的影响，你将能够分析这两种策略在随机访问性能上的差异，从而揭示数据结构选择对I/O效率的深远影响。[@problem_id:3642743]", "problem": "一个操作系统的文件子系统使用分层结构，其中文件映射层在存储层发出输入/输出操作之前，将文件的逻辑块索引转换为磁盘上的位置。考虑一个文件的两种可选映射组织方式：文件分配表 (FAT) 和基于区段的映射。在文件分配表 (FAT) 组织方式中，一个文件是簇的单向链表，目录项存储起始簇号。设每个簇包含 $C$ 个逻辑块。对文件内逻辑块索引 $b \\in \\mathbb{Z}_{\\ge 0}$ 的一次随机访问需要从起始簇开始遍历 FAT 链，直到包含块 $b$ 的那个簇。假设映射层和存储层的成本模型如下：\n\n- 访问一个已在内存缓存中的 FAT 条目需要 $t_{H}$ 个时间单位。\n- 访问一个不在缓存中的 FAT 条目需要 $t_{F}$ 个时间单位（从存储器读取到内存中）。\n- 在遍历过程中，对于每个所需的 FAT 条目，其位于缓存中的概率为 $p \\in [0,1]$，且各条目是否在缓存中是相互独立的。\n- 映射完成后，从存储设备读取目标数据块的成本为 $t_{B}$ 个时间单位。\n- 目录项的起始簇号假定在内存中已知，成本为 $0$。\n- 在基于区段的组织方式中，映射层执行一次成本为 $t_{E}$ 时间单位的 $O(1)$ 区段查找，然后存储层以相同的成本 $t_{B}$ 时间单位读取目标数据块。\n\n从文件分配表 (FAT) 链遍历如何计算包含给定逻辑块的簇的基本定义以及独立缓存命中事件的期望线性性质出发，推导在 FAT 组织方式中对逻辑块 $b$ 执行随机访问的期望总时间与在基于区段的组织方式中总时间的比率 $R(b)$ 的闭式表达式。将你的最终答案表示为关于 $b$、$C$、$p$、$t_{H}$、$t_{F}$、$t_{B}$ 和 $t_{E}$ 的单一简化解析表达式。不需要进行数值计算。最终答案必须是单一表达式；除了所要求的表达式外，不要提供不等式或方程。如果你选择呈现任何中间量，它们不能出现在最终答案中。最终答案中不要包含单位。", "solution": "问题要求推导在文件分配表 (FAT) 组织方式中对逻辑块 $b$ 进行随机访问的期望总时间与在基于区段的组织方式中进行相同访问的总时间的比率 $R(b)$ 的闭式表达式。我们的方法是首先确定基于区段的情况下的总时间表达式，然后推导基于 FAT 的情况下的期望总时间，最后计算它们的比率。\n\n首先，我们分析基于区段的组织方式中一次访问的总时间。问题陈述，映射层执行一次成本为 $t_{E}$ 时间单位的区段查找，该操作被描述为 $O(1)$ 操作。之后，存储层读取目标数据块，产生 $t_{B}$ 时间单位的成本。这两个操作是顺序执行的。因此，在基于区段的组织方式中一次访问的总时间，我们表示为 $T_{\\text{extent}}$，是这些成本的总和：\n$$T_{\\text{extent}} = t_{E} + t_{B}$$\n这个时间是确定性的。\n\n接下来，我们分析在 FAT 组织方式中一次访问的期望总时间。对索引为 $b \\in \\mathbb{Z}_{\\ge 0}$ 的逻辑块的访问包括两个主要步骤：首先，映射层必须通过遍历 FAT 链将逻辑块索引转换为物理磁盘位置；其次，存储层读取实际的数据块。\n\n文件的逻辑块被分组成簇，每个簇包含 $C$ 个逻辑块。块从 $0$ 开始索引。因此，文件的簇 $0$ 包含逻辑块 $0, 1, \\dots, C-1$。簇 $1$ 包含逻辑块 $C, C+1, \\dots, 2C-1$。通常，文件相对簇 $k$ 包含索引从 $kC$ 到 $(k+1)C-1$ 的逻辑块。要找到包含逻辑块 $b$ 的文件相对簇索引 $k$，我们必须找到整数 $k$ 使得 $kC \\le b  (k+1)C$。两边除以 $C$ 得到 $k \\le \\frac{b}{C}  k+1$。这意味着 $k$ 是 $\\frac{b}{C}$ 的整数部分，由向下取整函数给出：\n$$k = \\left\\lfloor \\frac{b}{C} \\right\\rfloor$$\n在 FAT 组织方式中，一个文件是簇的单向链表。目录项包含第一个簇（文件序列中的簇 0）的地址，假定该地址在内存中已知，成本为零。为了找到索引为 $k$ 的目标簇的位置，文件系统必须从第一个簇开始遍历该链表。这需要对 FAT 进行 $k$ 次顺序查找。例如，要找到第二个簇（索引为 1），必须读取对应于第一个簇（索引为 0）的 FAT 条目。要找到第三个簇（索引为 2），必须读取第二个簇的 FAT 条目，依此类推。因此，要到达索引为 $k = \\lfloor \\frac{b}{C} \\rfloor$ 的簇，总共需要进行 $N = \\lfloor \\frac{b}{C} \\rfloor$ 次 FAT 条目访问。\n\n设 $X_i$ 为表示遍历链中第 $i$ 次 FAT 访问成本的随机变量，其中 $i \\in \\{1, 2, \\dots, N\\}$。每次访问的成本取决于相应的 FAT 条目是否在内存缓存中。\n- 如果条目在缓存中（“命中”），成本为 $t_H$。这种情况发生的概率为 $p$。\n- 如果条目不在缓存中（“未命中”），成本为 $t_F$。这种情况发生的概率为 $1-p$。\n\n单次 FAT 访问的期望成本 $E[X_i]$ 是这两种结果的加权平均值：\n$$E[X_i] = p \\cdot t_{H} + (1-p) \\cdot t_{F}$$\n问题陈述，对于每个所需的 FAT 条目，缓存命中/未命中事件是独立的。因此，对于所有 $i=1, \\dots, N$，期望成本 $E[X_i]$ 都是相同的。我们用 $E[X_{\\text{access}}]$ 表示这个公共的期望成本。\n\n映射层遍历的总时间是 $N$ 次单独访问成本的总和，$T_{\\text{mapping-FAT}} = \\sum_{i=1}^{N} X_i$。根据期望的线性性质，期望总映射时间是每次访问的期望成本之和：\n$$E[T_{\\text{mapping-FAT}}] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i]$$\n由于对于所有 $i$，$E[X_i]$ 是常数，且 $N = \\lfloor \\frac{b}{C} \\rfloor$，这可以简化为：\n$$E[T_{\\text{mapping-FAT}}] = N \\cdot E[X_{\\text{access}}] = \\left\\lfloor \\frac{b}{C} \\right\\rfloor (p t_{H} + (1-p) t_{F})$$\n在映射层确定数据块的物理位置后，存储层执行读取操作，其成本是恒定的 $t_B$。基于 FAT 访问的总期望时间 $E[T_{\\text{FAT}}(b)]$ 是期望映射时间与块读取时间之和：\n$$E[T_{\\text{FAT}}(b)] = E[T_{\\text{mapping-FAT}}] + t_{B} = \\left\\lfloor \\frac{b}{C} \\right\\rfloor (p t_{H} + (1-p) t_{F}) + t_{B}$$\n\n最后，我们可以计算 FAT 组织方式的期望总时间与基于区段的组织方式的总时间的比率 $R(b)$：\n$$R(b) = \\frac{E[T_{\\text{FAT}}(b)]}{T_{\\text{extent}}}$$\n将推导出的分子和分母的表达式代入，我们得到最终的闭式表达式：\n$$R(b) = \\frac{\\left\\lfloor \\frac{b}{C} \\right\\rfloor (p t_{H} + (1-p) t_{F}) + t_{B}}{t_{E} + t_{B}}$$\n该表达式是简化的，并且只包含问题陈述中指定的变量。", "answer": "$$\\boxed{\\frac{\\left\\lfloor \\frac{b}{C} \\right\\rfloor \\left(p t_{H} + (1-p) t_{F}\\right) + t_{B}}{t_{E} + t_{B}}}$$", "id": "3642743"}, {"introduction": "文件系统的层次结构不仅体现在磁盘上，更体现在操作系统如何解释路径名以定位文件。本练习将带你进入虚拟文件系统（VFS）的路径解析层面，这是一个充满精妙规则和重要安全考量的领域。通过分析在`chroot`沙箱环境下，不同系统调用序列如何影响`\"a/../b\"`这类相对路径的解析结果，你将亲身体验路径解析规则的严谨性，并理解为何这些规则对于构建安全可靠的容器和隔离环境至关重要。[@problem_id:3642749]", "problem": "考虑一个在遵循可移植操作系统接口（POSIX）的类 Unix 系统上的进程。设该进程的初始当前工作目录 $cwd$ 等于 $\"/etc\"$，其根目录 $root$ 等于 $\"/\"$。该进程稍后在绝对路径 $\"/srv/sandbox\"$ 处创建了一个用作沙箱的目录，其中包含条目 $\"a\"$（一个目录）和 $\"b\"$（一个普通文件）。为贴近实际，假设在初始的 $cwd$ $\"/etc\"$ 下，也存在名为 $\"a\"$（一个目录）和 $\"b\"$（一个普通文件）的条目。该进程可以调用更改根目录操作 $\\mathrm{chroot}$ 来设置其新的 $root$，也可以调用更改目录操作 $\\mathrm{chdir}$ 或 $\\mathrm{fchdir}$ 来设置其 $cwd$。$openat$ 系统调用解析路径名时，可以相对于一个提供的目录文件描述符，或者如果传递了特殊常量 $AT\\_FDCWD$，则相对于进程的 $cwd$。假设没有挂载命名空间或绑定挂载来改变可见性，并忽略权限错误。\n\n仅使用以下关于路径解析的广泛接受的基本事实：在 POSIX 下，相对路径从 $cwd$ 开始解析，绝对路径从 $root$ 开始解析；组件 $\".\"$ 和 $\"..\"$ 在路径解析时进行解释，因此 $x/..\"$ 指的是在任何符号链接解析后 $x$ 实际表示的目录的父目录；$\\mathrm{chroot}$ 设置 $root$ 但不改变 $cwd$；当设置了 $root$ 后，路径遍历在解析期间不能通过 $\"..\"$ 上升到 $root$ 之上，但解析过程不会将一个在 $root$ 之外的 $cwd$ 追溯性地重新定位到 $root$ 之内。\n\n该进程希望使用 $openat$ 打开路径名 $\"a/../b\"$。以下哪个选项正确地陈述了保证所打开的路径被限制在沙箱 $\"/srv/sandbox\"$ 的子树下的条件（即，最终解析的路径不能命名 $\"/srv/sandbox\"$ 之外的任何东西）？选择所有适用的选项。\n\nA. 调用 $\\mathrm{chroot}(\"/srv/sandbox\")$，然后不改变 $cwd$ 直接调用 $openat(AT\\_FDCWD, \"a/../b\", O\\_RDONLY)$。限制能够得到保证，因为 $\"..\"$ 无法逃离新的 $root$。\n\nB. 调用 $\\mathrm{chroot}(\"/srv/sandbox\")$ 紧接着调用 $\\mathrm{chdir}(\"/\")`，然后调用 $openat(AT\\_FDCWD, \"a/../b\", O\\_RDONLY)$。限制能够得到保证。\n\nC. 不使用 $AT\\_FDCWD$，而是打开一个指向 $\"/srv/sandbox\"$ 的目录文件描述符 $d\\_root$（例如，通过 $d\\_root = open(\"/srv/sandbox\", O\\_PATH | O\\_DIRECTORY)$），然后调用 $openat(d\\_root, \"a/../b\", O\\_RDONLY)$。无论 $cwd$ 如何，限制都能得到保证。\n\nD. 调用 $\\mathrm{chroot}(\"/srv/sandbox\")$ 紧接着调用 $\\mathrm{chdir}(\"/\")`，但假设在沙箱内部 $\"a\"$ 是一个指向 $\"/\"$ 的符号链接。那么 $openat(AT\\_FDCWD, \"a/../b\", O\\_RDONLY)$ 可以解析到沙箱外部，因此限制无法得到保证。\n\nE. 调用 $\\mathrm{chroot}(\"/srv/sandbox\")$，同时保持一个预先存在的指向 $\"/etc\"$ 的目录文件描述符为打开状态，然后在调用 $openat(AT\\_FDCWD, \"a/../b\", O\\_RDONLY)$ 之前使用 $\\mathrm{fchdir}$ 将 $cwd$ 设置为该目录。限制仍然能够得到保证，因为 $root$ 屏障阻止了通过 $\"..\"$ 的逃逸。", "solution": "该问题陈述是计算系统理论中的一个定义明确的练习，具体涉及遵循 POSIX 标准的操作系统中文件系统路径解析的语义学。它提供了一个清晰的初始状态、一组已定义的操作，以及一系列控制系统行为的明确规则。这些规则与类 Unix 系统的既定行为一致。该问题具有科学依据、提法恰当、客观，并且不表现出任何逻辑矛盾或事实上的不健全。因此，它适合进行分析。\n\n核心任务是确定哪些情景能保证解析相对路径 `\"a/../b\"` 的结果是一个被限制在 `\"/srv/sandbox\"` 目录子树内的文件路径。从一个起始目录（我们称之为 $D_{start}$）解析路径 `\"a/../b\"` 的过程可以简化。组件 `\"a\"` 指向子目录 $D_{start}\\text{/a}$。接着组件 `\"../\"` 指向 $D_{start}\\text{/a}$ 的父目录，也就是 $D_{start}$ 本身（假设 `\"a\"` 是一个简单的目录而不是会使解析复杂化的符号链接，我们将在后面单独处理这种情况）。最后，组件 `\"b\"` 在 $D_{start}$ 内解析，得到路径 $D_{start}\\text{/b}$。因此，路径 `\"a/../b\"` 实际上等同于从起始目录解析的 `\"b\"`。\n\n因此，当且仅当路径解析的起始目录 $D_{start}$ 是 `\"/srv/sandbox\"` 本身或其子目录之一时，才能保证路径被限制在 `\"/srv/sandbox\"` 子树内。所讨论的系统调用是 $\\mathrm{openat}$，其起始目录由它的第一个参数决定。\n\n让我们基于这些原则和提供的基本事实来评估每个选项。初始状态为 $root = \\text{\"/\"}$ and $cwd = \\text{\"/etc\"}$。\n\n**选项 A 评估**\n1.  进程调用 $\\mathrm{chroot}(\"/srv/sandbox\")$。根据提供的规则，这将进程的 $root$ 目录设置为 `\"/srv/sandbox\"`。关键在于，此操作“不改变 $cwd$”。\n2.  $cwd$ 仍然是对 `\"/etc\"` 目录的引用。规则“解析过程不会将一个在 $root$ 之外的 $cwd$ 追溯性地重新定位到 $root$ 之内”证实了进程的 $cwd$ 仍然是全局文件系统中位于 `\"/etc\"` 的目录，它在新 $root$ 监牢之外。\n3.  进程随后调用 $\\mathrm{openat}(AT\\_FDCWD, \"a/../b\", O\\_RDONLY)$。特殊常量 $AT\\_FDCWD$ 指示系统调用相对于当前工作目录 $cwd$ 解析路径。\n4.  由于 $cwd$ 是 `\"/etc\"`，路径解析从那里开始。它将 `\"a/../b\"` 解析为 `\"/etc/b\"`。\n5.  最终路径 `\"/etc/b\"` 不在 `\"/srv/sandbox\"` 子树内。限制未能实现。\n6.  选项中给出的理由，“因为 `..` 无法逃离新的 $root$”，是错误的。路径解析完全在新 $root$ 之外开始并保持在该范围外，因此对 `\"..\"` 的遍历限制从未被触发。\n\n所述条件不能保证限制。\n结论：**错误**。\n\n**选项 B 评估**\n1.  进程调用 $\\mathrm{chroot}(\"/srv/sandbox\")$，将其 $root$ 设置为 `\"/srv/sandbox\"`。和之前一样，$cwd$ 仍然是 `\"/etc\"`。\n2.  进程随后调用 $\\mathrm{chdir}(\"/\")`。根据规则“绝对路径从 $root$ 开始解析”，路径 `\"/\"` 是相对于进程的新 $root$ 目录 `\"/srv/sandbox\"` 解析的。因此，$\\mathrm{chdir}(\"/\")` 成功地将 $cwd$ 更改为 `\"/srv/sandbox\"`。\n3.  进程现在的状态是 $root = \\text{\"/srv/sandbox\"}$ 和 $cwd = \\text{\"/srv/sandbox\"}$。\n4.  调用 $\\mathrm{openat}(AT\\_FDCWD, \"a/../b\", O\\_RDONLY)$ 从 $cwd$ 开始解析路径，即 `\"/srv/sandbox\"`。\n5.  从 `\"/srv/sandbox\"` 解析 `\"a/../b\"` 的过程如下：找到 `\"/srv/sandbox/a\"` 目录，`\"../\"` 解析为其父目录 `\"/srv/sandbox\"`，然后 `\"b\"` 解析为文件 `\"/srv/sandbox/b\"`。\n6.  最终路径是 `\"/srv/sandbox/b\"`，它被限制在沙箱子树内。\n\n所述条件确实保证了限制。\n结论：**正确**。\n\n**选项 C 评估**\n1.  这个选项绕过了在打开操作中使用 `chroot` 和 `AT_FDCWD`。取而代之的是，通过像 $d\\_root = \\mathrm{open}(\"/srv/sandbox\", O\\_PATH | O\\_DIRECTORY)$ 这样的调用，为目录 `\"/srv/sandbox\"` 获取一个文件描述符 $d\\_root$。\n2.  进程随后调用 $\\mathrm{openat}(d\\_root, \"a/../b\", O\\_RDONLY)$。这种形式的 $\\mathrm{openat}$ 会相对于与文件描述符 $d\\_root$ 关联的目录来解析给定的路径名。\n3.  解析的起始目录明确为 `\"/srv/sandbox\"`，无论进程的 $cwd$ 或 $root$ 是什么。\n4.  如同对选项B的分析一样，从起始目录 `\"/srv/sandbox\"` 解析 `\"a/../b\"` 得到最终路径 `\"/srv/sandbox/b\"`。\n5.  这个路径被限制在沙箱内。声明“无论 $cwd$ 如何，限制都能得到保证”是准确的。这是一种标准且健壮的技术，用于在特定目录内执行基于路径的操作，而无需改变像 $cwd$ 或 $root$ 这样的进程范围状态。\n\n所述条件确实保证了限制。\n结论：**正确**。\n\n**选项 D 评估**\n1.  这个选项提出了一个情景并对其结果做出了断言。我们必须评估该断言的真实性。\n2.  设置与选项B相同：调用 $\\mathrm{chroot}(\"/srv/sandbox\")$ 紧接着调用 $\\mathrm{chdir}(\"/\")`。如已确立，这将设置 $root = \\text{\"/srv/sandbox\"}$ 和 $cwd = \\text{\"/srv/sandbox\"}$。\n3.  新的条件是沙箱内的 `\"a\"` (`\"/srv/sandbox/a\"`) 是一个指向 `\"/\"` 的符号链接。\n4.  调用是 $\\mathrm{openat}(AT\\_FDCWD, \"a/../b\", O\\_RDONLY)$，从 $cwd = \\text{\"/srv/sandbox\"}$ 开始。\n5.  路径解析从 `\"a\"` 开始。在 `\"/srv/sandbox\"` 处，发现 `\"a\"` 是一个指向 `\"/\"` 的符号链接。\n6.  链接的目标 `\"/\"` 是一个绝对路径。因此，它的解析必须从进程当前的 $root$ 开始，也就是 `\"/srv/sandbox\"`。因此，该符号链接解析为目录 `\"/srv/sandbox\"`。\n7.  路径组件 `\"a\"` 实际上已解析为 `\"/srv/sandbox\"`。现在，处理下一个组件 `\"..\"`。它指向刚刚解析出的目录的父目录。\n8.  我们必须找到 `\"/srv/sandbox\"` 的父目录。然而，规则“路径遍历不能通过 `..` 上升到 $root$ 之上”适用。由于 `\"/srv/sandbox\"` 是进程的 $root$，尝试通过 `\"../\"` 上升的结果仍然是 `\"/srv/sandbox\"` 本身。\n9.  所以，路径 `\"a/..\"` 解析为 `\"/srv/sandbox\"`。\n10. 最后，组件 `\"b\"` 相对于这个结果进行解析，得到 `\"/srv/sandbox/b\"`。\n11. 最终路径被限制在沙箱内。因此，该选项声称路径“可以解析到沙箱外部”并且“限制无法得到保证”是错误的。\n\n此选项中的陈述在事实上是不正确的。\n结论：**错误**。\n\n**选项 E 评估**\n1.  进程调用 $\\mathrm{chroot}(\"/srv/sandbox\")$，设置 $root = \\text{\"/srv/sandbox\"}$。\n2.  然后它使用 $\\mathrm{fchdir}$，通过一个在 chroot *之前* 打开的指向 `\"/etc\"` 的文件描述符来设置其 $cwd$。此操作明确地将 $cwd$ 设置为与 `\"/etc\"` 对应的目录 inode。\n3.  最终状态是 $root = \\text{\"/srv/sandbox\"}$ 并且 $cwd$ 指向 `\"/etc\"` 目录，该目录在 $root$ 监牢之外。这个状态与选项 A 中的状态相同。\n4.  调用 $\\mathrm{openat}(AT\\_FDCWD, \"a/../b\", O\\_RDONLY)$ 相对于 $cwd$ 即 `\"/etc\"` 解析路径。\n5.  路径解析为 `\"/etc/b\"`，它没有被限制在 `\"/srv/sandbox\"` 子树内。\n6.  “限制仍然能够得到保证”的说法是错误的。其理由“因为 $root$ 屏障阻止了逃逸”同样存在缺陷，因为解析过程从一开始就从未进入过监牢。\n\n所述条件不能保证限制。\n结论：**错误**。\n\n综上所述，只有选项 B 和 C 描述了能够正确且稳健地保证文件操作被限制在 `\"/srv/sandbox\"` 子树内的情景。", "answer": "$$\\boxed{BC}$$", "id": "3642749"}]}