{"hands_on_practices": [{"introduction": "理论是一回事，亲手构建则是另一回事。这项练习旨在挑战你创建一个在内存中运行的、功能完备的有向无环图（DAG）目录系统模拟器。通过实现 `link` 和 `unlink` 等基本操作，特别是强制执行无环约束，你将对支撑这些高级文件系统的数据结构和核心算法获得具体而深刻的理解。[@problem_id:3619453]", "problem": "你需要设计并实现一个自包含的教学模拟器，用于一个建模为有向无环图（DAG）的目录系统。该模拟器必须完全在内存中运行，并严格强制无环性。该模型应遵循以下源自标准操作系统目录抽象和成熟图论的第一性原理定义和规则。\n\n模拟器必须体现的核心定义：\n- 目录系统表示为一个有向图 $G = (V, E)$，其中 $V$ 是节点的有限集合，$E \\subseteq V \\times V$ 是有向边的集合。\n- 每个节点 $v \\in V$ 代表一个文件系统对象，其类型为目录或文件。文件没有出边。目录可以有指向任何类型节点的出边。从一个目录出发的每条出边都由一个字符串名称标记。单个目录内的名称必须是唯一的。\n- 图必须是无环的。一个环是节点序列 $(v_0, v_1, \\dots, v_k)$，其中 $k \\geq 1$，使得对于所有 $i \\in \\{0, 1, \\dots, k-1\\}$ 都有 $(v_i, v_{i+1}) \\in E$，并且 $(v_k, v_0) \\in E$。因此，任何会使父节点从其预期的子节点变得可达的边的添加都必须被拒绝。\n- 每个节点 $v$ 维护一个入度（也称引用计数），表示为 $\\mathrm{in}(v) \\in \\mathbb{Z}_{\\ge 0}$，等于引用 $v$ 的目录条目数。根目录是一个特殊的节点，其标识符为 $0$，并且永远不会被垃圾回收。\n- 垃圾回收规则：当一条边被移除，且一个节点的入度变为 $0$（并且该节点不是根节点）时，该节点被删除。如果该节点是一个目录，则其所有出边都将被移除，其子节点的引用计数也相应递减；这可能会递归地级联。\n\n你的模拟器必须实现以下命令，并带有明确的错误状态：\n- link$(p, c, s)$：添加一条从标识符为 $p$ 的父节点（必须是目录）到标识符为 $c$ 的子节点的有向边，并在 $p$ 内为其分配名称字符串 $s$。\n  - 成功时返回 $0$。\n  - 如果 $p$ 或 $c$ 未引用有效的现有节点，或者 $p$ 不是目录，则返回 $-1$。\n  - 如果 $s$ 在 $p$ 中已经绑定到不同的子节点，则返回 $-2$。\n  - 如果从 $p$ 到 $c$ 已存在同名 $s$ 的边，则返回 $-3$。\n  - 如果添加该边会引入一个环（等价于，在添加之前 $p$ 可从 $c$ 到达），则返回 $-4$。\n- unlink$(p, s)$：从目录节点 $p$ 移除指向其子节点的名为 $s$ 的边。移除后，根据上述规则执行垃圾回收。\n  - 成功时返回 $0$。\n  - 如果不存在从 $p$ 出发的名为 $s$ 的边，则返回 $-5$。\n- rename$(p, s_{\\text{old}}, s_{\\text{new}})$：将目录节点 $p$ 中现有边的名称从 $s_{\\text{old}}$ 更改为 $s_{\\text{new}}$。\n  - 成功时返回 $0$。\n  - 如果 $s_{\\text{old}}$ 在 $p$ 中不存在，则返回 $-6$。\n  - 如果 $s_{\\text{new}}$ 在 $p$ 中已用于任何边，则返回 $-7$。\n\n模拟器还必须实现一个只读的 show 操作，用于计算当前图状态的不变度量：\n- 设 $N$ 为存活节点的总数。\n- 设 $E$ 为存活有向边的总数。\n- 设 $B$ 为无环性的布尔指示器，其中当且仅当当前图没有有向环时，$B = 1$，否则 $B = 0$。\n- 设 $S$ 为一个整数校验和，定义为 $S = \\sum_{(p \\to c, s) \\in E} \\left( |s| + p + c \\right)$，其中 $|s|$ 表示字符串 $s$ 的长度，求和遍及所有由名称 $s$ 标记的目录边 $(p \\to c)$。\n\n必须指导你设计的算法事实：\n- 可达性通过有向路径的存在来定义：如果存在一个序列 $u = v_0, v_1, \\dots, v_k = v$，其中 $k \\ge 0$ 且对所有 $i$ 都有 $(v_i, v_{i+1}) \\in E$，则节点 $u$ 可以到达节点 $v$。在 link$(p,c,s)$ 中拒绝环是通过在添加 $(p \\to c)$ 之前检查当前 $G$ 中 $p$ 是否可从 $c$ 到达来实现的。\n- 标准的带有颜色标记或已访问集合的深度优先搜索（DFS）适用于确定可达性和检测环，从而评估 $B$。\n\n你的程序必须：\n- 为下面的每个测试用例构建新的 DAG 实例。\n- 提供内部辅助操作，以根据测试序列的需要创建目录和文件类型的节点。每个 DAG 中必须存在标识符为 $0$ 的根目录，且它是一个目录。\n- 执行以下测试套件，每个测试都在一个新的 DAG 实例上执行：\n  1. 测试用例 $1$ (正常路径)：创建目录 $A$ 和 $B$，以及一个文件 $F$。执行 link$(0, A, \\text{\"home\"})$、link$(0, B, \\text{\"etc\"})$、link$(A, F, \\text{\"notes\"})$。然后计算 show 度量并返回列表 $[N, E, B, S]$。\n  2. 测试用例 $2$ (环拒绝)：创建目录 $A$。执行 link$(0, A, \\text{\"home\"})$。尝试 link$(A, 0, \\text{\"back\"})$。返回该尝试产生的整数错误码（预期为一个负整数，表示因环风险而拒绝）。\n  3. 测试用例 $3$ (重命名冲突)：创建文件 $F$ 和 $G$。执行 link$(0, F, \\text{\"x\"})$、link$(0, G, \\text{\"y\"})$。尝试 rename$(0, \\text{\"x\"}, \\text{\"y\"})$。返回该尝试产生的整数错误码（预期为一个负整数，表示目标名称冲突）。\n  4. 测试用例 $4$ (取消链接的垃圾回收)：创建目录 $A$ 和文件 $F$。执行 link$(0, A, \\text{\"home\"})$、link$(A, F, \\text{\"notes\"})$。执行 unlink$(0, \\text{\"home\"})$。返回垃圾回收完成后的整数节点数 $N$。\n  5. 测试用例 $5$ (多父节点链接与取消链接)：创建目录 $A$ 和 $B$。执行 link$(0, A, \\text{\"home\"})$、link$(0, B, \\text{\"etc\"})$、link$(B, A, \\text{\"alias\"})$。执行 unlink$(B, \\text{\"alias\"})$。返回取消链接后 $A$ 的整数入度 $\\mathrm{in}(A)$。\n\n最终输出格式规范：\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个测试结果在列表中占据一个位置。测试用例 1 使用一个四元素列表，测试用例 2、3、4 和 5 使用单个整数。\n- 具体来说，输出必须具有确切的形状 $[[N,E,B,S],r_2,r_3,r_4,r_5]$，其中 $r_2$、$r_3$、$r_4$ 和 $r_5$ 是如上定义的整数。不允许有其他输出。\n- 此任务不涉及物理单位、角度或百分比；所有答案都是纯整数或整数列表，并且所有数字都必须以普通整数形式报告。", "solution": "该问题要求设计并实现一个用于无环图目录系统的模拟器。解决方案必须基于图论和操作系统原理的形式化定义。解决方案的核心在于将文件系统建模为一个有向无环图（DAG）$G = (V, E)$，并正确实现状态修改操作（`link`、`unlink`、`rename`），以维护该结构的完整性，特别是其无环性和基于引用计数的垃圾回收。\n\n### 数据结构设计\n\n图 $G$ 由节点和边的集合表示。为了便于高效访问和管理，一个中央 `DAG` 结构封装了整个状态。\n\n1.  **节点表示**：每个节点 $v \\in V$ 由一个 `Node` 结构表示。该结构包含：\n    *   一个整数标识符 `id`，它是节点的唯一键。\n    *   一个 `type` 枚举类型，可以是 `NODE_DIRECTORY` 或 `NODE_FILE`。\n    *   一个整数 `in_degree`，表示引用计数 $\\mathrm{in}(v)$。此计数是入边的数量，对应于链接到此节点的父目录数。\n    *   一个布尔标志 `is_active`，用于逻辑上将节点标记为“存活”或“已删除”（由垃圾回收器操作）。\n    *   对于 `NODE_DIRECTORY` 类型的节点，有一个指向出边链表的指针。根据定义，文件节点没有出边。\n\n2.  **边表示**：每条带有名称标签 $s$ 的有向边 $(p, c) \\in E$ 由一个 `Edge` 结构表示。该结构包含：\n    *   一个字符数组 `name`，用于存储字符串标签 $s$。\n    *   一个整数 `child_id`，存储子节点 $c$ 的标识符。\n    *   一个 `next` 指针，形成一个从共同父目录 $p$ 发出的边的单向链表。\n\n3.  **图容器**：一个 `DAG` 结构聚合了图的各个组件：\n    *   一个 `Node` 结构数组 `nodes`，按节点 `id` 索引，提供对任何给定其标识符的节点的 $O(1)$ 访问。\n    *   一个整数 `next_node_id`，以确保为新创建的节点分配唯一的标识符。\n\n模拟始于一个位于 `id = 0` 的、活动的根目录，其 `in_degree` 在概念上非零，并且免于垃圾回收。\n\n### 算法实现\n\n**1. 通过可达性检查强制无环性**\n\n`link(p, c, s)` 操作必须保证添加从父节点 $p$ 到子节点 $c$ 的边不会引入环路。当且仅当图中已存在从 $c$ 到 $p$ 的路径时，才会创建环路。因此，在添加边 $(p, c)$ 之前，我们必须执行可达性检查。\n\n可达性查询“节点 $p$ 是否可从节点 $c$ 到达？”通过迭代深度优先搜索（DFS）来解决。算法如下：\n*   初始化一个大小为 $|V|$ 的布尔数组 `visited`，所有条目设置为 false。\n*   初始化一个栈，并将起始节点标识符 $c$ 推入。\n*   将 $c$ 标记为已访问。\n*   当栈不为空时：\n    1.  弹出一个节点标识符 $u$。\n    2.  如果 $u$ 是目标节点 $p$，则路径存在。返回 `true`。\n    3.  对于节点 $u$ 的每个子节点 $v$：\n        *   如果 $v$ 尚未被访问，则将其标记为已访问并推入栈中。\n*   如果循环完成而未找到 $p$，则不存在路径。返回 `false`。\n\n如果此检查返回 `true`，`link` 操作将以错误码 $-4$ 中止。\n\n**2. 垃圾回收**\n\n垃圾回收基于引用计数。如果一个节点的 `in_degree` 降至 $0$（并且它不是根节点），它就有资格被回收。此过程由 `unlink` 操作启动。\n\n`collect_garbage(v_id)` 过程是递归的：\n1.  检索与 `v_id` 对应的节点 $v$。\n2.  终止递归的基本情况是：如果 $v$ 已经不活动，如果 $v$ 是根节点（ID $0$），或者如果 $\\mathrm{in}(v) > 0$。\n3.  如果不满足任何基本情况，则将节点 $v$ 标记为不活动（`is_active = false`）。\n4.  如果 $v$ 是一个目录，则遍历其所有出边 $(v, w)$。对于每条这样的边：\n    *   递减子节点 $w$ 的 `in_degree`。\n    *   递归调用 `collect_garbage(w_id)`。\n    *   释放为 `Edge` 结构本身分配的内存。\n5.  遍历后，清空目录的边列表。\n\n这种级联删除正确地回收了所有不可达的子图。\n\n**3. 命令实现**\n\n面向用户的命令被实现为操作 `DAG` 数据结构的函数，使用上述算法来维护一致性。\n\n*   `link(p, c, s)`：首先，它验证节点 $p$ 和 $c$ 的存在性和类型。然后，它遍历 $p$ 的边列表以检查名称冲突（错误 $-2$）或重复的边（错误 $-3$）。随后，它执行关键的无环性检查。如果所有检查都通过，它会分配一个新的 `Edge`，将其前置到父节点的边列表中，并增加子节点的 `in_degree`。\n\n*   `unlink(p, s)`：它验证父节点 $p$ 并在其边列表中搜索名为 $s$ 的边。如果未找到，则返回错误 $-5$。如果找到，则从链表中移除该边并释放其内存。相应子节点的 `in_degree` 被递减，并对该子节点调用 `collect_garbage`，这可能触发级联。\n\n*   `rename(p, s_old, s_new)`：它首先检查新名称 $s_{\\text{new}}$ 是否已在目录 $p$ 中使用，如果是则返回错误 $-7$。然后，它搜索名为 $s_{\\text{old}}$ 的边。如果找到，则更新名称；否则，返回错误 $-6$。\n\n**4. `show` 度量计算**\n\n`show` 操作计算描述图当前状态的四个度量。\n\n*   $N$ (总节点数)：通过遍历 `nodes` 数组并计算所有 `is_active` 为 true 的节点来计算。\n*   $E$ (总边数)：通过遍历所有活动节点来计算。如果节点是目录，则将其边列表的大小加到运行总数中。\n*   $B$ (无环性)：一个布尔值，由全局环检测算法确定。采用三色 DFS 遍历：\n    *   所有节点初始为`WHITE`（未访问）。\n    *   遍历从图中每个 `WHITE` 节点开始。\n    *   访问节点时，将其着色为`GRAY`（访问中）。\n    *   如果遍历遇到一个 `GRAY` 节点，则找到了一个反向边，表示存在一个环。函数返回 $B=0$。\n    *   在访问完一个节点的所有后代之后，该节点被着色为`BLACK`（已完成）。\n    *   如果对所有节点的遍历完成而未发现环，则图是无环的，函数返回 $B=1$。\n*   $S$ (校验和)：通过遍历图中所有边 $(p \\to c, s)$ 并对每个边求和值 $|s| + p + c$ 来计算，其中 $|s|$ 是字符串名称的长度。\n\n这种全面的设计确保了问题陈述中指定的所有规则和行为都得到严格执行，从而实现一个正确且鲁棒的模拟。", "answer": "[[4, 3, 1, 19], -4, -7, 1, 1]", "id": "3619453"}, {"introduction": "在拥有一个功能性的 DAG 文件系统模型之后，我们现在可以构建实用的工具了。本练习将模拟 `du`（磁盘使用情况）命令的创建过程，并解决一个核心挑战：当文件可以通过多个路径（硬链接）访问时，如何准确计算总大小。你将使用 inode 位图实现一种遍历算法，以确保每个文件都只被计算一次，这是图处理中的一项基本技术。[@problem_id:3619477]", "problem": "给定一个适用于磁盘使用情况计算器（类似于标准工具“du”）的无环图目录系统（AGDS）的抽象模型。该模型假设以下基本基础：\n\n- 每个文件系统对象都有一个唯一的 inode 标识符，范围在 $\\{0,\\dots,N-1\\}$ 内，其中 $N$ 是一个有限整数。目录包含一个指向其他 inode 的有序引用（链接）列表。文件不包含链接；它们是叶节点。\n- 目录图是一个有向无环图（DAG）：目录可以链接到目录和文件，文件不链接到任何节点。允许文件的硬链接，但对目录的链接受到限制，以确保不会出现有向环。\n- 文件 inode $i$ 的大小是一个非负整数 $s(i) \\in \\mathbb{N}$。在此问题中，为了进行磁盘使用情况核算，目录的大小被视为 $0$。\n\n对于一组起始目录 inode，正确的磁盘使用情况遍历必须最多访问每个可达文件 inode 一次，并将其大小精确地累加一次，即使存在指向同一文件的多个硬链接。一种常用技术是 inode 位图：维护一个由 inode 标识符索引的位数组 $B$，其中如果 inode $i$ 已被计数，则 $B[i] = 1$。\n\n此问题的并发模型：\n\n- 遍历以离散步骤进行，使用带有显式堆栈的深度优先策略。在每个遍历步骤中，算法读取当前目录帧中的下一个条目，可能会进入子目录或遇到文件。\n- 并发的链接添加被建模为与遍历步骤交错的离散事件。一个添加事件在一个目录的条目列表末尾插入一个新目录条目，将该目录链接到一个现有的文件 inode 或一个新创建的文件 inode。不会发生删除，也不会添加会导致循环的目录链接。\n- 存在一个竞争窗口，因为在每一步都会读取目录的条目列表长度；因此，在目录帧被完全处理后添加的条目将不会被遍历看到。在帧完成之前添加的条目将在遍历到达这些索引时被观察到。这模拟了这样一个现实：遍历对目录可见的条目集不是一个全局快照，但磁盘使用情况算法仍必须永远不会重复计算任何文件。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n\n- 构建几个 AGDS 测试用例，每个测试用例由一组初始 inode、初始链接以及一系列交错事件定义：可以是遍历步骤或并发链接添加。对于每个测试用例，遍历总是从单个根目录 inode $r$ 开始。\n- 使用 inode 位图 $B$ 实现一个“du”遍历，以在首次遇到文件 inode $i$ 时决定是否将 $s(i)$ 添加到运行总和中。目录对总和的贡献为 $0$。遍历一直持续到显式堆栈为空。\n- 记录每个文件 inode $i$ 的大小被添加到总和中的次数（这是 $i$ 的“count-additions”）。需要检查的关键正确性属性是，对于所有文件 inode $i$，“count-additions”值最多为 $1$。\n\n您必须根据以下核心定义和经过充分测试的事实，从第一性原理出发推导和实现遍历逻辑：\n\n- 目录图是一个有向无环图 $G = (V, E)$，其中顶点集为 $V$，边集为 $E \\subseteq V \\times V$，表示“包含一个指向...的链接”。\n- 从根 $r$ 的可达集是 $R(r) = \\{ v \\in V \\mid \\exists \\text{ a directed path from } r \\text{ to } v \\}$。\n- 在没有并发的情况下，“du”的目标是计算 $S = \\sum_{i \\in R(r) \\cap F} s(i)$，其中 $F \\subseteq V$ 是文件 inode 的子集。在并发情况下，要求不是计算快照总和，而是确保“永不重复计数”的安全属性，即对于每个文件 inode $i$，$B[i]$ 从 $0$ 转换到 $1$ 最多一次，并且 $s(i)$ 最多被添加到总数中一次。\n\n重要提示：您的程序应纯粹模拟逻辑。不涉及任何物理单位。\n\n测试套件和覆盖范围：\n\n实现以下 $4$ 个测试用例。对于每个用例，构建初始 AGDS 和交错事件序列，然后执行仿真直到完成。对于每个测试用例，您的程序必须返回一个布尔结果，指示是否有任何文件的大小被添加了不止一次（其中 $1$ 表示“没有发生重复计数”，$0$ 表示“发生了重复计数”）。\n\n- 测试用例 $1$（正常路径，带有延迟的硬链接）：\n  - 初始 inodes：根目录 $r$、目录 $d$、文件 $f_1$ 和 $f_2$，大小分别为 $s(f_1)=10$ 和 $s(f_2)=20$。\n  - 初始链接：$r \\to f_1$，$r \\to d$，$d \\to f_2$。\n  - 事件序列：执行 $3$ 个遍历步骤以访问 $f_1$ 并进入 $d$ 以访问 $f_2$，然后添加新链接 $r \\to f_2$，然后继续遍历直到完成。\n  - 预期：没有重复计数；$f_2$ 的延迟链接被观察到但因为 $B[f_2]=1$ 而被跳过。\n\n- 测试用例 $2$（边界情况：跨多个子目录的多个硬链接指向同一文件）：\n  - 初始 inodes：根 $r$、子目录 $a$、$b$、$c$、文件 $f$，大小为 $s(f)=7$。\n  - 初始链接：$r \\to a$，$r \\to b$，$r \\to c$。\n  - 事件序列：交错遍历步骤，以便最终访问 $a$、$b$ 和 $c$ 中的每一个；在每个子目录被完全处理之前，从该子目录添加一个指向 $f$ 的链接。在遍历首次遇到 $f$ 之前，跨不同子目录添加至少 $2$ 个指向 $f$ 的链接，然后完成遍历。\n  - 预期：没有重复计数；尽管有多个链接，$f$ 也只被精确地计数一次。\n\n- 测试用例 $3$（竞争窗口导致计数不足但从不重复计数）：\n  - 初始 inodes：根 $r$、子目录 $x$、$y$。\n  - 初始链接：$r \\to x$，$r \\to y$。\n  - 事件序列：当 $x$ 为空时完全遍历它，然后创建一个大小为 $s(g)=5$ 的新文件 $g$，并在 $x$ 已被完全处理后添加 $x \\to g$，因此在那里不会看到它；在处理 $y$ 之前，添加 $y \\to g$；然后完成遍历。\n  - 预期：没有重复计数；$g$ 通过 $y$ 被看到一次并被计数一次。\n\n- 测试用例 $4$（边缘情况：根目录下为空文件系统）：\n  - 初始 inodes：仅有根 $r$。\n  - 初始链接：无。\n  - 事件序列：立即完成遍历。\n  - 预期：没有重复计数；总和为 $0$。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含按顺序排列的 $4$ 个测试用例的布尔结果，形式为用方括号括起来的逗号分隔列表，其中每个布尔值表示为整数 $0$ 或 $1$。例如，像 $[1,1,1,1]$ 这样的输出行表示所有测试用例都没有出现重复计数。\n\n约束和注意事项：\n\n- 您必须使用 inode 位图 $B$ 和显式堆栈来实现遍历，每次遍历一个目录条目，以允许与链接添加事件交错进行。\n- 您不能假设存在全局快照。在目录帧耗尽后追加的新目录条目将不会被该目录的遍历看到。\n- 您不得使用任何外部输入；所有内容必须在程序内存中构建并确定性地执行。", "solution": "问题陈述已经过严格验证，被认为是**有效的**。它在操作系统算法领域提出了一个定义明确、科学合理且内部一致的问题。无环图目录系统（AGDS）模型是一个标准抽象，而使用特定竞争窗口模型模拟并发的类`du`工具是一个可形式化且不平凡的任务。所有定义、约束和测试用例要求都清晰且足以构建确定性仿真，以验证指定的正确性属性。\n\n### 基于原则的仿真设计\n\n目标是在一个文件系统模型上模拟磁盘使用情况计算，并验证一个使用 inode 位图的特定实现策略，在简化的并发模型下，能够正确防止文件的重复计数。该设计基于以下原则。\n\n#### 1. 建模无环图目录系统（AGDS）\n\n文件系统被建模为一个有向无环图（DAG），表示为 `$G = (V, E)$`。顶点集 `$V$` 对应于 inode 集合，由 `$\\{0, \\dots, N-1\\}$` 中的整数唯一标识，适用于一个拥有 `$N$` 个 inode 的系统。如果目录 inode `$u$` 包含一个指向 inode `$v$` 的链接，则存在一条边 `$(u, v) \\in E$`。在我们的实现中，一个 `Inode` 结构体代表一个顶点。它存储其类型（目录或文件）、其大小 `$s(i)$`（对于目录为 `$0$`），以及对于目录，一个指向其他 inode 的动态链接列表。这直接将抽象图结构映射到具体的数据结构。\n\n```c\ntypedef enum { INODE_DIR, INODE_FILE } InodeType;\ntypedef struct {\n    int id;\n    InodeType type;\n    int size;\n    int entries[MAX_ENTRIES];\n    int num_entries;\n} Inode;\n```\n\n#### 2. 使用显式堆栈进行深度优先遍历\n\n需要一个非递归的深度优先搜索（DFS）来从根 inode `$r$` 开始遍历目录图。这是通过一个显式堆栈实现的。堆栈上的每个元素，或称 `StackFrame`，代表一个正在进行的目录遍历。一个帧包含正在处理的目录的 inode 标识符（`inode_id`）和该目录链接列表中下一个要访问的条目的索引（`entry_index`）。\n\n```c\ntypedef struct {\n    int inode_id;\n    int entry_index;\n} StackFrame;\n```\n\n遍历逻辑如下进行：\n- 查看堆栈顶部的帧 `$\\{d, k\\}$`。\n- 如果目录 `$d$` 的第 `$k$` 个条目存在，则处理它。\n- 如果该条目指向一个子目录，则将该子目录的新帧推入堆栈。\n- 如果该条目指向一个文件，则进入计数逻辑。\n- 在当前帧中递增条目索引 `$k$`。\n- 如果目录 `$d$` 中的所有条目都已处理完毕，则从堆栈中弹出其帧。\n- 当堆栈变空时，遍历终止。\n\n#### 3. 通过 Inode 位图确保正确性\n\n核心的正确性属性是，即使有多条路径（硬链接）指向同一个文件 inode `$i$`，每个可达文件的大小 `$s(i)$` 也最多被累加一次。这是通过一个辅助数据结构——inode 位图 `$B$` 来强制执行的。`$B$` 是一个大小为 `$N$` 的位数组，其中每个位 `$B[i]$` 对应一个 inode `$i$`。最初，所有位都为 `$0$`。当遍历首次遇到文件 inode `$i$` 时，它执行一个类似原子的检查并设置操作：\n\n1.  检查 `$B[i]$` 是否为 `$0$`。\n2.  如果是，则将 `$s(i)$` 添加到总和中，将 `$B[i]` 设置为 `$1$`，并记录此次对该文件进行了一次加法操作。\n3.  如果 `$B[i]$` 已经是 `$1$`，则表示该文件之前已被计数。遍历会跳过它并继续。\n\n这个机制保证了对于每个文件 `$i$`，加法 `total_sum += s(i)` 最多发生一次，满足了问题的主要安全要求。为了验证，我们维护一个 `count_additions` 数组，以明确跟踪对每个文件执行此加法操作的次数。一次正确的运行必须导致所有文件 inode `$i$` 的 `count_additions[i]` 最多为 `$1$`。\n\n#### 4. 仿真并发与竞争窗口\n\n并发是通过一系列确定性的、交错的事件来建模的。一个事件可以是一次遍历步骤或一次链接添加操作。仿真通过处理这个预定义的序列来进行。\n\n竞争窗口的建模方式是，确保在处理目录的每个遍历步骤中都重新读取该目录中的条目数。我们的 `perform_traversal_step` 函数通过检查 `frame->entry_index  dir->num_entries` 来实现这一点，其中 `dir->num_entries` 反映了目录当前可能被修改过的状态。如果在遍历处理完开始时存在的所有条目之后，但在帧被弹出之前，向目录添加了一个链接，那么新的条目将被看到。相反，如果在遍历的索引已经越过了原始条目列表的末尾之后添加链接，那么新的链接将被错过，从而正确地模拟了竞争条件。\n\n这种离散事件仿真允许对算法在特定并发场景下的行为进行严格和可复现的分析，正如测试套件中所定义的那样。该实现将问题描述中的每个测试用例转换为一个初始图配置和相应的事件序列来驱动仿真。", "answer": "[1, 1, 1, 1]", "id": "3619477"}, {"introduction": "一个健壮的文件系统依赖于其元数据的精确管理。最后的这项练习聚焦于 `$st\\_nlink$`（链接数），这是一个关键的元数据，用于追踪指向一个文件或目录的引用数量。你将通过一系列文件系统操作，追踪 `$st\\_nlink$` 值的变化，从而加深对在复杂的 DAG 环境中，文件和目录的链接是如何被精确计数的理解。[@problem_id:3619462]", "problem": "一个操作系统支持一个有向无环图（DAG）形式的目录命名空间，允许一个目录拥有多个硬链接，只要不形成环路。文件状态字段 $st\\_nlink$ 报告指向一个 inode 的硬链接数量。使用以下模型：\n- 对于一个非目录文件 $F$，$st\\_nlink(F)$ 是指向 $F$ 的目录项数量。\n- 对于一个目录 $D$，$st\\_nlink(D)$ 计算指向 $D$ 的每个目录项，包括 $D$ 自身的点条目“.”、任何父目录中命名为 $D$ 的条目，以及每个直接子目录中解析到 $D$ 的点点条目“..”。\n- 当在父目录 $P$ 内创建一个新的子目录 $C$ 时，新目录的 $st\\_nlink(C) = 2$（为其“.”条目和父目录中命名它的条目），并且 $st\\_nlink(P)$ 增加1，因为 $C$ 的“..”条目解析到 $P$。\n- 当在某个其他目录 $Q$ 中为已有目录 $D$ 创建一个额外的硬链接时（这不会使 $D$ 的“..”解析到 $Q$），$st\\_nlink(D)$ 增加1，而 $st\\_nlink(Q)$ 不变。\n- 取消链接一个非目录文件的名称会使目标的 $st\\_nlink$ 减1。通过 $rmdir$ 移除一个空子目录会使父目录的 $st\\_nlink$ 减1，并删除该子目录。\n\n假设文件系统初始为空，只有一个根目录。执行以下操作序列，并且所有操作在无环性方面都是有效的：\n- 步骤1：在根目录下创建目录 $/$P 和 $/$Q。\n- 步骤2：在目录 $/$P 中，创建一个名为 $f$ 的常规文件。\n- 步骤3：在路径 $/$Q$/g$ 创建一个指向 $/$P$/f$ 的硬链接。\n- 步骤4：在目录 $/$P 中，创建一个名为 $C$ 的子目录。\n- 步骤5：在目录 $/$Q 中，创建一个名为 $D$ 的子目录。\n- 步骤6：在目录 $/$Q 中，创建一个名为 $C\\_alias$ 的额外硬链接，指向已有目录 $/$P$/$C$（这不会改变 $/$C$..\"$ 解析到的父目录）。\n- 步骤7：在目录 $/$P$/$C$ 中，创建一个名为 $E$ 的子目录。\n- 步骤8：取消链接 $/$P$/$f$。\n- 步骤9：取消链接 $/$Q$/$C\\_alias$（移除指向 $/$P$/$C$ 的额外链接）。\n- 步骤10：通过 $rmdir$ 移除空子目录 $/$P$/$C$/$E$。\n\n在步骤10之后，以下哪个元组给出了 $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$ 的最终值？\n\nA. $\\;(3,\\;3,\\;2,\\;2,\\;1)$\n\nB. $\\;(3,\\;4,\\;3,\\;2,\\;1)$\n\nC. $\\;(2,\\;3,\\;2,\\;2,\\;1)$\n\nD. $\\;(3,\\;3,\\;3,\\;2,\\;2)$", "solution": "首先验证问题陈述的正确性和可解性。\n\n### 步骤1：提取已知条件\n- 目录系统是一个有向无环图（DAG）。\n- `st_nlink` 字段表示一个 inode 的链接数。\n- 对于一个非目录文件 $F$，$st\\_nlink(F)$ 是指向它的目录项数量。\n- 对于一个目录 $D$，$st\\_nlink(D)$ 是以下各项的总和：\n  1. 其自身的 `.` 条目。\n  2. 任何父目录中命名为 $D$ 的条目。\n  3. 来自每个直接子目录的 `..` 条目。\n- 在父目录 $P$ 中创建子目录 $C$：$st\\_nlink(C)$ 变为 $2$，并且 $st\\_nlink(P)$ 增加1。\n- 在目录 $Q$ 中为目录 $D$ 创建一个额外的硬链接：$st\\_nlink(D)$ 增加1；$st\\_nlink(Q)$ 不变。\n- 取消链接一个非目录文件的名称：使目标 inode 的 $st\\_nlink$ 减1。\n- 移除一个空子目录（`rmdir`）：使父目录的 $st\\_nlink$ 减1。\n- 初始条件：文件系统只包含根目录 `/`。\n- 操作序列：\n  1. 创建目录 `/P` 和 `/Q`。\n  2. 创建常规文件 `/P/f`。\n  3. 为 `/P/f` 创建硬链接 `/Q/g`。\n  4. 创建子目录 `/P/C`。\n  5. 创建子目录 `/Q/D`。\n  6. 为 `/P/C` 创建额外的硬链接 `/Q/C_alias`。\n  7. 创建子目录 `/P/C/E`。\n  8. 取消链接 `/P/f`。\n  9. 取消链接 `/Q/C_alias`。\n  10. `rmdir /P/C/E`。\n- 问题要求 $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$ 的最终值。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在计算机科学领域，特别是在操作系统文件系统设计方面，具有科学依据。所提供的在基于DAG的目录系统中对 `st_nlink` 进行计数的模型，虽然没有被普遍实现，但它是一个逻辑上一致且定义明确的概念。这个问题是良构的，具有清晰的初始状态、确定性的操作序列和一个具体的问题。语言客观且无歧义。所有术语都由所提供的规则充分定义。因此，该问题是有效的。\n\n### 步骤3：结论和行动\n问题是有效的。将逐步推导解决方案。\n\n### 解题推导\n我们将通过这十个操作序列，跟踪五个指定inode的 `st_nlink` 值。令我们关心的元组为 $\\big(n_P, n_Q, n_C, n_D, n_f\\big)$，表示 $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$。\n\n**初始状态：** 文件系统除了根目录外是空的。`/P`、`/Q`、`/P/C`、`/Q/D` 和 `f` 的inode尚不存在。它们的链接数实际上是 $0$。\n\n**步骤1：** 创建目录 `/P` 和 `/Q`。\n- 创建新目录 `/P`。根据规则，其链接数为 $2$。$n_P = 2$。\n- 创建新目录 `/Q`。根据规则，其链接数为 $2$。$n_Q = 2$。\n- 元组：$\\big(2, 2, \\text{不适用}, \\text{不适用}, \\text{不适用}\\big)$。\n\n**步骤2：** 创建一个常规文件 `/P/f`。\n- 为文件 `f` 创建一个inode，带有一个目录项 `/P/f`。其链接数为 $1$。$n_f = 1$。\n- 元组：$\\big(2, 2, \\text{不适用}, \\text{不适用}, 1\\big)$。\n\n**步骤3：** 为 `/P/f` 创建硬链接 `/Q/g`。\n- 第二个目录项 `/Q/g` 现在指向 `f` 的inode。其链接数增加1。\n- $n_f$ 变为 $1+1 = 2$。\n- 元组：$\\big(2, 2, \\text{不适用}, \\text{不适用}, 2\\big)$。\n\n**步骤4：** 创建子目录 `/P/C`。\n- 创建新目录 `/P/C`。其链接数为 $2$。$n_C = 2$。\n- 父目录 `/P` 从 `/P/C` 获得一个 `..` 链接。其链接数增加1。\n- $n_P$ 变为 $2+1 = 3$。\n- 元组：$\\big(3, 2, 2, \\text{不适用}, 2\\big)$。\n\n**步骤5：** 创建子目录 `/Q/D`。\n- 创建新目录 `/Q/D`。其链接数为 $2$。$n_D = 2$。\n- 父目录 `/Q` 从 `/Q/D` 获得一个 `..` 链接。其链接数增加1。\n- $n_Q$ 变为 $2+1 = 3$。\n- 元组：$\\big(3, 3, 2, 2, 2\\big)$。\n\n**步骤6：** 为 `/P/C` 创建额外的硬链接 `/Q/C_alias`。\n- 目标目录 `/P/C` 获得一个新名称。其链接数增加1。\n- $n_C$ 变为 $2+1 = 3$。\n- 根据规则，`/Q` 的链接数不变。\n- 元组：$\\big(3, 3, 3, 2, 2\\big)$。\n\n**步骤7：** 创建子目录 `/P/C/E`。\n- 父目录 `/P/C` 从 `/P/C/E` 获得一个 `..` 链接。其链接数增加1。\n- $n_C$ 变为 $3+1 = 4$。\n- 元组：$\\big(3, 3, 4, 2, 2\\big)$。\n\n**步骤8：** 取消链接 `/P/f`。\n- 目录项 `/P/f` 被移除。目标inode `f` 的链接数减少1。\n- $n_f$ 变为 $2-1 = 1$。\n- 元组：$\\big(3, 3, 4, 2, 1\\big)$。\n\n**步骤9：** 取消链接 `/Q/C_alias`。\n- 指向目录 `/P/C` 的额外硬链接被移除。与其创建过程对称，这会使目标目录的链接数减1。\n- $n_C$ 变为 $4-1 = 3$。\n- 元组：$\\big(3, 3, 3, 2, 1\\big)$。\n\n**步骤10：** 通过 `rmdir` 移除空子目录 `/P/C/E`。\n- `/P/C/E` 的父目录是 `/P/C`。移除 `/P/C/E` 会移除从 `/P/C/E` 指向 `/P/C` 的 `..` 链接。父目录的链接数减少1。\n- $n_C$ 变为 $3-1 = 2$。\n- 最终元组：$\\big(3, 3, 2, 2, 1\\big)$。\n\n最终推导出的值为 $st\\_nlink(/P) = 3$，$st\\_nlink(/Q) = 3$，$st\\_nlink(/P/C) = 2$，$st\\_nlink(/Q/D) = 2$，以及 $st\\_nlink(\\text{inode of }f) = 1$。\n\n### 逐项分析选项\n\n**A. $\\;(3,\\;3,\\;2,\\;2,\\;1)$**\n该元组与分步分析推导出的最终值相匹配。\n- $st\\_nlink(/P) = 3$: 正确。链接包括它在 `/` 中的条目 `P`、其自身的 `.` 条目，以及来自其子目录 `/P/C` 的 `..` 条目。\n- $st\\_nlink(/Q) = 3$: 正确。链接包括它在 `/` 中的条目 `Q`、其自身的 `.` 条目，以及来自其子目录 `/Q/D` 的 `..` 条目。\n- $st\\_nlink(/P/C) = 2$: 正确。链接包括它在 `/P` 中的条目 `C` 和其自身的 `.` 条目。来自 `C_alias` 的链接（步骤6）已被移除（步骤9），来自 `/P/C/E` 的 `..` 链接（步骤7）也已被移除（步骤10）。\n- $st\\_nlink(/Q/D) = 2$: 正确。链接包括它在 `/Q` 中的条目 `D` 和其自身的 `.` 条目。\n- $st\\_nlink(\\text{inode of }f) = 1$: 正确。条目 `/P/f` 已被移除（步骤8），只剩下条目 `/Q/g`。\n**结论：正确。**\n\n**B. $\\;(3,\\;4,\\;3,\\;2,\\;1)$**\n- $st\\_nlink(/Q)$ 的值为 $4$，这是不正确的。推导出的值为 $3$。\n- $st\\_nlink(/P/C)$ 的值为 $3$，这是不正确的。推导出的值为 $2$。这应该是步骤9之后、步骤10之前的状态。\n**结论：不正确。**\n\n**C. $\\;(2,\\;3,\\;2,\\;2,\\;1)$**\n- $st\\_nlink(/P)$ 的值为 $2$，这是不正确的。推导出的值为 $3$。它的链接数在步骤4中增加到 $3$，之后没有减少。\n**结论：不正确。**\n\n**D. $\\;(3,\\;3,\\;3,\\;2,\\;2)$**\n- $st\\_nlink(/P/C)$ 的值为 $3$，这是不正确的，原因如选项B中所解释。\n- $st\\_nlink(\\text{inode of }f)$ 的值为 $2$，这是不正确的。推导出的值为 $1$。这应该是步骤8中取消链接操作之前的状态。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3619462"}]}