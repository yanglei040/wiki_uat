{"hands_on_practices": [{"introduction": "在日志结构文件系统（LFS）中，所有写操作最初都是对日志的顺序追加。然而，这个过程并非没有代价；系统需要消耗 CPU 资源来管理元数据，例如段摘要。这项练习将引导你从第一性原理出发，为这种开销建立一个量化模型，这是性能分析和系统调优中的一项关键技能 [@problem_id:3654765]。", "problem": "日志结构文件系统（LFS）维护一个每段摘要，以加速崩溃恢复和清理。考虑一个实现，它将用户写入附加到大小为 $S = 2\\,\\mathrm{MiB}$ 的内存中段缓冲区，文件系统块大小为 $B = 4096\\,\\mathrm{bytes}$。当段已满时，系统会发出该段及其摘要。每个附加的块贡献一个摘要条目。每个条目的工作包括计算循环冗余校验（CRC）、格式化元数据，以及将条目插入用于清理期间快速查找的内存哈希表中。该实现在给定机器上进行了性能分析，并测量了以下每个操作的成本：\n\n- 对字节流计算一个 $32$ 位 CRC 的成本为每个字节 $c_{\\mathrm{crc}} = 3.2$ 个周期。\n- 格式化和存储大小为 $m = 32\\,\\mathrm{bytes}$ 的固定大小摘要元数据的成本为每个字节 $c_{\\mathrm{meta}} = 0.8$ 个周期。\n- 每个条目的固定格式化开销（分支、边界检查和指针追踪）成本为每个条目 $c_{\\mathrm{fmt}} = 150$ 个周期。\n- 在观察到的负载因子下，将条目插入内存哈希表的预期成本为每个条目 $c_{\\mathrm{hash}} = 75$ 个周期。\n\n此外，还有一个固定的每段头部组装成本 $c_{\\mathrm{seg}} = 10000$ 个周期，必须在段中的所有条目上进行摊销。此外，每次用户写入都有一个固定的每次写入同步开销 $c_{\\mathrm{w}} = 300$ 个周期。\n\n假设平均用户写入大小为 $w = 12\\,\\mathrm{KiB}$，并且写入与块边界对齐，因此每次写入的块数恰好为 $n = w / B$。假设段被密集填充，因此 $c_{\\mathrm{seg}}$ 的每条目摊销份额在段中的所有条目上是均匀的，并且所有成本线性相加，因为这些步骤在中央处理器（CPU）上是串行执行的。\n\n根据基本原理和给定测量值，推导每次写入的预期 CPU 周期 $C_{\\mathrm{cpu}}$ 的闭式表达式，然后根据所提供的参数对其进行数值计算。以周期为单位表示最终结果，并将答案四舍五入到四位有效数字。", "solution": "问题要求推导每次用户写入的预期 CPU 周期（表示为 $C_{\\mathrm{cpu}}$）的闭式表达式，并随后进行数值计算。推导将基于基本原理，将总成本分解为问题陈述中描述的各个组成部分。线性原理允许我们将这些单独的成本相加。\n\n首先，让我们以符号和数值形式定义给定的参数：\n- 段缓冲区大小: $S = 2\\,\\mathrm{MiB} = 2 \\times (1024)^2\\,\\mathrm{bytes} = 2 \\times 2^{20}\\,\\mathrm{bytes} = 2097152\\,\\mathrm{bytes}$。\n- 文件系统块大小: $B = 4096\\,\\mathrm{bytes} = 4 \\times 1024\\,\\mathrm{bytes} = 2^{12}\\,\\mathrm{bytes}$。\n- 平均用户写入大小: $w = 12\\,\\mathrm{KiB} = 12 \\times 1024\\,\\mathrm{bytes} = 12288\\,\\mathrm{bytes}$。\n- 每个条目的摘要元数据大小: $m = 32\\,\\mathrm{bytes}$。\n- 每字节 CRC 成本: $c_{\\mathrm{crc}} = 3.2$ 周期/字节。\n- 每字节元数据存储成本: $c_{\\mathrm{meta}} = 0.8$ 周期/字节。\n- 每个条目的固定格式化开销: $c_{\\mathrm{fmt}} = 150$ 周期/条目。\n- 每个条目的哈希表插入成本: $c_{\\mathrm{hash}} = 75$ 周期/条目。\n- 固定的每段头部组装成本: $c_{\\mathrm{seg}} = 10000$ 周期/段。\n- 固定的每次写入同步开销: $c_{\\mathrm{w}} = 300$ 周期/写入。\n\n每次写入的总成本 $C_{\\mathrm{cpu}}$ 是固定的每次写入开销与处理构成该写入的块相关成本的总和。单次用户写入的大小为 $w$，由 $n$ 个大小为 $B$ 的块组成。在块对齐的假设下，每次写入的块数为：\n$$n = \\frac{w}{B}$$\n总成本可以表示为：\n$$C_{\\mathrm{cpu}} = c_{\\mathrm{w}} + n \\cdot C_{\\mathrm{block}}$$\n其中 $C_{\\mathrm{block}}$ 是与处理单个块相关的总 CPU 成本。\n\n每个块的成本 $C_{\\mathrm{block}}$ 是几个组成部分的总和。问题陈述指出，每个附加的块贡献一个摘要条目。因此，每块成本等同于每条目成本。这些成本可以分类如下：\n\n1.  **CRC 计算成本**：此成本与块大小 $B$ 成正比。\n    $$C_{\\mathrm{crc\\_block}} = c_{\\mathrm{crc}} \\cdot B$$\n2.  **摘要条目生成成本**：这包括格式化和存储大小为 $m$ 的元数据、固定的每条目格式化开销以及哈希表插入成本。\n    $$C_{\\mathrm{summary\\_entry}} = (c_{\\mathrm{meta}} \\cdot m) + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}}$$\n3.  **摊销的每段成本**：每段的固定成本 $c_{\\mathrm{seg}}$ 必须分摊到该段内的所有块上。首先，我们计算可以放入单个大小为 $S$ 的段中的块数 $N_{B/S}$。\n    $$N_{B/S} = \\frac{S}{B}$$\n    那么，每块（或每条目）的摊销成本为：\n    $$C_{\\mathrm{amortized\\_seg}} = \\frac{c_{\\mathrm{seg}}}{N_{B/S}} = \\frac{c_{\\mathrm{seg}}}{S/B} = \\frac{c_{\\mathrm{seg}} \\cdot B}{S}$$\n\n每个块的总成本 $C_{\\mathrm{block}}$ 是这些组成部分的总和：\n$$C_{\\mathrm{block}} = C_{\\mathrm{crc\\_block}} + C_{\\mathrm{summary\\_entry}} + C_{\\mathrm{amortized\\_seg}}$$\n$$C_{\\mathrm{block}} = (c_{\\mathrm{crc}} \\cdot B) + (c_{\\mathrm{meta}} \\cdot m + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}}) + \\frac{c_{\\mathrm{seg}} \\cdot B}{S}$$\n\n现在，我们将 $C_{\\mathrm{block}}$ 的这个表达式代回到 $C_{\\mathrm{cpu}}$ 的方程中：\n$$C_{\\mathrm{cpu}} = c_{\\mathrm{w}} + n \\cdot \\left( c_{\\mathrm{crc}} \\cdot B + c_{\\mathrm{meta}} \\cdot m + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}} + \\frac{c_{\\mathrm{seg}} \\cdot B}{S} \\right)$$\n代入 $n = w/B$，我们得到每次写入的预期 CPU 周期的最终闭式表达式：\n$$C_{\\mathrm{cpu}} = c_{\\mathrm{w}} + \\frac{w}{B} \\left( c_{\\mathrm{crc}} \\cdot B + c_{\\mathrm{meta}} \\cdot m + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}} + \\frac{c_{\\mathrm{seg}} \\cdot B}{S} \\right)$$\n\n接下来，我们使用所提供的参数对该表达式进行数值计算。\n\n首先，计算每次写入的块数 $n$：\n$$n = \\frac{w}{B} = \\frac{12288\\,\\mathrm{bytes}}{4096\\,\\mathrm{bytes}} = 3$$\n\n现在，我们计算每块成本 $C_{\\mathrm{block}}$ 的组成部分：\n- 每块的 CRC 成本：\n$C_{\\mathrm{crc\\_block}} = c_{\\mathrm{crc}} \\cdot B = 3.2 \\cdot 4096 = 13107.2$ 周期。\n- 摘要条目成本（不包括摊销成本）：\n$C_{\\mathrm{summary\\_entry}} = (c_{\\mathrm{meta}} \\cdot m) + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}} = (0.8 \\cdot 32) + 150 + 75 = 25.6 + 150 + 75 = 250.6$ 周期。\n- 每块的摊销段成本：\n首先，计算每段的块数 $N_{B/S}$：\n$$N_{B/S} = \\frac{S}{B} = \\frac{2097152\\,\\mathrm{bytes}}{4096\\,\\mathrm{bytes}} = 512$$\n然后，摊销成本是：\n$$C_{\\mathrm{amortized\\_seg}} = \\frac{c_{\\mathrm{seg}}}{N_{B/S}} = \\frac{10000}{512} = 19.53125 \\text{ 周期。}$$\n\n每块的总成本是这些组成部分的总和：\n$$C_{\\mathrm{block}} = 13107.2 + 250.6 + 19.53125 = 13377.33125 \\text{ 周期。}$$\n\n最后，我们计算每次写入的总 CPU 周期 $C_{\\mathrm{cpu}}$：\n$$C_{\\mathrm{cpu}} = c_{\\mathrm{w}} + n \\cdot C_{\\mathrm{block}} = 300 + 3 \\cdot 13377.33125$$\n$$C_{\\mathrm{cpu}} = 300 + 40131.99375 = 40431.99375 \\text{ 周期。}$$\n\n问题要求将最终答案四舍五入到四位有效数字。计算值为 $40431.99375$。前四位有效数字是 $4, 0, 4, 3$。第五位数字是 $1$，所以我们向下舍入。\n$$C_{\\mathrm{cpu}} \\approx 40430$$\n为了用四位有效数字明确地表示这个值，我们可以使用科学计数法：$4.043 \\times 10^4$。", "answer": "$$\\boxed{4.043 \\times 10^4}$$", "id": "3654765"}, {"introduction": "日志结构文件系统的清理器是回收空间的核心机制，但它会带来“写放大”的代价——总磁盘流量可能远大于用户写入的数据。找到触发清理器的最佳时机是一个关键的优化问题。这项练习要求你对这一权衡进行数学建模，并找到最优的清理阈值以最小化系统开销 [@problem_id:3654742]。", "problem": "日志结构文件系统（LFS）的清理器通过选择利用率低于一个阈值的段来回收空间。考虑以下基于段清理和概率选择定义的原则性模型。\n\n大量段的利用率是独立的，由一个在 $[0,1]$ 上均匀分布的随机变量 $U$ 建模。当清理器运行时，它在满足 $U \\le u_t$ 的段中进行均匀选择，其中 $u_t \\in (0,1)$ 是一个固定的触发阈值。清理一个利用率为 $u$ 的段会读取1个段，并将占比为 $u$ 的有效数据写入新的段中，从而释放占比为 $1-u$ 的空间。写入新用户数据的行为本身，每写入一个单位的数据（归一化为1），总是会产生恰好1个段的设备流量。此外，在清理之前，系统可能需要扫描候选段以找到满足 $U \\le u_t$ 的段。在扫描过程中检查的每个候选段都会产生一个归一化的、依赖于工作负载的设备流量开销 $c_m$，其中 $m \\in \\{\\text{hot}, \\text{cold}\\}$ 表示工作负载模式。假设为找到一个合格段而检查的候选段的期望数量等于合格概率的倒数。\n\n工作负载随时间在两种模式下随机变化：\n- 系统有 $p$ 的概率处于热模式，每个候选段产生扫描成本 $c_{\\mathrm{hot}}$。\n- 系统有 $1-p$ 的概率处于冷模式，每个候选段产生扫描成本 $c_{\\mathrm{cold}}$。\n\n假设 $p = \\frac{1}{3}$，$c_{\\mathrm{hot}} = 2$，$c_{\\mathrm{cold}} = \\frac{1}{2}$。段大小和所有设备流量均已归一化，因此上述单位是无量纲的。\n\n从上述定义和基本概率（特别是条件期望和伯努利过程中首次成功前的试验次数期望）出发，推导出每单位新用户数据的预期总设备流量 $E[W(u_t)]$ 作为 $u_t$ 的函数，其中期望是针对工作负载模式的随机性计算的。然后，确定使 $E[W(u_t)]$ 最小化的 $u_t \\in (0,1)$ 的值。将你的最终答案，即最优阈值 $u_t^{\\star}$，表示为单个封闭形式的表达式。", "solution": "目标是找到最优利用率阈值 $u_t^{\\star}$，以最小化每单位新用户数据的预期总设备流量，记为 $E[W(u_t)]$。这个量通常被称为写放大因子。\n\n首先，我们建立设备流量各组成部分之间的关系。总设备流量是写入新用户数据的流量和清理过程产生的流量之和。问题将写入新用户数据的流量归一化为每单位数据1单位流量。要写入1单位的新数据，需要1单位的可用空间。这个空间必须由清理器回收。每单位新数据的总流量 $W$ 可以表示为：\n$$\nW = 1 + (\\text{Cleaning traffic incurred to free } 1 \\text{ unit of space})\n$$\n清理流量本身由两部分组成：扫描合格段和清理一个段的读/写操作。\n\n设 $U$ 是表示段利用率的随机变量，且 $U \\sim \\text{Uniform}[0, 1]$。\n如果一个段的利用率低于或等于阈值 $u_t$，则该段符合清理条件，其中 $u_t \\in (0, 1)$。随机选择一个段符合清理条件的概率是：\n$$\nP(U \\le u_t) = \\int_0^{u_t} 1 \\, du = u_t\n$$\n被选中进行清理的段的利用率，我们称之为 $U_s$，服从以 $U \\le u_t$ 为条件的 $U$ 的分布。该条件分布是在 $[0, u_t]$ 上的均匀分布，其概率密度函数为 $f_{U_s}(u) = \\frac{1}{u_t}$，其中 $u \\in [0, u_t]$。\n\n一个被清理段的期望利用率是：\n$$\nE[U_s] = E[U | U \\le u_t] = \\int_0^{u_t} u \\cdot f_{U_s}(u) \\, du = \\int_0^{u_t} u \\frac{1}{u_t} \\, du = \\frac{1}{u_t} \\left[ \\frac{u^2}{2} \\right]_0^{u_t} = \\frac{u_t}{2}\n$$\n清理一个利用率为 $u$ 的段可以释放 $1-u$ 单位的空间。每个被清理段释放的期望空间是：\n$$\nE[\\text{Space Freed}] = E[1 - U_s] = 1 - E[U_s] = 1 - \\frac{u_t}{2}\n$$\n清理一个利用率为 $u$ 的段的流量成本是 $1$（用于读取该段）加上 $u$（用于写入有效数据）。清理一个段的期望读/写流量是：\n$$\nE[\\text{Read/Write Traffic}] = E[1 + U_s] = 1 + E[U_s] = 1 + \\frac{u_t}{2}\n$$\n接下来，我们考虑扫描成本。寻找一个合格段的过程是一系列伯努利试验，成功概率为 $p_{succ} = u_t$。找到第一次成功所需的试验次数（即需要扫描的段数）的期望值是几何分布的均值，即 $1/p_{succ} = 1/u_t$。\n每个候选段的扫描成本是 $c_m$，其中 $m \\in \\{\\text{hot}, \\text{cold}\\}$。在给定工作负载模式 $m$ 的条件下，找到一个合格段的期望扫描流量是：\n$$\nE[\\text{Scanning Traffic} | m] = \\frac{1}{u_t} \\cdot c_m = \\frac{c_m}{u_t}\n$$\n在给定模式 $m$ 的条件下，清理一个段的预期总流量是预期扫描流量和读/写流量之和：\n$$\nC_{seg}(u_t, m) = E[\\text{Scanning Traffic} | m] + E[\\text{Read/Write Traffic}] = \\frac{c_m}{u_t} + 1 + \\frac{u_t}{2}\n$$\n为了释放1单位的空间，必须清理的段的期望数量是：\n$$\nN_{seg} = \\frac{1}{E[\\text{Space Freed}]} = \\frac{1}{1 - \\frac{u_t}{2}}\n$$\n在给定模式 $m$ 的条件下，为释放1单位空间而产生的清理流量是段的数量与每个段的成本的乘积：\n$$\nT_{clean}(u_t, m) = N_{seg} \\cdot C_{seg}(u_t, m) = \\frac{1}{1 - \\frac{u_t}{2}} \\left( \\frac{c_m}{u_t} + 1 + \\frac{u_t}{2} \\right)\n$$\n每单位新数据的总流量（写放大），在给定模式 $m$ 的条件下，是 $W(u_t, m) = 1 + T_{clean}(u_t, m)$：\n$$\nW(u_t, m) = 1 + \\frac{\\frac{c_m}{u_t} + 1 + \\frac{u_t}{2}}{1 - \\frac{u_t}{2}} = \\frac{(1 - \\frac{u_t}{2}) + (\\frac{c_m}{u_t} + 1 + \\frac{u_t}{2})}{1 - \\frac{u_t}{2}} = \\frac{2 + \\frac{c_m}{u_t}}{1 - \\frac{u_t}{2}}\n$$\n问题要求计算这个量在所有工作负载模式上的期望值。设成本的随机变量为 $C_M$。$C_M = c_{\\mathrm{hot}}$ 的概率为 $p$， $C_M = c_{\\mathrm{cold}}$ 的概率为 $1-p$。期望成本为 $E[C_M] = p \\cdot c_{\\mathrm{hot}} + (1-p) \\cdot c_{\\mathrm{cold}}$。我们将这个平均成本记为 $\\bar{c}$。\n使用全期望定律：\n$$\nE[W(u_t)] = p \\cdot W(u_t, \\text{hot}) + (1-p) \\cdot W(u_t, \\text{cold})\n$$\n$$\nE[W(u_t)] = p \\left(\\frac{2 + \\frac{c_{\\mathrm{hot}}}{u_t}}{1 - \\frac{u_t}{2}}\\right) + (1-p) \\left(\\frac{2 + \\frac{c_{\\mathrm{cold}}}{u_t}}{1 - \\frac{u_t}{2}}\\right) = \\frac{2p + \\frac{p c_{\\mathrm{hot}}}{u_t} + 2(1-p) + \\frac{(1-p)c_{\\mathrm{cold}}}{u_t}}{1 - \\frac{u_t}{2}}\n$$\n$$\nE[W(u_t)] = \\frac{2 + \\frac{p c_{\\mathrm{hot}} + (1-p)c_{\\mathrm{cold}}}{u_t}}{1 - \\frac{u_t}{2}} = \\frac{2 + \\frac{\\bar{c}}{u_t}}{1 - \\frac{u_t}{2}}\n$$\n现在，代入给定的数值：$p = 1/3$，$c_{\\mathrm{hot}} = 2$，$c_{\\mathrm{cold}} = 1/2$。\n$$\n\\bar{c} = \\frac{1}{3}(2) + \\left(1-\\frac{1}{3}\\right)\\left(\\frac{1}{2}\\right) = \\frac{2}{3} + \\frac{2}{3} \\cdot \\frac{1}{2} = \\frac{2}{3} + \\frac{1}{3} = 1\n$$\n因此，需要最小化的函数是：\n$$\nf(u_t) = E[W(u_t)] = \\frac{2 + \\frac{1}{u_t}}{1 - \\frac{u_t}{2}} = \\frac{\\frac{2u_t+1}{u_t}}{\\frac{2-u_t}{2}} = \\frac{2(2u_t+1)}{u_t(2-u_t)} = \\frac{4u_t+2}{2u_t - u_t^2}\n$$\n为了找到最小值，我们将 $f(u_t)$ 对 $u_t$求导，并令导数为0。使用商法则，其中 $g(u_t) = 4u_t+2$，$h(u_t) = 2u_t - u_t^2$：\n$$\n\\frac{df}{du_t} = \\frac{(4)(2u_t - u_t^2) - (4u_t+2)(2 - 2u_t)}{(2u_t - u_t^2)^2}\n$$\n令分子为零以找到临界点：\n$$\n4(2u_t - u_t^2) - (4u_t+2)(2 - 2u_t) = 0\n$$\n$$\n(8u_t - 4u_t^2) - (8u_t - 8u_t^2 + 4 - 4u_t) = 0\n$$\n$$\n8u_t - 4u_t^2 - (4u_t - 8u_t^2 + 4) = 0\n$$\n$$\n8u_t - 4u_t^2 - 4u_t + 8u_t^2 - 4 = 0\n$$\n$$\n4u_t^2 + 4u_t - 4 = 0\n$$\n$$\nu_t^2 + u_t - 1 = 0\n$$\n我们解这个关于 $u_t$ 的二次方程：\n$$\nu_t = \\frac{-1 \\pm \\sqrt{1^2 - 4(1)(-1)}}{2(1)} = \\frac{-1 \\pm \\sqrt{5}}{2}\n$$\n由于阈值 $u_t$ 必须在区间 $(0, 1)$ 内，我们取正根：\n$$\nu_t^{\\star} = \\frac{-1 + \\sqrt{5}}{2}\n$$\n$\\sqrt{5}$ 的值约等于 $2.236$，所以 $u_t^{\\star} \\approx \\frac{-1+2.236}{2} \\approx 0.618$，该值位于定义域 $(0,1)$ 内。二阶导数检验或一阶导数的符号分析表明这是一个最小值。一阶导数的分子 $4(u_t^2 + u_t - 1)$ 是一个开口向上的抛物线，在两根之间为负，在其他地方为正。因此，函数 $f(u_t)$ 在 $u_t^{\\star}$ 之前递减，之后递增，从而证实了这是一个最小值。", "answer": "$$\\boxed{\\frac{-1 + \\sqrt{5}}{2}}$$", "id": "3654742"}, {"introduction": "一个健壮的文件系统必须能够抵御崩溃。本练习将探讨一个现实中的故障场景——“撕裂的检查点”（torn checkpoint），并要求你使用概率建模来计算成功恢复的可能性。这项练习强调，系统设计不仅关乎正常情况下的性能，更关乎面对失败时的恢复能力 [@problem_id:3654820]。", "problem": "一个存储系统使用日志结构文件系统（LFS）。该系统定期写入一个检查点区域，以捕获内存中的映射元数据。每个检查点都会被复制并通过校验和进行保护，但电源故障可能会产生一个撕裂的检查点（torn checkpoint），导致最新的检查点无效。考虑以下故障场景。\n\n在写入最新检查点期间发生电源故障，因此该检查点的两个副本都未能通过校验和验证（即一个撕裂的检查点）。因此，恢复必须从前一个有效检查点开始。设从前一个有效检查点到崩溃之间经过的时间为 $\\Delta$。在此时间间隔 $(0,\\Delta]$ 内，LFS已将段（segment）附加到日志中。\n\n恢复过程如下：\n- 通过验证校验和来定位最后一个有效检查点，由于最新的检查点是撕裂的，因此回退到前一个有效检查点。\n- 从该检查点开始执行前滚扫描（roll-forward scan）：对于每个完全写入的段，系统会验证一个带校验和的段摘要块（segment-summary block），并重放其中包含的更新；在崩溃点处的部分写入的尾部，摘要的验证预计会失败，这标志着停止点。如果尾部的摘要虚假地显示为有效，恢复过程将错误地解释尾部，并被视为失败。\n\n假设以下概率模型基于标准的排队论和可靠性假设：\n- 在 $(0,\\Delta]$ 时间内完成的完全写入段的数量是一个泊松随机变量，其单位时间速率为 $\\lambda$，因此平均数量为 $\\lambda \\Delta$。\n- 每个完全写入段的摘要块独立地以概率 $q$ 成功通过验证。\n- 最终部分写入的尾部的摘要以概率 $\\beta$ 虚假地显示为有效；恢复要求此事件不发生。\n\n将 $p_{rf}$ 定义为在前述撕裂检查点场景下，前滚成功的概率。从这些假设以及泊松过程和独立伯努利试验的第一性原理出发，推导出一个关于 $\\lambda$、$\\Delta$、$q$ 和 $\\beta$ 的 $p_{rf}$ 的闭式解析表达式。将你的最终答案表示为单个简化表达式。不需要进行数值计算，也不需要单位。", "solution": "设 $p_{rf}$ 为前滚恢复过程成功的概率。根据问题描述，成功的恢复需要两个独立事件同时发生：\n1. 事件 $A$：在时间间隔 $(0, \\Delta]$ 内完成的所有完全写入段的段摘要块都成功通过验证。\n2. 事件 $B$：最终的部分写入的尾部段的摘要*没有*虚假地显示为有效。\n\n问题陈述说明这些事件是独立的。因此，成功的总概率是这两个事件概率的乘积：\n$$p_{rf} = P(A) \\times P(B)$$\n\n我们首先确定事件 $B$ 的概率。问题陈述说明尾部的摘要以概率 $\\beta$ 虚假地显示为有效。为了使恢复成功，此事件必须不发生。其互补事件（摘要如预期一样验证失败）的概率是：\n$$P(B) = 1 - \\beta$$\n\n现在，我们来确定事件 $A$ 的概率。在区间 $(0, \\Delta]$ 内完全写入的段的数量不是一个固定的数，而是一个随机变量。我们用 $N$ 表示这个随机变量。问题陈述说明 $N$ 服从均值为 $\\lambda \\Delta$ 的泊松分布。$N$ 的概率质量函数（PMF）由下式给出：\n$$P(N=k) = \\frac{(\\lambda\\Delta)^{k} \\exp(-\\lambda\\Delta)}{k!} \\quad \\text{for } k = 0, 1, 2, \\dots$$\n其中 $k$ 是完全写入段的数量。\n\n为了求出事件 $A$ 的概率，我们必须考虑 $N$ 的所有可能值。我们可以使用全概率公式，对所有可能的段数 $k$ 进行求和：\n$$P(A) = \\sum_{k=0}^{\\infty} P(A | N=k) P(N=k)$$\n$P(A | N=k)$ 这一项是在有 $k$ 个完全写入段的条件下，所有段摘要都成功验证的条件概率。问题陈述说明每个摘要块独立地以概率 $q$ 通过验证。对于 $k$ 个独立的段，它们全部通过验证的概率是它们各自概率的乘积：\n$$P(A | N=k) = q^k$$\n\n现在，我们可以将此结果和 $N$ 的 PMF 代回到 $P(A)$ 的求和式中：\n$$P(A) = \\sum_{k=0}^{\\infty} (q^k) \\left( \\frac{(\\lambda\\Delta)^{k} \\exp(-\\lambda\\Delta)}{k!} \\right)$$\n我们可以把不依赖于求和索引 $k$ 的项提取出来：\n$$P(A) = \\exp(-\\lambda\\Delta) \\sum_{k=0}^{\\infty} q^k \\frac{(\\lambda\\Delta)^{k}}{k!}$$\n我们合并求和式内部以 $k$ 为幂的项：\n$$P(A) = \\exp(-\\lambda\\Delta) \\sum_{k=0}^{\\infty} \\frac{(q\\lambda\\Delta)^{k}}{k!}$$\n该求和项是指数函数的麦克劳林级数展开式，$\\sum_{j=0}^{\\infty} \\frac{x^j}{j!} = \\exp(x)$。在我们的例子中，参数 $x$ 是 $q\\lambda\\Delta$。因此，该和式的结果为：\n$$\\sum_{k=0}^{\\infty} \\frac{(q\\lambda\\Delta)^{k}}{k!} = \\exp(q\\lambda\\Delta)$$\n将此结果代回到 $P(A)$ 的表达式中：\n$$P(A) = \\exp(-\\lambda\\Delta) \\exp(q\\lambda\\Delta)$$\n使用指数的性质 $\\exp(x)\\exp(y) = \\exp(x+y)$，我们得到：\n$$P(A) = \\exp(-\\lambda\\Delta + q\\lambda\\Delta) = \\exp(\\lambda\\Delta(q-1))$$\n\n最后，我们结合事件 $A$ 和事件 $B$ 的概率，求出前滚成功恢复的总概率 $p_{rf}$：\n$$p_{rf} = P(A) \\times P(B) = \\exp(\\lambda\\Delta(q-1)) \\times (1 - \\beta)$$\n这就得出了 $p_{rf}$ 作为给定参数函数的闭式解析表达式。", "answer": "$$\\boxed{(1 - \\beta) \\exp(\\lambda \\Delta (q - 1))}$$", "id": "3654820"}]}