{"hands_on_practices": [{"introduction": "理论知识只有在实践中才能真正被掌握。这项练习将让你扮演操作系统的内存管理器，通过手动追踪一系列的分配和释放请求，来区分“首次适应”（first-fit）和“再次适应”（next-fit）这两种分配策略。通过这个过程，你将亲身体会到，搜索策略中的微小差异是如何导致截然不同的内存布局，这是理解和设计高效分配器的关键一步。[@problem_id:3653441]", "problem": "考虑一个管理连续堆的显式空闲链表分配器。该空闲链表是一个严格按地址递增顺序维护的单向链表。该分配器在释放内存时会与左右相邻块进行立即合并，并且仅当分配后剩余部分至少为最小块大小阈值 $m$（一个模拟头部/尾部和最小有效载荷要求的正常数）时，才会在分配时分割一个空闲块。下面陈述的所有块大小均已包含任何分配器元数据；它们是从空闲链表中取出或返回到空闲链表的精确大小。所有大小都是固定字长的倍数，且请求永远不会违反内存对齐。该分配器在空闲链表上使用两种搜索策略之一：首次适配或下次适配。首次适配总是从头部开始扫描。下次适配维护一个漫游指针，从上次搜索结束的节点恢复搜索（需要时回绕到头部）；在任何分配之前，初始漫游指针位置在头部；从一个被分割的空闲块成功分配后，漫游指针被设置为剩余块；如果不存在剩余部分，则漫游指针指向被消耗块在空闲链表中的后继者。\n\n假设堆最初由一个大小为 $12n$ 字节的单个空闲块组成，起始地址为 $0$，结束地址为 $12n$。考虑以下操作序列，其中每个 $\\mathrm{malloc}$ 请求的块大小与陈述的完全一致，每个 $\\mathrm{free}$ 精确地释放由指定操作先前分配的块。这些操作是：\n\n- 操作 $1$: $\\mathrm{malloc}(3n)$ 产生块 $B_1$。\n- 操作 $2$: $\\mathrm{malloc}(4n)$ 产生块 $B_2$。\n- 操作 $3$: $\\mathrm{malloc}(2n)$ 产生块 $B_3$。\n- 操作 $4$: $\\mathrm{free}(B_2)$。\n- 操作 $5$: $\\mathrm{malloc}(3n)$ 产生块 $B_4$。\n- 操作 $6$: $\\mathrm{free}(B_1)$。\n- 操作 $7$: $\\mathrm{free}(B_3)$。\n\n我们得知，在操作 $7$ 之后，观测到的空闲链表（请记住，它按地址递增顺序排列）恰好包含两个空闲块：第一个大小为 $3n$，按地址顺序其后是第二个大小为 $6n$ 的块。\n\n在上述分配器模型下，以下哪个陈述是正确的？您的答案应指出哪种或哪些策略可以通过该操作序列产生观测到的空闲链表形态，在给定的下次适配漫游指针语义下，这种识别是否是唯一的，以及为了使该观测能够实现，关于 $n$（相对于 $m$）的充要条件是什么。\n\nA. 对于所有满足 $n \\ge m$ 的 $n$，首次适配和下次适配都可以产生观测到的最终空闲链表；因此，从该观测中无法唯一识别分配策略。\n\nB. 只有首次适配可以产生观测到的最终空闲链表，并且当且仅当 $n \\ge m$ 时才能如此；在陈述的下次适配漫游指针语义下，此识别是唯一的，因为下次适配无法产生该观测。\n\nC. 对于任何 $n$，只有下次适配可以产生观测到的最终空闲链表；首次适配不能。\n\nD. 对于任何 $n$，两种策略都不能产生观测到的最终空闲链表；无论 $n$ 为何值，该观测都与分配器模型矛盾。", "solution": "该问题陈述是计算系统领域中一个定义良好且自成体系的练习，具体涉及动态内存分配器的行为。它在科学上基于已建立的计算机科学原理，其术语的定义足够精确，可以进行形式化分析。因此，该问题是有效的。\n\n让我们用一个元组 `[地址, 大小]` 来表示一个内存块。用括号括起来的此类元组列表，例如 `(...)`，将代表空闲链表，该链表按地址递增顺序维护。\n\n堆的初始状态是一个位于地址 $0$、大小为 $12n$ 的单个空闲块。\n初始堆：`[0, 12n]`\n初始空闲链表 (FL)：`( [0, 12n] )`\n\n我们现在将为两种策略分别追踪操作序列：首次适配 (First-Fit, FF) 和下次适配 (Next-Fit, NF)。\n\n### 首次适配 (FF) 策略分析\n\nFF 策略总是从空闲链表的头部开始搜索合适的空闲块。\n\n**初始状态：** FL = `( [0, 12n] )`。\n\n**操作 1: `\\mathrm{malloc}(3n)` $\\to B_1$**\nFF 找到块 `[0, 12n]`。剩余部分为 $12n - 3n = 9n$。假设发生分割（要求 $9n \\ge m$），块 $B_1$ 在 `[0, 3n]` 处被分配。\n状态：FL = `( [3n, 9n] )`。$B_1$ 为 `[0, 3n]`。\n\n**操作 2: `\\mathrm{malloc}(4n)` $\\to B_2$**\nFF 找到块 `[3n, 9n]`。剩余部分为 $9n - 4n = 5n$。假设发生分割（要求 $5n \\ge m$），块 $B_2$ 在 `[3n, 4n]` 处被分配。\n状态：FL = `( [7n, 5n] )`。$B_2$ 为 `[3n, 4n]`。\n\n**操作 3: `\\mathrm{malloc}(2n)` $\\to B_3$**\nFF 找到块 `[7n, 5n]`。剩余部分为 $5n - 2n = 3n$。假设发生分割（要求 $3n \\ge m$），块 $B_3$ 在 `[7n, 2n]` 处被分配。\n状态：FL = `( [9n, 3n] )`。$B_3$ 为 `[7n, 2n]`。\n\n**操作 4: `\\mathrm{free}(B_2)`**\n位于 `[3n, 4n]` 的 $B_2$ 被释放。其左相邻块（位于 `[0, 3n]` 的 `B_1`）和右相邻块（位于 `[7n, 2n]` 的 `B_3`）都已被分配。因此，不发生合并。新的空闲块按地址顺序插入到空闲链表中。\n状态：FL = `( [3n, 4n], [9n, 3n] )`。\n\n**操作 5: `\\mathrm{malloc}(3n)` $\\to B_4$**\nFF 从 FL 的头部 `[3n, 4n]` 开始。这个块足够大。剩余部分为 $4n - 3n = n$。这里的`当且仅当`分割规则至关重要。\n*   **情况 1: $n \\ge m$。** 发生分割。$B_4$ 在 `[3n, 3n]` 处被分配。创建了一个新的空闲块，即剩余部分 `[6n, n]`。\n    FL 中的块 `[3n, 4n]` 被 `[6n, n]` 替换。\n    状态：FL = `( [6n, n], [9n, 3n] )`。$B_4$ 为 `[3n, 3n]`。\n*   **情况 2: $n  m$。** 不发生分割。整个块 `[3n, 4n]` 被分配给 $B_4$（产生了大小为 $n$ 的内部碎片）。\n    状态：FL = `( [9n, 3n] )`。$B_4$ 为 `[3n, 4n]`。\n\n我们对两种情况继续进行追踪。\n\n**操作 6: `\\mathrm{free}(B_1)`**\n位于 `[0, 3n]` 的 $B_1$ 被释放。\n*   **情况 1 ($n \\ge m$):** `[0, 3n]` 的右相邻块是位于 `[3n, 3n]` 的 $B_4$，它已被分配。不合并。新的空闲块 `[0, 3n]` 被添加到 FL 的头部。\n    状态：FL = `( [0, 3n], [6n, n], [9n, 3n] )`。\n*   **情况 2 ($n  m$):** `[0, 3n]` 的右相邻块是位于 `[3n, 4n]` 的 $B_4$，它已被分配。不合并。新的空闲块 `[0, 3n]` 被添加到 FL 的头部。\n    状态：FL = `( [0, 3n], [9n, 3n] )`。\n\n**操作 7: `\\mathrm{free}(B_3)`**\n位于 `[7n, 2n]` 的 $B_3$ 被释放。\n*   **情况 1 ($n \\ge m$):** 我们检查 `[7n, 2n]` 在堆中的相邻块。\n    -   左相邻块：在地址 $7n - n = 6n$ 处，我们有空闲块 `[6n, n]`。发生合并。新的块是 `[6n, n+2n] = [6n, 3n]`。\n    -   这个新块的右相邻块（即 $B_3$ 的原始右相邻块）：在地址 $7n+2n = 9n$ 处，我们有空闲块 `[9n, 3n]`。发生合并。最终合并的块是 `[6n, 3n+3n] = [6n, 6n]`。\n    此操作之前的 FL 是 `( [0, 3n], [6n, n], [9n, 3n] )`。块 `[6n, n]` 和 `[9n, 3n]` 被单个块 `[6n, 6n]` 替换。\n    **最终 FL (FF, $n \\ge m$): `( [0, 3n], [6n, 6n] )`**。这与观测到的状态相符：两个大小分别为 $3n$ 和 $6n$ 的块。只有当所有分割都如假设那样发生时，才会走这条路径，这要求 $9n \\ge m$、$5n \\ge m$、$3n \\ge m$ 和 $n \\ge m$。其充要条件是 $n \\ge m$。\n\n*   **情况 2 ($n  m$):** 我们检查 `[7n, 2n]` 的相邻块。\n    -   左相邻块：在地址 $3n$ 处，我们有位于 `[3n, 4n]` 的 $B_4$，它已被分配。不发生左合并。\n    -   右相邻块：在地址 $9n$ 处，我们有空闲块 `[9n, 3n]`。发生合并。新的块是 `[7n, 2n+3n] = [7n, 5n]`。\n    此操作之前的 FL 是 `( [0, 3n], [9n, 3n] )`。块 `[9n, 3n]` 被 `[7n, 5n]` 替换。\n    **最终 FL (FF, $n  m$): `( [0, 3n], [7n, 5n] )`**。这与观测不符。\n\n**FF 的结论：** 当且仅当 $n \\ge m$ 时，首次适配策略会产生观测到的最终空闲链表。\n\n### 下次适配 (NF) 策略分析\n\nNF 策略维护一个`漫游`指针，并从`漫游`指针的位置开始搜索。最初，漫游指针指向空闲链表的头部。\n\n**初始状态：** FL = `( [0, 12n] )`。漫游指针指向 `[0, 12n]`。\n\n**操作 1: `\\mathrm{malloc}(3n)` $\\to B_1$**\nNF 找到 `[0, 12n]`。假设分割（$9n \\ge m$），$B_1$ 为 `[0, 3n]`。剩余部分为 `[3n, 9n]`。\n状态：FL = `( [3n, 9n] )`。漫游指针更新为指向剩余部分，即 `[3n, 9n]`。\n\n**操作 2: `\\mathrm{malloc}(4n)` $\\to B_2$**\nNF 从 `[3n, 9n]` 开始并找到它。假设分割（$5n \\ge m$），$B_2$ 为 `[3n, 4n]`。剩余部分为 `[7n, 5n]`。\n状态：FL = `( [7n, 5n] )`。漫游指针更新为指向剩余部分，即 `[7n, 5n]`。\n\n**操作 3: `\\mathrm{malloc}(2n)` $\\to B_3$**\nNF 从 `[7n, 5n]` 开始并找到它。假设分割（$3n \\ge m$），$B_3$ 为 `[7n, 2n]`。剩余部分为 `[9n, 3n]`。\n状态：FL = `( [9n, 3n] )`。漫游指针更新为指向剩余部分，即 `[9n, 3n]`。\n\n**操作 4: `\\mathrm{free}(B_2)`**\n位于 `[3n, 4n]` 的 $B_2$ 被释放。不发生合并。`free` 操作不影响漫游指针。\n状态：FL = `( [3n, 4n], [9n, 3n] )`。漫游指针保持在 `[9n, 3n]`。\n\n**操作 5: `\\mathrm{malloc}(3n)` $\\to B_4$**\nNF 从漫游指针处 `[9n, 3n]` 开始搜索。这个块与大小为 $3n$ 的请求完美匹配。剩余部分为 0，小于 $m$（一个正的常数），因此不发生分割。该块被完全消耗。\n$B_4$ 在 `[9n, 3n]` 处被分配。先前的空闲块 `[9n, 3n]` 从 FL 中移除。\n漫游指针的更新规则规定，对于一个被消耗的块，漫游指针移动到它在空闲链表中的后继者。空闲链表是 `( [3n, 4n], [9n, 3n] )`。尾部 `[9n, 3n]` 的后继者通过回绕被认为是头部 `[3n, 4n]`。\n状态：FL = `( [3n, 4n] )`。漫游指针指向 `[3n, 4n]`。$B_4$ 为 `[9n, 3n]`。\n\n这个选择是确定性的。NF 必须选择 `[9n, 3n]`，因为这是它遇到的第一个足够大的块。它不会回绕去寻找 `[3n, 4n]`。在这一步，这从根本上将其行为与 FF 区分开来。\n\n**操作 6: `\\mathrm{free}(B_1)`**\n位于 `[0, 3n]` 的 $B_1$ 被释放。它的右相邻块是 `[3n, 4n]`，它是空闲的。发生合并。形成了一个新的空闲块 `[0, 7n]`。漫游指针之前指向 `[3n, 4n]`，它现在是新的更大块的一部分。可以合理地假设漫游指针现在指向 `[0, 7n]`。\n状态：FL = `( [0, 7n] )`。\n\n**操作 7: `\\mathrm{free}(B_3)`**\n位于 `[7n, 2n]` 的 $B_3$ 被释放。它的左相邻块是空闲块 `[0, 7n]`。发生合并。形成了一个新的空闲块 `[0, 9n]`。$B_3$ 的右相邻块是位于 `[9n, 3n]` 的 $B_4$，它已被分配。\n**最终 FL (NF): `( [0, 9n] )`**。\n\n这个最终状态包含一个大小为 $9n$ 的单个空闲块。这与观测到的状态不符。这个结果是稳健的，即使对 $m$ 的不同假设会阻止早期步骤中的分割，它也不会改变，因为漫游指针的位置仍然会导致它为 `B_4` 选择最后一个空闲块。\n\n**NF 的结论：** 下次适配策略无法产生观测到的最终空闲链表。\n\n### 选项评估\n\n*   **A. 对于所有满足 $n \\ge m$ 的 $n$，首次适配和下次适配都可以产生观测到的最终空闲链表；因此，从该观测中无法唯一识别分配策略。**\n    这是 **不正确** 的。我们的分析表明，下次适配策略无法产生观测到的状态。\n\n*   **B. 只有首次适配可以产生观测到的最终空闲链表，并且当且仅当 $n \\ge m$ 时才能如此；在陈述的下次适配漫游指针语义下，此识别是唯一的，因为下次适配无法产生该观测。**\n    这是 **正确** 的。我们的分析得出结论，FF 当且仅当 $n \\ge m$ 时产生该状态，而 NF 在任何情况下都无法产生该状态。因此，观测到这个最终状态唯一地将策略识别为首次适配，并对 $n$ 相对于 $m$ 设定了一个条件。\n\n*   **C. 对于任何 $n$，只有下次适配可以产生观测到的最终空闲链表；首次适配不能。**\n    这是 **不正确** 的。这与我们的发现相反。\n\n*   **D. 对于任何 $n$，两种策略都不能产生观测到的最终空闲链表；无论 $n$ 为何值，该观测都与分配器模型矛盾。**\n    这是 **不正确** 的。首次适配在 $n \\ge m$ 的条件下可以产生观测到的状态。", "answer": "$$\\boxed{B}$$", "id": "3653441"}, {"introduction": "在理解了不同分配策略的工作流程后，下一个关键步骤是量化它们的性能影响。本练习通过一个精心设计的思想实验，揭示了“最佳适应”（best-fit）策略在特定情况下的退化行为，即产生大量微小的、无法使用的内存碎片。通过推导内部碎片 $F_{\\text{int}}$ 和外部碎片 $F_{\\text{ext}}$ 的表达式，你将建立起对碎片化问题来源的深刻直觉，并理解内存分配中不存在“完美”策略的现实。[@problem_id:3653485]", "problem": "一个操作系统使用基于链表的空闲空间管理器，采用最佳适配（best-fit）分配策略和块分割，但在关注的时间段内不进行合并。该分配器实现大小类别分箱，箱宽度为 $b$ 字节：任何大小为 $x$ 的请求在搜索空闲列表前，其大小都会被向上取整至 $\\lceil x / b \\rceil \\cdot b$ 字节。空闲列表以链表形式维护，最佳适配策略会扫描该列表以找到大小至少为向上取整后大小的最小空闲块。当一个空闲块大于所需大小时，它会被分割成一个大小为向上取整后大小的已分配部分和一个剩余的空闲碎片。小于 $b$ 字节的剩余空闲碎片无法满足此序列中的任何请求，因为每个向上取整后的分配大小都至少为 $b$ 字节。假设此问题的元数据开销可忽略不计，并且所有地址都完美对齐以允许精确分割。\n\n为了展示当请求大小落在箱边界附近时，最佳适配策略如何退化成许多微小的碎片，请考虑以下分配模式和初始状态。\n\n- 初始状态：堆的空闲列表恰好包含 $n$ 个空闲块，每个大小为 $b + \\varepsilon$ 字节，其中 $0  \\varepsilon  b$。这 $n$ 个空闲块被已分配的哨兵块隔开，因此没有两个空闲块是相邻的；故即使启用了合并功能，也不可能进行合并。没有其他空闲块。\n- 分配序列：发出 $n$ 个分配请求，每个大小为 $r = b - \\delta$ 字节，其中 $0  \\delta  b$。根据分箱规则，每个请求的大小都被向上取整至 $b$ 字节。\n\n使用标准定义：\n- 内部碎片 $F_{\\text{int}}$ 是指由于向上取整而在已分配块内部浪费的总字节数（即，已分配大小减去请求大小）。\n- 外部碎片 $F_{\\text{ext}}$ 是指无法用于满足后续至少为 $b$ 字节请求的空闲内存的总字节数（即，严格小于 $b$ 字节的空闲碎片的大小总和）。\n\n在处理完所有 $n$ 个请求后，推导 $F_{\\text{int}}$ 和 $F_{\\text{ext}}$ 关于 $n$、$b$、$\\delta$ 和 $\\varepsilon$ 的闭式表达式。以字节为单位表示 $F_{\\text{int}}$ 和 $F_{\\text{ext}}$，并将最终结果以单个行向量中的一对数值形式给出。无需取整；请给出精确的符号表达式。", "solution": "我们从分配器的行为和碎片的正式定义出发进行分析。\n\n在此情境下的基本定义和规则如下：\n- 大小为 $x$ 的请求在分配前向上取整至 $\\lceil x / b \\rceil \\cdot b$ 字节。\n- 最佳适配选择大小至少为向上取整后大小的最小空闲块，然后将任何多余的部分分割成一个剩余的空闲碎片。\n- 内部碎片 $F_{\\text{int}}$ 是所有分配中（向上取整后的大小）-（请求的大小）的总和。\n- 外部碎片 $F_{\\text{ext}}$ 是严格小于 $b$ 字节的空闲碎片的总大小，因为这样的碎片无法满足任何向上取整后大小至少为 $b$ 字节的请求。\n\n初始状态和序列：\n- 空闲列表恰好包含 $n$ 个空闲块，每个大小为 $b + \\varepsilon$，其中 $0  \\varepsilon  b$。\n- 有 $n$ 个请求，每个大小为 $r = b - \\delta$，其中 $0  \\delta  b$。\n\n第 1 步：向上取整行为和每个请求的内部碎片。\n- 对于大小为 $r = b - \\delta$ 的请求，向上取整后的分配大小为\n$$\n\\lceil r / b \\rceil \\cdot b \\;=\\; \\lceil (b - \\delta)/b \\rceil \\cdot b \\;=\\; \\lceil 1 - \\delta/b \\rceil \\cdot b \\;=\\; 1 \\cdot b \\;=\\; b,\n$$\n因为 $0  \\delta  b$ 意味着 $0  \\delta/b  1$，所以 $1 - \\delta/b \\in (0,1)$，其向上取整值为 $1$。\n- 因此，每个请求的内部碎片为\n$$\nb - r \\;=\\; b - (b - \\delta) \\;=\\; \\delta.\n$$\n- 对于 $n$ 个请求，总内部碎片为\n$$\nF_{\\text{int}} \\;=\\; n \\cdot \\delta.\n$$\n\n第 2 步：最佳适配选择和剩余碎片。\n- 在每次分配时，空闲列表包含一个或多个大小为 $b + \\varepsilon$ 的块。所需的向上取整后大小为 $b$，因此最佳适配将选择其中一个大小为 $b + \\varepsilon$ 的块（它们是能满足要求的最小块，并且所有这些块的大小都相等）。\n- 分割一个 $b + \\varepsilon$ 大小的块以满足一个 $b$ 字节的分配，会留下一个大小为\n$$\n(b + \\varepsilon) - b \\;=\\; \\varepsilon.\n$$\n的剩余空闲碎片。\n- 根据假设，$0  \\varepsilon  b$，因此每个剩余碎片都严格小于 $b$，从而无法满足任何向上取整后的请求，因为每个向上取整后的请求大小都至少为 $b$ 字节。因此，每个剩余碎片都完全构成外部碎片。\n\n第 3 步：$n$ 次分配后的总外部碎片。\n- $n$ 次分配中的每一次都恰好产生一个大小为 $\\varepsilon$ 的剩余空闲碎片。\n- 没有其他空闲块，因为最初的 $n$ 个空闲块被 $n$ 次分配相继消耗掉了。合并功能被禁用，且空闲块被哨兵块隔开，因此没有剩余碎片会合并。\n- 因此，总外部碎片为\n$$\nF_{\\text{ext}} \\;=\\; n \\cdot \\varepsilon.\n$$\n\n第 4 步：整理最终表达式。\n- 内部碎片：$F_{\\text{int}} = n \\delta$ 字节。\n- 外部碎片：$F_{\\text{ext}} = n \\varepsilon$ 字节。\n\n这些是精确的符号表达式，它们量化了当从仅比 $b$ 稍大的空闲块中，为 $n$ 个向上取整至 $b$ 的近边界请求提供服务时，最佳适配策略如何退化成许多大小为 $\\varepsilon$ 的微小碎片。", "answer": "$$\\boxed{\\begin{pmatrix} n\\delta  n\\varepsilon \\end{pmatrix}}$$", "id": "3653485"}, {"introduction": "从分析到实现是掌握复杂系统的必经之路。这项最终的动手实践要求你编写一个内存分配模拟器，以直接观察“合并”（coalescing）技术的效果。通过实现并比较一个启用合并和另一个禁用合并的分配器，你将具体地看到外部碎片是如何累积并破坏内存使用效率的，从而深刻理解合并技术在现代内存管理中不可或缺的核心作用。[@problem_id:3653403]", "problem": "你需要实现一个确定性模拟器，该模拟器模拟一个使用空闲块链表来管理空闲空间的连续内存分配器。该分配器必须支持两种变体，这两种变体除了释放时的合并策略外完全相同：\n- 变体 C (带边界标签)：一个被释放的块通过合并共享边界的区间，与任何紧邻的空闲块进行合并。\n- 变体 B (移除脚部)：一个被释放的块被插入到空闲列表中，不进行任何合并，即使它与其他空闲块相邻。\n\n使用以下核心定义作为基本依据：\n- 一个连续内存区域被建模为从 $0$ 到 $M-1$ 的整数地址，其中 $M \\in \\mathbb{N}$ 是可寻址单元的总数。\n- 空闲空间被维护为一个由非重叠区间 $[b,\\ell]$ 组成的有序单向链表，表示从基地址 $b \\in \\mathbb{N}$ 开始、长度为 $\\ell \\in \\mathbb{N}$ 的块，即空闲单元为 $\\{b, b+1, \\dots, b+\\ell-1\\}$。两个连续的块 $[b_1,\\ell_1]$ 和 $[b_2,\\ell_2]$ 相邻当且仅当 $b_1+\\ell_1=b_2$。\n- 一个大小为 $s \\in \\mathbb{N}$ 的分配请求使用首次适应策略：选择第一个满足 $\\ell \\ge s$ 的空闲区间 $[b,\\ell]$，将区间 $[b,s]$ 作为有效载荷进行分配，并更新空闲列表：如果 $\\ell=s$，则移除 $[b,\\ell]$；如果 $\\ells$，则将其替换为 $[b+s,\\ell-s]$。\n- 对先前返回的分配 $[b,\\ell]$ 的释放操作，会将 $[b,\\ell]$ 按排序顺序插回到空闲列表中。在变体 C 中，通过重复合并相邻的邻居来进行合并，以确保没有两个空闲区间是相邻的。在变体 B 中，完全不进行合并。\n- 外部碎片度量定义为\n$$\nF_{\\text{ext}} \\;=\\;\n\\begin{cases}\n0,  \\text{if } T_{\\text{free}}=0,\\\n\\\\[4pt]\n1 - \\dfrac{L_{\\max}}{T_{\\text{free}}},  \\text{if } T_{\\text{free}} > 0,\n\\end{cases}\n$$\n其中 $T_{\\text{free}}$ 是总空闲空间（所有空闲区间长度之和），$L_{\\max}$ 是最大空闲区间的大小。\n\n分配标识符按如下方式分配。每次成功的分配都会按成功顺序被赋予下一个正整数标识符 $1,2,3,\\dots$，并与当时返回的确切区间 $[b,\\ell]$ 保持绑定。失败的分配（没有足够大的空闲块）不消耗标识符。释放操作指定一个标识符 $k \\in \\mathbb{N}$；如果 $k$ 当前已分配，则相应的块根据当前活动的变体返回到空闲列表中。如果 $k$ 当前未分配，则该释放请求被忽略。\n\n实现一个程序，对下面的每个测试用例运行变体 B 和变体 C，并为每个用例计算差值\n$$\n\\Delta \\;=\\; F_{\\text{ext}}^{\\text{(B)}} - F_{\\text{ext}}^{\\text{(C)}}\n$$\n在执行完整个操作序列后。将每个 $\\Delta$ 报告为小数点后精确到四位的小数。\n\n输入：没有输入。所有参数都是固定的并嵌入在程序中。\n\n操作表示法：每个操作要么是分配 $A\\;s$（分配大小为 $s$），要么是释放 $F\\;k$（释放标识符为 $k$）。\n\n测试套件（每个都从一个包含单个空闲块 $[0,M]$ 的全新初始状态独立执行）：\n- 测试用例 1：\n  - $M=64$\n  - 操作：$A\\;10,\\;A\\;12,\\;A\\;8,\\;F\\;2,\\;A\\;6,\\;F\\;3,\\;F\\;1,\\;A\\;5,\\;F\\;4$\n- 测试用例 2：\n  - $M=32$\n  - 操作：$A\\;8,\\;A\\;8,\\;F\\;1,\\;A\\;4,\\;F\\;2$\n- 测试用例 3：\n  - $M=50$\n  - 操作：$A\\;5,\\;A\\;5,\\;A\\;5,\\;A\\;5,\\;A\\;5,\\;F\\;2,\\;F\\;4,\\;A\\;3,\\;A\\;2,\\;F\\;3,\\;F\\;5,\\;F\\;1$\n\n最终输出格式：你的程序应生成单行输出，其中包含三个结果，以逗号分隔的列表形式用方括号括起来，并按测试用例的顺序排列：\n$$\n[\\Delta_1,\\Delta_2,\\Delta_3]\n$$\n每个 $\\Delta_i$ 必须打印为小数点后四位的小数。\n\n科学真实性和推导要求：\n- 你的设计应基于上述关于首次适应分配、区间合并和外部碎片度量 $F_{\\text{ext}}$ 的核心定义。\n- 确保你的实现维护一个空闲区间的有序链表表示，根据两种变体的定义对其进行更新，并在每个测试用例结束时严格根据 $T_{\\text{free}}$ 和 $L_{\\max}$ 计算 $F_{\\text{ext}}$。\n- 不要使用任何随机化；所有结果必须是确定性的和可复现的。\n\n你的程序必须是自包含的，且不得读取任何输入。唯一的输出必须是上面指定的确切格式的单行。所有量都是无量纲的。按规定将每个结果表示为四舍五入到小数点后四位的小数。", "solution": "本问题要求对一个内存分配器进行确定性模拟，该分配器在两种变体下运行：一种带合并（变体C），一种不带合并（变体B）。我们需要为三个独立的测试用例计算这两种变体最终外部碎片度量之间的差异 $\\Delta = F_{\\text{ext}}^{\\text{(B)}} - F_{\\text{ext}}^{\\text{(C)}}$。\n\n我们将手动追踪每个测试用例的操作序列。\n- `FL`：空闲块列表，表示为 `([基地址, 长度], ...)`。\n- `Alloc`：已分配块的映射，表示为 `{ID: [基地址, 长度]}`。\n\n**测试用例 1: M=64**\n操作: `A 10, A 12, A 8, F 2, A 6, F 3, F 1, A 5, F 4`\n\n1.  `A 10` -> ID 1: [0, 10]. FL: `([10, 54])`.\n2.  `A 12` -> ID 2: [10, 12]. FL: `([22, 42])`.\n3.  `A 8` -> ID 3: [22, 8]. FL: `([30, 34])`.\n4.  `F 2` (释放 [10, 12]). 两个变体的 FL 均为: `([10, 12], [30, 34])`.\n5.  `A 6` -> ID 4: [10, 6] (从 [10, 12] 分割). 两个变体的 FL 均为: `([16, 6], [30, 34])`.\n6.  `F 3` (释放 [22, 8]). 两个变体的 FL 均为: `([16, 6], [22, 8], [30, 34])`.\n7.  `F 1` (释放 [0, 10]). 两个变体的 FL 均为: `([0, 10], [16, 6], [22, 8], [30, 34])`.\n8.  `A 5` -> ID 5: [0, 5] (从 [0, 10] 分割). 两个变体的 FL 均为: `([5, 5], [16, 6], [22, 8], [30, 34])`.\n9.  `F 4` (释放 [10, 6]).\n\n*   **变体 B (不合并) 最终状态:**\n    *   将 [10, 6] 插入。FL: `([5, 5], [10, 6], [16, 6], [22, 8], [30, 34])`.\n    *   $T_{\\text{free}} = 5+6+6+8+34 = 59$.\n    *   $L_{\\max} = 34$.\n    *   $F_{\\text{ext}}^{\\text{(B)}} = 1 - 34/59 \\approx 0.423728$.\n\n*   **变体 C (合并) 最终状态:**\n    *   插入 [10, 6]。它与左边的 [5, 5] 相邻 (`5+5=10`)，合并为 [5, 11]。\n    *   新块 [5, 11] 与右边的 [16, 6] 相邻 (`5+11=16`)，合并为 [5, 17]。\n    *   新块 [5, 17] 与右边的 [22, 8] 相邻 (`5+17=22`)，合并为 [5, 25]。\n    *   新块 [5, 25] 与右边的 [30, 34] 相邻 (`5+25=30`)，合并为 [5, 59]。\n    *   FL: `([5, 59])`.\n    *   $T_{\\text{free}} = 59$.\n    *   $L_{\\max} = 59$.\n    *   $F_{\\text{ext}}^{\\text{(C)}} = 1 - 59/59 = 0$.\n\n*   $\\Delta_1 = 0.423728 - 0 \\approx 0.4237$.\n\n**测试用例 2: M=32**\n操作: `A 8, A 8, F 1, A 4, F 2`\n\n1.  `A 8` -> ID 1: [0, 8]. FL: `([8, 24])`.\n2.  `A 8` -> ID 2: [8, 8]. FL: `([16, 16])`.\n3.  `F 1` (释放 [0, 8]). 两个变体的 FL 均为: `([0, 8], [16, 16])`.\n4.  `A 4` -> ID 3: [0, 4] (从 [0, 8] 分割). 两个变体的 FL 均为: `([4, 4], [16, 16])`.\n5.  `F 2` (释放 [8, 8]).\n\n*   **变体 B (不合并) 最终状态:**\n    *   将 [8, 8] 插入。FL: `([4, 4], [8, 8], [16, 16])`.\n    *   $T_{\\text{free}} = 4+8+16 = 28$.\n    *   $L_{\\max} = 16$.\n    *   $F_{\\text{ext}}^{\\text{(B)}} = 1 - 16/28 = 1 - 4/7 \\approx 0.428571$.\n\n*   **变体 C (合并) 最终状态:**\n    *   插入 [8, 8]。它与左边的 [4, 4] 相邻 (`4+4=8`)，合并为 [4, 12]。\n    *   新块 [4, 12] 与右边的 [16, 16] 相邻 (`4+12=16`)，合并为 [4, 28]。\n    *   FL: `([4, 28])`.\n    *   $T_{\\text{free}} = 28$.\n    *   $L_{\\max} = 28$.\n    *   $F_{\\text{ext}}^{\\text{(C)}} = 1 - 28/28 = 0$.\n\n*   $\\Delta_2 = 0.428571 - 0 \\approx 0.4286$.\n\n**测试用例 3: M=50**\n操作: `A 5, A 5, A 5, A 5, A 5, F 2, F 4, A 3, A 2, F 3, F 5, F 1`\n\n1.  `A 5` (x5) -> IDs 1-5: [0,5], [5,5], [10,5], [15,5], [20,5]. FL: `([25, 25])`.\n2.  `F 2` (释放 [5, 5]). `F 4` (释放 [15, 5]). 两个变体的 FL 均为: `([5, 5], [15, 5], [25, 25])`.\n3.  `A 3` -> ID 6: [5, 3] (从 [5, 5] 分割).\n4.  `A 2` -> ID 7: [15, 2] (从 [15, 5] 分割). 两个变体的 FL 均为: `([8, 2], [17, 3], [25, 25])`.\n5.  `F 3` (释放 [10, 5]).\n    *   B: `([8, 2], [10, 5], [17, 3], [25, 25])`.\n    *   C: [8, 2] 与 [10, 5] 相邻 (`8+2=10`)，合并为 [8, 7]. FL: `([8, 7], [17, 3], [25, 25])`.\n6.  `F 5` (释放 [20, 5]).\n    *   B: `([8, 2], [10, 5], [17, 3], [20, 5], [25, 25])`.\n    *   C: [17, 3] 与 [20, 5] 相邻 (`17+3=20`)，合并为 [17, 8]. FL: `([8, 7], [17, 8], [25, 25])`.\n7.  `F 1` (释放 [0, 5]).\n\n*   **变体 B (不合并) 最终状态:**\n    *   插入 [0, 5]。FL: `([0, 5], [8, 2], [10, 5], [17, 3], [20, 5], [25, 25])`.\n    *   $T_{\\text{free}} = 5+2+5+3+5+25 = 45$.\n    *   $L_{\\max} = 25$.\n    *   $F_{\\text{ext}}^{\\text{(B)}} = 1 - 25/45 = 1 - 5/9 \\approx 0.444444$.\n\n*   **变体 C (合并) 最终状态:**\n    *   插入 [0, 5]。无相邻空闲块。FL: `([0, 5], [8, 7], [17, 8], [25, 25])`.\n    *   $T_{\\text{free}} = 5+7+8+25 = 45$.\n    *   $L_{\\max} = 25$.\n    *   $F_{\\text{ext}}^{\\text{(C)}} = 1 - 25/45 = 1 - 5/9 \\approx 0.444444$.\n\n*   $\\Delta_3 = 0.444444 - 0.444444 = 0.0000$.\n\n最终结果：$\\Delta_1 \\approx 0.4237, \\Delta_2 \\approx 0.4286, \\Delta_3 = 0.0000$.", "answer": "$$\n\\boxed{[0.4237, 0.4286, 0.0000]}\n$$", "id": "3653403"}]}