{"hands_on_practices": [{"introduction": "网络附加存储（如 iSCSI）提供了极大的灵活性，但可能带来显著的 CPU 开销。本练习将引导你量化使用专用硬件卸载网卡相对于纯软件方案的性能优势。通过这一计算，你将更深入地理解存储系统中硬件与软件解决方案之间的权衡。[@problem_id:3634733]", "problem": "一个存储团队正在评估两种使用 iSCSI (Internet 小型计算机系统接口) 连接远程磁盘的方法：一种是使用主机中央处理器 (CPU) 的软件启动器，另一种是在硬件中实现协议处理的 iSCSI 卸载网络接口控制器 (NIC)。他们希望通过结合两个基于基本原理的效果，即持续数据传输期间节省的 CPU 秒数和会话登录期间节省的挂钟连接时间，来对跨多个会话的卸载方法的端到端好处进行原则性估算。假设以下广泛使用的基础：\n- 任务消耗的总 CPU 时间是执行的总周期数除以 CPU 频率，即 $t_{\\text{cpu}} = \\frac{\\text{cycles}}{f}$。\n- 网络堆栈中的每字节和每数据包处理成本分别建模为恒定的周期成本 $a$ (周期/字节) 和 $p$ (周期/数据包)，总周期数是跨字节和数据包累加的。\n- 传输给定数量的有效载荷字节所需的数据包数量，是有效载荷字节总数除以每个数据包的有效载荷后向上取整的结果。\n- 1 mebibyte (MiB) 等于 $2^{20}$ 字节，即 $1 \\text{ MiB} = 2^{20} \\text{ bytes}$。\n- 在 CPU 上进行哈希计算的 $L$ 字节认证工作负载，每字节消耗恒定的周期数。\n\n考虑以下具体场景。一个 CPU 频率为 $f$ 的主机运行 $N$ 个 iSCSI 会话，这些会话依次连接，然后在 $T$ 秒的时间窗口内以每个会话 $s$ 的应用程序有效载荷吞吐量并发地维持读取操作。每个会话使用一个最大传输单元 (MTU)，其每个数据包的有效 TCP 有效载荷为 $\\text{pld}$ 字节。软件启动器产生的每字节成本为 $a_{\\text{sw}}$，每数据包成本为 $p_{\\text{sw}}$，而卸载 NIC 产生的成本为 $a_{\\text{off}}$ 和 $p_{\\text{off}}$。在登录（连接）期间，两种实现都执行一个固定的控制握手，往返时间为 $\\text{RTT}$，包含 $k$ 次往返，并且都必须对 $L$ 字节进行哈希认证。软件启动器进行此哈希计算需要每字节 $h_{\\text{sw}}$ 个周期，而卸载 NIC 将 CPU 哈希成本降低到软件成本的一小部分 $\\rho$，但在登录时为每个会话引入一个固定的固件设置延迟 $g$。假设 $k \\in \\mathbb{N}$，并且在比较连接时间时，控制握手延迟部分会相互抵消，因为它在两种情况下是相同的。\n\n使用以下参数值：\n- $f = 3.2 \\times 10^{9} \\text{ 周期/秒}$, $N = 8$, $T = 10 \\text{ s}$, $s = 50 \\text{ MiB/s}$。\n- $\\text{pld} = 1460 \\text{ 字节}$。\n- $a_{\\text{sw}} = 3 \\text{ 周期/字节}$, $p_{\\text{sw}} = 6000 \\text{ 周期/数据包}$。\n- $a_{\\text{off}} = 0.3 \\text{ 周期/字节}$, $p_{\\text{off}} = 600 \\text{ 周期/数据包}$。\n- $k = 6$, $\\text{RTT} = 1.5 \\times 10^{-3} \\text{ s}$, $L = 64 \\text{ KiB}$ (其中 $1 \\text{ KiB} = 1024 \\text{ 字节}$), $h_{\\text{sw}} = 20 \\text{ 周期/字节}$, $\\rho = 0.05$, $g = 2.0 \\times 10^{-4} \\text{ s}$。\n\n将卸载 NIC 相对于软件启动器在所有 $N$ 个会话中的组合时间优势 $M$ 定义为以下各项的总和：\n- 在 $T$ 秒的持续读取窗口期间节省的总 CPU 秒数，该值由软件和卸载方案在数据路径上的周期成本差异计算得出，以及\n- 在 $N$ 个顺序会话连接中节省的总挂钟连接（登录）时间，该值由每个会话中软件和卸载方案在客户端的连接时间差异计算得出。\n\n计算 $M$，并以秒为单位表示您的最终答案。将答案四舍五入到四位有效数字。", "solution": "问题陈述已经过验证，被认为是科学上合理的、定义明确且客观的。它使用成熟的基本原理模型来计算网络处理中的 CPU 成本，提出了一个计算机系统中的标准性能建模场景。所有必要的参数和定义均已提供，不存在矛盾或歧义。因此，可以构建一个完整的解决方案。\n\n问题要求计算 iSCSI 卸载 NIC 相对于软件启动器的组合时间优势 $M$。此优势定义为两个组成部分的总和：\n1.  在持续数据传输期间节省的总 CPU 秒数，我们将其表示为 $\\Delta t_{\\text{cpu,transfer}}$。\n2.  在所有会话中节省的总挂钟连接时间，我们将其表示为 $\\Delta t_{\\text{attach,total}}$。\n\n因此，总优势为 $M = \\Delta t_{\\text{cpu,transfer}} + \\Delta t_{\\text{attach,total}}$。我们将分别计算每个组成部分。\n\n首先，我们计算在持续数据传输期间节省的总 CPU 秒数，$\\Delta t_{\\text{cpu,transfer}}$。\n在所有 $N$ 个会话中，以每个会话 $s$ 的吞吐量持续 $T$ 时间，传输的应用程序有效载荷数据总量 $B_{\\text{total}}$ 为：\n$$B_{\\text{total}} = N \\times s \\times T$$\n吞吐量 $s$以 mebibytes 每秒（$\\text{MiB/s}$）为单位，必须转换为字节每秒。使用给定的转换关系 $1 \\text{ MiB} = 2^{20} \\text{ bytes}$：\n$$B_{\\text{total}} = N \\times (s \\times 2^{20}) \\times T$$\n\n传输这些字节所需的总数据包数 $P_{\\text{total}}$ 由每个数据包的有效载荷 $\\text{pld}$ 决定。根据问题描述，这是总字节数除以有效载荷大小后的向上取整值：\n$$P_{\\text{total}} = \\left\\lceil \\frac{B_{\\text{total}}}{\\text{pld}} \\right\\rceil$$\n\n数据传输消耗的总 CPU 周期是每字节成本和每数据包成本的总和。对于软件启动器，总周期数为：\n$$C_{\\text{sw,transfer}} = a_{\\text{sw}} B_{\\text{total}} + p_{\\text{sw}} P_{\\text{total}}$$\n对于卸载 NIC，CPU 产生的成本较低：\n$$C_{\\text{off,transfer}} = a_{\\text{off}} B_{\\text{total}} + p_{\\text{off}} P_{\\text{total}}$$\n\n使用卸载 NIC 节省的 CPU 周期数是两者之差：\n$$\\Delta C_{\\text{transfer}} = C_{\\text{sw,transfer}} - C_{\\text{off,transfer}} = (a_{\\text{sw}} - a_{\\text{off}}) B_{\\text{total}} + (p_{\\text{sw}} - p_{\\text{off}}) P_{\\text{total}}$$\n\n节省的 CPU 时间 $\\Delta t_{\\text{cpu,transfer}}$ 是节省的周期数除以 CPU 频率 $f$：\n$$\\Delta t_{\\text{cpu,transfer}} = \\frac{\\Delta C_{\\text{transfer}}}{f} = \\frac{(a_{\\text{sw}} - a_{\\text{off}}) B_{\\text{total}} + (p_{\\text{sw}} - p_{\\text{off}}) P_{\\text{total}}}{f}$$\n\n接下来，我们计算节省的总挂钟连接时间 $\\Delta t_{\\text{attach,total}}$。\n会话是依次连接的，因此节省的总时间是单个会话节省时间的 $N$ 倍。设 $\\Delta t_{\\text{attach,session}}$ 为一个会话登录所节省的挂钟时间。\n$$\\Delta t_{\\text{attach,total}} = N \\times \\Delta t_{\\text{attach,session}}$$\n\n单个会话的连接时间包括一个网络握手组件和一个受 CPU 限制的认证组件。问题陈述指出，握手延迟 ($k \\times \\text{RTT}$) 对两种方法是相同的，在比较中会相互抵消。因此，我们只需要考虑在认证上花费的时间差异以及任何其他指定的延迟。\n\n软件启动器认证的挂钟时间 $t_{\\text{auth,sw}}$ 是哈希 $L$ 字节所需的 CPU 时间。大小 $L$ 以 kibibytes ($\\text{KiB}$) 为单位，必须使用 $1 \\text{ KiB} = 1024 \\text{ bytes}$ 转换为字节。设 $L_{\\text{bytes}} = L \\times 1024$。\n$$t_{\\text{auth,sw}} = \\frac{C_{\\text{auth,sw}}}{f} = \\frac{L_{\\text{bytes}} \\times h_{\\text{sw}}}{f}$$\n\n对于卸载 NIC，哈希计算的 CPU 成本减少了因子 $\\rho$。CPU 上认证的挂钟时间为：\n$$t_{\\text{auth,off}} = \\frac{\\rho \\times (L_{\\text{bytes}} \\times h_{\\text{sw}})}{f}$$\n然而，卸载 NIC 引入了一个额外的固定固件设置延迟 $g$。\n\n每种实现的总挂钟连接时间为：\n$$t_{\\text{attach,sw}} = t_{\\text{handshake}} + t_{\\text{auth,sw}}$$\n$$t_{\\text{attach,off}} = t_{\\text{handshake}} + t_{\\text{auth,off}} + g$$\n\n每个会话节省的时间是两者之差：\n$$\\Delta t_{\\text{attach,session}} = t_{\\text{attach,sw}} - t_{\\text{attach,off}} = (t_{\\text{handshake}} + t_{\\text{auth,sw}}) - (t_{\\text{handshake}} + t_{\\text{auth,off}} + g)$$\n$$\\Delta t_{\\text{attach,session}} = t_{\\text{auth,sw}} - t_{\\text{auth,off}} - g = \\frac{L_{\\text{bytes}} h_{\\text{sw}}}{f} - \\frac{\\rho L_{\\text{bytes}} h_{\\text{sw}}}{f} - g = \\frac{(1 - \\rho) L_{\\text{bytes}} h_{\\text{sw}}}{f} - g$$\n\n在所有 $N$ 个会话中节省的总挂钟时间为：\n$$\\Delta t_{\\text{attach,total}} = N \\left(\\frac{(1 - \\rho) (L \\times 1024) h_{\\text{sw}}}{f} - g\\right)$$\n\n现在，我们将给定的数值代入这些表达式。\n给定值：$f = 3.2 \\times 10^9 \\text{ s}^{-1}$，$N = 8$，$T = 10 \\text{ s}$，$s = 50 \\text{ MiB/s}$，$\\text{pld} = 1460 \\text{ 字节}$，$a_{\\text{sw}} = 3$，$p_{\\text{sw}} = 6000$，$a_{\\text{off}} = 0.3$，$p_{\\text{off}} = 600$，$L = 64 \\text{ KiB}$，$h_{\\text{sw}} = 20$，$\\rho = 0.05$，$g = 2.0 \\times 10^{-4} \\text{ s}$。\n\n$\\Delta t_{\\text{cpu,transfer}}$ 的计算：\n$B_{\\text{total}} = 8 \\times (50 \\times 2^{20} \\text{ 字节/秒}) \\times 10 \\text{ s} = 4000 \\times 2^{20} \\text{ 字节} = 4194304000 \\text{ 字节}$。\n$P_{\\text{total}} = \\lceil \\frac{4194304000}{1460} \\rceil = \\lceil 2872810.95... \\rceil = 2872811 \\text{ 数据包}$。\n$\\Delta a = a_{\\text{sw}} - a_{\\text{off}} = 3 - 0.3 = 2.7$ 周期/字节。\n$\\Delta p = p_{\\text{sw}} - p_{\\text{off}} = 6000 - 600 = 5400$ 周期/数据包。\n$\\Delta C_{\\text{transfer}} = (2.7 \\times 4194304000) + (5400 \\times 2872811) = 11324620800 + 15513179400 = 26837800200 \\text{ 周期}$。\n$\\Delta t_{\\text{cpu,transfer}} = \\frac{26837800200}{3.2 \\times 10^9} \\approx 8.38681 \\text{ s}$。\n\n$\\Delta t_{\\text{attach,total}}$ 的计算：\n$L_{\\text{bytes}} = 64 \\text{ KiB} = 64 \\times 1024 \\text{ 字节} = 65536 \\text{ 字节}$。\n$1 - \\rho = 1 - 0.05 = 0.95$。\n$\\Delta t_{\\text{attach,session}} = \\frac{0.95 \\times 65536 \\times 20}{3.2 \\times 10^9} - 2.0 \\times 10^{-4} = \\frac{1245184}{3.2 \\times 10^9} - 0.0002 = 0.00038912 - 0.0002 = 0.00018912 \\text{ s}$。\n$\\Delta t_{\\text{attach,total}} = 8 \\times 0.00018912 \\text{ s} = 0.00151296 \\text{ s}$。\n\n最后，我们计算总优势 $M$：\n$M = \\Delta t_{\\text{cpu,transfer}} + \\Delta t_{\\text{attach,total}} = 8.3868125625 \\text{ s} + 0.00151296 \\text{ s} = 8.3883255225 \\text{ s}$。\n\n问题要求答案四舍五入到四位有效数字。\n$M \\approx 8.388 \\text{ s}$。", "answer": "$$\n\\boxed{8.388}\n$$", "id": "3634733"}, {"introduction": "除了平均性能，确保系统响应能力还需要管理最坏情况下的 I/O 延迟。本练习使用一个概率模型来分析不同磁盘连接方式（从本地 NVMe 到网络 iSCSI）的“尾部延迟”。通过计算延迟百分位并设置合适的超时值，你将学习到一种构建稳健且可预测操作系统的基本技术。[@problem_id:3634744]", "problem": "一个操作系统必须为不同磁盘连接方式的块I/O选择安全的超时设置，同时控制错误超时。考虑三种连接方式的单块读取延迟模型：非易失性内存快递 (NVMe)、串行高级技术附件 (SATA) 固态硬盘，以及以太网上的互联网小型计算机系统接口 (iSCSI)。对于每种连接方式，将每个请求的延迟随机变量建模为 $X = c + Z$，其中 $c$ 是一个表示基础延迟的非负常数，$Z$ 是一个捕捉因排队或重试而产生的偶然尾部延迟的随机变量。假设 $Z$ 以 $1 - p$ 的概率取值为 $0$，并以 $p$ 的概率等于 $Y$，其中 $Y$ 独立于 $c$ 且服从速率为 $\\lambda$ 的指数分布。指数分布的累积分布函数为 $F_{Y}(y) = 1 - \\exp(-\\lambda y)$，对于 $y \\ge 0$。该混合模型捕捉了在 $c$ 处存在一个概率集中点并带有一个指数尾部的经验观察。\n\n对于每种连接方式，使用以下参数，单位均为毫秒：\n- NVMe: $c_{\\mathrm{NVMe}} = 0.12$, $p_{\\mathrm{NVMe}} = 0.02$, $\\lambda_{\\mathrm{NVMe}} = \\frac{1}{0.35}$.\n- SATA: $c_{\\mathrm{SATA}} = 0.45$, $p_{\\mathrm{SATA}} = 0.03$, $\\lambda_{\\mathrm{SATA}} = \\frac{1}{3.0}$.\n- iSCSI: $c_{\\mathrm{iSCSI}} = 1.30$, $p_{\\mathrm{iSCSI}} = 0.05$, $\\lambda_{\\mathrm{iSCSI}} = \\frac{1}{10.0}$.\n\n使用上述基本定义并根据模型进行推理，完成以下操作：\n1. 推导 $X$ 的 $0.99$-分位数（第 $99$ 百分位数）延迟 $L_{99}$ 的表达式，并为每种连接方式计算 $L_{99}$。\n2. 为每种连接方式推荐一个操作系统超时 $t_{o}$，选择满足 $\\mathbb{P}(X > t_{o}) \\le \\theta$ 的最小 $t_{o}$，其中目标尾部超出概率 $\\theta = 10^{-4}$。为每种连接方式计算 $t_{o}$。\n\n将所有数值答案四舍五入到四位有效数字。所有答案以毫秒表示。以单行形式提供最终答案，其中包含六个值，顺序为：$L_{99}^{\\mathrm{NVMe}}$、$L_{99}^{\\mathrm{SATA}}$、$L_{99}^{\\mathrm{iSCSI}}$、$t_{o}^{\\mathrm{NVMe}}$、$t_{o}^{\\mathrm{SATA}}$、$t_{o}^{\\mathrm{iSCSI}}$。", "solution": "问题陈述已经过验证，并被确定为一个在应用概率和计算机系统性能分析领域中定义良好、有科学依据且客观的问题。所有必要的参数和定义都已提供，且没有内部矛盾。\n\n单块读取的延迟由随机变量 $X = c + Z$ 建模。此处，$c$ 是一个恒定的基础延迟，$Z$ 是一个表示额外延迟的随机变量。变量 $Z$ 服从一个混合分布：它以 $1-p$ 的概率为 $0$，并以 $p$ 的概率服从速率为 $\\lambda$ 的指数分布。设该指数随机变量为 $Y$。$Y$ 的累积分布函数 (CDF) 给出为 $F_Y(y) = 1 - \\exp(-\\lambda y)$，对于 $y \\ge 0$。\n\n首先，我们推导总延迟 $X$ 的 CDF，记为 $F_X(x) = \\mathbb{P}(X \\le x)$。\n$$F_X(x) = \\mathbb{P}(c + Z \\le x) = \\mathbb{P}(Z \\le x-c)$$\n设 $z' = x-c$。$Z$ 的支撑集是 $[0, \\infty)$，因为 $Y$ 的支撑集是 $[0, \\infty)$ 并且 $Z$ 也可以是 $0$。因此，如果 $x  c$，则 $x-c  0$，且 $\\mathbb{P}(Z \\le x-c) = 0$。所以，对于 $x  c$，$F_X(x) = 0$。\n\n对于 $x \\ge c$，我们有 $x-c \\ge 0$。我们可以使用全概率定律来求 $Z$ 的 CDF。\n$$\\mathbb{P}(Z \\le z') = \\mathbb{P}(Z \\le z' | Z=0)\\mathbb{P}(Z=0) + \\mathbb{P}(Z \\le z' | Z=Y)\\mathbb{P}(Z=Y)$$\n由于 $z' \\ge 0$，条件 $0 \\le z'$ 总是成立的。\n$$\\mathbb{P}(Z \\le z') = 1 \\cdot (1-p) + \\mathbb{P}(Y \\le z') \\cdot p$$\n代入指数分布的CDF，$F_Y(z') = 1 - \\exp(-\\lambda z')$:\n$$\\mathbb{P(Z \\le z')} = (1-p) + p(1 - \\exp(-\\lambda z')) = 1 - p + p - p\\exp(-\\lambda z') = 1 - p\\exp(-\\lambda z')$$\n将 $z' = x-c$ 代回，我们得到对于 $x \\ge c$ 时 $X$ 的 CDF：\n$$F_X(x) = 1 - p\\exp(-\\lambda(x-c))$$\n该 CDF 在 $x=c$ 处有一个不连续点。一个请求恰好在基础延迟 $c$ 完成的概率是 $\\mathbb{P}(X=c) = \\mathbb{P}(Z=0) = 1-p$。该点的 CDF 值为 $F_X(c) = \\mathbb{P}(X \\le c) = \\mathbb{P}(X=c) = 1-p$，这与我们推导的公式一致：$F_X(c) = 1 - p\\exp(0) = 1-p$。\n\n1. 推导 $0.99$-分位数（第 $99$ 百分位数）延迟 $L_{99}$ 的表达式。\n$q$-分位数 $x_q$ 是满足 $F_X(x_q) = q$ 的值。我们需要找到 $L_{99}$ 使得 $F_X(L_{99}) = 0.99$。\n首先，我们检查分位数是位于 $c$ 处的概率集中点还是在指数尾部。在概率集中点处的 CDF 值为 $1-p$。\n对于 NVMe: $1 - p_{\\mathrm{NVMe}} = 1 - 0.02 = 0.98$。\n对于 SATA: $1 - p_{\\mathrm{SATA}} = 1 - 0.03 = 0.97$。\n对于 iSCSI: $1 - p_{\\mathrm{iSCSI}} = 1 - 0.05 = 0.95$。\n在所有三种情况下，目标概率 $0.99$ 都大于 $1-p$。这意味着 $L_{99}$ 必须大于 $c$ 并且位于分布的连续指数尾部内。我们求解 $L_{99}$：\n$$F_X(L_{99}) = 1 - p\\exp(-\\lambda(L_{99}-c)) = 0.99$$\n$$p\\exp(-\\lambda(L_{99}-c)) = 1 - 0.99 = 0.01$$\n$$\\exp(-\\lambda(L_{99}-c)) = \\frac{0.01}{p}$$\n对两边取自然对数：\n$$-\\lambda(L_{99}-c) = \\ln\\left(\\frac{0.01}{p}\\right) = -\\ln\\left(\\frac{p}{0.01}\\right)$$\n$$L_{99}-c = \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{0.01}\\right)$$\n$$L_{99} = c + \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{10^{-2}}\\right)$$\n\n我们现在为每种连接方式计算 $L_{99}$。\n- NVMe: $c_{\\mathrm{NVMe}} = 0.12$, $p_{\\mathrm{NVMe}} = 0.02$, $\\lambda_{\\mathrm{NVMe}} = \\frac{1}{0.35}$。\n$L_{99}^{\\mathrm{NVMe}} = 0.12 + 0.35 \\cdot \\ln\\left(\\frac{0.02}{0.01}\\right) = 0.12 + 0.35 \\ln(2) \\approx 0.12 + 0.35(0.693147) \\approx 0.362601$ 毫秒。\n保留四位有效数字，$L_{99}^{\\mathrm{NVMe}} = 0.3626$ 毫秒。\n\n- SATA: $c_{\\mathrm{SATA}} = 0.45$, $p_{\\mathrm{SATA}} = 0.03$, $\\lambda_{\\mathrm{SATA}} = \\frac{1}{3.0}$。\n$L_{99}^{\\mathrm{SATA}} = 0.45 + 3.0 \\cdot \\ln\\left(\\frac{0.03}{0.01}\\right) = 0.45 + 3.0 \\ln(3) \\approx 0.45 + 3.0(1.098612) \\approx 3.745836$ 毫秒。\n保留四位有效数字，$L_{99}^{\\mathrm{SATA}} = 3.746$ 毫秒。\n\n- iSCSI: $c_{\\mathrm{iSCSI}} = 1.30$, $p_{\\mathrm{iSCSI}} = 0.05$, $\\lambda_{\\mathrm{iSCSI}} = \\frac{1}{10.0}$。\n$L_{99}^{\\mathrm{iSCSI}} = 1.30 + 10.0 \\cdot \\ln\\left(\\frac{0.05}{0.01}\\right) = 1.30 + 10.0 \\ln(5) \\approx 1.30 + 10.0(1.609438) \\approx 17.39438$ 毫秒。\n保留四位有效数字，$L_{99}^{\\mathrm{iSCSI}} = 17.39$ 毫秒。\n\n2. 推荐一个操作系统超时 $t_{o}$。\n我们需要找到最小的 $t_o$，使得超过此超时的概率最多为 $\\theta = 10^{-4}$。\n$$\\mathbb{P}(X > t_o) \\le \\theta$$\n这等价于 $1 - \\mathbb{P}(X \\le t_o) \\le \\theta$，或 $F_X(t_o) \\ge 1 - \\theta$。\n为找到最小的此类 $t_o$，我们将 CDF 设置为该最小要求值：\n$$F_X(t_o) = 1 - \\theta = 1 - 10^{-4} = 0.9999$$\n其逻辑与第1部分中的分位数计算相同。对于所有三种连接方式，$1-p  0.9999$，因此超时 $t_o$ 将大于基础延迟 $c$。\n$$1 - p\\exp(-\\lambda(t_o-c)) = 1 - \\theta$$\n$$p\\exp(-\\lambda(t_o-c)) = \\theta$$\n$$\\exp(-\\lambda(t_o-c)) = \\frac{\\theta}{p}$$\n$$-\\lambda(t_o-c) = \\ln\\left(\\frac{\\theta}{p}\\right) = -\\ln\\left(\\frac{p}{\\theta}\\right)$$\n$$t_o - c = \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{\\theta}\\right)$$\n$$t_o = c + \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{\\theta}\\right)$$\n\n我们现在为每种连接方式计算 $t_o$，其中 $\\theta = 10^{-4}$。\n- NVMe: $c_{\\mathrm{NVMe}} = 0.12$, $p_{\\mathrm{NVMe}} = 0.02$, $\\lambda_{\\mathrm{NVMe}} = \\frac{1}{0.35}$。\n$t_{o}^{\\mathrm{NVMe}} = 0.12 + 0.35 \\cdot \\ln\\left(\\frac{0.02}{10^{-4}}\\right) = 0.12 + 0.35 \\ln(200) \\approx 0.12 + 0.35(5.298317) \\approx 1.97441$ 毫秒。\n保留四位有效数字，$t_{o}^{\\mathrm{NVMe}} = 1.974$ 毫秒。\n\n- SATA: $c_{\\mathrm{SATA}} = 0.45$, $p_{\\mathrm{SATA}} = 0.03$, $\\lambda_{\\mathrm{SATA}} = \\frac{1}{3.0}$。\n$t_{o}^{\\mathrm{SATA}} = 0.45 + 3.0 \\cdot \\ln\\left(\\frac{0.03}{10^{-4}}\\right) = 0.45 + 3.0 \\ln(300) \\approx 0.45 + 3.0(5.703782) \\approx 17.5613$ 毫秒。\n保留四位有效数字，$t_{o}^{\\mathrm{SATA}} = 17.56$ 毫秒。\n\n- iSCSI: $c_{\\mathrm{iSCSI}} = 1.30$, $p_{\\mathrm{iSCSI}} = 0.05$, $\\lambda_{\\mathrm{iSCSI}} = \\frac{1}{10.0}$。\n$t_{o}^{\\mathrm{iSCSI}} = 1.30 + 10.0 \\cdot \\ln\\left(\\frac{0.05}{10^{-4}}\\right) = 1.30 + 10.0 \\ln(500) \\approx 1.30 + 10.0(6.214608) \\approx 63.4461$ 毫秒。\n保留四位有效数字，$t_{o}^{\\mathrm{iSCSI}} = 63.45$ 毫秒。\n\n所需的六个值是 $L_{99}^{\\mathrm{NVMe}}$、$L_{99}^{\\mathrm{SATA}}$、$L_{99}^{\\mathrm{iSCSI}}$、$t_{o}^{\\mathrm{NVMe}}$、$t_{o}^{\\mathrm{SATA}}$ 和 $t_{o}^{\\mathrm{iSCSI}}$。", "answer": "$$\\boxed{\\begin{pmatrix} 0.3626  3.746  17.39  1.974  17.56  63.45 \\end{pmatrix}}$$", "id": "3634744"}, {"introduction": "当一个系统连接了多个磁盘，特别是在存在克隆盘的情况下，操作系统如何确保从正确的磁盘启动？本练习探讨了仅依赖文件系统 UUID 进行识别时可能发生的错误引导的概率风险，并评估了一种加密保护措施。你将分析使用额外的唯一标识符如何能极大地降低从错误设备启动的概率，从而阐明系统可靠性的一个关键原则。[@problem_id:3634761]", "problem": "一台服务器支持多种磁盘连接方法，包括串行高级技术附件（Serial Advanced Technology Attachment, SATA）、非易失性内存主机控制器接口规范（Non-Volatile Memory Express, NVMe）和互联网小型计算机系统接口（Internet Small Computer Systems Interface, iSCSI）。在早期启动过程中，操作系统的设备枚举器以事件驱动的方式跨总线扫描连接设备，候选块设备的整体到达顺序可以建模为一个均匀随机排列，这反映了异步发现延迟和独立总线探测。启动配置通过文件系统通用唯一标识符（Universally Unique Identifier, UUID）来识别根卷，该UUID是存储在文件系统超级块中的一个标准化通用唯一标识符字符串。由于块级克隆，恰好有 $k$ 个连接设备共享相同的文件系统UUID；其中一个是预期的根设备，而其余 $k-1$ 个是错误的克隆设备。所有其他连接设备都具有不匹配的文件系统UUID。不存在设备路径固定提示或跨总线的持久排序保证。\n\n假设有 $n_{S}$ 个SATA磁盘，$n_{N}$ 个NVMe命名空间和 $n_{I}$ 个iSCSI逻辑单元号（LUN）；这些总数决定了枚举器扫描的设备池，但不会以其他方式影响 $k$ 个匹配设备中哪一个首先出现。系统当前选择第一个文件系统UUID与配置目标相等的连接设备。\n\n然后，您部署了一项安全措施：引入 $G$ 个独立的全局唯一标识符（Globally Unique Identifier, GUID）命名空间，在配置时，每个连接设备在每个命名空间中都被分配一个新的随机 $128$ 位GUID。克隆设备保留与预期根设备相同的文件系统UUID，但不共享任何新分配的GUID。启动接受规则变为一个合取条件：一个设备只有在其文件系统UUID和所有 $G$ 个命名空间的GUID都与配置值匹配时才被接受。将随机的 $128$ 位GUID视为在连接设备之间和命名空间之间独立且均匀分布。\n\n从随机枚举和加密标识符独立性的第一性原理出发：\n- 在原始规则（仅匹配文件系统UUID）下，推导从错误连接设备启动的概率 $p_{misboot}$ 的表达式，用 $k$ 表示。\n- 在安全措施下，推导 $p_{misboot}$ 的闭式表达式，作为 $k$ 和 $G$ 的函数。\n- 对于 $k=3$ 和 $G=2$ 的情况，数值计算采取安全措施后的 $p_{misboot}$，将答案四舍五入到四位有效数字。将最终概率以十进制科学记数法表示。不需要单位。\n\n为具体起见，您可以取 $n_{S}=4$，$n_{N}=3$ 和 $n_{I}=5$，并且您应该论证在所述假设下，这些计数值为什么会或不会影响 $p_{misboot}$。最终的数值答案必须是针对 $k=3$ 和 $G=2$ 的、采取安全措施后的 $p_{misboot}$，并四舍五入到四位有效数字。", "solution": "该问题要求在两种不同的启动规则下推导错误启动概率，并进行最终的数值评估。\n\n首先，我们讨论设备计数 $n_{S}$、$n_{N}$ 和 $n_{I}$ 的作用。设备总数为 $N = n_{S} + n_{N} + n_{I}$。问题陈述，操作系统以“均匀随机排列”的方式扫描设备，并选择*第一个*满足启动标准的设备。启动标准涉及匹配一个特定的文件系统UUID。有 $k$ 个设备具有此目标UUID，而 $N-k$ 个设备没有。启动过程永远不会在 $N-k$ 个设备中的任何一个上终止，因此它们与最终选择无关。决策完全在 $k$ 个候选设备中做出。由于 $N$ 个设备的整体排列是均匀随机的，所以 $k$ 个候选设备的相对顺序也是一个大小为 $k$ 的均匀随机排列。这意味着具有匹配UUID的 $k$ 个设备中的每一个，出现在候选序列首位的概率是相等的。因此，$n_{S}$、$n_{N}$ 和 $n_{I}$ 的具体值（其总和为 $N$）不影响错误启动的概率，因为该概率仅取决于 $k$ 个候选设备组内的相对顺序。\n\n在原始规则下 $p_{misboot}$ 的推导：\n在原始规则下，系统从它找到的第一个具有正确文件系统UUID的设备启动。我们有 $k$ 个这样的设备，包括 $1$ 个正确的根设备和 $k-1$ 个不正确的克隆设备。如前所述，这 $k$ 个设备中的每一个都有相同的机会成为从该集合中遇到的第一个设备。\n如果遇到的第一个设备是 $k-1$ 个克隆设备中的一个，就会发生错误启动。此事件的概率是不利结果的数量除以可能结果的总数。\n有 $k-1$ 个不利结果（选择一个克隆设备）和 $k$ 个总可能结果（选择任何一个具有匹配UUID的设备）。因此，错误启动的概率 $p_{misboot}$ 是：\n$$p_{misboot} = \\frac{k-1}{k}$$\n\n在安全措施规则下 $p_{misboot}$ 的推导：\n在安全措施下，设备必须匹配文件系统UUID和所有 $G$ 个配置的GUID。$k-1$ 个克隆设备共享文件系统UUID，但在 $G$ 个命名空间中的每一个都被分配了新的、随机的 $128$ 位GUID。\n假设均匀分布，一个随机生成的 $128$ 位GUID恰好与特定目标GUID匹配的概率是 $p_{g} = \\frac{1}{2^{128}}$。\n由于 $G$ 个GUID是独立的，单个克隆设备纯粹偶然拥有一整套匹配GUID（即“GUID碰撞”）的概率是：\n$$p_{coll} = (p_{g})^{G} = \\left(\\frac{1}{2^{128}}\\right)^G = 2^{-128G}$$\n这个概率极小。只有当至少一个克隆设备发生GUID碰撞*并且*在真正的根卷之前被扫描到时，才会发生错误启动。\n\n设 $M$ 为发生GUID碰撞的克隆设备数量（总共 $k-1$ 个）。这是一个遵循二项分布的随机变量，$M \\sim \\text{Binomial}(k-1, p_{coll})$。恰好有 $m$ 个碰撞克隆的概率是 $P(M=m) = \\binom{k-1}{m} p_{coll}^m (1-p_{coll})^{k-1-m}$。\n能够通过所有检查（即“可启动”）的设备集合包括真正的根卷（它总是通过检查）和 $M$ 个发生碰撞的克隆设备。可启动设备的总数是 $1+M$。\n系统将从它遇到的这 $1+M$ 个可启动设备中的第一个启动。如果这个设备是 $M$ 个克隆设备之一，则发生错误启动。给定有 $M=m$ 个碰撞克隆，则有 $1+m$ 个可启动设备。根据对称性，这些设备中第一个被扫描到的是克隆设备的概率为 $\\frac{m}{1+m}$。\n为了求出错误启动的总概率，我们计算这个条件概率在 $M$ 所有可能取值上的期望值：\n$$p_{misboot} = E\\left[\\frac{M}{1+M}\\right] = \\sum_{m=0}^{k-1} P(M=m) \\frac{m}{1+m}$$\n代入二项概率，我们得到：\n$$p_{misboot} = \\sum_{m=1}^{k-1} \\binom{k-1}{m} p_{coll}^m (1-p_{coll})^{k-1-m} \\frac{m}{1+m}$$\n我们使用组合恒等式 $\\frac{m}{m+1}\\binom{k-1}{m} = \\frac{1}{k}\\binom{k}{m+1}$。求和变为：\n$$p_{misboot} = \\sum_{m=1}^{k-1} \\frac{1}{k}\\binom{k}{m+1} p_{coll}^m (1-p_{coll})^{k-1-m}$$\n令 $j = m+1$。该和式变换为：\n$$p_{misboot} = \\frac{1}{k} \\sum_{j=2}^{k} \\binom{k}{j} p_{coll}^{j-1} (1-p_{coll})^{k-j} = \\frac{1}{k \\cdot p_{coll}} \\sum_{j=2}^{k} \\binom{k}{j} p_{coll}^{j} (1-p_{coll})^{k-j}$$\n根据二项式定理，我们知道 $\\sum_{j=0}^{k} \\binom{k}{j} p_{coll}^j (1-p_{coll})^{k-j} = 1$。从 $j=2$ 到 $k$ 的和是这个总和减去 $j=0$ 和 $j=1$ 的项：\n$$ \\sum_{j=2}^{k} \\binom{k}{j} p_{coll}^{j} (1-p_{coll})^{k-j} = 1 - \\binom{k}{0}p_{coll}^0(1-p_{coll})^k - \\binom{k}{1}p_{coll}^1(1-p_{coll})^{k-1} $$\n$$ = 1 - (1-p_{coll})^k - k \\cdot p_{coll} (1-p_{coll})^{k-1} $$\n将此代回，得到安全措施下错误启动概率的闭式表达式：\n$$p_{misboot} = \\frac{1}{k \\cdot p_{coll}} \\left[ 1 - (1-p_{coll})^k - k \\cdot p_{coll} (1-p_{coll})^{k-1} \\right]$$\n其中 $p_{coll} = 2^{-128G}$。\n\n对 $k=3$ 和 $G=2$ 进行数值评估：\n对于这些值，碰撞概率为 $p_{coll} = 2^{-128 \\times 2} = 2^{-256}$。\n我们将 $k=3$ 代入推导出的表达式：\n$$p_{misboot} = \\frac{1}{3 \\cdot p_{coll}} \\left[ 1 - (1-p_{coll})^3 - 3 \\cdot p_{coll} (1-p_{coll})^2 \\right]$$\n展开方括号中的项：\n$$ 1 - (1 - 3p_{coll} + 3p_{coll}^2 - p_{coll}^3) - 3p_{coll}(1 - 2p_{coll} + p_{coll}^2) $$\n$$ = 1 - 1 + 3p_{coll} - 3p_{coll}^2 + p_{coll}^3 - (3p_{coll} - 6p_{coll}^2 + 3p_{coll}^3) $$\n$$ = 3p_{coll}^2 - 2p_{coll}^3 $$\n将此结果代回：\n$$p_{misboot} = \\frac{1}{3 \\cdot p_{coll}} (3p_{coll}^2 - 2p_{coll}^3) = p_{coll} - \\frac{2}{3}p_{coll}^2$$\n由于 $p_{coll} = 2^{-256}$ 是一个极小的数，与 $p_{coll}$ 相比，$\\frac{2}{3}p_{coll}^2$ 这一项可以忽略不计。因此，我们可以近似为 $p_{misboot} \\approx p_{coll} = 2^{-256}$。\n我们将其转换为科学记数法：\n$$ \\log_{10}(p_{misboot}) \\approx \\log_{10}(2^{-256}) = -256 \\log_{10}(2) \\approx -256 \\times 0.30103 \\approx -77.06368 $$\n$$ p_{misboot} \\approx 10^{-77.06368} = 10^{0.93632} \\times 10^{-78} \\approx 8.6358 \\times 10^{-78} $$\n四舍五入到四位有效数字，概率为 $8.636 \\times 10^{-78}$。", "answer": "$$\\boxed{8.636 \\times 10^{-78}}$$", "id": "3634761"}]}