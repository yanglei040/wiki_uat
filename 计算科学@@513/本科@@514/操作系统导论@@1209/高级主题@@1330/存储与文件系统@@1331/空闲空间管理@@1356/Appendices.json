{"hands_on_practices": [{"introduction": "外部碎片是连续内存分配中的一个基本挑战，即总的可用空间足够，但没有一个单独的连续块大到足以满足分配请求。这个练习通过一个精心设计的场景，让你亲身体验“首次适应”分配策略在特定模式下如何导致严重的碎片化。通过推导最大连续空闲块的大小，你将对这种低效性有一个具体而定量的理解 ([@problem_id:3657317])。", "problem": "考虑一个操作系统，它使用连续堆分配和首次适应策略（首次适应策略选择最早出现的、大小不小于请求的空闲孔洞），并在释放时立即合并相邻的空闲孔洞。该系统没有紧凑化，没有分配元数据的开销，并且所有分配都按 $1$ 字节对齐。堆最初由一个大小为 $M$ 字节的单一空闲块组成。\n\n一个请求方在空堆中发出 $n$ 个分配请求，请求大小在 $a$ 和 $b$ 之间交替，从 $a$ 开始，其中 $a$ 和 $b$ 是正整数，且 $a  b$。请求数量 $n \\geq 2$。堆的总大小 $M$ 等于所有 $n$ 个请求大小的总和。在所有 $n$ 次分配完成后，所有大小为 $a$ 的已分配块都被释放。所有大小为 $b$ 的已分配块保持分配状态。\n\n你的任务是找到操作序列完成后最大连续空闲孔洞大小的解析表达式，记为 $H$。", "solution": "在尝试求解之前，将首先根据指定标准对问题进行验证。\n\n### 第 1 步：提取已知条件\n问题陈述中提供的数据、变量和条件如下：\n- 内存分配是连续堆分配。\n- 放置策略是首次适应：选择足够大的最早的（地址最低的）空闲孔洞。\n- 释放在操作上涉及立即合并相邻的空闲孔洞。\n- 没有内存紧凑。\n- 没有分配元数据的开销。\n- 分配按 $1$ 字节对齐。\n- 堆开始时是一个大小为 $M$ 字节的单一空闲块。\n- 发出了一系列 $n$ 个分配请求。\n- 请求的大小在 $a$ 和 $b$ 之间交替，从 $a$ 开始。\n- $a$ 和 $b$ 是正整数，约束条件为 $a  b$。\n- 请求数量 $n \\geq 2$。\n- 堆的总大小 $M$ 等于所有 $n$ 个请求大小的总和。\n- 在所有 $n$ 次分配完成后，所有大小为 $a$ 的已分配块都被释放。\n- 所有大小为 $b$ 的已分配块保持分配状态。\n- 目标是找到最大连续空闲孔洞大小的解析表达式，记为 $H$。\n\n### 第 2 步：使用提取的已知条件进行验证\n对问题陈述的有效性进行评估：\n- **科学依据与客观性**：该问题基于操作系统内存管理的基本概念，特别是连续分配、放置算法（首次适应）和碎片。这些是计算机科学中成熟的、正式的课题。语言精确客观。\n- **适定性**：该问题是自洽的。所有必要条件均已提供：堆的初始状态、分配算法、精确的请求序列、释放过程以及合并规则。堆大小 $M$ 被定义为恰好足够容纳所有分配，确保分配阶段是完全确定的。问题要求的是一个单一、特定的量（$H$），它是所定义过程的直接结果。约束条件 $a > 0$、 $b > 0$、 $a  b$ 和 $n \\geq 2$ 确保了这是一个非平凡的情景。该问题没有欠定、过约束或模棱两可之处。\n\n### 第 3 步：结论与行动\n该问题被认为是有效的，因为它是操作系统领域一个适定的、有科学依据的问题。将推导其解。\n\n### 解题推导\n推导过程通过分析每个主要阶段（分配阶段和释放阶段）之后堆内存布局的状态来进行。\n\n**1. 分配阶段与内存布局**\n\n堆开始时是一个从地址 $0$ 开始、大小为 $M$ 的单一空闲块。分配策略是首次适应。请求的块大小在 $a$ 和 $b$ 之间交替，从 $a$ 开始。请求大小的序列是 $a, b, a, b, \\dots$。\n\n- **请求 1（大小 $a$）**：唯一的空闲块是大小为 $M$ 的整个堆。由于 $M$ 是所有 $n$ 个请求的总和，所以 $M \\geq a$。首次适应策略在堆的起始处（地址 $0$）分配一个大小为 $a$ 的块。堆的状态变为：一个大小为 $a$ 的已分配块，后跟一个大小为 $M-a$ 的单一空闲块。\n\n- **请求 2（大小 $b$）**：唯一的空闲块是从地址 $a$ 开始、大小为 $M-a$ 的那个块。由于 $M-a$ 足以容纳剩下的 $n-1$ 个请求，因此它的大小对于 $b$ 来说是足够的。首次适应策略紧跟在第一个块之后分配一个大小为 $b$ 的块。堆的状态变为：一个大小为 $a$ 的已分配块，一个大小为 $b$ 的已分配块，以及一个大小为 $M-a-b$ 的新空闲块。\n\n这个过程对所有 $n$ 个请求持续进行。在第 $k$ 步（对于 $1 \\leq k \\leq n$），只有一个可用的空闲块，它位于先前已分配块的末尾。首次适应算法别无选择，只能将新块放置在这个唯一的空闲孔洞中。因此，这 $n$ 个块从内存的起始位置被连续分配。\n\n由于所有请求块的总大小恰好是 $M$，在第 $n$ 次分配之后，堆中没有剩余的空闲空间。最终的内存布局由 $n$ 个相邻的块组成。它们大小的序列恰好是请求的序列：$a, b, a, b, \\dots$。\n\n设 $P_i$ 是第 $i$ 个分配的块。如果 $i$ 是奇数，则 $P_i$ 的大小是 $a$；如果 $i$ 是偶数，则其大小是 $b$。最终布局是：\n$[P_1(\\text{大小 } a)][P_2(\\text{大小 } b)][P_3(\\text{大小 } a)][P_4(\\text{大小 } b)] \\cdots [P_n]$\n\n**2. 释放与合并阶段**\n\n在分配阶段之后，所有大小为 $a$ 的块被立即释放。这些是 $i$ 为奇数的块 $P_i$。大小为 $b$ 的块（$i$ 为偶数）保持已分配状态。\n\n让我们分析合并规则：“在释放时立即合并相邻的空闲孔洞”。当一个块被释放时，系统会检查它的直接邻居（较低和较高的地址）。如果一个邻居也是空闲块，它们就会被合并。\n\n考虑一个正在被释放的、大小为 $a$ 的任意块 $P_i$。由于其索引 $i$ 必须是奇数：\n- 它的左邻居是 $P_{i-1}$。由于 $i$ 是奇数且 $i \\geq 1$，所以 $i-1$ 是偶数。如果 $i > 1$，块 $P_{i-1}$ 的大小为 $b$ 并保持已分配状态。因此，它不是空闲的。如果 $i=1$，则没有左邻居。\n- 它的右邻居是 $P_{i+1}$。由于 $i$ 是奇数，所以 $i+1$ 是偶数。如果 $i  n$，块 $P_{i+1}$ 的大小为 $b$ 并保持已分配状态。因此，它不是空闲的。如果 $i=n$（并且 $n$ 是奇数），则没有右邻居。\n\n这意味着，当一个大小为 $a$ 的块被释放时，它的邻居（如果存在的话）总是大小为 $b$ 的已分配块。因此，没有相邻的空闲孔洞可以进行合并。每次释放一个大小为 $a$ 的块都会创建一个大小为 $a$ 的、孤立的空闲孔洞。\n\n由于所有这些空闲孔洞的大小都是 $a$，且它们无法相互合并，因此它们都保持为 $a$ 字节的大小。在所有大小为 $a$ 的块被释放后，内存中将散布着大小为 $a$ 的空闲孔洞，被大小为 $b$ 的已分配块隔开。\n\n因此，最大连续空闲孔洞的大小 $H$ 恰好是 $a$。\n$$ H = a $$\n该结果与 $n$ 的奇偶性无关，只要 $n \\geq 2$。\n\n**结论**\n完成指定的分配和释放序列后，最大连续空闲孔洞的大小是 $a$。", "answer": "$$\n\\boxed{a}\n$$", "id": "3657317"}, {"introduction": "在现代多核处理器上，当多个线程同时请求分配空间时，并发控制成为关键。如果缺乏正确的同步机制，就会出现“检查时-使用时”(Time-of-Check to Time-of-Use, TOCTOU)等竞争条件，破坏数据结构的完整性。本练习将引导你探索一种使用无锁原子操作的高级解决方案，并定量分析其在竞争下的失败概率，从而深入理解高性能并发系统的设计与分析 ([@problem_id:3624135])。", "problem": "一个操作系统中的存储分配器使用位向量（位图）进行空闲空间管理。每个位标记一个块：位值为 $0$ 表示空闲块，位值为 $1$ 表示已分配块。位图被组织成机器字，每个字 $b$ 位；在此系统中，$b = 64$。一个线程扫描位图以查找从索引 $i$ 开始的、长度为 $L_{s} = 96$ 的连续空闲位。这段连续位跨越 $W = 2$ 个 $64$ 位的字。由于“检查时到使用时”（time-of-check to time-of-use）的竞争条件，在该线程验证该段连续位是空闲之后，但在其更新位图之前，另一个线程可能会在这些字中进行分配。\n\nA部分（概念性）。假设标准的原子原语可用，包括“比较并交换”（Compare-And-Swap, CAS），请为扫描线程提出一个无锁验证步骤，以确保在声明占用该段连续位时的正确性。解释导致验证失败的条件，以及线程在失败时应该怎么做。\n\nB部分（计算）。量化第一次尝试时验证失败的概率 $\\phi$。假设以下现实场景和随机模型：\n- 位图有 $N = 2^{20}$ 位。\n- 其他线程并发地执行分配尝试，这被建模为一个齐次泊松过程。共有 $T = 16$ 个这样的线程，每个线程以 $r = 50{,}000$ 次尝试/秒 的速率发起分配尝试。\n- 其他线程的每次分配尝试都针对一段长度为 $L_{a} = 64$ 的连续位，其起始位置在位图中所有有效的起始位置中均匀随机选择。假设边界效应可以忽略不计，因为扫描线程找到的连续位远离位图的边缘。\n- 扫描线程最后一次读取这两个字与它对这两个字进行第一次 CAS 尝试之间的时间窗口（危险窗口）为 $\\Delta = 8 \\,\\mu\\mathrm{s}$。\n- 假设在这个短暂的时间窗口内，几乎所有并发尝试都会成功，因此，将任何重叠的尝试视为导致至少一个字的值发生变化的修改是足够的。\n\n在这些假设下，从第一性原理推导出 $\\phi$。将你最终的 $\\phi$ 的十进制答案四舍五入到四位有效数字。不要使用百分号；将 $\\phi$ 表示为无单位的纯小数。", "solution": "该问题经评估具有科学依据、问题明确、客观且内部一致。提供了唯一解所需的所有数据。该场景描述了操作系统中一个经典的“检查时到使用时”（TOCTOU）竞争条件，而使用原子原语和随机模型对其进行分析的要求是计算机系统工程中一个有效且标准的练习。\n\nA部分：无锁验证\n核心问题是扫描线程检查空闲空间与其后续使用（分配）该空间之间的竞争条件。在扫描线程的读操作和写操作之间的时间间隔内，一个并发线程可以修改位图字的状态。为了在不使用传统锁的情况下解决这个问题，扫描线程必须在提交自己的更新之前，原子地验证状态没有发生变化。 “比较并交换”（CAS）原子原语非常适合此目的。\n\n为扫描线程提出的无锁验证和更新过程如下：\n1.  线程扫描位图，并识别出一段长度为 $L_s = 96$ 的候选空闲位。这段连续位跨越 $W=2$ 个字，我们将其分别表示为 $word_1$ 和 $word_2$，位于内存地址 $addr_1$ 和 $addr_2$。\n2.  线程读取这两个字的当前值，我们称之为 $old\\_val_1$ 和 $old\\_val_2$。它确认这些值确实代表了所需的连续空闲位块。\n3.  线程计算分配这 96 位后将产生的新值 $new\\_val_1$ 和 $new\\_val_2$。这涉及到将相应的 96 个位从 $0$ 改为 $1$。\n4.  为了声明占用该空间，线程执行两次连续的 CAS 操作。双字 CAS（DCAS）将是理想的选择，因为它会使两个字的更新成为原子操作，但假设只有单字 CAS 可用，则序列将是：\n    - `success_1 = CAS(addr_1, old_val_1, new_val_1)`\n    - `success_2 = CAS(addr_2, old_val_2, new_val_2)`\n\n验证步骤隐含在 CAS 操作中。`CAS(address, expected, new)` 操作仅当 `address` 处的当前值与 `expected` 相同时才会成功。\n\n如果 `success_1` 为假或 `success_2` 为假，则验证失败。这种情况精确地发生在：当一个并发线程在扫描线程读取了 $word_1$ 或 $word_2$（或两者）的初始值（$old\\_val_1$ 和 $old\\_val_2$）之后，修改了它们。内存位置的值不再与期望值匹配，因此 CAS 操作失败，从而正确地发出状态已更改的信号，并防止了损坏的分配。\n\n失败后，线程必须采取纠正措施。如果第一个 CAS 失败，状态保持不变，线程可以简单地重新开始扫描以寻找新的空闲块。如果第一个 CAS 成功但第二个失败，位图将处于一个中间状态，其中一个字已更新而另一个未更新。尝试通过写回 $old\\_val_1$ 来“回滚”第一个 CAS 是不安全的，因为它可能会覆盖在此期间另一个线程进行的另一个合法的分配。最稳健且最简单的恢复策略是接受部分分配尝试已失败，并且资源可能已被浪费。线程应完全中止当前尝试，并**从头开始**或从新位置重新开始扫描，以寻找另一个空闲的连续位。部分声明的空间通常由系统级垃圾回收处理，或者通过设计分配器来避免关键分配跨越字边界来处理。\n\nB部分：失败概率\n我们被要求量化验证失败的概率 $\\phi$。如果在危险窗口 $\\Delta$ 期间，两个目标字中至少有一个被并发线程修改，就会发生这种失败。\n\n并发分配尝试被建模为一个齐次泊松过程。总尝试率是并发线程数 $T$ 与每个线程的速率 $r$ 的乘积。\n$$ \\lambda_{\\text{total}} = T \\times r $$\n代入给定值，$T=16$ 和 $r=50{,}000 \\, \\text{s}^{-1}$：\n$$ \\lambda_{\\text{total}} = 16 \\times 50{,}000 \\, \\text{s}^{-1} = 800{,}000 \\, \\text{s}^{-1} = 8 \\times 10^{5} \\, \\text{s}^{-1} $$\n\n接下来，我们确定由另一个线程进行的单次随机分配尝试与我们的目标区域发生冲突的概率 $P_{\\text{conflict}}$。我们的目标区域跨越 $W=2$ 个字，覆盖 $2 \\times b = 2 \\times 64 = 128$ 位。一次并发分配是针对一段长度为 $L_a = 64$ 的连续位。其起始位置在大小为 $N = 2^{20}$ 位的位图中所有有效的起始位置中均匀随机选择。\n\n长度为 $L_a$ 的分配的有效起始位置数量为 $N_{\\text{pos}} = N - L_a + 1$。\n如果并发分配的 $L_a$ 位范围与我们的 $2b$ 位目标范围重叠，则发生冲突。设目标范围是长度为 $2b$ 的区间。从给定位置开始的长度为 $L_a$ 的分配，如果其区间与目标区间重叠，则会发生冲突。此类冲突起始位置的数量由两个区间长度之和减一给出。\n$$ N_{\\text{conflict}} = (2b) + L_a - 1 $$\n当 $b=64$ 和 $L_a=64$ 时：\n$$ N_{\\text{conflict}} = 2 \\times 64 + 64 - 1 = 128 + 64 - 1 = 191 $$\n单次尝试导致冲突的概率是冲突起始位置数与总可能起始位置数的比率：\n$$ P_{\\text{conflict}} = \\frac{N_{\\text{conflict}}}{N_{\\text{pos}}} = \\frac{2b + L_a - 1}{N - L_a + 1} $$\n代入数值：\n$$ P_{\\text{conflict}} = \\frac{191}{2^{20} - 64 + 1} = \\frac{191}{1,048,576 - 63} = \\frac{191}{1,048,513} $$\n\n*冲突*分配尝试的速率 $\\lambda_{\\text{conflict}}$ 是总尝试速率乘以冲突概率：\n$$ \\lambda_{\\text{conflict}} = \\lambda_{\\text{total}} \\times P_{\\text{conflict}} = (T \\times r) \\times \\frac{2b + L_a - 1}{N - L_a + 1} $$\n$$ \\lambda_{\\text{conflict}} = 8 \\times 10^5 \\, \\text{s}^{-1} \\times \\frac{191}{1,048,513} \\approx 145.73 \\, \\text{s}^{-1} $$\n\n在危险窗口 $\\Delta = 8 \\,\\mu\\mathrm{s} = 8 \\times 10^{-6} \\, \\mathrm{s}$ 内的冲突事件数 $k$ 服从泊松分布 $P(k) = \\frac{\\mu^k e^{-\\mu}}{k!}$。此区间内的平均事件数 $\\mu$ 为：\n$$ \\mu = \\lambda_{\\text{conflict}} \\times \\Delta $$\n$$ \\mu = \\left( (T \\times r) \\frac{2b + L_a - 1}{N - L_a + 1} \\right) \\Delta $$\n代入数值：\n$$ \\mu = \\left( 8 \\times 10^5 \\times \\frac{191}{1,048,513} \\right) \\times 8 \\times 10^{-6} $$\n$$ \\mu = 6.4 \\times \\frac{191}{1,048,513} = \\frac{1222.4}{1,048,513} \\approx 0.001165839 $$\n\n如果在窗口 $\\Delta$ 内发生至少一次冲突事件，验证就会失败。其概率 $\\phi$ 为 $P(k \\ge 1)$。\n$$ \\phi = P(k \\ge 1) = 1 - P(k=0) $$\n对于泊松分布，$P(k=0) = \\frac{\\mu^0 e^{-\\mu}}{0!} = e^{-\\mu}$。\n$$ \\phi = 1 - e^{-\\mu} = 1 - \\exp(-\\mu) $$\n代入 $\\mu$ 的值：\n$$ \\phi = 1 - \\exp(-0.001165839) $$\n$$ \\phi \\approx 1 - 0.998834834 = 0.001165166 $$\n将结果四舍五入到四位有效数字，我们得到：\n$$ \\phi \\approx 0.001165 $$\n用科学记数法表示，即为 $1.165 \\times 10^{-3}$。", "answer": "$$\\boxed{1.165 \\times 10^{-3}}$$", "id": "3624135"}]}