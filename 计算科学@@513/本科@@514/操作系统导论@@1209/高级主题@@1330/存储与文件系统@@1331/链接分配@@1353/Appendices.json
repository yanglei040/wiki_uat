{"hands_on_practices": [{"introduction": "理论学习之后，让我们通过动手实践来巩固知识。我们首先从一个基本问题开始：在链式分配中，存储空间是如何被有效利用的？这个练习将引导你从第一性原理出发，量化分析链式分配中的指针开销，并推导出在给定的开销限制下，磁盘块大小需要满足的临界条件。通过这个实践 ([@problem_id:3653104])，你将对文件系统设计中数据与元数据之间的权衡建立起一个具体的、定量的认识。", "problem": "一个文件系统使用链接分配，其中每个磁盘块的总大小为 $B$ 字节。在每个块中，存储一个大小为 $p$ 字节的指针以定位文件中的下一个块，而块的其余部分用于存储文件数据。假设每个块中都存在此指针字段。指针所占用的字节被视为元数据，元数据与有效数据的比率定义为指针开销分数。一个系统设计约束要求，对于每个块，指针开销不得超过该块中存储的有效数据的指定分数 $\\theta$。\n\n从以下定义出发：\n- 每块的有效数据等于总字节数减去元数据字节数，以及\n- 指针开销分数定义为元数据字节数与有效数据字节数的比率，\n\n请从基本原理出发，推导出一个关于阈值块大小 $B_{\\text{threshold}}$（用 $p$ 和 $\\theta$ 表示）的闭式表达式，在该阈值下，指针开销等于允许的分数 $\\theta$。将此阈值解释为一个边界，使得对于任何小于 $B_{\\text{threshold}}$ 的块大小 $B$，每块的开销超过有效数据的 $\\theta$ 倍；而对于任何大于或等于 $B_{\\text{threshold}}$ 的 $B$，每块的开销至多是有效数据的 $\\theta$ 倍。假设 $B>p$ 且 $\\theta>0$。\n\n请将最终答案表示为一个以字节为单位的、仅含 $p$ 和 $\\theta$ 的闭式解析表达式。不要代入数值，最终方框答案内也不要包含单位。", "solution": "题目要求在一个使用链接分配的文件系统中，推导阈值块大小 $B_{\\text{threshold}}$ 的闭式表达式。推导必须从题目陈述中定义的基本原理出发。\n\n设磁盘块的总大小为 $B$ 字节。\n设每个块中存储的指针大小为 $p$ 字节。该指针构成元数据。\n设允许的最大指针开销分数为 $\\theta$。我们已知假设条件 $B > p$ 和 $\\theta > 0$。\n\n首先，我们将题目陈述中提供的定义形式化。\n\n设单个块中元数据的大小为 $M$。根据题目，这仅包含指针。\n$$M = p$$\n\n设单个块中存储的有效数据量为 $D$。题目将其定义为总块大小减去元数据字节数。\n$$D = B - M$$\n代入 $M$ 的表达式，我们得到有效数据作为 $B$ 和 $p$ 的函数：\n$$D(B) = B - p$$\n\n接下来，我们定义指针开销分数，记为 $O_f$。题目将其定义为元数据字节数与有效数据字节数的比率。\n$$O_f = \\frac{M}{D}$$\n代入 $M$ 和 $D(B)$ 的表达式，我们可以将开销分数表示为块大小 $B$ 的函数：\n$$O_f(B) = \\frac{p}{B - p}$$\n\n系统设计施加了一个约束，即指针开销不得超过有效数据的分数 $\\theta$。这可以转化为不等式 $M \\le \\theta D$。两边同除以 $D$（由于 $B > p$ 意味着 $D > 0$，所以 $D$ 是正数），此约束等价于：\n$$\\frac{M}{D} \\le \\theta$$\n代入我们的开销分数表达式，该约束为：\n$$O_f(B) = \\frac{p}{B - p} \\le \\theta$$\n\n题目要求的是阈值块大小 $B_{\\text{threshold}}$，它被定义为指针开销分数*等于*允许的分数 $\\theta$ 时的特定块大小。这代表了约束的边界情况。因此，我们令 $O_f(B_{\\text{threshold}}) = \\theta$。\n$$\\frac{p}{B_{\\text{threshold}} - p} = \\theta$$\n\n现在我们求解这个关于 $B_{\\text{threshold}}$ 的方程。鉴于 $\\theta > 0$ 且要求 $B_{\\text{threshold}} > p$，我们可以安全地将方程两边同乘以 $(B_{\\text{threshold}} - p)$：\n$$p = \\theta (B_{\\text{threshold}} - p)$$\n将右侧的 $\\theta$ 分配进去得到：\n$$p = \\theta B_{\\text{threshold}} - \\theta p$$\n为了解出 $B_{\\text{threshold}}$，我们首先分离出包含它的项：\n$$\\theta B_{\\text{threshold}} = p + \\theta p$$\n将右侧的项提取公因子 $p$ 得到：\n$$\\theta B_{\\text{threshold}} = p(1 + \\theta)$$\n最后，由于 $\\theta > 0$，我们可以两边同除以 $\\theta$ 以获得阈值块大小的闭式表达式：\n$$B_{\\text{threshold}} = \\frac{p(1 + \\theta)}{\\theta}$$\n\n这个表达式也可以写成 $B_{\\text{threshold}} = p\\left(1 + \\frac{1}{\\theta}\\right)$。\n\n为了验证题目中提供的解释，我们考察开销分数函数 $O_f(B) = \\frac{p}{B - p}$ 的行为。它关于 $B$ 的导数是 $\\frac{d(O_f)}{dB} = -\\frac{p}{(B - p)^2}$。由于 $p > 0$ 且 $(B-p)^2 > 0$，对于 $B > p$，该导数恒为负。这意味着 $O_f(B)$ 是一个关于 $B$ 的单调递减函数。\n因此：\n- 对于任何块大小 $B < B_{\\text{threshold}}$，必然有 $O_f(B) > O_f(B_{\\text{threshold}})$，即 $\\frac{p}{B-p} > \\theta$。这与每块的开销超过有效数据的 $\\theta$ 倍的条件相符。\n- 对于任何块大小 $B \\ge B_{\\text{threshold}}$，必然有 $O_f(B) \\le O_f(B_{\\text{threshold}})$，即 $\\frac{p}{B-p} \\le \\theta$。这与每块的开销至多是有效数据的 $\\theta$ 倍的条件相符。\n因此，推导出的 $B_{\\text{threshold}}$ 表达式与题目陈述中给出的所有条件和解释都是一致的。", "answer": "$$\\boxed{\\frac{p(1 + \\theta)}{\\theta}}$$", "id": "3653104"}, {"introduction": "理解了空间效率后，我们再来关注时间效率。链式分配的一个显著缺点是难以高效地访问文件末尾，这使得某些操作的成本很高。本练习 ([@problem_id:3653085]) 模拟了文件截断操作，要求你计算并比较在链式分配和索引分配两种模式下的性能差异。通过这个具体的性能分析，你将深刻理解不同文件分配策略的优缺点，并认识到算法优化在操作系统中的重要性。", "problem": "考虑一个文件系统，它支持两种文件块分配方法：通过文件分配表（FAT）的链接分配和通过索引节点（inode）的索引分配。在链接分配中，文件的目录条目仅存储指向第一个块的指针；每个块存储一个指向下一个块的指针。在索引分配中，索引节点（inode）将指向所有数据块的指针存储在一个单级索引块中，该索引块保存在主内存中。\n\n假设一个文件当前占用了 $N=50{,}000$ 个块。一个应用程序发出了 $B=10{,}000$ 次连续的截断操作，每次操作都精确地移除文件的最后一个块。所有元数据结构都驻留在主内存中。以下操作成本适用：\n- 读取单个指针（从FAT或索引块）的成本为 $t_{r} = 80$ 纳秒。\n- 写入单个指针（到FAT或索引块）的成本为 $t_{w} = 120$ 纳秒。\n- 在空闲空间位图中写入一位的成本为 $t_{f} = 150$ 纳秒。\n- 每次截断调用更新文件元数据（例如，目录条目或inode中的文件大小）的成本为 $t_{i} = 200$ 纳秒。\n\n在没有尾指针的链接分配下，截断一个当前长度为 $m$ 的文件的最后一个块需要从头部遍历链表到尾部的前一个块，以更新该前驱块的下一个指针为空终止符。在索引分配下，截断最后一个块需要清除索引中的最后一个指针，并且不需要遍历。\n\n您必须：\n1. 根据链接分配和索引分配的核心定义，推导每种方法在每个截断步骤中执行的指针更新次数，并对链接分配的 $B$ 次连续截断进行汇总。\n2. 使用给定的成本，计算使用链接分配和索引分配，以 $B$ 次连续的单块截断方式移除最后 $B$ 个块的总时间。\n3. 假设操作系统对链接分配应用了批量优化：它一次性遍历链表到新的尾部（第 $(N-B)$ 个块），执行一次指针写入以在此处终止列表，在位图中写入 $B$ 位，并执行一次元数据更新。推导这种批量方法的总时间。\n4. 最后，报告使用 $B$ 次连续单块截断的链接分配总时间与使用 $B$ 次连续单块截断的索引分配总时间的比率，作为一个无量纲的数字。将最终比率四舍五入到四位有效数字。为清晰起见，所有中间时间都以秒表示，但要求的最终比率是无量纲的。", "solution": "首先验证问题，以确保其科学上合理、问题提出得当且客观。\n\n### 步骤 1：提取已知条件\n- **文件系统方法**：链接分配（FAT，无尾指针）和索引分配（inode，单级索引）。\n- **初始状态**：文件大小为 $N = 50{,}000$ 个块。\n- **操作**：$B = 10{,}000$ 次连续的单块截断。\n- **内存假设**：所有元数据（FAT、索引块）都在主内存中。\n- **操作成本**：\n    - 指针读取时间：$t_r = 80 \\text{ ns}$\n    - 指针写入时间：$t_w = 120 \\text{ ns}$\n    - 空闲空间位图位写入时间：$t_f = 150 \\text{ ns}$\n    - 每次调用的元数据更新时间（例如，文件大小）：$t_i = 200 \\text{ ns}$\n- **链接分配算法（连续）**：对于一个有 $m$ 个块的文件，遍历到第 $m-1$ 个块并更新其指针。\n- **索引分配算法（连续）**：清除索引块中的最后一个指针。\n- **链接分配算法（批量）**：一次性遍历到第 $N-B$ 个块，一次指针写入， $B$ 次位图写入，一次元数据更新。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题提出了一个来自操作系统领域的典型但标准的算法分析问题。链接和索引文件分配的概念是基础性的。成本模型虽然简化（例如，忽略缓存效应并假设恒定的内存访问时间），但对于比较性能分析来说是一个有效的基础。所有参数都定义清晰，任务明确。问题是自包含的且逻辑一致。它不违反科学原理，问题没有提得不好，并且是客观呈现的。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供完整的解决方案。\n\n解决方案通过解决问题的四个要求部分来进行。\n\n### 1 & 2. 连续单块截断的总时间\n\n我们将推导两种分配方法进行 $B$ 次连续截断的成本。\n\n**链接分配（连续）**\n\n首先，我们分析单个截断步骤的成本。设第 $k$ 次截断操作发生时，文件有 $m_k$ 个块，其中 $k \\in \\{1, 2, \\dots, B\\}$。初始时，$m_1=N$。第一次截断后，$m_2 = N-1$，依此类推。第 $k$ 次截断前的块数为 $m_k = N - (k-1)$。\n\n要截断最后一个块（$m_k$），系统必须遍历块的链表以找到其前驱块，即块 $m_k - 1$。这需要读取块 $1, 2, \\dots, m_k-2$ 中的指针。\n- 第 $k$ 次截断的指针读取次数：$N_{\\text{reads},k} = m_k - 2 = (N - k + 1) - 2 = N - k - 1$。\n- 到达块 $m_k - 1$ 后，其指针被覆写为空终止符。这构成一次指针写入。\n- 第 $k$ 次截断的指针写入次数：$N_{\\text{writes},k} = 1$。\n\n第 $k$ 次截断的总成本 $C_{\\text{linked}, k}$ 是指针读取、一次指针写入、一次位图更新和一次元数据更新的成本之和：\n$$C_{\\text{linked},k} = (N - k - 1)t_r + t_w + t_f + t_i$$\n为了找到总时间 $T_{\\text{linked, succ}}$，我们将这个成本对所有 $B$ 次截断（从 $k=1$ 到 $k=B$）求和：\n$$T_{\\text{linked, succ}} = \\sum_{k=1}^{B} C_{\\text{linked},k} = \\sum_{k=1}^{B} \\left[ (N-k-1)t_r + t_w + t_f + t_i \\right]$$\n$$T_{\\text{linked, succ}} = t_r \\sum_{k=1}^{B} (N-k-1) + B(t_w+t_f+t_i)$$\n求和项是一个等差数列的和：\n$$\\sum_{k=1}^{B} (N-k-1) = (N-2) + (N-3) + \\dots + (N-B-1)$$\n这个和可以计算为 $\\frac{\\text{项数}}{2} \\times (\\text{第一项} + \\text{最后一项})$：\n$$\\sum_{k=1}^{B} (N-k-1) = \\frac{B}{2}((N-2) + (N-B-1)) = \\frac{B(2N-B-3)}{2}$$\n所以，总时间是：\n$$T_{\\text{linked, succ}} = \\left[\\frac{B(2N-B-3)}{2}\\right]t_r + B(t_w+t_f+t_i)$$\n代入给定值：\n$N = 50000$, $B = 10000$, $t_r = 80 \\times 10^{-9} \\text{ s}$, $t_w = 120 \\times 10^{-9} \\text{ s}$, $t_f = 150 \\times 10^{-9} \\text{ s}$, $t_i = 200 \\times 10^{-9} \\text{ s}$。\n$$T_{\\text{linked, succ}} = \\left[\\frac{10000(2 \\cdot 50000 - 10000 - 3)}{2}\\right](80 \\times 10^{-9}) + 10000(120+150+200) \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = \\left[\\frac{10000(89997)}{2}\\right](80 \\times 10^{-9}) + 10000(470) \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = (449,985,000)(80 \\times 10^{-9}) + 4,700,000 \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = 35.9988 \\text{ s} + 0.0047 \\text{ s} = 36.0035 \\text{ s}$$\n\n**索引分配（连续）**\n\n对于索引分配，inode 指向内存中的一个索引块，该索引块包含一个指向数据块的指针数组。要截断最后一个块，系统只需要修改这个索引块。\n- 对于每次截断，指向最后一个块的指针被清除（设置为空）。这是一次指针写入。不需要为遍历而进行指针读取。\n- 每次截断的指针读取次数：$N_{\\text{reads}} = 0$。\n- 每次截断的指针写入次数：$N_{\\text{writes}} = 1$。\n\n单次截断的成本 $C_{\\text{indexed}}$ 是恒定的：\n$$C_{\\text{indexed}} = t_w + t_f + t_i$$\n$B$ 次连续截断的总时间 $T_{\\text{indexed, succ}}$ 是：\n$$T_{\\text{indexed, succ}} = B \\times C_{\\text{indexed}} = B(t_w+t_f+t_i)$$\n代入值：\n$$T_{\\text{indexed, succ}} = 10000(120 + 150 + 200) \\times 10^{-9} = 10000(470) \\times 10^{-9} = 4,700,000 \\times 10^{-9} = 0.0047 \\text{ s}$$\n\n### 3. 批量优化的链接分配的总时间\n\n在这种情况下，移除 $B$ 个块的总操作是通过单次遍历完成的。\n1.  **遍历**：系统遍历到新的尾块，即块 $N-B$。这需要读取块 $1, 2, \\dots, N-B-1$ 中的指针。\n    指针读取次数：$N - B - 1$。\n2.  **指针写入**：块 $N-B$ 中的指针被更新为空终止符。\n    指针写入次数：$1$。\n3.  **位图更新**：所有 $B$ 个被释放的块在空闲空间位图中被标记。\n    位图写入次数：$B$。\n4.  **元数据更新**：对整个批量操作，文件大小只更新一次。\n    元数据更新次数：$1$。\n\n总时间 $T_{\\text{linked, batch}}$ 是：\n$$T_{\\text{linked, batch}} = (N-B-1)t_r + t_w + B t_f + t_i$$\n代入值：\n$$T_{\\text{linked, batch}} = (50000 - 10000 - 1)(80 \\times 10^{-9}) + 120 \\times 10^{-9} + 10000(150 \\times 10^{-9}) + 200 \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = (39999)(80 \\times 10^{-9}) + 120 \\times 10^{-9} + 1,500,000 \\times 10^{-9} + 200 \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = (3,199,920 + 120 + 1,500,000 + 200) \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = 4,700,240 \\times 10^{-9} = 0.00470024 \\text{ s}$$\n\n### 4. 连续截断时间的比率\n\n最后，我们计算连续链接分配的总时间与连续索引分配的总时间的比率。\n$$R = \\frac{T_{\\text{linked, succ}}}{T_{\\text{indexed, succ}}} = \\frac{\\left[\\frac{B(2N-B-3)}{2}\\right]t_r + B(t_w+t_f+t_i)}{B(t_w+t_f+t_i)}$$\n$$R = \\frac{\\left[\\frac{B(2N-B-3)}{2}\\right]t_r}{B(t_w+t_f+t_i)} + 1 = \\frac{(2N-B-3)t_r}{2(t_w+t_f+t_i)} + 1$$\n使用数值：\n$$R = \\frac{(2 \\cdot 50000 - 10000 - 3)(80)}{2(120+150+200)} + 1$$\n$$R = \\frac{(89997)(80)}{2(470)} + 1$$\n$$R = \\frac{7199760}{940} + 1$$\n$$R \\approx 7659.31914... + 1 = 7660.31914...$$\n四舍五入到四位有效数字，比率为 $7660$。\n或者，使用计算出的时间：\n$$R = \\frac{36.0035 \\text{ s}}{0.0047 \\text{ s}} \\approx 7660.31914...$$\n结果是一致的。最终四舍五入的值是 $7660$。", "answer": "$$\\boxed{7660}$$", "id": "3653085"}, {"introduction": "一个优秀的文件系统不仅要高效，还必须足够健壮。在最后一个练习中，我们将直面一个真实世界中可能发生的故障场景：由于数据损坏，导致两个不同的文件意外共享了同一数据块。这个思想实验 ([@problem_id:3653075]) 要求你在有限的元数据条件下，像文件系统检查工具一样，运用图遍历的知识来检测并修复这种严重的一致性问题。这个挑战将让你体会到，在系统设计中，保证数据正确性与完整性是多么至关重要。", "problem": "一个操作系统对文件使用链接分配。根据链接分配的定义，每个文件表示为一个磁盘块的单向链表：目录存储每个文件的头块标识符，每个已分配的块存储一个指向文件中下一个块标识符的指针，或者一个特殊的空值 $0$ 来标记文件结尾。空闲空间被追踪为一个单向链式空闲列表，其头指针存储在超级块中。该系统不维护一个将块映射到后继者的全局文件分配表（FAT），也没有任何持久化的按块的所有者或引用计数；磁盘上仅存在目录头、空闲列表头和块内后继指针。\n\n考虑一个磁盘块标识符为 $1,2,\\dots,12$ 的小磁盘。目录列出了两个文件，File $A$ 和 File $B$，它们的头块分别是 $2$ 和 $7$。空闲列表的头是 $1$。块内后继指针 $n(b)$ 如下（其中 $n(b)=0$ 表示文件结尾）：\n\n- File $A$：$n(2)=4$, $n(4)=6$, $n(6)=9$, $n(9)=0$。\n- File $B$：$n(7)=8$, $n(8)=6$（然后遵循 $n(6)$ 的指向）。\n- 空闲列表：$n(1)=3$, $n(3)=5$, $n(5)=10$, $n(10)=11$, $n(11)=12$, $n(12)=0$。\n\n在向 File $B$ 写入期间发生崩溃后，系统正处于上述状态。你需要从有向图中的可达性的第一性原理出发进行推理：将每个磁盘块视为一个顶点，每个块内后继指针视为一条有向边 $b \\to n(b)$，每个目录头视为一个根节点。一个一致性检查器必须 (i) 检测两个文件是否通过指针别名共享一个块（即存在一个可以从两个文件根节点到达的块），以及 (ii) 仅使用可用的磁盘上元数据和任何临时的内存中结构来解决不一致性，而不依赖于任何预先存在的全局索引。如果一个解决方案不破坏任何剩余的文件数据，则被认为是正确的；如果在没有额外空间的情况下无法完全保留两个文件，该解决方案可以使用空闲块复制数据或截断最多一个文件，但它决不能释放任何仍被引用的块。\n\n在以下哪些过程中，既能检测到此特定状态下的共享块不一致性，又能根据所述约束产生一个正确的解决方案？选择所有适用的选项。\n\nA. 从每个文件的头部开始分别遍历其链，对单个链使用循环检测算法（例如，Floyd的龟兔算法）以确保该文件内没有循环；如果没有发现每个文件的循环或悬空指针，则声明系统一致。不跨文件跟踪任何全局访问信息。\n\nB. 从 File $A$ 和 File $B$ 的头部开始执行根导向遍历，维护一个从块标识符到引用计数的内存中映射 $c(b)$，初始值设为 $0$。每次从任何文件根发现 $b$ 时，增加 $c(b)$。如果任何 $c(b)>1$，报告共享块。为解决问题，选择一个文件（例如，File $B$），通过从空闲列表中分配新块并将共享块的内容和后继结构复制到新块中来复制共享的后缀；然后重新连接该文件中的前驱节点，使其指向第一个新块。从空闲列表中移除新分配的块。保持另一个文件不变。\n\nC. 通过设置 $n(8)=0$ 来在共享段之前截断 File $B$，并立即将块 $6$ 和 $9$ 链接到空闲列表的头部，将它们标记为空闲，因为 File $B$ 不再需要它们。\n\nD. 仅检查空闲列表是否存在异常（例如循环或与自身重叠）。如果空闲列表是一个与文件头不相交的有效简单链，则声明系统一致，因为在链接分配下，任何问题必然会体现在空闲列表中。\n\nE. 遍历两个文件，同时维护一个内存中的已访问集合 $V$ 和一个“首次拥有者”映射 $o(b)$，该映射记录了首次发现一个块是从哪个文件。当发现一个块 $b$ 已经存在于 $V$ 中，但其 $o(b)$ 是一个不同的文件时，检测到交叉链接。通过在后发现的文件的前驱节点处截断它（例如，为 File $B$ 设置 $n(8)=0$）来解决，并且不要将任何共享块添加到空闲列表中。保持先发现的文件的链完整。", "solution": "在尝试解决方案之前，将首先验证问题陈述的科学合理性、自洽性和清晰度。\n\n### 第一步：提取已知条件\n- **文件系统模型**：对文件使用链接分配。\n- **文件结构**：每个文件是磁盘块的单向链表。目录存储每个文件的头块。每个块包含一个指向下一个块标识符的指针 $n(b)$。指针值为 $0$ 表示文件结尾。\n- **空闲空间管理**：一个单向链式的空闲块列表，其头指针存储在超级块中。\n- **系统约束**：没有全局文件分配表（FAT）。没有持久化的按块的所有者或引用计数。磁盘上唯一的元数据是目录头、空闲列表头和块内后继指针。\n- **磁盘状态**：\n    - 块标识符：$1, 2, \\dots, 12$。\n    - File A 头：块 $2$。\n    - File B 头：块 $7$。\n    - 空闲列表头：块 $1$。\n- **后继指针, $n(b)$**：\n    - 对于 File A 的链：$n(2)=4$, $n(4)=6$, $n(6)=9$, $n(9)=0$。\n    - 对于 File B 的链：$n(7)=8$, $n(8)=6$。\n    - 对于空闲列表：$n(1)=3$, $n(3)=5$, $n(5)=10$, $n(10)=11$, $n(11)=12$, $n(12)=0$。\n- **问题背景**：系统在崩溃后处于此状态。\n- **任务**：一致性检查器必须：\n    1. 检测共享块（指针别名）。\n    2. 仅使用磁盘上的元数据和临时的内存中结构来解决不一致性。\n- **解决方案约束**：\n    1. 不得损坏剩余的文件数据。\n    2. 如果无法完全保留，可以利用空闲块复制数据或截断最多一个文件。\n    3. 不得释放任何仍被文件引用的块。\n\n### 第二步：使用提取的已知条件进行验证\n问题描述了一个简化但连贯的链接分配文件系统模型。这是操作系统入门课程中的一个标准主题。状态使用有向图模型进行描述，其中块是顶点，指针是边。这是一种形式化且严谨的表示方法。\n\n- **科学依据**：该问题基于数据结构（链表、图）和操作系统（文件系统管理、崩溃一致性）的原理。这种特定的不一致性——两个文件链指向同一个块——是此类系统中一种现实的故障模式，尤其是在没有更高级的完整性机制的情况下。\n- **问题定义良好**：磁盘的初始状态（所有相关的指针和列表头）被完全指定。一致性检查器的任务（检测和解决）以及对正确解决方案的约束被明确定义。这使得对所提出的算法可以进行无歧义的评估。\n- **客观性**：问题以精确的技术术语陈述（例如，“单向链表”、“指针别名”、“根导向遍历”）。没有主观或模棱两可的语言。\n\n该问题没有违反任何无效性标准。例如，它不是自相矛盾的；$n(b)$ 的值定义了一个特定但存在不一致的图结构。对于手头的任务，它没有被不充分地指定。该问题正确地将一个实际的文件系统问题形式化为一个可解的图论问题。\n\n### 第三步：结论与行动\n问题陈述是**有效的**。将通过分析给定状态和评估每个提议的程序来推导解决方案。\n\n### 系统状态分析\n首先，我们根据已知条件构建磁盘块的状态。\n- **File A 链**：从头块 $2$ 开始，链为 $2 \\to n(2)=4 \\to n(4)=6 \\to n(6)=9 \\to n(9)=0$。分配给 File A 的块是 $\\{2, 4, 6, 9\\}$。\n- **File B 链**：从头块 $7$ 开始，链为 $7 \\to n(7)=8 \\to n(8)=6$。由于 $n(8)=6$，File B 的链与 File A 的链合并。从 File B 头部开始的完整路径是 $7 \\to 8 \\to 6 \\to 9 \\to 0$。从 File B 头部可达的块是 $\\{7, 8, 6, 9\\}$。\n- **共享块**：块 $6$ 和 $9$ 可以从 File A 和 File B 的头部到达。这是一个“共享块”或“交叉链接”的不一致性。\n- **空闲列表链**：从头块 $1$ 开始，链为 $1 \\to 3 \\to 5 \\to 10 \\to 11 \\to 12 \\to 0$。空闲块是 $\\{1, 3, 5, 10, 11, 12\\}$。\n- **块分配摘要**：\n    - 仅由 File A 使用：$\\{2, 4\\}$\n    - 仅由 File B 使用：$\\{7, 8\\}$\n    - 由 File A 和 File B 共享：$\\{6, 9\\}$\n    - 空闲：$\\{1, 3, 5, 10, 11, 12\\}$\n\n任务是评估那些既能检测到块 $\\{6, 9\\}$ 被共享，又能根据给定约束解决此问题的程序。\n\n### 逐项分析\n\n**A. 从每个文件的头部开始分别遍历其链...使用循环检测算法...不跨文件跟踪任何全局访问信息。**\n- **检测**：此过程检查单个列表*内部*的病态情况。File A 的链，$2 \\to 4 \\to 6 \\to 9 \\to 0$，是一条没有循环的简单路径。File B 的链，$7 \\to 8 \\to 6 \\to 9 \\to 0$，也是一条没有循环的简单路径。由于该过程明确说明“不跨文件跟踪任何全局访问信息”，因此它没有机制来得知块 $6$（以及随后的 $9$）是两个列表的成员。因此，此过程将无法检测到共享块不一致性。\n- **结论**：**不正确**。\n\n**B. 从 File A 和 File B 的头部开始执行根导向遍历，维护一个内存中映射 $c(b)$ 从块标识符到引用计数...如果任何 $c(b)>1$，报告共享块。为解决问题，选择一个文件...并通过从空闲列表中分配新块来复制共享的后缀...**\n- **检测**：此过程使用引用计数方法。\n    1. 初始化一个映射 $c(b) \\to 0$ 对于所有块 $b$。\n    2. 遍历 File A ($2 \\to 4 \\to 6 \\to 9$)：这将设置 $c(2)=1$, $c(4)=1$, $c(6)=1$, $c(9)=1$。\n    3. 遍历 File B ($7 \\to 8 \\to 6 \\to 9$)：这将设置 $c(7)=1$, $c(8)=1$。当访问块 $6$ 时，它会增加 $c(6)$，使得 $c(6)=2$。\n    4. 对于块 $6$，满足条件 $c(b)>1$。成功检测到不一致性。\n- **解决方案**：该过程建议为一个文件复制共享的后缀。共享的后缀从块 $6$ 开始。它由块 $\\{6, 9\\}$ 组成。\n    1. 从空闲列表分配两个新块（例如，块 $1$ 和 $3$）。新的空闲列表头变为 $5$。\n    2. 将块 $6$ 的内容复制到块 $1$。将块 $9$ 的内容复制到块 $3$。\n    3. 为新链设置指针：$n(1)=3$ 和 $n(3)=0$。\n    4. 更新 File B 链中的前驱节点，块 $8$，使其指向新链：$n(8)=1$。\n- **最终状态**：\n    - File A: $2 \\to 4 \\to 6 \\to 9 \\to 0$ (不变)。\n    - File B: $7 \\to 8 \\to 1 \\to 3 \\to 0$。\n    - 两个原始文件的数据都得以保留。没有错误地释放被引用的块。此解决方案遵守所有陈述的约束。\n- **结论**：**正确**。\n\n**C. 通过设置 $n(8)=0$ 来在共享段之前截断 File B...并立即将块 $6$ 和 $9$ 链接到空闲列表的头部，将它们标记为空闲...**\n- **检测**：此选项描述的是解决方案，而不是检测方法。它预先假定不一致性是已知的。\n- **解决方案**：该过程是通过设置 $n(8)=0$ 来截断 File B，然后将块 $6$ 和 $9$ 添加到空闲列表。\n    1. 设置 $n(8)=0$ 后，File B 变为 $7 \\to 8 \\to 0$。\n    2. 然后该过程将块 $6$ 和 $9$ 添加到空闲列表。\n    3. 然而，File A 的链仍然是 $2 \\to 4 \\to 6 \\to 9 \\to 0$。块 $6$ 和 $9$ 仍被 File A 使用。\n    4. 将一个仍在使用中的块添加到空闲列表是一个严重错误，因为当该块被重新分配时会导致数据损坏。这违反了“不得释放任何仍被引用的块”的约束。\n- **结论**：**不正确**。\n\n**D. 仅检查空闲列表是否存在异常...如果空闲列表是一个与文件头不相交的有效简单链，则声明系统一致...**\n- **检测**：此过程仅检查空闲列表。在给定状态下，空闲列表是 $1 \\to 3 \\to 5 \\to 10 \\to 11 \\to 12 \\to 0$。这是一个有效的、以null结尾的、无环的链。其成员与文件头（$2$ 和 $7$）不相交。根据其逻辑，此过程将声明系统一致。它完全错过了两个文件分配链之间的交叉链接。其潜在假设（所有不一致性都会在空闲列表中体现出来）是错误的。\n- **结论**：**不正确**。\n\n**E. 遍历两个文件，同时维护一个内存中的已访问集合 $V$ 和一个“首次拥有者”映射 $o(b)$...当发现一个块 $b$ 已经存在于 $V$ 中，但其 $o(b)$ 是一个不同的文件时，检测到交叉链接。通过在后发现的文件的前驱节点处截断它...并且不要将任何共享块添加到空闲列表中。**\n- **检测**：此过程使用已访问集合和所有权跟踪。\n    1. 初始化 $V=\\{\\}$ 和一个所有者映射 $o$。\n    2. 遍历 File A ($2 \\to 4 \\to 6 \\to 9$)：\n       - 对于 $b \\in \\{2, 4, 6, 9\\}$，将 $b$ 添加到 $V$ 并设置 $o(b) = \\text{File A}$。\n    3. 遍历 File B ($7 \\to 8 \\to 6 \\to \\dots$)：\n       - 访问 $7$：不在 $V$ 中。添加到 $V$，设置 $o(7) = \\text{File B}$。\n       - 访问 $8$：不在 $V$ 中。添加到 $V$，设置 $o(8) = \\text{File B}$。\n       - 访问 $6$：在 $V$ 中。检查所有者：$o(6) = \\text{File A}$。这与当前文件 File B 不同。检测到交叉链接。\n- **解决方案**：该过程是截断后来发现使用共享块的文件（File B）。File B 链中共享块 $6$ 的前驱节点是块 $8$。\n    1. 通过设置 $n(8)=0$ 来截断 File B。\n    2. 共享块 $\\{6, 9\\}$ 被明确“不要添加...到空闲列表”。这是正确的，因为它们仍然是 File A 的一部分。\n- **最终状态**：\n    - File A: $2 \\to 4 \\to 6 \\to 9 \\to 0$ (不变)。\n    - File B: $7 \\to 8 \\to 0$ (被截断)。\n    - File A 的数据得以保留，而 File B 被截断，这是一种允许的解决方案策略。没有释放被引用的块。此解决方案遵守所有陈述的约束。\n- **结论**：**正确**。", "answer": "$$\\boxed{BE}$$", "id": "3653075"}]}