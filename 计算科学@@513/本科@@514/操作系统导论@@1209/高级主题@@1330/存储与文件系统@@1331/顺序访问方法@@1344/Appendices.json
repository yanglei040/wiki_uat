{"hands_on_practices": [{"introduction": "在顺序访问文件时，一个核心的性能考量是如何平衡单次操作的固定开销与数据传输的可变成本。这个练习将引导你通过一个简化的性能模型，探索系统调用开销与数据传输速率之间的权衡 [@problem_id:3682197]。通过计算确保系统调用开销不超过特定阈值的最小数据块大小 $B^{\\star}$，你将亲身体会到如何通过“摊销”固定成本来优化I/O密集型任务的吞吐量。", "problem": "一个程序通过重复调用操作系统的读系统调用（syscall）从存储设备中获取固定大小的数据块，从而使用顺序访问方法来读取一个大文件。在此模型中，每个大小为 $B$ 字节的数据块由一次系统调用读取，该调用会产生 $\\alpha$ 纳秒的固定开销，数据传输以每秒 $R$ 字节的持续设备速率进行。对于此工作负载，假设：没有缓存或预取效应，数据传输与系统调用开销没有重叠，以及以给定速率 $R$ 的稳定顺序流。\n\n设系统调用开销所占总挂钟时间比例的目标上限为 $x$，表示为 0 到 1 之间的小数。仅使用总时间是各组成部分时间之和以及顺序访问按序读取相邻数据块（每个数据块一次系统调用）的第一性原理，确定最小数据块大小 $B^{\\star}$，以保证在整个读取过程中，系统调用开销的比例最多为 $x$。\n\n使用以下参数：$\\alpha = 3{,}500$ 纳秒， $R = 700$ 兆字节/秒 (MiB/s)，以及 $x = 0.03$。将 $1$ 兆字节 (MiB) 视为 $1{,}048{,}576$ 字节，将 $1$ 千字节 (KiB) 视为 $1{,}024$ 字节。以 KiB 为单位表示最终的数据块大小。将答案四舍五入到四位有效数字。", "solution": "问题要求计算最小数据块大小，记为 $B^{\\star}$，以确保系统调用（syscall）开销所占总时间的比例不超过一个指定值 $x$。分析从第一性原理开始，考虑读取单个数据块所需的时间。\n\n根据问题描述，读取一个大小为 $B$ 字节的数据块的总挂钟时间 $T_{\\text{total}}$，是固定的系统调用开销时间 $T_{\\text{overhead}}$ 和可变的数据传输时间 $T_{\\text{transfer}}$ 之和。模型假设这两个阶段不重叠。\n$$T_{\\text{total}} = T_{\\text{overhead}} + T_{\\text{transfer}}$$\n系统调用开销是每次调用的固定时间，给定为 $\\alpha$。\n$$T_{\\text{overhead}} = \\alpha$$\n对于一个大小为 $B$ 字节的数据块，以每秒 $R$ 字节的持续速率进行数据传输的时间由大小与速率之比给出。\n$$T_{\\text{transfer}} = \\frac{B}{R}$$\n将这些代入总时间的方程，得到：\n$$T_{\\text{total}} = \\alpha + \\frac{B}{R}$$\n系统调用开销所占总时间的比例，我们称之为 $f_{\\text{overhead}}$，是开销时间与总时间之比。\n$$f_{\\text{overhead}} = \\frac{T_{\\text{overhead}}}{T_{\\text{total}}} = \\frac{\\alpha}{\\alpha + \\frac{B}{R}}$$\n问题指定了一个目标上限，要求这个比例最多为 $x$。\n$$f_{\\text{overhead}} \\le x$$\n代入 $f_{\\text{overhead}}$ 的表达式，得出不等式：\n$$\\frac{\\alpha}{\\alpha + \\frac{B}{R}} \\le x$$\n为了找到满足此条件的最小数据块大小 $B^{\\star}$，我们首先观察到 $f_{\\text{overhead}}$ 是关于 $B$ 的单调递减函数，因为增加 $B$ 会使分数的分母增大。因此，最小大小 $B^{\\star}$ 是使等式成立的大小。对于任何 $B > B^{\\star}$，该不等式都将严格满足。我们通过将该比例设为等于 $x$ 来求解 $B^{\\star}$。\n$$\\frac{\\alpha}{\\alpha + \\frac{B^{\\star}}{R}} = x$$\n我们现在求解这个方程以得到 $B^{\\star}$。\n$$\\alpha = x \\left(\\alpha + \\frac{B^{\\star}}{R}\\right)$$\n$$\\alpha = x\\alpha + x\\frac{B^{\\star}}{R}$$\n$$\\alpha - x\\alpha = x\\frac{B^{\\star}}{R}$$\n$$\\alpha(1 - x) = x\\frac{B^{\\star}}{R}$$\n分离出 $B^{\\star}$ 得到解析解：\n$$B^{\\star} = \\frac{\\alpha R (1-x)}{x}$$\n现在，我们代入给定的参数值，确保所有单位一致。时间的标准单位是秒 (s)，大小的标准单位是字节。\n给定的参数是：\n$\\alpha = 3{,}500 \\text{ ns} = 3{,}500 \\times 10^{-9} \\text{ s}$\n$R = 700 \\text{ MiB/s} = 700 \\times 1{,}048{,}576 \\text{ 字节/s} = 733{,}993{,}200 \\text{ 字节/s}$\n$x = 0.03$\n另外，$1-x = 1 - 0.03 = 0.97$。\n\n将这些值代入 $B^{\\star}$ 的表达式中：\n$$B^{\\star} = \\frac{(3{,}500 \\times 10^{-9} \\text{ s}) \\times (733{,}993{,}200 \\text{ 字节/s}) \\times 0.97}{0.03}$$\n首先，我们计算分子：\n$$ \\text{分子} = (3{,}500 \\times 10^{-9}) \\times 733{,}993{,}200 \\times 0.97 \\text{ 字节}$$\n$$ \\text{分子} = 2.5689762 \\times 0.97 \\text{ 字节} \\approx 2.491906914 \\text{ 字节}$$\n现在，我们除以分母 $x = 0.03$：\n$$B^{\\star} = \\frac{2.491906914}{0.03} \\text{ 字节} \\approx 83{,}063.5638 \\text{ 字节}$$\n问题要求最终答案以千字节 (KiB) 为单位，并四舍五入到四位有效数字。我们使用转换因子 $1 \\text{ KiB} = 1{,}024 \\text{ 字节}$。\n$$B^{\\star} \\text{ [以 KiB 为单位]} = \\frac{83{,}063.5638 \\text{ 字节}}{1{,}024 \\text{ 字节/KiB}} \\approx 81.1167615 \\text{ KiB}$$\n将此值四舍五入到四位有效数字，我们看第五位有效数字。该数字是 $81.116...$。第五位数字是 $6$，大于或等于 $5$，因此我们将第四位数字向上取整。\n$$B^{\\star} \\approx 81.12 \\text{ KiB}$$", "answer": "$$\\boxed{81.12}$$", "id": "3682197"}, {"introduction": "真实的I/O系统很少是完全串行的；相反，它们像一条流水线，其中CPU处理和设备传输等阶段可以重叠。这个练习构建了一个更真实的双阶段流水线模型，让你能够分析CPU和I/O设备之间的性能竞赛 [@problem_id:3682208]。你的任务是推导出使设备“饱和”（即成为性能瓶颈）的临界缓冲大小，从而掌握识别和管理系统瓶颈的核心方法，这是优化任何复杂系统的关键一步。", "problem": "一个用户空间中的顺序文件读取器使用顺序存取方法，从存储设备重复读取大小为 $B$ 字节的数据。该设备的每次读取请求有固定的服务延迟 $L$（单位：秒）和稳态传输带宽 $r$（单位：字节/秒）。每次读取请求在用户空间中会产生 $\\alpha + \\beta B$ 个周期的中央处理器（CPU）开销，其中 $\\alpha$（单位：周期）模拟了固定的单次调用成本（例如，系统调用边界、缓冲区管理），而 $\\beta$（单位：周期/字节）模拟了每字节成本（例如，内存复制、校验和）。CPU 以固定的时钟频率 $f$（单位：周期/秒）运行。该系统使用带有异步输入/输出（I/O）的双缓冲机制，因此在预热后，不同数据块的设备传输和 CPU 开销可以在稳态下完美重叠。\n\n仅使用以下基本原理来推导性能：\n- 延迟和带宽的定义：每个数据块的设备服务时间为 $L + B/r$ 秒。\n- 周期与时间的转换：一个数据块的 CPU 时间为 $(\\alpha + \\beta B)/f$ 秒。\n- 在一个两级重叠流水线中，可持续的稳态启动间隔等于两个阶段时间中的较大者。\n\n将“使设备饱和”定义为：在稳态下，设备阶段是瓶颈（即，CPU 从不延迟流水线）。在所有能使设备饱和的缓冲区大小 $B$ 中，选择最小的 $B$ 值以最小化内存占用和延迟放大。假设参数满足 $ \\beta/f  1/r $ 和 $ \\alpha/f  L $，以确保存在一个唯一的正缓冲区大小能达到此边界。\n\n根据第一性原理和上述定义，推导出一个封闭形式的解析表达式，用于计算能最低限度使设备饱和的最优缓冲区大小 $B$（单位：字节）。最终答案需表示为仅包含 $L$、$r$、$\\alpha$、$\\beta$ 和 $f$ 的单一符号表达式。无需进行数值代入，也无需四舍五入。最终表达式中不要包含单位。", "solution": "所描述的系统是一个两级流水线，其中对不同数据块的 CPU 处理和设备 I/O 可以并发执行。这两个阶段是：\n1.  CPU 阶段，处理一个大小为 $B$ 的数据块。\n2.  I/O 设备阶段，读取一个大小为 $B$ 的数据块。\n\n处理一个数据块所需的每个阶段的时间是给定的。CPU 阶段的时间是 CPU 周期数除以 CPU 时钟频率：\n$$T_{CPU} = \\frac{\\alpha + \\beta B}{f}$$\n设备阶段的时间是固定延迟和可变传输时间之和：\n$$T_{device} = L + \\frac{B}{r}$$\n在一个完美重叠的流水线中，稳态下可以处理新数据块的速率（吞吐量）由两个阶段中较慢的一个决定。连续数据块完成之间的时间，即启动间隔 $\\tau$，由下式给出：\n$$\\tau = \\max(T_{CPU}, T_{device})$$\n问题将“使设备饱和”定义为设备阶段成为瓶颈的条件。这意味着设备阶段所花费的时间大于或等于 CPU 阶段所花费的时间。形式上，这表示为：\n$$T_{device} \\geq T_{CPU}$$\n代入 $T_{device}$ 和 $T_{CPU}$ 的表达式：\n$$L + \\frac{B}{r} \\geq \\frac{\\alpha + \\beta B}{f}$$\n目标是找到满足此条件的最小缓冲区大小 $B$。最小的 $B$ 值将是使两边相等的值，该点代表系统从 CPU 密集型过渡到设备密集型的边界点。任何小于此值的 $B$ 都会导致 $T_{CPU}  T_{device}$，使 CPU 成为瓶颈。因此，我们在等式成立时求解 $B$：\n$$L + \\frac{B}{r} = \\frac{\\alpha + \\beta B}{f}$$\n为了求解 $B$，我们首先将包含 $B$ 的项与常数项分开。\n$$L + \\frac{B}{r} = \\frac{\\alpha}{f} + \\frac{\\beta B}{f}$$\n重新整理方程，将含 $B$ 的项归到一边：\n$$\\frac{B}{r} - \\frac{\\beta B}{f} = \\frac{\\alpha}{f} - L$$\n从左边的项中提出因子 $B$：\n$$B \\left( \\frac{1}{r} - \\frac{\\beta}{f} \\right) = \\frac{\\alpha}{f} - L$$\n现在，我们可以通过将两边都除以括号中的项来分离出 $B$。这是允许的，因为问题提供的约束条件确保了除数不为零。\n$$B = \\frac{\\frac{\\alpha}{f} - L}{\\frac{1}{r} - \\frac{\\beta}{f}}$$\n问题提供了两个约束条件，以保证 $B$ 有一个唯一的正解。\n1.  约束条件 $\\alpha/f  L$ 意味着分子 $\\frac{\\alpha}{f} - L$ 是正数。这意味着每次调用的 CPU 固定时间超过了设备的固定延迟。\n2.  约束条件 $\\beta/f  1/r$ 意味着分母 $\\frac{1}{r} - \\frac{\\beta}{f}$ 也是正数。这意味着 CPU 处理一个字节的时间小于设备传输一个字节的时间。\n\n由于分子和分母都为正，所得的缓冲区大小 $B$ 也是正数，这在物理上是必需的。\n\n为了以简化的封闭形式呈现表达式，我们可以通过为主要分数中的分子和分母找到一个公分母来消除复合分数。\n分子可以写成：\n$$\\frac{\\alpha}{f} - L = \\frac{\\alpha - Lf}{f}$$\n分母可以写成：\n$$\\frac{1}{r} - \\frac{\\beta}{f} = \\frac{f - r\\beta}{rf}$$\n将这些代回 $B$ 的表达式中：\n$$B = \\frac{\\frac{\\alpha - Lf}{f}}{\\frac{f - r\\beta}{rf}}$$\n为了简化这个繁分数，我们将分子乘以分母的倒数：\n$$B = \\left( \\frac{\\alpha - Lf}{f} \\right) \\left( \\frac{rf}{f - r\\beta} \\right)$$\n项 $f$ 被消去，得到最终表达式：\n$$B = \\frac{r(\\alpha - Lf)}{f - r\\beta}$$\n这就是能最低限度使存储设备饱和的最优缓冲区大小 $B$ 的封闭形式解析表达式。", "answer": "$$\\boxed{\\frac{r(\\alpha - Lf)}{f - r\\beta}}$$", "id": "3682208"}, {"introduction": "理论知识只有通过实践才能真正内化。这个动手编码练习将带你深入操作系统内核，从最基本的块设备原语出发，亲手构建一个完整的顺序访问方法（SAM）接口 [@problem_id:3682261]。你将需要设计数据结构、实现逻辑到物理地址的转换，并管理一个单块缓存来优化性能。完成这项任务后，你将对文件系统如何将抽象的“文件”概念映射到具体的硬件操作有一个具体而深刻的认识。", "problem": "在一个教学操作系统场景中，您需要为一个抽象块设备实现一个顺序存取方法 (SAM) 接口。目标是形式化对一个物理上存储在块设备上的字节可寻址区域的顺序访问，并将 open、next 和 rewind 操作映射到块读取和字节偏移量。块设备提供连续的、固定大小的块，唯一允许的访问原语是块读取，它将整个块复制到 SAM 层可访问的缓存中。\n\n基本原理：\n- 块设备是一个大小统一的块数组。如果块大小为 $B$ 字节，并且有 $N$ 个块，则该设备在索引 $0$ 到 $N \\cdot B - 1$ 处存储 $N \\cdot B$ 字节。\n- 顺序数据集是由一个起始块 $S$ 和一个长度 $L$（以字节为单位）定义的连续字节区间，因此其有效的字节偏移量 $p$ 满足 $0 \\le p  L$（相对于数据集的起始位置）。\n- 顺序存取方法 (SAM) 支持：\n  - open：将顺序光标定位到数据集的开头，即将当前偏移量设置为 $0$。\n  - next：返回下一个逻辑记录并前移光标。\n  - rewind：将光标重置到开头（$0$），使任何依赖于当前位置的缓存失效。\n- 记录在数据集中被编码为变长记录，带有一个单字节的长度前缀：一个记录由 1 字节的长度 $\\ell$（有效载荷长度）和随后的 $\\ell$ 个有效载荷字节组成。有效的编码满足所有记录的 $(1 + \\ell)$ 之和等于 $L$。\n\n从字节偏移量到块设备的映射：\n- 给定一个相对于数据集的字节偏移量 $p$ 且 $0 \\le p  L$，对应的设备块索引是\n$$\n\\text{block}(p) = S + \\left\\lfloor \\frac{p}{B} \\right\\rfloor,\n$$\n块内字节偏移量是\n$$\n\\text{off}(p) = p \\bmod B.\n$$\n- SAM 层持有一个单块缓存。要获取偏移量 $p$ 处的任何字节，需计算 $\\text{block}(p)$ 和 $\\text{off}(p)$。如果缓存当前未持有 $\\text{block}(p)$，则执行一次该块的块读取操作，将其读入缓存，然后从缓存中返回位于 $\\text{off}(p)$ 的字节。如果缓存已持有 $\\text{block}(p)$，则直接返回缓存的字节，不发出新的块读取请求。\n- 每次块读取都会增加一个块读取操作计数器。rewind 操作会使缓存失效，并为下一次遍历将块读取计数器重置为 $0$。\n\n程序要求：\n- 使用上述语义实现 SAM。next 操作必须：\n  - 在当前相对于数据集的偏移量 $p$ 处，使用映射规则读取长度字节 $\\ell$，然后顺序读取 $\\ell$ 个有效载荷字节，并相应地推进偏移量。\n  - 如果在超出 $L$ 之前获得了完整的记录，则返回成功指示符；如果没有更多记录（即 $p \\ge L$），则返回失败指示符。\n- 为了使结果纯粹为数字且可复现，将记录的贡献值定义为其有效载荷字节值的总和。在一次遍历中，计算总有效载荷和以及记录的总数。同时，计算该次遍历期间发生了多少次块读取。\n- 唯一允许的设备原语是向缓存中进行完整的块读取。不允许除通过块读取后的缓存之外的任何直接从设备内存中按字节读取的操作。\n\n测试套件：\n通过将指定的记录写入一个零初始化的设备的数据集区域来构建以下四个测试用例。每个记录定义为 $[\\ell \\mid \\text{payload bytes}]$，表示一个字节的长度 $\\ell$ 后跟 $\\ell$ 个有效载荷字节。\n\n- 测试用例 1（顺利情况，记录跨越块边界）：\n  - 块大小 $B = 8$，块数 $N = 4$，起始块 $S = 1$。\n  - 记录：$[3 \\mid 1,2,3]$, $[2 \\mid 4,5]$, $[4 \\mid 6,7,8,9]$。\n  - 数据集长度 $L = 12$ 字节。\n- 测试用例 2（边界对齐：记录恰好在块边界结束）：\n  - 块大小 $B = 8$，块数 $N = 3$，起始块 $S = 0$。\n  - 记录：$[7 \\mid 10,20,30,40,50,60,70]$, $[1 \\mid 255]$。\n  - 数据集长度 $L = 10$ 字节。\n- 测试用例 3（空数据集）：\n  - 块大小 $B = 8$，块数 $N = 2$，起始块 $S = 0$。\n  - 记录：无。\n  - 数据集长度 $L = 0$ 字节。\n- 测试用例 4（跨越多个块的大记录）：\n  - 块大小 $B = 16$，块数 $N = 4$，起始块 $S = 2$。\n  - 记录：$[30 \\mid 1,2,3,\\dots,30]$。\n  - 数据集长度 $L = 31$ 字节。\n\n对每个测试用例，执行：\n- open，\n- 迭代执行 next 直到文件末尾，计算：\n  - 该遍的总有效载荷和，\n  - 记录数，\n  - 块读取计数，\n- rewind，\n- 再次迭代执行 next 以计算第二次遍历，内容包括：\n  - 第二次遍历的总有效载荷和，\n  - 第二次遍历的块读取计数。\n\n最终输出规范：\n- 您的程序应生成一行输出，其中包含按测试用例聚合的结果列表。对每个测试用例，输出列表 $[\\text{sum\\_first}, \\text{count}, \\text{reads\\_first}, \\text{sum\\_second}, \\text{reads\\_second}]$。\n- 总输出必须是单行中的单个类 JSON 列表，格式严格如下：\n  - 示例形式：$[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],[a_3,b_3,c_3,d_3,e_3],[a_4,b_4,c_4,d_4,e_4]]$，\n  - 其中所有 $a_i$, $b_i$, $c_i$, $d_i$, $e_i$ 均为整数。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于操作系统文件存取方法的原理，定义和约束条件完整且一致，问题阐述良好，并以客观、正式的语言表达。没有可识别的缺陷会妨碍推导出唯一且有意义的解决方案。因此，我们可以着手解决问题。\n\n任务是在一个模拟的块设备上实现一个顺序存取方法 (SAM)。这需要创建一个抽象层，在一个物理上组织成固定大小块的存储介质上提供字节流访问（`open`、`next`、`rewind`）。解决方案的核心涉及将逻辑字节偏移量映射到物理块地址，并管理一个单块缓存以最小化块读取操作。\n\n### 数据结构\n\n为了对系统建模，我们定义了以下结构：\n\n1.  **块设备 (Block Device)**：物理存储介质由一个块数组表示。我们可以用一个结构体来建模，其中包含一个指向连续内存区域的指针、块大小 $B$ 和总块数 $N$。\n    ```c\n    typedef struct {\n        unsigned char* memory;\n        int B; // Block size in bytes\n        int N; // Number of blocks\n    } BlockDevice;\n    ```\n\n2.  **SAM 数据集状态 (SAM Dataset State)**：此结构封装了顺序数据集的状态，包括其属性和当前访问状态。它包含：\n    *   对底层 `BlockDevice` 的引用。\n    *   数据集参数：起始块 $S$ 和总长度 $L$（以字节为单位）。\n    *   当前逻辑位置，或称光标 `p`，它是相对于数据集起始位置的字节偏移量（$0 \\le p  L$）。\n    *   一个单块缓存及其状态：一个用于存放一个数据块的缓冲区，以及一个整数用于跟踪当前缓存中持有的块的索引。索引为 $-1$ 可以表示缓存无效或为空。\n    *   一个用于记录已执行的块读取操作次数的计数器。\n    ```c\n    typedef struct {\n        BlockDevice* device;\n        int S; // Start block\n        int L; // Length in bytes\n        int p; // Current dataset-relative byte offset (cursor)\n        unsigned char* cache;\n        int cached_block_index;\n        int block_reads;\n    } SAM_Dataset;\n    ```\n\n### 核心逻辑：映射与缓存\n\n基本操作是根据其相对于数据集的偏移量 $p$ 来检索单个字节。这由一个实现了指定映射和缓存逻辑的辅助函数来处理。\n\n**`read_byte(SAM_Dataset* ds, int p)`**：\n给定一个数据集 `ds` 和一个相对于数据集的偏移量 $p$，此函数返回该位置的字节值。\n\n1.  **地址转换 (Address Translation)**：首先，逻辑偏移量 $p$ 被转换为物理设备地址。根据问题描述，设备块索引和块内偏移量计算如下：\n    $$\n    \\text{block\\_idx}(p) = S + \\left\\lfloor \\frac{p}{B} \\right\\rfloor\n    $$\n    $$\n    \\text{offset\\_in\\_block}(p) = p \\bmod B\n    $$\n    在 C 语言的整数运算中，对于非负的 $p$ 和 $B$，这分别对应于 `ds-S + p / ds-device-B` 和 `p % ds-device-B`。\n\n2.  **缓存管理 (Cache Management)**：然后函数检查所需的块 `block_idx` 是否已在缓存中。\n    *   **缓存命中 (Cache Hit)**：如果 `block_idx` 等于 `ds-cached_block_index`，则该块已被加载。直接从缓存的 `ds-cache[offset_in_block]` 处返回字节。不发生块读取。\n    *   **缓存未命中 (Cache Miss)**：如果 `block_idx` 不是缓存中的块，则必须执行一次块读取。\n        a. `ds-block_reads` 计数器加一。\n        b. 将 `block_idx` 处的整个块从设备的内存复制到 `ds-cache` 缓冲区。设备上的源地址是 `ds-device-memory + block_idx * ds-device-B`。\n        c. 将 `ds-cached_block_index` 更新为 `block_idx`。\n        d. 然后从现在已更新的缓存的 `ds-cache[offset_in_block]` 处返回字节。\n\n### SAM 操作\n\nSAM 接口函数（`open`、`next`、`rewind`）是使用 `read_byte` 辅助函数实现的。\n\n1.  **`sam_open(SAM_Dataset* ds)`**：此操作为遍历数据集做准备。它仅将光标重置到开头。\n    *   设置 `ds-p = 0`。\n    *   初始化 `ds-block_reads = 0`。\n    *   通过设置 `ds-cached_block_index = -1` 使缓存失效。\n\n2.  **`sam_rewind(SAM_Dataset* ds)`**：根据问题描述，此操作为后续的遍历重置状态，与 `sam_open` 相同。\n    *   设置 `ds-p = 0`。\n    *   重置 `ds-block_reads = 0`。\n    *   通过设置 `ds-cached_block_index = -1` 使缓存失效。\n\n3.  **`sam_next(SAM_Dataset* ds, int* payload_sum)`**：此函数读取下一个变长记录。\n    *   **文件末尾检查**：首先检查光标 `ds-p` 是否位于或超出数据集的末尾（`ds-p = ds-L`）。如果是，则表示失败（文件末尾）并返回。\n    *   **读取长度前缀**：调用 `read_byte(ds, ds-p)` 获取记录的长度前缀 $\\ell$。然后光标 `ds-p` 加一。\n    *   **读取有效载荷**：进入一个循环，迭代 $\\ell$ 次。在每次迭代中，调用 `read_byte(ds, ds-p)` 获取下一个有效载荷字节，将其值加到当前记录的运行总和中，并使 `ds-p` 加一。\n    *   **返回值**：函数通过 `payload_sum` 指针参数更新该次遍历的总有效载荷和，并返回一个成功指示符。\n\n### 执行计划\n\n主程序将为四个指定的测试用例分别执行逻辑。\n\n1.  **测试用例设置 (Test Case Setup)**：对每个测试用例，我们为块设备和 SAM 缓存动态分配内存。设备内存被零初始化。\n2.  **数据填充 (Data Population)**：将测试用例的记录数据写入模拟的设备内存中。数据从对应于数据集起始块的设备字节偏移量（即 $S \\cdot B$）处开始放置。\n3.  **第一次遍历 (First Pass)**：\n    *   调用 `sam_open` 初始化状态。\n    *   循环调用 `sam_next` 直到它发出文件结束信号。\n    *   在循环内部，累加总有效载荷和并增加记录计数。\n    *   循环结束后，记录 `sum_first`、`count` 和 `reads_first` 的最终值。\n4.  **第二次遍历 (Second Pass)**：\n    *   调用 `sam_rewind` 重置状态。\n    *   重复 `sam_next` 循环以重新读取数据集。\n    *   累加第二次遍历的总有效载荷和。\n    *   循环结束后，记录 `sum_second` 和 `reads_second`。\n5.  **输出生成 (Output Generation)**：处理完所有测试用例后，将收集到的结果以指定的单行类 JSON 格式 `[[...],[...],...]` 打印到标准输出。\n6.  **清理 (Cleanup)**：为每个测试用例释放所有动态分配的内存（设备和缓存），以防止内存泄漏。", "answer": "[[45, 3, 2, 45, 2], [535, 2, 2, 535, 2], [0, 0, 0, 0, 0], [465, 1, 2, 465, 2]]", "id": "3682261"}]}