{"hands_on_practices": [{"introduction": "理论知识的最终目的是指导实践。在编写并发程序时，我们能否在代码运行之前，仅通过检查数据结构就预见伪共享的风险？本练习将引导你将伪共享的定义转化为一个具体的数学判据。通过推导和应用这个判据 [@problem_id:3641010]，你将学会如何进行静态代码审查，从源头上识别并规避潜在的性能陷阱。", "problem": "在一个字节可寻址的共享内存系统中，内存层次结构使用一个数据缓存，该缓存将主内存组织成大小为 $B$ 字节的固定大小的缓存行。不同线程对驻留在同一缓存行中的不同地址进行的两次并发写入可能会导致伪共享。根据定义，对于某个整数 $k$，落在同一半开区间 $[kB,(k+1)B)$ 内的内存地址包含在同一缓存行中。\n\n考虑一个分配在基地址 $A$ 上的结构，该基地址是 $B$ 字节对齐的（即，$A$ 是 $B$ 的倍数）。为了代码审查的目的，你需要一个谓词，如果一对字段相对于 $A$ 的起始字节偏移量映射到同一个缓存行，该谓词就将这对字段标记为有风险。假设每个字段都严格包含在单个缓存行内（没有字段跨越两个缓存行），并且给定 $B=64$ 字节以及六个结构体字段，它们相对于 $A$ 的起始字节偏移量分别为 $o_1=0$, $o_2=40$, $o_3=64$, $o_4=68$, $o_5=120$, $o_6=160$。\n\n从上述基本定义（在同一区间 $[kB,(k+1)B)$ 内的地址共享一个缓存行）出发，推导出一个解析指标 $S(o_i,o_j,B)$，如果一对起始偏移量 $o_i$ 和 $o_j$ 共享一个缓存行，则该指标返回 $1$，否则返回 $0$。然后，使用这个指标，确定在这六个字段中，会被该谓词标记为有风险的无序不同对的总数。将你的最终答案表示为单个整数。", "solution": "该问题要求我们首先推导一个解析谓词，我们称之为指标函数 $S(o_i, o_j, B)$，以确定结构中的两个字段是否落在同一个缓存行中。随后，我们必须使用这个指标来计算给定的一组字段偏移量中此类“有风险”对的数量。\n\n首先，我们形式化地定义两个内存地址位于同一缓存行的条件。根据问题陈述，一个大小为 $B$ 字节的缓存行对应于某个非负整数 $k$ 的内存地址半开区间 $[kB, (k+1)B)$。一个地址，我们称之为 $addr$，如果满足 $kB \\le addr  (k+1)B$，则它落在索引为 $k$ 的缓存行中。两边除以 $B$ 得到 $k \\le \\frac{addr}{B}  k+1$。这是向下取整函数的定义，因此对于给定地址 $addr$ 的缓存行索引 $k$ 为 $k = \\lfloor \\frac{addr}{B} \\rfloor$。因此，两个不同的地址 $addr_i$ 和 $addr_j$ 驻留在同一个缓存行中，当且仅当它们具有相同的缓存行索引：\n$$\n\\left\\lfloor \\frac{addr_i}{B} \\right\\rfloor = \\left\\lfloor \\frac{addr_j}{B} \\right\\rfloor\n$$\n\n问题考虑的是分配在基地址 $A$ 上的一个结构体内的字段。一个相对于 $A$ 的起始字节偏移量为 $o_i$ 的字段，其绝对内存地址为 $addr_i = A + o_i$。因此，如果两个字段的起始偏移量分别为 $o_i$ 和 $o_j$ 共享一个缓存行，则：\n$$\n\\left\\lfloor \\frac{A+o_i}{B} \\right\\rfloor = \\left\\lfloor \\frac{A+o_j}{B} \\right\\rfloor\n$$\n\n一个关键信息是基地址 $A$ 是 $B$ 字节对齐的。这意味着 $A$ 是 $B$ 的倍数，所以我们可以写成 $A = mB$，其中 $m$ 是某个整数。将此代入我们的条件中，得到：\n$$\n\\left\\lfloor \\frac{mB+o_i}{B} \\right\\rfloor = \\left\\lfloor \\frac{mB+o_j}{B} \\right\\rfloor\n$$\n$$\n\\left\\lfloor m + \\frac{o_i}{B} \\right\\rfloor = \\left\\lfloor m + \\frac{o_j}{B} \\right\\rfloor\n$$\n使用向下取整函数的性质 $\\lfloor x+n \\rfloor = \\lfloor x \\rfloor + n$（对于任意整数 $n$），我们可以简化方程：\n$$\nm + \\left\\lfloor \\frac{o_i}{B} \\right\\rfloor = m + \\left\\lfloor \\frac{o_j}{B} \\right\\rfloor\n$$\n$$\n\\left\\lfloor \\frac{o_i}{B} \\right\\rfloor = \\left\\lfloor \\frac{o_j}{B} \\right\\rfloor\n$$\n这个简化的条件表明，对于一个 $B$ 字节对齐的结构，两个字段是否共享一个缓存行仅取决于它们的偏移量 $o_i, o_j$ 和缓存行大小 $B$，而与基地址 $A$ 无关。\n\n现在我们可以定义解析指标 $S(o_i, o_j, B)$，如果字段共享一个缓存行，则返回 $1$，否则返回 $0$。根据我们推导出的条件，该函数为：\n$$\nS(o_i, o_j, B) =\n\\begin{cases}\n1  \\text{ if } \\left\\lfloor \\frac{o_i}{B} \\right\\rfloor = \\left\\lfloor \\frac{o_j}{B} \\right\\rfloor \\\\\n0  \\text{ otherwise}\n\\end{cases}\n$$\n\n接下来，我们将这个指标应用于给定的数据。缓存行大小为 $B = 64$ 字节。六个字段的偏移量为 $o_1=0$, $o_2=40$, $o_3=64$, $o_4=68$, $o_5=120$ 和 $o_6=160$。我们为每个偏移量计算缓存行索引 $k_i = \\lfloor \\frac{o_i}{64} \\rfloor$：\n\\begin{itemize}\n    \\item $k_1 = \\lfloor \\frac{0}{64} \\rfloor = \\lfloor 0 \\rfloor = 0$\n    \\item $k_2 = \\lfloor \\frac{40}{64} \\rfloor = \\lfloor 0.625 \\rfloor = 0$\n    \\item $k_3 = \\lfloor \\frac{64}{64} \\rfloor = \\lfloor 1 \\rfloor = 1$\n    \\item $k_4 = \\lfloor \\frac{68}{64} \\rfloor = \\lfloor 1.0625 \\rfloor = 1$\n    \\item $k_5 = \\lfloor \\frac{120}{64} \\rfloor = \\lfloor 1.875 \\rfloor = 1$\n    \\item $k_6 = \\lfloor \\frac{160}{64} \\rfloor = \\lfloor 2.5 \\rfloor = 2$\n\\end{itemize}\n\n现在我们得到了每个字段的缓存行索引：$\\{k_1, k_2, k_3, k_4, k_5, k_6\\} = \\{0, 0, 1, 1, 1, 2\\}$。如果两个字段具有相同的缓存行索引，则它们构成一个有风险的对。为了计算无序不同对的数量，我们可以按缓存行索引对字段进行分组：\n\\begin{itemize}\n    \\item 缓存行 $k=0$：偏移量为 $\\{o_1, o_2\\}$ 的字段。此组中有 $N_0 = 2$ 个字段。\n    \\item 缓存行 $k=1$：偏移量为 $\\{o_3, o_4, o_5\\}$ 的字段。此组中有 $N_1 = 3$ 个字段。\n    \\item 缓存行 $k=2$：偏移量为 $\\{o_6\\}$ 的字段。此组中有 $N_2 = 1$ 个字段。\n\\end{itemize}\n\n大小为 $N$ 的组内的无序对数由二项式系数 $\\binom{N}{2} = \\frac{N(N-1)}{2}$ 给出。我们为每个组计算这个值：\n\\begin{itemize}\n    \\item $k=0$ 组中的风险对数量：$\\binom{N_0}{2} = \\binom{2}{2} = \\frac{2(1)}{2} = 1$。这对对应于 $(o_1, o_2)$。\n    \\item $k=1$ 组中的风险对数量：$\\binom{N_1}{2} = \\binom{3}{2} = \\frac{3(2)}{2} = 3$。这些对对应于 $(o_3, o_4)$、$(o_3, o_5)$ 和 $(o_4, o_5)$。\n    \\item $k=2$ 组中的风险对数量：$\\binom{N_2}{2} = \\binom{1}{2} = \\frac{1(0)}{2} = 0$。\n\\end{itemize}\n风险对的总数是所有组的对数之和：\n$$\n\\text{Total risky pairs} = \\binom{2}{2} + \\binom{3}{2} + \\binom{1}{2} = 1 + 3 + 0 = 4\n$$\n因此，在给定的六个字段中，有 $4$ 对无序的不同字段对会被标记为有风险。", "answer": "$$\\boxed{4}$$", "id": "3641010"}, {"introduction": "识别问题后，下一步是解决问题，但这并非没有代价。解决伪共享最常用的方法是数据填充，它通过增加内存使用量来换取性能提升。这个决策是否明智？本练习 [@problem_id:3640979] 提供了一个基于假设性能测量数据的场景，让你亲手计算这种权衡，量化每一兆字节（MiB）额外内存带来了多大的性能收益。这种成本效益分析是性能优化工程师必备的核心技能。", "problem": "在一个操作系统入门课程中，一个多核系统执行一个微基准测试，以研究伪共享（false sharing）和缓存对齐（cache alignment）。$T$ 个工作线程中的每一个都维护着自己的一个包含 $N$ 个结构的数组，这些结构中含有频繁更新的计数器。在没有填充（padding）的情况下，每个结构的大小为 $s$ 字节。为了缓解伪共享，每个结构被填充到 $B$ 字节，其中 $B$ 等于处理器的缓存行大小。填充通过确保频繁写入的结构不会跨线程共享同一个缓存行，从而减少了一致性流量（coherence traffic）。\n\n假设以下为测量和已知量：\n- 线程数：$T = 8$。\n- 每个线程的元素数：$N = 2 \\times 10^{6}$。\n- 未填充的结构大小：$s = 24$ 字节。\n- 填充后的结构大小（等于缓存行大小）：$B = 64$ 字节。\n- 无填充时的基线吞吐量：$X = 1.2 \\times 10^{8}$ 次操作/秒 (ops/sec)。\n- 有填充时的吞吐量：$Y = 4.2 \\times 10^{8}$ ops/sec。\n\n从第一性原理出发，使用以下定义：所有线程因填充而产生的总额外内存消耗是填充后总大小与未填充总大小之差，并且 1 兆字节 (mebibyte, MiB) 等于 $2^{20}$ 字节。计算每消耗一兆字节（MiB）额外内存所带来的吞吐量增益的比率，该比率定义为以 ops/sec 为单位的吞吐量增益除以以 MiB 为单位的额外内存。以 ops/sec 每 MiB 为单位表示最终答案，并将答案四舍五入到四位有效数字。", "solution": "当多个线程写入位于同一缓存行上的不同变量时，就会出现伪共享现象，这会导致缓存一致性协议中频繁的缓存行失效，从而降低吞吐量。将每个结构填充到缓存行大小，可确保由不同线程写入的结构被分离到不同的缓存行中，从而减少了一致性流量并可能提高吞吐量。我们将吞吐量增益与由填充引起的内存开销进行比较。\n\n我们从以下定义出发：\n\n1. 所有数组在没有填充时使用的总内存为\n$$\nM_{\\text{unpadded}} = T \\times N \\times s.\n$$\n\n2. 填充到 $B$ 字节后使用的总内存为\n$$\nM_{\\text{padded}} = T \\times N \\times B.\n$$\n\n3. 由于填充而产生的额外内存消耗（内存浪费）为\n$$\nW_{\\text{bytes}} = M_{\\text{padded}} - M_{\\text{unpadded}} = T \\times N \\times (B - s).\n$$\n\n4. 使用 $1 \\text{ MiB} = 2^{20}$ 字节将此额外内存从字节转换为兆字节（MiB）：\n$$\nW_{\\text{MiB}} = \\frac{W_{\\text{bytes}}}{2^{20}}.\n$$\n\n5. 由于填充带来的吞吐量增益为\n$$\nG = Y - X.\n$$\n\n6. 每兆字节额外内存的吞吐量增益的期望比率为\n$$\nR = \\frac{G}{W_{\\text{MiB}}}.\n$$\n\n现在代入给定值：\n\n- $T = 8$,\n- $N = 2 \\times 10^{6}$,\n- $s = 24$,\n- $B = 64$,\n- $X = 1.2 \\times 10^{8}$,\n- $Y = 4.2 \\times 10^{8}$,\n- $2^{20} = 1{,}048{,}576$.\n\n计算以字节为单位的额外内存：\n$$\nW_{\\text{bytes}} = 8 \\times \\left(2 \\times 10^{6}\\right) \\times (64 - 24) = 8 \\times 2 \\times 10^{6} \\times 40 = 640 \\times 10^{6}.\n$$\n\n转换为兆字节（MiB）：\n$$\nW_{\\text{MiB}} = \\frac{640 \\times 10^{6}}{1{,}048{,}576} = \\frac{640{,}000{,}000}{1{,}048{,}576}.\n$$\n为确保准确性，将其保留为精确分数会很有帮助。\n\n计算吞吐量增益：\n$$\nG = 4.2 \\times 10^{8} - 1.2 \\times 10^{8} = 3.0 \\times 10^{8}.\n$$\n\n构造比率：\n$$\nR = \\frac{3.0 \\times 10^{8}}{ \\frac{640{,}000{,}000}{1{,}048{,}576} } = 3.0 \\times 10^{8} \\times \\frac{1{,}048{,}576}{640{,}000{,}000}.\n$$\n\n简化标量因子：\n$$\n\\frac{3.0 \\times 10^{8}}{640{,}000{,}000} = \\frac{300{,}000{,}000}{640{,}000{,}000} = \\frac{3}{6.4} = 0.46875.\n$$\n\n因此，\n$$\nR = 0.46875 \\times 1{,}048{,}576 = 491{,}520.\n$$\n\n四舍五入到四位有效数字：\n$$\nR \\approx 4.915 \\times 10^{5}.\n$$\n\n该比率表示由于填充而消耗的每 MiB 额外内存所带来的吞吐量增益（以 ops/sec 为单位）。", "answer": "$$\\boxed{4.915 \\times 10^{5}}$$", "id": "3640979"}, {"introduction": "在复杂的真实软件中，性能瓶颈往往隐藏得很深，静态分析可能不足以定位问题。此时，我们需要借助动态分析工具进行诊断。本练习 [@problem_id:3641015] 将带你扮演一位性能工程师，学习如何利用硬件性能监控单元（PMU）提供的底层事件数据，来侦测和定位伪共享。你将了解到，特定的事件组合（如高比例的 RFO-HITM 事件）可以作为伪共享的“确凿证据”，从而将抽象的性能问题与具体的代码行关联起来。", "problem": "考虑一个多核系统，该系统有 $N$ 个相同的核心，遵循 Modified, Exclusive, Shared, Invalid (MESI) 缓存一致性协议，并且缓存行大小为 $64$ 字节。两个代码区域（表示为 $R_1$ 和 $R_2$）在一个程序中执行，该程序使用 $T$ 个线程并发地更新一个共享数组的元素。硬件性能监控单元 (PMU) 在 $1$ 秒的时间间隔内进行采样，采样数据通过指令地址到代码行的映射归因到源代码行。PMU 提供了两种特定事件的计数：在另一个核心中处于 Modified 状态的缓存行中命中 (HITM)，以及为获得所有权而读取 (Read For Ownership, RFO)。根据定义，意图将缓存行转换为 Exclusive 或 Modified 状态的写操作需要一个 RFO，而当一个核心从另一个持有该缓存行为 Modified 状态的核心获取该缓存行时，就会发生 HITM，这意味着发生了核心间的缓存到缓存传输。当不同的线程访问驻留在同一缓存行中的不同变量时，会发生伪共享 (False sharing)，从而导致不必要的一致性流量和所有权的“乒乓”效应。\n\n收集到的数据如下。在区域 $R_1$ 中，单个源代码行 $\\ell_1$ 占该区域事件样本的 $65\\%$；归因于 $R_1$ 的计数器为 $\\text{RFO}_{R_1} = 120{,}000$ 和 $\\text{HITM}_{R_1} = 48{,}000$。在区域 $R_2$ 中，事件样本相当均匀地分布在 $30$ 行代码上，其中 $\\text{RFO}_{R_2} = 90{,}000$ 和 $\\text{HITM}_{R_2} = 4{,}500$。$R_1$ 中存储指令的动态计数为 $300{,}000$，$R_2$ 中为 $280{,}000$。假设采样误差可以忽略不计，并且这些区域中没有基于锁的同步。\n\n下列哪种方法最恰当地利用这些 PMU 事件来检测伪共享，将其与特定的代码区域相关联，并提出有科学依据的阈值来标记可疑的源代码行？\n\nA. 通过指令地址映射将 HITM 和 RFO 样本归因于源代码行，并计算每行的比率 $\\rho = \\text{HITM}/\\text{RFO}$ 和集中度 $\\kappa$（定义为映射到该行的区域事件样本的分数）。如果在测量间隔内，某行的 $\\rho \\ge 0.3$ 且 $\\kappa \\ge 0.5$，则将其标记为伪共享嫌疑行。\n\nB. 如果任何区域在 $1$ 秒内的绝对 HITM 计数超过 $50{,}000$，则将其标记为伪共享，而不管事件如何在源代码行之间分布或相应的 RFO 计数如何。\n\nC. 使用末级缓存 (LLC) 未命中率和每周期指令数 (IPC)：标记任何 LLC 未命中率超过 $20\\%$ 且 IPC 低于 $1.0$ 的区域，因为这表明内存压力可能由伪共享引起。\n\nD. 对每个区域计算比率 $\\sigma = \\text{RFO}/\\text{stores}$，如果 $\\sigma \\ge 0.6$，则标记为伪共享，因为与 RFO 相关的大部分存储操作表明存在过度的一致性流量。\n\n选择最佳选项，该选项既描述了一种基于缓存一致性行为的可靠检测方法，又提供了能够根据上述数据正确标记 $R_1$ 中的 $\\ell_1$ 但不标记 $R_2$ 中任何行的阈值。", "solution": "从 Modified, Exclusive, Shared, Invalid (MESI) 缓存一致性协议的行为开始分析。一个核心要对处于 Shared 或 Invalid 状态的缓存行进行写操作，必须首先获得独占所有权，这会发出一个为获得所有权而读取 (RFO) 的请求。如果此时另一个核心以 Modified 状态持有该行，请求核心将通过缓存到缓存的传输接收该行，这被记录为在另一个核心中处于 Modified 状态的缓存行中命中 (HITM)。在没有伪共享的工作负载中，许多写操作仍然需要 RFO，但相对较少的请求会从另一个核心的 Modified 状态得到服务，因为所有权变更不频繁，而且当缓存行没有在核心之间被主动“乒乓”传递时，数据通常来自末级缓存 (LLC) 或内存。相比之下，伪共享会导致同一缓存行的所有权在核心之间快速交替，从而增加了作为 HITM 事件服务的 RFO 的比例。\n\n为了在源代码行粒度上检测伪共享，必须将 PMU 事件与代码相关联，并使用一个能够区分正常写所有权获取和过度的核心间缓存行传输的指标。通过指令地址将样本与源代码行相关联，提供了必要的代码区域归因。一个稳健的指标会考虑给定代码行的比率 $\\rho = \\text{HITM}/\\text{RFO}$，它反映了相对于所有权请求，所有权从另一个核心的 Modified 状态转移的频率。一个集中度指标 $\\kappa$，定义为映射到单个代码行的区域事件的比例，有助于确保该现象局限于特定的代码行，而不是分散在许多行上（后者可能表明普遍的内存压力，而非特定的伪共享）。\n\n将此推理应用于给定数据。对于 $R_1$：\n- $\\text{RFO}_{R_1} = 120{,}000$ 且 $\\text{HITM}_{R_1} = 48{,}000$，因此区域级比率为\n$$\\rho_{R_1} = \\frac{48{,}000}{120{,}000} = 0.4.$$\n- $\\ell_1$ 的集中度为 $\\kappa_{\\ell_1} = 0.65$（因为 $\\ell_1$ 占了 $R_1$ 中 $65\\%$ 的事件样本）。\n\n对于 $R_2$：\n- $\\text{RFO}_{R_2} = 90{,}000$ 且 $\\text{HITM}_{R_2} = 4{,}500$，得出\n$$\\rho_{R_2} = \\frac{4{,}500}{90{,}000} = 0.05.$$\n- 事件分布在 $30$ 行上，因此没有单行的集中度很高；对于 $R_2$ 中的任何行 $\\ell$，如果均匀分布，则 $\\kappa_{\\ell} \\approx \\frac{1}{30} \\approx 0.033$。\n\n阈值的选择应反映出与典型行为的有意义的偏差。在许多没有伪共享、良好扩展的写密集型工作负载中，$\\rho$ 值很小，当所有权来自处于 Shared 状态的缓存或 LLC 而不是另一个核心的 Modified 状态时，$\\rho$ 通常接近于 $0$。像 $\\rho \\ge 0.3$ 这样的阈值可以捕捉到大部分写所有权获取是由另一个处于 Modified 状态的核心服务的案例，这标志着所有权的“乒乓”效应。像 $\\kappa \\ge 0.5$ 这样的集中度阈值确保信号局限于少数几行，这与特定源代码行上的伪共享相符。\n\n评估各个选项：\n\nA. 此选项描述了将 PMU 样本与源代码行相关联，并结合使用比率 $\\rho = \\text{HITM}/\\text{RFO}$ 和集中度指标 $\\kappa$。阈值 $\\rho \\ge 0.3$ 和 $\\kappa \\ge 0.5$ 具有科学依据：它们能捕捉到异常高的核心间 Modified 命中并确保局部性。根据给定数据，$R_1$ 的 $\\rho_{R_1} = 0.4$ 且 $\\kappa_{\\ell_1} = 0.65$，因此 $\\ell_1$ 会被标记。$R_2$ 的 $\\rho_{R_2} = 0.05$ 且每行的集中度低，因此 $R_2$ 中没有行会被标记。结论 — 正确。\n\nB. 此选项使用绝对 HITM 阈值，未考虑 RFO 或局部性。绝对计数取决于运行时间、系统规模和工作负载强度，这使得像 $\\text{HITM} \\ge 50{,}000$ 这样的固定阈值不可靠，并可能漏掉 $R_1$（其值为 $48{,}000$），同时错误分类其他工作负载。它也未能与特定代码行相关联。结论 — 错误。\n\nC. 此选项依赖于末级缓存 (LLC) 未命中率和每周期指令数 (IPC)。伪共享通常表现为一致性流量和所有权反弹，而不一定会增加 LLC 未命中；一致性传输可能发生在私有缓存之间。IPC 是一个粗粒度的性能指标，不能专门诊断伪共享。该方法既没有利用 HITM 和 RFO，也没有提供行级关联。结论 — 错误。\n\nD. 此选项使用 $\\sigma = \\text{RFO}/\\text{stores}$。许多存储操作合法地需要 RFO（对于处于 Shared 状态的行），因此即使没有伪共享，$\\sigma$ 也可能很高。它没有区分所有权是否来自另一个核心的 Modified 状态，而这才是“乒乓”效应的关键信号。阈值 $\\sigma \\ge 0.6$ 是任意的，并且根据给定数据不会标记 $R_1$（$\\sigma_{R_1} = \\frac{120{,}000}{300{,}000} = 0.4$），但更重要的是，该指标并非针对伪共享。结论 — 错误。\n\n因此，选项 A 中的方法和阈值设置是恰当的，并且它会根据所提供的数据正确标记 $R_1$ 中的 $\\ell_1$，而不标记 $R_2$ 中的行。", "answer": "$$\\boxed{A}$$", "id": "3641015"}]}