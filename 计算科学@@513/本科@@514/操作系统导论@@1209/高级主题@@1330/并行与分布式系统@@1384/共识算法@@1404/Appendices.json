{"hands_on_practices": [{"introduction": "本练习将容错这一抽象概念置于一个具体的设计问题中。通过计算在特定数量的故障下维持系统运行所需的最小节点数 $N$ 和法定人数大小 $q$，你将掌握分布式系统中冗余的核心原则，并学会如何量化系统的整体可靠性。这是设计任何稳健的、基于共识的服务的第一步。[@problem_id:3627669]", "problem": "一个实验室集群使用一个带有多数派法定人数（例如 Paxos 或 Raft）的容错共识算法来协调操作系统服务。故障模型是仅崩溃（crash-only）模型：一个故障节点要么停止运行，要么变得无响应，但不会产生不正确的消息，并且节点在修复后会恢复。假设节点间的故障是相互独立的。\n\n您必须确定在故障情况下维持安全性和活性所需的最小集群大小和法定人数，然后估计共识服务的稳态可用性。\n\n仅使用以下基础原则：\n- 法定人数的定义是：其规模足以取得进展的任何节点子集，并且任意两个法定人数必须相交以保证安全性。\n- 对活性的要求是：在发生指定数量的崩溃后，剩余的正常运行节点子集能够形成一个法定人数。\n- 针对具有无记忆（指数）时间的独立故障和修复组件的标准可靠性建模，其中长期可用性是组件正常运行的时间比例。\n\n执行以下操作：\n1. 对于崩溃容错参数 $f = 2$，确定最小节点数 $N$ 和最小多数派法定人数大小 $q$，使得系统在最多 $f$ 个节点并发崩溃的情况下仍能继续取得进展。\n2. 每个节点的平均无故障时间（MTBF）为 $200$ 小时，平均修复时间（MTTR）为 $10$ 小时。将每个节点建模为在“正常运行”和“宕机”状态之间独立交替，其故障和修复时间服从指数分布。估计共识服务的稳态可用性（以小数表示，而非百分比），定义为在任意时刻至少有 $q$ 个节点（总共 $N$ 个）正常运行的概率。\n\n将您的最终答案表示为一行三个值 $\\left(N, q, \\text{availability}\\right)$，其中可用性四舍五入到四位有效数字。最终答案框中不应包含任何单位。", "solution": "该问题提法明确，具有科学依据，并提供了确定集群大小、法定人数大小和系统可用性所需的所有必要信息。所引用的原则——用于安全性的法定人数相交、用于活性的可生存性以及标准可靠性建模——是分布式系统和可靠性工程的基础。因此，该问题被认为是有效的。\n\n根据问题陈述的要求，解答分为两部分。\n\n第 1 部分：确定最小集群大小 $N$ 和法定人数大小 $q$。\n\n系统采用多数派法定人数共识算法，并且必须能够容忍 $f$ 个崩溃故障。必须满足两个基本属性：安全性和活性。\n\n安全性属性要求任意两个法定人数必须有非空交集。对于一个有 $N$ 个节点和统一法定人数大小为 $q$ 的系统，该条件数学上表示为：\n$$q + q > N \\implies 2q > N$$\n由于 $q$ 必须是整数，这等价于 $q \\ge \\lfloor \\frac{N}{2} \\rfloor + 1$。这就定义了多数派法定人数。\n\n活性属性要求系统在最多 $f$ 个节点并发崩溃的情况下仍能继续取得进展（即形成一个法定人数）。这意味着剩余的正常运行节点数量必须至少等于一个法定人数的大小：\n$$N - f \\ge q$$\n\n为了找到容忍 $f$ 个故障所需的最小节点数 $N$，我们结合这两个不等式：\n$$N - f \\ge q > \\frac{N}{2}$$\n关注不等式的两端，我们有：\n$$N - f > \\frac{N}{2}$$\n$$N - \\frac{N}{2} > f$$\n$$\\frac{N}{2} > f$$\n$$N > 2f$$\n由于 $N$ 必须是整数，所以最小节点数为 $N_{min} = 2f + 1$。\n\n问题陈述系统必须容忍最多 $f = 2$ 个并发崩溃。将这个值代入 $N_{min}$ 的表达式：\n$$N = 2(2) + 1 = 5$$\n所以，所需的最小节点数为 $N = 5$。\n\n当 $N=5$ 时，我们现在可以使用安全性条件来确定最小多数派法定人数大小 $q$：\n$$q = \\lfloor \\frac{N}{2} \\rfloor + 1 = \\lfloor \\frac{5}{2} \\rfloor + 1 = 2 + 1 = 3$$\n因此，最小法定人数大小为 $q = 3$。\n\n我们必须验证这个配置 $(N=5, q=3)$ 对于 $f=2$ 也满足活性条件：\n$$N - f \\ge q \\implies 5 - 2 \\ge 3 \\implies 3 \\ge 3$$\n该条件成立。因此，最小集群大小为 $N=5$，最小法定人数大小为 $q=3$。\n\n第 2 部分：估计稳态可用性。\n\n首先，我们计算单个节点的稳态可用性，记为 $A_{node}$。对于一个具有指数故障和修复时间的组件，其故障率为 $\\lambda = \\frac{1}{\\text{MTBF}}$，修复率为 $\\mu = \\frac{1}{\\text{MTTR}}$。稳态可用性是节点长期运行的时间比例，由以下公式给出：\n$$A_{node} = \\frac{\\mu}{\\lambda + \\mu} = \\frac{\\frac{1}{\\text{MTTR}}}{\\frac{1}{\\text{MTBF}} + \\frac{1}{\\text{MTTR}}}$$\n将分子和分母同乘以 $(\\text{MTBF} \\times \\text{MTTR})$，可简化为：\n$$A_{node} = \\frac{\\text{MTBF}}{\\text{MTBF} + \\text{MTTR}}$$\n给定 MTBF = $200$ 小时，MTTR = $10$ 小时：\n$$A_{node} = \\frac{200}{200 + 10} = \\frac{200}{210} = \\frac{20}{21}$$\n一个节点宕机的概率是 $U_{node} = 1 - A_{node} = 1 - \\frac{20}{21} = \\frac{1}{21}$。\n\n如果至少有一个法定人数的节点处于正常运行状态，则共识服务可用。在 $N=5$ 和 $q=3$ 的情况下，如果 $3$、$4$ 或 $5$ 个节点正常运行，则服务可用。由于节点故障是独立的，大小为 $N$ 的集群中正常运行的节点数 $k$ 服从二项分布。恰好有 $k$ 个节点正常运行的概率由以下公式给出：\n$$P(k) = \\binom{N}{k} (A_{node})^k (1 - A_{node})^{N-k}$$\n共识服务的可用性 $A_{service}$ 是正常运行节点数大于或等于 $q$ 的概率：\n$$A_{service} = P(k \\ge q) = \\sum_{k=q}^{N} \\binom{N}{k} (A_{node})^k (1 - A_{node})^{N-k}$$\n代入 $N=5$、$q=3$ 和 $A_{node} = \\frac{20}{21}$：\n$$A_{service} = P(k=3) + P(k=4) + P(k=5)$$\n$$A_{service} = \\binom{5}{3} \\left(\\frac{20}{21}\\right)^3 \\left(\\frac{1}{21}\\right)^{2} + \\binom{5}{4} \\left(\\frac{20}{21}\\right)^4 \\left(\\frac{1}{21}\\right)^{1} + \\binom{5}{5} \\left(\\frac{20}{21}\\right)^5 \\left(\\frac{1}{21}\\right)^{0}$$\n二项式系数为 $\\binom{5}{3} = \\frac{5!}{3!2!} = 10$，$\\binom{5}{4} = 5$ 和 $\\binom{5}{5} = 1$。\n$$A_{service} = 10 \\cdot \\frac{20^3}{21^3} \\cdot \\frac{1^2}{21^2} + 5 \\cdot \\frac{20^4}{21^4} \\cdot \\frac{1^1}{21^1} + 1 \\cdot \\frac{20^5}{21^5} \\cdot \\frac{1^0}{21^0}$$\n让我们提取公因式以简化计算：\n$$A_{service} = \\frac{20^3}{21^5} \\left[ 10 + 5 \\cdot 20 + 20^2 \\right]$$\n$$A_{service} = \\frac{8000}{4084101} \\left[ 10 + 100 + 400 \\right]$$\n$$A_{service} = \\frac{8000}{4084101} \\left[ 510 \\right]$$\n$$A_{service} = \\frac{4080000}{4084101}$$\n现在，我们计算其小数值并四舍五入到四位有效数字：\n$$A_{service} \\approx 0.99900076$$\n四舍五入到四位有效数字得到 $0.9990$。\n\n最终结果是 $N=5$，$q=3$，可用性 $\\approx 0.9990$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n5 & 3 & 0.9990\n\\end{pmatrix}\n}\n$$", "id": "3627669"}, {"introduction": "在建立了容错系统的静态结构之后，理解其动态性能至关重要。本练习通过考虑网络延迟和丢包概率 $\\pi$ 等因素，对 Raft 算法中提交一次操作的期望时间（一个关键的延迟指标）进行建模。通过这一分析，你将对真实世界的网络不完美性如何影响共识协议的效率建立起直观的认识。[@problem_id:3645073]", "problem": "一个分布式操作系统使用 Raft 共识算法来复制状态。当领导者（leader）在本地附加了条目，并收到了大多数跟随者（follower）的确认后，客户端的写入被视为已提交。在稳态、无故障条件下，定义以下可测量量。\n\n- 令 $r_m$ 表示在没有丢包情况下的基准多数派往返时间，其测量范围从领导者向所有跟随者发送单个 AppendEntries 请求开始，到形成多数派所需的最后一个确认到达领导者为止。该基准时间包含了多数派路径上的网络传播和排队效应，但不包括跟随者的处理时间。\n- 令 $p_f$ 表示每个 AppendEntries 请求在跟随者端的处理时间，其测量范围从跟随者收到请求开始，到其确认准备好发送为止。\n- 令 $\\pi \\in [0,1)$ 表示网络上每次独立消息传输的独立丢包概率。丢包事件在重传和不同跟随者之间是独立的。在感兴趣的时间区间内，没有领导者崩溃或重新选举。\n\n假设以下操作模型。\n\n- 在每次复制尝试中，领导者发送一次 AppendEntries 并等待恰好 $r_m$ 的时间以获得多数派确认。跟随者的处理时间 $p_f$ 是额外累加的，因此在没有丢包妨碍及时形成多数派的情况下，单次尝试的壁钟时间为 $r_m + p_f$。\n- 一次尝试能够成功提交，当且仅当关键多数派路径上的端到端交换无丢包地传递了 AppendEntries 请求和相应的确认。在多数派的等效信道近似下，将每次尝试的成功概率建模为 $s = (1 - \\pi)^2$。如果一次尝试未能提交，领导者会立即重复尝试，具有相同的时间设置和独立的丢包事件，直到该条目成功提交。没有指数退避。\n\n仅根据上述定义和独立性假设，推导出一个关于条目提交的期望时间 $E[T_c]$ 的封闭形式表达式，该表达式是 $r_m$、$p_f$ 和 $\\pi$ 的函数。然后，根据你的表达式，定性解释当丢包概率 $\\pi$ 很小时，$E[T_c]$ 如何随 $\\pi$ 变化。将你对 $E[T_c]$ 的最终答案表示为单个简化的解析表达式。无需四舍五入，也无需单位。", "solution": "问题要求在一个简化的 Raft 共识算法模型中，计算提交一个日志条目的期望时间，并对该时间作为丢包概率的函数进行定性分析。提交一个条目的过程可以被建模为一系列独立的伯努利试验。\n\n首先，我们必须定义单次试验的参数，该试验对应于一次复制尝试。\n如果条目被提交，则称一次尝试是成功的。问题指出，每次尝试的成功概率由 $s$ 给出。根据等效信道近似，这被定义为领导者的 `AppendEntries` 请求和跟随者的确认都在关键路径上成功传输的概率。对于每次消息传输，独立的丢包概率为 $\\pi$，因此单次消息传输成功的概率是 $(1 - \\pi)$。由于一次成功的往返（请求和确认）需要两次这样的传输，所以一次尝试的成功概率是：\n$$s = (1 - \\pi) \\times (1 - \\pi) = (1 - \\pi)^2$$\n\n接下来，我们确定单次复制尝试的持续时间。问题陈述，“领导者发送一次 AppendEntries 并等待恰好 $r_m$ 的时间以获得多数派确认。”它还指明，“跟随者的处理时间 $p_f$ 是额外累加的，因此在没有丢包妨碍及时形成多数派的情况下，单次尝试的壁钟时间为 $r_m + p_f$。”如果一次尝试未能提交，领导者会“立即重复尝试，具有相同的时间设置”。“具有相同的时间设置”这一短语意味着每次尝试，无论成功与否，都具有相同的持续时间。为了完成一次成功的尝试，领导者必须等待足够长的时间以覆盖往返网络延迟（$r_m$）和跟随者处理时间（$p_f$）。因此，领导者为每次尝试设置的超时必须至少为 $r_m + p_f$。问题的描述得出的结论是，每次尝试的持续时间（我们将其表示为 $T_1$）是恒定的。\n$$T_1 = r_m + p_f$$\n\n整个过程由一系列这样的尝试组成，直到第一次成功为止。设 $K$ 为实现首次提交所需的尝试次数的随机变量。由于每次尝试都是一个具有恒定成功概率 $s$ 的独立试验，因此 $K$ 服从参数为 $s$ 的几何分布。\n$K$ 的概率质量函数由下式给出：\n$$P(K=k) = (1-s)^{k-1}s, \\quad \\text{for } k = 1, 2, 3, \\dots$$\n对于几何分布，达到首次成功所需的期望试验次数为：\n$$E[K] = \\frac{1}{s}$$\n\n提交的总时间 $T_c$ 是尝试次数 $K$ 乘以每次尝试的固定持续时间 $T_1$。\n$$T_c = K \\cdot T_1$$\n我们被要求找出提交的期望时间 $E[T_c]$。利用期望的线性性质：\n$$E[T_c] = E[K \\cdot T_1]$$\n由于 $T_1$ 是一个常数，我们可以写成：\n$$E[T_c] = T_1 \\cdot E[K]$$\n代入 $T_1$ 和 $E[K]$ 的表达式：\n$$E[T_c] = (r_m + p_f) \\cdot \\frac{1}{s}$$\n现在，代入成功概率 $s = (1 - \\pi)^2$ 的表达式：\n$$E[T_c] = \\frac{r_m + p_f}{(1 - \\pi)^2}$$\n这就是提交该条目的期望时间的封闭形式表达式。\n\n任务的第二部分是定性解释当丢包概率 $\\pi$ 很小时，$E[T_c]$ 如何随 $\\pi$ 变化。为此，我们可以分析函数 $E[T_c](\\pi)$ 在 $\\pi$ 接近 0 时的行为。我们可以使用项 $(1 - \\pi)^{-2}$ 在 $\\pi = 0$ 附近的泰勒级数展开。\n二项式级数展开的一般形式是 $(1+x)^\\alpha = 1 + \\alpha x + \\frac{\\alpha(\\alpha-1)}{2!}x^2 + \\dots$。对于我们的表达式，$x = -\\pi$ 且 $\\alpha = -2$。\n一阶泰勒展开为：\n$$(1 - \\pi)^{-2} \\approx 1 + (-2)(-\\pi) = 1 + 2\\pi$$\n将此近似值代回 $E[T_c]$ 的表达式中：\n$$E[T_c] \\approx (r_m + p_f)(1 + 2\\pi) \\quad \\text{for small } \\pi$$\n此表达式表明，对于小的丢包概率 $\\pi$，期望提交时间 $E[T_c]$ 大致随 $\\pi$ 线性增加。基准期望时间（当 $\\pi=0$ 时）为 $r_m + p_f$，即单次成功尝试的持续时间。随着丢包概率 $\\pi$ 从零开始增加，提交的期望时间会受到惩罚。线性近似表明，$\\pi$ 的每一个小增量都会给提交时间增加大约 $2\\pi(r_m + p_f)$ 的期望延迟。这是因为非零的丢包概率引入了一次或多次失败尝试的可能性，每次失败都会给总时间增加 $r_m + p_f$，而这种失败尝试的期望次数随 $\\pi$ 的增长而增长。函数 $E[T_c](\\pi)$ 在 $\\pi \\in [0, 1)$ 上是严格递增和凸的，这意味着随着 $\\pi$ 变大，丢包的惩罚以一个不断增长的速率增加。", "answer": "$$\\boxed{\\frac{r_m + p_f}{(1 - \\pi)^2}}$$", "id": "3645073"}, {"introduction": "共识算法的运行依赖于准确地检测节点（尤其是领导者）是否发生故障。这个动手实践问题将探索一种累积式故障检测器的设计，这是一种提供“怀疑等级” $\\phi(t)$ 而非简单“在线/离线”状态的精密机制。你将解决一个优化问题，以平衡快速检测故障的需求与误报风险，这是构建稳定且响应迅速的分布式系统时的一个关键权衡。[@problem_id:3627694]", "problem": "您正在设计一个操作系统（OS）级的监控组件，该组件使用扩展伯克利数据包过滤器（eBPF）程序来为主节点心跳添加时间戳并导出其到达间隔时间。这些测量值被用于一个累积失效检测器，其怀疑级别为 $\\phi(t)$。当 $\\phi(t)$ 超过阈值 $\\Phi$ 时，该检测器会在一个共识模块中触发主节点选举。您将假设来自健康主节点的心跳到达遵循速率为 $\\lambda$（单位为 $\\mathrm{s}^{-1}$）的泊松过程，这意味着到达间隔时间是参数为 $\\lambda$ 的独立同分布的指数随机变量。\n\n基本和核心定义：\n- 对于速率为 $\\lambda$ 的泊松过程，其到达间隔时间随机变量 $X$ 的生存函数为 $\\Pr\\{X > x\\} = e^{-\\lambda x}$，其中 $x \\ge 0$。\n- 累积失效检测器定义为 $\\phi(t) = -\\log_{10} \\Pr\\{X > t - t_{\\text{last}}\\}$，其中 $t_{\\text{last}}$ 是最后观察到的心跳的时间戳。在指数模型下，对于经过时间 $x = t - t_{\\text{last}}$，该定义变为 $\\phi(x) = -\\log_{10}(e^{-\\lambda x}) = \\dfrac{\\lambda x}{\\ln 10}$。\n- 当 $\\phi(t)$ 首次超过一个恒定阈值 $\\Phi$ 时，共识模块会启动一次主节点选举。\n\n设计目标：\n- 您必须选择怀疑阈值 $\\Phi$，以最小化错误的主节点选举，同时在真实主节点崩溃的情况下保证检测时间要求。\n\n用于评估的可量化定义：\n- 检测时间要求：如果主节点实际发生故障（停止发送心跳），则“到达怀疑的时间”是使得 $\\phi(x^{\\ast}) = \\Phi$ 的首次穿越时间 $x^{\\ast}$。在指数模型下，这意味着 $x^{\\ast} = \\dfrac{\\Phi \\ln 10}{\\lambda}$。为了保证在 $D$ 秒内怀疑，其必要和充分条件是 $x^{\\ast} \\le D$，即 $\\Phi \\le \\dfrac{\\lambda D}{\\ln 10}$。\n- 监控时域内的错误选举模型：当主节点健康时，如果 $\\phi(t)$ 在下一次心跳到达之前超过 $\\Phi$，则会发生错误的主节点选举。对于指数变量 $X$，每个时间间隔的错误怀疑概率为 $\\Pr\\{X > x^{\\ast}\\} = 10^{-\\Phi}$。在长度为 $H$ 秒的时域内，预期的时间间隔机会数为 $\\lambda H$，在该时域内至少发生一次错误选举的概率为 $p(H,\\Phi) = 1 - \\exp\\!\\left(-\\lambda H \\cdot 10^{-\\Phi}\\right)$。\n\n优化问题：\n- 在满足检测时间约束 $x^{\\ast} \\le D$ 的前提下，选择 $\\Phi$ 以最小化 $p(H,\\Phi)$。从第一性原理出发，论证为什么最优选择位于约束的边界上，并计算由此产生的 $\\Phi^{\\ast}$，作为 $\\lambda$ 和 $D$ 的函数。\n\n实现任务：\n- 编写一个完整的程序，为每个给定的测试用例计算最优阈值 $\\Phi^{\\ast}$，并将所有结果输出到单行中。\n\n输入由问题固定；您的程序不得读取任何输入。使用以下测试套件，其中 $\\lambda$ 的单位是 $\\mathrm{s}^{-1}$，$D$ 和 $H$ 的单位是 $\\mathrm{s}$，输出的 $\\Phi^{\\ast}$ 无单位：\n- 测试用例 1（通用“理想路径”）：$\\lambda = 1.0$, $D = 2.0$, $H = 60.0$。\n- 测试用例 2（边界：非常紧迫的检测时间）：$\\lambda = 2.0$, $D = 0.1$, $H = 60.0$。\n- 测试用例 3（低心跳速率）：$\\lambda = 0.5$, $D = 5.0$, $H = 120.0$。\n- 测试用例 4（高心跳速率和宽裕的检测时间）：$\\lambda = 5.0$, $D = 8.0$, $H = 30.0$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个 $\\Phi^{\\ast}$ 值都四舍五入到小数点后恰好六位数字（例如，$[\\;0.123456,1.000000,2.500000\\;]$）。方括号内不得有空格。\n\n交付内容：\n- 一个单一的可编译程序，为每个测试用例计算 $\\Phi^{\\ast}$，并以确切要求的格式打印结果。不允许用户输入。所有常量必须嵌入在程序中。", "solution": "所述问题构成了一个定义明确的约束优化问题。我们的任务是为累积失效检测器选择一个怀疑阈值 $\\Phi$，以在满足真实故障检测时间的约束下，最小化错误主节点选举的概率。\n\n各量定义如下：\n- 健康主节点的心跳速率为 $\\lambda$，遵循泊松过程。\n- 心跳之间的时间 $X$ 是一个指数随机变量，其概率密度函数为 $f(x) = \\lambda e^{-\\lambda x}$，生存函数为 $\\Pr\\{X > x\\} = e^{-\\lambda x}$，其中 $x \\ge 0$。\n- 自上次心跳以来经过时间 $x$ 后的怀疑级别为 $\\phi(x) = \\dfrac{\\lambda x}{\\ln 10}$。\n- 当 $\\phi(x)$ 超过阈值 $\\Phi$ 时，触发主节点选举。发生这种情况的时间 $x^{\\ast}$ 可通过求解 $\\Phi = \\phi(x^{\\ast})$ 得到，即 $x^{\\ast} = \\dfrac{\\Phi \\ln 10}{\\lambda}$。\n- 检测时间约束要求必须在 $D$ 秒内检测到真实故障。这要求“到达怀疑的时间” $x^{\\ast}$ 不超过 $D$，即 $x^{\\ast} \\le D$。代入 $x^{\\ast}$ 的表达式，我们得到对 $\\Phi$ 的约束：\n$$ \\dfrac{\\Phi \\ln 10}{\\lambda} \\le D \\implies \\Phi \\le \\dfrac{\\lambda D}{\\ln 10} $$\n由于对于任何非零的经过时间，怀疑级别必须为正，因此阈值的定义域为 $\\Phi > 0$。\n\n- 在时间跨度 $H$ 内，至少发生一次错误选举（即在主节点健康时触发怀疑）的概率由我们想要最小化的目标函数给出：\n$$ p(H,\\Phi) = 1 - \\exp\\!\\left(-\\lambda H \\cdot 10^{-\\Phi}\\right) $$\n\n因此，优化问题是：\n在约束 $0  \\Phi \\le \\dfrac{\\lambda D}{\\ln 10}$ 下，关于 $\\Phi$ 最小化 $p(H,\\Phi)$。\n\n为解决此问题，我们分析目标函数 $p(H,\\Phi)$ 的行为。\n让我们考虑函数 $p(\\Phi) = 1 - \\exp(-C \\cdot 10^{-\\Phi})$，其中 $C = \\lambda H$ 是一个正常数。\n要最小化 $p(\\Phi)$，我们必须最大化从 1 中减去的那一项，即 $\\exp(-C \\cdot 10^{-\\Phi})$。\n指数函数 $e^z$ 是其参数 $z$ 的严格递增函数。因此，最大化 $e^z$ 等价于最大化其参数 $z$。在我们的例子中，参数是 $z = -C \\cdot 10^{-\\Phi}$。\n最大化 $-C \\cdot 10^{-\\Phi}$ 等价于最小化 $C \\cdot 10^{-\\Phi}$，因为 $C$ 是一个正常数。\n由于 $C = \\lambda H  0$，最小化 $C \\cdot 10^{-\\Phi}$ 等价于最小化 $10^{-\\Phi}$ 这一项。\n\n函数 $h(\\Phi) = 10^{-\\Phi} = \\left(\\frac{1}{10}\\right)^{\\Phi}$ 是一个标准的指数函数，其底数在 0 和 1 之间。这类函数对于所有实数 $\\Phi$ 都是严格递减的。\n或者，我们可以分析它关于 $\\Phi$ 的导数：\n$$ \\dfrac{d}{d\\Phi} (10^{-\\Phi}) = 10^{-\\Phi} \\ln(10) \\cdot (-1) = -\\ln(10) \\cdot 10^{-\\Phi} $$\n由于 $\\ln(10)  0$ 并且对于所有实数 $\\Phi$ 都有 $10^{-\\Phi}  0$，所以导数总是负的。导数严格为负的函数是严格递减的。\n\n这证明了我们最初的目标函数 $p(H,\\Phi)$ 是 $\\Phi$ 的一个严格递减函数。要在给定区间上最小化一个严格递减的函数，必须在该区间内为其参数选择可能的最大值。\n\n$\\Phi$ 的允许区间由检测时间约束定义：\n$$ 0  \\Phi \\le \\dfrac{\\lambda D}{\\ln 10} $$\n此区间中 $\\Phi$ 的最大值出现在边界上。因此，在满足检测时间要求的同时最小化错误选举概率的最优阈值 $\\Phi^{\\ast}$ 是：\n$$ \\Phi^{\\ast} = \\dfrac{\\lambda D}{\\ln 10} $$\n这个结果是直观正确的。更高的阈值 $\\Phi$ 使系统不那么“容易触发”，从而降低了错误怀疑的频率。最优策略是将阈值设置得尽可能高，直到达到要求在时间 $D$ 内检测到真实故障所施加的限制。监控时域 $H$ 影响错误选举概率 $p(H, \\Phi)$ 的值，但它不影响最优阈值 $\\Phi^{\\ast}$ 的选择，后者完全由每个时间间隔内检测时间与误报之间的权衡决定。", "answer": "$$\\boxed{\\text{[0.868589,0.086859,1.085736,17.371779]}}$$", "id": "3627694"}]}