{"hands_on_practices": [{"introduction": "分布式系统的核心优势之一是通过冗余来提高可用性。本练习将通过一个简化的概率模型，帮助你定量地分析副本数量与服务整体可用性之间的关系。通过推导和计算，你将亲身体会到“收益递减”原则在系统设计中的实际应用，这对于在成本和可靠性之间做出权衡至关重要。[@problem_id:3645021]", "problem": "一个分布式操作系统 (DOS) 将一个无状态、以读取为主的服务部署为 $k$ 个相同的副本，分布在独立的节点上。在一个固定的任务窗口期内，每个节点不可用的概率为 $p \\in (0,1)$，且与其他所有节点相互独立。如果在该窗口期内至少有1个副本可用，则该服务被认为是可用的。假设没有相关性故障，并忽略网络分区和请求路由延迟。\n\n仅从概率公理和独立性定义出发，完成以下任务：\n\n1. 推导服务的精确可用性 $A(k)$，作为 $k$ 和 $p$ 的函数。\n2. 使用您推导的 $A(k)$ 表达式，推导增加第 $k$ 个副本所带来的边际可用性增益 $\\Delta(k)$，其定义为 $\\Delta(k) = A(k) - A(k-1)$（$k \\ge 1$），并约定 $A(0)=0$。然后，确定比率 $\\rho(k) = \\frac{\\Delta(k+1)}{\\Delta(k)}$（$k \\ge 1$），并解释这对于随着 $k$ 增加而出现的收益递减意味着什么。\n3. 对于一个具体的系统，其中 $p = 0.02$，确定最小的整数 $k$，使得增加第 $k$ 个副本带来的增量收益低于目标阈值 $\\varepsilon = 1.0 \\times 10^{-6}$，即 $\\Delta(k)  \\varepsilon$。\n\n将您针对参数 $p = 0.02$ 和 $\\varepsilon = 1.0 \\times 10^{-6}$ 的最终答案报告为 $k$ 的整数值。除了精确整数外，不需要进行四舍五入。", "solution": "问题陈述已经过分析，被认为是有效的。它在科学上以基础概率论为依据，问题阐述清晰，目标明确，数据充分，并以客观、正式的语言表达。因此，我们可以开始求解。\n\n解决方案按照问题陈述的要求分为三个部分。\n\n### 第一部分：服务可用性 $A(k)$ 的推导\n\n设 $U_i$ 为第 $i$ 个副本在任务窗口期内不可用的事件，其中 $i \\in \\{1, 2, \\dots, k\\}$。问题陈述中指出，此事件的概率为 $p$。\n$$P(U_i) = p$$\n因此，第 $i$ 个副本可用的概率，我们用其对立事件 $U_i^c$ 表示，为：\n$$P(U_i^c) = 1 - p$$\n根据定义，如果至少有一个副本可用，则服务可用。计算其对立事件的概率更为直接：即服务不可用。服务不可用当且仅当所有 $k$ 个副本都不可用。这对应于事件 $U_1, U_2, \\dots, U_k$ 的交集。\n$$P(\\text{服务不可用}) = P(U_1 \\cap U_2 \\cap \\dots \\cap U_k)$$\n问题明确指出节点是独立的。因此，事件 $U_i$ 是相互独立的。它们交集的概率是它们各自概率的乘积：\n$$P(\\text{服务不可用}) = \\prod_{i=1}^{k} P(U_i) = \\prod_{i=1}^{k} p = p^k$$\n服务的可用性 $A(k)$ 是服务可用的概率。这是 $1$ 减去服务不可用的概率。\n$$A(k) = 1 - P(\\text{服务不可用})$$\n代入推导出的表达式，得到可用性作为 $k$ 和 $p$ 的精确函数：\n$$A(k) = 1 - p^k$$\n\n### 第二部分：边际增益 $\\Delta(k)$ 和比率 $\\rho(k)$ 的推导\n\n边际可用性增益 $\\Delta(k)$ 定义为 $\\Delta(k) = A(k) - A(k-1)$，$k \\ge 1$，并约定 $A(0) = 0$。\n使用 $A(k)$ 的表达式：\n$$A(k) = 1 - p^k$$\n$$A(k-1) = 1 - p^{k-1}$$\n将这些代入 $\\Delta(k)$ 的定义中：\n$$\\Delta(k) = (1 - p^k) - (1 - p^{k-1}) = 1 - p^k - 1 + p^{k-1} = p^{k-1} - p^k$$\n提出公因子 $p^{k-1}$：\n$$\\Delta(k) = p^{k-1}(1-p)$$\n这个表达式代表了通过增加第 $k$ 个副本所获得的服务的增量可用性概率。它恰好是前 $k-1$ 个副本均失败（概率为 $p^{k-1}$）且第 $k$ 个副本可用（概率为 $1-p$）的概率。\n\n接下来，我们确定比率 $\\rho(k) = \\frac{\\Delta(k+1)}{\\Delta(k)}$，$k \\ge 1$。\n首先，通过在 $\\Delta(k)$ 的公式中用 $k+1$ 替换 $k$，我们得到 $\\Delta(k+1)$ 的表达式：\n$$\\Delta(k+1) = p^{(k+1)-1}(1-p) = p^k(1-p)$$\n现在，我们构建这个比率：\n$$\\rho(k) = \\frac{\\Delta(k+1)}{\\Delta(k)} = \\frac{p^k(1-p)}{p^{k-1}(1-p)}$$\n由于 $p \\in (0,1)$，项 $1-p$ 非零，可以消去。我们得到：\n$$\\rho(k) = \\frac{p^k}{p^{k-1}} = p^{k-(k-1)} = p^1 = p$$\n比率 $\\rho(k)$ 是一个常数，等于 $p$。由于 $p \\in (0,1)$，这意味着增加一个副本带来的边际增益总是前一个副本边际增益的一个固定比例 $p$。这代表了边际增益的几何级数递减，是收益递减原则的一个典型例子。后续增加的每个副本对系统整体可用性的贡献越来越小。\n\n### 第三部分：最小副本数 $k$ 的确定\n\n我们需要找到最小的整数 $k$，使得增量增益 $\\Delta(k)$ 低于阈值 $\\varepsilon$。条件是：\n$$\\Delta(k)  \\varepsilon$$\n代入 $\\Delta(k)$ 的表达式以及给定的值 $p = 0.02$ 和 $\\varepsilon = 1.0 \\times 10^{-6}$：\n$$p^{k-1}(1-p)  \\varepsilon$$\n$$(0.02)^{k-1}(1 - 0.02)  1.0 \\times 10^{-6}$$\n$$(0.02)^{k-1}(0.98)  10^{-6}$$\n为了解出 $k$，我们首先分离含有指数的项：\n$$(0.02)^{k-1}  \\frac{10^{-6}}{0.98}$$\n现在我们对两边取自然对数 ($\\ln$)。由于自然对数是严格递增函数，不等式的方向保持不变。\n$$\\ln\\left((0.02)^{k-1}\\right)  \\ln\\left(\\frac{10^{-6}}{0.98}\\right)$$\n使用对数性质 $\\ln(a^b) = b\\ln(a)$：\n$$(k-1)\\ln(0.02)  \\ln(10^{-6}) - \\ln(0.98)$$\n为了分离出 $(k-1)$，我们必须除以 $\\ln(0.02)$。关键要注意的是，由于 $0.02  1$，$\\ln(0.02)$ 的值是负数。不等式两边同除以一个负数会改变不等号的方向。\n$$k-1 > \\frac{\\ln(10^{-6}) - \\ln(0.98)}{\\ln(0.02)}$$\n现在，我们可以解出 $k$：\n$$k > 1 + \\frac{\\ln(10^{-6}) - \\ln(0.98)}{\\ln(0.02)}$$\n我们来计算右边的表达式：\n$$k > 1 + \\frac{-6\\ln(10) - \\ln(0.98)}{\\ln(0.02)}$$\n使用计算值，$\\ln(10) \\approx 2.302585$，$\\ln(0.98) \\approx -0.0202027$，以及 $\\ln(0.02) \\approx -3.912023$。\n$$k > 1 + \\frac{-6(2.302585) - (-0.0202027)}{-3.912023}$$\n$$k > 1 + \\frac{-13.815510 + 0.0202027}{-3.912023}$$\n$$k > 1 + \\frac{-13.7953073}{-3.912023} \\approx 1 + 3.52638$$\n$$k > 4.52638$$\n由于 $k$ 必须是整数，满足此不等式的最小整数值为 $5$。\n为了验证，当 $k=5$ 时，增益为 $\\Delta(5) = (0.02)^{4}(0.98) = (1.6 \\times 10^{-7})(0.98) = 1.568 \\times 10^{-7}$，小于 $\\varepsilon = 1.0 \\times 10^{-6}$。\n当 $k=4$ 时，增益为 $\\Delta(4) = (0.02)^{3}(0.98) = (8.0 \\times 10^{-6})(0.98) = 7.84 \\times 10^{-6}$，不小于 $\\varepsilon$。\n因此，最小的整数确实是 $k=5$。", "answer": "$$\\boxed{5}$$", "id": "3645021"}, {"introduction": "利用网络中可用的计算资源是分布式操作系统提升性能的关键手段。这个练习将引导你分析一个经典的决策问题：是否应该将一个计算任务迁移到更快的远程节点上执行。通过建立一个简单的成本效益模型，你将推导出一个明确的迁移阈值，从而理解系统如何在“迁移开销”和“执行速度增益”之间做出最佳选择。[@problem_id:3644955]", "problem": "一个分布式操作系统 (DOS) 可以将一个计算密集型进程从本地节点迁移到远程节点，以减少其完成时间。假设该进程的作业大小为 $x$，以本地中央处理器 (CPU) 秒为单位，这意味着如果它完全在本地节点上执行，将需要本地处理器 $x$ 秒的 CPU 时间。远程节点相对于本地节点提供了一个速度比 $\\rho$，这意味着远程处理器的执行速率是本地处理器的 $\\rho$ 倍，其中 $\\rho  1$。将进程迁移到远程节点的行为会产生一次性的网络和设置成本 $C_{n}$（以秒为单位），其中包括状态转移和远程调度开销。假设计算与通信之间没有重叠，计算量在迁移前后保持不变，且两个节点上都没有排队延迟。\n\n仅使用“执行时间等于工作量除以速度”和“独立的开销会增加完成时间”这两个基本事实，推导出一个决策规则，该规则保证迁移能够带来净完成时间的减少。请将您的答案表示为阈值作业大小 $x^{*}$（以秒为单位），形式为关于 $\\rho$ 和 $C_{n}$ 的闭合符号表达式，使得当且仅当 $x  x^{*}$ 时，迁移会严格减少完成时间。请提供精确的最终答案，不要近似。阈值以秒为单位表示。", "solution": "该问题要求推导分布式系统中进程迁移的决策规则。该规则应确定阈值作业大小，记为 $x^*$，当作业大小超过此阈值时，将进程迁移到远程节点会严格减少其完成时间。推导将基于所提供的基本原则和变量。\n\n首先，我们来形式化两种可能的执行场景的完成时间：本地执行和远程执行。\n\n设 $T_{local}$ 为进程完全在本地节点上执行的总完成时间。问题将作业大小 $x$ 定义为进程在本地节点上所需的 CPU 时间（以秒为单位）。因此，本地执行的完成时间为：\n$$T_{local} = x$$\n\n接下来，设 $T_{remote}$ 为进程迁移到远程节点后的总完成时间。该时长包括两个不同的、不重叠的部分：迁移开销和远程计算时间。\n\n迁移成本是一个固定的、一次性的开销，给定为 $C_{n}$ 秒。\n\n远程节点上的计算时间取决于作业的工作内容和远程处理器的速度。设 $W$ 代表进程的总计算工作量。由于该进程在本地处理器上需要 $x$ 秒，我们可以将工作量表示为 $W = S_{local} \\cdot x$，其中 $S_{local}$ 是本地处理器的执行速度（例如，每秒指令数）。远程处理器的速度是本地处理器的 $\\rho$ 倍，因此其速度为 $S_{remote} = \\rho \\cdot S_{local}$。远程节点上的执行时间是工作量除以远程速度：\n$$T_{compute\\_remote} = \\frac{W}{S_{remote}} = \\frac{S_{local} \\cdot x}{\\rho \\cdot S_{local}} = \\frac{x}{\\rho}$$\n问题陈述计算与通信之间没有重叠。因此，远程场景的总完成时间是迁移开销和远程计算时间之和：\n$$T_{remote} = C_{n} + T_{compute\\_remote} = C_{n} + \\frac{x}{\\rho}$$\n\n当且仅当完成时间被严格减少时，迁移才是有利的。这可以用以下不等式表示：\n$$T_{remote}  T_{local}$$\n代入 $T_{remote}$ 和 $T_{local}$ 的推导表达式：\n$$C_{n} + \\frac{x}{\\rho}  x$$\n为了找到阈值作业大小 $x^*$，我们必须解这个关于 $x$ 的不等式。我们首先分离包含 $x$ 的项：\n$$C_{n}  x - \\frac{x}{\\rho}$$\n从右侧提取因子 $x$ 得：\n$$C_{n}  x \\left(1 - \\frac{1}{\\rho}\\right)$$\n为简化括号中的项，我们求公分母：\n$$C_{n}  x \\left(\\frac{\\rho - 1}{\\rho}\\right)$$\n问题陈述远程节点速度更快，即 $\\rho  1$。这意味着项 $\\rho - 1$ 是正数。由于 $\\rho$ 也是正数，分数 $\\frac{\\rho-1}{\\rho}$ 是一个正量。因此，我们可以在不等式两边同乘以其倒数 $\\frac{\\rho}{\\rho-1}$，而不用改变不等号的方向：\n$$C_{n} \\cdot \\frac{\\rho}{\\rho - 1}  x$$\n这个不等式可以重写为：\n$$x > C_{n} \\frac{\\rho}{\\rho - 1}$$\n该表达式定义了迁移有利的条件。问题要求找到阈值作业大小 $x^*$，使得当且仅当 $x > x^*$ 时，迁移才严格有利。通过将我们的结果与此条件进行比较，我们可以确定 $x^*$ 的表达式：\n$$x^* = C_{n} \\frac{\\rho}{\\rho - 1}$$\n这就是阈值作业大小的闭合形式符号表达式。如果作业大小 $x$ 大于此值，则由更快的远程处理器节省的时间将超过迁移的固定成本。", "answer": "$$\\boxed{C_{n} \\frac{\\rho}{\\rho - 1}}$$", "id": "3644955"}, {"introduction": "分布式共享内存（DSM）为分布式编程提供了便利的抽象，但也可能引发一些微妙的性能问题，“伪共享”就是其中的典型。本练习模拟了一个由于伪共享而导致额外网络通信开销的场景，要求你量化这种开销并提出解决方案。这个过程将帮助你深入理解数据布局对分布式系统性能的巨大影响，以及为什么在设计并行程序时必须考虑底层的一致性粒度。[@problem_id:3644993]", "problem": "一个并行程序运行在一个分布式共享内存 (DSM) 系统上，该系统以页面为粒度实现基于失效的一致性协议。该系统的页面大小为 $P = 4096$ 字节。系统中有 $N = 8$ 个节点，每个节点运行一个线程。每个线程每秒对一个大型共享数组的元素执行 $r = 5.0 \\times 10^{5}$ 次写操作。该数组是页面对齐的。由于线程在页面内独立放置元素，任何给定的写操作有 $\\phi = 0.12$ 的伪共享概率，即其目标页面在没有真实数据依赖的情况下被其他节点同时缓存。当发生此类伪共享事件时，失效协议会向该页面的每个远程共享者发送一条失效消息和一条确认消息。一个发生伪共享的页面的平均远程共享者数量为 $\\bar{s} = 3$。\n\n从基于失效的一致性协议中关于期望值和消息计数的基本原理出发，推导并计算在这些条件下由伪共享引起的每秒一致性消息的期望速率。用“消息/秒”作为单位表示你的最终数值答案。\n\n然后，基于 DSM 一致性的页面级特性和给定的页面大小 $P$，提出一种具体的数据布局转换方法，通过防止伪共享来降低 $\\phi$，并定性地解释为什么它在 DSM 系统中是有效的。你可以假设只有一个线程需要写入数组元素的某个给定子集，并且可以在页面边界上对齐和划分数据以隔离写入者。\n\n作为最终答案，仅提供在进行任何布局更改之前，以消息/秒为单位的期望一致性消息速率。无需四舍五入，最终方框内不应包含单位。", "solution": "在尝试解答之前，首先评估问题陈述的有效性。\n\n已知条件如下：\n- 页面大小：$P = 4096$ 字节\n- 节点/线程数：$N = 8$\n- 每个线程的写速率：$r = 5.0 \\times 10^{5}$ 次写/秒\n- 伪共享概率：$\\phi = 0.12$\n- 发生伪共享页面的平均远程共享者数量：$\\bar{s} = 3$\n- 一致性协议：基于失效\n- 每个伪共享事件中，每个远程共享者产生的消息：1 条失效消息和 1 条确认消息。\n\n该问题在科学上基于并行计算机体系结构和分布式操作系统的原理，特别是关于分布式共享内存 (DSM) 系统中的缓存一致性。页面粒度上的伪共享概念是一个被充分理解的性能问题。该问题提法得当，为获得唯一的定量解提供了所有必要参数（$N$、$r$、$\\phi$、$\\bar{s}$ 和协议消息计数）。其语言客观而精确。所提供的数据在数值上是一致的，对于一个高性能分布式系统来说是合理的。问题中不存在科学缺陷、矛盾或歧义。因此，该问题被认为是有效的。\n\n按照问题陈述的要求，分两部分进行解答。\n\n第 1 部分：计算期望的一致性消息速率。\n由伪共享引起的一致性消息总速率可以通过考虑系统中所有线程的贡献，从基本原理推导得出。\n\n首先，我们确定整个系统每秒发生的写操作总数。有 $N$ 个线程，每个线程每秒执行 $r$ 次写操作，则系统总写速率 $R_{write}$ 为：\n$$R_{write} = N \\times r$$\n\n接下来，我们确定这些写操作导致伪共享事件的速率。一个伪共享事件由一次写操作以概率 $\\phi$ 触发。因此，伪共享事件的期望速率 $R_{event}$ 是总写速率乘以该概率：\n$$R_{event} = R_{write} \\times \\phi = (N \\times r) \\times \\phi$$\n\n对于每个伪共享事件，基于失效的一致性协议会生成消息。对一个发生伪共享的页面进行写操作，需要向所有拥有该页面缓存副本的其他节点（远程共享者）发送失效消息。问题陈述指出，对于一个给定的伪共享事件，平均有 $\\bar{s}$ 个远程共享者。该协议要求向每个远程共享者发送一条失效消息，并从每个远程共享者接收一条确认消息。因此，每个远程共享者生成的消息数量为 $1 + 1 = 2$。\n每个伪共享事件的总消息数 $M_{event}$ 是每个共享者产生的消息数乘以平均共享者数：\n$$M_{event} = 2 \\times \\bar{s}$$\n\n最后，每秒一致性消息的总期望速率 $R_{msg}$ 是伪共享事件的速率与每个事件生成的消息数的乘积。\n$$R_{msg} = R_{event} \\times M_{event} = (N \\times r \\times \\phi) \\times (2 \\times \\bar{s})$$\n\n代入给定的数值：\n- $N = 8$\n- $r = 5.0 \\times 10^{5} \\text{ s}^{-1}$\n- $\\phi = 0.12$\n- $\\bar{s} = 3$\n\n我们计算速率：\n$$R_{msg} = 8 \\times (5.0 \\times 10^{5}) \\times 0.12 \\times (2 \\times 3)$$\n$$R_{msg} = 8 \\times (5.0 \\times 10^{5}) \\times 0.12 \\times 6$$\n$$R_{msg} = 40.0 \\times 10^{5} \\times 0.12 \\times 6$$\n$$R_{msg} = (4.0 \\times 10^{6}) \\times 0.72$$\n$$R_{msg} = 2.88 \\times 10^{6} \\text{ 消息/秒}$$\n\n第 2 部分：用于减少伪共享的数据布局转换。\n在基于页面的 DSM 系统中，伪共享的根本原因是多个被不同线程访问的独立数据项碰巧位于同一内存页面上。一致性协议以 $P=4096$ 字节的页面为粒度运行，这意味着它无法区分对同一页面内不同字节的写入。一个线程对页面任何部分的写入都会导致系统将整个页面视为已修改，从而触发对拥有该页面缓存副本的其他线程的失效操作，即使这些线程访问的是该页面内完全不同的数据元素。\n\n防止这种情况的一种具体数据布局转换是**数据填充和对齐**。该策略是确保由不同线程独占写入的共享数组的不相交子集被分配在物理上不同的内存页面上。\n\n该转换实现如下：\n假设 $N$ 个线程中的每一个都有一个工作负载，涉及对共享数组的特定、不重叠的分区进行写入，我们必须修改该数组的内存分配。我们不应连续地分配这些分区，而是应将每个分区显式地对齐到页面边界。这意味着每个线程的可写分区的起始地址必须是页面大小 $P = 4096$ 的倍数。\n\n例如，如果线程 0 写入 `data_partition_0`，线程 1 写入 `data_partition_1`，我们应确保 `data_partition_1` 的起始内存地址在 `data_partition_0` 的起始地址之后至少 $P$ 字节，并且其本身在 $P$ 字节边界上对齐。如果 `data_partition_0` 的大小不是 $P$ 的整数倍，则必须在其后插入未使用的内存或“填充”，以强制 `data_partition_1` 从下一个页面边界开始。\n\n这种转换是有效的，因为它将不同线程的写入目标物理上隔离到不同的页面上。当线程 $i$ 写入其数据分区时，它修改的是一个只包含其自身数据的页面。没有其他线程 $j$（其中 $j \\neq i$）会因为自身的写入而有理由缓存这个页面。因此，线程 $i$ 的写入不会触发对线程 $j$ 所需页面的失效操作。这通过确保单个一致性块（一个页面）不包含被多个写入者独立修改的数据，从而直接解决了伪共享的前提。这种布局更改将伪共享概率 $\\phi$ 降低至接近 0，其代价是由于填充而增加了内存消耗。", "answer": "$$\\boxed{2.88 \\times 10^{6}}$$", "id": "3644993"}]}