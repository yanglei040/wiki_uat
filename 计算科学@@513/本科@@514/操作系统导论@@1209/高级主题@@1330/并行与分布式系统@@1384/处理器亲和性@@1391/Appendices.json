{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。作为一名系统性能工程师，您经常面临的一项任务就是诊断并解决延迟问题。本练习模拟了一个真实场景：一个对延迟敏感的服务未能达到其性能目标。您的任务是分析给出的性能计数器，例如CPU利用率和缓存未命中率，来找出性能瓶颈的根源，并决定是应该调整软亲和性策略，还是扩展硬亲和性掩码。这个练习旨在锻炼您基于数据进行决策的能力，并深刻理解CPU饱和与缓存局部性之间的区别。[@problem_id:3672826]", "problem": "一个延迟敏感的远程过程调用 (RPC) 微服务运行在一台具有两个非一致性内存访问 (NUMA) 节点的对称多处理器上。该机器共有 $32$ 个物理核心，平均分配在 NUMA 节点 $0$ 上的 $16$ 个核心和 NUMA 节点 $1$ 上的 $16$ 个核心。该服务被置于一个硬处理器亲和性掩码（硬亲和性）之下，该掩码将其限制在 NUMA 节点 $0$ 上的 $8$ 个逻辑 CPU 上运行。操作系统调度器使用软处理器亲和性（软亲和性）来倾向于使用最近的核心，但可能会为了平衡负载而迁移任务。\n\n您可以调整软亲和性的“粘性”（以减少迁移并增加缓存局部性），或调整硬亲和性掩码（以更改服务可运行的 CPU 集合）。在一个 $\\Delta t = 60$ 秒的观察窗口内，您收集了性能计数器（performance counters (perf)）和服务级别指标：\n\n- 在 $8$ 个允许的 CPU 上，中央处理器 (CPU) 使用率平均为 $92\\%$，其中 $3$ 个 CPU 的繁忙时间超过 $97\\%$，每个允许的 CPU 的平均运行队列长度约为 $1.8$ 个可运行任务。机器上剩余的 $24$ 个 CPU 平均使用率为 $28\\%$。\n- 在允许的集合内，每个请求的平均跨核心迁移次数为 $0.06$；由于硬掩码的限制，跨 NUMA 迁移次数为 $0$。\n- 末级缓存 (LLC) 未命中率很低：中位数为每千条指令 $3$ 次未命中 (MPKI)，第 99 百分位数 ($P_{99}$) 为 $6$ MPKI。\n- 测得服务的第 99 百分位数延迟 $P_{99}$ 为 $15$ 毫秒。服务级别目标是尾延迟目标 $P_{99} \\le X$ 毫秒，其中 $X = 10$ 毫秒。\n\n根据第一性原理，回顾以下几点：\n- 处理器亲和性约束或偏向线程的运行位置。硬亲和性定义了合法的 CPU 集合。软亲和性使调度器偏向于最近使用过的 CPU，以保护缓存局部性。\n- 缓存局部性减少 LLC 未命中；频繁的迁移会增加 LLC 未命中，因为缓存是每个核心独有的。\n- 用排队论的术语来说，当服务器的利用率 $\\rho$ 接近 $1$ 时，等待时间会迅速增长；将工作分配到更多相同的服务器上可以降低每台服务器的 $\\rho$ 并降低尾延迟。\n\n鉴于以上情况，请选择单个最佳的下一步措施，以满足 $P_{99} \\le 10$ 毫秒的目标，同时将性能衰退的风险降至最低。\n\nA. 在保持相同硬掩码的同时，收紧软亲和性（增加粘性）。\n\nB. 扩展硬亲和性掩码，以包含同一 NUMA 节点上更多的空闲 CPU，并保持软亲和性不变。\n\nC. 跨越两个 NUMA 节点扩展硬亲和性掩码，以包含另一个 NUMA 节点上的 CPU。\n\nD. 不做任何改变，并依赖进一步的缓存预热来降低 $P_{99}$。", "solution": "问题要求我们找出单个最佳行动，以将一个远程过程调用 (RPC) 微服务的第 99 百分位数 ($P_{99}$) 延迟从测量的 $15$ 毫秒降低到满足服务级别目标 (SLO) $P_{99} \\le 10$ 毫秒。\n\n首先，我们必须对问题陈述进行严格的验证。\n\n**步骤 1：提取已知条件**\n- 系统架构：对称多处理器，两个非一致性内存访问 (NUMA) 节点。\n- 核心配置：总共 $32$ 个物理核心，$16$ 个在 NUMA 节点 $0$ 上，$16$ 个在 NUMA 节点 $1$ 上。\n- 服务配置：服务受硬处理器亲和性掩码限制，只能在 NUMA 节点 $0$ 上的 $8$ 个逻辑 CPU 上运行。\n- 调度器：操作系统使用软处理器亲和性。\n- 可调参数：软亲和性粘性和硬亲和性掩码。\n- 观察窗口：$\\Delta t = 60$ 秒。\n- 性能指标：\n    - CPU 使用率 (亲和性集合)：在 $8$ 个允许的 CPU 上平均为 $92\\%$；其中 $3$ 个 CPU 的使用率超过 $97\\%$。\n    - 运行队列长度：每个允许的 CPU 平均约有 $1.8$ 个可运行任务。\n    - CPU 使用率 (其他)：剩余的 $24$ 个 CPU 平均使用率为 $28\\%$。\n    - 迁移：在亲和性集合内，每个请求平均有 $0.06$ 次跨核心迁移；跨 NUMA 迁移为 $0$。\n    - 缓存性能：末级缓存 (LLC) 未命中数中位数为每千条指令 $3$ 次 (MPKI)；$P_{99}$ 的 LLC 未命中数为 $6$ MPKI。\n    - 服务延迟：测得的 $P_{99} = 15$ 毫秒。\n    - 延迟目标：$P_{99} \\le X$ 毫秒，其中 $X = 10$ 毫秒。\n- 提供的第一性原理：\n    1.  处理器亲和性：硬亲和性设置允许的 CPU；软亲和性使调度器偏向于最近使用过的 CPU。\n    2.  缓存局部性：迁移会增加 LLC 未命中。\n    3.  排队论：当利用率 $\\rho \\to 1$ 时，等待时间迅速增加。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述具有科学依据，提法恰当且客观。它呈现了一个现代多核、NUMA 系统中的经典性能调优场景。\n- NUMA、处理器亲和性、LLC 未命中、MPKI、运行队列长度和尾延迟等概念在计算机科学和操作系统中都是标准概念。\n- 所提供的数据是一致的，并指向一个合理的性能瓶颈。高 CPU 使用率 ($92\\%$) 与长运行队列 ($1.8 > 1$) 有因果关系，根据排队论，这直接导致等待时间增加，从而导致高尾延迟 ($P_{99}$)。\n- 低 LLC 未命中率 ($3$-$6$ MPKI) 和低迁移率 (每个请求 $0.06$ 次) 一致地表明缓存局部性不是主要问题。\n- 指向 NUMA 节点 $0$ 的硬亲和性掩码正确地解释了为什么跨 NUMA 迁移为 $0$。\n- 问题没有未充分说明之处；有足够的信息来诊断根本原因并评估各个选项。它不是矛盾的、不可行的或微不足道的。\n\n**步骤 3：结论和行动**\n问题陈述是**有效的**。我们可以继续进行解答。\n\n**解答的推导**\n\n主要目标是降低 $P_{99}$ 延迟。我们必须首先通过分析提供的指标来确定当前高延迟的根本原因。\n\n1.  **瓶颈诊断：**\n    最显著的证据是 CPU 争用状态。分配给该服务的 $8$ 个 CPU 的平均使用率为 $92\\%$。其中三个几乎完全饱和（$>97\\%$）。接近 $\\rho = 1$ 的使用率水平是性能瓶颈的强烈指标。每个 CPU 平均 $1.8$ 个任务的运行队列长度证实了这一点。大于 $1$ 的运行队列长度意味着，平均而言，可运行的任务多于可用的 CPU，迫使任务等待。这个等待时间，即*排队延迟*，是请求总响应时间的直接贡献者。尾延迟 ($P_{99}$) 对排队延迟尤其敏感，因为它反映了那些在队列中等待时间最长的“最不幸运”请求的体验。\n\n    相比之下，与内存性能相关的指标是有利的。$3$ MPKI（中位数）和 $6$ MPKI（$P_{99}$）的 LLC 未命中率被描述为低，这对于许多服务器工作负载来说是一个合理的评估。这一点，再加上低跨核心迁移率（每个请求 $0.06$ 次），表明应用程序表现出良好的缓存局部性，并且操作系统的软亲和性是有效的。\n\n    因此，结论很明确：主要瓶颈是**CPU饱和**，而不是缓存性能不佳或内存延迟过高。该服务“缺少”CPU 周期，导致高排队延迟，从而导致高 $P_{99}$ 延迟。\n\n2.  **对建议行动的评估：**\n    最优解决方案必须直接解决 CPU 饱和瓶颈，并以最小的风险引入新问题。\n\n    **A. 在保持相同硬掩码的同时，收紧软亲和性（增加粘性）。**\n    这个行动旨在通过使迁移更加不频繁来改善缓存局部性。然而，数据显示缓存局部性已经很好，并且不是问题的根源。通过增加粘性，这个行动可能会加剧负载不平衡。它会使调度器更难将任务从一个饱和的（$>97\\%$）核心移动到 $8$ 个 CPU 集合中一个稍微软空闲（但仍然过载）的核心。这可能会增加而不是减少最坏情况下的排队延迟。这个选项是错误的，因为它针对的是一个不存在的问题。\n    **结论：不正确。**\n\n    **B. 扩展硬亲和性掩码，以包含同一 NUMA 节点上更多的空闲 CPU，并保持软亲和性不变。**\n    这个行动直接针对问题的根本原因：CPU 饱和。在 NUMA 节点 $0$ 上，总共有 $16$ 个核心，但只有 $8$ 个被该服务使用。这在同一 NUMA 节点上留下了 $16 - 8 = 8$ 个空闲核心。扩展亲和性掩码以包含部分或全部这些核心将允许工作负载分散到更多的处理器上。这将降低每个核心的平均利用率 $\\rho$，使系统脱离 $\\rho \\approx 1$ 的临界区域。根据排队论的原理，利用率的这种降低将导致等待时间的超线性减少，从而直接降低尾延迟。因为新的 CPU 位于*同一个* NUMA 节点上，所以在内存访问延迟方面没有惩罚；所有线程将继续对节点 $0$ 上的内存进行快速的本地访问。这是一个直接、高效且低风险的解决方案。\n    **结论：正确。**\n\n    **C. 跨越两个 NUMA 节点扩展硬亲和性掩码，以包含另一个 NUMA 节点上的 CPU。**\n    和选项 B 一样，这会缓解 CPU 饱和。然而，它引入了一个重大的新风险。服务的内存大概率分配在 NUMA 节点 $0$ 上。如果一个线程被调度到 NUMA 节点 $1$ 的 CPU 上，它的内存访问将变为*远程*访问，需要穿过节点间的互连。远程内存访问的延迟比本地访问高得多，带宽也低得多。这种效应被称为“NUMA 税”，可能会引入一个新的内存访问瓶颈，从而抵消拥有更多 CPU 核心带来的好处，甚至可能增加整体延迟。由于本地 NUMA 节点上还有空闲核心，这种跨 NUMA 扩展是一个不必要且高风险的策略。\n    **结论：不正确。**\n\n    **D. 不做任何改变，并依赖进一步的缓存预热来降低 $P_{99}$。**\n    这个选项基于一个有缺陷的前提。$\\Delta t = 60$ 秒的观察窗口对于一个高流量服务达到“热”缓存稳态来说是绰绰有余的。高 CPU 使用率（$92\\%$）和长运行队列（$1.8$）这些关键指标表明存在结构性的资源短缺，而不是短暂的预热效应。低 LLC 未命中率进一步证实了缓存性能良好。等待无法解决工作负载需求与配置的 CPU 资源之间的根本性不匹配问题。\n    **结论：不正确。**\n\n基于此分析，唯一正确识别并以最小风险解决 CPU 饱和瓶颈的选项是在本地 NUMA 节点上扩展 CPU 集合。", "answer": "$$\\boxed{B}$$", "id": "3672826"}, {"introduction": "在解决了系统级的瓶颈之后，让我们深入到CPU核心的微架构层面。处理器亲和性设置可能与底层的硬件特性（如对称多线程，即SMT）产生意想不到的交互作用。本练习提出了一个由于硬亲和性配置错误而意外禁用了某些SMT线程的场景。您的任务是基于指令每周期数（$\\text{IPC}$）的变化来量化这种配置错误导致的吞吐量下降。通过这个计算，您将学会如何评估亲和性设置对处理器微架构利用率的影响，并理解为何看似微小的配置变更也可能导致显著的性能差异。[@problem_id:3672757]", "problem": "一个计算密集型微基准测试被用于测量处理器亲和性在一台运行类 Linux 调度器的工作站上的效果。该机器支持对称多线程（SMT），每个物理核心有两个硬件线程。该处理器有 $12$ 个物理核心（总共 $24$ 个逻辑处理器），所有核心都以固定频率 $f = 3.2 \\times 10^{9}$ 周期/秒 运行。工作负载生成 $24$ 个相同的线程，每个线程在紧密循环中执行算术指令，因此每周期指令数（$\\text{IPC}$）主导了吞吐量。在完全 SMT 利用率下（一个核心上的两个硬件线程都处于活动状态），由于兄弟线程之间的资源共享，每个线程的平均 $\\text{IPC}$ 为 $1.15$。当一个核心只运行单个硬件线程时（其兄弟线程空闲或被禁用），该线程的平均 $\\text{IPC}$ 上升到 $1.75$。\n\n测试了两种亲和性配置：\n\n- 软亲和性：线程表达其偏好的核心，但调度器可以自由迁移它们以平衡负载；实际上，所有 $24$ 个逻辑处理器都被同时利用，所有线程都以 $\\text{IPC} = 1.15$ 运行。\n- 硬亲和性：线程使用严格的掩码进行固定，这无意中排除了 $12$ 个核心中 $7$ 个核心的第二个硬件线程。因此，$7$ 个核心只运行一个线程（每个线程的 $\\text{IPC} = 1.75$），而剩下的 $5$ 个核心则运行两个硬件线程（每个线程的 $\\text{IPC} = 1.15$）。被掩码排除的线程不运行。\n\n假设使用广泛应用的吞吐量近似公式 $T \\approx f \\times \\text{IPC} \\times \\text{active\\_threads}$，其中 $T$ 是所有运行线程的总和指令/秒，而 $\\text{active\\_threads}$ 是并发调度的线程数。没有其他瓶颈（例如，内存带宽和输入/输出不受限制），并且频率 $f$ 在所有核心上都相同，且不随负载变化。\n\n仅使用以上信息以及调度和 SMT 争用的基本原理，计算由硬亲和性掩码引起的绝对吞吐量下降 $\\Delta T$（基线减去错误配置）。以吉指令/秒（GIPS）为单位表示你的答案，并将最终数值四舍五入到四位有效数字。", "solution": "问题陈述经过严格验证，被确定为有效。它在科学上基于计算机体系结构和操作系统的原理，特别是关于对称多线程（SMT）、每周期指令数（IPC）和处理器亲和性。所有提供的数据都是一致、充分且物理上合理的，构成了一个适定问题，该问题允许唯一且有意义的解。\n\n解决这个问题的基本原理是，多核处理器的总指令吞吐量是其所有并发活动硬件线程的指令吞吐量之和。单个线程的吞吐量 $T_{thread}$ 是处理器频率 $f$ 与该线程实现的每周期指令数 $\\text{IPC}$ 的乘积。\n$$\nT_{thread} = f \\times \\text{IPC}\n$$\n因此，总系统吞吐量 $T_{system}$ 是各个线程吞吐量的总和：\n$$\nT_{system} = \\sum_{i=1}^{N_{active\\_threads}} T_{thread,i} = f \\times \\sum_{i=1}^{N_{active\\_threads}} \\text{IPC}_i\n$$\n这是对问题中给出的近似公式 $T \\approx f \\times \\text{IPC} \\times \\text{active\\_threads}$ 的更精确表述，尤其是在 IPC 在所有线程中不均匀的情况下。\n\n我们已知以下值：\n- 处理器频率, $f = 3.2 \\times 10^{9}$ 周期/秒。\n- 当兄弟线程激活时（SMT开启）的线程IPC：$\\text{IPC}_{SMT} = 1.15$。\n- 当兄弟线程空闲时（SMT关闭）的线程IPC：$\\text{IPC}_{single} = 1.75$。\n- 物理核心总数：$N_{cores} = 12$。\n\n我们首先计算软亲和性配置的基线吞吐量，记为 $T_{soft}$。在这种情况下，所有 $12$ 个核心都被完全利用，每个核心有两个线程，总共有 $N_{soft} = 12 \\times 2 = 24$ 个活动线程。这些线程中的每一个都经历 SMT 争用，因此它们的 IPC 统一为 $\\text{IPC}_{SMT}$。\n$$\nT_{soft} = N_{soft} \\times (f \\times \\text{IPC}_{SMT})\n$$\n$$\nT_{soft} = 24 \\times f \\times 1.15 = 27.6 \\times f\n$$\n\n接下来，我们计算配置错误的硬亲和性情况下的吞吐量，记为 $T_{hard}$。处理器核心被分为两组。\n第1组由 $N_{cores,1} = 7$ 个核心组成，每个核心只运行一个线程。该组中的线程总数为 $N_{threads,1} = 7 \\times 1 = 7$。由于这些线程在没有兄弟线程的情况下运行，它们的 IPC 是 $\\text{IPC}_{single}$。该组的总吞吐量 $T_1$ 是：\n$$\nT_1 = N_{threads,1} \\times (f \\times \\text{IPC}_{single}) = 7 \\times f \\times 1.75 = 12.25 \\times f\n$$\n第2组由剩下的 $N_{cores,2} = 12 - 7 = 5$ 个核心组成。这些核心运行两个硬件线程，总共有 $N_{threads,2} = 5 \\times 2 = 10$ 个线程。这些线程经历 SMT 争用，因此它们的 IPC 是 $\\text{IPC}_{SMT}$。该组的总吞吐量 $T_2$ 是：\n$$\nT_2 = N_{threads,2} \\times (f \\times \\text{IPC}_{SMT}) = 10 \\times f \\times 1.15 = 11.5 \\times f\n$$\n硬亲和性配置下的总吞吐量是两组吞吐量之和。\n$$\nT_{hard} = T_1 + T_2 = 12.25 \\times f + 11.5 \\times f = 23.75 \\times f\n$$\n请注意，在此配置中，只有 $N_{hard} = N_{threads,1} + N_{threads,2} = 7 + 10 = 17$ 个线程处于活动状态，因为其他线程被亲和性掩码排除了。\n\n问题要求计算绝对吞吐量下降 $\\Delta T$，即基线吞吐量与错误配置吞吐量之间的差值。\n$$\n\\Delta T = T_{soft} - T_{hard}\n$$\n$$\n\\Delta T = 27.6 \\times f - 23.75 \\times f = (27.6 - 23.75) \\times f\n$$\n$$\n\\Delta T = 3.85 \\times f\n$$\n\n现在，我们代入频率 $f$ 的数值。\n$$\nf = 3.2 \\times 10^{9} \\text{ 周期/秒}\n$$\n$$\n\\Delta T = 3.85 \\times (3.2 \\times 10^{9} \\text{ 周期/秒}) = 12.32 \\times 10^{9} \\text{ 指令/秒}\n$$\n问题要求答案以吉指令/秒（GIPS）为单位，其中 $1 \\text{ GIPS} = 10^{9}$ 指令/秒。\n$$\n\\Delta T = 12.32 \\text{ GIPS}\n$$\n问题要求将结果四舍五入到四位有效数字。计算出的值 $12.32$ 已经恰好是四位有效数字，因此无需进一步四舍五入。", "answer": "$$\\boxed{12.32}$$", "id": "3672757"}, {"introduction": "实践的最后一部分将带您从具体的诊断和计算，转向更抽象的理论建模。理解硬亲和性与软亲和性之间的权衡是掌握处理器亲和性概念的关键。本练习将引导您使用排队论（一种强大的性能分析数学工具）来为这一权衡建立一个精确的模型。您将为一个多级流水线工作负载推导出一个封闭形式的解析表达式，用以比较软亲和性和硬亲和性下的平均端到端延迟。这个练习不仅能巩固您对亲和性基本原理的理解，还能展示如何运用数学模型来严谨地推理复杂系统的性能行为。[@problem_id:3672755]", "problem": "一个多核系统以一个包含 $P$ 个阶段的流水线形式执行一个流式工作负载。每个阶段 $i \\in \\{1,2,\\dots,P\\}$ 从一个生产者-消费者队列中读取输入，执行计算，并将其结果入队到下一阶段的队列中。第一阶段的外部到达过程被建模为速率为 $\\lambda$ 的泊松过程。假设每个阶段的队列在稳态下可以近似为一个马尔可夫到达、马尔可夫服务、单服务器（M/M/1）队列。\n\n在硬处理器亲和性下，每个阶段 $i$ 被固定到一个中央处理器（CPU）核心上，该核心在缓存中保留其工作集，从而产生一个有效指数服务速率 $\\mu_i^{\\mathrm{H}} = \\gamma_i \\mu_i$，其中 $\\gamma_i \\geq 1$ 且基准速率 $\\mu_i > 0$。在软处理器亲和性下，由阶段 $i$ 执行的每个任务可能在连续激活之间以概率 $q_i \\in [0,1)$ 跨核心迁移；在发生迁移的激活上，冷缓存效应会通过一个惩罚因子 $\\beta_i \\in (0,1)$ 来缩放基准速率，因此该次激活的服务速率为 $\\beta_i \\mu_i$，否则为 $\\mu_i$。为了在软亲和性下进行 M/M/1 近似，我们将阶段 $i$ 的服务时间分布建模为一个单一指数分布，其速率等于其平均服务时间的倒数，\n$$\n\\mu_i^{\\mathrm{S}} = \\left( (1 - q_i)\\frac{1}{\\mu_i} + q_i \\frac{1}{\\beta_i \\mu_i} \\right)^{-1}.\n$$\n\n假设两种策略下系统都是稳定的，即 $\\lambda  \\min_{i} \\{\\mu_i^{\\mathrm{H}}\\}$ 且 $\\lambda  \\min_{i} \\{\\mu_i^{\\mathrm{S}}\\}$，并且 M/M/1 的离开过程结果（Burke 定理）成立，因此在稳态下，每个阶段的到达过程都是速率为 $\\lambda$ 的泊松过程。\n\n仅使用 M/M/1 系统的基本排队论结果和上述定义，推导软亲和性下的端到端流水线平均延迟与硬亲和性下的端到端流水线平均延迟之比 $R$ 的闭式解析表达式，\n$$\nR \\equiv \\frac{\\mathbb{E}[T_{\\mathrm{soft}}]}{\\mathbb{E}[T_{\\mathrm{hard}}]},\n$$\n该表达式应是关于 $i=1,\\dots,P$ 的 $\\lambda$、$\\mu_i$、$\\gamma_i$、$q_i$ 和 $\\beta_i$ 的函数。你的最终答案必须是单一的闭式解析表达式。无需进行数值计算。", "solution": "此题的目标是推导在软亲和性与硬亲和性策略下，一个软件流水线的端到端平均延迟之比 $R = \\frac{\\mathbb{E}[T_{\\mathrm{soft}}]}{\\mathbb{E}[T_{\\mathrm{hard}}]}$。\n\n我们使用的基本原理是期望的线性性，它允许我们将流水线的总平均延迟视为每个独立阶段平均延迟的总和。\n$$\n\\mathbb{E}[T_{\\text{total}}] = \\sum_{i=1}^{P} \\mathbb{E}[T_i]\n$$\n其中 $\\mathbb{E}[T_i]$ 是第 $i$ 阶段的平均延迟（即逗留时间）。\n\n根据题意，每个阶段都可近似为一个M/M/1排队模型。对于一个到达率为 $\\lambda'$、服务速率为 $\\mu'$ 的M/M/1队列，其平均逗留时间为：\n$$\n\\mathbb{E}[T] = \\frac{1}{\\mu' - \\lambda'}\n$$\n由于Burke定理成立，每个阶段的到达过程都是速率为 $\\lambda$ 的泊松过程。\n\n**1. 硬亲和性下的延迟 ($\\mathbb{E}[T_{\\mathrm{hard}}$])**\n\n在硬亲和性策略下，第 $i$ 阶段的服务速率是固定的 $\\mu_i^{\\mathrm{H}} = \\gamma_i \\mu_i$。将此代入M/M/1延迟公式：\n$$\n\\mathbb{E}[T_{i, \\mathrm{hard}}] = \\frac{1}{\\mu_i^{\\mathrm{H}} - \\lambda} = \\frac{1}{\\gamma_i \\mu_i - \\lambda}\n$$\n总平均延迟是所有 $P$ 个阶段延迟之和：\n$$\n\\mathbb{E}[T_{\\mathrm{hard}}] = \\sum_{i=1}^{P} \\frac{1}{\\gamma_i \\mu_i - \\lambda}\n$$\n\n**2. 软亲和性下的延迟 ($\\mathbb{E}[T_{\\mathrm{soft}}$])**\n\n在软亲和性策略下，服务速率是一个有效平均值。题目给出了有效服务速率 $\\mu_i^{\\mathrm{S}}$ 的表达式，它源于平均服务时间：\n$$\n\\mu_i^{\\mathrm{S}} = \\left( (1 - q_i)\\frac{1}{\\mu_i} + q_i \\frac{1}{\\beta_i \\mu_i} \\right)^{-1}\n$$\n我们首先简化这个表达式。其倒数为平均服务时间：\n$$\n\\frac{1}{\\mu_i^{\\mathrm{S}}} = \\frac{1 - q_i}{\\mu_i} + \\frac{q_i}{\\beta_i \\mu_i} = \\frac{\\beta_i(1 - q_i) + q_i}{\\beta_i \\mu_i}\n$$\n因此，有效服务速率为：\n$$\n\\mu_i^{\\mathrm{S}} = \\frac{\\beta_i \\mu_i}{\\beta_i + q_i(1 - \\beta_i)}\n$$\n现在，我们将这个有效服务速率代入M/M/1延迟公式：\n$$\n\\mathbb{E}[T_{i, \\mathrm{soft}}] = \\frac{1}{\\mu_i^{\\mathrm{S}} - \\lambda} = \\frac{1}{\\frac{\\beta_i \\mu_i}{\\beta_i + q_i(1 - \\beta_i)} - \\lambda}\n$$\n总平均延迟为所有阶段延迟之和：\n$$\n\\mathbb{E}[T_{\\mathrm{soft}}] = \\sum_{i=1}^{P} \\frac{1}{\\frac{\\beta_i \\mu_i}{\\beta_i + q_i(1 - \\beta_i)} - \\lambda}\n$$\n\n**3. 延迟比率 $R$**\n\n最后，我们构建比率 $R$：\n$$\nR = \\frac{\\mathbb{E}[T_{\\mathrm{soft}}]}{\\mathbb{E}[T_{\\mathrm{hard}}]} = \\frac{\\sum_{i=1}^{P} \\frac{1}{\\frac{\\beta_i \\mu_i}{\\beta_i + q_i(1 - \\beta_i)} - \\lambda}}{\\sum_{i=1}^{P} \\frac{1}{\\gamma_i \\mu_i - \\lambda}}\n$$\n为了使表达式更清晰，我们可以化简分子求和中的项：\n$$\n\\frac{1}{\\frac{\\beta_i \\mu_i}{\\beta_i + q_i(1 - \\beta_i)} - \\lambda} = \\frac{1}{\\frac{\\beta_i \\mu_i - \\lambda(\\beta_i + q_i(1 - \\beta_i))}{\\beta_i + q_i(1 - \\beta_i)}} = \\frac{\\beta_i + q_i(1 - \\beta_i)}{\\beta_i \\mu_i - \\lambda(\\beta_i + q_i(1 - \\beta_i))}\n$$\n将此化简结果代回，我们得到最终的闭式表达式。", "answer": "$$\n\\boxed{\n\\frac{\\sum_{i=1}^{P} \\frac{\\beta_i + q_i(1 - \\beta_i)}{\\beta_i \\mu_i - \\lambda(\\beta_i + q_i(1 - \\beta_i))}}{\\sum_{i=1}^{P} \\frac{1}{\\gamma_i \\mu_i - \\lambda}}\n}\n$$", "id": "3672755"}]}