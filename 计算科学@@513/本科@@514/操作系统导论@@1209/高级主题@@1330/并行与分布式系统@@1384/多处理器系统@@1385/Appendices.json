{"hands_on_practices": [{"introduction": "在设计并发服务器时，一个常见的挑战是如何确定最佳的线程池大小。线程太少会导致宝贵的CPU核心处于空闲状态，而线程太多又会因过度的上下文切换而产生巨大开销。这个练习提供了一个实用的指导法则，帮助你找到一个“最佳点”，将核心数量、线程池大小与工作负载的I/O阻塞特性联系起来，从而在最大化吞吐量和控制系统开销之间取得平衡。[@problem_id:3661557]", "problem": "一台服务器运行在一台拥有 $N$ 个硬件核心的多核机器上。它使用一个大小为 $P$ 的固定大小线程池来处理稳定的同质任务流。每个线程在中央处理器（CPU）上执行和等待输入/输出（I/O）之间重复交替。在任何调度时刻，一个线程被阻塞（等待I/O）的概率为 $p_b$，且与其他线程无关，而可运行的概率为 $1 - p_b$。操作系统采用循环（round-robin）调度器：当多个可运行线程竞争一个给定的核心时，调度器会为该核心上的每个可运行线程分配一个长度为 $q$ 的时间片，并在每个时间片结束时执行一次成本为 $c$ 的上下文切换（当一个正在运行的线程在其时间片完成前阻塞时也会发生）。\n\n你希望设计一个调优测试，通过改变 $P$ 来最大化吞吐量，同时控制上下文切换的开销。对于每个 $P$，你将在持续的工作负载下测量两个指标：(i) 总吞吐量（单位时间内完成的CPU段）和 (ii) 每秒的上下文切换次数。你的目标是选择一个 $P$，使得可运行线程的期望数量接近核心数，以避免核心空闲，但又不能太大，以至于循环抢占和频繁阻塞导致过度的上下文切换开销。\n\n哪个选项最好地描述了你在选择 $P$ 时应应用的规则及其背后的基本原理？\n\nA. 设置 $P = N$，因为任何更大的 $P$ 只会增加上下文切换而不会提高吞吐量；当 $q$ 固定时，阻塞概率 $p_b$ 对理想的 $P$ 没有影响。\n\nB. 设置 $P \\approx \\left\\lceil \\dfrac{N}{1 - p_b} \\right\\rceil$，因为可运行线程的期望数量 $\\mathbb{E}[R] = P (1 - p_b)$ 应该接近 $N$：如果 $\\mathbb{E}[R]  N$，一些核心会空闲，吞吐量会下降；如果 $\\mathbb{E}[R] \\gg N$，循环抢占会确保每个核心的上下文切换开销约为 $c / q$，从而降低每个核心的有效CPU时间。\n\nC. 设置 $P \\approx N (1 - p_b)$，因为阻塞减少了有效的CPU需求；线程池大小应与 $1 - p_b$ 成比例减少，以最小化上下文切换开销。\n\nD. 设置 $P \\gg N$（例如 $P = 10 N$），因为激进的超额订阅可以隐藏I/O停顿；当 $q$ 固定时，保持核心繁忙所带来的吞吐量增益总是超过上下文切换开销 $c$。\n\nE. 设置 $P \\approx \\left\\lfloor \\dfrac{N}{1 + p_b} \\right\\rfloor$，因为在分母中将 $p_b$ 加到 $1$ 上考虑了阻塞，并减少了由抢占引起的上下文切换，同时保持了核心的完全利用。", "solution": "### 解决方案推导\n\n**1. 建立模型**\n\n系统的目标是在拥有 $N$ 个核心的情况下最大化吞吐量。吞吐量最大化约等于保持所有 $N$ 个核心持续忙于有用的工作。\n\n- 系统有 $P$ 个线程。\n- 每个线程可运行的概率是 $1 - p_b$。\n- 每个线程被阻塞（等待I/O）的概率是 $p_b$。\n\n设 $R$ 为在任意时刻可运行的线程数量。由于每个线程的阻塞状态是独立的，可运行线程的期望数量（平均数量）为：\n$$\\mathbb{E}[R] = P \\times (1 - p_b)$$\n\n**2. 分析核心利用率与开销**\n\n为了使所有 $N$ 个核心都保持繁忙，系统平均需要至少有 $N$ 个可运行的线程。这引出了核心的权衡：\n\n- **订阅不足 (Under-subscription)**: 如果可运行线程的期望数量远小于核心数（$\\mathbb{E}[R] \\ll N$），那么在任何时刻，都很有可能存在空闲的核心。这将导致CPU资源浪费，系统吞吐量无法达到最大。\n\n- **超额订阅 (Over-subscription)**: 如果可运行线程的期望数量远大于核心数（$\\mathbb{E}[R] \\gg N$），那么每个核心都会有多个可运行线程在排队等待。这虽然保证了核心不会空闲，但会带来额外的开销：\n    - **上下文切换**：调度器需要在排队的线程之间频繁切换，每次切换都有成本 $c$。\n    - **资源竞争**：过多的线程会增加对内存、锁等其他资源的竞争。\n\n**3. 寻找最优平衡点**\n\n理想的平衡点是，我们有恰好足够的可运行线程来占满所有核心，而又不会产生过度的排队和开销。因此，最优策略是将可运行线程的*期望*数量设置为等于核心数量：\n$$\\mathbb{E}[R] \\approx N$$\n\n将 $\\mathbb{E}[R]$ 的表达式代入，我们得到：\n$$P (1 - p_b) \\approx N$$\n\n求解线程池大小 $P$：\n$$P \\approx \\frac{N}{1 - p_b}$$\n\n由于线程数必须是整数，且为了应对概率波动（即避免偶尔因可运行线程数低于 $N$ 而导致核心空闲），通常会向上取整。因此，一个稳健的经验法则是：\n$$P \\approx \\left\\lceil \\frac{N}{1 - p_b} \\right\\rceil$$\n\n这个公式直观地反映了：如果线程是计算密集型的（$p_b \\to 0$），那么 $P \\approx N$；如果线程有50%的时间在阻塞（$p_b = 0.5$），那么我们需要两倍于核心数的线程（$P \\approx 2N$）来保证平均有 $N$ 个线程可运行。\n\n**4. 评估选项**\n\n- **A.** 错误。它忽略了阻塞概率 $p_b$。如果线程会阻塞，设置 $P = N$ 将导致核心利用不足。\n- **B.** 正确。它使用了我们推导出的公式，并且其背后的原理描述完全正确：它在避免核心空闲（订阅不足）和控制上下文切换开销（超额订阅）之间取得了平衡。\n- **C.** 错误。该公式会导致严重的订阅不足。阻塞意味着我们需要*更多*的线程来补偿，而不是更少。\n- **D.** 错误。它忽略了超额订阅的成本。当 $P$ 过大时，上下文切换和资源竞争的开销会超过保持核心繁忙带来的收益，甚至可能导致吞吐量下降。\n- **E.** 错误。该公式在数学上是不正确的，同样会导致核心利用不足。\n\n因此，选项B提供了正确的规则和原理。", "answer": "$$\\boxed{B}$$", "id": "3661557"}, {"introduction": "在多处理器编程中，一个诡异的性能陷阱是“伪共享”（false sharing）。即使多个线程访问的是完全不同的数据，但如果这些数据恰好位于同一个缓存行（cache line）中，硬件缓存一致性协议就会导致严重的性能下降。本练习将指导你设计一个微基准测试来精确地暴露这一现象，并展示如何通过调整数据布局（如填充）来解决这个隐藏的性能杀手。[@problem_id:3661589]", "problem": "一个包含 $M$ 个元素的数组，每个元素大小为 $b$ 字节，由运行在多核处理器上的 $N$ 个线程共享。每个核心拥有私有的L1和L2缓存以及一个共享的末级缓存，缓存一致性通过修改、独占、共享、无效（MESI）协议来维护。缓存行大小为 $L$ 字节。操作系统调度器可能会在核心之间迁移线程，除非通过处理器亲和性（绑定）来阻止。提出了一个吞吐量实验，其中每个线程 $t \\in \\{0, 1, \\dots, N-1\\}$ 对一个指定的数组元素重复执行非原子性增量操作，该元素的索引是步长参数 $s$ 的函数；步长 $s$ 将在一组整数值上变化，以观察吞吐量骤降现象。吞吐量以单位时间内的总增量次数来衡量。\n\n仅使用以下基本事实：\n- 根据一致性协议，一个核心对缓存行中某个地址的写入，会强制其他核心对该行的副本转换为无效状态，即使这些核心写入的是同一行内的不同字。\n- 当多个核心频繁写入同一缓存行内的不同字时，一致性流量（“乒乓效应”）会占主导地位，尽管没有真正的数据依赖（伪共享），但仍会降低吞吐量。\n- 绑定线程可以防止调度器迁移，否则迁移会引入额外的噪声和混淆的缓存行为。\n- 通过填充或对齐数据，使并发写入的字占据不同的缓存行，可以减少一致性冲突。\n\n选择最能严谨地指定一个实验以揭示伪共享的选项，该选项通过改变 $s$ 来实现此目的，并提出操作系统调度器策略和数据布局策略，以专门缓解由伪共享引起的吞吐量骤降，同时控制其他混淆因素（如非一致性内存访问（NUMA）效应和线程迁移）。假设 $N$ 至少为 $4$，$L$ 是一个典型的缓存行大小（例如 $L = 64$ 字节），$b$ 对应一个 $64$ 位整数（例如 $b = 8$ 字节）。如果需要，数组的基地址可以对齐。\n\nA. 将每个线程绑定到同一插槽上的一个独立物理核心。将数组的基地址与缓存行边界对齐。分配线程 $t$ 在固定时间内持续更新索引 $i_t = t \\cdot s$，并对 $s$ 进行扫描，取值如 $s \\in \\{1, 2, 4, 8, 16, 32\\}$。记录每秒的总增量次数。为缓解吞吐量骤降，引入每个线程 $p$ 个元素的填充，使每个线程的槽位索引变为 $i_t = t \\cdot (s + p)$，其中 $p$ 取满足 $p \\cdot b \\geq L$ 的最小值，并保持线程绑定以防止迁移。\n\nB. 允许操作系统自由调度和迁移线程。对于每个 $s$，分配每个线程 $t$ 以概率性跳过步长 $s$ 的方式，在 $\\{0, 1, \\dots, M-1\\}$ 中均匀地更新随机索引。测量吞吐量。为缓解吞吐量骤降，增加线程数量并启用同步多线程（SMT）来隐藏内存延迟。\n\nC. 在具有非一致性内存访问（NUMA）的双插槽系统中，将一半线程绑定到插槽0的核心，另一半绑定到插槽1的核心。分配线程 $t$ 更新索引 $i_t = t \\cdot s$，并对 $s$ 取较大值进行扫描，例如 $s \\geq M/N$，确保线程更新的元素间隔很远。为缓解吞吐量骤降，跨NUMA节点交错分配内存，并依赖硬件预取器。\n\nD. 将所有线程绑定到单个核心以最大化缓存重用。分配线程 $t$ 更新索引 $i_t = t \\cdot s$ 并改变 $s$。为缓解吞吐量骤降，使用页表属性禁用缓存，并完全依赖主内存访问以避免一致性交互。\n\nE. 将每个线程绑定到同一插槽上的一个独立物理核心。不刻意对齐数组基地址。分配线程 $t$ 更新索引 $i_t = t \\cdot s$，并对 $s$ 取值 $\\{1, 2, 3, 5, 7, 9\\}$ 进行变化。为缓解吞吐量骤降，启用积极的编译器向量化和硬件预取，而不改变数据布局。", "solution": "### 解决方案推导\n\n**1. 理解伪共享**\n\n伪共享（False Sharing）是多处理器系统中的一个性能陷阱。当多个处理器核心上的不同线程，虽然在逻辑上访问和修改的是独立的变量，但这些变量在物理内存中恰好位于同一个缓存行（Cache Line）时，就会发生伪共享。\n\n根据MESI等缓存一致性协议，当一个核心写入缓存行中的任何部分时，该缓存行在其他所有核心的缓存中都必须被标记为“无效”（Invalid）。这导致其他核心下次访问该行时（即使是访问该行内完全不同的数据），会发生缓存未命中，并需要从持有“已修改”（Modified）副本的核心那里重新获取整个缓存行。这种在核心之间来回传递缓存行的现象被称为“乒乓效应”，它会产生大量的总线流量和延迟，严重降低性能，尽管线程之间并无真正的数据共享。\n\n**2. 设计揭示伪共享的实验**\n\n一个严谨的实验必须满足以下条件：\n- **控制变量**：为了清晰地观察伪共享，必须消除其他可能影响性能的混淆因素。\n    - **线程迁移**：操作系统可能在核心之间迁移线程，这会带来额外的缓存开销并使结果变得嘈杂。因此，应将每个线程**绑定（pinning）**到一个固定的物理核心上。\n    - **NUMA效应**：在多插槽（multi-socket）系统中，跨NUMA节点的内存访问延迟远高于本地访问。为了专门研究缓存一致性，所有线程和数据应位于同一个NUMA节点（即同一个插槽）上。\n    - **内存对齐**：为了使数据元素到缓存行的映射关系可预测，数组的基地址应与缓存行边界对齐。\n\n- **触发与避免伪共享**：实验需要系统地改变数据布局，以展示伪共享发生和不发生时的性能差异。\n    - 在本实验中，线程 $t$ 访问索引为 $i_t = t \\cdot s$ 的元素。相邻线程 $t$ 和 $t+1$ 访问的数据地址相隔 $s \\cdot b$ 字节。\n    - 伪共享是否发生取决于这个距离与缓存行大小 $L$ 的关系。\n        - **当 $s \\cdot b  L$ 时**：相邻线程访问的元素很可能位于同一个缓存行内，导致严重的伪共享。\n        - **当 $s \\cdot b \\geq L$ 时**：相邻线程访问的元素保证位于不同的缓存行中（假设已对齐），伪共享现象消失。\n    - 因此，通过扫描步长 $s$ 的值，并跨越临界点 $L/b$（在本例中为 $64/8=8$），我们可以观察到吞吐量的急剧变化。\n\n**3. 评估选项**\n\n- **A.** 此选项的设计完全符合上述原则。它将线程绑定到同一插槽上的不同核心，对齐了数组，并系统地扫描了步长 $s$（$1, 2, 4, 8, 16, 32$），这恰好能跨越 $s=8$ 的临界点，完美地揭示了伪共享现象。其缓解策略——通过填充（padding）来增加元素间的有效步长，确保并发访问的数据位于不同缓存行——直接解决了问题的根本原因。\n\n- **B.** 此选项存在严重缺陷。允许线程自由迁移并使用随机访问模式会引入大量噪声，完全掩盖了由步长 $s$ 决定的系统性伪共享效应。其缓解策略（SMT和增加线程）也与解决伪共享无关。\n\n- **C.** 此选项故意引入了NUMA效应作为混淆因素，而不是控制它。此外，它只扫描较大的 $s$ 值，这恰恰避免了伪共享发生的条件，因此无法揭示该现象。\n\n- **D.** 将所有线程绑定到单个核心消除了多核并行性，因此也就无法研究核心间的伪共享问题。禁用缓存的“缓解策略”更是荒谬的，它会使性能下降几个数量级。\n\n- **E.** 此选项的实验设计较弱，因为它没有对齐数组基地址，导致结果不可靠。其缓解策略（向量化和预取）对解决线程间的写争用问题（伪共享的核心）无效。\n\n**结论**：选项A提供了最严谨、最科学的实验设计来隔离、测量和缓解伪共享。", "answer": "$$\\boxed{A}$$", "id": "3661589"}, {"introduction": "在多处理器系统中，确保公平性和响应性至关重要，尤其是在处理具有不同优先级的任务时。当高优先级线程需要等待低优先级线程释放锁时，就会发生“优先级反转”，严重时甚至可能导致高优先级任务“饿死”（starvation）。这个练习构建了一个这样的场景，并要求你评估更高级的内核级机制，如协作式抢占点和优先级感知的锁，以从根本上解决这个问题，保证系统的公平性和可预测性。[@problem_id:3661484]", "problem": "考虑一个多核操作系统，其拥有 $N$ 个相同的核心，并运行一个全局固定优先级、抢占式调度器。抢占在全局范围内启用，但在某些临界区内除外。在这些临界区中，线程在获取用于保护内核数据结构的共享锁时会禁用抢占。该锁是一个简单的测试并设置自旋锁，没有公平性保证。以下定义构成了推理的基础：\n\n- 互斥（Mutual exclusion）确保在任何时候最多只有一个线程持有锁。\n- 前进（Progress）要求如果一个或多个线程希望进入临界区，则某个线程必须能取得进展。\n- 有界等待（Bounded waiting）保证每个请求锁的线程最终都能在有限的时间内获得锁，该时间界限不依赖于其他线程的无界行为。\n- 饥饿（Starvation）发生在由于竞争或调度决策导致线程的等待时间无界时。\n- 优先级反转（Priority inversion）发生在高优先级线程等待一个持有资源的低优先级线程时。\n\n该系统有 $N = 4$ 个核心和两类线程：\n- $H = 2$ 个高优先级线程 $\\{H_1, H_2\\}$，它们周期性地进入一个持续时间为 $C_H = 10\\,\\mu s$ 的临界区，周期为 $P_H = 5\\,ms$。\n- $L = 6$ 个低优先级线程 $\\{L_1,\\dots,L_6\\}$，它们重复进入同一个临界区，持续时间为 $C_L = 200\\,\\mu s$，在释放锁和重新获取锁之间有持续时间为 $W_L = 50\\,\\mu s$ 的非临界区工作。\n\n假设自旋锁具有高度的缓存局部性：释放锁的线程所在的核心会短暂保留锁的缓存行，这使其在释放锁后立即重新获取锁时具有概率优势。在临界区内抢占是禁用的，因此锁的持有者在退出临界区并重新启用抢占之前，不会被非自愿地调度出去。在持续负载下，三个核心运行低优先级线程，这些线程循环执行临界区和非临界区工作。第四个核心在就绪时调度高优先级线程。\n\n根据经验观察，一个到达并竞争锁的高优先级线程 $H_i$ 可能会被无限期地饿死，因为其他核心上的低优先级线程由于缓存局部性偏差而重复重新获取锁。由于在临界区内抢占是禁用的，调度器无法抢占一个持有锁的低优先级线程，因此，无论是互斥还是前进原则，都不能保证 $H_i$ 的有界等待。\n\n您的任务是选择一种设计变更，既能防止高优先级线程的饥饿，又能为其进入临界区的最坏情况等待时间得出一个可证明的、紧凑的上限，且该上限与 $L$ 和 $C_L$ 无关。请考虑以下候选设计和参数：\n\n- 候选方案 A：在临界区内以至多 $\\tau = 50\\,\\mu s$ 的间隔插入协作式抢占点。在抢占点，锁持有者检查一个内核标志，该标志指示是否存在任何更高优先级的等待者。如果存在这样的等待者，持有者会执行一次安全的交接：它完成当前保持不变量的微观步骤，释放锁，并直接将所有权转移给最高优先级的等待者。锁被替换为一个优先级感知的队列锁，该锁按优先级降序排列等待者并实现优先级继承（PI）：低优先级的持有者在持有锁期间继承等待者中的最高优先级。交接开销为 $\\delta = 5\\,\\mu s$。\n- 候选方案 B：在临界区内保持抢占禁用，但将锁替换为仅对低优先级线程增加指数退避的测试并设置自旋锁；高优先级线程不使用退避。\n- 候选方案 C：全局启用抢占，包括在临界区内。保留非公平的测试并设置自旋锁，并依赖调度器在需要时中断长的临界区。\n- 候选方案 D：在临界区内保持抢占禁用，但将锁替换为先进先出（FIFO）票据锁。没有实现优先级感知的排序或优先级继承。\n\n哪个候选方案能同时确保（i）在所述负载和缓存局部性偏差下高优先级线程的无饥饿，以及（ii）高优先级线程进入临界区的最坏情况等待时间上限与 $L$ 和 $C_L$ 无关？对于选定的候选方案，请用给定的参数表述该上限，并从基本原理（互斥、前进、有界等待和优先级反转控制）出发，简要论证该上限为何成立。选择最佳答案。\n\nA. 候选方案 A。\n\nB. 候选方案 B。\n\nC. 候选方案 C。\n\nD. 候选方案 D。", "solution": "### 解决方案推导\n\n**1. 问题分析：高优先级线程为何会“饿死”？**\n\n问题描述的场景中，高优先级线程 $H_i$ 饥饿的根源在于几个因素的致命组合：\n- **非公平的自旋锁**：简单的测试并设置（Test-and-Set）自旋锁不保证请求的顺序。\n- **缓存局部性偏差**：刚刚释放锁的核心，其缓存中仍然持有该锁的缓存行（处于“独占”或“已修改”状态）。这使得该核心上的线程能够以极低的延迟再次获取锁，而其他核心上的线程则需要通过昂贵的总线事务来争抢，处于劣势。这导致一个低优先级线程循环可以“霸占”锁。\n- **禁用抢占**：在临界区内禁用抢占，意味着一旦低优先级线程 $L_j$ 获得锁，它将持有锁直到完成其长达 $C_L = 200\\,\\mu s$ 的临界区。在此期间，即使更高优先级的线程 $H_i$ 变为就绪态，调度器也无法介入。这造成了长时间的优先级反转。\n\n这三点结合起来，导致高优先级线程不仅要等待长临界区，还可能被其他低优先级线程无限次地“插队”，从而产生无界等待，即饥饿。\n\n**2. 评估标准**\n\n我们需要一个解决方案，同时满足两个硬性要求：\n- (i) **无饥饿**：保证高优先级线程的等待时间是有界的。\n- (ii) **等待时间上限与 $L$ 和 $C_L$ 无关**：最坏情况下的等待时间不能随着低优先级线程的数量（$L$）或其临界区长度（$C_L$）的增加而增加。\n\n**3. 评估候选方案**\n\n- **A. 协作式抢占、优先级队列锁、优先级继承**\n    - **协作式抢占点**：在临界区内以 $\\tau=50\\,\\mu s$ 的间隔插入检查点。这确保了任何线程持有锁的时间都不会超过 $\\tau$ 而不响应更高优先级的请求。这直接打破了对 $C_L=200\\,\\mu s$ 的依赖。\n    - **优先级感知的队列锁**：等待的线程按优先级排队。这从根本上解决了“插队”问题，保证了高优先级线程不会被后到的低优先级线程超越。这使得等待时间与低优先级线程的数量 $L$ 无关。\n    - **最坏情况等待时间分析**：当一个高优先级线程 $H_i$ 请求锁时，它最多需要等待：\n        1.  当前持有锁的一个线程（可能是低优先级的）到达下一个抢占点并执行交接。最坏情况下的时间是 $\\tau + \\delta$。\n        2.  所有在 $H_i$ 之前就已经在队列中等待的、优先级不低于 $H_i$ 的其他线程。在本例中，最多有 $H-1 = 1$ 个其他高优先级线程。每个线程的临界区时间为 $C_H$。\n    - 因此，最坏情况等待时间上限为：\n      $$W_{H, \\text{max}} \\le (\\tau + \\delta) + (H-1) \\cdot C_H$$\n      $$W_{H, \\text{max}} \\le (50\\,\\mu s + 5\\,\\mu s) + (2-1) \\cdot 10\\,\\mu s = 65\\,\\mu s$$\n    - 这个上限是有界的（满足条件 i），并且它只依赖于 $\\tau, \\delta, H, C_H$，完全独立于 $L$ 和 $C_L$（满足条件 ii）。\n    - **结论**：此方案完全满足要求。\n\n- **B. 指数退避**\n    - 这种方法是概率性的，不能提供确定性的等待时间上限。高优先级线程仍有（尽管很小的）可能被饿死。此外，如果一个低优先级线程获得了锁，它仍然会持有锁长达 $C_L = 200\\,\\mu s$，因此等待时间依赖于 $C_L$。不满足条件 (ii)。\n\n- **C. 在临界区内启用抢占**\n    - 这是一个灾难性的设计。如果一个持有自旋锁的线程被抢占，其他核心上等待该锁的线程会徒劳地消耗CPU，更糟的是，如果调度器在同一个核心上调度另一个需要该锁的线程，将导致死锁。这引入了比饥饿更严重的正确性问题。\n\n- **D. FIFO票据锁**\n    - 票据锁通过强制先进先出（FIFO）顺序，确实解决了饥饿问题，保证了有界等待（满足条件 i）。\n    - 但是，它不感知优先级。如果一个高优先级线程到达时，队列中已经有 $k$ 个低优先级线程在它前面，它就必须等待这 $k$ 个线程全部完成它们长达 $C_L$ 的临界区。因此，最坏情况等待时间直接依赖于 $C_L$ 和可以排队的核心数（最多 $N-1$ 个）。不满足条件 (ii)。\n\n**最终结论**：只有候选方案A通过结合协作式抢占和优先级排队，从根本上解决了优先级反转和不公平竞争的问题，提供了一个紧凑且独立于低优先级任务参数的等待时间上限。", "answer": "$$\\boxed{A}$$", "id": "3661484"}]}