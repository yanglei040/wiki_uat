{"hands_on_practices": [{"introduction": "在现代多插槽（multi-socket）系统中，处理器访问内存的速度并非处处相等，这种特性被称为非一致性内存访问（NUMA）。这给操作系统调度器带来了一个根本性的两难处境：是应该为了最大化 CPU 利用率而积极地在不同处理器插槽间迁移线程，还是应该为了保持对本地内存的快速访问而将线程固定在某个插槽上？这项练习旨在通过一个真实场景，挑战您分析负载均衡和内存局部性之间的权衡，并选择能够最大化内存局部性同时满足性能要求的最佳调度策略 [@problem_id:3661196]。", "problem": "一个双插槽多处理器，每个插槽有$N=8$个核心。每个插槽拥有一个容量为$C=16 \\text{ MiB}$的共享末级缓存（LLC）和本地动态随机存取存储器（DRAM）。该机器实现了非统一内存访问（NUMA）架构，并采用首次接触（first-touch）分配策略：一个页面被放置在首次接触它的那个插槽的本地DRAM中。一组$T=16$个相同的用户线程执行一个通过屏障（barrier）同步的循环。在每次迭代中，一个线程会重复遍历大小为$w=1 \\text{ MiB}$的私有工作集，然后参与一个屏障同步，之后它会扫描一个由同一进程中所有线程使用的、大小为$D=4 \\text{ MiB}$的绝大多数情况下为只读的共享数据集。由于输入/输出导致的短时阻塞事件会使一个随机的线程子集（平均占其中的$25\\%$）阻塞大约$5$毫秒；为了在这些事件期间保持接近完全的利用率，操作系统（OS）必须在所选的任何平衡域内，以大约$1$毫秒的间隔执行负载均衡。\n\n假设以下基本事实和定义：\n- 当引用的数据自上次访问以来仍保留在缓存中时，发生缓存命中；当聚合的活跃使用数据超过缓存容量时，发生容量引发的未命中。\n- 如果在相关的重用窗口期间，竞争给定LLC的聚合工作集小于LLC容量，则命中率很高；如果超过容量，则命中率会因驱逐（eviction）而降低。\n- 在首次接触放置策略下，将一个线程迁移到不同的插槽会使其后续的页面访问变为远程访问，直到这些页面被迁移为止；远程DRAM访问比本地DRAM访问慢。\n- 此处“最大化局部性”的目标是指最大化存储器引用中，其结果为LLC命中，或在LLC未命中时由本地DRAM而非远程DRAM服务的预期比例。\n\n您正在评估调度器平衡范围选项$S$，以在所述的利用率要求下最大化局部性。请考虑以下候选策略：\n\nA. 系统级每核心平衡：一个横跨两个插槽的单一全局域，每$1$毫秒重新平衡运行队列，不优先考虑插槽局部性。\n\nB. 每插槽平衡：每个插槽拥有独立的平衡域，在每个插槽内每$1$毫秒重新平衡；罕见的跨插槽重新平衡仅每$100$毫秒发生一次，以纠正长期存在的不平衡。\n\nC. 初始随机放置后不进行重新平衡：每个线程被永久固定（pinned）到其最初选择的核心上。\n\nD. 跨插槽配对核心平衡：每$1$毫秒在跨插槽的固定核心对内执行平衡（对于每个索引$i$，插槽$0$的核心$i$与插槽$1$的核心$i$配对），允许在每对核心内频繁进行跨插槽迁移。\n\n哪种$S$的选择在满足利用率要求的同时，能最好地最大化如上定义的局部性？\n\n选择一项：\n\nA. 系统级每核心平衡\n\nB. 每插槽平衡\n\nC. 初始随机放置后不进行重新平衡\n\nD. 跨插槽配对核心平衡", "solution": "核心挑战是在两个相互竞争的目标之间取得平衡：最大化内存局部性和维持高CPU利用率。根据定义，局部性包括缓存命中（最快）和本地DRAM访问（较慢，但远快于远程DRAM访问）。必须通过负载均衡来应对线程阻塞，以维持利用率。\n\n我们来分析系统参数。系统有$2$个插槽，每个插槽有$N=8$个核心，总共有$16$个核心。有$T=16$个线程，初始时可以实现线程到核心的一对一映射。我们假设初始采用均衡布局，每个插槽上有$8$个线程。\n\n在这种布局下，我们分析每个插槽的内存占用。每个插槽承载$8$个线程。一个插槽上的总私有数据大小为$8 \\times w = 8 \\times 1 \\text{ MiB} = 8 \\text{ MiB}$。所有线程还访问一个大小为$D=4 \\text{ MiB}$的共享数据集。因此，竞争一个插槽LLC的总活动工作集为$8 \\text{ MiB} + 4 \\text{ MiB} = 12 \\text{ MiB}$。\n每个插槽的LLC容量为$C=16 \\text{ MiB}$。由于活动工作集（$12 \\text{ MiB}$）小于LLC容量（$16 \\text{ MiB}$），如果线程保持在其初始插槽上，它们在初始预热阶段后将体验到很高的LLC命中率。此外，由于首次接触策略，每个线程的私有数据将被分配在其所在插槽的本地DRAM中。这种配置代表了局部性的理想状态。\n\n复杂性源于负载均衡。平均有$25\\%$的$16$个线程（即$4$个线程）在任何时候都处于阻塞状态。这会产生空闲核心，操作系统必须以$1 \\text{ ms}$的间隔将运行中的线程迁移到这些核心上以维持利用率。平衡范围$S$的选择决定了这种迁移如何影响局部性。\n\n现在，我们来评估每个候选策略。\n\nA. 系统级每核心平衡\n该策略在所有$16$个核心上创建一个单一的平衡域。为了利用一个空闲核心，调度器可以将任何运行中的线程从任何核心迁移到任何其他核心。一个最初在插槽$0$上的线程可能会被迁移到插槽$1$上的一个空闲核心。这对局部性有严重的负面影响：\n1.  **NUMA局部性**：该线程的私有数据（$w=1 \\text{ MiB}$）被分配在插槽$0$的DRAM中，现在必须从插槽$1$远程访问。这明显更慢。\n2.  **缓存局部性**：该线程失去了其在插槽$0$ LLC中所有数据的好处。它现在必须开始填充插槽$1$的LLC，导致缓存未命中，并可能驱逐对插槽$1$上其他线程有用的数据。\n鉴于$1 \\text{ ms}$的频繁重新平衡间隔，线程会不断地在插槽之间迁移，这种情况被称为“缓存和NUMA颠簸”，它通过最小化LLC命中和本地DRAM访问来极大地损害性能。该策略为了利用率而完全牺牲了局部性。\n结论：**不正确**。\n\nB. 每插槽平衡\n该策略为每个$8$核的插槽建立一个独立的平衡域。$1 \\text{ ms}$间隔的负载均衡仅在插槽*内部*进行。插槽$0$上的线程只能被迁移到插槽$0$上的其他核心。\n1.  **NUMA局部性**：因为线程从不离开其插槽，其私有数据始终保留在本地DRAM中。NUMA局部性被完美地保留下来。\n2.  **缓存局部性**：一个插槽上的所有$8$个核心共享同一个$16 \\text{ MiB}$的LLC。当一个线程在同一插槽内的核心之间迁移时，它继续访问同一个LLC。该插槽上$8$个线程的聚合工作集保持为$12 \\text{ MiB}$，这适合LLC的容量。因此，高缓存命中率得以维持。\n该策略智能地解决了负载不平衡问题。平均而言，每个插槽上将有$2$个线程阻塞，留下$6$个运行线程和$2$个空闲核心。插槽内平衡器可以在这$8$个核心之间分配这$6$个线程以维持利用率，而不会产生任何跨插槽迁移的惩罚。罕见的$100 \\text{ ms}$间隔的跨插槽重新平衡作为对长期统计不平衡的纠正措施，但其频率足够低，可以避免颠簸。这种方法正确地将插槽识别为自然的局部性域，并尊重了这一点。\n结论：**正确**。\n\nC. 初始随机放置后不进行重新平衡\n该策略将每个线程永久地固定到一个核心上。这提供了最大可能的局部性，因为线程的执行上下文永远不会移动。然而，它完全无法满足问题明确提出的利用率要求。当一个核心上的线程阻塞时，该核心在阻塞期间（`~5 \\text{ ms}`）保持空闲。平均有$4$个线程阻塞，因此$16$个核心中的$4$个（$25\\%$）将处于空闲状态，导致利用率低下。问题要求操作系统*必须*执行负载均衡以维持利用率。\n结论：**不正确**。\n\nD. 跨插槽配对核心平衡\n该策略创建了$8$个小而僵化的平衡域，每个域由一对核心组成，其中一个来自每个插槽（例如，插槽$0$的核心$i$和插槽$1$的核心$i$）。$1 \\text{ ms}$间隔的平衡仅在这些配对内部进行。这实际上是系统级平衡的一种受限形式，并存在同样的基本缺陷。如果插槽$0$核心$i$上的线程阻塞，来自插槽$1$核心$i$的运行线程可能会被迁移过去。这是一次跨插槽迁移，它会破坏NUMA和缓存局部性，就像选项A一样。此外，该策略在系统级负载均衡方面表现不佳。如果分配给一对的两个线程都阻塞了，该域中的两个核心都变为空闲，而该策略没有机制从其他更繁忙的配对中获取工作。\n结论：**不正确**。\n\n总之，每插槽平衡是唯一一种策略，它通过频繁的负载均衡满足利用率要求，同时又保留了系统架构所能提供的关键的NUMA和缓存局部性。它通过将频繁的迁移限制在局部性域（即插槽）内，正确地平衡了这种权衡。", "answer": "$$\\boxed{B}$$", "id": "3661196"}, {"introduction": "同时多线程（SMT）技术通过在单个物理核心上运行多个硬件线程来提高处理器利用率，但它也带来了一个副作用：同一核心上的硬件线程会争用流水线、缓存等共享资源。本练习通过一个假设模型来量化这种硬件干扰对调度公平性的影响，要求您计算实际资源分配与理想加权公平分配之间的偏差 [@problem_id:3661255]。这个实践揭示了为何在支持 SMT 的处理器上，调度器即便精确地按权重分配时间片，也难以实现完美的公平性。", "problem": "一个系统有$N=3$个相同的处理器核心，每个核心支持两个同步多线程 (SMT) 硬件线程。操作系统采用加权公平性策略：在没有干扰的情况下，一个权重为$w_i$的可运行软件线程$i$应获得的处理器总容量份额等于$w_i$除以所有可运行线程的权重之和。然而，在 SMT 资源共享的情况下，每个硬件线程$k$会表现出一个测得的共享标量$s_k \\in (0,1]$，它会与绑定到该硬件线程上的任何软件线程的实际服务速率相乘，这反映了对共享流水线和缓存资源的竞争。假设调度器继续按与$w_i$成比例的方式分配时间片，但实际服务速率变为与$w_i s_{k(i)}$成正比，其中$k(i)$表示托管软件线程$i$的硬件线程。实际容量份额即为$w_i s_{k(i)}$的值经过所有可运行线程的总和归一化后的结果。\n\n考虑五个可运行的软件线程$i \\in \\{1,2,3,4,5\\}$，其权重分别为$w_1=1.0$，$w_2=2.0$，$w_3=1.5$，$w_4=1.0$和$w_5=3.0$。它们被钉扎到三个核心上的硬件线程，具体如下：线程 1 到硬件线程$k=1$，线程 2 到$k=2$，线程 3 到$k=3$，线程 4 到$k=4$，线程 5 到$k=5$；同级的硬件线程$k=6$处于空闲状态。活跃硬件线程的实测共享标量为$s_1=0.58$，$s_2=0.62$，$s_3=0.55$，$s_4=0.60$和$s_5=0.98$。\n\n将线程$i$的理想加权份额定义为$p_i = \\frac{w_i}{\\sum_{j=1}^{5} w_j}$，将 SMT 竞争下的实际份额定义为$f_i = \\frac{w_i s_{k(i)}}{\\sum_{j=1}^{5} w_j s_{k(j)}}$。使用与理想值的平方偏差之和公式\n$$L \\;=\\; \\sum_{i=1}^{5} \\left(f_i - p_i\\right)^{2},$$\n计算该系统的$L$值。将$L$的最终值表示为一个无单位的纯数，并四舍五入到四位有效数字。", "solution": "基本原理是处理器容量的加权公平性定义，以及同步多线程（SMT）资源共享会缩放每个线程的实际服务速率这一观察。在一个理想的加权公平分配中，若可运行线程的总权重为 $\\sum_{j=1}^{5} w_j$，则每个线程 $i$ 应获得的份额为\n$$p_i \\;=\\; \\frac{w_i}{\\sum_{j=1}^{5} w_j}。$$\n在 SMT 干扰下，实际服务速率与 $w_i s_{k(i)}$ 成正比，因此实际份额是归一化后的量\n$$f_i \\;=\\; \\frac{w_i s_{k(i)}}{\\sum_{j=1}^{5} w_j s_{k(j)}}。$$\n所要求的公平性损失度量是平方偏差之和\n$$L \\;=\\; \\sum_{i=1}^{5} \\left(f_i - p_i\\right)^{2}。$$\n\n第 1 步：通过对权重求和来计算理想份额 $p_i$。总权重为\n$$\\sum_{j=1}^{5} w_j \\;=\\; 1.0 + 2.0 + 1.5 + 1.0 + 3.0 \\;=\\; 8.5。$$\n因此，\n$$p_1 \\;=\\; \\frac{1.0}{8.5} \\;=\\; \\frac{2}{17}, \\quad p_2 \\;=\\; \\frac{2.0}{8.5} \\;=\\; \\frac{4}{17}, \\quad p_3 \\;=\\; \\frac{1.5}{8.5} \\;=\\; \\frac{3}{17}, \\quad p_4 \\;=\\; \\frac{1.0}{8.5} \\;=\\; \\frac{2}{17}, \\quad p_5 \\;=\\; \\frac{3.0}{8.5} \\;=\\; \\frac{6}{17}。$$\n\n第 2 步：计算实际分配的分子项 $w_i s_{k(i)}$ 及其总和。使用给定的 $s_k$ 值和映射关系，\n$$w_1 s_{k(1)} \\;=\\; 1.0 \\cdot 0.58 \\;=\\; \\frac{29}{50},$$\n$$w_2 s_{k(2)} \\;=\\; 2.0 \\cdot 0.62 \\;=\\; \\frac{31}{25},$$\n$$w_3 s_{k(3)} \\;=\\; 1.5 \\cdot 0.55 \\;=\\; \\frac{33}{40},$$\n$$w_4 s_{k(4)} \\;=\\; 1.0 \\cdot 0.60 \\;=\\; \\frac{3}{5},$$\n$$w_5 s_{k(5)} \\;=\\; 3.0 \\cdot 0.98 \\;=\\; \\frac{147}{50}。$$\n这五项的总和是\n$$\\sum_{j=1}^{5} w_j s_{k(j)} \\;=\\; \\frac{29}{50} + \\frac{31}{25} + \\frac{33}{40} + \\frac{3}{5} + \\frac{147}{50}。$$\n使用公分母 $200$，上式变为\n$$\\sum_{j=1}^{5} w_j s_{k(j)} \\;=\\; \\frac{116 + 248 + 165 + 120 + 588}{200} \\;=\\; \\frac{1237}{200}。$$\n\n第 3 步：计算作为归一化分数的实际份额 $f_i$：\n$$f_1 \\;=\\; \\frac{\\frac{29}{50}}{\\frac{1237}{200}} \\;=\\; \\frac{116}{1237}, \\quad\nf_2 \\;=\\; \\frac{\\frac{31}{25}}{\\frac{1237}{200}} \\;=\\; \\frac{248}{1237}, \\quad\nf_3 \\;=\\; \\frac{\\frac{33}{40}}{\\frac{1237}{200}} \\;=\\; \\frac{165}{1237}, \\quad\nf_4 \\;=\\; \\frac{\\frac{3}{5}}{\\frac{1237}{200}} \\;=\\; \\frac{120}{1237}, \\quad\nf_5 \\;=\\; \\frac{\\frac{147}{50}}{\\frac{1237}{200}} \\;=\\; \\frac{588}{1237}。$$\n\n第 4 步：使用公分母计算偏差 $d_i = f_i - p_i$。每对分数的公分母为 $1237 \\cdot 17 = 21029$。精确计算每个偏差：\n$$d_1 \\;=\\; \\frac{116}{1237} - \\frac{2}{17} \\;=\\; \\frac{116 \\cdot 17 - 2 \\cdot 1237}{21029} \\;=\\; \\frac{1972 - 2474}{21029} \\;=\\; -\\frac{502}{21029},$$\n$$d_2 \\;=\\; \\frac{248}{1237} - \\frac{4}{17} \\;=\\; \\frac{248 \\cdot 17 - 4 \\cdot 1237}{21029} \\;=\\; \\frac{4216 - 4948}{21029} \\;=\\; -\\frac{732}{21029},$$\n$$d_3 \\;=\\; \\frac{165}{1237} - \\frac{3}{17} \\;=\\; \\frac{165 \\cdot 17 - 3 \\cdot 1237}{21029} \\;=\\; \\frac{2805 - 3711}{21029} \\;=\\; -\\frac{906}{21029},$$\n$$d_4 \\;=\\; \\frac{120}{1237} - \\frac{2}{17} \\;=\\; \\frac{120 \\cdot 17 - 2 \\cdot 1237}{21029} \\;=\\; \\frac{2040 - 2474}{21029} \\;=\\; -\\frac{434}{21029},$$\n$$d_5 \\;=\\; \\frac{588}{1237} - \\frac{6}{17} \\;=\\; \\frac{588 \\cdot 17 - 6 \\cdot 1237}{21029} \\;=\\; \\frac{9996 - 7422}{21029} \\;=\\; \\frac{2574}{21029}。$$\n\n第 5 步：计算损失 $L$：\n$$L \\;=\\; \\sum_{i=1}^{5} d_i^{2} \\;=\\; \\frac{502^{2} + 732^{2} + 906^{2} + 434^{2} + 2574^{2}}{21029^{2}}。$$\n计算分子各项：\n$$502^{2} \\;=\\; 252004, \\quad 732^{2} \\;=\\; 535824, \\quad 906^{2} \\;=\\; 820836, \\quad 434^{2} \\;=\\; 188356, \\quad 2574^{2} \\;=\\; 6625476。$$\n求和得到\n$$252004 + 535824 + 820836 + 188356 + 6625476 \\;=\\; 8422496。$$\n分母是\n$$21029^{2} \\;=\\; 442218841。$$\n因此，\n$$L \\;=\\; \\frac{8422496}{442218841} \\;\\approx\\; 0.019045991\\ldots。$$\n\n按要求四舍五入到四位有效数字，\n$$L \\;\\approx\\; 0.01905。$$", "answer": "$$\\boxed{0.01905}$$", "id": "3661255"}, {"introduction": "分叉-连接（fork-join）是并行计算中一种常见的编程模型，主线程派生出多个可并行的任务，然后等待它们全部完成后再继续执行。整个作业的性能关键取决于这些并行任务如何被有效地分配到所有可用的处理器核心上。这项动手练习要求您应用一个经典的调度算法来为一组并行任务找到最优的分配方案，从而最小化整个作业的完成时间（即完工时间）[@problem_id:3661208]。", "problem": "给定一个在具有$N$个相同核心的对称多处理器系统上运行的单一分叉-连接作业。该作业具有以下结构：一个持续时间为$a$个时间单位的严格串行前缀，随后是$J$个独立任务的分叉，最后是一个连接，会产生$s$个时间单位的同步开销。$J$个并行任务中的每一个都有一个整数处理时间，且任务是不可抢占的。串行前缀必须在任何并行任务可以开始之前完成。连接开销$s$是一个纯粹的等待延迟，它不占用核心，但在所有并行任务完成后会增加到作业的完成时间中。所有核心都具有相同的速度，在任何时候一个核心最多只能处理一个任务。布局决策将每个并行任务分配给一个核心，而协同调度决策确定一个核心按顺序执行哪组任务。所有任务在串行前缀完成后立即变为可执行状态。\n\n您的目标是确定一个布局和协同调度策略，以最小化总完工时间（作业完成的时间）。该策略必须尊重核心是相同的、任务在分叉发生后是独立的、以及连接会等到所有并行任务完成。假设在同一核心上切换任务的开销为零，并且除了任务处理之外唯一的额外成本是连接同步成本$s$。\n\n仅使用基本的操作系统定义和调度原则。特别地，不要假设任何专门的调度公式。从完工时间的定义和分叉-连接执行的结构出发进行推理。\n\n编写一个完整的程序，对于下面的每个测试案例，计算在上述模型下的最小可能完工时间。您的程序不得读取输入。它必须对测试套件进行硬编码，并以确切要求的格式打印结果。\n\n测试套件（每个案例由$(N, a, s, J, \\text{tasks})$指定，任务时间以时间单位计）：\n- 案例 1：$(N, a, s, J, \\text{tasks}) = (4, 3, 2, 6, [4, 4, 2, 2, 1, 1])$。\n- 案例 2：$(2, 0, 1, 3, [5, 3, 3])$。\n- 案例 3：$(1, 2, 0, 4, [3, 2, 2, 2])$。\n- 案例 4：$(10, 1, 5, 3, [7, 1, 1])$。\n- 案例 5：$(3, 0, 0, 6, [2, 2, 2, 2, 2, 2])$。\n- 案例 6：$(2, 5, 3, 5, [4, 4, 4, 4, 4])$。\n\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序与上述案例相同。每个结果都必须是一个整数。例如，一个包含三个结果的输出行应如下所示：$[r_1,r_2,r_3]$（不含空格）。\n\n约束和说明：\n- 将所有时间量视为无单位整数。\n- 持续时间为$a$的串行前缀会占用一个核心$a$个时间单位，并且必须在任何并行任务开始之前完成。\n- 连接同步成本$s$是在所有并行任务完成后发生的纯粹延迟，不使用核心。\n- 每个任务必须在单个核心上完整运行，不可抢占；一个核心可以按顺序执行多个任务。\n- 核心是相同的；核心上任务的顺序不改变该核心执行的总时间。\n\n您的任务是为每个案例计算在上述模型下任何布局和协同调度策略可实现的最小完工时间，并以指定的确切输出格式打印这些最小完工时间的列表。", "solution": "目标是找到分叉-连接作业的最小可能完工时间$T_{makespan}$。作业的执行包括三个不同的、顺序的阶段：串行前缀、并行执行阶段和连接同步。总完工时间是这些阶段持续时间的总和：\n$$T_{makespan} = T_{serial} + T_{parallel} + T_{join}$$\n根据问题描述，我们已知$T_{serial} = a$和$T_{join} = s$。因此，问题简化为最小化并行阶段的持续时间$T_{parallel}$。\n\n并行阶段涉及在$N$个相同的核心上调度$J$个独立的、非抢占式的任务。所有任务在串行前缀完成后同时可用。一个核心在任何时候最多只能执行一个任务。在单个核心上执行多个任务的时间是它们各自处理时间的总和。只有当最后一个任务在其被分配的任何一个核心上执行完毕时，并行阶段才算完成。\n\n设$J$个任务处理时间的集合为$\\mathcal{P} = \\{p_1, p_2, \\ldots, p_J\\}$。我们必须找到这个集合的一个划分为$N$个不相交的子集，$\\mathcal{S}_1, \\mathcal{S}_2, \\ldots, \\mathcal{S}_N$，其中每个子集$\\mathcal{S}_i$代表分配给核心$i$的任务。核心$i$上的总处理时间，或负载，是$L_i = \\sum_{p \\in \\mathcal{S}_i} p$。\n\n由于所有并行任务都在时间$a$之后开始，并且核心并行工作，所以并行阶段在最繁忙的核心完成其工作时结束。因此，并行阶段的持续时间由所有核心中的最大负载决定：\n$$T_{parallel} = \\max_{i=1, \\ldots, N} \\{L_i\\}$$\n最小化$T_{makespan}$等价于找到一个能最小化此最大负载的任务划分。这是计算机科学中一个经典的优化问题，称为多处理器调度问题，该问题是 NP-难的。然而，对于小规模的问题实例，可以找到最优调度。解决此问题的一个高效且广泛使用的启发式算法是“最长处理时间优先”（Longest Processing Time, LPT）算法。该算法按处理时间的降序对任务进行排序，然后逐一将每个任务分配给当前累积负载最低的核心。在许多情况下，包括所提供的案例，这种贪心方法都能得出最优解。\n\nLPT 算法如下：\n1.  按处理时间的降序对任务$\\mathcal{P}$进行排序。\n2.  将$N$个核心的负载初始化为零：$L_i = 0$ for $i=1, \\ldots, N$。\n3.  对于排序列表中的每个任务$p_j$，找到当前负载最小的核心$k$，即$L_k = \\min_{i=1, \\ldots, N} \\{L_i\\}$。\n4.  将任务$p_j$分配给核心$k$，并更新其负载：$L_k \\leftarrow L_k + p_j$。\n5.  在所有任务分配完毕后，最小并行完工时间为$T_{parallel} = \\max_{i=1, \\ldots, N} \\{L_i\\}$。\n\n我们现在将此方法应用于每个测试案例。\n\n**案例 1：** $(N, a, s, J, \\text{tasks}) = (4, 3, 2, 6, [4, 4, 2, 2, 1, 1])$\n任务降序排序：$[4, 4, 2, 2, 1, 1]$。核心负载$L = \\{0, 0, 0, 0\\}$。\n- 分配任务 4：$L = \\{4, 0, 0, 0\\}$\n- 分配任务 4：$L = \\{4, 4, 0, 0\\}$\n- 分配任务 2：$L = \\{4, 4, 2, 0\\}$\n- 分配任务 2：$L = \\{4, 4, 2, 2\\}$\n- 分配任务 1：$L = \\{4, 4, 2, 3\\}$\n- 分配任务 1：$L = \\{4, 4, 3, 3\\}$\n最终负载为 $\\{4, 4, 3, 3\\}$。最大负载为$T_{parallel} = \\max(4, 4, 3, 3) = 4$。\n$T_{makespan} = a + T_{parallel} + s = 3 + 4 + 2 = 9$。\n\n**案例 2：** $(N, a, s, J, \\text{tasks}) = (2, 0, 1, 3, [5, 3, 3])$\n任务降序排序：$[5, 3, 3]$。核心负载$L = \\{0, 0\\}$。\n- 分配任务 5：$L = \\{5, 0\\}$\n- 分配任务 3：$L = \\{5, 3\\}$\n- 分配任务 3：$L = \\{5, 6\\}$\n最终负载为 $\\{5, 6\\}$。最大负载为$T_{parallel} = \\max(5, 6) = 6$。\n$T_{makespan} = a + T_{parallel} + s = 0 + 6 + 1 = 7$。\n\n**案例 3：** $(N, a, s, J, \\text{tasks}) = (1, 2, 0, 4, [3, 2, 2, 2])$\n由于只有$N=1$个核心，所有并行任务都必须在该核心上顺序执行。\n单个核心上的总负载是所有任务时间之和：$3 + 2 + 2 + 2 = 9$。\n所以，$T_{parallel} = 9$。\n$T_{makespan} = a + T_{parallel} + s = 2 + 9 + 0 = 11$。\n\n**案例 4：** $(N, a, s, J, \\text{tasks}) = (10, 1, 5, 3, [7, 1, 1])$\n有$J=3$个任务和$N=10$个核心。由于核心数多于任务数，每个任务都可以分配给其专用的核心。这些任务完全并行运行。\n并行阶段的持续时间由最长的任务决定。\n$T_{parallel} = \\max(7, 1, 1) = 7$。\n$T_{makespan} = a + T_{parallel} + s = 1 + 7 + 5 = 13$。\n\n**案例 5：** $(N, a, s, J, \\text{tasks}) = (3, 0, 0, 6, [2, 2, 2, 2, 2, 2])$\n有$J=6$个持续时间为$2$的相同任务和$N=3$个核心。\n总工作量为$6 \\times 2 = 12$。每个核心的理想平均负载为$12 / 3 = 4$。\n这可以通过为每个核心分配两个任务来完美实现。\n$L_1 = 2+2=4$, $L_2 = 2+2=4$, $L_3 = 2+2=4$。\n最大负载为$T_{parallel} = 4$。\n$T_{makespan} = a + T_{parallel} + s = 0 + 4 + 0 = 4$。\n\n**案例 6：** $(N, a, s, J, \\text{tasks}) = (2, 5, 3, 5, [4, 4, 4, 4, 4])$\n任务降序排序：$[4, 4, 4, 4, 4]$。核心负载$L = \\{0, 0\\}$。\n- 分配任务 4：$L = \\{4, 0\\}$\n- 分配任务 4：$L = \\{4, 4\\}$\n- 分配任务 4：$L = \\{8, 4\\}$\n- 分配任务 4：$L = \\{8, 8\\}$\n- 分配任务 4：$L = \\{12, 8\\}$\n最终负载为 $\\{12, 8\\}$。最大负载为$T_{parallel} = \\max(12, 8) = 12$。\n总工作量为$5 \\times 4 = 20$。对于$N=2$个核心，最优划分应为 $\\{10, 10\\}$，但这是不可能的，因为所有任务时间都是$4$的倍数。可以达到的最接近的划分和是 $\\{12, 8\\}$。\n$T_{makespan} = a + T_{parallel} + s = 5 + 12 + 3 = 20$。\n\n计算得出的测试案例的最小完工时间为 $[9, 7, 11, 13, 4, 20]$。", "answer": "```\n[9,7,11,13,4,20]\n```", "id": "3661208"}]}