{"hands_on_practices": [{"introduction": "理论是实践的向导。在设计复杂的复制策略之前，我们首先需要一种量化单个组件可靠性的方法。本练习将指导您使用连续时间马尔可夫链（CTMC）这一强大工具，来为一个副本的生命周期（从健康、到故障、再到恢复）建立数学模型，并推导出其稳态可用性。通过这个练习，您将学会如何将抽象的系统行为转化为精确的数学描述，这是评估和改进系统容错能力的第一步。", "problem": "一个操作系统服务采用复制技术以实现容错。考虑单个副本，其运行状态随时间根据一个连续时间马尔可夫链 (CTMC) 演变。该副本可以处于且仅处于 $3$ 种状态之一：健康 ($H$)、恢复中 ($R$) 或故障 ($F$)。系统仅在副本处于健康状态 $H$ 时提供服务；恢复中状态 $R$ 和故障状态 $F$ 均不可用。\n\n基于指数分布停留时间的无记忆性以及 CTMC 的定义，作如下假设：\n- 在健康状态时，副本的故障时间服从指数分布，速率为 $\\lambda \\gt 0$，从而从状态 $H$ 转移到 $F$。\n- 修复过程分两个指数阶段进行，每个阶段的速率均为 $\\mu \\gt 0$，分别对应诊断/启动和状态重建。具体来说，链以速率 $\\mu$ 从 $F$ 转移到 $R$，并以速率 $\\mu$ 从 $R$ 转移回 $H$。\n\n请仅使用 CTMC 的基本定义和稳态（长时）概率，建立这个 $3$ 状态 CTMC 的模型，并推导稳态可用性 $A(\\lambda,\\mu)$，其定义为副本处于状态 $H$ 的平稳概率。将最终结果表示为一个关于 $\\lambda$ 和 $\\mu$ 的、简化的封闭形式代数表达式。无需四舍五入，且最终表达式中不应包含任何单位。", "solution": "该问题是有效的，因为它描述了一个标准的、良定的连续时间马尔可夫链 (CTMC) 模型，这是可靠性工程和操作系统分析中的一个基本工具。所有必要的参数均已提供，问题具有科学依据，并且存在唯一的稳定解。\n\n该系统被建模为一个状态空间为 $S = \\{H, R, F\\}$ 的 CTMC，其中 $H$ 表示健康状态，$R$ 表示恢复中状态，$F$ 表示故障状态。这些状态之间的转移由具有给定速率的指数分布停留时间控制。转移可以总结如下：\n1.  从状态 $H$ 到状态 $F$，速率为 $\\lambda$。\n2.  从状态 $F$ 到状态 $R$，速率为 $\\mu$。\n3.  从状态 $R$ 到状态 $H$，速率为 $\\mu$。\n\n我们寻求该链的稳态（或平稳）概率分布。设 $\\pi_H$、$\\pi_R$ 和 $\\pi_F$ 分别是系统在状态 $H$、$R$ 和 $F$ 中花费的时间的长期比例。这些概率在稳态下是恒定的，这意味着对于每个状态，流入该状态的速率必须等于流出该状态的速率。这一原则导出了一组平衡方程。\n\n每个状态的平衡方程构建如下：\n- 对于状态 $H$：流入状态 $H$ 的流量来自状态 $R$，速率为 $\\mu$。流出状态 $H$ 的流量去往状态 $F$，速率为 $\\lambda$。因此，平衡方程为：\n$$ \\mu \\pi_R = \\lambda \\pi_H $$\n\n- 对于状态 $R$：流入状态 $R$ 的流量来自状态 $F$，速率为 $\\mu$。流出状态 $R$ 的流量去往状态 $H$，速率为 $\\mu$。因此，平衡方程为：\n$$ \\mu \\pi_F = \\mu \\pi_R $$\n此方程简化为：\n$$ \\pi_F = \\pi_R $$\n\n- 对于状态 $F$：流入状态 $F$ 的流量来自状态 $H$，速率为 $\\lambda$。流出状态 $F$ 的流量去往状态 $R$，速率为 $\\mu$。因此，平衡方程为：\n$$ \\lambda \\pi_H = \\mu \\pi_F $$\n\n注意，这三个方程是线性相关的。我们可以使用其中任意两个。我们使用 $\\mu \\pi_R = \\lambda \\pi_H$ 和 $\\pi_F = \\pi_R$。从第一个方程，我们可以用 $\\pi_H$ 表示 $\\pi_R$：\n$$ \\pi_R = \\frac{\\lambda}{\\mu} \\pi_H $$\n由于 $\\pi_F = \\pi_R$，我们同样得到：\n$$ \\pi_F = \\frac{\\lambda}{\\mu} \\pi_H $$\n\n为了找到唯一解，我们必须使用归一化条件，即所有平稳概率之和必须等于 $1$：\n$$ \\pi_H + \\pi_R + \\pi_F = 1 $$\n\n现在，我们将用 $\\pi_H$ 表示的 $\\pi_R$ 和 $\\pi_F$ 的表达式代入归一化方程：\n$$ \\pi_H + \\left(\\frac{\\lambda}{\\mu} \\pi_H\\right) + \\left(\\frac{\\lambda}{\\mu} \\pi_H\\right) = 1 $$\n\n提取公因式 $\\pi_H$：\n$$ \\pi_H \\left(1 + \\frac{\\lambda}{\\mu} + \\frac{\\lambda}{\\mu}\\right) = 1 $$\n$$ \\pi_H \\left(1 + \\frac{2\\lambda}{\\mu}\\right) = 1 $$\n\n为了解出 $\\pi_H$，我们首先合并括号内的项：\n$$ \\pi_H \\left(\\frac{\\mu + 2\\lambda}{\\mu}\\right) = 1 $$\n\n最后，我们分离出 $\\pi_H$：\n$$ \\pi_H = \\frac{\\mu}{\\mu + 2\\lambda} $$\n\n问题将稳态可用性 $A(\\lambda, \\mu)$ 定义为副本处于健康状态 $H$ 的平稳概率。因此，$A(\\lambda, \\mu) = \\pi_H$。\n\n稳态可用性的最终表达式为：\n$$ A(\\lambda, \\mu) = \\frac{\\mu}{\\mu + 2\\lambda} $$\n这是一个用给定参数 $\\lambda$ 和 $\\mu$ 表示的封闭形式代数表达式。", "answer": "$$\\boxed{\\frac{\\mu}{\\mu + 2\\lambda}}$$", "id": "3641355"}, {"introduction": "复制是提高数据持久性的核心手段，但不同的复制策略在安全性和性能之间存在根本性的权衡。本练习设定了一个清晰的概率模型，让您直接比较两种基础复制策略——同步复制和异步复制——在面对崩溃故障时的数据丢失风险。通过运用期望值的线性和指示变量等基本概率工具，您将能够量化每种策略的持久性保证，从而深刻理解在系统设计中选择不同复制模式所带来的具体后果。", "problem": "一个操作系统中的分布式存储服务会将每个客户端的写入操作复制到 $n$ 个相同的存储节点上。考虑针对每个客户端写入的两种复制策略：同步复制到所有 $n$ 个节点，以及异步复制（即在单个主节点上确认，随后再传播到其余的 $n-1$ 个节点）。\n\n采用以下概率模型来描述写入期间因崩溃导致的数据丢失：\n- 对于每次写入和在系统崩溃时正在主动持久化该写入的每个副本，恢复后该副本不包含该写入的概率为 $p \\in [0,1]$。将 $p$ 理解为每次写入、每个副本的丢失概率，它综合了相对于写入持久化操作的崩溃机会和时机。假设对于给定的写入，这些丢失事件在副本之间是独立的，并且写入操作在时间上也是独立的。\n- 在同步复制下，所有 $n$ 个副本立即开始持久化，并且只有在所有 $n$ 个副本都已将写入持久化后，才会确认该写入。如果在一次崩溃后， $n$ 个副本中没有任何一个包含该写入，则认为该写入丢失。\n- 在异步复制下，在崩溃可能影响给定写入的脆弱窗口内，只有主副本在主动持久化该写入；其他 $n-1$ 个副本尚未开始持久化。如果主副本在恢复后不包含该写入，则认为该写入丢失。\n\n设 $t$ 为发出的客户端写入次数，其中 $t \\in \\mathbb{N}$，并假设丢失事件在不同写入之间是独立的。\n\n仅从独立性、指示随机变量和期望的线性性的定义出发，推导在以下两种情况下，$t$ 次写入中丢失写入的总数的期望值的闭式表达式：\n- 同步复制到 $n$ 个副本，以及\n- 上述的异步复制。\n\n将最终答案表示为一个 $1 \\times 2$ 的行矩阵，其第一项是同步情况，第二项是异步情况，用 $p$、$n$ 和 $t$ 表示。不要四舍五入；提供不带单位的精确表达式。", "solution": "该问题陈述经核实，具有科学依据、阐述严谨、客观且完整。它呈现了计算机系统分析中的一个标准概率建模练习。未发现任何缺陷。我们可以继续进行推导。\n\n设 $L$ 是表示在 $t$ 次客户端总写入中丢失的写入总数的随机变量。我们被要求为两种不同的复制策略求出 $L$ 的期望值，记为 $E[L]$。\n\n推导将基于所要求的三个基本原则：\n1.  **指示随机变量(Indicator Random Variables)：** 对于任意事件 $A$，设 $I_A$ 是一个随机变量，使得如果事件 $A$ 发生，则 $I_A = 1$，否则 $I_A = 0$。指示变量的期望是该事件的概率：$E[I_A] = 1 \\cdot P(A) + 0 \\cdot P(A^c) = P(A)$。\n2.  **期望的线性性(Linearity of Expectation)：** 对于任意一组随机变量 $X_1, X_2, \\dots, X_t$，它们的和的期望等于它们各自期望的和：$E[\\sum_{i=1}^{t} X_i] = \\sum_{i=1}^{t} E[X_i]$。无论这些随机变量是否独立，该性质都成立。\n3.  **事件的独立性(Independence of Events)：** 如果事件 $A_1, A_2, \\dots, A_n$ 相互独立，则它们交集的概率等于它们各自概率的乘积：$P(A_1 \\cap A_2 \\cap \\dots \\cap A_n) = \\prod_{j=1}^{n} P(A_j)$。\n\n设 $L_i$ 为第 $i$ 次写入（对于 $i \\in \\{1, 2, \\dots, t\\}$）丢失事件的指示随机变量。\n$$\nL_i = \\begin{cases} 1  \\text{如果写入 } i \\text{ 丢失} \\\\ 0  \\text{否则} \\end{cases}\n$$\n丢失的写入总数 $L$ 是这些指示变量的和：\n$$\nL = \\sum_{i=1}^{t} L_i\n$$\n根据期望的线性性，丢失写入的总数期望值为：\n$$\nE[L] = E\\left[\\sum_{i=1}^{t} L_i\\right] = \\sum_{i=1}^{t} E[L_i]\n$$\n根据指示变量的性质，有 $E[L_i] = P(\\text{写入 } i \\text{ 丢失})$。问题陈述指出，丢失事件在不同写入之间是独立的。这意味着任何一次给定写入丢失的概率对所有写入都是恒定的。设这个概率为 $\\pi$。\n$$\nP(\\text{写入 } i \\text{ 丢失}) = \\pi \\quad \\forall i \\in \\{1, 2, \\dots, t\\}\n$$\n因此，丢失写入的总数期望值简化为：\n$$\nE[L] = \\sum_{i=1}^{t} \\pi = t \\pi\n$$\n任务简化为为每种复制策略找出特定的丢失概率 $\\pi$。\n\n**1. 同步复制**\n\n设 $\\pi_{sync}$ 为在同步复制策略下单次写入丢失的概率。\n根据定义，一次写入丢失是指在崩溃后，$n$ 个副本中没有任何一个包含该写入。\n设 $F_j$ 为副本 $j$（对于 $j \\in \\{1, \\dots, n\\}$）在恢复后不包含该写入的事件。\n在同步模型中，所有 $n$ 个副本都在主动持久化该写入。问题陈述指出，对于每个这样的副本，在崩溃后不包含该写入的概率是 $p$。\n因此，对于所有 $j \\in \\{1, \\dots, n\\}$，有 $P(F_j) = p$。\n“写入丢失”事件是所有这些失败事件的交集：$F_1 \\cap F_2 \\cap \\dots \\cap F_n$。\n问题假设这些丢失事件在副本之间是独立的。因此，我们可以通过将它们各自的概率相乘来计算它们交集的概率：\n$$\n\\pi_{sync} = P(F_1 \\cap F_2 \\cap \\dots \\cap F_n) = \\prod_{j=1}^{n} P(F_j) = \\prod_{j=1}^{n} p = p^n\n$$\n在同步复制下，丢失写入的总数期望值 $E[L_{sync}]$ 为：\n$$\nE[L_{sync}] = t \\pi_{sync} = t p^n\n$$\n\n**2. 异步复制**\n\n设 $\\pi_{async}$ 为在异步复制策略下单次写入丢失的概率。\n根据定义，一次写入丢失是指主副本在恢复后不包含该写入。\n在异步模型中，在崩溃可能发生的瞬间，只有主副本在主动持久化该写入。我们把主副本标记为副本1。其他 $n-1$ 个副本尚未开始持久化。\n“写入丢失”事件就是事件 $F_1$，其中 $F_1$ 是指主副本在恢复后未能包含该写入的事件。\n其他 $n-1$ 个副本的状态与此策略定义的丢失条件无关。\n单个正在主动持久化的主副本的失败概率为 $p$。\n$$\n\\pi_{async} = P(F_1) = p\n$$\n在异步复制下，丢失写入的总数期望值 $E[L_{async}]$ 为：\n$$\nE[L_{async}] = t \\pi_{async} = t p\n$$\n\n最终答案是一个 $1 \\times 2$ 的行矩阵，分别包含同步和异步情况下的期望值。\n第一项：$t p^n$\n第二项：$t p$", "answer": "$$\n\\boxed{\\begin{pmatrix} t p^{n} & t p \\end{pmatrix}}\n$$", "id": "3641421"}, {"introduction": "理论模型必须经受住现实世界复杂性的考验。本练习将带您深入探讨一个在真实存储系统中普遍存在但常被忽略的问题：“撕裂写”（torn writes），即因断电等原因导致的扇区部分写入。您需要分析在这种物理故障模式下，一个基于法定人数（quorum）的复制系统如何确保数据不错乱。这个练习将挑战您综合运用法定人数的交集属性、校验和（checksum）等完整性检查机制，来设计一个正确的恢复协议，从而保护系统免受数据损坏的威胁。", "problem": "考虑一个操作系统存储子系统中的副本化仅追加日志（replicated append-only log）。存在 $n$ 个副本，当从至少 $q$ 个副本接收到确认时，一次写入被视为已提交。每条日志记录由一个序列号 $S$、一个大小为 $L$ 字节的有效负载 $P$ 以及一个存储了序对 $(L,H)$ 的定长头部组成，其中 $H$ 是根据 $(S,P)$ 计算的校验和。校验和函数是一个 $b$ 位的循环冗余校验（CRC），我们假设它在有效输入上表现得像一个均匀分布的哈希函数。磁盘以大小为 $\\sigma$ 字节的扇区为单位进行写入，电源故障可能导致扇区的部分写入，产生一个撕裂扇区（torn sector），其中只有扇区的前缀被持久化。\n\n在恢复时，系统必须检测到撕裂写入（torn writes）并重建最新的已提交记录。恢复过程从头开始扫描每个副本的日志，通过检查接下来的 $L$ 字节是否存在以及重新计算的校验和 $H'$ 是否等于存储的 $H$ 来验证每条记录。当一条记录验证失败时，扫描停止，该副本的日志被截断到最后一条有效记录处。假设是崩溃-停止故障（副本要么忠实地存储它们尝试写入的位，要么由于撕裂扇区而丢失后缀；副本不是恶意的），并且确认仅在头部 $(L,H)$ 和有效负载 $P$ 已通过适当的写屏障（write barriers）发布到设备后才发送。\n\n假设 $n=5$，$q=3$，$\\sigma=4096$ 字节，$b=32$。分析部分写入（撕裂扇区）对副本正确性的影响，并提出校验和加长度的帧结构（checksum-plus-length framing）如何能从法定人数（quorum）中进行修复。下列哪些陈述是正确的？选择所有适用的选项。\n\nA. 仅靠多数法定人数就足以掩盖撕裂扇区，无需任何完整性机制，因为任意两个多数法定人数集合相交，交集中的副本可以消除正确尾部的歧义。\n\nB. 对于一个均匀分布的 $b$ 位校验和，一个随机的撕裂有效负载恰好与存储的 $L$ 和 $H$ 都匹配的概率最多为 $2^{-b}$，这使得对于 $b=32$ 的情况，未被检测到的损坏可以忽略不计。\n\nC. 在修复中，读取任意 $q$ 个副本，并选择其校验和在其中出现最频繁的有效负载，总是能返回最新的已提交有效负载。\n\nD. 一个健全的修复规则是：在具有有效 $(L,H)$ 的候选项中，找到最大的序列号 $S$，使得序对 $(L,H)$ 在至少 $q$ 个副本上完全相同地出现；宣布该有效负载已提交，并重写所有其他副本以使其匹配；在崩溃-停止故障和可通过帧结构检测的撕裂扇区条件下，这可以重建已提交的记录。\n\nE. 将记录与扇区大小 $\\sigma$ 对齐可以消除撕裂扇区，因此如果 $L$ 是 $\\sigma$ 的倍数，则校验和加长度的帧结构是不必要的。", "solution": "用户提供了一个关于操作系统存储子系统中副本化仅追加日志的问题陈述。任务是验证问题陈述，然后评估五个给定陈述的正确性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   系统：副本化仅追加日志。\n-   副本数量：$n$。\n-   写入法定人数大小：$q$。如果被 $\\ge q$ 个副本确认，一次写入即被提交。\n-   日志记录：\n    -   序列号 $S$。\n    -   大小为 $L$ 字节的有效负载 $P$。\n    -   头部：$(L, H)$，其中 $L$ 是有效负载大小，$H$ 是校验和。\n-   校验和：\n    -   函数：$b$ 位的循环冗余校验（CRC）。\n    -   计算对象：$(S, P)$。\n    -   假设：表现得像一个均匀分布的哈希函数。\n-   存储特性：\n    -   扇区大小：$\\sigma$ 字节。\n    -   故障模式：电源故障可能导致扇区的部分写入，从而产生一个撕裂扇区。\n-   故障模型：\n    -   崩溃-停止故障：副本不会恶意行为。它们要么正确存储数据，要么因撕裂写入而丢失日志的后缀。\n-   提交-确认协议：确认仅在头部 $(L, H)$ 和有效负载 $P$ 已通过适当的写屏障发布到存储设备后才发送。\n-   恢复过程：\n    1.  从头开始扫描每个副本的日志。\n    2.  通过检查以下条件来验证每条记录：\n        a. 接下来的 $L$ 字节（有效负载）存在。\n        b. 对 $(S,P)$ 重新计算的校验和 $H'$ 等于存储的校验和 $H$。\n    3.  如果验证失败，则将副本的日志截断到最后一条有效记录处。\n-   问题常数：$n=5$，$q=3$，$\\sigma=4096$ 字节，$b=32$。\n-   问题：分析正确性和修复机制，并确定所提供的陈述中哪些是正确的。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题牢固地植根于分布式系统和容错存储的原理。基于法定人数的复制（如 Paxos 或 Raft）、用于数据完整性的校验和（如 CRC）以及像撕裂写入这样的物理故障模式，都是计算机科学与工程中标准且被充分理解的概念。\n-   **适定性：** 这个问题是适定的。它描述了一个系统模型、一个故障模型和一个恢复目标。参数都已定义，任务是评估关于系统行为的特定声明，这是一个可解的分析任务。\n-   **客观性：** 语言是技术性的、精确的和客观的，没有主观或含糊的陈述。\n-   **完整性与一致性：** 问题提供了足够的信息来分析这些陈述。崩溃-停止模型、法定人数条件（$q>n/2$ 因为 $3 > 5/2$）、撕裂写入的性质以及校验和的作用都得到了明确说明。没有内部矛盾。\n\n**步骤 3：结论与行动**\n问题陈述是**有效的**。这是一个分析容错分布式系统的标准练习。我将继续进行解决方案推导和选项分析。\n\n### 解决方案与选项分析\n\n该系统使用多数法定人数（majority quorum，$n=5, q=3$）。多数法定人数系统的一个关键特性是任意两个法定人数集合都有非空交集。具体来说，对于任意两个法定人数集合 $Q_1, Q_2$，我们有 $|Q_1 \\cap Q_2| \\ge |Q_1|+|Q_2|-n = q+q-n = 3+3-5=1$。这个交集对于确保能够检索到关于最新已提交状态的信息至关重要。问题围绕这个法定人数特性如何与物理数据损坏（撕裂扇区）以及用于检测它的机制（校验和加长度的帧结构）相互作用展开。\n\n**A. 仅靠多数法定人数就足以掩盖撕裂扇区，无需任何完整性机制，因为任意两个多数法定人数集合相交，交集中的副本可以消除正确尾部的歧义。**\n\n这个陈述是**不正确的**。法定人数交集特性旨在解决不同*有效*日志版本之间的冲突，而不是检测或纠正数据损坏。撕裂扇区会导致数据损坏、无效。如果没有像校验和这样的完整性机制，就不可能区分有效记录与记录的前缀或部分写入留下的其他随机数据。两个法定人数集合交集中的副本本身可能就包含损坏的、撕裂的数据。依赖这样的副本来“消除歧义”会传播损坏。例如，如果序列号为 $S_k$ 的一次写入被副本 $\\{R_1, R_2, R_3\\}$ 确认并提交，随后尝试对 $S_{k+1}$ 进行新的写入，电源故障可能导致 $R_1$ 留下了 $S_{k+1}$ 的撕裂写入，而 $R_2$ 和 $R_3$ 从未开始写入。恢复时，如果我们轮询一个法定人数集合 $\\{R_1, R_4, R_5\\}$，$R_1$ 副本的数据是损坏的。没有校验和，恢复协议无法确定 $R_1$ 的尾部已损坏且必须被截断。因此，完整性机制是必不可少的，仅靠法定人数是不够的。\n\n**B. 对于一个均匀分布的 $b$ 位校验和，一个随机的撕裂有效负载恰好与存储的 $L$ 和 $H$ 都匹配的概率最多为 $2^{-b}$，这使得对于 $b=32$ 的情况，未被检测到的损坏可以忽略不计。**\n\n这个陈述是**正确的**。校验和加长度的帧结构机制在恢复时的工作方式如下：读取一个头部 $(L, H)$，读取随后的 $L$ 字节以获得有效负载 $P$，并验证 `checksum(S, P) == H` 是否成立。如果磁盘上一段损坏的字节序列被意外地解释为一条有效记录，就会发生未检测到的错误。这要求损坏的数据能被解析为一个看起来有效的头部 $(L_{corr}, H_{corr})$ 和一个长度为 $L_{corr}$ 的有效负载 $P_{corr}$，并且重新计算的校验和与 $H_{corr}$ 匹配。保护的核心在于校验和。假设校验和函数表现得像一个随机预言机（如“均匀分布的哈希”所暗示的），对于任何任意输入数据（如损坏的有效负载），其 $b$ 位校验和计算出特定预定值的概率是 $1/2^b$。因此，随机损坏通过校验和验证的概率是 $2^{-b}$。当 $b=32$ 时，这个概率是 $1/2^{32} \\approx 2.3 \\times 10^{-10}$，这是一个极小的值。对于大多数应用来说，这个风险被认为是可忽略的。该陈述正确地描述了校验和的这一基本属性。\n\n**C. 在修复中，读取任意 $q$ 个副本，并选择其校验和在其中出现最频繁的有效负载，总是能返回最新的已提交有效负载。**\n\n这个陈述是**不正确的**。这描述了一种简单的投票机制，已知该机制存在缺陷。它可能导致选择一个从未被提交的写入。考虑以下场景：最新的已提交记录是 $S_k$，存在于所有 $n=5$ 个副本上。发起了一次对记录 $S_{k+1}$ 的新写入。它成功写入了 $2$ 个副本，$\\{R_1, R_2\\}$，这少于法定人数大小 $q=3$。因此，$S_{k+1}$ *未被*提交。此时发生电源故障。在恢复并截断部分写入后，日志尾部的状态是：\n-   $R_1$：包含有效的记录 $S_{k+1}$。\n-   $R_2$：包含有效的记录 $S_{k+1}$。\n-   $R_3, R_4, R_5$：包含有效的记录 $S_k$。\n现在，一个修复进程读取一个由 $q=3$ 个副本组成的法定人数集合，例如 $\\{R_1, R_2, R_3\\}$。它观察到两个 $S_{k+1}$ 的校验和实例和一个 $S_k$ 的校验和实例。按照所提议的规则，它会选择 $S_{k+1}$ 作为正确状态，因为其校验和出现最频繁。然而，$S_{k+1}$ 从未被提交。这将通过“复活”未提交的数据来违反系统的正确性。\n\n**D. 一个健全的修复规则是：在具有有效 $(L,H)$ 的候选项中，找到最大的序列号 $S$，使得序对 $(L,H)$ 在至少 $q$ 个副本上完全相同地出现；宣布该有效负载已提交，并重写所有其他副本以使其匹配；在崩溃-停止故障和可通过帧结构检测的撕裂扇区条件下，这可以重建已提交的记录。**\n\n这个陈述是**正确的**。这个规则是像 Paxos 或 Raft 这类系统中使用的读/恢复协议的简化版本。让我们分析其逻辑：\n1. 一条记录的写入只有在它已成功存储在 $q$ 个副本的法定人数集合上时才被提交。\n2. `(L,H)` 序对作为一条记录特定版本（序列号 $S$）内容的唯一标识符。\n3. 该规则搜索具有最高序列号 $S_{max}$ 的记录，该记录的内容（由 $(L,H)$ 标识）存在于至少 $q$ 个副本上。\n4. 因为任何对序列号 $S_{commit}$ 的已提交写入都必须已存储在一个法定人数集合 $Q_{write}$ 上，而恢复过程会读取自己的法定人数集合 $Q_{read}$，所以交集 $Q_{write} \\cap Q_{read}$ 是非空的。这确保了恢复过程将看到任何已提交写入的证据。\n5. 通过要求给定记录 $(S, (L,H))$ 达到完整的法定人数（$q$），该规则确保它只考虑那些*可能已经*被提交的记录。\n6. 通过选择*最大*的此类序列号，它找到了保证稳定的最新状态。任何序列号更高但出现在少于 $q$ 个副本上的记录，根据定义，都未被提交，必须回滚。任何序列号更低的记录都是被这个更新的已提交状态所取代的日志前缀的一部分。此过程正确地识别了已提交日志的头部。\n\n**E. 将记录与扇区大小 $\\sigma$ 对齐可以消除撕裂扇区，因此如果 $L$ 是 $\\sigma$ 的倍数，则校验和加长度的帧结构是不必要的。**\n\n这个陈述是**不正确的**。对齐能消除撕裂扇区的前提是错误的。“撕裂扇区”是一种物理现象，指单个扇区的写入操作被中断。问题陈述明确允许这种情况。即使一次记录写入只涉及一个扇区（即 $L \\le \\sigma$ 且记录包含在一个扇区内），该扇区本身也可能在电源故障时被撕裂。如果一条记录跨越多个扇区（即 $L > \\sigma$），电源故障可能在写入部分扇区后、但在全部写入完成前发生，从而留下一个不完整（撕裂）的记录。写入 $k=\\lceil L/\\sigma \\rceil$ 个扇区的操作通常不是一个原子操作。因此，对齐并不能消除记录被部分写入的可能性。因此，像校验和加长度的帧结构这样的完整性机制仍然是必要的，用以检测这种部分写入，并区分有效、完整的记录与损坏、不完整的记录。", "answer": "$$\\boxed{BD}$$", "id": "3641407"}]}