{"hands_on_practices": [{"introduction": "在对称多处理（SMP）系统中，一个被称为“伪共享”的微妙现象可能会悄悄地窃取您程序的性能。当不同核心上运行的线程修改驻留在同一缓存行上的独立数据项时，就会发生这种情况，从而导致不必要的缓存一致性流量。这个练习将引导您构建一个简单的数学模型，以具体量化伪共享的成本，并评估一种称为内存填充的常见优化技术的有效性 [@problem_id:3685550]。", "problem": "您正在研究对称多处理（Symmetric Multiprocessing, SMP）系统，其中多个处理器核心共享一个单一的一致性内存空间。在此类系统中，缓存一致性协议（例如，修改、独占、共享、无效（Modified, Exclusive, Shared, Invalid, MESI）协议）通过在发生写入时使其他核心的缓存行失效或更新，来维护内存的一致性视图。当多个线程频繁地写入位于同一缓存行中的独立变量时，会发生一种称为“伪共享”（false sharing）的现象，这会产生不必要的一致性流量并增加写入延迟。\n\n考虑一个包含 $N$ 个线程计数器的数组，其中线程 $i$ 会重复地递增其自己的计数器。在未填充布局中，这些计数器在内存中连续放置，每个计数器占用 $s$ 字节。内存系统使用大小为 $L$ 字节的缓存行，因此最多有 $\\left\\lfloor \\frac{L}{s} \\right\\rfloor$ 个不同的计数器可以占用同一个缓存行。在填充布局中，每个计数器都放置在其专用的 $64$ 字节区域中，以确保没有两个计数器共享一个缓存行。\n\n假设在对称多处理系统上，增量操作的时间成本遵循以下性能模型：\n- 对于执行核心独占的缓存行上的计数器，每次增量操作需要一个基本时间 $p_{\\text{base}}$（单位：纳秒）。\n- 由于伪共享，如果 $k$ 个线程同时对位于同一缓存行上的计数器进行增量操作，那么为了重新获取独占所有权，每次增量操作平均会为该行上每个其他参与线程带来一个额外的一致性开销 $p_{\\text{remote}}$（单位：纳秒）。也就是说，平均每次增量的开销与 $k-1$ 成正比。\n\n设每个线程对其自己的计数器执行 $M$ 次增量操作。设 $F = \\left\\lfloor \\frac{L}{s} \\right\\rfloor$ 为未填充布局中每个缓存行最多的计数器数量。线程按顺序分配给计数器，因此在未填充布局中，最大共享组的大小为 $k_{\\max} = \\min(N, F)$。在具有 $64$ 字节间距的填充布局中，我们假设每个计数器映射到一个不同的缓存行，因此 $k=1$。\n\n在这些假设下：\n- 定义 $T_{\\text{unpadded}}$ 为在未填充布局中，一个线程完成 $M$ 次增量操作所需的时间，该时间由最慢的共享组决定。\n- 定义 $T_{\\text{padded}}$ 为在填充的 $64$ 字节布局中，一个线程完成 $M$ 次增量操作所需的时间。\n- 加速比为 $R = \\frac{T_{\\text{unpadded}}}{T_{\\text{padded}}}$。\n\n您的任务是根据以上定义，利用缓存一致性行为的第一性原理推导出 $R$，并实现一个程序来计算给定测试套件的 $R$ 值。所有时间都以纳秒为单位处理。不涉及角度。不应使用百分比；请将任何比例表示为小数。\n\n测试套件：\n对于每个测试用例，参数为 $(N, s, L, M, p_{\\text{base}}, p_{\\text{remote}})$，其中 $N$、$s$、$L$ 和 $M$ 为整数，$p_{\\text{base}}$ 和 $p_{\\text{remote}}$ 为浮点数纳秒。请使用以下测试用例：\n1. $(N=8, s=8, L=64, M=1000000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n2. $(N=1, s=8, L=64, M=1000000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n3. $(N=4, s=16, L=64, M=500000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n4. $(N=9, s=8, L=64, M=1000000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n5. $(N=8, s=64, L=64, M=1000000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n6. $(N=8, s=8, L=64, M=2000000, p_{\\text{base}}=10.0, p_{\\text{remote}}=10.0)$\n7. $(N=10, s=12, L=64, M=750000, p_{\\text{base}}=8.0, p_{\\text{remote}}=24.0)$\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。每个 $R$ 值都应以十进制形式的浮点值打印。\n\n程序必须完全自包含，不需要任何输入，并计算所列出的每个测试用例的 $R$ 值。不应打印任何无关的文本。", "solution": "该问题要求推导加速比 $R$，该比率量化了在对称多处理（SMP）系统中使用填充内存布局相对于连续（未填充）布局，在减轻伪共享方面的性能提升。该解决方案是根据所提供的性能模型推导出来的。\n\n首先，我们对单个计数器增量操作的时间成本进行形式化。模型指出，如果其他线程正在访问同一缓存行，则一次增量操作需要一个基本时间 $p_{\\text{base}}$ 外加一个缓存一致性流量的开销。对于一组 $k$ 个并发递增同一缓存行上计数器的线程，每次增量操作会为其他 $k-1$ 个竞争线程中的每一个带来 $p_{\\text{remote}}$ 的开销。因此，作为共享线程数 $k$ 的函数，单次增量的平均时间 $T_{\\text{inc}}(k)$ 为：\n$$T_{\\text{inc}}(k) = p_{\\text{base}} + (k-1) p_{\\text{remote}}$$\n该方程假设 $k \\ge 1$。如果 $k=1$，则没有其他竞争线程，时间正确地简化为 $T_{\\text{inc}}(1) = p_{\\text{base}}$。\n\n接下来，我们确定一个线程在填充和未填充两种情况下完成其工作所需的总时间。每个线程执行 $M$ 次增量操作。\n\n在填充布局中，每个计数器都分配在自己的 $64$ 字节内存区域中。假设缓存行大小 $L$ 小于或等于 $64$ 字节（这是一个标准的假设，并且对于所有 $L=64$ 的测试用例都成立），这种填充确保了没有两个计数器会驻留在同一个缓存行上。因此，当一个线程递增其计数器时，它是该缓存行的唯一用户。竞争线程的数量始终为 $k=1$。因此，单次增量的时间为 $T_{\\text{inc}}(1) = p_{\\text{base}}$。一个线程执行 $M$ 次增量操作的总时间 $T_{\\text{padded}}$ 为：\n$$T_{\\text{padded}} = M \\cdot T_{\\text{inc}}(1) = M \\cdot p_{\\text{base}}$$\n\n在未填充布局中，计数器在内存中是连续放置的。每个计数器的大小为 $s$ 字节。给定缓存行大小为 $L$ 字节，单个缓存行可以容纳的最大计数器数量为 $F = \\left\\lfloor \\frac{L}{s} \\right\\rfloor$。\n问题陈述指出，线程是按顺序分配给计数器的，并且性能由“最慢的共享组”决定。这对应于为最拥挤的缓存行竞争的线程组。这个最大共享组的大小 $k_{\\text{max}}$ 是线程总数 $N$ 和每个缓存行最大计数器数 $F$ 的最小值。\n$$k_{\\text{max}} = \\min(N, F) = \\min\\left(N, \\left\\lfloor \\frac{L}{s} \\right\\rfloor\\right)$$\n对于这个最慢组中的任何线程，单次增量的时间为 $T_{\\text{inc}}(k_{\\text{max}})$。这样一个线程完成 $M$ 次增量操作的总时间 $T_{\\text{unpadded}}$ 为：\n$$T_{\\text{unpadded}} = M \\cdot T_{\\text{inc}}(k_{\\text{max}}) = M \\cdot (p_{\\text{base}} + (k_{\\text{max}} - 1) p_{\\text{remote}})$$\n注意，如果 $k_{\\text{max}} = 1$（当 $N=1$ 或 $F=1$ 时发生），则不存在伪共享，并且 $T_{\\text{unpadded}}$ 正确地简化为 $M \\cdot p_{\\text{base}}$。\n\n最后，我们推导加速比 $R$，定义为 $R = \\frac{T_{\\text{unpadded}}}{T_{\\text{padded}}}$。代入 $T_{\\text{unpadded}}$ 和 $T_{\\text{padded}}$ 的表达式：\n$$R = \\frac{M \\cdot (p_{\\text{base}} + (k_{\\text{max}} - 1) p_{\\text{remote}})}{M \\cdot p_{\\text{base}}}$$\n代表增量次数的因子 $M$ 被消去，这表明加速比与总工作负载无关，仅取决于系统参数和竞争水平：\n$$R = \\frac{p_{\\text{base}} + (k_{\\text{max}} - 1) p_{\\text{remote}}}{p_{\\text{base}}}$$\n代入 $k_{\\text{max}}$ 的表达式，得到用于计算的最终公式：\n$$R = \\frac{p_{\\text{base}} + \\left(\\min\\left(N, \\left\\lfloor \\frac{L}{s} \\right\\rfloor\\right) - 1\\right) p_{\\text{remote}}}{p_{\\text{base}}}$$\n这也可以表示为：\n$$R = 1 + \\frac{\\left(\\min\\left(N, \\left\\lfloor \\frac{L}{s} \\right\\rfloor\\right) - 1\\right) p_{\\text{remote}}}{p_{\\text{base}}}$$\n这个最终表达式将用于计算所提供的每个测试用例的比率。对于所有测试用例，$N \\ge 1$ 且 $L \\ge s$，这确保了 $k_{\\text{max}} \\ge 1$，因此项 $k_{\\text{max}}-1$ 是非负的。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3685550"}, {"introduction": "在并行编程中，开发者经常面临一个关键的设计决策：是在线程间共享数据，还是为每个线程提供其私有副本。这个选择直接影响到性能和复杂性。此练习将引导您对共享全局变量与线程局部存储（TLS）之间的性能权衡进行建模，帮助您量化何时值得付出 TLS 的设置开销以避免昂贵的缓存一致性流量 [@problem_id:3685589]。", "problem": "在对称多处理（SMP）场景中，多个线程在多个处理器上运行，并访问线程本地存储（TLS）或共享的全局变量。您的任务是使用一个基于内存层次结构和概率论的原则性模型，来分析和量化在缓存一致性条件下，线程本地存储与共享全局变量之间的性能权衡。\n\n使用的基础理论：\n- 在对称多处理（SMP）中，所有处理器对内存拥有平等的访问权限，并通过缓存一致性协议来维护一致性。对共享缓存行的写入操作可能会使其他缓存中的副本失效，从而产生额外的延迟。这种增加的延迟将被建模为每次失效事件的惩罚成本。\n- 线程本地存储（TLS）将每个线程的变量映射到不同的内存位置，从而消除了该变量的线程间一致性问题。TLS 可能会有每个线程一次性的初始化成本，用于设置存储空间。\n- 概率论中的期望值：对于一个成功概率为 $p$ 的伯努利随机变量，每次试验的预期惩罚贡献为 $p$ 乘以惩罚的成本。在 $N$ 次相同操作上进行分摊，得到的单次操作开销等于总开销除以 $N$。\n\n定义和假设：\n- 令 $P$ 表示处理器数量。所有处理器都是相同的，并并发运行线程。\n- 每个线程对一个变量（TLS 或共享全局变量）执行 $N$ 次访问。\n- TLS 每个线程有一次性初始化成本 $c_{\\text{init}}$（单位：周期）和稳定的单次访问成本 $c_{\\text{tls}}$（单位：周期）。\n- 共享全局变量访问有稳定的单次访问基础成本 $c_{\\text{shrd}}$（单位：周期）。如果一次访问是写入操作，并且该缓存行的最新有效副本由另一个处理器（远程）持有，则该写入会触发失效和一致性流量，并带来额外的单次访问惩罚 $c_{\\text{coh}}$（单位：周期）。\n- 令 $f_{\\text{write}} \\in [0,1]$ 为写入访问所占的比例。令 $p_{\\text{remote}} \\in [0,1]$ 为一次写入命中由远程处理器拥有的缓存行的概率。对于共享全局变量：\n  - 单次访问的失效概率为 $p_{\\text{inv}} = f_{\\text{write}} \\cdot p_{\\text{remote}}$。\n  - 单次访问的共享成本期望值为 $E_{\\text{shared}} = c_{\\text{shrd}} + p_{\\text{inv}} \\cdot c_{\\text{coh}}$。\n- TLS 通过其设计避免了变量的一致性失效。分摊初始化成本后：\n  - 单次访问的 TLS 成本期望值为 $E_{\\text{tls}} = c_{\\text{tls}} + \\frac{c_{\\text{init}}}{N}$。\n\n您的程序必须为每个测试用例计算：\n- TLS 的单次访问成本期望值 $E_{\\text{tls}}$（单位：周期）。\n- 共享变量的单次访问成本期望值 $E_{\\text{shared}}$（单位：周期）。\n- 单次访问的加速比 $S = \\frac{E_{\\text{shared}}}{E_{\\text{tls}}}$（无单位）。\n- 因使用 TLS 而避免的单次访问一致性流量，量化为 $p_{\\text{inv}}$（无单位的分数）。\n\n所有表示周期数的输出必须以周期为单位。最终的加速比和一致性概率必须表示为小数。\n\n测试套件：\n- 案例 1：$P = 8$, $N = 1000000$, $f_{\\text{write}} = 0.1$, $p_{\\text{remote}} = 0.7$, $c_{\\text{init}} = 2000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n- 案例 2：$P = 1$, $N = 100000$, $f_{\\text{write}} = 0.5$, $p_{\\text{remote}} = 0$, $c_{\\text{init}} = 1000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n- 案例 3：$P = 32$, $N = 10000$, $f_{\\text{write}} = 1$, $p_{\\text{remote}} = 1$, $c_{\\text{init}} = 2000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 200$。\n- 案例 4：$P = 4$, $N = 1$, $f_{\\text{write}} = 0.2$, $p_{\\text{remote}} = 0.5$, $c_{\\text{init}} = 5000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n- 案例 5：$P = 16$, $N = 1000000$, $f_{\\text{write}} = 0.01$, $p_{\\text{remote}} = 0.9$, $c_{\\text{init}} = 2000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表由每个案例的结果列表组成，每个结果列表的形式为 $[E_{\\text{tls}},E_{\\text{shared}},S,p_{\\text{inv}}]$，每个数值的格式都为小数点后恰好六位，并且总输出用方括号括起来。例如：$[[\\dots],[\\dots],\\dots]$。", "solution": "该问题是有效的。它提出了一个定义明确、自成体系且有科学依据的模型，用于分析在对称多处理（SMP）系统中，线程本地存储（TLS）与共享全局变量之间的性能权衡。该模型虽然经过简化，但它基于计算机体系结构的既定原则，包括内存层次结构、缓存一致性以及使用期望值进行性能分析。所有必要的参数都已提供，并且目标也已明确说明。未使用的参数 $P$（处理器数量）的存在是一个上下文细节，不会使模型失效，因为该模型的抽象层次直接使用概率 $p_{\\text{remote}}$。\n\n分析的关键在于计算两种不同内存访问策略的单次访问成本期望值：使用共享全局变量与使用线程本地存储。\n\n首先，我们分析访问共享全局变量的成本。任何访问（读或写）的基础成本都给定为 $c_{\\text{shrd}}$。只有在特定情况下才会产生额外成本 $c_{\\text{coh}}$：该访问必须是写入操作，并且该写入必须使远程处理器持有的相应缓存行副本失效。问题给出了写入访问所占的比例 $f_{\\text{write}}$，以及一次写入使远程缓存行失效的概率 $p_{\\text{remote}}$。由于对于任何给定的访问，这两个条件是独立事件，因此产生一致性惩罚的概率是它们各自概率的乘积。这得出了单次访问的失效概率 $p_{\\text{inv}}$：\n$$p_{\\text{inv}} = f_{\\text{write}} \\cdot p_{\\text{remote}}$$\n这是一个伯努利试验，其中“成功”是一个概率为 $p_{\\text{inv}}$、成本为 $c_{\\text{coh}}$ 的一致性事件。每次访问的预期惩罚值是事件的概率乘以其成本。因此，共享变量的单次访问总成本期望值 $E_{\\text{shared}}$ 是基础成本与预期惩罚成本之和：\n$$E_{\\text{shared}} = c_{\\text{shrd}} + p_{\\text{inv}} \\cdot c_{\\text{coh}}$$\n\n接下来，我们分析使用线程本地存储的成本。根据设计，TLS 为每个线程的变量分配一个唯一的内存位置，从而避免了线程间的数据共享及相关的缓存一致性流量。因此，不存在一致性惩罚 $c_{\\text{coh}}$。访问 TLS 变量的稳定单次访问成本为 $c_{\\text{tls}}$。但是，每个线程初始化其本地存储时存在一次性设置成本 $c_{\\text{init}}$。为了与共享变量的单次访问成本进行公平比较，我们将这个一次性成本分摊到线程执行的总访问次数 $N$ 上。每次访问的分摊初始化成本为 $\\frac{c_{\\text{init}}}{N}$。因此，TLS 的单次访问总成本期望值 $E_{\\text{tls}}$ 为：\n$$E_{\\text{tls}} = c_{\\text{tls}} + \\frac{c_{\\text{init}}}{N}$$\n\n最后，为了比较这两种策略，我们计算加速比 $S$，即共享变量成本与 TLS 成本的比率。当加速比 $S > 1$ 时，表明 TLS 性能更优。\n$$S = \\frac{E_{\\text{shared}}}{E_{\\text{tls}}}$$\n\n$p_{\\text{inv}}$ 本身也是一个有用的度量，它表示如果使用共享变量，会导致一致性流量的内存访问所占的比例。这量化了 TLS 通过其设计所避免的一致性活动量。\n\n现在，我们将这些公式应用于给定的测试用例。\n\n**案例 1：** $N = 1000000$, $f_{\\text{write}} = 0.1$, $p_{\\text{remote}} = 0.7$, $c_{\\text{init}} = 2000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n-   $p_{\\text{inv}} = 0.1 \\cdot 0.7 = 0.07$\n-   $E_{\\text{tls}} = 4 + \\frac{2000}{1000000} = 4 + 0.002 = 4.002$ 周期\n-   $E_{\\text{shared}} = 6 + (0.07 \\cdot 60) = 6 + 4.2 = 10.2$ 周期\n-   $S = \\frac{10.2}{4.002} \\approx 2.548726$\n\n**案例 2：** $N = 100000$, $f_{\\text{write}} = 0.5$, $p_{\\text{remote}} = 0.0$, $c_{\\text{init}} = 1000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n-   $p_{\\text{inv}} = 0.5 \\cdot 0.0 = 0.0$\n-   $E_{\\text{tls}} = 4 + \\frac{1000}{100000} = 4 + 0.01 = 4.01$ 周期\n-   $E_{\\text{shared}} = 6 + (0.0 \\cdot 60) = 6.0$ 周期\n-   $S = \\frac{6.0}{4.01} \\approx 1.496259$\n\n**案例 3：** $N = 10000$, $f_{\\text{write}} = 1.0$, $p_{\\text{remote}} = 1.0$, $c_{\\text{init}} = 2000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 200$。\n-   $p_{\\text{inv}} = 1.0 \\cdot 1.0 = 1.0$\n-   $E_{\\text{tls}} = 4 + \\frac{2000}{10000} = 4 + 0.2 = 4.2$ 周期\n-   $E_{\\text{shared}} = 6 + (1.0 \\cdot 200) = 206.0$ 周期\n-   $S = \\frac{206.0}{4.2} \\approx 49.047619$\n\n**案例 4：** $N = 1$, $f_{\\text{write}} = 0.2$, $p_{\\text{remote}} = 0.5$, $c_{\\text{init}} = 5000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n-   $p_{\\text{inv}} = 0.2 \\cdot 0.5 = 0.1$\n-   $E_{\\text{tls}} = 4 + \\frac{5000}{1} = 5004.0$ 周期\n-   $E_{\\text{shared}} = 6 + (0.1 \\cdot 60) = 6 + 6 = 12.0$ 周期\n-   $S = \\frac{12.0}{5004.0} \\approx 0.002398$\n\n**案例 5：** $N = 1000000$, $f_{\\text{write}} = 0.01$, $p_{\\text{remote}} = 0.9$, $c_{\\text{init}} = 2000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n-   $p_{\\text{inv}} = 0.01 \\cdot 0.9 = 0.009$\n-   $E_{\\text{tls}} = 4 + \\frac{2000}{1000000} = 4 + 0.002 = 4.002$ 周期\n-   $E_{\\text{shared}} = 6 + (0.009 \\cdot 60) = 6 + 0.54 = 6.54$ 周期\n-   $S = \\frac{6.54}{4.002} \\approx 1.634183$", "answer": "```c\n// This program models and compares the performance of thread-local storage (TLS)\n// versus shared global variables in a symmetric multiprocessing (SMP) environment.\n#include", "id": "3685589"}]}