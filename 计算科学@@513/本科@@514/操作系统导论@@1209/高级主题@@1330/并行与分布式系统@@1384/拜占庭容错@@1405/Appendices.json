{"hands_on_practices": [{"introduction": "操作系统如何能信任它接收到的数据？本练习探讨了容错在传感器数据聚合中的一个实际应用，这是系统健康监测中的常见任务。通过实现一个$f$-截尾均值估计器，你将学习如何构建一个鲁棒的系统，即使在一部分传感器提供恶意读数的情况下，也能得出一个可靠的温度估计值 [@problem_id:3625176]。", "problem": "一个操作系统（OS）的风扇控制器使用多个板载热传感器来估算中央处理器（CPU）的温度并设置风扇速度。该系统必须具备拜占庭容错（BFT）能力，其中最多有 $f$ 个传感器可能任意（恶意）行动，而其余的 $n-f$ 个传感器是诚实的。设CPU的真实温度为 $T \\in \\mathbb{R}$。诚实传感器 $i$ 报告的值为 $x_{i} = T + \\varepsilon_{i}$，其中 $|\\varepsilon_{i}| \\leq \\delta$，$\\delta > 0$ 是一个已知的界限。恶意传感器可以不受限制地报告任何实数。\n\n为了聚合这 $n$ 个读数，操作系统使用 $f$-截尾均值估计器：将 $n$ 个报告值排序以获得顺序统计量 $x_{(1)} \\leq x_{(2)} \\leq \\cdots \\leq x_{(n)}$，丢弃最低的 $f$ 个和最高的 $f$ 个值，并计算\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)} \\, ,\n$$\n假设 $n \\geq 2f + 1$ 以使估计器是良定义的。\n\n对手试图在上述约束条件下最大化估计误差。推导绝对误差的紧凑最坏情况上界\n$$\nE = \\sup \\, \\big| \\hat{T} - T \\big| \\, ,\n$$\n该上界应涵盖所有可能的恶意值分配和所有满足 $|\\varepsilon_{i}| \\leq \\delta$ 的诚实噪声实现。将您的最终界限表示为 $n$、$f$ 和 $\\delta$ 的闭式函数。您必须以摄氏度表示该界限。不需要进行数值四舍五入。", "solution": "问题要求绝对估计误差 $E = \\sup \\, \\big| \\hat{T} - T \\big|$ 的紧凑最坏情况上界，其中 $\\hat{T}$ 是真实温度 $T$ 的 $f$-截尾均值估计器。该估计器由下式给出：\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)}\n$$\n该系统由 $n$ 个传感器组成，其中最多有 $f$ 个可能是恶意的（拜占庭式的）并报告任意值。其余的 $n-f$ 个传感器是诚实的，报告值为 $x_i = T + \\varepsilon_i$，其中噪声 $\\varepsilon_i$ 的界限为 $|\\varepsilon_i| \\leq \\delta$。该分析受限于条件 $n \\geq 2f + 1$。\n\n绝对误差为 $|\\hat{T} - T|$。为了找到其上确界，我们可以分析偏差 $\\hat{T} - T$ 的最大和最小可能值。由于问题的对称性（恶意传感器可以报告任意高或低的值，且诚实误差界 $|\\varepsilon_i| \\le \\delta$ 关于0对称），最大正误差 $\\sup(\\hat{T}-T)$ 的大小将与最大负误差 $\\sup(T-\\hat{T})$ 的大小相同。我们将专注于寻找 $\\hat{T}$ 的最大可能值。\n\n让我们分析估计器求和中可能出现的值的范围。求和是针对从 $f+1$ 到 $n-f$ 的顺序统计量 $x_{(i)}$。我们将证明，无论恶意传感器报告什么值，任何这样的值 $x_{(i)}$ 都必须位于区间 $[T-\\delta, T+\\delta]$ 内。\n\n首先，让我们为平均窗口中的任何值 $x_{(i)}$ 建立一个上界。平均值中包含的最大值是 $x_{(n-f)}$。考虑最大的 $f+1$ 个报告值集合：$\\{x_{(n-f)}, x_{(n-f+1)}, \\dots, x_{(n)}\\}$。根据顺序统计量的定义，此集合中的所有值都大于或等于 $x_{(n-f)}$。这个集合包含 $f+1$ 个传感器读数。由于只有 $f$ 个恶意传感器，这 $f+1$ 个读数中至少有一个必须来自诚实传感器。设这个诚实读数为 $x_{h}$。对于这个诚实读数，我们知道 $x_{h} = T + \\varepsilon_{h}$ 且 $\\varepsilon_{h} \\leq \\delta$，所以 $x_{h} \\leq T + \\delta$。\n由于 $x_{h}$ 在集合 $\\{x_{(n-f)}, \\dots, x_{(n)}\\}$ 中，我们有 $x_{h} \\geq x_{(n-f)}$。\n结合这些不等式得出 $x_{(n-f)} \\leq x_{h} \\leq T + \\delta$。\n由于 $x_{(n-f)}$ 是平均窗口中的最大值，因此对于任何 $i \\in \\{f+1, \\dots, n-f\\}$，我们有 $x_{(i)} \\leq x_{(n-f)} \\leq T + \\delta$。\n\n其次，让我们用对称的论证来建立一个下界。平均值中包含的最小值是 $x_{(f+1)}$。考虑最小的 $f+1$ 个报告值集合：$\\{x_{(1)}, x_{(2)}, \\dots, x_{(f+1)}\\}$。此集合中的所有值都小于或等于 $x_{(f+1)}$。这个集合也包含 $f+1$ 个传感器读数。根据鸽巢原理，这些读数中至少有一个必须来自诚实传感器。设这个诚实读数为 $x_{h'}$。对于这个读数，$x_{h'} = T + \\varepsilon_{h'}$ 且 $\\varepsilon_{h'} \\geq -\\delta$，所以 $x_{h'} \\geq T - \\delta$。\n由于 $x_{h'}$ 在集合 $\\{x_{(1)}, \\dots, x_{(f+1)}\\}$ 中，我们有 $x_{h'} \\leq x_{(f+1)}$。\n结合这些得出 $x_{(f+1)} \\geq x_{h'} \\geq T - \\delta$。\n由于 $x_{(f+1)}$ 是平均窗口中的最小值，因此对于任何 $i \\in \\{f+1, \\dots, n-f\\}$，我们有 $x_{(i)} \\geq x_{(f+1)} \\geq T - \\delta$。\n\n我们已经证明，对于求和范围内的任何索引 $i$，$f+1 \\leq i \\leq n-f$，相应的顺序统计量 $x_{(i)}$ 的界限为\n$$\nT - \\delta \\leq x_{(i)} \\leq T + \\delta\n$$\n这对于任何可能的恶意值集合和任何有效的诚实传感器噪声实现都成立。\n\n现在，我们可以界定估计器 $\\hat{T}$。使用和中每一项的上界：\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)} \\leq \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} (T + \\delta)\n$$\n和中的项数为 $(n-f) - (f+1) + 1 = n-2f$。\n$$\n\\hat{T} \\leq \\frac{1}{n - 2f} (n - 2f)(T + \\delta) = T + \\delta\n$$\n类似地，使用每一项的下界：\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)} \\geq \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} (T - \\delta) = T - \\delta\n$$\n结合这些结果，我们发现估计值 $\\hat{T}$ 总是包含在区间 $[T - \\delta, T + \\delta]$ 内。这意味着绝对误差的界限为：\n$$\n|\\hat{T} - T| \\leq \\delta\n$$\n这表明 $\\sup \\, |\\hat{T}-T| \\le \\delta$。\n\n为了证明这个界限是紧凑的，我们必须构造一个最坏情况的场景，在该场景中误差恰好为 $\\delta$。对手的目标是最大化误差，这涉及到选择 $f$ 个恶意值，并在所有可能的诚实噪声实现 $|\\varepsilon_i| \\le \\delta$ 上进行最大化。为了最大化 $\\hat{T}-T$，对手可以采用以下策略：\n1. 将所有 $n-f$ 个诚实传感器的噪声设置为其最大可能值 $\\varepsilon_i = +\\delta$。这使得所有诚实传感器都报告值 $T+\\delta$。\n2. 将所有 $f$ 个恶意传感器的值设置为某个小于任何诚实读数的值，例如，报告一个非常大的负数（或任何小于 $T+\\delta$ 的值）。一个简单的选择是让它们报告 $T-\\delta$。\n\n那么，$n$ 个传感器读数的集合是 $\\{T-\\delta, \\dots, T-\\delta\\}$（$f$ 次）和 $\\{T+\\delta, \\dots, T+\\delta\\}$（$n-f$ 次）。排序后的读数列表 $x_{(1)} \\leq x_{(2)} \\leq \\cdots \\leq x_{(n)}$ 将是：\n$$\nx_{(1)} = \\cdots = x_{(f)} = T - \\delta\n$$\n$$\nx_{(f+1)} = \\cdots = x_{(n)} = T + \\delta\n$$\n估计器 $\\hat{T}$ 对从 $x_{(f+1)}$ 到 $x_{(n-f)}$ 的值进行平均。在这种情况下，所有这些值都等于 $T+\\delta$。\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} (T + \\delta) = \\frac{1}{n - 2f} (n-2f)(T+\\delta) = T + \\delta\n$$\n对于这种情况，估计误差为 $\\hat{T} - T = (T+\\delta) - T = \\delta$。\n通过对称的论证（将诚实噪声设置为 $-\\delta$ 并将恶意值设置为一个非常大的正数），可以实现 $-\\delta$ 的误差。\n\n由于绝对误差 $|\\hat{T} - T|$ 总是小于或等于 $\\delta$，并且我们已经展示了一个它恰好等于 $\\delta$ 的场景，所以绝对误差的紧凑最坏情况上界（上确界）是 $\\delta$。问题陈述该界限应以摄氏度表示，这是 $\\delta$ 的单位。", "answer": "$$\\boxed{\\delta}$$", "id": "3625176"}, {"introduction": "分布式系统中安全共识的基础在于法定人数（quorum）的概念。本练习挑战你从理论走向实践，首先从集合论的第一性原理推导出最小安全法定人数的大小。然后，你将应用这些知识来模拟一个拜占庭容错的检查点服务，以确定一个分布式系统在休眠前是否能安全地就单一状态达成一致 [@problem_id:3625121]。", "problem": "您将处理一个受操作系统休眠启发的场景：在进入低功耗状态之前，一个分布式检查点服务必须就一个要持久化的内存映像摘要达成一致。\n\n该系统在多个节点上进行复制，并且必须能够容忍拜占庭故障。共识是在已签名的内存映像摘要（表示为 $h$，每个提议的映像对应一个）上执行的。您的任务是编写一个程序，基于拜占庭故障下仲裁规则的集合论推导，来模拟是否可以达成安全共识，如果可以，将选择哪个摘要。\n\n请使用以下纯粹以逻辑和数学术语陈述的基本原理：\n\n- 拜占庭容错（BFT）意味着最多有 $f$ 个节点可以任意行动。系统总共有 $n$ 个节点。正确的节点遵循协议规则，包括在给定的决策轮次中最多为一个摘要签名。\n- 接受规则要求对单个摘要有仲裁数量的签名。如果一个签名在语法上是正确的，并且附加到目标摘要 $h$ 上，则该签名被认为是有效的；否则它是无效的。在本模拟中，有效性是为每个签名在测试用例中提供的一个布尔谓词。\n- 仲裁大小，表示为 $t$，必须被选择以在以下约束条件下保证安全性和活性：\n  1. 安全性：任何两个不同的摘要 $h_a \\neq h_b$ 都不能同时被正确的节点接受。等价地，任何两个针对不同摘要的仲裁必须在至少一个正确的节点上相交，因为正确的节点每轮最多为一个摘要签名。\n  2. 活性：如果最多有 $f$ 个节点是拜占庭节点，那么只要存在足够多的正确签名，正确的节点就能形成一个接受摘要的仲裁。\n- 集合论基础：对于一个包含 $n$ 个节点的全体，任何两个大小为 $t$ 的子集的交集大小至少为 $2t - n$。由于最多有 $f$ 个节点可以是拜占庭节点，要保证交集包含至少一个正确节点，就需要交集的大小超过 $f$。\n\n您的程序必须：\n1. 使用上述约束和集合论事实，从 $n$ 和 $f$ 推导出最小整数仲裁大小 $t$，而不依赖任何预先给定的快捷公式。\n2. 验证签名，对每个摘要只计算有效且不同的签名者，并强制每个正确的节点在本轮中最多为一个摘要签名。\n3. 确定是否有一个唯一的摘要是可安全接受的。如果一个摘要 $h$ 收集了至少 $t$ 个有效签名，并且没有其他摘要同时达到该数量，那么该摘要是可接受的；如果超过一个摘要达到或超过 $t$，或者一个正确的节点为多个摘要签名，或者该配置对于拜占庭容错是不可行的，那么就无法达成安全共识。\n4. 生成最终答案，形式为一行，其中包含一个用方括号括起来的逗号分隔的整数列表，每个测试用例对应一个整数。如果可以安全地达成共识，则该整数是接受的摘要标识符 $h$；如果无法达成安全共识，则为 $-1$。\n\n可行性检查：拜占庭容错的一个经典充分可行性条件是 $n \\geq 3f + 1$。如果某个测试用例不满足此条件，程序必须为该用例返回 $-1$。\n\n测试套件规范（所有标识符和计数均为整数，所有集合均为有限集；对于每个数学实体，数字都用 LaTeX 包装）：\n- 测试用例 $1$ (正常路径):\n  - $n=7$, $f=2$, 正确节点 $\\{0,1,2,3,4\\}$。\n  - 摘要:\n    - $h=101$ 有效签名者 $\\{0,1,2,3,4,5\\}$, 全部有效。\n    - $h=202$ 签名者 $\\{5,6\\}$ 其中节点 $5$ 有效，节点 $6$ 无效。\n  - 预期行为: 只有 $h=101$ 达到仲裁数量；接受 $101$。\n- 测试用例 $2$ (边界可行性):\n  - $n=4$, $f=1$, 正确节点 $\\{0,1,2\\}$。\n  - 摘要:\n    - $h=303$ 有效签名者 $\\{0,1,2\\}$, 全部有效。\n  - 预期行为: 接受 $303$。\n- 测试用例 $3$ (正确节点双重签名导致安全性失效):\n  - $n=7$, $f=2$, 正确节点 $\\{0,1,2,3,4\\}$。\n  - 摘要:\n    - $h=404$ 有效签名者 $\\{0,1,2,3,5\\}$, 全部有效。\n    - $h=505$ 有效签名者 $\\{0,1,2,4,6\\}$, 全部有效。\n  - 预期行为: 正确节点 $0,1,2$ 为两个摘要签名；拒绝共识并返回 $-1$。\n- 测试用例 $4$ (不可行的配置):\n  - $n=6$, $f=2$, 正确节点 $\\{0,1,2,3\\}$。\n  - 摘要:\n    - $h=606$ 有效签名者 $\\{0,1,2,3,4\\}$, 全部有效。\n  - 预期行为: 由于 $n  3f + 1$ (即 $6  7$), 返回 $-1$。\n- 测试用例 $5$ (签名不足):\n  - $n=7$, $f=2$, 正确节点 $\\{0,1,2,3,4\\}$。\n  - 摘要:\n    - $h=707$ 签名者 $\\{0,1,2,3\\}$, 其中节点 $0,1,2$ 有效，节点 $3$ 无效，只剩下 $3$ 个有效签名。\n  - 预期行为: 没有摘要达到仲裁数量；返回 $-1$。\n- 测试用例 $6$ (拜占庭节点含糊其辞但仲裁唯一):\n  - $n=10$, $f=3$, 正确节点 $\\{0,1,2,3,4,5,6\\}$。\n  - 摘要:\n    - $h=808$ 有效签名者 $\\{0,1,2,3,4,5,7\\}$, 全部有效。\n    - $h=909$ 有效签名者 $\\{7,8,9,6\\}$, 全部有效。\n    - $h=1000$ 有效签名者 $\\{8,9\\}$, 全部有效。\n  - 预期行为: 只有 $h=808$ 满足仲裁数量；接受 $808$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,\\dots]$）。对于上述测试套件，程序必须按顺序输出每个用例接受的摘要标识符或 $-1$。", "solution": "该问题要求设计一个模拟，以确定在一个受拜占庭故障影响的分布式系统中，是否能就内存摘要达成安全共识。解决方案源自拜占庭容错（BFT）的第一性原理，特别关注仲裁的集合论属性。\n\n为每个测试用例确定结果的过程基于一系列验证步骤和计算，这些步骤和计算植根于已有的 BFT 理论。\n\n**步骤 1：系统可行性条件**\n\n系统由总共 $n$ 个节点描述，其中最多有 $f$ 个可能是拜占庭节点。一个广泛确立的、使系统能够在存在 $f$ 个拜占庭故障的情况下解决共识问题的充分条件是，节点总数 $n$ 必须至少为 $3f + 1$。这由不等式表达：\n$$n \\ge 3f + 1$$\n这个条件确保了在 $f$ 个节点被发现是故障节点后，剩余的 $n-f$ 个正确节点的数量足够多（$n-f \\ge 2f+1$），能够压倒可能说谎并创建两个大小为 $f$ 的对立派系的故障节点。问题陈述中指出，如果给定的测试用例不满足此可行性条件，则无法达成安全共识，结果必须为 $-1$。\n\n**步骤 2：最小仲裁大小（$t$）的推导**\n\nBFT 安全性的核心在于确保两个相互冲突的提案（例如，针对不同的摘要 $h_a$ 和 $h_b$）永远不能被系统同时接受。接受一个摘要 $h$ 定义为从不同的节点收集到至少 $t$ 个有效签名的仲裁。\n\n设 $Q_a$ 是为摘要 $h_a$ 签名的节点集合，$Q_b$ 是为摘要 $h_b$ 签名的节点集合。为了使两个摘要都被接受，这些集合的大小必须满足仲裁阈值：$|Q_a| \\ge t$ 和 $|Q_b| \\ge t$。在我们的推导中，我们考虑最小情况，即 $|Q_a| = t$ 和 $|Q_b| = t$。\n\n安全性属性要求不可能为相互冲突的摘要形成两个仲裁。根据定义，一个正确的节点在每个决策轮次中最多为一个摘要签名。因此，如果任何两个潜在仲裁的交集 $Q_a \\cap Q_b$ 被保证包含至少一个正确的节点，那么安全性就得到了保障。如果一个正确的节点处于交集中，它将被要求为 $h_a$ 和 $h_b$ 两者签名。它会签署其中一个但拒绝另一个，从而阻止其中一个仲裁的形成。\n\n对于安全性而言，最坏的情况是交集 $Q_a \\cap Q_b$ 完全由拜占庭节点组成。系统中最多有 $f$ 个拜占庭节点。为了保证交集至少包含一个正确的节点，其大小必须严格大于 $f$。\n$$|Q_a \\cap Q_b|  f$$\n根据集合论，两个集合交集的大小受容斥原理的限制。对于一个包含 $n$ 个节点的全体：\n$$|Q_a \\cap Q_b| \\ge |Q_a| + |Q_b| - n$$\n将 $|Q_a| = t$ 和 $|Q_b| = t$ 代入，我们得到：\n$$|Q_a \\cap Q_b| \\ge 2t - n$$\n结合这两个不等式来强制执行安全性要求，得出：\n$$2t - n  f$$\n求解仲裁大小 $t$：\n$$2t  n + f$$\n$$t  \\frac{n+f}{2}$$\n由于 $t$ 必须是一个整数（代表节点计数），满足此严格不等式的最小整数 $t$ 值可以通过对右侧进行向下取整并加 1 得到。\n$$t = \\left\\lfloor \\frac{n+f}{2} \\right\\rfloor + 1$$\n这个公式提供了安全接受一个摘要所需的最少签名数。\n\n**步骤 3：达成共识的算法过程**\n\n基于以上原则，可以制定一个确定性算法来评估每个测试用例。\n\n1.  **可行性检查**：对于给定的参数 $n$ 和 $f$，首先验证是否 $n \\ge 3f + 1$。如果此条件为假，则系统不可行。该用例的程序终止，结果为 $-1$。\n\n2.  **仲裁计算**：如果系统可行，则使用推导出的公式计算最小整数仲裁大小 $t$：$t = \\lfloor \\frac{n+f}{2} \\rfloor + 1$。\n\n3.  **签名验证和正确性检查**：\n    a. 初始化数据结构以跟踪每个提议摘要的有效签名数量，并监控正确节点的签名活动。\n    b. 对于每个摘要，遍历其签名者列表。只有当签名被标记为有效时，才会计数。\n    c. 同时，检查正确节点的协议违规行为。一个正确的节点最多只能为一个摘要签名。如果发现一个被识别为正确的节点为两个或更多不同的摘要提供了有效签名，这构成了严重的安全故障。该用例的程序终止，结果为 $-1$。根据定义，拜占庭节点被允许含糊其辞（签署多个摘要）。\n\n4.  **确定最终结果**：\n    a. 在处理完所有签名并确认没有正确的节点进行双重签名后，确定哪些摘要（如果有的话）已达到仲裁阈值 $t$。\n    b. 令 $S$ 为已累积至少 $t$ 个有效签名的摘要集合。\n    c. 如果此集合的大小恰好为一，即 $|S| = 1$，则已达成唯一、安全的共识。结果是 $S$ 中单个摘要的标识符 $h$。\n    d. 如果集合的大小为零，即 $|S| = 0$，则没有摘要获得足够的支持。\n    e. 如果集合的大小大于一，即 $|S|  1$，则有两个或更多摘要达到了仲裁阈值，导致了违反安全性的模糊性。\n    f. 在 $|S| \\neq 1$ 的两种情况下，都不可能达成安全共识，结果为 $-1$。\n\n这个结构化的过程确保了问题中规定的所有拜占庭容错共识条件都得到严格检查，从而为每个场景得出一个明确的结论。", "answer": "[101, 303, -1, -1, -1, 808]", "id": "3625121"}, {"introduction": "在基于法定人数共识的基础上，本实践探讨了系统崩溃后恢复一致状态的动态挑战。你将为一个复制的操作系统日志实现一个验证机制，以防御试图重放陈旧条目的拜占庭节点。这项任务要求你不仅要强制执行法定人数规则，还要保证周期（epoch）一致性和日志的连续性，从而展示拜占庭容错原理如何保障有状态服务的安全 [@problem_id:3625120]。", "problem": "设计并实现一个完整的程序，该程序在一个使用拜占庭容错（BFT）的复制操作系统日志服务中，检测崩溃后对陈旧日志条目的拜占庭重放。该日志在 $n$ 个节点间复制，其中最多 $f$ 个节点可能是拜占庭节点（任意故障）。系统在恢复阶段使用法定人数签名的重放证明来验证条目。\n\n需要使用的基本和核心定义：\n- 拜占庭容错（BFT）要求，为保证在任意故障下的安全性，系统至少有 $n \\ge 3f+1$ 个节点，并使用大小为 $q \\ge 2f+1$ 的法定人数，以确保法定人数交集至少包含 $f+1$ 个诚实节点。\n- 在时期 $e$ 中索引为 $k$ 的已提交日志条目必须得到该时期内来自不同节点的法定人数签名背书，即重放证明至少包含 $q$ 个与时期 $e$ 和条目索引 $k$ 相关的不同节点的签名。\n- 稳定索引 $i$ 是所有非故障节点一致认为在崩溃前已持久化提交的最后一个索引。\n- 时期（也称为视图）$e$ 是一个用于基于领导者轮次的单调递增标识符；在此模型中，只有来自当前时期 $e_{\\mathrm{cur}}$ 的证明才可用于恢复。\n- 崩溃后，恢复过程必须重建一个从 $i+1$ 严格开始的连续的已提交条目后缀。任何间隙或乱序重放都将被拒绝，以保持日志的连续性。\n\n假设在 BFT 模型中以下事实已经过充分测试：\n- 当 $n \\ge 3f+1$ 且 $q \\ge 2f+1$ 时，任何两个大小为 $q$ 的法定人数在至少 $f+1$ 个节点上相交，这保证了任何交集中至少有一个诚实节点，并在正确验证的情况下防止跨时期的冲突提交。\n- 来自恶意节点、带有旧时期 $e \\ne e_{\\mathrm{cur}}$ 证明的陈旧重放不会被接受，因为交集中的诚实节点在当前恢复下不会为旧时期签名。\n\n您的程序必须基于这些原则实现以下决策逻辑：\n- 如果 $n  3f+1$ 或 $q  2f+1$，则配置对于 BFT 恢复是不安全的；该测试用例输出一个哨兵值 $-1$。\n- 否则，从稳定索引 $i$ 和预期的下一个索引 $i+1$ 开始。\n- 给定一个来自潜在恶意节点的重放条目序列。每个条目是一个元组 $(k, e_k, s_k)$，其中 $k$ 是条目索引，$e_k$ 是重放证明所声称的时期，$s_k$ 是证明中不同签名的数量。\n- 仅当以下所有条件同时成立时，才接受一个条目：\n  1. $e_k = e_{\\mathrm{cur}}$，\n  2. $s_k \\ge q$，\n  3. 在评估时刻 $k = i+1$（即，预期的下一个索引）。\n- 当一个条目被接受时，将稳定索引更新为 $k$，并增加预期的下一个索引。不满足所有条件的条目将被忽略。索引为 $i$ 的条目被认为是陈旧的，不得被重新提交。\n\n在按给定顺序处理完所有重放条目后，输出该测试用例的最终稳定索引。如果根据第一条规则配置不安全，则输出 $-1$。\n\n实现此程序以处理以下测试套件。对于每个测试用例，参数和重放条目都已明确指定：\n\n- 测试用例 1 (快乐路径法定人数接受)：\n  - $n=7$, $f=2$, $q=5$, $i=10$, $e_{\\mathrm{cur}}=3$,\n  - 重放条目: $(11, 3, 5)$, $(12, 3, 5)$, $(13, 3, 4)$。\n- 测试用例 2 (边界处的时期不匹配造成间隙，从而阻塞后续条目)：\n  - $n=7$, $f=2$, $q=5$, $i=20$, $e_{\\mathrm{cur}}=4$,\n  - 重放条目: $(21, 3, 5)$, $(22, 4, 5)$, $(23, 4, 5)$。\n- 测试用例 3 (因法定人数规模不足导致配置不安全)：\n  - $n=7$, $f=2$, $q=4$, $i=5$, $e_{\\mathrm{cur}}=1$,\n  - 重放条目: $(6, 1, 4)$, $(7, 1, 4)$。\n- 测试用例 4 (乱序重放；仅接受从 $i+1$ 开始的连续条目)：\n  - $n=7$, $f=2$, $q=5$, $i=7$, $e_{\\mathrm{cur}}=2$,\n  - 重放条目: $(9, 2, 5)$, $(8, 2, 5)$, $(10, 2, 5)$。\n- 测试用例 5 (拒绝了 $i$ 的陈旧副本；接受了来自当前时期的后续有效条目)：\n  - $n=7$, $f=2$, $q=5$, $i=15$, $e_{\\mathrm{cur}}=6$,\n  - 重放条目: $(15, 6, 5)$, $(16, 6, 5)$, $(17, 5, 5)$, $(17, 6, 5)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。该列表必须按顺序包含每个测试用例的最终稳定索引（一个整数）。对于不安全的配置，请在相应位置包含 $-1$。例如，输出格式必须与 $[r_1,r_2,r_3,r_4,r_5]$ 完全一样，其中每个 $r_j$ 是测试用例 $j$ 的整数结果。", "solution": "该问题要求设计并实现一个基于 BFT 的算法，用于在复制操作系统的恢复阶段验证重放的日志条目。解决方案必须严格遵守所提供的拜占庭容错原则。\n\n问题的核心在于确保在一个总共有 $n$ 个副本的系统中，能够抵御数量有限的拜占庭（任意恶意的）节点（以 $f$ 表示）的攻击。所提供的安全性条件是许多 BFT 协议的基础：\n1. 系统规模：副本总数 $n$ 必须至少为 $3f+1$。这个条件 $n \\ge 3f+1$ 确保了即使有 $f$ 个节点是拜占庭节点，剩下的 $2f+1$ 个诚实节点也足以在投票中超过它们，从而达成正确的共识。\n2. 法定人数规模：操作必须由一个大小为 $q$ 的节点法定人数进行验证。该法定人数的规模必须至少为 $2f+1$。这个条件 $q \\ge 2f+1$ 至关重要，因为它保证了任何两个法定人数的交集至少包含一个诚实节点。具体来说，从 $n$ 个节点集合中选出的两个大小为 $q$ 的法定人数，其交集大小至少为 $2q-n$。给定 $n \\ge 3f+1$ 和 $q \\ge 2f+1$，这个交集至少为 $q-(n-q) = 2q-n$。一个更好的论证是：不在第一个法定人数中的节点数量为 $n-q \\le (3f+1)-(2f+1)=f$。第二个法定人数必须从第一个法定人数中抽取至少 $q-(n-q) = 2q-n$ 个节点。进一步，第二个法定人数必须从第一个法定人数中抽取至少 $q-f \\ge (2f+1)-f = f+1$ 个节点。这个大小至少为 $f+1$ 的交集必须包含至少一个诚实节点，因为最多只有 $f$ 个故障节点。这个非故障的交集可以防止系统提交冲突的状态。\n\n用于验证给定测试用例的算法流程如下。\n\n_步骤 1：配置验证_\n首先，我们根据已建立的 BFT 安全性要求评估系统的配置参数 $(n, f, q)$。\n- 如果 $n  3f+1$ 或 $q  2f+1$，系统无法保证能抵御 $f$ 个拜占庭故障。任何恢复尝试都将是根本不安全的，因为可能会提交冲突的状态。在这种情况下，算法必须立即终止对该测试用例的处理，并通过返回哨兵值 $-1$ 将其报告为无效。\n\n_步骤 2：初始化_\n如果配置有效，则初始化恢复过程。我们定义一个状态变量 `current_stable_index`，并将其初始化为测试用例中提供的最后一个已知的稳定索引 $i$。算法的目标是通过验证和应用新的日志条目来推进该索引。恢复过程必须是连续的，因此我们定义一个 `expected_next_index` 为 `current_stable_index` $+ 1$。\n\n_步骤 3：顺序处理条目_\n算法按提供的顺序逐一处理给定的重放条目序列。对于每个由元组 $(k, e_k, s_k)$ 表示的条目（其中 $k$ 是日志索引，$e_k$ 是其证明的时期，$s_k$ 是其证明中的签名数量），会执行一个三部分的验证检查。一个条目当且仅当以下所有三个条件同时为真时才被接受：\n1. 时期正确性：$e_k = e_{\\mathrm{cur}}$。证明必须属于当前的恢复时期 $e_{\\mathrm{cur}}$。这可以防止拜占庭节点重放来自旧时期的有效条目，从而导致状态回滚或不一致。诚实节点只会为当前时期的消息签名。\n2. 法定人数支持：$s_k \\ge q$。条目的证明必须得到足够数量的签名支持，以形成一个有效的法定人数。这确保了提交该条目的决定得到了系统绝大多数的支持。\n3. 日志连续性：$k = \\text{expected\\_next\\_index}$。条目的索引 $k$ 必须紧跟在当前稳定索引之后。此规则对于维护一个连续、无间隙的日志至关重要，这对于确定性状态机复制是必不可少的。任何乱序或重复的条目都将被拒绝。\n\n_步骤 4：状态更新_\n如果一个条目通过了所有三个验证检查，它就被视为已接受。然后更新恢复过程的状态：\n- `current_stable_index` 被推进到已接受条目的索引 $k$。\n- `expected_next_index` 递增，为日志中的下一个条目做准备。\n如果一个条目未能通过任何验证检查，它将被忽略，状态（`current_stable_index` 和 `expected_next_index`）保持不变。然后算法继续处理序列中的下一个条目。\n\n_步骤 5：最终确定_\n在处理完所有提供的重放条目后，`current_stable_index` 的最终值表示可以被安全重建的最高连续日志索引。这个最终值就是该测试用例的结果。\n\n这种对 BFT 原则的系统性应用确保了即使在存在恶意行为者的情况下，日志恢复过程也是鲁棒、安全的，并维护了复制状态机的完整性。", "answer": "[12, 20, -1, 8, 17]", "id": "3625120"}]}