{"hands_on_practices": [{"introduction": "虽然逻辑时钟是分布式系统中的一个核心概念，但在许多现实应用中，对物理时钟进行同步仍然至关重要。Cristian 算法提供了一种简单直观的物理时钟同步方法，但其准确性会受到网络延迟不对称性的影响。这个练习将引导你从第一性原理出发，推导在这种不对称情况下的同步误差，从而让你深刻理解理想化算法与实际网络环境之间的差距。[@problem_id:3688987]", "problem": "一个客户端进程 $C$ 试图在现实的网络不对称性下，使用 Cristian 算法将其本地物理时钟与一个参考服务器 $S$ 同步。设 $d_{\\text{forward}}$ 为从 $C$ 到 $S$ 的单向网络延迟，$d_{\\text{backward}}$ 为从 $S$ 到 $C$ 的单向网络延迟，并设 $p$ 为服务器从接收请求到发送回复的处理时间。客户端测得该次交换的往返时间 (RTT) 为 $r$，并根据 Cristian 算法，将其时钟设置为服务器的发送时间加上测得的往返时间的一半。假设两个时钟以相同的速率运行，并且服务器在发送回复的瞬间为其添加时间戳。\n\n从第一性原理出发——具体来说，即单向传播延迟、服务器处理时间和 Cristian 算法操作规则的定义——推导当 $d_{\\text{forward}} \\neq d_{\\text{backward}}$ 时产生的同步误差表达式，然后使用该表达式，根据在某次特定运行中观察到的以下约束条件，计算绝对误差的最坏情况界限：\n- 测得的往返时间 $r = 96.0$ 毫秒，\n- 服务器处理时间 $p = 1.2$ 毫秒，\n- 前向延迟 $d_{\\text{forward}} \\in [21.0, 29.0]$ 毫秒，\n- 后向延迟 $d_{\\text{backward}} \\in [60.0, 72.0]$ 毫秒。\n\n假设对于此次交换，实际延迟满足 $d_{\\text{forward}} + d_{\\text{backward}} = r - p$。将你的最终答案表示为最大可能绝对同步误差（以毫秒为单位），并将你的答案四舍五入到三位有效数字。", "solution": "本题要求在网络不对称的情况下，推导 Cristian 算法中的同步误差，并根据给定的约束条件计算其最坏情况下的界限。\n\n首先，我们基于一个参考物理时间 $t$ 建立一个事件时间线。设服务器时钟 $S$ 为参考，因此其时间为 $S(t) = t$。客户端进程为 $C$。\n事件序列如下：\n1.  在时刻 $t_0$，客户端 $C$ 向服务器 $S$ 发送一个同步请求。\n2.  请求在时刻 $t_1 = t_0 + d_{\\text{forward}}$ 到达 $S$，其中 $d_{\\text{forward}}$ 是从 $C$ 到 $S$ 的单向延迟。\n3.  服务器处理该请求，耗时 $p$。然后在发送回复的瞬间为其添加时间戳。这发生在时刻 $t_2 = t_1 + p = t_0 + d_{\\text{forward}} + p$。发送回客户端的时间戳为 $T_S = S(t_2) = t_2$。\n4.  回复在时刻 $t_3 = t_2 + d_{\\text{backward}} = t_0 + d_{\\text{forward}} + p + d_{\\text{backward}}$ 返回到客户端，其中 $d_{\\text{backward}}$ 是从 $S$ 到 $C$ 的单向延迟。\n\n客户端测量的总往返时间 ($r$) 是从发送请求 ($t_0$) 到接收回复 ($t_3$) 之间的时间间隔。\n$$r = t_3 - t_0 = (t_0 + d_{\\text{forward}} + p + d_{\\text{backward}}) - t_0 = d_{\\text{forward}} + p + d_{\\text{backward}}$$\n该关系与问题中给出的约束 $d_{\\text{forward}} + d_{\\text{backward}} = r - p$ 一致。\n\n根据所述的 Cristian 算法的具体实现，客户端在时刻 $t_3$ 收到回复后，将其时钟设置为一个新值 $T_{\\text{new}}$：\n$$T_{\\text{new}} = T_S + \\frac{r}{2}$$\n同步误差，我们用 $\\epsilon$ 表示，是新设置的客户端时间与真实物理时间 $t_3$ 之间的差值。\n$$\\epsilon = T_{\\text{new}} - t_3$$\n我们可以用 $T_S$ (即 $t_2$) 和 $d_{\\text{backward}}$ 来表示 $t_3$，即 $t_3 = t_2 + d_{\\text{backward}} = T_S + d_{\\text{backward}}$。将此代入误差方程：\n$$\\epsilon = \\left(T_S + \\frac{r}{2}\\right) - (T_S + d_{\\text{backward}}) = \\frac{r}{2} - d_{\\text{backward}}$$\n为了得到一个用基本延迟和处理时间表示的表达式，我们代入 $r = d_{\\text{forward}} + p + d_{\\text{backward}}$：\n$$\\epsilon = \\frac{1}{2}(d_{\\text{forward}} + p + d_{\\text{backward}}) - d_{\\text{backward}}$$\n简化此表达式可得到同步误差：\n$$\\epsilon = \\frac{1}{2}(d_{\\text{forward}} + p - d_{\\text{backward}})$$\n这就是同步误差的一般表达式。\n\n接下来，我们必须使用给定的约束条件计算绝对误差 $|\\epsilon|$ 的最坏情况界限：\n- 测得的 RTT：$r = 96.0$ 毫秒\n- 服务器处理时间：$p = 1.2$ 毫秒\n- 前向延迟：$d_{\\text{forward}} \\in [21.0, 29.0]$ 毫秒\n- 后向延迟：$d_{\\text{backward}} \\in [60.0, 72.0]$ 毫秒\n\n这些参数通过以下条件相关联：\n$$d_{\\text{forward}} + d_{\\text{backward}} = r - p = 96.0 - 1.2 = 94.8 \\text{ ms}$$\n为了找到 $|\\epsilon|$ 的最大值，我们首先找到 $\\epsilon$ 的可能范围。我们可以将 $\\epsilon$ 表示为单个变量（例如 $d_{\\text{forward}}$）的函数。根据和的约束，我们有 $d_{\\text{backward}} = 94.8 - d_{\\text{forward}}$。将此代入误差公式：\n$$\\epsilon(d_{\\text{forward}}) = \\frac{1}{2}(d_{\\text{forward}} + p - (94.8 - d_{\\text{forward}})) = \\frac{1}{2}(2d_{\\text{forward}} + p - 94.8)$$\n代入 $p = 1.2$：\n$$\\epsilon(d_{\\text{forward}}) = \\frac{1}{2}(2d_{\\text{forward}} + 1.2 - 94.8) = \\frac{1}{2}(2d_{\\text{forward}} - 93.6) = d_{\\text{forward}} - 46.8$$\n$d_{\\text{forward}}$ 的允许值范围由其给定区间与 $d_{\\text{backward}}$ 约束所隐含的区间的交集决定。\n显式约束是 $d_{\\text{forward}} \\in [21.0, 29.0]$。\n$d_{\\text{backward}} \\in [60.0, 72.0]$ 的约束意味着：\n$$60.0 \\le 94.8 - d_{\\text{forward}} \\le 72.0$$\n从所有部分减去 $94.8$：\n$$60.0 - 94.8 \\le -d_{\\text{forward}} \\le 72.0 - 94.8$$\n$$-34.8 \\le -d_{\\text{forward}} \\le -22.8$$\n乘以 $-1$ 并反转不等号：\n$$22.8 \\le d_{\\text{forward}} \\le 34.8$$\n$d_{\\text{forward}}$ 的有效范围是两个区间的交集：$[21.0, 29.0] \\cap [22.8, 34.8]$，即 $[22.8, 29.0]$。\n所以，$d_{\\text{forward}}$ 必须在 $[22.8, 29.0]$ 的范围内。\n\n误差函数 $\\epsilon(d_{\\text{forward}}) = d_{\\text{forward}} - 46.8$ 是 $d_{\\text{forward}}$ 的一个线性函数。其极值将出现在 $d_{\\text{forward}}$ 有效区间的端点处。\n在下界，$d_{\\text{forward}} = 22.8$：\n$$\\epsilon_{\\text{min}} = 22.8 - 46.8 = -24.0 \\text{ ms}$$\n在上界，$d_{\\text{forward}} = 29.0$：\n$$\\epsilon_{\\text{max}} = 29.0 - 46.8 = -17.8 \\text{ ms}$$\n可能的误差范围是 $\\epsilon \\in [-24.0, -17.8]$。\n最坏情况下的绝对误差是此范围内 $|\\epsilon|$ 的最大值。\n$$|\\epsilon_{\\text{min}}| = |-24.0| = 24.0 \\text{ ms}$$\n$$|\\epsilon_{\\text{max}}| = |-17.8| = 17.8 \\text{ ms}$$\n这两个值的最大值是 $24.0$ ms。\n$$\\max(|\\epsilon|) = 24.0 \\text{ ms}$$\n结果必须四舍五入到三位有效数字。数值 $24.0$ 已经以三位有效数字呈现。", "answer": "$$\\boxed{24.0}$$", "id": "3688987"}, {"introduction": "当物理时钟的同步充满挑战时，逻辑时钟提供了一种优雅的替代方案来为事件排序。与只能保证单向蕴含关系（如果事件 $e$ 先于事件 $f$，$e \\rightarrow f$，则 $L(e) \\lt L(f)$）的 Lamport 时钟不同，向量时钟能够精确地捕捉因果关系（$e \\rightarrow f$ 当且仅当 $VC(e) \\lt VC(f)$）。通过这个练习，你将亲手为一个包含消息乱序的分布式执行过程分配向量时间戳，并验证事件之间的“先于关系”（Happens-Before），从而具体地理解系统如何跟踪和比较不同进程的因果历史。[@problem_id:3688990]", "problem": "给定一个包含三个进程 $P_1$、$P_2$ 和 $P_3$ 的分布式执行。该系统不提供消息传递的先进先出（FIFO）保证，因此网络可能会对消息进行重排序。每个进程维护一个维度为 $3$ 的向量时钟（VC），其初始值为 $(0,0,0)$。向量时钟（VC）算法定义如下：\n\n- 对于进程 $i \\in \\{1,2,3\\}$ 上的任何事件，在为该事件打上时间戳之前，将本地向量时钟的第 $i$ 个分量加 $1$。\n- 对于发送事件，将发送方的当前向量时钟捎带在消息上。\n- 对于进程 $i$ 上的接收事件，设 $V_{\\text{local}}$ 为本地向量，$V_{\\text{msg}}$ 为捎带的向量。首先，通过逐分量求最大值将本地向量更新为 $\\max(V_{\\text{local}}, V_{\\text{msg}})$，然后将第 $i$ 个分量加 $1$，并用结果向量为该接收事件打上时间戳。\n\n先行发生（Happens-Before, HB）关系由以下规则生成：\n- 每个进程上的程序顺序（如果在同一进程上事件 $e$ 在事件 $f$ 之前，则 $e \\rightarrow_{\\mathrm{HB}} f$），\n- 消息因果关系（对于任何消息 $m$，有 $\\mathrm{send}(m) \\rightarrow_{\\mathrm{HB}} \\mathrm{recv}(m)$），\n- 以上两者的传递闭包。\n\n提供给您以下具有明确程序顺序和消息边的执行轨迹。事件在 $P_1$ 上标记为 $a_k$，在 $P_2$ 上标记为 $b_k$，在 $P_3$ 上标记为 $c_k$：\n\n- 在进程 $P_1$ 上：$a_1$：本地计算；$a_2$：向 $P_2$ 发送 $m_1$；$a_3$：向 $P_2$ 发送 $m_2$。\n- 在进程 $P_2$ 上：$b_1$：本地计算；$b_2$：接收 $m_2$；$b_3$：向 $P_3$ 发送 $m_3$；$b_4$：接收 $m_1$。\n- 在进程 $P_3$ 上：$c_1$：本地计算；$c_2$：接收 $m_3$。\n\n每个进程上的程序顺序如上所列。消息匹配如下：$a_2$ 发送 $m_1$ 而 $b_4$ 接收 $m_1$；$a_3$ 发送 $m_2$ 而 $b_2$ 接收 $m_2$；$b_3$ 发送 $m_3$ 而 $c_2$ 接收 $m_3$。注意网络重排序：在 $P_1$ 上 $m_1$ 在 $m_2$ 之前发送（因为 $a_2 \\rightarrow a_3$），但 $P_2$ 在 $m_1$ 之前接收 $m_2$（$b_2 \\rightarrow b_4$）。\n\n任务：\n1. 使用上述向量时钟（VC）规则，为每个事件 $a_1$、$a_2$、$a_3$、$b_1$、$b_2$、$b_3$、$b_4$、$c_1$、$c_2$ 分配一个向量时间戳。\n2. 仅使用逐分量向量比较，验证此轨迹中由程序顺序和消息因果关系产生的先行发生（HB）关系中的每一条边。然后，利用性质“对于事件 $e$ 和 $f$，$e \\rightarrow_{\\mathrm{HB}} f$ 当且仅当 $\\mathrm{VC}(e) \\le \\mathrm{VC}(f)$（逐分量）且 $\\mathrm{VC}(e) \\neq \\mathrm{VC}(f)$”，将其扩展到所有事件对。\n3. 计算在此执行中满足 $e \\rightarrow_{\\mathrm{HB}} f$ 的有序对 $(e,f)$（其中 $e \\neq f$）的总数。以单个整数形式提供您的答案（无单位）。", "solution": "问题要求计算给定分布式执行的向量时钟时间戳，验证先行发生（HB）关系，并计算所有满足 $e$ 先行于 $f$ 的有序事件对 $(e,f)$ 的数量。\n\n系统由三个进程 $P_1$、$P_2$ 和 $P_3$ 组成。每个进程维护一个 $3$ 维向量时钟，初始值为 $(0,0,0)$。事件在 $P_1$ 上为 $a_1, a_2, a_3$；在 $P_2$ 上为 $b_1, b_2, b_3, b_4$；在 $P_3$ 上为 $c_1, c_2$。\n\n令 $\\mathrm{VC}(e)$ 表示事件 $e$ 的向量时钟，令 $V_i$ 表示进程 $P_i$ 的本地向量时钟。初始时，$V_1 = V_2 = V_3 = (0,0,0)$。我们将按照执行的因果顺序计算每个事件的时间戳。\n\n**任务1：为每个事件分配一个向量时间戳。**\n\n1.  **$P_1$ 上的事件 $a_1$（本地计算）：**\n    进程 $P_1$ 将其本地时钟的第一个分量加一。\n    $V_1 \\leftarrow (0,0,0) + (1,0,0) = (1,0,0)$。\n    该事件被赋予时间戳：$\\mathrm{VC}(a_1) = (1,0,0)$。\n\n2.  **$P_1$ 上的事件 $a_2$（向 $P_2$ 发送 $m_1$）：**\n    进程 $P_1$ 将其本地时钟的第一个分量加一。\n    $V_1 \\leftarrow (1,0,0) + (1,0,0) = (2,0,0)$。\n    该事件被赋予时间戳：$\\mathrm{VC}(a_2) = (2,0,0)$。消息 $m_1$ 携带此时间戳，$V_{m_1} = (2,0,0)$。\n\n3.  **$P_1$ 上的事件 $a_3$（向 $P_2$ 发送 $m_2$）：**\n    进程 $P_1$ 将其本地时钟的第一个分量加一。\n    $V_1 \\leftarrow (2,0,0) + (1,0,0) = (3,0,0)$。\n    该事件被赋予时间戳：$\\mathrm{VC}(a_3) = (3,0,0)$。消息 $m_2$ 携带此时间戳，$V_{m_2} = (3,0,0)$。\n\n4.  **$P_2$ 上的事件 $b_1$（本地计算）：**\n    进程 $P_2$ 将其本地时钟的第二个分量加一。\n    $V_2 \\leftarrow (0,0,0) + (0,1,0) = (0,1,0)$。\n    该事件被赋予时间戳：$\\mathrm{VC}(b_1) = (0,1,0)$。\n\n5.  **$P_2$ 上的事件 $b_2$（从 $P_1$ 接收 $m_2$）：**\n    进程 $P_2$ 首先通过取其本地时钟 $V_2=(0,1,0)$ 和消息时钟 $V_{m_2}=(3,0,0)$ 的分量最大值来更新其时钟。\n    $V_2 \\leftarrow \\max((0,1,0), (3,0,0)) = (3,1,0)$。\n    然后，它将其本地时钟的第二个分量加一。\n    $V_2 \\leftarrow (3,1,0) + (0,1,0) = (3,2,0)$。\n    该事件被赋予时间戳：$\\mathrm{VC}(b_2) = (3,2,0)$。\n\n6.  **$P_2$ 上的事件 $b_3$（向 $P_3$ 发送 $m_3$）：**\n    进程 $P_2$ 将其本地时钟的第二个分量加一。\n    $V_2 \\leftarrow (3,2,0) + (0,1,0) = (3,3,0)$。\n    该事件被赋予时间戳：$\\mathrm{VC}(b_3) = (3,3,0)$。消息 $m_3$ 携带此时间戳，$V_{m_3} = (3,3,0)$。\n\n7.  **$P_3$ 上的事件 $c_1$（本地计算）：**\n    进程 $P_3$ 将其本地时钟的第三个分量加一。\n    $V_3 \\leftarrow (0,0,0) + (0,0,1) = (0,0,1)$。\n    该事件被赋予时间戳：$\\mathrm{VC}(c_1) = (0,0,1)$。\n\n8.  **$P_2$ 上的事件 $b_4$（从 $P_1$ 接收 $m_1$）：**\n    进程 $P_2$ 用消息时钟 $V_{m_1}=(2,0,0)$ 更新其时钟。其当前的本地时钟是 $V_2=(3,3,0)$。\n    $V_2 \\leftarrow \\max((3,3,0), (2,0,0)) = (3,3,0)$。\n    然后，它将其本地时钟的第二个分量加一。\n    $V_2 \\leftarrow (3,3,0) + (0,1,0) = (3,4,0)$。\n    该事件被赋予时间戳：$\\mathrm{VC}(b_4) = (3,4,0)$。请注意，$m_1$ 的到达没有从 $P_1$ 向 $P_2$ 引入新的因果知识，因为 $P_2$ 已经通过消息 $m_2$ 获知了来自 $P_1$ 的一个更晚的事件。\n\n9.  **$P_3$ 上的事件 $c_2$（从 $P_2$ 接收 $m_3$）：**\n    进程 $P_3$ 用消息时钟 $V_{m_3}=(3,3,0)$ 更新其时钟。其当前的本地时钟是 $V_3=(0,0,1)$。\n    $V_3 \\leftarrow \\max((0,0,1), (3,3,0)) = (3,3,1)$。\n    然后，它将其本地时钟的第三个分量加一。\n    $V_3 \\leftarrow (3,3,1) + (0,0,1) = (3,3,2)$。\n    该事件被赋予时间戳：$\\mathrm{VC}(c_2) = (3,3,2)$。\n\n向量时间戳的最终列表是：\n- $\\mathrm{VC}(a_1) = (1,0,0)$\n- $\\mathrm{VC}(a_2) = (2,0,0)$\n- $\\mathrm{VC}(a_3) = (3,0,0)$\n- $\\mathrm{VC}(b_1) = (0,1,0)$\n- $\\mathrm{VC}(b_2) = (3,2,0)$\n- $\\mathrm{VC}(b_3) = (3,3,0)$\n- $\\mathrm{VC}(b_4) = (3,4,0)$\n- $\\mathrm{VC}(c_1) = (0,0,1)$\n- $\\mathrm{VC}(c_2) = (3,3,2)$\n\n**任务2：验证并扩展先行发生关系。**\n\n对于任意两个事件 $e$ 和 $f$，关系 $e \\rightarrow_{\\mathrm{HB}} f$ 成立当且仅当 $\\mathrm{VC}(e)  \\mathrm{VC}(f)$。对于向量 $V$ 和 $W$，关系 $V  W$ 意味着对于所有索引 $i$ 都有 $V[i] \\le W[i]$ 且 $V \\neq W$。我们可以使用这个性质来找到所有有序对。\n\n**任务3：计算有序 HB 对的总数。**\n\n我们必须计算满足 $\\mathrm{VC}(e)  \\mathrm{VC}(f)$ 的不同事件对 $(e, f)$ 的数量。我们遍历每个事件 $e$，并计算它先行于的事件 $f$ 的数量。\n\n- 从 $e = a_1, \\mathrm{VC}(a_1)=(1,0,0)$：\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(a_2) = (2,0,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(a_3) = (3,0,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(b_2) = (3,2,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：6。\n\n- 从 $e = a_2, \\mathrm{VC}(a_2)=(2,0,0)$：\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(a_3) = (3,0,0)$\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(b_2) = (3,2,0)$\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：5。\n\n- 从 $e = a_3, \\mathrm{VC}(a_3)=(3,0,0)$：\n  - $\\mathrm{VC}(a_3)  \\mathrm{VC}(b_2) = (3,2,0)$\n  - $\\mathrm{VC}(a_3)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(a_3)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(a_3)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：4。\n\n- 从 $e = b_1, \\mathrm{VC(b_1)}=(0,1,0)$：\n  - $\\mathrm{VC}(b_1)  \\mathrm{VC}(b_2) = (3,2,0)$\n  - $\\mathrm{VC}(b_1)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(b_1)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(b_1)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：4。\n\n- 从 $e = b_2, \\mathrm{VC(b_2)}=(3,2,0)$：\n  - $\\mathrm{VC}(b_2)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(b_2)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(b_2)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：3。\n\n- 从 $e = b_3, \\mathrm{VC(b_3)}=(3,3,0)$：\n  - $\\mathrm{VC}(b_3)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(b_3)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：2。\n\n- 从 $e = b_4, \\mathrm{VC(b_4)}=(3,4,0)$：没有事件 $f$ 满足 $\\mathrm{VC}(b_4)  \\mathrm{VC}(f)$。\n  总对数：0。\n\n- 从 $e = c_1, \\mathrm{VC(c_1)}=(0,0,1)$：\n  - $\\mathrm{VC}(c_1)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：1。\n\n- 从 $e = c_2, \\mathrm{VC(c_2)}=(3,3,2)$：没有事件 $f$ 满足 $\\mathrm{VC}(c_2)  \\mathrm{VC}(f)$。\n  总对数：0。\n\n满足 $e \\rightarrow_{\\mathrm{HB}} f$ 的有序对 $(e,f)$ 的总数是这些单独计数的总和：\n总计 = $6 + 5 + 4 + 4 + 3 + 2 + 0 + 1 + 0 = 25$。", "answer": "$$\\boxed{25}$$", "id": "3688990"}, {"introduction": "逻辑时钟的一个强大应用是解决分布式系统中的一致性问题。在分布式数据库或存储系统中，确保数据在所有副本上的状态最终一致是至关重要的，这要求所有并发的写操作都能按照一个确定性的全序关系来执行。这项实践将挑战你设计并实现一个复制协议，该协议利用 Lamport 时钟和一个确定性的“决胜局”规则来创建一个全序关系，从而解决这个在分布式系统中普遍存在的状态复制难题。[@problem_id:3689003]", "problem": "设计并实现一个独立的复制文件寄存器模拟器，该模拟器使用 Lamport 逻辑时钟来解决写入顺序问题。该寄存器保存一个整数。每次写入操作会将寄存器设置为一个整数值，并在其源副本上用一个 Lamport 逻辑时钟值进行标记。该系统是异步的：消息可能被延迟、重排序或重复，但不会损坏。您的模拟器必须计算在处理完每个所提供测试用例的所有消息投递后，寄存器中存储的最终整数值。\n\n使用以下基本原理来推导您的算法：\n- Lamport 逻辑时钟将进程 $i$ 上的每个事件与一个时间戳 $L \\in \\mathbb{N}$ 相关联。时钟更新规则如下：对于进程 $i$ 上的任何本地事件，设置 $L \\leftarrow L + 1$；当进程 $i$ 收到一个携带时间戳 $t$ 的消息时，设置 $L \\leftarrow \\max(L, t) + 1$。先行发生关系 $\\rightarrow$ 被捕获，使得如果 $e \\rightarrow f$，则 $L(e)  L(f)$。\n- 为实现与先行发生关系一致的并发事件的确定性全序，通过使用进程标识符确定性地打破平局，将 Lamport 时间戳的偏序扩展为全序。让每次写入都由一个三元组 $\\langle L, i, s \\rangle$ 标记，其中 $L$ 是 Lamport 时间戳，$i$ 是源进程的整数标识符，$s$ 是该次写入的进程内唯一序列号。在写入操作上定义一个严格全序 $\\prec$：对于事件 $a=\\langle L_a, i_a, s_a \\rangle$ 和 $b=\\langle L_b, i_b, s_b \\rangle$，当且仅当 $L_a  L_b$，或 $L_a = L_b$ 且 $i_a  i_b$，或 $L_a = L_b$ 且 $i_a = i_b$ 且 $s_a  s_b$ 时，声明 $a \\prec b$。\n\n协议要求：\n- 每个副本使用其当前的 Lamport 时间 $L$ 和自身的标识符 $i$ 来标记其本地写入，并分配一个在副本内严格递增的序列号 $s$。该写入操作携带一个整数值负载 $v$。\n- 所有副本必须通过按照由 $\\prec$ 定义的全序应用所有已投递的写入操作，来收敛到相同的状态。这在序 $\\prec$ 下实现了“最后写入者获胜”的语义：最终状态是已投递的、在序 $\\prec$ 下最大的那次写入所对应的值 $v$。\n- 网络可能会投递重复的消息。协议必须是幂等的：一个由相同序对 $(i, s)$ 标记的写入，无论其重复投递了多少次，都必须最多被应用一次。假设没有损坏：如果两次投递具有相同的 $(i, s)$，那么它们的 $(L, v)$ 也完全相同。\n\n您的程序必须执行以下操作：\n- 实现上述协议，为每个测试用例计算在处理完该用例的所有消息投递后，寄存器中的最终整数值。\n- 忽略由 $(i, s)$ 标识的重复项，按 $\\prec$ 顺序对唯一的写入进行排序，然后按 $\\prec$ 的升序应用它们，这样最终状态就是该顺序中最后一次写入所对应的 $v$ 值。\n\n测试套件规范：\n每次写入都以元组 $(i, L, s, v)$ 的形式提供，其中 $i, L, s, v \\in \\mathbb{Z}$，$i$ 是进程标识符，$L$ 是 Lamport 时间戳，$s$ 是进程内序列号，$v$ 是写入的整数值。每个测试用例还提供一个到达序列，它是一个引用该测试用例写入元组的索引列表；索引是从 0 开始的。到达序列可能包含重复项，并且可以是任意顺序。\n\n为以下测试用例实现您的模拟器：\n- 测试用例 1:\n  - 写入: $[(1, 1, 1, 10), (2, 2, 1, 20)]$。\n  - 到达序列: $[1, 0]$。\n- 测试用例 2:\n  - 写入: $[(1, 5, 1, 7), (2, 2, 1, 3)]$。\n  - 到达序列: $[1, 0]$。\n- 测试用例 3:\n  - 写入: $[(1, 1, 1, 100), (2, 1, 1, 200)]$。\n  - 到达序列: $[0, 1]$。\n- 测试用例 4:\n  - 写入: $[(1, 1, 11, 1), (2, 2, 21, 2), (1, 3, 12, 3), (3, 3, 31, 4)]$。\n  - 到达序列: $[1, 0, 3, 2, 3, 2]$。\n- 测试用例 5:\n  - 写入: $[(9, 1, 1, 5), (9, 2, 2, 6), (9, 3, 3, 7)]$。\n  - 到达序列: $[2, 1, 0]$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。列表的第 $k$ 个元素必须是为测试用例 $k$ 计算出的最终整数值。例如，三个测试用例的输出必须是 $[x_1,x_2,x_3]$ 的形式，不含空格。", "solution": "该问题的核心是根据一个确定的全序规则 $\\prec$ 来确定复制寄存器的最终值，该规则实现了“最后写入者获胜”的语义。全序由元组 $\\langle L, i, s \\rangle$（Lamport 时间戳，进程 ID，序列号）的字典序比较定义。对于每个测试用例，我们必须首先从到达序列中识别出所有唯一的写入操作，然后找到这些写入中根据 $\\prec$ 排序为最大的那一个，其对应的整数值 $v$ 就是寄存器的最终值。\n\n**测试用例 1:**\n- 唯一写入: $\\{(1, 1, 1, 10), (2, 2, 1, 20)\\}$\n- 排序键: $\\langle 1, 1, 1 \\rangle$ 和 $\\langle 2, 2, 1 \\rangle$\n- 比较: 由于 Lamport 时间戳 $1  2$，所以 $\\langle 1, 1, 1 \\rangle \\prec \\langle 2, 2, 1 \\rangle$。\n- 最终值: 最大的写入是 `(2, 2, 1, 20)`，其值为 20。\n\n**测试用例 2:**\n- 唯一写入: $\\{(1, 5, 1, 7), (2, 2, 1, 3)\\}$\n- 排序键: $\\langle 5, 1, 1 \\rangle$ 和 $\\langle 2, 2, 1 \\rangle$\n- 比较: 由于 Lamport 时间戳 $5 > 2$，所以 $\\langle 2, 2, 1 \\rangle \\prec \\langle 5, 1, 1 \\rangle$。\n- 最终值: 最大的写入是 `(1, 5, 1, 7)`，其值为 7。\n\n**测试用例 3:**\n- 唯一写入: $\\{(1, 1, 1, 100), (2, 1, 1, 200)\\}$\n- 排序键: $\\langle 1, 1, 1 \\rangle$ 和 $\\langle 1, 2, 1 \\rangle$\n- 比较: Lamport 时间戳相同 ($L=1$) 。比较进程 ID $i$，$1  2$。因此，$\\langle 1, 1, 1 \\rangle \\prec \\langle 1, 2, 1 \\rangle$。\n- 最终值: 最大的写入是 `(2, 1, 1, 200)`，其值为 200。\n\n**测试用例 4:**\n- 唯一写入（来自到达序列 `[1, 0, 3, 2, 3, 2]`）: $W_0=(1, 1, 11, 1), W_1=(2, 2, 21, 2), W_2=(1, 3, 12, 3), W_3=(3, 3, 31, 4)$。\n- 排序键: $W_0 \\to \\langle 1, 1, 11 \\rangle, W_1 \\to \\langle 2, 2, 21 \\rangle, W_2 \\to \\langle 3, 1, 12 \\rangle, W_3 \\to \\langle 3, 3, 31 \\rangle$。\n- 比较: $W_2$ 和 $W_3$ 的 Lamport 时间戳最大 ($L=3$) 。比较 $W_2$ 和 $W_3$：它们的 $L$ 相同，比较进程 ID $i$，因为 $1  3$，所以 $\\langle 3, 1, 12 \\rangle \\prec \\langle 3, 3, 31 \\rangle$。\n- 最终值: 最大的写入是 $W_3$，其值为 4。\n\n**测试用例 5:**\n- 唯一写入: $\\{(9, 1, 1, 5), (9, 2, 2, 6), (9, 3, 3, 7)\\}$\n- 排序键: $\\langle 1, 9, 1 \\rangle, \\langle 2, 9, 2 \\rangle, \\langle 3, 9, 3 \\rangle$。\n- 比较: 按 Lamport 时间戳排序，$\\langle 3, 9, 3 \\rangle$ 是最大的。\n- 最终值: 最大的写入是 `(9, 3, 3, 7)`，其值为 7。\n\n将所有结果汇总，最终的输出列表是 `[20,7,200,4,7]`。", "answer": "[20,7,200,4,7]", "id": "3689003"}]}