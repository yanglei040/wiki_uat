{"hands_on_practices": [{"introduction": "在分布式系统中，网络是不可靠的，这可能导致远程过程调用（RPC）请求被重复发送。本练习将引导你分析一个基本但至关重要的问题：如何设计幂等的 RPC 操作，确保重复执行不会产生意外的副作用，这是构建可靠服务的基石。通过对常见文件系统操作的分类，你将学会从第一性原理出发，识别并解决非幂等性带来的挑战 [@problem_id:3677029]。", "problem": "客户端使用远程过程调用（Remote Procedure Call, RPC）与远程文件服务通信，RPC 被正式定义为一个确定性过程，它将一个请求和当前的服务器状态映射到一个新的状态和一个回复。假设服务器维护一个由 $S$ 表示的状态空间，并将一次 RPC 执行定义为一个函数 $F$，其中 $F(S, x) = (S', r)$，$x$ 是操作请求，$S'$ 是新状态，$r$ 是回复。由于重试机制，网络实现了“至少一次” (at-least-once) 的交付语义：如果客户端在超时时间内没有收到回复，它会重新发送相同的请求，服务器可能会多次执行同一个请求。如果对于任何状态 $S$，一个操作 $x$ 满足\n$$F(S, x) = (S', r) \\quad \\text{and} \\quad F(S', x) = (S', r),$$\n则称该操作 $x$ 在状态和可观察的回复两方面都是幂等的，这意味着，与单次执行相比，重复执行不会改变最终的状态或回复。\n\n考虑一个类似可移植操作系统接口 (POSIX) 的文件服务，它在路径 $P$ 或文件 $F$上提供以下操作：\n$\\mathsf{read}(F, o, n)$ 从偏移量 $o$ 返回 $n$ 个字节；$\\mathsf{writeAt}(F, o, B)$ 在偏移量 $o$ 处写入字节序列 $B$；$\\mathsf{append}(F, B)$ 将 $B$ 追加到 $F$ 的末尾；$\\mathsf{create}(P)$ 在路径 $P$ 处创建一个新的空文件，如果 $P$ 不存在则返回成功；$\\mathsf{delete}(P)$ 删除路径 $P$ 处的文件；$\\mathsf{chmod}(P, m)$ 将模式位设置为 $m$（绝对赋值）；以及 $\\mathsf{rename}(A, B)$ 原子地将路径 $A$ 移动到 $B$。\n\n假设：\n- 服务器原子地执行每个操作，并在回复前立即持久化其效果。\n- 只有一个客户端发出这些操作，重复执行的唯一来源是网络层面对同一请求的重试；在重试之间没有其他客户端的并发写入。\n- 当一个操作被重试时，客户端会重新发送一个完全相同的请求消息。\n\n根据上述幂等性的基本定义和标准的类 POSIX 语义，请对以下操作进行分类：哪些操作在“至少一次”语义下是天然幂等的，哪些是非幂等的（因为重试会改变用户可见的语义，即状态和回复）。对于非幂等的操作，提出包装策略 (wrapper strategies)，使其在重试下是安全的，而无需全局事务。例如，可以引入客户端生成的幂等性密钥 (idempotency keys) 和条件性前置条件 (conditional preconditions)，服务器可以验证这些条件，以便对同一逻辑请求的重复执行产生相同的效果和回复。\n\n哪个选项正确地对幂等和非幂等操作进行了分类，并提出了能在重试下实现幂等行为同时尊重典型文件系统不变量的包装策略？\n\nA. 将 $\\mathsf{read}(F, o, n)$、$\\mathsf{writeAt}(F, o, B)$ 和 $\\mathsf{chmod}(P, m)$ 分类为幂等操作；将 $\\mathsf{append}(F, B)$、$\\mathsf{create}(P)$、$\\mathsf{delete}(P)$ 和 $\\mathsf{rename}(A, B)$ 分类为非幂等操作，因为即使状态不变，重试也可能改变回复。使用请求范围的幂等性密钥 $k$ 使非幂等操作变得安全：对于 $\\mathsf{append}$，使用 $\\mathsf{appendToken}(F, k, B)$，它只写入一次 $B$，记录所选的偏移量，并在对同一 $k$ 的重试中返回相同的偏移量；对于 $\\mathsf{create}$，使用 $\\mathsf{createToken}(P, k)$，它要么创建文件并记录 $\\langle P, k \\rangle$，要么如果 $P$ 因同一 $k$ 而已存在，则返回成功，如果 $P$ 因其他原因存在，则返回“已存在”；对于 $\\mathsf{delete}$，使用 $\\mathsf{deleteToken}(P, k)$，它删除文件并记录 $\\langle P, k \\rangle$，在对 $k$ 的重试中返回相同的成功，如果 $P$ 不存在且不是由 $k$ 删除的，则返回“未找到”；对于 $\\mathsf{rename}$，使用 $\\mathsf{renameToken}(A, B, k, i, v)$，它只有当 $A$ 当前指向版本为 $v$ 的 inode $i$ 时才会有条件地重命名，记录 $\\langle A \\to B, k \\rangle$，并在重试 $k$ 时返回相同的成功或错误。\n\nB. 将 $\\mathsf{append}(F, B)$ 分类为幂等操作，因为两次追加相同的 $B$ 会产生两个 $B$ 的副本，这是“可接受的”；将 $\\mathsf{writeAt}(F, o, B)$ 分类为非幂等操作，因为写入两次会“覆盖不同的字节”；并通过客户端重试计数器 $c$ 使所有操作安全，无需服务器支持，假设如果 $c$ 增加，服务器会丢弃重复请求。\n\nC. 将 $\\mathsf{rename}(A, B)$ 分类为幂等操作，因为两次移动一个路径不会“再次移动它”；将 $\\mathsf{delete}(P)$ 分类为幂等操作，因为删除一个已经不存在的文件没有状态效果；并通过将一个临时文件重命名为 $P$ 来使 $\\mathsf{create}(P)$ 安全，无需任何幂等性密钥，假设重命名操作的重试总是返回成功。\n\nD. 将 $\\mathsf{read}(F, o, n)$ 分类为非幂等操作，因为文件可能在重试之间发生变化；将 $\\mathsf{writeAt}(F, o, B)$ 和 $\\mathsf{append}(F, B)$ 分类为幂等操作；并通过在重试前引入客户端休眠来使非幂等操作安全，以便服务器“稳定下来”，而无需任何服务器端的去重或条件检查。\n\n选择唯一的最佳选项。", "solution": "从第一性原理开始。一个 RPC 操作 $x$ 是幂等的，如果 $F(F(S, x)_1, x) = F(S, x)$，其中 $F(S, x) = (S', r)$ 且 $F(S', x) = (S', r)$；这里的下标 $1$ 选择状态分量。换句话说，应用两次 $x$ 产生的状态和回复与应用一次 $x$ 相同。在“至少一次”语义下，同一个逻辑请求 $x$ 可能会执行多次，因此幂等性取决于重复执行相同的请求是否会相对于单次执行改变最终状态或回复。\n\n假设限制了可变性：单个客户端、原子操作和完全相同的重试意味着重复执行之间的任何变化都是由操作本身引起的，而不是并发干扰。\n\n分析每个操作：\n\n- $\\mathsf{read}(F, o, n)$: 根据假设，在重试之间文件内容不会改变，因为没有其他客户端写入，并且同一客户端只是因为丢失回复而重试。因此，状态保持不变，回复（即返回的字节序列）在重新执行时也是相同的。所以 $\\mathsf{read}$ 是幂等的。\n\n- $\\mathsf{writeAt}(F, o, B)$: 在相同的偏移量 $o$ 处两次写入相同的字节 $B$，其最终状态与写入一次相同：第一次写入后，该范围内的文件字节等于 $B$，第二次写入在相同位置再次写入 $B$，文件保持不变。在类 POSIX 语义中，成功写入的回复会指示写入的字节数；由于原子性和持久性，重复执行会返回相同的成功信息。因此，在所述条件下 $\\mathsf{writeAt}$ 是幂等的。\n\n- $\\mathsf{chmod}(P, m)$ 采用绝对赋值：两次将模式位设置为 $m$ 会得到相同的模式 $m$；因为赋值是绝对的（不是切换或算术更新），重试时表示成功的回复是相同的。因此 $\\mathsf{chmod}$ 是幂等的。\n\n- $\\mathsf{append}(F, B)$: 将 $B$ 追加到文件末尾会使文件长度增加 $\\lvert B \\rvert$。重新执行相同的追加操作将再次使长度增加 $\\lvert B \\rvert$，并且文件内容将包含两个 $B$ 的副本。回复通常包括追加的字节数或新的结束偏移量；这个回复在第一次和第二次执行之间会有所不同。因此 $\\mathsf{append}$ 不是幂等的。\n\n- $\\mathsf{create}(P)$: 在 $P$ 处创建文件一次，状态从“不存在”变为“存在”。在同一路径 $P$ 上第二次执行会产生不同的回复：标准语义会返回“已存在”错误；即使状态保持“存在”，回复也改变了。因此，根据包含回复语义的定义，$\\mathsf{create}$ 不是幂等的。\n\n- $\\mathsf{delete}(P)$: 删除文件一次，状态从“存在”变为“不存在”。对一个不存在的文件进行第二次执行会产生不同的回复，“未找到”，尽管状态仍然是“不存在”。鉴于定义包括回复，$\\mathsf{delete}$ 不是幂等的。\n\n- $\\mathsf{rename}(A, B)$: 将路径从 $A$ 移动到 $B$ 一次，会导致 $A$ 变为不存在，而 $B$ 变为存在（指向被移动的 inode）。对相同的参数进行第二次执行通常会失败，因为 $A$ 不再存在，从而产生不同的回复；因此 $\\mathsf{rename}$ 不是幂等的。\n\n对于非幂等操作，包装器可以通过将逻辑请求与一个幂等性密钥 $k$ 绑定，并让服务器在重新执行同一逻辑请求时返回相同的效果和回复，从而提供幂等语义。这类包装器的原则包括：\n\n- 通过每个客户端的密钥进行去重：服务器为已完成的操作存储一个从 $(\\text{client}, k)$ 到结果 $(S', r)$ 的映射，确保带有相同 $(\\text{client}, k)$ 的重复请求返回已存储的回复 $r$，并且不会重新应用状态更改。\n\n- 条件性前置条件：服务器检查状态是否满足客户端在发出请求时看到的前置条件（例如，重命名操作的源 inode 和版本）。如果前置条件不满足，则返回相同的错误；如果前置条件满足且操作已在密钥 $k$ 下完成，则返回相同的成功信息。\n\n将这些原则应用于每个非幂等操作：\n\n- $\\mathsf{append}(F, B)$: 使用 $\\mathsf{appendToken}(F, k, B)$，它在追加 $B$ 时在每个文件的账本中记录 $k$，以及选择的偏移量 $o$ 和 $B$ 的哈希值以检测不匹配。当使用相同的 $k$ 重试时，服务器返回先前记录的 $o$ 并且不再追加，从而确保对于 $x = \\mathsf{appendToken}(F, k, B)$ 成立 $F(F(S, x)_1, x) = F(S, x)$。\n\n- $\\mathsf{create}(P)$: 使用 $\\mathsf{createToken}(P, k)$，它在成功时创建文件并记录 $\\langle P, k \\rangle$。如果带有相同 $k$ 的重试请求到达，服务器会检测到现有记录并再次返回成功。如果路径 $P$ 存在但不是在密钥 $k$ 下创建的，服务器将返回“已存在”错误，从而保持不变量。\n\n- $\\mathsf{delete}(P)$: 使用 $\\mathsf{deleteToken}(P, k)$，它删除文件并记录 $\\langle P, k \\rangle$。在使用相同 $k$ 重试时，即使 $P$ 已经不存在，服务器也会返回成功，因为相同的逻辑删除操作早先已在密钥 $k$ 下完成。如果 $P$ 不存在且没有关于 $k$ 的记录，服务器将返回“未找到”，从而保持相对于不同逻辑请求的正确性。\n\n- $\\mathsf{rename}(A, B)$: 使用 $\\mathsf{renameToken}(A, B, k, i, v)$，其中客户端包含发出重命名请求前观察到的源 inode $i$ 和版本 $v$。服务器仅当 $A$ 指向版本为 $v$ 的 inode $i$ 时才执行重命名，然后记录 $\\langle A \\to B, k \\rangle$。使用相同 $k$ 的重试会返回相同的成功信息；如果 $A$ 不再匹配 $i, v$ 且没有关于 $k$ 的记录，服务器会返回与第一次尝试相同的错误，从而避免意外的额外移动。\n\n评估每个选项：\n\nA. 该选项将 $\\mathsf{read}$、$\\mathsf{writeAt}$ 和 $\\mathsf{chmod}$ 分类为幂等，其余的因重试会改变回复（即使状态可能不变）而分类为非幂等。这与上述分析相符。所提出的包装器使用幂等性密钥 $k$ 和条件检查来确保重复执行产生相同的回复而无需重新应用状态更改。每个包装器都尊重常见的文件系统不变量：$\\mathsf{appendToken}$ 在重试时不会重复内容，$\\mathsf{createToken}$ 区分由同一逻辑请求创建的文件与预先存在的文件，$\\mathsf{deleteToken}$ 为不同的逻辑请求保留“未找到”的语义，同时使同一逻辑删除操作幂等，而 $\\mathsf{renameToken}$ 使用前置条件（$i, v$）来避免意外的额外移动，并在重试时返回相同的结果。结论 — 正确。\n\nB. 该选项错误地宣称 $\\mathsf{append}$ 是幂等的，理由是重复内容是“可接受的”。根据正式定义，追加两次会产生与追加一次不同的状态和回复，因此它不是幂等的。它还错误地声称在所述假设下 $\\mathsf{writeAt}$ 是非幂等的；在相同的偏移量 $o$ 处两次写入相同的 $B$ 会产生相同的状态和回复。此外，仅依赖客户端重试计数器 $c$ 而无服务器端去重，无法保证服务器会抑制重复请求，尤其是在重新连接或面对无状态服务器时。结论 — 错误。\n\nC. 该选项错误地将 $\\mathsf{rename}$ 分类为幂等，理由是移动“不会再次移动它”，但重试会因为源路径不复存在而产生不同的回复，违反了幂等性条件。它还将 $\\mathsf{delete}$ 视为幂等，但这在第二次执行返回“未找到”时失败。所提出的 $\\mathsf{create}$ 包装器仅依赖于将临时文件重命名为 $P$ 而不使用幂等性密钥，这不能确保重试的重命名操作返回相同的回复；如果第一次重命名成功而第二次执行，源临时路径可能已丢失，回复也会不同。结论 — 错误。\n\nD. 该选项在给定假设下错误地将 $\\mathsf{read}$ 分类为非幂等；在没有中间写入的情况下，重试的读取操作会返回相同的数据和回复。它错误地将 $\\mathsf{append}$ 分类为幂等。建议的“重试前休眠”没有提供任何服务器端机制来确保重复抑制或回复一致性，因此无法在重试下实现幂等行为。结论 — 错误。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "3677029"}, {"introduction": "RPC 服务直接暴露在网络中，必须能够抵御来自客户端的恶意输入。这个实践练习模拟了一个真实世界中的安全挑战：资源耗尽攻击，攻击者通过发送特制的消息头来耗尽服务器内存。你将通过实现一个遵循安全策略的模拟反序列化器，来验证防御性编码如何防止此类漏洞，从而加深对健壮服务设计的理解 [@problem_id:3677042]。", "problem": "您需要设计并实现一个独立的程序，该程序模拟远程过程调用（RPC）消息的反序列化器，并评估一个防御性编码的部分反序列化策略是否能在对抗性和边界输入下防止资源耗尽。上下文是一个长度前缀的 RPC 消息，其中第一个字段声明了消息长度。您的任务是从第一性原理出发，推理流式输入下的资源分配，并实现一个测试工具，用于验证安全属性，而无需执行任何网络输入或实际的内存分配。\n\n基本和核心定义：\n- 远程过程调用（RPC）是一种机制，其中客户端在远程服务器上调用一个过程，就像调用本地过程一样。一种常见的消息分帧方法是在每条消息前加上一个声明的长度。反序列化是从字节序列重建结构化消息的过程。\n- 如果实现允许基于不受信任的输入进行无界或过大的分配，就会发生资源耗尽。为避免这种情况，内存分配应受配置限制的约束，并增量执行。\n- 我们考虑单个连接一次最多处理一条消息，解析器维持恒定的开销。\n\n要模拟的安全策略（不要假设任何快捷公式；相反，忠实地应用以下规则）：\n- 设 $L$ 为声明的消息长度（单位：字节），$C$ 为配置的单条消息长度上限（单位：字节），$M$ 为此连接可用的内存预算（单位：字节），$O$ 为恒定的单连接解析器开销（单位：字节），$P$ 为实际到达的负载总字节数（如果流被截断，该值可能小于 $L$），$s$ 为增量到达的每个负载块的大小（单位：字节）。\n- 安全的反序列化器必须强制执行以下不变量：\n  - 如果在读取头部时声明的长度 $L$ 超过上限 $C$，则立即中止消息，不分配任何消息缓冲区。解析器开销 $O$ 仍然驻留。\n  - 如果 $L \\leq C$，不要预先分配 $L$ 字节。而应随着负载的到达增量地增长消息缓冲区，增量最多为到达的块大小 $s$，并且绝不超过已接收负载和上限 $C$ 中的较小者。\n  - 如果接收到的总负载达到声明的长度 $L$，则消息完成并且消息缓冲区被释放。如果流提前截断（$P  L$），则在输入结束时释放部分填充的消息缓冲区。\n  - 在任何时候，当前分配的内存等于解析器开销 $O$ 加上当前的消息缓冲区；峰值分配是在处理消息期间观察到的此数量的最大值。\n- 当且仅当峰值分配不超过预算 $M$ 时，系统才能避免资源耗尽。\n\n您的程序必须：\n- 为提供的测试套件中的每个测试用例模拟上述过程，按大小为 $s$ 字节的块（最后一个块可能更小）逐步处理负载的到达，遵守当 $L > C$ 时的中止条件，当 $L \\leq C$ 时的增量增长规则，以及在完成或截断时释放缓冲区的规则。\n- 对于每个测试用例，如果安全策略避免了资源耗尽（峰值分配 $\\leq M$），则输出整数 $1$，否则输出 $0$。\n\n测试套件：\n- 测试用例 1：$L = 1024$ 字节, $P = 1024$ 字节, $s = 128$ 字节, $C = 2048$ 字节, $M = 4096$ 字节, $O = 64$ 字节。\n- 测试用例 2：$L = 1000000000$ 字节, $P = 1$ 字节, $s = 1$ 字节, $C = 65536$ 字节, $M = 10000000$ 字节, $O = 64$ 字节。\n- 测试用例 3：边界情况，其中 $L = C$：$L = 4096$ 字节, $P = 4096$ 字节, $s = 257$ 字节, $C = 4096$ 字节, $M = 5000$ 字节, $O = 64$ 字节。\n- 测试用例 4：负载被截断且受上限约束：$L = 50000$ 字节, $P = 10000$ 字节, $s = 3000$ 字节, $C = 8192$ 字节, $M = 8300$ 字节, $O = 64$ 字节。\n- 测试用例 5：零长度消息：$L = 0$ 字节, $P = 0$ 字节, $s = 1$ 字节, $C = 16$ 字节, $M = 64$ 字节, $O = 64$ 字节。\n- 测试用例 6：预算紧张导致失败：$L = 1024$ 字节, $P = 1024$ 字节, $s = 512$ 字节, $C = 1024$ 字节, $M = 1000$ 字节, $O = 64$ 字节。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\left[ x,y,z \\right]$），其中每个元素按顺序对应一个测试用例，如果该用例的安全策略避免了资源耗尽，则为整数 $1$，否则为 $0$。输出是无单位的整数，表示真值，其中 $1$ 代表真，$0$ 代表假。不应打印任何其他文本。", "solution": "该问题要求在特定安全策略下模拟一个远程过程调用（RPC）的反序列化过程，以确定是否避免了资源耗尽。我们将验证问题陈述，然后通过根据所提供的规则模拟内存分配状态，系统地推导出每个测试用例的结果。\n\n### 问题验证\n\n#### 第1步：提取已知条件\n\n问题定义了以下符号参数：\n- $L$：声明的消息长度（单位：字节）。\n- $C$：配置的单条消息长度上限（单位：字节）。\n- $M$：此连接可用的内存预算（单位：字节）。\n- $O$：恒定的单连接解析器开销（单位：字节）。\n- $P$：实际到达的负载总字节数。\n- $s$：增量到达的每个负载块的大小（单位：字节）。\n\n安全策略由一组不变量定义：\n1.  如果 $L  C$，则在读取头部时中止消息。不分配消息缓冲区。解析器开销 $O$ 仍然存在。\n2.  如果 $L \\leq C$，则不预先分配消息缓冲区。它随着负载的到达而增量增长。在任何时候，缓冲区大小都不能超过到目前为止接收到的总负载和上限 $C$ 中的较小者。\n3.  如果接收到的总负载达到 $L$，则认为消息完成。缓冲区在完成后释放。如果流被截断（$P  L$），则部分缓冲区在输入结束时释放。\n4.  当前内存分配是解析器开销 $O$ 和当前消息缓冲区大小的总和。\n5.  峰值分配是在处理一条消息期间观察到的最大内存分配。\n6.  当且仅当峰值分配不超过预算 $M$ 时，才能避免资源耗尽。\n\n测试套件为参数 $L, P, s, C, M, O$ 提供了六个不同的具体值。\n\n#### 第2步：使用提取的已知条件进行验证\n\n该问题根据以下标准进行评估：\n- **科学依据**：该问题在计算机科学基本原理方面有充分的依据，特别是在网络协议、操作系统和防御性编程领域。长度前缀消息、资源耗尽攻击以及带上限的增量分配等概念是软件工程中标准且现实的主题。\n- **定义明确**：该问题定义明确。模拟的规则是确定性的，并以算法方式陈述。对于测试套件中的每一组输入参数，都可以计算出唯一的结果（峰值分配），从而得出一个明确的二进制结果（$1$ 或 $0$）。\n- **客观性**：该问题以精确、定量和客观的语言陈述。它没有主观性或模糊性。\n- **完整性和一致性**：该问题是自包含的。为每个测试用例提供了所有必要的数据和规则。这些规则被构造为一组非矛盾的条件不变量。`if L > C` 的情况与 `if L = C` 的情况互斥，形成了一个完整的决策过程。\n- **现实性**：场景和参数对于建模和测试网络服务的逻辑是现实的。选择这些值是为了探测边界条件，这是算法测试中的标准做法。\n\n#### 第3步：结论与行动\n\n问题陈述是**有效的**。它在科学上是合理的，定义明确，并且提供了所有必要的信息。我们将继续进行逐步求解。\n\n### 算法解决方案\n对于每个测试用例，我们模拟内存分配过程，以找到峰值分配并将其与内存预算 $M$ 进行比较。设 `peak_alloc` 为观察到的峰值内存分配，`current_alloc` 为给定步骤中分配的内存。\n\n单个测试用例的模拟算法如下：\n1.  将 `peak_alloc` 初始化为恒定的解析器开销 $O$。这是基线分配。\n2.  评估第一个不变量：将声明的长度 $L$ 与上限 $C$ 进行比较。\n    - 如果 $L  C$，策略要求立即中止。从不分配消息缓冲区。内存使用量绝不会超过初始的解析器开销。因此，`peak_alloc` 保持为 $O$。\n    - 如果 $L \\leq C$，则进入增量分配阶段。\n3.  对于 $L \\leq C$ 的情况，模拟负载分块到达。初始化 `bytes_received = 0` 和 `buffer_size = 0`。\n4.  只要还有负载可以到达（`bytes_received  P`）并且消息尚未完成（`bytes_received  L`），就循环：\n    - a. 确定下一个传入数据块的大小：`chunk_size = min(s, P - bytes_received)`。\n    - b. 更新已接收的数据总量：`bytes_received = bytes_received + chunk_size`。\n    - c. 根据规则更新分配的缓冲区大小：`buffer_size = min(bytes_received, C)`。缓冲区增长以容纳接收到的数据，但受上限 $C$ 的限制。\n    - d. 计算当前的总内存分配：`current_alloc = O + buffer_size`。\n    - e. 更新峰值分配：`peak_alloc = max(peak_alloc, current_alloc)`。\n5.  循环终止后（由于接收到所有负载 $P$ 或在长度 $L$ 处完成消息），缓冲区被释放。`peak_alloc` 值保存了消息生命周期中的最大内存占用。\n6.  如果 `peak_alloc` $\\leq M$，则测试用例的最终结果为 $1$，否则为 $0$。\n\n我们现在将此算法应用于每个测试用例。\n\n**测试用例 1**：$L=1024, P=1024, s=128, C=2048, M=4096, O=64$。\n- $L \\leq C$ ($1024 \\leq 2048$) 。继续进行分配。\n- `peak_alloc` 初始化为 $O=64$。\n- 模拟接收负载，直到 `bytes_received` 达到 $1024$。缓冲区随接收到的负载而增长。\n- 最大缓冲区大小将为 $\\min(1024, C=2048) = 1024$ 字节。\n- 峰值分配发生在缓冲区已满时：`peak_alloc` $= O + 1024 = 64 + 1024 = 1088$ 字节。\n- 条件检查：$1088 \\leq M=4096$。为真。\n- 结果：$1$。\n\n**测试用例 2**：$L=10^9, P=1, s=1, C=65536, M=10^7, O=64$。\n- $L  C$ ($10^9  65536$) 。策略要求立即中止。\n- 没有分配缓冲区。峰值分配就是解析器开销。\n- `peak_alloc` $= O = 64$ 字节。\n- 条件检查：$64 \\leq M=10^7$。为真。\n- 结果：$1$。\n\n**测试用例 3**：$L=4096, P=4096, s=257, C=4096, M=5000, O=64$。\n- $L \\leq C$ ($4096 \\leq 4096$) 。继续进行分配。\n- `peak_alloc` 初始化为 $O=64$。\n- 模拟接收负载，直到 `bytes_received` 达到 $4096$。\n- 最大缓冲区大小将为 $\\min(4096, C=4096) = 4096$ 字节。\n- 峰值分配为 `peak_alloc` $= O + 4096 = 64 + 4096 = 4160$ 字节。\n- 条件检查：$4160 \\leq M=5000$。为真。\n- 结果：$1$。\n\n**测试用例 4**：$L=50000, P=10000, s=3000, C=8192, M=8300, O=64$。\n- $L  C$ ($50000  8192$) 。策略要求立即中止。\n- 没有分配缓冲区。测试用例的名称，“负载被截断且受上限约束”，是一个干扰项；当 $L  C$ 时中止的首要规则优先适用。\n- `peak_alloc` $= O = 64$ 字节。\n- 条件检查：$64 \\leq M=8300$。为真。\n- 结果：$1$。\n\n**测试用例 5**：$L=0, P=0, s=1, C=16, M=64, O=64$。\n- $L \\leq C$ ($0 \\leq 16$) 。继续。\n- `peak_alloc` 初始化为 $O=64$。\n- $P=0$，所以没有负载到达。接收循环不执行。由于 `bytes_received` ($0$) 不小于 $L$ ($0$)，消息立即被视为完成。\n- 没有分配缓冲区（`buffer_size` 保持为 $0$）。\n- 峰值分配不超过初始开销：`peak_alloc` $= 64$ 字节。\n- 条件检查：$64 \\leq M=64$。为真。\n- 结果：$1$。\n\n**测试用例 6**：$L=1024, P=1024, s=512, C=1024, M=1000, O=64$。\n- $L \\leq C$ ($1024 \\leq 1024$) 。继续进行分配。\n- `peak_alloc` 初始化为 $O=64$。\n- 模拟接收负载，直到 `bytes_received` 达到 $1024$。\n- 最大缓冲区大小将为 $\\min(1024, C=1024) = 1024$ 字节。\n- 峰值分配为 `peak_alloc` $= O + 1024 = 64 + 1024 = 1088$ 字节。\n- 条件检查：$1088 \\leq M=1000$。为假。\n- 结果：$0$。\n\n### 结果摘要\n测试用例的结果是：\n1.  用例 1: $1$\n2.  用例 2: $1$\n3.  用例 3: $1$\n4.  用例 4: $1$\n5.  用例 5: $1$\n6.  用例 6: $0$\n程序应将这些结果以逗号分隔的列表形式输出在方括号中。", "answer": "[1,1,1,1,1,0]", "id": "3677042"}, {"introduction": "本练习要求您为一个基于远程过程调用（RPC）的内存映射服务建模，该服务实现了“修改-共享-无效”（MSI）一致性协议。通过精确模拟缺页、消息传递和延迟累积，您将深入理解分布式共享内存系统的成本和复杂性，这是构建高性能分布式数据库和计算框架的基础。", "problem": "您需要为一个简化的、确定性的、基于远程过程调用（RPC）的内存映射服务建模，该服务支持客户端与中央服务器之间的页面共享。该服务实现一个类似于“修改-共享-无效”（MSI）方案的一致性协议，并且必须根据精确的规则来核算缺页、消息计数和延迟累积。您的任务是编写一个完整的程序，为一组固定的测试套件模拟此系统，并为每个测试用例输出聚合指标。\n\n需要使用的基本原理和定义：\n\n- 远程过程调用（RPC）是一种客户端-服务器交互模式，客户端向服务器请求服务，如同调用本地过程一样。在本问题中，一次 RPC 会产生通信延迟和消息计数，但不涉及实际的网络。\n- 页面是共享的不可分割单元。每个客户端为每个页面追踪其一致性状态：无效（$\\mathsf{I}$）、共享（$\\mathsf{S}$）或修改（$\\mathsf{M}$）。\n- 一致性不变量（以服务器为中心的 MSI）：\n  - 在任何时刻，最多只能有一个客户端以 $\\mathsf{M}$ 状态持有某个页面。如果一个页面有一个处于 $\\mathsf{M}$ 状态的所有者，则其他任何客户端都不能以 $\\mathsf{S}$ 状态持有该页面。\n  - 如果一个页面没有处于 $\\mathsf{M}$ 状态的所有者，则零个或多个客户端可以以 $\\mathsf{S}$ 状态持有该页面。\n- 当客户端的操作（读或写）尝试访问其当前状态为 $\\mathsf{I}$ 的页面时，就会发生缺页。\n- 延迟模型和消息模型：\n  - 每次 RPC 都是一次客户端与服务器之间的往返交互，计为两条单向消息。\n  - 一次携带负载的 RPC 产生的延迟为 $2L_n + L_s + B \\cdot T_b$，其中 $L_n$ 是单向网络延迟，$L_s$ 是每次 RPC 的服务器处理时间，$B$ 是页面大小（以字节为单位），$T_b$ 是每字节的传输时间。\n  - 一次仅控制的 RPC 产生的延迟为 $2L_n + L_s$。\n  - 所有无效化操作都由服务器串行处理；对单个目标客户端的每次无效化都是一次仅控制的 RPC。\n  - 所有成本在操作序列上线性累加；不存在并行处理。\n\n操作与一致性转换：\n\n- 客户端 $c$ 对页面 $p$ 的读操作 $\\mathsf{R}(c,p)$：\n  - 如果客户端状态为 $\\mathsf{M}$ 或 $\\mathsf{S}$，则读操作为本地操作，不产生消息和延迟。\n  - 如果客户端状态为 $\\mathsf{I}$ 且服务器上页面 $p$ 没有所有者，客户端通过一次携带负载的 RPC 获取页面；客户端状态转换到 $\\mathsf{S}$ 并被添加到共享者集合中。\n  - 如果客户端状态为 $\\mathsf{I}$ 且页面 $p$ 在服务器上的所有者是某个 $c' \\ne c$，服务器通过一次携带负载的 RPC 从 $c'$ 召回页面，然后通过另一次携带负载的 RPC 将其提供给 $c$；两者最终都处于 $\\mathsf{S}$ 状态，所有者被清除，两者都成为共享者。\n- 客户端 $c$ 对页面 $p$ 的写操作 $\\mathsf{W}(c,p)$：\n  - 如果客户端状态为 $\\mathsf{M}$，则写操作为本地操作。\n  - 如果服务器上没有所有者且 $c$ 是一个共享者，客户端通过向服务器发起一次仅控制的 RPC 来升级到 $\\mathsf{M}$ 状态；服务器通过对每个目标发送一次仅控制的 RPC 来使其他所有共享者无效；该客户端成为唯一的所有者，不再有共享者。\n  - 如果服务器上没有所有者且 $c$ 不是共享者，客户端首先通过一次携带负载的 RPC 获取页面（成为共享者），然后执行上述升级序列。\n  - 如果服务器上的所有者是某个 $c' \\ne c$，服务器通过一次携带负载的 RPC 从 $c'$ 召回页面，然后通过另一次携带负载的 RPC 将其传输给 $c$；$c$ 成为唯一的所有者，不再有共享者。\n- 版本控制：服务器上每个页面维护一个整数版本号，用以模拟逻辑写进度。在每次写操作 $\\mathsf{W}(c,p)$ 中，当客户端 $c$ 被认为执行了写操作的时刻（包括 $c$ 已持有 $\\mathsf{M}$ 状态的情况），页面 $p$ 的版本号增加 1。读操作不改变版本号。\n- 缺页：在操作发生时，每次访问客户端状态为 $\\mathsf{I}$ 的页面，都会使缺页计数增加 1。\n\n每个测试用例需要计算的指标：\n\n- 单向消息总数（一次 RPC 计为 $2$）。\n- 总延迟（RPC 延迟之和），以抽象时间单位计。\n- 缺页总数。\n- 执行完操作序列后，所有页面的最终版本号之和。\n\n要求的输出格式：\n\n- 您的程序应生成单行输出，其中包含每个测试用例的结果，格式为逗号分隔的列表的列表。每个内部列表的形式为 $[\\text{messages}, \\text{time}, \\text{faults}, \\text{version\\_sum}]$，均为整数，外部列表聚合了所有测试用例的结果（例如 $[[a,b,c,d],[e,f,g,h]]$）。\n\n需要在程序中精确实现的测试套件：\n\n- 测试用例 $1$：\n  - 参数：客户端数 $N=2$，页面数 $P=1$，页面大小 $B=100$，网络延迟 $L_n=5$，服务器延迟 $L_s=3$，每字节传输时间 $T_b=1$。\n  - 操作（按顺序）：$\\mathsf{R}(0,0)$、$\\mathsf{R}(1,0)$、$\\mathsf{W}(0,0)$、$\\mathsf{R}(1,0)$。\n- 测试用例 $2$：\n  - 参数：$N=1$, $P=1$, $B=256$, $L_n=2$, $L_s=2$, $T_b=1$。\n  - 操作：$\\mathsf{R}(0,0)$、$\\mathsf{W}(0,0)$、$\\mathsf{R}(0,0)$、$\\mathsf{W}(0,0)$、$\\mathsf{W}(0,0)$。\n- 测试用例 $3$：\n  - 参数：$N=2$, $P=2$, $B=64$, $L_n=4$, $L_s=1$, $T_b=2$。\n  - 操作：$\\mathsf{W}(0,0)$、$\\mathsf{W}(1,0)$、$\\mathsf{W}(0,0)$、$\\mathsf{W}(1,1)$、$\\mathsf{R}(0,1)$。\n- 测试用例 $4$（边界情况，无操作）：\n  - 参数：$N=3$, $P=3$, $B=128$, $L_n=3$, $L_s=2$, $T_b=1$。\n  - 操作：无。\n\n科学真实性和推导约束：\n\n- 仅使用此处陈述的定义和规则作为基础。不要臆造任何额外的“神奇”优化、重叠处理或并行无效化；所有无效化操作都是串行化的，所有成本都是累加的。\n- 在上述模型下，所有计数和时间都必须是整数。\n- 角度不适用；除了抽象时间单位外，不使用任何物理单位。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素是如上所述的一个测试用例的结果列表。例如，输出格式必须与 $[[r_1,r_2,r_3,r_4],[r_5,r_6,r_7,r_8],\\dots]$ 完全一样，不得包含额外文本。", "solution": "我们从远程过程调用（RPC）延迟、一致性不变量和缺页语义的定义出发，构建一个无歧义的、确定性的成本模型。\n\n基本原则：\n\n- 每次 RPC 恰好产生两条单向消息，并根据其是否携带负载来增加延迟。对于仅控制的 RPC，延迟为 $2L_n + L_s$。对于携带负载的 RPC，延迟为 $2L_n + L_s + B \\cdot T_b$。\n- 在“修改-共享-无效”（MSI）不变量下，对于给定页面，最多只能有一个所有者处于 $\\mathsf{M}$ 状态。当存在所有者时，不存在共享者。当不存在所有者时，可以有零个或多个共享者处于 $\\mathsf{S}$ 状态。\n- 当进行操作的客户端的每页状态在操作瞬间为 $\\mathsf{I}$ 时，发生一次缺页。\n\n根据这些规则，我们推导出每个操作的精确 RPC 序列：\n\n- 对于 $\\mathsf{R}(c,p)$：\n  - 如果客户端状态为 $\\mathsf{S}$ 或 $\\mathsf{M}$：成本为 $0$ 条消息和 $0$ 延迟。\n  - 如果客户端状态为 $\\mathsf{I}$ 且没有所有者：客户端执行一次获取操作（一次携带负载的 RPC）。消息数 $=2$，延迟 $=2L_n + L_s + B\\cdot T_b$。\n  - 如果客户端状态为 $\\mathsf{I}$ 且存在所有者 $c'\\ne c$：服务器必须首先从 $c'$ 召回最新页面（一次携带负载的 RPC），然后将其交付给 $c$（一次携带负载的 RPC）。消息数 $=4$，延迟 $=2(2L_n + L_s + B\\cdot T_b)$。之后，$c'$ 和 $c$ 都变为 $\\mathsf{S}$ 状态，服务器不再记录所有者。\n- 对于 $\\mathsf{W}(c,p)$：\n  - 如果客户端状态为 $\\mathsf{M}$：成本为 $0$ 条消息和 $0$ 延迟。页面版本号增加 1。\n  - 如果没有所有者且 $c$ 是共享者：客户端发起一次仅控制的 RPC 进行升级；服务器为每个其他共享者发送一次仅控制的 RPC 使其无效。消息数 $=2(1 + k)$，延迟 $=(1 + k)(2L_n + L_s)$，其中 $k$ 是其他共享者的数量。页面版本号增加 1。\n  - 如果没有所有者且 $c$ 不是共享者：客户端首先通过一次携带负载的 RPC 获取页面（消息数 $=2$，延迟 $=2L_n + L_s + B\\cdot T_b$）并成为共享者，然后执行上述升级序列。页面版本号增加 1。\n  - 如果存在所有者 $c'\\ne c$：服务器通过一次携带负载的 RPC 从 $c'$ 召回页面，然后通过另一次携带负载的 RPC 将其传输给 $c$。消息数 $=4$，延迟 $=2(2L_n + L_s + B\\cdot T_b)$。页面版本号增加 1。\n\n一致性状态转换：\n\n- 当没有所有者时，获取页面（Fetch）使请求者加入共享者集合并进入 $\\mathsf{S}$ 状态。\n- 升级（Upgrade）使请求者成为唯一的所有者（$\\mathsf{M}$），清除共享者集合，并将其他客户端的状态置为无效（$\\mathsf{I}$）。\n- 从所有者处召回（Recall）后进行读操作，会使前所有者和请求者都变为 $\\mathsf{S}$ 状态，并清除所有者记录。\n- 从所有者处召回后进行写操作，会使请求者成为所有者（$\\mathsf{M}$），并将前所有者的状态置为无效（$\\mathsf{I}$）。\n\n现在我们将这些规则应用于每个测试用例，以获得预期的指标。\n\n令 $C = 2L_n + L_s$ 表示仅控制 RPC 的延迟，令 $P = 2L_n + L_s + B\\cdot T_b$ 表示携带负载 RPC 的延迟。每次 RPC 产生 2 条单向消息。\n\n测试用例 1：\n- 参数：$N=2$, $P=1$, $B=100$, $L_n=5$, $L_s=3$, $T_b=1$。因此 $C=2\\cdot 5 + 3 = 13$，$P=13 + 100\\cdot 1 = 113$。\n- 操作：\n  - $\\mathsf{R}(0,0)$：客户端状态为 $\\mathsf{I}$，无所有者。获取负载：消息数 $+2$，时间 $+113$，缺页数 $+1$。客户端变为 $\\mathsf{S}$。\n  - $\\mathsf{R}(1,0)$：客户端状态为 $\\mathsf{I}$，无所有者。获取负载：消息数 $+2$，时间 $+113$，缺页数 $+1$。现在共享者为 $\\{0,1\\}$。\n  - $\\mathsf{W}(0,0)$：共享者升级，有另一个共享者。升级控制 RPC $+1$，向另一个共享者发送无效化控制 RPC $+1$。消息数 $+2\\cdot (1+1) = +4$，时间 $+(1+1)\\cdot 13 = +26$，缺页数 $+0$。客户端变为 $\\mathsf{M}$，其他客户端被置为无效。版本号 $+1$。\n  - $\\mathsf{R}(1,0)$：客户端状态为 $\\mathsf{I}$，所有者是客户端 0。召回负载然后交付负载：消息数 $+4$，时间 $+2\\cdot 113 = +226$，缺页数 $+1$。两个客户端都变为 $\\mathsf{S}$。\n- 总计：消息数 $12$，时间 $113+113+26+226=478$，缺页数 $3$，版本号和 $1$。\n\n测试用例 2：\n- 参数：$N=1$, $P=1$, $B=256$, $L_n=2$, $L_s=2$, $T_b=1$。因此 $C=2\\cdot 2 + 2 = 6$，$P=6 + 256\\cdot 1 = 262$。\n- 操作：\n  - $\\mathsf{R}(0,0)$：$\\mathsf{I}$，无所有者。获取负载：消息数 $+2$，时间 $+262$，缺页数 $+1$。变为 $\\mathsf{S}$。\n  - $\\mathsf{W}(0,0)$：共享者升级，无其他共享者。升级控制 RPC $+1$：消息数 $+2$，时间 $+6$，缺页数 $+0$。变为 $\\mathsf{M}$。版本号 $+1$。\n  - $\\mathsf{R}(0,0)$：已经是 $\\mathsf{M}$，本地操作，无成本。\n  - $\\mathsf{W}(0,0)$：已经是 $\\mathsf{M}$，本地操作，版本号 $+1$。\n  - $\\mathsf{W}(0,0)$：已经是 $\\mathsf{M}$，本地操作，版本号 $+1$。\n- 总计：消息数 $4$，时间 $268$，缺页数 $1$，版本号和 $3$。\n\n测试用例 3：\n- 参数：$N=2$, $P=2$, $B=64$, $L_n=4$, $L_s=1$, $T_b=2$。因此 $C=2\\cdot 4 + 1 = 9$，$P=9 + 64\\cdot 2 = 137$。\n- 操作：\n  - $\\mathsf{W}(0,0)$：$\\mathsf{I}$，无所有者。获取负载：消息数 $+2$，时间 $+137$，缺页数 $+1$。无其他共享者时升级：消息数 $+2$，时间 $+9$。成为所有者。版本号 $+1$。\n  - $\\mathsf{W}(1,0)$：所有者是客户端 0。召回负载并交付负载：消息数 $+4$，时间 $+2\\cdot 137=274$，缺页数 $+1$。新所有者是客户端 1。版本号 $+1$。\n  - $\\mathsf{W}(0,0)$：所有者是客户端 1。召回负载并交付负载：消息数 $+4$，时间 $+274$，缺页数 $+1$。新所有者是客户端 0。版本号 $+1$。\n  - $\\mathsf{W}(1,1)$：页面 1 无所有者。获取负载：消息数 $+2$，时间 $+137$，缺页数 $+1$。无其他共享者时升级：消息数 $+2$，时间 $+9$。新所有者是客户端 1。页面 1 的版本号 $+1$。\n  - $\\mathsf{R}(0,1)$：客户端状态为 $\\mathsf{I}$，所有者是客户端 1。召回负载并交付负载：消息数 $+4$，时间 $+274$，缺页数 $+1$。两者都变为 $\\mathsf{S}$。\n- 总计：消息数 $20$，时间 $1114$，缺页数 $5$。版本号和 $= 3$（页面 0）$+ 1$（页面 1）$= 4$。\n\n测试用例 4：\n- 参数：$N=3$, $P=3$, $B=128$, $L_n=3$, $L_s=2$, $T_b=1$。因此 $C=2\\cdot 3 + 2 = 8$，$P=8 + 128\\cdot 1 = 136$。\n- 操作：无。\n- 总计：消息数 $0$，时间 $0$，缺页数 $0$，版本号和 $0$。\n\n因此，按顺序排列的每个测试用例的最终要求输出为：\n- 测试用例 1：$[12,478,3,1]$。\n- 测试用例 2：$[4,268,1,3]$。\n- 测试用例 3：$[20,1114,5,4]$。\n- 测试用例 4：$[0,0,0,0]$。\n\n您的程序必须精确实现上述规则，并生成单行输出，将这四个结果列表聚合为一个列表的列表，格式如前所述。", "answer": "[[12, 478, 3, 1], [4, 268, 1, 3], [20, 1114, 5, 4], [0, 0, 0, 0]]", "id": "3677099"}]}