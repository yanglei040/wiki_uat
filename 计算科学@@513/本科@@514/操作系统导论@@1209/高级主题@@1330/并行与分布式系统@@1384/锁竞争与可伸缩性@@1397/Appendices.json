{"hands_on_practices": [{"introduction": "为了定量地分析锁的争用情况，我们可以将锁抽象为一个排队系统中的服务台。这个练习 [@problem_id:3654523] 将指导你如何运用强大的 $M/G/1$ 排队模型来预测线程获取锁所需的平均等待时间。掌握这项技能对于性能预测和瓶颈分析至关重要。", "problem": "一个操作系统内核使用单个互斥锁来保护对共享运行队列的更新。线程根据泊松过程尝试获取锁，到达率为每秒 $\\lambda$ 次。获取锁后，线程执行一个临界区，其时间是一个随机变量 $S$（锁持有时间），该时间在线程间独立且与到达过程无关。该锁使用先到先服务（FCFS）的准入策略，并且调度程序确保在线程持有锁期间提供非抢占式服务。假设系统处于稳态，其中 $\\lambda \\mathbb{E}[S]  1$。\n\n您可以使用以下基本事实：(i) 泊松到达过程的泊松到达见时间平均（PASTA）特性，(ii) 利特尔定律（Little’s Law），以及 (iii) 更新过程的平均剩余寿命恒等式，$\\mathbb{E}[R] = \\mathbb{E}[S^{2}] / \\left(2 \\mathbb{E}[S]\\right)$，其中 $R$ 是在繁忙期内随机时刻观察到的剩余服务时间。\n\n在此工作负载中，到达率为每秒 $\\lambda = 150{,}000$ 次。临界区时间 $S$ 具有双峰分布：$S = 1$ 微秒的概率为 $0.9$，$S = 10$ 微秒的概率为 $0.1$。\n\n从上述核心定义和事实出发，将该锁建模为单服务台 FCFS 队列，并推导一个表达式，用于计算一个到达线程在获取锁之前等待的平均时间（不包括其自身的临界区时间）。然后，在给定参数下评估该平均等待时间。以微秒为单位表示您的最终数值答案，并四舍五入到四位有效数字。", "solution": "首先验证问题，以确保其科学上合理、自洽且提法明确。\n\n### 第一步：提取已知条件\n-   **模型**：单服务台先到先服务（FCFS）队列。\n-   **到达过程**：泊松过程，到达率为每秒 $\\lambda = 150{,}000$ 次。\n-   **服务时间**：一个随机变量 $S$。其分布为双峰分布：$P(S = 1 \\text{ µs}) = 0.9$ 且 $P(S = 10 \\text{ µs}) = 0.1$。服务时间在线程间独立且与到达过程无关。\n-   **稳定性条件**：系统处于稳态，其中 $\\lambda \\mathbb{E}[S]  1$。\n-   **给定的基本事实**：\n    1.  泊松到达见时间平均（PASTA）。\n    2.  利特尔定律。\n    3.  平均剩余寿命恒等式：$\\mathbb{E}[R] = \\frac{\\mathbb{E}[S^2]}{2 \\mathbb{E}[S]}$，其中 $R$ 是在繁忙期内随机时刻观察到的剩余服务时间。\n-   **目标**：推导队列中平均等待时间 $\\mathbb{E}[W_q]$ 的表达式，然后根据给定参数进行计算。最终答案应以微秒为单位，并四舍五入到四位有效数字。\n\n### 第二步：使用提取的已知条件进行验证\n该问题描述了一个具有泊松到达和一般服务时间分布的单服务台队列（M/G/1 队列），这是排队论中一个标准且被充分理解的模型，常用于计算机系统性能分析。该问题具有科学依据。\n\n问题提供了推导解决方案所需的所有必要参数（$\\lambda$ 和 $S$ 的分布）及理论工具。必须验证队列的稳定性。\n平均服务时间 $\\mathbb{E}[S]$ 为：\n$$ \\mathbb{E}[S] = (1 \\text{ µs}) \\times 0.9 + (10 \\text{ µs}) \\times 0.1 = 0.9 \\text{ µs} + 1.0 \\text{ µs} = 1.9 \\text{ µs} = 1.9 \\times 10^{-6} \\text{ s} $$\n到达率为 $\\lambda = 150{,}000 \\text{ s}^{-1}$。\n服务台利用率 $\\rho$ 由 $\\lambda \\mathbb{E}[S]$ 给出：\n$$ \\rho = (150{,}000 \\text{ s}^{-1}) \\times (1.9 \\times 10^{-6} \\text{ s}) = 1.5 \\times 10^5 \\times 1.9 \\times 10^{-6} = 0.285 $$\n由于 $\\rho = 0.285  1$，稳定性条件得到满足，存在稳态解。问题提法明确且内部一致。问题客观且无歧义。\n\n### 第三步：结论与行动\n问题有效。将提供完整解答。\n\n### 平均等待时间的推导\n该系统被建模为 M/G/1 队列。我们的目标是求出队列中的平均等待时间，记为 $\\mathbb{E}[W_q]$。这是一个到达线程在开始其临界区之前所花费的平均等待时间。\n\n考虑一个到达队列的线程。它必须等待的时间 $W_q$ 等于为系统中已存在的所有线程提供服务所需的总时间。这个时间由两部分组成：\n1.  当前持有锁的线程的剩余服务时间（如果有的话）。我们称这个随机变量为 $R_a$。\n2.  在新到达线程之前，队列中所有等待线程的全部服务时间之和。\n\n因此，我们可以将一个到达线程的等待时间写为：\n$$ W_q = R_a + \\sum_{i=1}^{N_q} S_i $$\n其中 $N_q$ 是到达时队列中等待的线程数，$S_i$ 是队列中第 $i$ 个线程的服务时间。\n\n根据期望的线性性质，平均等待时间为：\n$$ \\mathbb{E}[W_q] = \\mathbb{E}[R_a] + \\mathbb{E}\\left[\\sum_{i=1}^{N_q} S_i\\right] $$\n\n由于 PASTA 特性，一个到达的线程观察到的系统处于其稳态。队列中线程数的时间平均值为 $\\mathbb{E}[N_q]$。服务时间 $S_i$ 与 $N_q$ 无关。我们可以对第二项应用沃尔德恒等式（Wald's identity）：\n$$ \\mathbb{E}\\left[\\sum_{i=1}^{N_q} S_i\\right] = \\mathbb{E}[S] \\mathbb{E}[N_q] $$\n根据应用于队列的利特尔定律，平均等待线程数是到达率和平均等待时间的乘积：\n$$ \\mathbb{E}[N_q] = \\lambda \\mathbb{E}[W_q] $$\n将此代入前一个方程得到：\n$$ \\mathbb{E}\\left[\\sum_{i=1}^{N_q} S_i\\right] = \\mathbb{E}[S] (\\lambda \\mathbb{E}[W_q]) = (\\lambda \\mathbb{E}[S]) \\mathbb{E}[W_q] = \\rho \\mathbb{E}[W_q] $$\n\n现在我们分析第一项，$\\mathbb{E}[R_a]$，即一个到达者所看到的平均剩余服务时间。一个到达的线程发现服务台（锁）正忙的概率为 $\\rho = \\lambda \\mathbb{E}[S]$，空闲的概率为 $1 - \\rho$。\n如果服务台空闲，剩余时间为 $0$。如果服务台正忙，期望的剩余服务时间由条件于服务台正忙的平均剩余寿命恒等式给出，即 $\\mathbb{E}[R] = \\frac{\\mathbb{E}[S^2]}{2 \\mathbb{E}[S]}$。\n因此，一个到达者所看到的无条件期望剩余时间是：\n$$ \\mathbb{E}[R_a] = \\rho \\cdot \\mathbb{E}[R] + (1-\\rho) \\cdot 0 = (\\lambda \\mathbb{E}[S]) \\cdot \\frac{\\mathbb{E}[S^2]}{2 \\mathbb{E}[S]} = \\frac{\\lambda \\mathbb{E}[S^2]}{2} $$\n\n结合这两部分的表达式，我们得到：\n$$ \\mathbb{E}[W_q] = \\frac{\\lambda \\mathbb{E}[S^2]}{2} + \\rho \\mathbb{E}[W_q] $$\n现在我们可以解出 $\\mathbb{E}[W_q]$：\n$$ \\mathbb{E}[W_q] - \\rho \\mathbb{E}[W_q] = \\frac{\\lambda \\mathbb{E}[S^2]}{2} $$\n$$ \\mathbb{E}[W_q] (1 - \\rho) = \\frac{\\lambda \\mathbb{E}[S^2]}{2} $$\n$$ \\mathbb{E}[W_q] = \\frac{\\lambda \\mathbb{E}[S^2]}{2(1-\\rho)} $$\n这就是用于计算平均等待时间的波拉切克-欣钦（Pollaczek-Khinchine）公式。\n\n### 数值计算\n为了计算这个表达式，我们首先计算服务时间 $S$ 的必要矩。为方便起见，我们用微秒 (µs) 作为时间单位进行计算。\n到达率为 $\\lambda = 150{,}000 \\text{ s}^{-1} = 150{,}000 \\times 10^{-6} \\text{ µs}^{-1} = 0.15 \\text{ µs}^{-1}$。\n服务时间 $S$ 的分布为 $P(S=1 \\text{ µs}) = 0.9$ 和 $P(S=10 \\text{ µs}) = 0.1$。\n\n一阶矩（平均服务时间）：\n$$ \\mathbb{E}[S] = (1 \\text{ µs} \\times 0.9) + (10 \\text{ µs} \\times 0.1) = 0.9 \\text{ µs} + 1.0 \\text{ µs} = 1.9 \\text{ µs} $$\n\n服务时间的二阶矩：\n$$ \\mathbb{E}[S^2] = \\sum_{i} s_i^2 P(S=s_i) = ((1 \\text{ µs})^2 \\times 0.9) + ((10 \\text{ µs})^2 \\times 0.1) = (1 \\text{ µs}^2 \\times 0.9) + (100 \\text{ µs}^2 \\times 0.1) = 0.9 \\text{ µs}^2 + 10 \\text{ µs}^2 = 10.9 \\text{ µs}^2 $$\n\n服务台利用率 $\\rho$：\n$$ \\rho = \\lambda \\mathbb{E}[S] = (0.15 \\text{ µs}^{-1}) \\times (1.9 \\text{ µs}) = 0.285 $$\n如验证时所确认，系统是稳定的。\n\n现在，我们将这些值代入 $\\mathbb{E}[W_q]$ 的公式中：\n$$ \\mathbb{E}[W_q] = \\frac{\\lambda \\mathbb{E}[S^2]}{2(1-\\rho)} = \\frac{(0.15 \\text{ µs}^{-1}) \\times (10.9 \\text{ µs}^2)}{2(1-0.285)} $$\n$$ \\mathbb{E}[W_q] = \\frac{1.635 \\text{ µs}}{2(0.715)} = \\frac{1.635 \\text{ µs}}{1.43} $$\n$$ \\mathbb{E}[W_q] \\approx 1.14335664... \\text{ µs} $$\n问题要求答案四舍五入到四位有效数字。\n$$ \\mathbb{E}[W_q] \\approx 1.143 \\text{ µs} $$\n一个到达的线程在获取锁之前等待的平均时间约为 $1.143$ 微秒。", "answer": "$$\\boxed{1.143}$$", "id": "3654523"}, {"introduction": "当一个线程发现锁被占用时，它必须等待。这个实践 [@problem_id:3654546] 探讨了一个关键的设计抉择：是采用主动的“自旋”等待还是被动的“睡眠”等待，并重点关注其能耗影响。通过计算两种策略的能耗平衡点，你将学会如何设计出在不同争用水平下都能保持高效的自适应锁策略。", "problem": "一个多核应用程序运行在一个系统上，其中等待锁的线程可以选择主动地在锁上自旋，或自愿地休眠（挂起）并在稍后被唤醒。将因锁竞争而浪费的能量定义为线程因等待锁而无法取得进展时所消耗的能量。仅使用以下基本事实：能量等于功率的时间积分，和的期望值等于期望值的和。\n\n考虑以下简化模型和参数：\n\n- 有 $N$ 个相同的线程，每个线程以每秒 $a$ 次尝试的速率试图进入同一个临界区。其中有比例为 $f$ 的尝试会遇到锁竞争而必须等待。在给定的竞争水平下，平均等待时长（从到达至获取）为 $W$。\n- 自旋时，一个等待中的线程在整个等待期间持续消耗功率 $P_{\\text{spin}}$。\n- 休眠时，一个等待中的线程在等待期间消耗功率 $P_{\\text{sleep}}$，并且每次等待还会产生一次性的唤醒转换能量成本 $E_{\\text{wake}}$。忽略对其他线程的任何性能副作用，并假设在等待期间核心上没有安排其他工作。\n- 使用 $E=\\int P(t)\\,dt$ 表示能量，并假设在上述建模的每种状态下功率水平是恒定的。\n\n任务：\n\n1. 从 $E=\\int P(t)\\,dt$ 出发，推导在纯自旋策略和纯休眠策略下，每秒浪费的期望能量的表达式，用 $N$、$a$、$f$、$W$、$P_{\\text{spin}}$、$P_{\\text{sleep}}$ 和 $E_{\\text{wake}}$ 表示。清晰地陈述您使用的任何中间期望值。\n\n2. 使用参数 $N=8$、$a=1000$ s$^{-1}$、$P_{\\text{spin}}=10$ W、$P_{\\text{sleep}}=1.5$ W、$E_{\\text{wake}}=5\\times 10^{-4}$ J，对三种竞争水平，评估任务1中得出的表达式。对于每种竞争水平，报告自旋和休眠策略下每秒浪费的能量（单位为 J/s）。\n   - 低竞争：$f=0.01$，$W=0.05$ ms。\n   - 中等竞争：$f=0.20$，$W=0.50$ ms。\n   - 高竞争：$f=0.60$，$W=5.00$ ms。\n\n3. 使用相同模型，定义 $T^{\\star}$ 为单次等待中自旋消耗的能量等于休眠消耗的能量时的等待时长。推导 $T^{\\star}$ 关于 $P_{\\text{spin}}$、$P_{\\text{sleep}}$ 和 $E_{\\text{wake}}$ 的闭式表达式，然后用上述参数进行数值计算。以毫秒为单位表示 $T^{\\star}$，并将最终数值答案四舍五入至三位有效数字。\n\n4. 简要提出一个节能锁策略，该策略使用您对 $T^{\\star}$ 的结果来动态决定等待者应该自旋还是休眠，并论证为何在变化的竞争下它在能量上是有利的。\n\n只有任务3中 $T^{\\star}$ 的数值将被作为最终答案评分。请按要求以毫秒为单位表示 $T^{\\star}$。", "solution": "该问题陈述已经过验证，被认为是合理、定义明确且客观的。它提供了一个基于既定物理原理和计算机科学概念的可形式化模型。所有必要的参数都已定义，并且任务的结构能够导出一个唯一且有意义的解决方案。\n\n### 任务1：期望浪费能量速率的推导\n\n我们被要求推导在两种不同的锁策略（纯自旋和纯休眠）下每秒的期望浪费能量，即平均浪费功率。我们将平均浪费功率表示为 $\\mathcal{P}_{\\text{wasted}}$。\n\n首先，我们确定锁竞争事件发生的速率。有 $N$ 个线程，每个线程以每秒 $a$ 次尝试的速率获取锁。其中比例为 $f$ 的尝试会遇到竞争。所有线程的总竞争尝试速率 $R_{\\text{contend}}$ 是这些量的乘积：\n$$\nR_{\\text{contend}} = N \\times a \\times f\n$$\n该速率的单位是“每秒竞争事件数”或 s$^{-1}$。\n\n接下来，我们确定单次竞争事件的期望浪费能量。问题将浪费的能量 $E$ 定义为功率 $P(t)$ 的时间积分：$E = \\int P(t) \\, dt$。设 $T_{\\text{wait}}$ 为线程等待竞争锁的时长的随机变量。我们已知其期望值为 $E[T_{\\text{wait}}] = W$。\n\n**纯自旋策略：**\n在此策略下，等待中的线程在整个等待时长 $T_{\\text{wait}}$ 内消耗恒定的功率 $P_{\\text{spin}}$。单次等待事件中浪费的能量 $E_{\\text{wait,spin}}$ 为：\n$$\nE_{\\text{wait,spin}} = \\int_0^{T_{\\text{wait}}} P_{\\text{spin}} \\, dt = P_{\\text{spin}} T_{\\text{wait}}\n$$\n每次竞争事件的期望浪费能量即为所要求的中间期望值：\n$$\nE[E_{\\text{wait,spin}}] = E[P_{\\text{spin}} T_{\\text{wait}}] = P_{\\text{spin}} E[T_{\\text{wait}}] = P_{\\text{spin}} W\n$$\n\n**纯休眠策略：**\n在此策略下，等待中的线程在时长 $T_{\\text{wait}}$ 内消耗功率 $P_{\\text{sleep}}$，并产生一次性的唤醒转换能量成本 $E_{\\text{wake}}$。单次等待事件中浪费的能量 $E_{\\text{wait,sleep}}$ 为：\n$$\nE_{\\text{wait,sleep}} = \\left(\\int_0^{T_{\\text{wait}}} P_{\\text{sleep}} \\, dt\\right) + E_{\\text{wake}} = P_{\\text{sleep}} T_{\\text{wait}} + E_{\\text{wake}}\n$$\n每次竞争事件的期望浪费能量即为所要求的中间期望值：\n$$\nE[E_{\\text{wait,sleep}}] = E[P_{\\text{sleep}} T_{\\text{wait}} + E_{\\text{wake}}] = P_{\\text{sleep}} E[T_{\\text{wait}}] + E_{\\text{wake}} = P_{\\text{sleep}} W + E_{\\text{wake}}\n$$\n\n最后，每秒总期望浪费能量（平均浪费功率）是竞争事件的速率乘以每次事件的期望能量。这源于“和的期望等于期望的和”这一原则，该原则应用于给定时间间隔内的大量事件。\n\n对于纯自旋策略，每秒的期望浪费能量为：\n$$\n\\mathcal{P}_{\\text{wasted,spin}} = R_{\\text{contend}} \\times E[E_{\\text{wait,spin}}] = (Naf) \\times (P_{\\text{spin}} W) = NafP_{\\text{spin}}W\n$$\n\n对于纯休眠策略，每秒的期望浪费能量为：\n$$\n\\mathcal{P}_{\\text{wasted,sleep}} = R_{\\text{contend}} \\times E[E_{\\text{wait,sleep}}] = (Naf) \\times (P_{\\text{sleep}}W + E_{\\text{wake}})\n$$\n\n### 任务2：不同竞争水平下的评估\n\n给定参数：$N=8$，$a=1000$ s$^{-1}$，$P_{\\text{spin}}=10$ W，$P_{\\text{sleep}}=1.5$ W，以及 $E_{\\text{wake}}=5 \\times 10^{-4}$ J。我们必须为三种情景评估推导出的表达式，确保单位一致。等待时长 $W$ 以毫秒（ms）给出，因此我们通过乘以 $10^{-3}$ 将其转换为秒（s）。每秒浪费能量的单位是焦耳/秒（J/s），等同于瓦特（W）。\n\n尝试速率的公共因子是 $Na = 8 \\times 1000 \\text{ s}^{-1} = 8000 \\text{ s}^{-1}$。\n\n**低竞争：** $f=0.01$，$W=0.05 \\text{ ms} = 0.05 \\times 10^{-3}$ s。\n竞争事件的速率是 $R_{\\text{contend}} = Naf = 8000 \\times 0.01 = 80$ s$^{-1}$。\n$$\n\\mathcal{P}_{\\text{wasted,spin}} = (80 \\text{ s}^{-1}) \\times (10 \\text{ J/s}) \\times (0.05 \\times 10^{-3} \\text{ s}) = 0.04 \\text{ J/s}\n$$\n$$\n\\mathcal{P}_{\\text{wasted,sleep}} = (80 \\text{ s}^{-1}) \\times \\left( (1.5 \\text{ J/s}) \\times (0.05 \\times 10^{-3} \\text{ s}) + 5 \\times 10^{-4} \\text{ J} \\right) = 80 \\times (0.075 \\times 10^{-3} + 0.5 \\times 10^{-3}) = 80 \\times (0.575 \\times 10^{-3}) = 0.046 \\text{ J/s}\n$$\n- 对于低竞争：自旋浪费 $0.04$ J/s，休眠浪费 $0.046$ J/s。\n\n**中等竞争：** $f=0.20$，$W=0.50 \\text{ ms} = 0.50 \\times 10^{-3}$ s。\n竞争事件的速率是 $R_{\\text{contend}} = Naf = 8000 \\times 0.20 = 1600$ s$^{-1}$。\n$$\n\\mathcal{P}_{\\text{wasted,spin}} = (1600 \\text{ s}^{-1}) \\times (10 \\text{ J/s}) \\times (0.50 \\times 10^{-3} \\text{ s}) = 8 \\text{ J/s}\n$$\n$$\n\\mathcal{P}_{\\text{wasted,sleep}} = (1600 \\text{ s}^{-1}) \\times \\left( (1.5 \\text{ J/s}) \\times (0.50 \\times 10^{-3} \\text{ s}) + 5 \\times 10^{-4} \\text{ J} \\right) = 1600 \\times (0.75 \\times 10^{-3} + 0.5 \\times 10^{-3}) = 1600 \\times (1.25 \\times 10^{-3}) = 2 \\text{ J/s}\n$$\n- 对于中等竞争：自旋浪费 $8$ J/s，休眠浪费 $2$ J/s。\n\n**高竞争：** $f=0.60$，$W=5.00 \\text{ ms} = 5.00 \\times 10^{-3}$ s。\n竞争事件的速率是 $R_{\\text{contend}} = Naf = 8000 \\times 0.60 = 4800$ s$^{-1}$。\n$$\n\\mathcal{P}_{\\text{wasted,spin}} = (4800 \\text{ s}^{-1}) \\times (10 \\text{ J/s}) \\times (5.00 \\times 10^{-3} \\text{ s}) = 240 \\text{ J/s}\n$$\n$$\n\\mathcal{P}_{\\text{wasted,sleep}} = (4800 \\text{ s}^{-1}) \\times \\left( (1.5 \\text{ J/s}) \\times (5.00 \\times 10^{-3} \\text{ s}) + 5 \\times 10^{-4} \\text{ J} \\right) = 4800 \\times (7.5 \\times 10^{-3} + 0.5 \\times 10^{-3}) = 4800 \\times (8.0 \\times 10^{-3}) = 38.4 \\text{ J/s}\n$$\n- 对于高竞争：自旋浪费 $240$ J/s，休眠浪费 $38.4$ J/s。\n\n### 任务3：平衡等待时长 $T^{\\star}$ 的推导与评估\n\n我们将 $T^{\\star}$ 定义为在单次事件中，自旋消耗的能量等于休眠消耗的能量时的等待时长。设此时长为 $T$。\n自旋时长为 $T$ 的能量是 $E_{\\text{spin}}(T) = P_{\\text{spin}} T$。\n休眠时长为 $T$ 的能量是 $E_{\\text{sleep}}(T) = P_{\\text{sleep}} T + E_{\\text{wake}}$。\n\n令这两个表达式相等以找到平衡点 $T^{\\star}$：\n$$\nP_{\\text{spin}} T^{\\star} = P_{\\text{sleep}} T^{\\star} + E_{\\text{wake}}\n$$\n我们解出 $T^{\\star}$：\n$$\n(P_{\\text{spin}} - P_{\\text{sleep}}) T^{\\star} = E_{\\text{wake}}\n$$\n$$\nT^{\\star} = \\frac{E_{\\text{wake}}}{P_{\\text{spin}} - P_{\\text{sleep}}}\n$$\n这就是所要求的闭式表达式。\n\n现在我们使用给定参数计算 $T^{\\star}$：$P_{\\text{spin}}=10$ W，$P_{\\text{sleep}}=1.5$ W，以及 $E_{\\text{wake}}=5 \\times 10^{-4}$ J。\n$$\nT^{\\star} = \\frac{5 \\times 10^{-4} \\text{ J}}{10 \\text{ J/s} - 1.5 \\text{ J/s}} = \\frac{5 \\times 10^{-4}}{8.5} \\text{ s} \\approx 0.588235... \\times 10^{-4} \\text{ s}\n$$\n问题要求答案以毫秒（ms）为单位，并四舍五入至三位有效数字。我们将秒转换为毫秒，通过乘以 $1000$（或 $10^3$）。\n$$\nT^{\\star} \\approx (0.588235... \\times 10^{-4}) \\times 10^3 \\text{ ms} = 0.0588235... \\text{ ms}\n$$\n四舍五入到三位有效数字得到 $0.0588$ ms。\n\n### 任务4：提出的节能锁策略\n\n值 $T^{\\star}$ 代表了单次等待的能量平衡点。\n- 如果等待时间短于 $T^{\\star}$，自旋消耗的能量更少。\n- 如果等待时间长于 $T^{\\star}$，休眠消耗的能量更少。\n\n等待的线程事先并不知道等待时长。一个稳健的、节能的策略应该能适应这种不确定性。一个合适的策略是混合的、两阶段等待策略。\n\n**策略提议：先自旋后休眠**\n当一个线程发现锁被竞争时，它应该首先自旋一段时长 $T^{\\star}$。如果在此时间内获得了锁，则该线程使用了针对短等待的更节能的策略。如果在 $T^{\\star}$ 时间过去后锁仍被另一个线程持有，那么等待的线程应停止自旋并转换到休眠状态（即，将自己挂起），等待锁可用时被唤醒。\n\n**理由：**\n这个策略在能量上是有利的，因为它根据等待时间动态地选择更好的策略。\n1. **对于短等待（$W  T^{\\star}$）：** 线程很可能在初始的自旋阶段就获得锁。这正确地采用了自旋，对于这些短时等待而言，自旋比休眠更节能，因为它避免了相对较高的固定唤醒成本 $E_{\\text{wake}}$。\n2. **对于长等待（$W > T^{\\star}$）：** 线程将先自旋初始的 $T^{\\star}$ 时段，然后在剩余的 $W - T^{\\star}$ 时段内休眠。这个初始自旋的能量代价是最小的，因为根据 $T^{\\star}$ 的定义，自旋 $T^{\\star}$ 时长的能量等于休眠 $T^{\\star}$ 时长的能量（如果我们那样建模的话，也包括唤醒成本）。在余下的长等待时间里，线程受益于休眠状态下低得多的功耗（$P_{\\text{sleep}}  P_{\\text{spin}}$），与纯自旋策略相比，可以显著节省能量。\n\n这种自适应策略有效地对冲了两种情况，在无需事先知道等待时长的情况下，在变化的竞争水平下提供了近乎最优的能源性能。", "answer": "$$\\boxed{0.0588}$$", "id": "3654546"}, {"introduction": "自旋等待虽然实现简单，但并非“免费”的。最后的这个练习 [@problem_id:3645691] 将深入探讨锁争用在硬件层面带来的后果，特别是为了维护缓存一致性而在系统互连上产生的流量。通过计算自旋线程所消耗的带宽，你将更深刻地理解为什么高争用会从根本上限制系统的可伸缩性。", "problem": "一个多核处理器实现了一个基于目录的缓存一致性协议，该协议遵循修改-独占-共享-无效（MESI）状态。该系统是缓存一致性非均匀内存访问（ccNUMA）架构，所有核心都连接到一个单一的片上互连。考虑一个使用比较并交换（CAS）实现的竞争自旋锁，该锁采用测试并测试并设置（TTAS）范式，其中许多线程重复读取位于单个缓存行中的锁变量，并且仅当读取操作表明锁可能空闲时才尝试执行 CAS。假设 MESI 一致性流量具有以下基本事实：\n- 对缓存行的写入操作要求写入者通过“为所有权而读”（RFO）获取独占所有权，这将使该行的所有其他共享副本失效，并将该行的数据传输给写入者。\n- 对不在缓存中的缓存行进行读取操作会启动一个“共享读”（RS）事务，该事务将该行的数据传输给读取者。\n- 在一个高度竞争的 TTAS 锁中，当锁看起来空闲时，读取操作会使该行在许多共享者之间保持共享状态，而每次成功的获取或释放都是一次写入操作，会触发一次 RFO 并使所有共享者失效，之后每个被失效的自旋者在下一次写入之前都会通过恰好一次 RS 重新获取该行。\n\n假设有 $N=40$ 个线程（每个线程都固定到其自己的核心上）在大小为 $S=64$ 字节的单个缓存行上自旋。锁持有者的平均临界区时间为 $t_{cs}=150\\times 10^{-9}$ 秒，且竞争足够激烈，以至于锁一经释放就总有至少一个线程准备好立即获取它（锁的吞吐量受临界区限制）。每个自旋者轮询的频率足够高，以至于在两次连续写入之间的每个锁阶段都至少执行一次读取，因此每次无效化最终都会导致每个自旋者在下一次写入前产生恰好一个新的 RS。\n\n互连上的一致性消息大小如下：\n- RFO 请求头大小为 $h_{RFO}=16$ 字节；每个 RFO 会向每个共享者触发大小为 $h_{inv}=8$ 字节的无效化消息，并从每个被无效化的共享者那里收到大小为 $h_{ack}=8$ 字节的确认消息；每个 RFO 还会导致一个大小为 $S$ 字节的数据响应发送给写入者。\n- RS 请求头大小为 $h_{RS}=16$ 字节；每个 RS 会导致一个大小为 $S$ 字节的数据响应发送给读取者。\n\n忽略所有其他流量（例如，与锁无关的内存写回、超出所列消息大小的目录状态更新以及传输层流控单元）。将所有列出的消息大小视为每条消息在互连上传输的总字节数。\n\n从所述的 MESI 和 TTAS 行为出发，推导每秒无效化和为所有权而读（RFO）的稳态速率，然后计算该锁消耗的总一致性带宽（以字节/秒为单位），汇总由以下原因产生的字节数：\n- RFO 及其引起的无效化广播和确认消息，\n- 作为无效化结果而发生的 RS 请求及其数据响应。\n\n将最终带宽以 $\\mathrm{GBytes/s}$ 表示，并将您的答案四舍五入到四位有效数字。最终答案必须是一个实数值。", "solution": "用户希望我验证并解决一个关于多核系统中缓存一致性带宽的问题。\n\n### 第1步：问题验证\n\n首先，我必须仔细验证问题陈述。\n\n#### 提取的已知条件：\n-   **系统：** 一个多核处理器，有 $N=40$ 个线程，每个线程位于其自己的核心上。该架构是缓存一致性非均匀内存访问（ccNUMA），带有一个单一的片上互连。\n-   **协议：** 基于目录的 MESI（修改-独占-共享-无效）协议。\n-   **同步原语：** 一个使用测试并测试并设置（TTAS）范式、通过比较并交换（CAS）实现的竞争自旋锁。锁变量位于单个缓存行中。\n-   **性能参数：**\n    -   缓存行大小：$S = 64$ 字节。\n    -   平均临界区时间：$t_{cs} = 150 \\times 10^{-9}$ 秒。\n    -   线程/核心数：$N = 40$。\n-   **一致性消息大小：**\n    -   为所有权而读（RFO）请求头：$h_{RFO} = 16$ 字节。\n    -   无效化消息：$h_{inv} = 8$ 字节。\n    -   无效化确认：$h_{ack} = 8$ 字节。\n    -   RFO 数据响应：$S = 64$ 字节。\n    -   共享读（RS）请求头：$h_{RS} = 16$ 字节。\n    -   RS 数据响应：$S = 64$ 字节。\n-   **假设和系统行为：**\n    1.  一次写入需要一个 RFO，该 RFO 会使所有其他共享副本失效并将数据传输给写入者。\n    2.  一次读未命中会启动一个 RS，该 RS 会将数据传输给读取者。\n    3.  竞争激烈，使得锁的吞吐量受临界区限制。\n    4.  在 TTAS 锁中，每次成功的获取或释放都是一次触发 RFO 的写入。\n    5.  在 RFO 使共享者失效后，每个被失效的自旋者在下一次写入发生前都会通过恰好一次 RS 重新获取该行。\n\n#### 使用提取的已知条件进行验证：\n-   **科学依据：** 该问题坚实地建立在计算机体系结构和并行计算的原理之上。MESI、ccNUMA、TTAS、RFO 和 RS 都是标准的、定义明确的概念。所描述的行为是一个简化但标准的自旋锁竞争模型。\n-   **适定性：** 该问题是适定的。它提供了所有必要的数值（$N, S, t_{cs}$ 以及所有消息大小）和一套清晰的行为假设，从而可以计算出唯一且有意义的一致性带宽值。\n-   **客观性：** 问题陈述使用了精确、客观和技术性的语言，没有歧义或主观性陈述。\n-   **完整性和一致性：** 该问题是自洽的。这些假设虽然简化了一个复杂的过程，但是被明确陈述且内部一致。例如，“每次无效化导致每个自旋者产生一次 RS”的假设为计算提供了一个清晰的模型。\n-   **可行性：** 场景和参数在高性能计算环境中是现实的。消息大小和时序是合理的。\n\n#### 结论：\n该问题在科学上是合理的、适定的且内部一致。它为定量分析提供了有效的基础。我将继续进行求解。\n\n### 第2步：求解推导\n\n目标是计算竞争自旋锁消耗的总一致性带宽。策略是确定引起一致性事件的速率，并将其乘以每个事件传输的总数据量。\n\n#### 1. 一致性事件的速率\n问题指出，锁的吞吐量受临界区时间 $t_{cs}$ 的限制。这意味着平均每 $t_{cs}$ 秒发生一次锁的交接。一个单独的锁交接周期包括一个线程释放锁和另一个线程立即获取锁。\n-   **锁释放：** 这是一个写入操作，将锁变量设置为 `free`。\n-   **锁获取：** 这是一个成功的比较并交换（CAS）操作，它是一个读-改-写操作，本质上是一次写入。\n\n根据问题，“每次成功的获取或释放都是一次写入操作，会触发一次 RFO”。因此，在每个 $t_{cs}$ 的时间间隔内，会发生两次 RFO 事件。RFO 的速率 $f_{RFO}$ 为：\n$$f_{RFO} = \\frac{2}{t_{cs}}$$\n这也是无效化广播的速率，因为每个 RFO 会触发一次。数值上，该速率为：\n$$f_{RFO} = \\frac{2}{150 \\times 10^{-9} \\, s} = \\frac{2}{150} \\times 10^{9} \\, s^{-1} \\approx 1.33 \\times 10^{7} \\, s^{-1}$$\n\n#### 2. 每个 RFO 事件的一致性流量\n我们必须计算单个 RFO 及其直接后果产生的总互连流量。问题指出，一次 RFO 会使“所有其他共享副本”失效。在这个有 $N$ 个线程的高度竞争场景中，一个线程发出的 RFO 需要使其余 $N-1$ 个线程中的副本失效。\n\n一次此类事件的总流量 $B_{event}$ 是与 RFO 本身相关的流量和后续共享读（RS）请求产生的流量之和。\n\n**A. RFO 及其相关无效化产生的流量 ($B_{RFO\\_traffic}$):**\n-   写入核心发送的一个 RFO 请求头：$h_{RFO}$。\n-   发送到其他 $N-1$ 个核心的无效化消息：$(N-1) \\times h_{inv}$。\n-   从 $N-1$ 个被无效化的核心发回的确认消息：$(N-1) \\times h_{ack}$。\n-   发送给写入者的包含缓存行的单个数据响应：$S$。\n\n$$B_{RFO\\_traffic} = h_{RFO} + (N-1)(h_{inv} + h_{ack}) + S$$\n代入给定值：\n$$B_{RFO\\_traffic} = 16 \\, \\text{bytes} + (40-1)(8 \\, \\text{bytes} + 8 \\, \\text{bytes}) + 64 \\, \\text{bytes}$$\n$$B_{RFO\\_traffic} = 16 + 39 \\times 16 + 64 = 16 + 624 + 64 = 704 \\, \\text{bytes}$$\n\n**B. 随后的共享读（RS）请求产生的流量 ($B_{RS\\_traffic}$):**\nRFO 使 $N-1$ 个核心失效。问题指出“每个被失效的自旋者都会通过恰好一次 RS 重新获取该行”。这意味着 $N-1$ 个核心将发出 RS 请求。每个 RS 请求都会产生请求头和数据响应的流量。\n-   来自 $N-1$ 个核心的 RS 请求头：$(N-1) \\times h_{RS}$。\n-   发送到这 $N-1$ 个核心的数据响应：$(N-1) \\times S$。\n\n$$B_{RS\\_traffic} = (N-1)(h_{RS} + S)$$\n代入给定值：\n$$B_{RS\\_traffic} = (40-1)(16 \\, \\text{bytes} + 64 \\, \\text{bytes})$$\n$$B_{RS\\_traffic} = 39 \\times 80 = 3120 \\, \\text{bytes}$$\n\n**C. 每个事件的总流量：**\n与单个 RFO-无效化-重新获取序列相关的总流量为：\n$$B_{event} = B_{RFO\\_traffic} + B_{RS\\_traffic} = 704 \\, \\text{bytes} + 3120 \\, \\text{bytes} = 3824 \\, \\text{bytes}$$\n\n#### 3. 总一致性带宽\n总一致性带宽 $BW$ 是单位时间内产生的总流量。在每个 $t_{cs}$ 的时间周期内，发生两次这样的事件（一次用于释放，一次用于获取）。\n每个周期的总流量为 $B_{cycle} = 2 \\times B_{event}$。\n带宽是该流量除以周期时间 $t_{cs}$。\n$$BW = \\frac{B_{cycle}}{t_{cs}} = \\frac{2 \\times B_{event}}{t_{cs}}$$\n代入数值：\n$$BW = \\frac{2 \\times 3824 \\, \\text{bytes}}{150 \\times 10^{-9} \\, s} = \\frac{7648}{150} \\times 10^{9} \\, \\text{Bytes/s}$$\n$$BW \\approx 50.9866... \\times 10^{9} \\, \\text{Bytes/s}$$\n\n问题要求以 GBytes/s 为单位给出答案，其中 $1$ GByte $= 10^9$ 字节，并四舍五入到四位有效数字。\n$$BW \\approx 50.99 \\, \\text{GBytes/s}$$", "answer": "$$\\boxed{50.99}$$", "id": "3645691"}]}