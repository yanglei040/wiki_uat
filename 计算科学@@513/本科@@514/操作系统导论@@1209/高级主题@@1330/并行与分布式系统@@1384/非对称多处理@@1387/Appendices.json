{"hands_on_practices": [{"introduction": "非对称多处理的核心优势在于其专业化能力。本练习将引导你量化这一优势：通过对比一个能感知任务特性（I/O密集型 vs. CPU密集型）的智能调度器与一个普通调度器的系统吞吐量差异，你将亲手计算出非对称设计带来的性能提升。这个实践清晰地揭示了为什么将合适的任务分配给合适的处理器至关重要。[@problem_id:3621298]", "problem": "一个操作系统实验探索了非对称多处理（AMP），其中一个异构多处理器平台包含专门的工作核心。考虑一个拥有 $2$ 个工作核心和一个独立的调度核心的 AMP 系统，在稳态吞吐量下，调度核心的开销可以忽略不计。一个工作核心，记为 $W_{\\mathrm{IO}}$，专门用于处理输入/输出（I/O）密集型任务；另一个核心，记为 $W_{\\mathrm{CPU}}$，专门用于处理 CPU 密集型任务。实验要求学生设计一个调度器，该调度器使用 I/O 等待比率 $\\omega$（定义为任务因等待 I/O 而不可运行的时间占总时间的长期比例）来优先将 I/O 密集型任务分配给 $W_{\\mathrm{IO}}$，将 CPU 密集型任务分配给 $W_{\\mathrm{CPU}}$。系统在高的多道程序水平下运行，有大量独立任务，因此就绪队列实际上永不为空。\n\n将就绪的 CPU 工作建模为一连串大小统一的独立“计算量子”。每个量子要么属于 I/O 密集型任务，要么属于 CPU 密集型任务。在一个长期的观察窗口中，由 $\\omega$ 驱动的测量分类得出，所有就绪量子中有比例为 $p$ 的是 I/O 密集型的，比例为 $1-p$ 的是 CPU 密集型的，其中 $p=\\frac{4}{7}$。两个工作核心上每个量子的处理时间（服务时间），以毫秒为单位，如下所示：\n- 在 $W_{\\mathrm{IO}}$ 上：I/O 密集型量子的处理时间为 $t_{A,i}=3\\,\\mathrm{ms}$；CPU 密集型量子的处理时间为 $t_{A,c}=7\\,\\mathrm{ms}$。\n- 在 $W_{\\mathrm{CPU}}$ 上：I/O 密集型量子的处理时间为 $t_{B,i}=6\\,\\mathrm{ms}$；CPU 密集型量子的处理时间为 $t_{B,c}=4\\,\\mathrm{ms}$。\n\n假设除了两个工作核心外没有其他共享瓶颈，工作核心之间没有干扰，并且路由决策不会引入额外延迟。同时假设在使用感知 $\\omega$ 的策略时，分类是完美的：所有 I/O 密集型量子都被识别并可以路由到 $W_{\\mathrm{IO}}$，所有 CPU 密集型量子都可以路由到 $W_{\\mathrm{CPU}}$。在基准的“不感知 $\\omega$”的策略下，每个工作核心接收到具有相同 I/O 密集型量子比例 $p$ 的混合任务。\n\n仅从“吞吐量等于长期完成的量子数除以经过的时间”等基本定义出发，以及对于一个具有独立服务时间的饱和单一服务器，其长期吞吐量等于长期平均服务时间的倒数这一事实，推导并计算吞吐量差异\n$$\\Delta = \\text{throughput}_{\\omega\\text{-aware}} - \\text{throughput}_{\\omega\\text{-agnostic}}.$$\n将最终答案表示为以量子/秒为单位的精确值。不要四舍五入。", "solution": "问题要求计算一个非对称多处理（AMP）系统上两种调度策略之间的吞吐量差异。我们首先确立题目提供的基本原理和定义。系统总吞吐量，我们记为 $R$，定义为长期完成的量子数除以经过的时间。系统由两个并行操作的工作核心 $W_{\\mathrm{IO}}$ 和 $W_{\\mathrm{CPU}}$ 组成。在饱和状态下，单个服务器的吞吐量是其长期平均服务时间的倒数。\n\n设 $p$ 为 I/O 密集型量子的比例，给定为 $p = \\frac{4}{7}$。因此，CPU 密集型量子的比例是 $1 - p = 1 - \\frac{4}{7} = \\frac{3}{7}$。每个工作核心上处理 I/O 密集型（$i$）和 CPU 密集型（$c$）量子的服务时间以毫秒（$ms$）为单位给出：\n- 在 $W_{\\mathrm{IO}}$ 上：$t_{\\mathrm{IO},i} = 3\\,\\mathrm{ms}$ 和 $t_{\\mathrm{IO},c} = 7\\,\\mathrm{ms}$。\n- 在 $W_{\\mathrm{CPU}}$ 上：$t_{\\mathrm{CPU},i} = 6\\,\\mathrm{ms}$ 和 $t_{\\mathrm{CPU},c} = 4\\,\\mathrm{ms}$。\n\n首先，我们分析“不感知 $\\omega$”的策略。\n在此策略下，两个工作核心接收到相同的量子统计混合。由于就绪队列永不为空，两个工作核心都处于饱和状态。系统的总吞吐量是两个工作核心各自吞吐量之和。\n对于单个工作核心，吞吐量是其平均服务时间 $\\bar{t}$ 的倒数。平均服务时间是 I/O 密集型和 CPU 密集型量子服务时间的加权平均值。\n\n对于工作核心 $W_{\\mathrm{IO}}$，其平均服务时间为：\n$$ \\bar{t}_{\\mathrm{IO}, \\text{agnostic}} = p \\cdot t_{\\mathrm{IO},i} + (1-p) \\cdot t_{\\mathrm{IO},c} = \\left(\\frac{4}{7}\\right)(3) + \\left(\\frac{3}{7}\\right)(7) = \\frac{12}{7} + \\frac{21}{7} = \\frac{33}{7}\\,\\mathrm{ms} $$\n工作核心 $W_{\\mathrm{IO}}$ 的吞吐量为：\n$$ R_{\\mathrm{IO}, \\text{agnostic}} = \\frac{1}{\\bar{t}_{\\mathrm{IO}, \\text{agnostic}}} = \\frac{1}{33/7} = \\frac{7}{33}\\,\\text{quanta/ms} $$\n\n对于工作核心 $W_{\\mathrm{CPU}}$，其平均服务时间为：\n$$ \\bar{t}_{\\mathrm{CPU}, \\text{agnostic}} = p \\cdot t_{\\mathrm{CPU},i} + (1-p) \\cdot t_{\\mathrm{CPU},c} = \\left(\\frac{4}{7}\\right)(6) + \\left(\\frac{3}{7}\\right)(4) = \\frac{24}{7} + \\frac{12}{7} = \\frac{36}{7}\\,\\mathrm{ms} $$\n工作核心 $W_{\\mathrm{CPU}}$ 的吞吐量为：\n$$ R_{\\mathrm{CPU}, \\text{agnostic}} = \\frac{1}{\\bar{t}_{\\mathrm{CPU}, \\text{agnostic}}} = \\frac{1}{36/7} = \\frac{7}{36}\\,\\text{quanta/ms} $$\n\n不感知 $\\omega$ 策略的总吞吐量是个体吞吐量之和：\n$$ \\text{throughput}_{\\omega\\text{-agnostic}} = R_{\\mathrm{IO}, \\text{agnostic}} + R_{\\mathrm{CPU}, \\text{agnostic}} = \\frac{7}{33} + \\frac{7}{36} = 7 \\left( \\frac{1}{33} + \\frac{1}{36} \\right) = 7 \\left( \\frac{12 + 11}{396} \\right) = 7 \\left( \\frac{23}{396} \\right) = \\frac{161}{396}\\,\\text{quanta/ms} $$\n\n接下来，我们分析“感知 $\\omega$”的策略。\n在此策略下，完美的分类将所有 I/O 密集型量子路由到 $W_{\\mathrm{IO}}$，并将所有 CPU 密集型量子路由到 $W_{\\mathrm{CPU}}$。我们将其建模为两个并行的处理流水线。考虑大量的总量子数 $N$。I/O 密集型量子的数量为 $N_i = pN$，CPU 密集型量子的数量为 $N_c = (1-p)N$。\n$W_{\\mathrm{IO}}$ 处理所有 $N_i$ 个量子所需的时间为：\n$$ T_{\\mathrm{IO}} = N_i \\cdot t_{\\mathrm{IO},i} = (pN) \\cdot t_{\\mathrm{IO},i} $$\n$W_{\\mathrm{CPU}}$ 处理所有 $N_c$ 个量子所需的时间为：\n$$ T_{\\mathrm{CPU}} = N_c \\cdot t_{\\mathrm{CPU},c} = ((1-p)N) \\cdot t_{\\mathrm{CPU},c} $$\n由于两个工作核心并行操作，处理整批 $N$ 个量子的总时间 $T$ 由两个流水线中较慢的一个（瓶颈）决定：\n$$ T = \\max(T_{\\mathrm{IO}}, T_{\\mathrm{CPU}}) = \\max((pN) \\cdot t_{\\mathrm{IO},i}, ((1-p)N) \\cdot t_{\\mathrm{CPU},c}) $$\n根据其基本定义，系统总吞吐量为 $R = N/T$：\n$$ \\text{throughput}_{\\omega\\text{-aware}} = \\frac{N}{\\max((pN) \\cdot t_{\\mathrm{IO},i}, ((1-p)N) \\cdot t_{\\mathrm{CPU},c})} = \\frac{1}{\\max(p \\cdot t_{\\mathrm{IO},i}, (1-p) \\cdot t_{\\mathrm{CPU},c})} $$\n我们现在计算 $\\max$ 函数内部的值：\n$$ p \\cdot t_{\\mathrm{IO},i} = \\frac{4}{7} \\cdot 3 = \\frac{12}{7}\\,\\mathrm{ms} $$\n$$ (1-p) \\cdot t_{\\mathrm{CPU},c} = \\frac{3}{7} \\cdot 4 = \\frac{12}{7}\\,\\mathrm{ms} $$\n在此策略下，系统是完美平衡的，意味着相对于彼此，没有一个工作核心是瓶颈。因此：\n$$ \\text{throughput}_{\\omega\\text{-aware}} = \\frac{1}{12/7} = \\frac{7}{12}\\,\\text{quanta/ms} $$\n\n最后，我们计算吞吐量差异 $\\Delta$：\n$$ \\Delta = \\text{throughput}_{\\omega\\text{-aware}} - \\text{throughput}_{\\omega\\text{-agnostic}} = \\frac{7}{12} - \\frac{161}{396} $$\n为了进行分数相减，我们找到一个公分母，即 $396 = 12 \\times 33$。\n$$ \\Delta = \\frac{7 \\cdot 33}{12 \\cdot 33} - \\frac{161}{396} = \\frac{231}{396} - \\frac{161}{396} = \\frac{231 - 161}{396} = \\frac{70}{396} $$\n化简分数得到：\n$$ \\Delta = \\frac{35}{198}\\,\\text{quanta/ms} $$\n问题要求答案以量子/秒为单位。因为 1 秒有 $1000$ 毫秒，我们将结果乘以 $1000$：\n$$ \\Delta_{\\text{quanta/s}} = \\frac{35}{198} \\times 1000 = \\frac{35000}{198} = \\frac{17500}{99} $$\n分数 $\\frac{17500}{99}$ 是最简形式。", "answer": "$$\\boxed{\\frac{17500}{99}}$$", "id": "3621298"}, {"introduction": "理解了任务专业化的好处后，我们必须面对一个现实挑战：任务迁移并非没有代价。本练习将带你探究非对称系统中一个主要的性能开销来源——当任务在缓存大小不同（例如“大核”与“小核”）的处理器之间迁移时，可能发生的缓存抖动（cache thrashing）。通过计算由此产生的额外时钟周期损失，你将更深刻地理解调度决策中需要权衡的实际硬件成本。[@problem_id:3621294]", "problem": "考虑一个由一个“大”核和一个“小”核组成的非对称多处理 (Asymmetric Multiprocessing, AMP) 系统。大核拥有一个容量为 $2\\,\\text{MiB}$ 的私有二级缓存 (L2)，而小核拥有一个容量为 $512\\,\\text{KiB}$ 的私有 L2。两个核心共享一个末级缓存 (LLC)。您正在设计一个实验室测量，以量化将一个内存密集型任务从大核迁移到小核所带来的与缓存相关的性能影响，重点关注迁移后因缓存颠簸 (cache thrash) 而增加的周期损失。\n\n该任务重复扫描一个数组，其工作集大小为 $W = 1.5\\,\\text{MiB}$，其中包含连续的 64 字节行。在跨核上下文切换到小核后，该任务在其时间片内对该数组执行两次遍历。将因缓存颠簸而损失的周期数 $L$ 定义为：相对于一个假设基准（即小核的 L2 能够容纳整个工作集，且第二次遍历将由 L2 命中来服务），在第二次遍历中，由于工作集无法装入小核的 L2 而产生的额外停顿周期。为保证科学真实性，假设：\n\n- 缓存行大小为 $B = 64\\,\\text{B}$。\n- 小核的时钟频率为 $f_{L} = 1.5 \\times 10^{9}\\,\\text{cycles/s}$。\n- 小核的 L2 命中延迟（当工作集能装入时的假设基准）为 $c_{\\mathrm{L2}} = 14$ 个周期。\n- 在迁移后的第二次遍历期间，通过硬件性能计数器测得，L2 未命中但在共享末级缓存 (LLC) 中命中的概率为 $p = 0.75$，而 LLC 未命中并需要访问主内存的概率为 $1 - p$。\n- 测得的 LLC 命中时间为 $t_{\\mathrm{LLC}} = 35\\,\\text{ns}$，测得的主内存访问时间为 $t_{\\mathrm{MEM}} = 120\\,\\text{ns}$。\n\n使用内存层次结构性能和周期-时间转换（周期等于频率乘以时间）的基本定义，计算 $L$ 作为一个实数值，表示在小核上由于缓存颠簸，在第二次遍历中相对于同一核心上的 L2 命中基准所造成的额外周期损失。将您的最终答案四舍五入到四位有效数字。以周期为单位表示最终答案。", "solution": "目标是计算任务迁移到较小缓存后，在第二次遍历其工作集时损失的周期数 $L$。该损失 $L$ 定义为实际场景中内存访问所花费的周期数与假设基准场景中的周期数之差。\n\n首先，我们确定单次遍历中的总内存访问次数。工作集大小为 $W = 1.5\\,\\text{MiB}$，缓存行大小为 $B = 64\\,\\text{B}$。工作集中的唯一缓存行数 $N_{\\text{lines}}$ 为：\n$$N_{\\text{lines}} = \\frac{W}{B} = \\frac{1.5 \\times 2^{20}\\,\\text{B}}{64\\,\\text{B}} = \\frac{1.5 \\times 2^{20}}{2^6} = 1.5 \\times 2^{14} = 1.5 \\times 16384 = 24576$$\n对数组的一次完整遍历涉及 $N_{\\text{lines}}$ 次缓存行访问。\n\n接下来，我们分析第二次遍历的假设基准场景。在此基准中，假设小核的 L2 缓存足够大，可以容纳整个 $1.5\\,\\text{MiB}$ 的工作集。在第一次遍历之后，整个工作集将驻留在 L2 缓存中。因此，在第二次遍历期间，$N_{\\text{lines}}$ 次访问中的每一次都将是 L2 命中。L2 命中的延迟给定为 $c_{\\mathrm{L2}} = 14$ 个周期。\n在基准场景中，第二次遍历的总周期数 $C_{\\text{baseline}}$ 为：\n$$C_{\\text{baseline}} = N_{\\text{lines}} \\times c_{\\mathrm{L2}}$$\n\n现在，我们分析实际场景。小核的 L2 缓存容量为 $C_L = 512\\,\\text{KiB} = 0.5\\,\\text{MiB}$。工作集大小为 $W = 1.5\\,\\text{MiB}$。由于 $W > C_L$，工作集无法装入 L2 缓存。任务按顺序扫描数组。\n在第一次遍历期间，$0.5\\,\\text{MiB}$ 的 L2 缓存被工作集的前三分之一填满。随着扫描的继续，较旧的缓存行被逐出，为较新的行腾出空间。当第一次遍历完成时，L2 缓存包含工作集的最后 $0.5\\,\\text{MiB}$。\n当第二次遍历开始时，它从数组的开头开始。数组开头的缓存行在第一次遍历期间已被逐出。因此，第二次遍历期间的每次访问都将导致 L2 缓存未命中。这是一个典型的缓存颠簸案例。\n必须计算 L2 未命中的成本。此成本是 LLC 命中和主内存访问的加权平均值。延迟以时间为单位给出，必须使用小核的频率 $f_{L} = 1.5 \\times 10^{9}\\,\\text{cycles/s}$ 转换为周期数。\n\nLLC 命中延迟（以周期为单位），$c_{\\mathrm{LLC}}$，为：\n$$c_{\\mathrm{LLC}} = t_{\\mathrm{LLC}} \\times f_{L} = (35 \\times 10^{-9}\\,\\text{s}) \\times (1.5 \\times 10^{9}\\,\\text{cycles/s}) = 52.5\\,\\text{cycles}$$\n主内存访问延迟（以周期为单位），$c_{\\mathrm{MEM}}$，为：\n$$c_{\\mathrm{MEM}} = t_{\\mathrm{MEM}} \\times f_{L} = (120 \\times 10^{-9}\\,\\text{s}) \\times (1.5 \\times 10^{9}\\,\\text{cycles/s}) = 180\\,\\text{cycles}$$\n\nL2 未命中但在 LLC 中命中的概率为 $p = 0.75$。其未命中 LLC 并需访问主内存的概率为 $1-p = 0.25$。L2 未命中的平均成本 $c_{\\text{miss,L2}}$ 为：\n$$c_{\\text{miss,L2}} = p \\times c_{\\mathrm{LLC}} + (1 - p) \\times c_{\\mathrm{MEM}}$$\n$$c_{\\text{miss,L2}} = (0.75 \\times 52.5) + (0.25 \\times 180) = 39.375 + 45 = 84.375\\,\\text{cycles}$$\n\n在实际场景中，第二次遍历的每次访问都是 L2 未命中。第二次遍历的总周期数 $C_{\\text{actual}}$ 为：\n$$C_{\\text{actual}} = N_{\\text{lines}} \\times c_{\\text{miss,L2}}$$\n\n损失的周期数 $L$ 是产生的额外周期，即实际场景与基准场景之间的差值：\n$$L = C_{\\text{actual}} - C_{\\text{baseline}} = (N_{\\text{lines}} \\times c_{\\text{miss,L2}}) - (N_{\\text{lines}} \\times c_{\\mathrm{L2}}) = N_{\\text{lines}} \\times (c_{\\text{miss,L2}} - c_{\\mathrm{L2}})$$\n此公式表示总访问次数乘以每次访问在 L2 中未命中相对于在 L2 中命中的周期惩罚。\n\n代入计算出的值：\n$$L = 24576 \\times (84.375 - 14) = 24576 \\times 70.375$$\n$$L = 1729536\\,\\text{cycles}$$\n\n问题要求将答案四舍五入到四位有效数字。\n$$L = 1729536 \\approx 1730000 = 1.730 \\times 10^6$$\n$1.730$ 中末尾的零是有效数字。", "answer": "$$\\boxed{1.730 \\times 10^{6}}$$", "id": "3621294"}, {"introduction": "现在，我们将视角从单个任务扩展到整个系统，分析一种经典的非对称架构——主从模型（master-worker model）。在这种设计中，所有系统调用都被转发到一个专用的主处理器上处理。本练习将运用排队论这一强大工具，对该系统进行建模，让你能够计算系统调用的端到端延迟，并理解主处理器在系统负载增加时如何成为潜在的性能瓶颈。[@problem_id:3621335]", "problem": "考虑一个用于教学实验室的非对称多处理（Asymmetric Multiprocessing, AMP）操作系统（Operating System, OS）设计。在这个 AMP 系统中，有一个专用的主核心（master core）执行所有特权内核系统调用，还有 $n$ 个相同的从核心（worker core）执行用户级线程。当一个在从核心上运行的用户线程发起系统调用时，从核心会将该系统调用转发给主核心。转发过程会在从核心上产生一个测量到的软件开销 $c$，用于整理参数和触发处理器间中断。当主核心完成系统调用后，它会将结果发送回始发从核心，这在返回路径上会产生额外的开销 $c$。假设以下模型假设作为分析的基本基础：\n\n- 每个从核心根据一个独立的泊松过程（Poisson process）生成系统调用请求，其速率为 $\\lambda$（请求/秒）。\n- 主核心一次处理一个系统调用请求，其服务时间是独立同分布的指数分布，速率为 $\\mu$（请求/秒）。\n- 独立泊松过程的叠加产生一个新的泊松过程，其速率等于各个速率之和。主核心可以被建模为一个 $M/M/1$ 队列，该队列当且仅当总到达率严格小于服务率时是稳定的。\n- 所有队列均为先进先出（First-In First-Out, FIFO），转发和返回路径上的转发开销 $c$ 是确定性的，并且与主核心的服务时间不重叠。\n\n将系统调用的端到端延迟（end-to-end latency）定义为从从核心发起系统调用转发的那一刻到从核心接收到返回值的瞬间所经过的时间。在实验室中，测量和配置的参数如下：\n- 从核心数量：$n = 6$。\n- 每个核心的系统调用到达率：$\\lambda = 800$ 请求/秒。\n- 主核心服务率：$\\mu = 6000$ 请求/秒。\n- 单向转发开销：$c = 8$ 微秒。\n\n任务：\n- 从给定的模型假设出发，推导以下内容的符号表达式：\n  1. 到达主核心的总到达率、流量强度以及主核心队列中请求的期望数量。\n  2. 作为 $n$, $\\lambda$, $\\mu$ 和 $c$ 的函数的预期端到端系统调用延迟。\n- 然后，使用提供的数值计算预期的端到端系统调用延迟。用毫秒表示你的最终数值答案，并四舍五入到四位有效数字。", "solution": "该问题要求分析一个非对称多处理（AMP）系统中的系统调用延迟。该系统使用排队论进行建模，其中主核心被视为一个 $M/M/1$ 队列。我们的任务是为关键性能指标推导符号表达式，然后计算端到端延迟的数值。\n\n首先，我们将按要求推导符号表达式。该系统由 $n$ 个从核心组成，每个从核心根据速率为 $\\lambda$ 的泊松过程生成系统调用请求。这些请求都指向单个主核心。\n\n1.  **总到达率、流量强度和预期队列长度**\n\n到达主核心的总到达率（用 $\\Lambda$ 表示）是来自 $n$ 个独立从核心的速率之和。根据泊松过程的叠加性质：\n$$ \\Lambda = \\sum_{i=1}^{n} \\lambda = n\\lambda $$\n主核心以速率 $\\mu$ 服务这些请求，服务时间服从指数分布。流量强度 $\\rho$ 是总到达率与服务率的比值。它代表服务器（主核心）繁忙的时间比例。\n$$ \\rho = \\frac{\\Lambda}{\\mu} = \\frac{n\\lambda}{\\mu} $$\n为使排队系统稳定，到达率必须严格小于服务率，即 $\\rho  1$。\n\n对于一个稳定的 $M/M/1$ 系统，主核心队列中请求的期望数量 $L_q$ 由以下公式给出：\n$$ L_q = \\frac{\\rho^2}{1-\\rho} $$\n代入 $\\rho$ 的表达式，我们得到：\n$$ L_q = \\frac{\\left(\\frac{n\\lambda}{\\mu}\\right)^2}{1 - \\frac{n\\lambda}{\\mu}} = \\frac{(n\\lambda)^2}{\\mu(\\mu - n\\lambda)} $$\n\n2.  **预期的端到端系统调用延迟**\n\n系统调用的端到端延迟 $T_{e2e}$ 定义为从从核心发起转发到接收到结果的瞬间所经过的时间。这个总时间是三个不同的、不重叠的部分之和：\n- 初始转发开销，$c$。\n- 在主核心系统中所花费的时间，$W$。这包括在队列中等待的时间和服务时间。\n- 返回路径开销，$c$。\n\n因此，单个请求的总延迟为 $T_{e2e} = c + W + c = 2c + W$。我们关心的是这个延迟的期望值 $E[T_{e2e}]$。由于 $c$ 是一个确定性常数，我们有：\n$$ E[T_{e2e}] = E[2c + W] = 2c + E[W] $$\n$E[W]$ 是一个请求在 $M/M/1$ 系统中花费的期望时间（也称为期望逗留时间）。对于一个稳定的 $M/M/1$ 队列，这个值由以下公式给出：\n$$ E[W] = \\frac{1}{\\mu - \\Lambda} $$\n将 $\\Lambda = n\\lambda$ 代入此表达式，得到：\n$$ E[W] = \\frac{1}{\\mu - n\\lambda} $$\n最后，我们可以写出预期的端到端延迟的符号表达式：\n$$ E[T_{e2e}] = 2c + \\frac{1}{\\mu - n\\lambda} $$\n\n现在，我们使用提供的参数值进行数值计算：\n- 从核心数量：$n = 6$\n- 每个核心的系统调用到达率：$\\lambda = 800 \\text{ s}^{-1}$\n- 主核心服务率：$\\mu = 6000 \\text{ s}^{-1}$\n- 单向转发开销：$c = 8 \\text{ µs} = 8 \\times 10^{-6} \\text{ s}$\n\n首先，我们计算总到达率 $\\Lambda$：\n$$ \\Lambda = n\\lambda = 6 \\times 800 \\text{ s}^{-1} = 4800 \\text{ s}^{-1} $$\n我们检查稳定性条件：\n$$ \\rho = \\frac{\\Lambda}{\\mu} = \\frac{4800}{6000} = 0.8 $$\n由于 $\\rho = 0.8  1$，系统是稳定的，我们的模型适用。\n\n接下来，我们计算在主核心系统中的期望时间 $E[W]$：\n$$ E[W] = \\frac{1}{\\mu - n\\lambda} = \\frac{1}{6000 - 4800} \\text{ s} = \\frac{1}{1200} \\text{ s} $$\n换算成小数，$\\frac{1}{1200} \\approx 0.0008333... \\text{ s}$。\n\n现在，我们计算预期的端到端延迟 $E[T_{e2e}]$：\n$$ E[T_{e2e}] = 2c + E[W] = 2 \\times (8 \\times 10^{-6} \\text{ s}) + \\frac{1}{1200} \\text{ s} $$\n$$ E[T_{e2e}] = 1.6 \\times 10^{-5} \\text{ s} + \\frac{1}{1200} \\text{ s} $$\n$$ E[T_{e2e}] = 0.000016 \\text{ s} + 0.0008333... \\text{ s} = 0.000849333... \\text{ s} $$\n问题要求答案以毫秒（ms）为单位。我们将结果从秒转换为毫秒：\n$$ E[T_{e2e}] = 0.000849333... \\text{ s} \\times 1000 \\frac{\\text{ms}}{\\text{s}} = 0.849333... \\text{ ms} $$\n最后，我们将答案四舍五入到四位有效数字。前四位有效数字是 $8, 4, 9, 3$。随后的数字是 $3$，所以我们不向上取整。\n$$ E[T_{e2e}] \\approx 0.8493 \\text{ ms} $$", "answer": "$$\\boxed{0.8493}$$", "id": "3621335"}]}