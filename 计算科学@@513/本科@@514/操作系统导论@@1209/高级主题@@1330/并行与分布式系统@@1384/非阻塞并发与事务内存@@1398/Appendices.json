{"hands_on_practices": [{"introduction": "在无锁并发编程中，像“比较并交换”（CAS）这样的原子操作是基础。然而，直接使用它们可能会引入微妙的“ABA问题”。为了解决这个问题，一种常见的技术是使用“标记指针”或版本计数器。[@problem_id:3663893] 将此理论付诸实践，要求你扮演系统设计者的角色：根据系统的性能指标和可靠性要求，计算出版本标签需要多少位才能有效防止ABA问题，从而将一个抽象的并发问题转化为一个具体的工程计算。", "problem": "一个使用原子比较并交换（CAS）操作实现的无锁栈，在单个 $64$ 位字中使用带标签的指针来缓解 ABA 问题。头字段由一个指针和一个版本标签组成，每当一次成功的、改变头指针的 CAS 操作（包括入栈和出栈）发生时，该版本标签就会加 $1$。版本标签以模 $2^{b}$ 的形式存储，其中 $b$ 是标签的位数。系统的最坏情况下成功的头指针更新速率为每秒 $N$ 次更新。为确保在长度为 $T$ 的目标无回绕间隔内，ABA 问题不会因标签回绕而被隐藏，标签在任何长度为 $T$ 的间隔内都不能发生回绕。\n\n假设如下：\n- 最坏情况下持续的成功头指针更新速率为 $N = 1.2 \\times 10^{8}$ 次/秒。\n- 要求的无回绕间隔为 $T = 3$ 小时。\n\n仅使用原子比较并交换（CAS）的标准语义、ABA 问题的定义以及速率和计数随时间变化的算术关系，确定保证在任何长度为 $T$ 的间隔内不发生标签回绕所需的最小整数标签宽度 $b$（以比特为单位）。以精确的整数比特数表示您的答案。最终答案中不要包含任何单位。", "solution": "问题要求在给定最坏更新速率 $N$ 的情况下，确定版本标签所需的最小整数比特数 $b$，以防止在指定的时间间隔 $T$ 内发生回绕。这是设计无锁数据结构以缓解 ABA 问题时的一个经典问题。\n\n首先，我们将给定的参数形式化。\n最坏情况下持续的成功头指针更新速率为 $N = 1.2 \\times 10^{8}$ 次/秒。\n要求的无回绕间隔为 $T = 3$ 小时。\n版本标签是一个用 $b$ 个比特存储的整数计数器，每次成功更新时都会递增。该标签可以表示 $2^b$ 个不同的值，从 $0$ 到 $2^b - 1$。当计数器递增 $2^b$ 次时，会发生回绕，其值将重置为起始值（模 $2^b$）。\n\n核心原则是，为保证在间隔 $T$ 内不发生回绕，此间隔内可能发生的最大更新总数必须严格小于标签可以表示的唯一状态数。\n\n设 $U_{max}$ 为时间间隔 $T$ 内可能发生的最大更新次数。该值通过将更新速率 $N$ 乘以间隔时长 $T$ 来计算。\n首先，我们必须将 $T$ 转换为与 $N$ 一致的单位，即秒。\n给定 $T = 3$ 小时，我们将其转换为秒：\n$$T_{\\text{seconds}} = 3 \\text{ hours} \\times \\frac{60 \\text{ minutes}}{1 \\text{ hour}} \\times \\frac{60 \\text{ seconds}}{1 \\text{ minute}} = 3 \\times 3600 \\text{ seconds} = 10800 \\text{ s}$$\n\n接下来，我们计算在此间隔内的最大更新总数 $U_{max}$：\n$$U_{max} = N \\times T_{\\text{seconds}}$$\n$$U_{max} = (1.2 \\times 10^{8} \\text{ s}^{-1}) \\times (10800 \\text{ s})$$\n$$U_{max} = 1.2 \\times 10^{8} \\times 1.08 \\times 10^{4}$$\n$$U_{max} = 1.296 \\times 10^{12}$$\n\n一个 $b$ 位标签可以表示的不同状态数为 $2^b$。为防止回绕，总更新次数 $U_{max}$ 必须小于 $2^b$。\n$$U_{max}  2^b$$\n$$1.296 \\times 10^{12}  2^b$$\n\n为了找到满足此不等式的最小整数值 $b$，我们对两边取以 2 为底的对数：\n$$\\log_{2}(1.296 \\times 10^{12})  \\log_{2}(2^b)$$\n$$\\log_{2}(1.296 \\times 10^{12})  b$$\n\n我们可以计算该对数值：\n$$\\log_{2}(1.296 \\times 10^{12}) = \\frac{\\ln(1.296 \\times 10^{12})}{\\ln(2)}$$\n使用计算工具以获得精确值：\n$$\\ln(1.296 \\times 10^{12}) \\approx 27.890270$$\n$$\\ln(2) \\approx 0.693147$$\n$$b > \\frac{27.890270}{0.693147} \\approx 40.236606$$\n\n由于 $b$ 必须是整数，满足条件 $b > 40.236606$ 的最小整数值是 $41$。\n因此，版本标签至少需要 $b=41$ 位，以确保在给定的最坏更新速率下，在任何 $3$ 小时的间隔内都不会发生回绕。\n如果 $b=40$，状态数为 $2^{40} \\approx 1.0995 \\times 10^{12}$。这个值小于所要求的 $1.296 \\times 10^{12}$ 次更新，因此可能发生回绕。\n如果 $b=41$，状态数为 $2^{41} \\approx 2.1990 \\times 10^{12}$。这个值大于 $1.296 \\times 10^{12}$，因此满足无回绕条件。", "answer": "$$\\boxed{41}$$", "id": "3663893"}, {"introduction": "从底层原子操作转向更高级的抽象，事务内存（TM）旨在通过提供原子性和隔离性来简化并发编程。然而，现实世界的系统充满了复杂性，例如异步的操作系统信号。[@problem_id:3663950] 提出了一个在操作系统或运行时系统开发者面前的关键设计挑战：当一个信号中断了正在执行的事务时，应该如何处理才能不破坏TM的核心保证？这个练习迫使我们思考在正确性、活性和性能之间必须做出的权衡。", "problem": "在一个支持事务内存（Transactional Memory, TM）的操作系统中，考虑一个拥有多个线程的单一进程。一个给定的线程执行一个事务，记为 $T$，该事务更新一个共享数据结构。该操作系统还支持可移植操作系统接口（Portable Operating System Interface, POSIX）信号。一个信号，记为 $S$，可以被传递给一个特定的线程，并导致一个用户级信号处理器，记为 $H$，在该线程上运行。信号处理器 $H$ 可能会执行输入/输出、读取共享数据结构以及修改线程局部状态。\n\n假设以下基本定义和系统事实为基础：\n- 事务 $T$ 的原子性和隔离性：$T$ 的所有内存效应要么在提交时全部生效，要么全部不生效（全有或全无），并且没有其他代码能观察到 $T$ 的部分效应。形式上，如果 $M_0$ 是 $T$ 开始时的内存状态，$M_1$ 是 $T$ 提交时的状态，那么可见的内存转换要么是提交时的 $M_0 \\rightarrow M_1$，要么是中止时的 $M_0 \\rightarrow M_0$；绝不能有外部可见的中间状态。\n- 信号 $S$ 是一个异步事件。在 POSIX 语义下，处理器 $H$ 作为被中断线程上的一个异步控制转移来执行，并且只能安全地调用被指定为异步信号安全的函数。由 $H$ 产生的输入/输出效应是外部可见的，并且不能被 TM 回滚。\n- 硬件事务内存（Hardware Transactional Memory, HTM）和软件事务内存（Software Transactional Memory, STM）都提供 $T$ 的推测执行并检测冲突，但 $T$ 的推测性写入在提交前对外部是不可见的。HTM 和 STM 通常都不提供机制来使输入/输出具有事务性，或者在不中止事务的情况下，跨任意异步处理器执行来挂起并随后恢复一个事务。\n- 信号传递的活性要求：虽然不保证立即传递，但系统不应允许对 $S$ 的无限期延迟，以至于如果线程长时间处于事务中，$H$ 可能永远不会运行。\n\n假设当线程正在执行 $T$ 的过程中 $S$ 到达，并且 $H$ 可能会触及 $T$ 读取或写入的内存。在不假设不切实际的新硬件能力的情况下，哪种处理 $S$ 的语义能最好地保留 TM 的保证（原子性和隔离性）、避免向 $H$ 或外部世界暴露未提交的状态，并保持合理的活性？\n\n选择最佳选项。\n\n- A. 立即在 $T$ 内部执行 $H$，使得 $H$ 的所有内存访问和输入/输出都成为与 $T$ 相同的推测上下文的一部分。如果 $T$ 提交，则 $T$ 和 $H$ 的效应原子性地变得可见；如果 $T$ 中止，则所有效应，包括输入/输出，都会被回滚。\n\n- B. 在收到 $S$ 时自动中止 $T$，丢弃 $T$ 的所有推测性效应，然后在任何事务之外的同一线程上传递 $H$。在 $H$ 返回后，运行时可以根据程序员的策略选择性地重试 $T$。\n\n- C. 将 $S$ 的传递推迟到 $T$ 成功提交后的下一个事务边界，然后运行 $H$。如果由于争用 $T$ 不断重试，$S$ 将保持待处理状态直到提交发生。\n\n- D. 中断 $T$ 并在任何事务之外传递 $H$，同时系统快照 $T$ 的推测状态，并在稍后从中断点恢复 $T$，使其推测性读写集保持完整，就好像 $T$ 从未被中断一样。处理器 $H$ 必须避免访问 $T$ 的推测性读写集中的任何内存。\n\n- E. 在 $S$ 到达的瞬间强制提交 $T$，使 $T$ 的所有效应立即变得可见，然后在 $T$ 之外运行 $H$，以确保及时处理，而不中止 $T$ 已经完成的工作。", "solution": "问题要求分析当一个线程正在执行内存事务 $T$ 时，如何处理一个到达的异步 POSIX 信号 $S$。目标是找到一个能够最好地保留事务内存（TM）的保证（即原子性和隔离性）的语义模型，同时确保信号传递的活性，并且不依赖于不切实际的系统能力。\n\n让我们基于所提供的基本原则来分析这个问题。\n\n事务 $T$ 由其原子性来定义。内存状态的转换必须是从一个一致状态 $M_0$ 到另一个一致状态 $M_1$（提交时），或者回到原始状态 $M_0$（中止时）。任何中间的、部分修改的状态都绝不应对系统的任何其他部分可见。这个属性至关重要。\n\n一个 POSIX 信号处理器 $H$ 代表一个异步控制流。关键的是，问题陈述了 $H$ 可以执行输入/输出（I/O）。I/O 操作是程序内存状态之外的副作用，并且通常是不可逆的。例如，如果发出 I/O 的事务后来中止了，那么写入文件或通过网络发送的数据是无法“收回”的。I/O 的这种非事务性是一个关键约束。如前所述：“由 $H$ 产生的输入/输出效应是外部可见的，并且不能被 TM 回滚。”\n\n问题还引入了一个活性要求：“系统不应允许对 $S$ 的无限期延迟。” 这排除了那些可能无限期推迟信号处理的解决方案。\n\n最后，我们必须在常见的硬件事务内存（HTM）和软件事务内存（STM）实现的现实约束内操作，这些实现不支持事务性 I/O 或在异步事件中挂起并恢复事务的通用能力。\n\n在这些原则确立之后，我们可以系统地评估每个提议的选项。\n\n**A. 立即在 $T$ 内部执行 $H$，使得 $H$ 的所有内存访问和输入/输出都成为与 $T$ 相同的推测上下文的一部分。如果 $T$ 提交，则 $T$ 和 $H$ 的效应原子性地变得可见；如果 $T$ 中止，则所有效应，包括输入/输出，都会被回滚。**\n这个选项与问题的基本前提存在根本性的矛盾。它声称由 $H$ 执行的输入/输出可以被回滚。然而，问题定义明确指出 I/O 效应“不能被 TM 回滚”。如果 $H$ 在 $T$ 内部执行，进行了一次 I/O 操作（例如，打印到控制台），然后 $T$ 中止，那么这个 I/O 效应将会保留下来。这违反了“全有或全无”的原子性保证，而这是事务的基石。系统将处于这样一种状态：一部分推测执行（I/O）产生了永久的外部效应，而另一部分（内存更改）已被丢弃。这是一个不一致且不可接受的结果。\n**结论：不正确。**\n\n**B. 在收到 $S$ 时自动中止 $T$，丢弃 $T$ 的所有推测性效应，然后在任何事务之外的同一线程上传递 $H$。在 $H$ 返回后，运行时可以根据程序员的策略选择性地重试 $T$。**\n这种方法在事务上下文和信号处理上下文之间提供了一个清晰而安全的分离。\n1.  **原子性和隔离性：** 通过中止 $T$，系统维护了原子性保证。中止是一个有效的事务结果，将内存返回到事务之前的状态 $M_0$。$T$ 的所有推测性和未提交的效应都被丢弃，因此隔离性得到了完美的保持。\n2.  **信号处理器执行：** 处理器 $H$ 随后在一个正常的、非事务性的状态下执行。它看到的是一致的内存状态 $M_0$。它执行的任何 I/O 都是非推测性的，并正确反映了程序当时的状态。\n3.  **活性：** 信号 $S$ 在中止后得到及时处理。没有无限期延迟，满足了活性要求。\n4.  **现实性：** 这种“悲观”方法在现实世界的 TM 系统中是一种被广泛采用的实用策略，因为它简单、安全，并且不需要任何特殊的硬件或复杂的软件机制。其代价是丢弃在 $T$ 中已完成工作的性能损失，但这是在面对异步、非事务性事件时为保证正确性和安全性所必须付出的代价。\n**结论：正确。**\n\n**C. 将 $S$ 的传递推迟到 $T$ 成功提交后的下一个事务边界，然后运行 $H$。如果由于争用 $T$ 不断重试，$S$ 将保持待处理状态直到提交发生。**\n这个选项清晰地将事务与信号处理器分离开来。然而，它未能满足活性要求。问题明确考虑了事务可能长时间运行或因争用而反复重试的情况。在这种情况下，“如果由于争用 $T$ 不断重试，$S$ 将保持待处理状态直到提交发生”会导致信号可能被任意长时间延迟的情况。这种无限期延迟直接违反了所述的活性要求。对于某些信号（例如，`SIGTERM`、`SIGINT`），如此长的延迟是不可接受的。\n**结论：不正确。**\n\n**D. 中断 $T$ 并在任何事务之外传递 $H$，同时系统快照 $T$ 的推测状态，并在稍后从中断点恢复 $T$，使其推测性读写集保持完整，就好像 $T$ 从未被中断一样。处理器 $H$ 必须避免访问 $T$ 的推测性读写集中的任何内存。**\n这个选项提出了一个事务的“挂起与恢复”机制。问题陈述本身对此表示怀疑，指出 TM 系统“通常都不提供机制来……挂起并随后恢复一个事务”。这确实需要复杂且“不切实际”的硬件或软件支持，而这些支持通常是不可用的。此外，它施加了一个条件，即“$H$ 必须避免访问 $T$ 的推测性读写集中的任何内存。” 这在两个方面存在问题。首先，问题陈述了 $H$ *可能*会触及 $T$ 读取或写入的内存，因此这个约束与问题的设定相矛盾。其次，在运行时强制执行这样的约束将是困难且非标准的。这个选项描述的是一个假设的、先进的系统，而不是在给定约束下的一个现实解决方案。\n**结论：不正确。**\n\n**E. 在 $S$ 到达的瞬间强制提交 $T$，使 $T$ 的所有效应立即变得可见，然后在 $T$ 之外运行 $H$，以确保及时处理，而不中止 $T$ 已经完成的工作。**\n这个选项违反了事务的本质。事务是程序员定义的一个逻辑工作单元，旨在完整执行以确保数据一致性。在一个任意的、过早的时间点（信号到达时）强制提交，会使一组不完整的内存修改永久化。这几乎肯定会破坏共享数据结构，违反应用程序的不变式。例如，如果 $T$ 正在通过从一个账户借记并向另一个账户贷记来转移资金，如果在借记之后、贷记之前强制提交，将导致资金丢失。这破坏了预期操作的原子性，是正确性上的灾难性失败。\n**结论：不正确。**\n\n基于对所述原则的严格应用，只有选项 B 提供了一种在事务期间处理信号的可行、安全且现实的机制。它通过中止事务来优先考虑正确性和系统稳定性，从而为信号处理器的执行创造一个干净的状态，并完全符合问题陈述中给出的所有约束。", "answer": "$$\\boxed{B}$$", "id": "3663950"}, {"introduction": "在分析了底层的实现细节和高层的设计抉择之后，检验理解程度的最终方法是亲手构建一个系统。[@problem_id:3663912] 提供了这样一个顶点练习：模拟实现一个事务性内存分配器。这个任务虽然不简单，但它是一个经典的例子，融合了许多关键概念：使用原子操作维护全局状态，利用线程本地的推测执行来处理事务性变更，以及对无法回滚的“不可撤销”操作进行特殊处理。这个练习将理论知识综合运用到一个具体的模拟实现中。", "problem": "您需要设计并实现一个非阻塞、事务性的、每线程的内存分配器模拟器，该模拟器能在多线程间强制执行一致的全局记账，并能正确处理不可撤销的释放操作。您编写的程序必须是一个完整、可运行的程序，并能按照下文描述的精确格式输出单行结果。\n\n基本和核心定义：\n- 使用比较并交换（CAS）实现的原子读-改-写是一种广泛接受的原语，它可以在无锁的情况下提供线性化的更新。通过一个可以进行递增和比较交换的原子整数来对此进行建模。\n- 在事务性内存模型中，一个线程执行一个事务，该事务会累积一个写集合增量（在此即净内存变化），并原子性地提交。设全局总分配字节数为 $G$，每线程的本地已分配字节数为 $L_i$，每个事务的净变化为 $\\Delta_i$。一次正确的提交必须保持 $G_{\\text{final}} = G_{\\text{initial}} + \\sum \\Delta_i^{\\text{committed}}$ 以及 $G_{\\text{final}} = \\sum L_i^{\\text{final}}$。\n- 非阻塞进度意味着没有线程持有锁；进度是通过原子操作和中止/重试机制实现的。不可撤销操作是指无法安全回滚的操作。一个不可撤销的 $free()$ 调用必须进行全局串行化以保持正确性；在同一时间只能有一个线程执行该操作。\n\n行为规范：\n- 每个线程 $i$ 开始时都有一个已知的本地分配量 $L_i$（单位为字节）。全局总量 $G$ 的初始值与 $G = \\sum L_i$ 保持一致。\n- 每个线程执行一个包含三种有序操作序列的事务：\n  1. 分配（Allocate）：将本地增量增加一个非负整数值 $a$，即 $\\Delta \\leftarrow \\Delta + a$。\n  2. 释放（Free）：将本地增量减少一个非负整数值 $f$，即 $\\Delta \\leftarrow \\Delta - f$。\n  3. 不可撤销的释放（Irrevocable free）：该操作效果与释放（free）相同，但必须全局串行化执行。一个线程在其事务中最多只能执行一次不可撤销的释放。在任何时候，只有一个线程可以持有不可撤销权，该权利通过一个全局所有者变量建模，并使用CAS获取。如果请求线程无法获得不可撤销权，其事务必须立即中止，不执行任何全局或本地更改。\n- 如果事务在提交时会导致本地分配量变为负数，则该事务也必须中止。形式上，只有当 $L_i + \\Delta \\ge 0$ 时，才允许提交。\n- 成功提交时，将 $\\Delta$ 原子性地应用于 $G$，并更新 $L_i \\leftarrow L_i + \\Delta$，同时释放持有的任何不可撤销所有权。中止时，$G$ 和 $L_i$ 保持不变，并释放已获得的任何不可撤销所有权。\n\n不可撤销释放的确定性决胜机制：\n- 为避免本练习中的不确定性和活锁，使用一个全局的决胜标识符来指定下一个允许获取不可撤销权的线程。当尝试进行不可撤销释放时，只有其标识符与该决胜标识符相等的线程才能获取不可撤销权；其他尝试进行不可撤销释放的线程必须立即中止。如果决胜标识符设置为 $-1$，则所有线程都可以尝试获取。但在本问题的测试套件中，只要有多个线程并发执行不可撤销释放操作，决胜标识符就会被设置为一个特定的线程标识符。\n\n您的程序必须：\n- 仅使用原子操作（无锁），利用线程实现并发，模拟上述事务性每线程分配器的语义。您必须使用整数类型的字节，所有记账均以字节为单位。\n- 为提供的测试套件生成单行输出，其中包含聚合结果，且格式必须完全符合规定。\n\n需要实现的测试套件：\n- 测试用例 $1$（正常路径，无不可撤销操作）：\n  - 线程数：$2$；决胜标识符 $=-1$。\n  - 初始本地值：$L_0 = 0$, $L_1 = 0$；设置 $G = 0$。\n  - 操作：\n    - 线程 $0$：分配 $100$，分配 $50$，释放 $70$。\n    - 线程 $1$：分配 $30$，释放 $10$，分配 $5$。\n  - 预期属性：两个事务都提交；最终记账必须一致。\n- 测试用例 $2$（不可撤销释放的串行化）：\n  - 线程数：$3$；决胜标识符 $=0$。\n  - 初始本地值：$L_0 = 200$, $L_1 = 150$, $L_2 = 0$；设置 $G = 350$。\n  - 操作：\n    - 线程 $0$：不可撤销地释放 $200$。\n    - 线程 $1$：不可撤销地释放 $150$。\n    - 线程 $2$：分配 $60$。\n  - 预期属性：线程 $0$ 提交其不可撤销释放；线程 $1$ 因决胜标识符限制在尝试不可撤销释放时中止；线程 $2$ 提交；最终记账必须一致。\n- 测试用例 $3$（净增量为零，提交成功）：\n  - 线程数：$1$；决胜标识符 $=-1$。\n  - 初始本地值：$L_0 = 100$；设置 $G = 100$。\n  - 操作：\n    - 线程 $0$：分配 $100$，释放 $100$。\n  - 预期属性：以 $\\Delta = 0$ 成功提交；最终记账必须一致。\n- 测试用例 $4$（因本地值为负而安全中止）：\n  - 线程数：$1$；决胜标识符 $=-1$。\n  - 初始本地值：$L_0 = 50$；设置 $G = 50$。\n  - 操作：\n    - 线程 $0$：释放 $60$。\n  - 预期属性：事务中止，因为 $L_0 + \\Delta = 50 - 60 = -10$ 将为负；最终记账必须一致。\n\n要求的输出格式：\n- 对于每个测试用例 $i$，计算最终的全局总字节数 $G_i$（一个整数）、已提交事务的数量 $C_i$（一个整数）、已中止事务的数量 $A_i$（一个整数），以及一个一致性指示符 $B_i$（布尔值，true表示为 $1$，false表示为 $0$），用于表示 $G_i = \\sum L_j^{\\text{final}}$ 是否成立。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的精确顺序为：$[G_1,C_1,A_1,B_1,G_2,C_2,A_2,B_2,G_3,C_3,A_3,B_3,G_4,C_4,A_4,B_4]$。\n\n所有答案均为整数。不允许用户输入；所有数据均按上述规定硬编码。", "solution": "该问题要求设计并实现一个用于非阻塞、事务性内存分配器的确定性模拟。解决方案遵循指定的行为规则，并按要求使用原子操作进行并发控制。该解决方案的核心是一个C程序，它模拟了四个不同的测试用例，每个用例都涉及多个执行事务的线程，然后将结果聚合到单行格式化的输出中。\n\n逻辑设计基于以下原则：\n\n1.  **状态表示**：系统状态分为共享的全局状态和每线程的本地状态。\n    -   全局已分配字节总数 $G$ 由一个 `_Atomic long` 变量表示。这确保了来自并发提交事务的更新能够被正确串行化并应用，而不会产生数据竞争。\n    -   不可撤销释放操作的所有权由一个全局的 `_Atomic int` 变量 `irrevocable_owner` 管理。值为 $-1$ 表示该权利未被拥有。ID为 $i$ 的线程通过成功执行比较并交换（CAS）操作，将该值从 $-1$ 更改为 $i$ 来获取该权利。\n    -   每线程的本地分配量 $L_i$ 存储在一个标准的 `long` 数组中。由于每个线程 $i$ 只修改自己的元素 $L_i$（且仅在成功提交时），因此无需对该数组进行直接的原子操作。主线程仅在所有工作线程终止后才访问该数组进行验证，从而避免了竞争条件。\n    -   每个测试用例的聚合统计数据——已提交事务数 $C_i$ 和已中止事务数 $A_i$——也通过 `_Atomic int` 计数器建模，以支持安全的并发递增。\n\n2.  **事务执行模型**：每个线程的执行被建模为单个、全有或全无的事务。一个专用的线程函数实现了这一逻辑。\n    -   **累积阶段**：线程首先处理其分配的操作序列（`allocate`、`free`、`irrevocable free`）。它在一个私有的本地变量中计算分配的净变化量 $\\Delta$。\n    -   **中止条件**：事务被设计为在特定条件下立即中止，从而在无锁的情况下确保前向进度和正确性。\n        -   **不可撤销释放失败**：如果 (a) `tie_breaker` 处于激活状态且线程ID不匹配，或 (b) 线程因所有权已被持有而未能通过CAS获取全局不可撤销所有权，则尝试执行 `irrevocable free` 将触发中止。\n        -   **安全违规**：在提交之前，事务会验证提交是否会导致本地分配量变为负数。如果 $L_i + \\Delta  0$，事务必须中止。\n    -   **提交/中止逻辑**：\n        -   **提交时**：如果没有满足中止条件，事务将提交。计算出的 $\\Delta$ 使用 `atomic_fetch_add` 原子性地加到全局总数 $G$ 上。线程的本地分配量更新为：$L_i \\leftarrow L_i + \\Delta$。如果线程已获得不可撤销权，它通过原子性地将 `irrevocable_owner` 设置回 $-1$ 来释放它。最后，全局提交计数器 $C_i$ 被原子性地递增。\n        -   **中止时**：全局状态 $G$ 和本地状态 $L_i$ 保持不变。如果线程在事务尝试期间获得了不可撤销权，必须释放它以防止死锁。全局中止计数器 $A_i$ 被原子性地递增。\n\n3.  **并发性与确定性**：该模拟利用C的 `threads.h` 库来创建和管理线程，从而对指定的并发环境进行建模。然而，问题的严格规则，包括每个线程固定的操作序列和用于不可撤销操作的确定性决胜机制，消除了运行时的不确定性。这确保了模拟对每个测试用例都能产生单一、可预测且可验证的结果。\n\n4.  **验证**：在给定测试用例的所有线程完成执行并被联接（join）后，主线程会执行最终的一致性检查。它计算所有最终的每线程本地分配量之和 $\\sum L_j^{\\text{final}}$，并将其与最终的全局分配总量 $G_i$ 进行比较。检查结果存储为布尔指示符 $B_i$，如果模拟正确，该值必须为真（$1$）。这验证了基本不变量 $G = \\sum L_j$。\n\n实现系统地将这些原则应用于四个测试用例中的每一个。定义了一个 `TestCase` 数据结构来保存初始参数（$L_i$ 值、决胜标识符）和每个线程的操作列表。主程序遍历这些测试用例，设置初始状态，运行并发模拟，并收集最终结果（$G_i, C_i, A_i, B_i$）。最后，它以精确指定的逗号分隔格式打印所有收集到的结果。", "answer": "$$\\boxed{[105,2,0,1,210,2,1,1,100,1,0,1,50,0,1,1]}$$", "id": "3663912"}]}