{"hands_on_practices": [{"introduction": "本次练习 [@problem_id:3671212] 将引导您分析经典的优先级反转场景。通过计算一系列中等优先级任务所造成的延迟，您将具体地理解，在没有优先级继承等保护机制的系统中，反转的持续时间会如何随着干预任务数量的增加而线性增长，甚至变得无法预测。这项实践揭示了优先级反转问题的核心危险，即高优先级任务的响应时间可能会被不相关的大量中等优先级活动所主导。", "problem": "一个单处理器调度器使用固定优先级抢占式调度，并对处于同一优先级的任务采用轮询时间分片。每当中央处理器 (CPU) 调度一个就绪任务运行时，都会产生一个持续时间为 $\\delta$ 的恒定上下文切换开销。一个高优先级任务 $H$ 试图获取一个当前由低优先级任务 $L$ 持有的互斥锁。系统中没有优先级继承机制：任务 $L$ 保持其低优先级。在任务 $H$ 因互斥锁而阻塞的瞬间，恰好有 $m$ 个中等优先级的任务 $\\{M_{1}, M_{2}, \\ldots, M_{m}\\}$ 处于就绪状态。每个中等优先级任务在被调度时，会运行恰好一个持续时间为 $q$ 的时间量，然后因输入/输出而阻塞，其阻塞时间足够长，以至于在此事件期间不会再次变为就绪状态。在此事件期间，没有其他任务到达。将本次实验运行的“优先级反转延迟” $D_{\\text{inv}}$ 定义为从任务 $H$ 因互斥锁而阻塞时开始，到最后一个中等优先级任务完成其一个时间量并阻塞后（即，在调度器下一次运行任务 $L$ 之前）立即结束的这段经过时间。在这个实验设计中，您将在不同的运行中改变 $q$、$\\delta$ 和 $m$ 的值。\n\n请仅使用固定优先级抢占式调度、时间量和上下文切换开销的核心定义，为所述场景中的一次运行推导 $D_{\\text{inv}}$ 作为 $q$、$\\delta$ 和 $m$ 的函数的解析表达式。然后，使用具体参数值 $q = 3.7$ 毫秒，$\\delta = 0.23$ 毫秒，以及 $m = 19$ 来计算您的表达式。将您的数值答案四舍五入到四位有效数字。最终延迟以毫秒为单位表示。最终结果只提供一个数字。", "solution": "该问题提出了一个涉及单处理器系统上任务调度的场景，并要求推导和计算一个称为“优先级反转延迟”的特定指标。\n\n### 步骤 1：问题验证\n\n首先，对问题陈述进行严格的验证。\n\n**提取已知条件：**\n- **调度策略：** 固定优先级抢占式调度。对于同一优先级的任务，使用轮询时间分片。\n- **系统：** 单处理器。\n- **上下文切换开销：** 每次调度就绪任务时，都会产生一个持续时间为 $\\delta$ 的恒定开销。\n- **任务集与状态：**\n    - 一个高优先级任务 $H$。\n    - 一个持有互斥锁的低优先级任务 $L$。\n    - $m$ 个中等优先级任务 $\\{M_{1}, M_{2}, \\ldots, M_{m}\\}$。\n    - 初始状态始于任务 $H$ 试图获取由 $L$ 持有的互斥锁并阻塞的瞬间。在同一瞬间，所有 $m$ 个中等优先级任务都处于就绪状态。\n- **任务行为：**\n    - 每个中等优先级任务 $M_i$ 在被调度时，会运行恰好一个持续时间为 $q$ 的时间量。\n    - 运行完其时间量后，每个 $M_i$ 会因输入/输出操作而阻塞，并且在关注的时间段内不会再次变为就绪状态。\n- **优先级继承：** 明确说明未实现。任务 $L$ 保持其低优先级。\n- **优先级反转延迟 $D_{\\text{inv}}$ 的定义：** 从 $H$ 因互斥锁而阻塞的时刻起，到 $m$ 个中等优先级任务中的最后一个完成其时间量并阻塞的时刻为止所经过的时间。\n- **用于评估的参数：** $q = 3.7$ 毫秒，$\\delta = 0.23$ 毫秒，以及 $m = 19$。\n\n**根据标准进行验证：**\n- **科学依据：** 该问题牢固地植根于操作系统的基本原理，特别是任务调度、并发控制（互斥锁）以及有充分文献记载的优先级反转现象。所使用的所有术语（$q$、$\\delta$、抢占、优先级）都是该领域的标准术语。该场景是用于说明调度行为的经典示例。\n- **适定性：** 该问题是适定的。初始条件被精确指定，所有相关任务的行为是确定性的，并且待计算的量 $D_{\\text{inv}}$ 有明确的起点和终点。这种结构确保可以推导出唯一且有意义的解。\n- **客观性：** 语言正式、精确，没有任何主观或模糊的术语。\n\n**结论：** 问题陈述是有效的，具有科学性、适定性、客观性和内部一致性。我将继续推导解决方案。\n\n### 步骤 2：解析表达式的推导\n\n问题要求计算高优先级任务 $H$ 经历的优先级反转延迟 $D_{\\text{inv}}$。此延迟是由 $m$ 个中等优先级任务的执行引起的，这些任务抢占了持有 $H$ 所需互斥锁的低优先级任务 $L$。\n\n让我们定义时间测量的起点 $t=0$ 为任务 $H$ 因互斥锁而阻塞的瞬间。\n在 $t=0$ 时，就绪任务集包括低优先级任务 $L$ 和 $m$ 个中等优先级任务 $\\{M_1, M_2, \\ldots, M_m\\}$。任务 $H$ 此时处于阻塞状态。\n\n根据固定优先级抢占式调度策略，调度器必须始终从最高优先级的非空队列中运行一个就绪任务。由于中等优先级任务的优先级高于任务 $L$，调度器将忽略 $L$，转而执行中等优先级任务。\n\n这 $m$ 个中等优先级任务都处于同一优先级水平，并使用轮询策略进行调度。这意味着它们将被顺序执行。由于它们的行为相同，具体的执行顺序（$M_1, M_2, \\ldots$ 或任何其他排列）不影响总耗时。我们假设它们按其索引顺序进行调度。\n\n1.  **任务 $M_1$ 的执行**：调度器选择 $M_1$ 运行。在 $M_1$ 执行之前，系统必须执行一次上下文切换来调度它。这会产生 $\\delta$ 的开销。上下文切换之后，$M_1$ 运行其规定的时间量 $q$。系统处理 $M_1$ 所消耗的总时间是上下文切换时间和执行时间之和：$t_1 = \\delta + q$。完成其时间量后，$M_1$ 阻塞并从就绪队列中移除。\n\n2.  **任务 $M_2$ 的执行**：在 $M_1$ 阻塞后，调度器再次被调用。此时最高优先级的就绪任务是 $\\{M_2, \\ldots, M_m\\}$。调度器选择 $M_2$。同样，需要一次持续时间为 $\\delta$ 的上下文切换，然后执行一个时间量 $q$。此步骤所耗费的时间为 $t_2 = \\delta + q$。\n\n这个过程对所有 $m$ 个中等优先级任务重复。集合中的每个任务 $M_i$ 都需要一次 $\\delta$ 的上下文切换，并运行一个时间量 $q$ 后阻塞。因此，每个任务 $M_i$ 的时间贡献为 $(\\delta + q)$。\n\n总的优先级反转延迟 $D_{\\text{inv}}$ 定义为直到最后一个中等优先级任务 $M_m$ 完成其时间量并阻塞为止的时间。这是所有 $m$ 个中等优先级任务的时间贡献之和。\n\n$$D_{\\text{inv}} = \\sum_{i=1}^{m} (\\text{context switch for } M_i + \\text{run time of } M_i)$$\n$$D_{\\text{inv}} = \\sum_{i=1}^{m} (\\delta + q)$$\n\n由于 $\\delta$ 和 $q$ 对于所有 $m$ 个任务都是常数，因此求和可以简化为：\n$$D_{\\text{inv}} = m(q + \\delta)$$\n这就是优先级反转延迟作为 $m$、$q$ 和 $\\delta$ 的函数的解析表达式。\n\n### 步骤 3：数值计算\n\n问题为参数提供了以下具体值：\n- $q = 3.7$ 毫秒\n- $\\delta = 0.23$ 毫秒\n- $m = 19$\n\n将这些值代入推导出的表达式：\n$$D_{\\text{inv}} = 19 \\times (3.7 + 0.23)$$\n首先，计算括号内的和：\n$$q + \\delta = 3.7 + 0.23 = 3.93 \\text{ ms}$$\n现在，乘以中等优先级任务的数量 $m$：\n$$D_{\\text{inv}} = 19 \\times 3.93$$\n$$D_{\\text{inv}} = 74.67 \\text{ ms}$$\n\n问题要求将数值答案四舍五入到四位有效数字。计算出的值 $74.67$ 已经恰好包含四位有效数字（$7$、$4$、$6$ 和 $7$）。因此，无需进一步四舍五入。优先级反转延迟的最终数值结果是 $74.67$ 毫秒。", "answer": "$$\\boxed{74.67}$$", "id": "3671212"}, {"introduction": "我们的第一个练习探讨了由任务抢占引起的反转，而本练习 [@problem_id:3671216] 则聚焦于另一个常见原因：内核或用户代码中的非抢占区域。您需要确定一个高优先级任务可能遭遇的最大阻塞时间。这项实践旨在揭示一个至关重要的设计原则：通过严格控制非抢占代码段的执行长度，我们可以为优先级反转设置一个确定的上限，这是保证实时系统可预测性的关键技术。", "problem": "在操作系统的固定优先级、抢占式调度器中，为了确保某些内核级或用户级临界操作的原子性，抢占在显式的非抢占区域内被禁用。考虑三个周期性任务，其优先级严格排序为 $p_H > p_M > p_L$，其中 $H$ 表示高优先级任务，$M$ 表示中优先级任务，$L$ 表示低优先级任务。任务 $H$ 的一个作业在时间 $t=0$ 到达。调度器遵循以下基本规则：一个就绪的高优先级作业会立即抢占一个低优先级作业，除非低优先级作业正处于非抢占区域内；上下文切换在非抢占区域之外瞬时发生；并且非抢占区域有一个系统强制执行的上限 $\\tau$。\n\n假设操作系统强制规定最大非抢占区域长度为 $\\tau = 3.100\\ \\mathrm{ms}$。在所考虑的工作负载中，低优先级任务 $L$ 偶尔会进入一个长度为 $2.847\\ \\mathrm{ms}$ 的非抢占区域，而中优先级任务 $M$ 偶尔会进入一个长度为 $1.802\\ \\mathrm{ms}$ 的非抢占区域。假设任务 $H$ 的一个作业在 $t=0$ 时在阻塞的最坏情况下到达，并且任务 $L$ 恰好在 $t=0$ 时进入其非抢占区域。在 $L$ 离开其非抢占区域后，$M$ 可能已准备好运行。系统中没有其他任务。\n\n从抢占和非抢占区域的核心定义出发，并且除了所述的调度器行为外不假设任何专门的协议，推导出任务 $H$ 的作业仅因低优先级任务的非抢占区域而可能遭受的最大优先级反转延迟 $B$，并根据给定的参数 $p_H$、$p_M$、$p_L$ 和 $\\tau$ 计算其数值。以毫秒为单位表示您的最终答案，并四舍五入到四位有效数字。", "solution": "问题要求在一个固定优先级、抢占式调度系统中，高优先级任务 $H$ 因低优先级任务的非抢占区域而可能经历的最大优先级反转延迟 $B$。\n\n首先，我们必须确立支配该场景的基本原则。\n1.  **固定优先级抢占式调度**：在一组就绪任务中，调度器总是执行优先级最高的任务。如果一个比当前运行任务优先级更高的任务变为就绪状态，该高优先级任务将立即抢占正在运行的任务。\n2.  **非抢占区域**：这是抢占规则的一个例外。如果一个任务正在非抢占区域内执行，那么在它退出该区域之前，它不能被任何其他任务抢占，无论其优先级如何。\n3.  **优先级反转**：当一个高优先级任务准备好运行但被迫等待一个低优先级任务完成某项活动时，就会发生这种现象。在本问题中，优先级反转的原因明确限定为非抢占区域。这种等待的持续时间就是优先级反转延迟，也称为阻塞时间。\n\n设三个任务为 $H$、$M$ 和 $L$，其优先级为 $p_H > p_M > p_L$。任务 $H$ 的一个作业在时间 $t=0$ 到达并变为就绪状态。\n\n任务 $H$ 要被阻塞，它必须在一个低优先级任务（$M$ 或 $L$）已经在非抢占区域内运行时变为就绪状态。如果一个低优先级任务正在运行但不在非抢占区域内，$H$ 会立即抢占它，不会发生阻塞。\n\n任务 $H$ 的最大阻塞时间将发生在特定的最坏情况事件序列下：\n1.  一个低优先级任务（例如任务 $i$，其中 $p_i  p_H$）进入其持续时间为 $C_{i,np}$ 的非抢占区域。\n2.  在任务 $i$ 进入其区域后一个无穷小的时间 $\\epsilon  0$，高优先级任务 $H$ 变为就绪状态。\n3.  由于任务 $i$ 处于非抢占区域，调度器不能为了运行 $H$ 而抢占它。任务 $H$ 现在被阻塞。\n4.  任务 $H$ 必须等待任务 $i$ 完成其整个非抢占区域。这个等待的持续时间是 $C_{i,np}$。\n5.  一旦任务 $i$ 退出其非抢占区域，调度器就会被调用。就绪任务集合包括 $H$、$i$ 以及可能在阻塞期间变为就绪的其他任务。在我们的问题中，提示指出任务 $M$ 此时可能已准备就绪。\n6.  调度器必须从就绪队列中选择优先级最高的任务。由于 $p_H$ 是最高优先级（$p_H > p_M > p_L$），任务 $H$ 保证会被选中执行。\n\n此分析揭示了一个关键点：一个高优先级任务最多只能被单个低优先级任务的一个非抢占区域阻塞。一旦阻塞区域结束，$H$ 将会运行，从而阻止任何其他低优先级任务（如 $M$）被调度并随后进入其自身的非抢占区域以导致进一步的阻塞。陈述“在 $L$ 离开其非抢占区域后，$M$ 可能已准备好运行”是为了测试对这一点的理解；即使 $M$ 已经就绪，它也无法运行，因为 $H$ 具有更高的优先级并且也已就绪。\n\n因此，任务 $H$ 可能遭受的最大优先级反转延迟 $B$ 是所有优先级低于 $p_H$ 的任务中最长的非抢占区域的持续时间。\n\n优先级低于 $p_H$ 的任务是 $M$ 和 $L$。问题给出了它们各自非抢占区域的长度：\n- 任务 $L$ 的非抢占区域长度，$C_{L,np} = 2.847\\ \\mathrm{ms}$。\n- 任务 $M$ 的非抢占区域长度，$C_{M,np} = 1.802\\ \\mathrm{ms}$。\n\n最大延迟 $B$ 是这些值的最大值：\n$$\nB = \\max(C_{L,np}, C_{M,np})\n$$\n代入给定值：\n$$\nB = \\max(2.847\\ \\mathrm{ms}, 1.802\\ \\mathrm{ms})\n$$\n$$\nB = 2.847\\ \\mathrm{ms}\n$$\n问题还提供了一个系统范围内的最大非抢占区域长度 $\\tau = 3.100\\ \\mathrm{ms}$。该值作为系统中任何非抢占区域的上限。给定的任务 $L$ 和 $M$ 的区域长度（$2.847\\ \\mathrm{ms}$ 和 $1.802\\ \\mathrm{ms}$）都小于 $\\tau$，这证实了问题陈述的一致性。然而，该特定工作负载的最大阻塞是由所涉及任务的实际特性决定的，而不是由理论上的系统范围限制决定的。\n\n提示指定了一个场景，“L 恰好在 t=0 时进入其非抢占区域”。由于任务 $L$ 的非抢占区域是两者中较长的，这个特定场景确实对应于任务 $H$ 的最坏情况阻塞。\n\n最大优先级反转延迟的最终值为 $2.847\\ \\mathrm{ms}$。问题要求将答案四舍五入到四位有效数字。数字 $2.847$ 已经有四位有效数字，因此无需四舍五入。", "answer": "$$\\boxed{2.847}$$", "id": "3671216"}, {"introduction": "优先级反转并非一个纯粹的调度理论问题，它在硬件层面有具体的表现。这项进阶练习 [@problem_id:3671221] 建立了一个模型，来分析中等优先级任务如何加剧反转：它不仅消耗了CPU时间，还通过污染共享缓存来驱逐低优先级任务的数据。通过计算由缓存未命中引起的额外延迟，您将认识到硬件层面的资源争用会如何显著放大一个软件调度问题，从而更深刻地理解现代计算机系统中复杂的性能交互。", "problem": "考虑一个单核系统，该系统采用固定优先级抢占式调度，包含三个线程：一个高优先级线程 $T_{H}$、一个中优先级线程 $T_{M}$ 和一个低优先级线程 $T_{L}$。低优先级线程 $T_{L}$ 持有一个互斥锁（mutex），而高优先级线程 $T_{H}$ 需要该锁才能进入其临界区。系统中没有优先级继承机制。当 $T_{L}$ 持有锁时，只要 $T_{M}$ 处于可运行状态，调度器就允许 $T_{M}$ 抢占 $T_{L}$，每次抢占的固定时间片长度为 $\\Delta$。中央处理器（CPU）的频率为每秒 $f$ 个周期。\n\n假设采用以下工作集和缓存交互模型。每次 $T_{M}$ 运行时，它会访问 $e$ 个缓存行，这些缓存行与当前 $T_{L}$ 临界区相关的缓存行映射到相同的缓存组，从而将它们从共享缓存中驱逐出去。当 $T_{L}$ 在每次被抢占后恢复执行时，它将为重新加载这 $e$ 个缓存行中的每一个产生恰好一次额外的缓存未命中，每次未命中的惩罚为 $p$ 个周期。在 $T_{L}$ 最终释放锁之前，这种模式会重复 $k$ 次抢占。\n\n参数：\n- CPU 频率 $f = 2.5 \\times 10^{9}$ 周期/秒。\n- 未命中惩罚 $p = 200$ 周期/次未命中。\n- 每次抢占驱逐的缓存行数 $e = 128$。\n- 抢占次数 $k = 75$。\n- 每次抢占的中优先级时间片 $\\Delta = 1$ 毫秒。\n\n从基本定义出发进行推导：由周期数产生的耗时等于周期数除以每秒周期数；优先级反转是指高优先级线程因低优先级线程持有锁以及中优先级活动的干扰而产生的额外等待时间。请基于这些第一性原理推导：\n\n1. $T_{L}$ 因 $T_{M}$ 的驱逐操作而产生的额外缓存未命中，所导致的附加延迟 $M$（以毫秒为单位表示 $M$）。\n2. 最终的优先级反转 $D$，定义为在没有 $T_{M}$ 的基线情况下，$T_{H}$ 额外增加的等待时间。该时间是 $T_{L}$ 持有锁期间 $T_{M}$ 的调度运行时间与缓存未命中引起的延迟 $M$ 之和（以毫秒为单位表示 $D$）。\n\n提供精确值，无需四舍五入。最终答案以毫秒表示。", "solution": "我们从两个核心事实出发：\n- 以周期为单位的时间成本通过除以 CPU 频率转换为秒，因此，如果一个计算产生 $C$ 个周期的成本，其对应的时间（秒）为 $C/f$。\n- 在此无优先级继承的设定中，优先级反转是高优先级线程 $T_{H}$ 所承受的额外等待，其原因是低优先级线程 $T_{L}$ 持有锁，而中优先级线程 $T_{M}$ 抢占 $T_{L}$ 并通过缓存颠簸（cache thrashing）降低了 $T_{L}$ 的执行进度。\n\n定义仅由缓存颠簸引起的附加延迟 $M$。$T_{M}$ 的每次抢占会驱逐 $e$ 个与 $T_{L}$ 相关的缓存行。在所述模型下，当 $T_{L}$ 在一次抢占后恢复执行时，它将精确地重新加载这 $e$ 个缓存行，每行产生一次额外的未命中。设每次未命中的惩罚为 $p$ 个周期。在 $k$ 次抢占中，额外未命中的总次数为 $k \\cdot e$，产生的额外总周期数为\n$$\nC_{\\text{miss}} = k \\cdot e \\cdot p.\n$$\n使用 CPU 频率 $f$ 将周期转换为秒，得到\n$$\nt_{\\text{miss}} = \\frac{C_{\\text{miss}}}{f} = \\frac{k \\cdot e \\cdot p}{f}.\n$$\n为表示为毫秒，乘以 $10^{3}$：\n$$\nM = 10^{3} \\cdot \\frac{k \\cdot e \\cdot p}{f} \\quad \\text{毫秒}.\n$$\n代入给定值 $k = 75$，$e = 128$，$p = 200$ 和 $f = 2.5 \\times 10^{9}$：\n首先计算周期数：\n$$\nC_{\\text{miss}} = 75 \\cdot 128 \\cdot 200 = 75 \\cdot 25{,}600 = 1{,}920{,}000 \\ \\text{周期}.\n$$\n转换为秒：\n$$\nt_{\\text{miss}} = \\frac{1{,}920{,}000}{2.5 \\times 10^{9}} = 0.000768 \\ \\text{秒}.\n$$\n转换为毫秒：\n$$\nM = 10^{3} \\cdot 0.000768 = 0.768 \\ \\text{毫秒}.\n$$\n\n接下来，定义最终的优先级反转 $D$。在没有 $T_{M}$ 的情况下，$T_{H}$ 在 $T_{L}$ 持有锁期间的基线等待时间将不包括 $T_{M}$ 的 CPU 时间和缓存颠簸开销。当 $T_{M}$ 存在时，归因于 $T_{M}$ 的额外等待时间是以下两项之和：\n- 在 $k$ 次抢占中，$T_{M}$ 的调度运行时间，即 $k \\cdot \\Delta$。\n- $T_{L}$ 因缓存未命中而经历的附加延迟 $M$，这直接延长了锁的持有时间，从而也延长了 $T_{H}$ 的等待时间。\n\n因此，\n$$\nD = k \\cdot \\Delta + M.\n$$\n使用 $k = 75$ 和 $\\Delta = 1 \\ \\text{毫秒}$，得到\n$$\nk \\cdot \\Delta = 75 \\cdot 1 = 75 \\ \\text{毫秒}.\n$$\n因此，\n$$\nD = 75 + 0.768 = 75.768 \\ \\text{毫秒}.\n$$\n\n我们已经从第一性原理推导出了 $M$ 和 $D$：每次抢占的额外未命中会产生一个附加的周期成本，该成本通过 $f$ 进行转换；总的优先级反转是调度器引起的延迟和缓存引起的延迟之和。两个值都按要求以毫秒表示。", "answer": "$$\\boxed{\\begin{pmatrix}0.768  75.768\\end{pmatrix}}$$", "id": "3671221"}]}