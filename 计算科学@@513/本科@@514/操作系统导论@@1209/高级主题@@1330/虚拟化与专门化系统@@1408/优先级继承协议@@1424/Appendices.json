{"hands_on_practices": [{"introduction": "我们将从一个阐明优先继承协议核心动机的基础场景开始。在许多操作系统中，当一个高优先级任务等待一个被低优先级任务持有的资源时，可能会出现一个不相关的中等优先级任务抢占了该低优先级任务的情况，这便是“优先级反转”。本练习将引导你定量地比较有无该协议的系统性能，让你清晰地看到优先继承协议是如何解决经典的优先级反转问题的。[@problem_id:3670912]", "problem": "考虑一个单处理器系统，其调度策略为 Linux 的先进先出（FIFO）实时策略，表示为 `SCHED_FIFO`。在 `SCHED_FIFO` 策略下，任务具有固定优先级；调度器总是分派就绪的最高优先级任务，一个正在运行的任务只能被优先级严格更高的任务抢占。假设三个任务共享一个受锁保护的互斥资源，该锁强制执行原子临界区。最高优先级任务 $H$ 在其作业开始时需要该锁；中等优先级任务 $M$ 不使用该锁；低优先级任务 $L$ 在其作业的一部分中使用该锁。优先级继承协议（Priority Inheritance Protocol, PIP）会将资源持有者的优先级提升至被该资源阻塞的最高优先级任务的优先级；若没有 PIP，当一个高优先级任务被锁阻塞时，一个低优先级的锁持有者可能会被不相关的中等优先级任务抢占，从而导致优先级反转。\n\n假设以下参数和最坏情况下的到达对齐。低优先级任务 $L$ 的最坏情况执行时间为 $C_{L}=10\\ \\mathrm{ms}$，其中一个持续时间为 $b=5\\ \\mathrm{ms}$ 的连续临界区需要该锁。最高优先级任务 $H$ 的最坏情况执行时间为 $C_{H}=2\\ \\mathrm{ms}$，并在释放后立即需要该锁。一个最坏情况执行时间为 $C_{M}=C_{L}-b$ 的中等优先级任务 $M$ 的单个作业与 $H$ 同时释放。在时间 $t=0$ 时，任务 $H$ 被释放并尝试锁定资源；同时，$M$ 被释放；任务 $L$ 已经在执行并刚刚进入其临界区，因此除非被抢占，它将在接下来的 $b$ 个单位时间内持有该锁。该资源锁在临界区原子性方面是不可抢占的，但当持有锁时，并不能阻止处理器被更高优先级的任务抢占；因此，在持有锁期间的抢占会延迟解锁时间。\n\n仅使用响应时间（完成时间减去释放时间）的定义、`SCHED_FIFO` 下固定优先级抢占式调度的语义以及优先级继承协议下优先级继承捐赠的机制，推导任务 $H$ 在两种情况下的最坏情况响应时间 $R_{H}$：(i) 没有优先级捐赠和 (ii) 有优先级捐赠。然后计算两种情况下 $R_{H}$ 的数值（以毫秒为单位）以及定义为 $\\Delta = R_{H}^{\\mathrm{without}} - R_{H}^{\\mathrm{with}}$ 的改进量。以 $\\mathrm{ms}$ 表示最终数值答案，并将您的答案四舍五入到四位有效数字。", "solution": "问题按如下方式进行验证。\n\n首先，逐字提取所有给定条件。\n系统：单处理器。\n调度策略：`SCHED_FIFO`（固定优先级，抢占式）。\n任务：$H$（高优先级）、$M$（中优先级）、$L$（低优先级）。优先级关系为 $P_H > P_M > P_L$。\n资源：受锁保护的单个互斥资源。\n协议：在第二种场景中考虑优先级继承协议（Priority Inheritance Protocol, PIP）。\n任务参数：\n- 低优先级任务 $L$：最坏情况执行时间 $C_{L}=10\\ \\mathrm{ms}$；临界区持续时间 $b=5\\ \\mathrm{ms}$。\n- 高优先级任务 $H$：最坏情况执行时间 $C_{H}=2\\ \\mathrm{ms}$；释放后立即需要锁。\n- 中优先级任务 $M$：最坏情况执行时间 $C_{M}=C_{L}-b$。\n初始条件（最坏情况到达对齐）：\n- 在时间 $t=0$ 时，任务 $H$ 被释放并尝试锁定资源。\n- 在时间 $t=0$ 时，任务 $M$ 被释放。\n- 在时间 $t=0$ 时，任务 $L$ 已经在执行并刚刚进入其临界区，在接下来的 $b$ 个单位时间内持有该锁。\n定义：\n- 响应时间 $R$ = 完成时间 - 释放时间。\n目标：\n- 推导任务 $H$ 在两种情况下的最坏情况响应时间 $R_{H}$：(i) 没有优先级捐赠和 (ii) 有优先级捐赠。\n- 计算 $R_{H}^{\\mathrm{without}}$ 和 $R_{H}^{\\mathrm{with}}$ 的数值（以毫秒为单位）。\n- 计算改进量 $\\Delta = R_{H}^{\\mathrm{without}} - R_{H}^{\\mathrm{with}}$。\n- 将最终数值答案四舍五入到四位有效数字。\n\n其次，根据指定标准对问题进行验证。\n- **科学依据：** 该问题是实时操作系统研究中的一个经典标准场景，专门用于演示优先级反转问题以及优先级继承协议提供的解决方案。所有概念都是计算机科学的基础。\n- **适定性：** 该问题已完整规定了所有必要的参数、初始条件，并清晰定义了调度和资源锁定机制。参数 $C_M$ 被明确定义为 $C_{L}-b = 10 \\ \\mathrm{ms} - 5 \\ \\mathrm{ms} = 5 \\ \\mathrm{ms}$。通过模拟系统随时间的行为，可以推导出唯一的稳定解。\n- **客观性：** 问题以精确的技术语言陈述，没有歧义或主观论断。\n\n该问题被认为是科学合理、适定、客观的，并且没有违反任何指定的无效标准。因此，它被判定为 **有效**。现在推导解决方案。\n\n该问题要求在两种不同的资源管理策略下，计算高优先级任务 $H$ 的最坏情况响应时间，记为 $R_H$。任务的响应时间定义为其自身执行时间、因等待资源而被阻塞的任何时间以及被更高优先级任务抢占的任何时间的总和。对于任务 $H$，没有更高优先级的任务，因此其响应时间为 $R_H = C_H + B_H$，其中 $C_H$ 是其执行时间，$B_H$ 是其总阻塞时间。\n\n首先，我们计算任务 $M$ 的执行时间：\n$C_M = C_L - b = 10\\ \\mathrm{ms} - 5\\ \\mathrm{ms} = 5\\ \\mathrm{ms}$。\n\n**场景 (i)：无优先级继承**\n\n在这种场景下，任务优先级是静态的。\n- 在 $t=0$ 时：任务 $L$ 正在其临界区中执行，持有锁。任务 $H$ 和任务 $M$ 被释放。由于 $P_H > P_L$，任务 $H$ 抢占任务 $L$。\n- 抢占后，任务 $H$ 立即尝试获取锁。锁被 $L$ 持有，因此任务 $H$ 进入阻塞状态。\n- 调度器现在必须分派就绪的最高优先级任务。任务 $H$ 处于阻塞状态。就绪队列中包含 $M$ 和 $L$。由于 $P_M > P_L$，任务 $M$ 被分派并开始执行。这就是优先级反转的时刻：中等优先级的任务 $M$ 运行时，高优先级的任务 $H$ 却被低优先级的任务 $L$ 阻塞。\n- 从 $t=0$ 到 $t=C_M = 5\\ \\mathrm{ms}$：任务 $M$ 执行至完成。在此期间，$H$ 保持阻塞状态，$L$ 保持被抢占状态。\n- 在 $t=5\\ \\mathrm{ms}$ 时：任务 $M$ 完成。调度器再次分派就绪的最高优先级任务。$H$ 仍处于阻塞状态。就绪队列中唯一的任务是 $L$。任务 $L$ 恢复执行。\n- 从 $t=5\\ \\mathrm{ms}$ 到 $t=5\\ \\mathrm{ms} + b = 10\\ \\mathrm{ms}$：任务 $L$ 执行其临界区，持续时间为 $b=5\\ \\mathrm{ms}$。\n- 在 $t=10\\ \\mathrm{ms}$ 时：任务 $L$ 完成其临界区并释放锁。锁的释放使任务 $H$ 解除阻塞，进入就绪状态。由于 $P_H$ 是最高优先级，$H$ 立即抢占 $L$ 并开始执行。\n- 从 $t=10\\ \\mathrm{ms}$ 到 $t=10\\ \\mathrm{ms} + C_H = 12\\ \\mathrm{ms}$：任务 $H$ 执行至完成。\n- 在 $t=12\\ \\mathrm{ms}$ 时：任务 $H$ 完成其作业。\n\nH 的响应时间是完成时间减去释放时间：\n$R_{H}^{\\mathrm{without}} = 12\\ \\mathrm{ms} - 0\\ \\mathrm{ms} = 12\\ \\mathrm{ms}$。\n\n从分析上看，任务 $H$ 的阻塞时间 $B_H$ 是 $L$ 持有锁的时间（直接阻塞）和 $H$ 等待 $L$ 期间 $M$ 执行的时间（推进阻塞）之和。\n$B_H = b + C_M = 5\\ \\mathrm{ms} + 5\\ \\mathrm{ms} = 10\\ \\mathrm{ms}$。\n$R_{H}^{\\mathrm{without}} = C_H + B_H = 2\\ \\mathrm{ms} + 10\\ \\mathrm{ms} = 12\\ \\mathrm{ms}$。\n\n**场景 (ii)：使用优先级继承协议 (PIP)**\n\n在这种场景下，持有锁的任务其优先级可以被临时提升。\n- 在 $t=0$ 时：任务 $L$ 正在其临界区中执行，持有锁。任务 $H$ 和 $M$ 被释放。$H$ 抢占 $L$ 并立即尝试获取锁，导致其阻塞。\n- **优先级继承机制**：由于高优先级任务 $H$ 现在被低优先级任务 $L$ 阻塞，任务 $L$ 的优先级被 $H$ “捐赠”。$L$ 的有效优先级被提升到 $P_H$。\n- 调度器必须分派就绪的最高优先级任务。任务集包括阻塞的 $H$、优先级为 $P_M$ 的就绪任务 $M$ 和有效优先级为 $P_H$ 的就绪任务 $L$。由于 $P_H > P_M$，任务 $L$ 在就绪任务中具有最高优先级，并被分派运行。\n- 从 $t=0$ 到 $t=b = 5\\ \\mathrm{ms}$：任务 $L$ 以继承的优先级 $P_H$ 执行并完成其临界区。任务 $M$ 保持在就绪状态，无法运行。\n- 在 $t=5\\ \\mathrm{ms}$ 时：任务 $L$ 释放锁。释放锁后，其优先级立即恢复到其基本优先级 $P_L$。锁的释放使任务 $H$ 解除阻塞，进入就绪状态。\n- 调度器分派就绪的最高优先级任务。现在的就绪任务是 $H$（优先级 $P_H$）、$M$（优先级 $P_M$）和 $L$（优先级 $P_L$）。任务 $H$ 被分派。\n- 从 $t=5\\ \\mathrm{ms}$ 到 $t=5\\ \\mathrm{ms} + C_H = 7\\ \\mathrm{ms}$：任务 $H$ 执行至完成。\n- 在 $t=7\\ \\mathrm{ms}$ 时：任务 $H$ 完成其作业。\n\nH 的响应时间是完成时间减去释放时间：\n$R_{H}^{\\mathrm{with}} = 7\\ \\mathrm{ms} - 0\\ \\mathrm{ms} = 7\\ \\mathrm{ms}$。\n\n从分析上看，使用 PIP 时，中等优先级任务 $M$ 无法抢占持有锁的任务 $L$，因为 $L$ 的优先级被提升了。推进阻塞被消除。$H$ 经历的唯一阻塞是 $L$ 完成其临界区造成的直接阻塞。\n$B_H = b = 5\\ \\mathrm{ms}$。\n$R_{H}^{\\mathrm{with}} = C_H + B_H = 2\\ \\mathrm{ms} + 5\\ \\mathrm{ms} = 7\\ \\mathrm{ms}$。\n\n**改进量计算**\n\n改进量是响应时间的差值：\n$\\Delta = R_{H}^{\\mathrm{without}} - R_{H}^{\\mathrm{with}} = 12\\ \\mathrm{ms} - 7\\ \\mathrm{ms} = 5\\ \\mathrm{ms}$。\n这个改进量恰好对应于中等优先级任务的执行时间 $C_M$，PIP 机制阻止了该任务的运行。\n\n所要求的数值答案是 $R_{H}^{\\mathrm{without}}$、$R_{H}^{\\mathrm{with}}$ 和 $\\Delta$。四舍五入到四位有效数字，它们分别为 $12.00\\ \\mathrm{ms}$、$7.000\\ \\mathrm{ms}$ 和 $5.000\\ \\mathrm{ms}$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n12.00  7.000  5.000\n\\end{pmatrix}\n}\n$$", "id": "3670912"}, {"introduction": "现实世界的系统通常具有复杂的依赖网络，而不仅仅是简单的“一对一”阻塞。为了分析这些情况，我们需要一个更强大的工具。本练习引入了“等待图”（wait-for graph），它是一种将这些复杂的线程与锁的依赖关系可视化的方法，并帮助你追踪优先级“馈赠”是如何在长阻塞链中进行传递的。[@problem_id:3670926]", "problem": "考虑一个操作系统（OS），该系统采用抢占式固定优先级调度，并使用二进制信号量实现互斥锁。一个试图获取已被持有锁的线程会被阻塞，从而产生对该锁的等待依赖关系，并延伸至对锁持有者的等待依赖关系。优先级继承协议（PIP）规定，当一个高优先级线程在一个锁上被阻塞时，该锁的持有者会临时继承被阻塞线程的优先级，并且如果该持有者本身在另一个锁上被阻塞，则此优先级传递是可传递的，直到链条终止于一个未被阻塞的线程。等待图表示为一个有向图 $G=(V,E)$，其中 $V$ 包含线程和锁，而 $E$ 包含两种形式的边：当线程 $T$ 等待获取锁 $L$ 时，为 $T \\to L$；当锁 $L$ 由线程 $T$ 持有时，为 $L \\to T$。\n\n现有线程 $T_0,T_1,T_2,T_3,T_4,T_5,T_6,T_7$，其基础优先级分别为 $p(T_0)=90, p(T_1)=40, p(T_2)=35, p(T_3)=20, p(T_4)=15, p(T_5)=10, p(T_6)=50, p(T_7)=25$。还有锁 $L_1,L_2,L_3,L_4,L_5,L_A,L_B$。假设存在以下瞬时状态，该状态与互斥和抢占式调度一致：\n- $T_0$ 被阻塞，等待获取 $L_1$，$L_1$ 由 $T_1$ 持有。\n- $T_1$ 被阻塞，等待获取 $L_2$，$L_2$ 由 $T_2$ 持有。\n- $T_2$ 被阻塞，等待获取 $L_3$，$L_3$ 由 $T_3$ 持有。\n- $T_3$ 被阻塞，等待获取 $L_4$，$L_4$ 由 $T_4$ 持有。\n- $T_4$ 被阻塞，等待获取 $L_5$，$L_5$ 由 $T_5$ 持有。\n- $T_6$ 被阻塞，等待获取 $L_A$，$L_A$ 由 $T_2$ 持有。\n- $T_7$ 被阻塞，等待获取 $L_B$，$L_B$ 由 $T_4$ 持有。\n- $T_5$ 没有等待任何锁，并继续执行直到它释放 $L_5$。\n\n任务：\n- 使用上述定义，通过列出关系中隐含的所有顶点和边，为该状态构建有向等待图 $G=(V,E)$。将每个锁和线程视为 $V$ 中的独立顶点。\n- 仅使用抢占式固定优先级调度、互斥和优先级继承协议（PIP）的既定定义，论证为什么优先级馈赠必须沿着 $G$ 中的任何简单有向等待路径传播，直到到达一个没有在等待的线程。\n- 令 $\\ell$ 为 $G$ 中最长简单有向等待路径的长度（边的数量）。计算 $\\ell$。将最终答案表示为整数；无需四舍五入。", "solution": "问题陈述已经过验证，被认为是自洽、一致且科学合理的。它在操作系统调度的背景下，特别是在优先级继承协议（PIP）方面，提出了一个定义明确的场景。所有数据和定义都清晰充分，足以进行形式化的解答。\n\n问题要求完成三项任务：构建等待图，论证优先级馈赠的可传递性，以及计算最长简单有向等待路径的长度。我们将依次解决每个任务。\n\n**任务1：构建等待图 $G=(V,E)$**\n\n图 $G=(V,E)$ 由一个顶点集 $V$ 和一个有向边集 $E$ 组成。顶点代表线程和锁。边代表“等待”（$T \\to L$）和“持有”（$L \\to T$）关系。\n\n根据问题描述，顶点集 $V$ 为：\n$$V = \\{T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, L_1, L_2, L_3, L_4, L_5, L_A, L_B\\}$$\n\n有向边集 $E$ 根据给定状态构建：\n1.  $T_0$ 等待 $L_1$：$T_0 \\to L_1$\n2.  $L_1$ 由 $T_1$ 持有：$L_1 \\to T_1$\n3.  $T_1$ 等待 $L_2$：$T_1 \\to L_2$\n4.  $L_2$ 由 $T_2$ 持有：$L_2 \\to T_2$\n5.  $T_2$ 等待 $L_3$：$T_2 \\to L_3$\n6.  $L_3$ 由 $T_3$ 持有：$L_3 \\to T_3$\n7.  $T_3$ 等待 $L_4$：$T_3 \\to L_4$\n8.  $L_4$ 由 $T_4$ 持有：$L_4 \\to T_4$\n9.  $T_4$ 等待 $L_5$：$T_4 \\to L_5$\n10. $L_5$ 由 $T_5$ 持有：$L_5 \\to T_5$\n11. $T_6$ 等待 $L_A$：$T_6 \\to L_A$\n12. $L_A$ 由 $T_2$ 持有：$L_A \\to T_2$\n13. $T_7$ 等待 $L_B$：$T_7 \\to L_B$\n14. $L_B$ 由 $T_4$ 持有：$L_B \\to T_4$\n\n因此，边集 $E$ 为：\n$$E = \\{ (T_0,L_1), (L_1,T_1), (T_1,L_2), (L_2,T_2), (T_2,L_3), (L_3,T_3), (T_3,L_4), (L_4,T_4), (T_4,L_5), (L_5,T_5), (T_6,L_A), (L_A,T_2), (T_7,L_B), (L_B,T_4) \\}$$\n\n**任务2：关于优先级馈赠可传递性的论证**\n\n关于优先级馈赠沿简单有向等待路径传播的论证，直接源于为抢占式调度和优先级继承协议（PIP）提供的定义。\n\n$G$ 中的一个简单有向等待路径形如 $T_a \\to L_1 \\to T_b \\to L_2 \\to T_c \\to \\dots \\to T_z$，其中 $T_z$ 是一个没有在等待的线程。每个形如 $T_i \\to L \\to T_j$ 的子路径都意味着线程 $T_i$ 被阻塞，正在等待获取由线程 $T_j$ 当前持有的锁 $L$。\n\n让我们考虑这样一条路径的一段：$T_i \\to L_k \\to T_j$。根据问题陈述，这意味着 $T_i$ 在由 $T_j$ 持有的锁 $L_k$ 上被阻塞。如果等待线程的基础优先级 $p(T_i)$ 大于持锁线程的基础优先级 $p(T_j)$，这种情况就是一个优先级反转的实例。在抢占式系统中，$T_j$ 可能会被另一个满足 $p(T_j)  p(T_m)  p(T_i)$ 的线程 $T_m$ 抢占，从而延迟 $L_k$ 的释放，并延长高优先级线程 $T_i$ 的阻塞时间。\n\nPIP旨在解决这个问题。定义指出：“当一个高优先级线程在一个锁上被阻塞时，该锁的持有者会临时继承被阻塞线程的优先级”。令 $p_{eff}(T)$ 表示线程 $T$ 的有效优先级。初始时，$p_{eff}(T) = p(T)$。如果 $p(T_i) > p(T_j)$，PIP 规定 $T_j$ 继承 $T_i$ 的优先级。$T_j$ 的有效优先级变为：\n$$p_{eff}(T_j) = \\max(p_{eff}(T_j), p_{eff}(T_i))$$\n如果有多个线程在等待 $T_j$ 持有的锁，$T_j$ 将继承它们优先级中的最大值。\n\n现在，考虑可传递性条款：“……并且如果该持有者本身在另一个锁上被阻塞，则此优先级传递是可传递的，直到链条终止于一个未被阻塞的线程。”\n假设我们的路径继续为：$T_i \\to L_k \\to T_j \\to L_m \\to T_n$。这里，$T_j$，即初始的锁持有者，自身也被阻塞，等待由 $T_n$ 持有的锁 $L_m$。\n1.  $T_j$ 从 $T_i$ 继承了优先级，所以它的有效优先级现在是 $p_{eff}(T_j) = \\max(p(T_j), p_{eff}(T_i))$。\n2.  从调度器和资源 $L_m$ 的角度来看，线程 $T_j$ 是一个有效优先级为 $p_{eff}(T_j)$ 的等待线程。\n3.  $T_j$ 被 $T_n$ 阻塞。如果 $p_{eff}(T_j) > p(T_n)$，这是另一个优先级反转的实例。\n4.  再次应用PIP，锁持有者 $T_n$ 必须继承它所阻塞的线程的优先级。因此，$T_n$ 继承 $p_{eff}(T_j)$。$T_n$ 新的有效优先级是：\n$$p_{eff}(T_n) = \\max(p_{eff}(T_n), p_{eff}(T_j)) = \\max(p_{eff}(T_n), \\max(p(T_j), p_{eff}(T_i)))$$\n这证明了 $T_i$ 的优先级被传播到了 $T_n$。这个逻辑可以递归地应用于任何简单有向等待路径的整个长度。依赖链中最高优先级“头部”线程的优先级会从一个锁持有者传递到下一个，直到到达链中的最终线程，该线程没有被阻塞，因此可以执行。这确保了最终线程以足够高的优先级运行，以防止被中等优先级的线程抢占，从而使其能够完成其临界区并释放锁，进而解除整个链的阻塞。\n\n**任务3：计算最长简单有向等待路径的长度 $\\ell$**\n\n简单有向路径是指不重复顶点的路径。路径的长度是它包含的边的数量。我们必须在任务1中构建的图 $G$ 中找到最长的此类路径。由于没有描述死锁循环，该图是一个有向无环图（DAG）。\n\n该图包含三个不同的依赖链，它们最终会合并。这些链源于那些正在等待但自身不持有任何锁的线程。在图 $G$ 中，这些是入度为0的线程顶点。它们是 $T_0$、$T_6$ 和 $T_7$。所有依赖链都终止于 $T_5$，它是唯一一个持有锁但没有等待其他锁的线程。\n\n我们追踪从每个起点到单一终点 $T_5$ 的路径：\n\n1.  **从 $T_0$ 开始的路径**：\n    $T_0 \\to L_1 \\to T_1 \\to L_2 \\to T_2 \\to L_3 \\to T_3 \\to L_4 \\to T_4 \\to L_5 \\to T_5$\n    顶点序列为 $(T_0, L_1, T_1, L_2, T_2, L_3, T_3, L_4, T_4, L_5, T_5)$。所有顶点都是唯一的，因此是简单路径。\n    边的数量是顶点数减1。此路径中有11个顶点。\n    长度 = $11 - 1 = 10$。\n\n2.  **从 $T_6$ 开始的路径**：\n    此路径在顶点 $T_2$ 处与第一条路径合并。\n    $T_6 \\to L_A \\to T_2 \\to L_3 \\to T_3 \\to L_4 \\to T_4 \\to L_5 \\to T_5$\n    顶点序列为 $(T_6, L_A, T_2, L_3, T_3, L_4, T_4, L_5, T_5)$。所有顶点都是唯一的。\n    此路径中有9个顶点。\n    长度 = $9 - 1 = 8$。\n\n3.  **从 $T_7$ 开始的路径**：\n    此路径在顶点 $T_4$ 处与第一条路径合并。\n    $T_7 \\to L_B \\to T_4 \\to L_5 \\to T_5$\n    顶点序列为 $(T_7, L_B, T_4, L_5, T_5)$。所有顶点都是唯一的。\n    此路径中有5个顶点。\n    长度 = $5 - 1 = 4$。\n\n比较从等待线程开始的最大简单有向路径的长度，我们得到长度为 $10$、$8$ 和 $4$。$G$ 中最长的简单有向等待路径是从 $T_0$ 开始的路径。\n\n因此，最长简单有向等待路径的长度 $\\ell$ 为 $10$。", "answer": "$$\\boxed{10}$$", "id": "3670926"}, {"introduction": "优先继承的原则不仅限于简单的互斥锁。本练习将其应用扩展到更复杂的“读写锁”（Reader-Writer lock）场景，并揭示了一个重要的后果：“链式阻塞”（chained blocking）。你将推导出一个“写者”任务可能遭遇的最大阻塞时间，从而深入理解优先继承协议在“多对一”阻塞情况下的性能影响。[@problem_id:3670917]", "problem": "一个单处理器系统使用固定优先级抢占式调度和读写（RW）锁来处理共享数据。为二进制信号量实现了优先级继承协议（PIP），并将其扩展到读写锁，规则如下：任何当前以共享（读）模式持有读写锁并因此阻止写者获取锁的任务，都有资格在其继续持有读写锁期间继承被阻塞写者的优先级。该读写锁是写者优先的：一旦有写者排队，就不会允许新的读者进入，直到该写者获取并释放锁。\n\n考虑一个最高优先级的写者任务 $T_{H}$，它试图以写模式获取读写锁，但被阻塞，因为有 $r$ 个较低优先级的读者任务 $T_{L}^{1},\\dots,T_{L}^{r}$ 已经以共享模式持有了该读写锁。每个读者任务 $T_{L}^{i}$ 在读写锁保护下执行一个临界区，其持续时间最多为 $L_{i}$（时间单位），在临界区内没有嵌套锁、没有自我挂起，并且是纯粹的处理器密集型执行。假设在 $T_{H}$ 请求锁的瞬间，这 $r$ 个读者是当前唯一持有该锁的任务，并且所有新到达的读者都被锁的写者优先策略所阻塞。\n\n仅从固定优先级抢占式调度、优先级继承协议（PIP）的语义以及读写锁的语义的核心定义出发，推断优先级传递是必须应用于所有 $r$ 个读者还是仅应用于一个子集，并推导由这 $r$ 个并发读者引起的 $T_{H}$ 最坏情况阻塞时间的紧密上界 $B_{H}$。你的界限必须表示为关于 $r$ 和 $L_{1},\\dots,L_{r}$ 的封闭形式解析表达式。假设所有 $L_{i}$ 都以毫秒为单位进行测量，并以毫秒表示最终的界限。不需要四舍五入。", "solution": "首先根据指定标准验证问题。\n\n### 步骤 1：提取已知条件\n- **系统**：单处理器。\n- **调度**：固定优先级抢占式调度。\n- **同步**：读写（RW）锁。\n- **锁策略**：写者优先。一旦有写者排队，就不允许新的读者进入。\n- **协议**：实现了优先级继承协议（PIP）。\n- **PIP 扩展规则**：如果一个任务以共享（读）模式持有读写锁，从而阻止写者获取该锁，则该任务有资格继承被阻塞写者的优先级。\n- **任务**：\n  - $T_{H}$：一个最高优先级的写者任务。\n  - $T_{L}^{1}, \\dots, T_{L}^{r}$：一组 $r$ 个较低优先级的读者任务。\n- **场景**：\n  - 在初始时刻，$T_{H}$ 试图以写模式获取读写锁。\n  - $T_{H}$ 被阻塞，因为 $r$ 个任务 $T_{L}^{1}, \\dots, T_{L}^{r}$ 已经以共享模式持有了该锁。\n- **任务属性**：\n  - 每个读者任务 $T_{L}^{i}$ 执行一个受读写锁保护的单一临界区。\n  - 任务 $T_{L}^{i}$ 的临界区持续时间最多为 $L_{i}$ 个时间单位。\n  - 读者任务的临界区是纯粹的处理器密集型，没有嵌套锁或自我挂起。\n- **假设**：\n  - 当 $T_{H}$ 发出请求时，这 $r$ 个读者是唯一持有该锁的任务。\n  - 所有新的读者都被写者优先策略阻塞。\n- **目标**：\n  1. 确定优先级继承是应用于所有 $r$ 个读者还是一个子集。\n  2. 推导由这 $r$ 个读者引起的 $T_{H}$ 的最坏情况阻塞时间的紧密上界 $B_{H}$，并表示为关于 $r$ 和 $L_{1}, \\dots, L_{r}$ 的封闭形式解析表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，提法恰当且客观。它使用了实时操作系统领域的标准概念，包括固定优先级调度、读写锁和优先级继承协议。所描述的场景是分析阻塞时间和优先级反转的经典案例研究。问题陈述是自包含的，提供了推导解决方案所需的所有必要定义和约束。术语精确，没有矛盾或事实错误。该问题是可形式化的，需要对系统组件之间的交互进行非平凡的推理。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供一个合理的解决方案。\n\n### 解答推导\n\n解决方案是通过分析任务、调度器和锁定机制之间基于所提供规则的交互来推导的。\n\n首先，我们讨论优先级传递是否适用于所有 $r$ 个读者。高优先级写者任务 $T_{H}$ 试图以独占（写）模式获取读写锁。如果锁已被任何其他任务（无论是读模式还是写模式）持有，则不能将锁授予写者。在这种情况下，锁被 $r$ 个读者任务 $\\{T_{L}^{1}, T_{L}^{2}, \\dots, T_{L}^{r}\\}$ 以共享（读）模式同时持有。$T_{H}$ 解除阻塞的条件是*所有* $r$ 个读者都释放该锁。\n\n根据指定的 PIP 规则，“任何当前以共享（读）模式持有读写锁并因此阻止写者获取锁的任务，都有资格继承被阻塞写者的优先级。” 由于任何一个任务 $T_{L}^{i}$ 继续持有锁都足以阻止 $T_{H}$ 继续执行，所以这 $r$ 个读者中的每一个都直接导致了 $T_{H}$ 的阻塞。因此，为了解决这种优先级反转，必须将优先级传递应用于所有 $r$ 个读者任务。每个任务 $T_{L}^{i}$（其中 $i \\in \\{1, \\dots, r\\}$）都会继承 $T_{H}$ 的优先级。\n\n接下来，我们推导阻塞时间 $B_{H}$ 的紧密上界。在应用 PIP 之后，所有 $r$ 个读者任务现在都准备好以与 $T_{H}$ 相同的高优先级水平执行。系统是单处理器的，这是一个关键约束。在单处理器上，任何时刻只能有一个任务执行。\n\n当多个任务准备好在同一优先级水平上运行时，次级调度策略（例如，FIFO 或轮询）将决定其顺序。然而，无论平局决胜规则如何，由于所有 $r$ 个读者现在都具有系统中最高的活动优先级并且是处理器密集型的，它们不能被任何其他任务抢占。因此，它们的临界区将在单个 CPU 上串行执行。一个读者将获得处理器访问权，运行其临界区直到完成，并释放锁；然后另一个读者将做同样的事情，依此类推，直到所有 $r$ 个读者都完成。\n\n$T_{H}$ 的总阻塞时间是从它请求锁的时刻到最终获得锁的全部时长。这个时间段只有在 $r$ 个读者中的最后一个完成其临界区并释放锁时才会结束。读者 $T_{L}^{i}$ 的临界区的最坏情况执行时间为 $L_{i}$。由于它们在 CPU 上的执行是串行的，因此所有 $r$ 个读者完成其临界区所需的总最坏情况时间是它们各自最坏情况持续时间的总和。\n\n这种现象被称为链式阻塞，即一个高优先级任务被阻塞的时间取决于多个低优先级任务的累积执行时间。写者优先策略在这里至关重要，因为它阻止了在 $T_{H}$ 排队请求后可能到达的任何新读者获取锁，从而将阻塞任务的数量限制为最初的 $r$ 个读者集合。\n\n因此，阻塞时间 $B_{H}$ 的紧密上界是当 $T_{H}$ 发出请求时持有锁的所有 $r$ 个读者的最大临界区长度之和。这个界限被认为是紧密的，因为可以轻易地构造出一个最坏情况：在 $T_{H}$ 请求锁的瞬间，所有 $r$ 个读者都刚刚进入它们的临界区并准备执行，并且每个读者随后都消耗其最大处理时间 $L_{i}$。单处理器调度器会接着逐一执行它们，导致总阻塞时间等于它们持续时间之和。\n\n因此，$T_H$ 的阻塞时间的紧密上界的最终表达式是：\n$$B_{H} = L_{1} + L_{2} + \\dots + L_{r} = \\sum_{i=1}^{r} L_{i}$$\n$B_H$ 的单位是毫秒，因为其组成项 $L_i$ 是以毫秒为单位给出的。", "answer": "$$\\boxed{\\sum_{i=1}^{r} L_{i}}$$", "id": "3670917"}]}