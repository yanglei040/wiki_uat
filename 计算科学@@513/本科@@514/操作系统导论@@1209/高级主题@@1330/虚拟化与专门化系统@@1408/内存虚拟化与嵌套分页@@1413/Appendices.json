{"hands_on_practices": [{"introduction": "要真正掌握嵌套分页，最有效的方法之一就是亲手完成一次完整的地址转换。这个练习将引导你完成一个从客户机虚拟地址（GVA）到主机物理地址（HPA）的两阶段翻译过程，这正是硬件辅助内存虚拟化的核心机制。通过这个练习 [@problem_id:3657979]，你不仅能熟悉页表查询的步骤，还将学会如何在每一步中验证访问权限，这是确保系统安全与隔离的关键。", "problem": "一个 $32$ 位客户机在启用物理地址扩展 (PAE) 和“不可执行”(NX) 支持的情况下，以监管者模式运行。该客户机尝试向客户机线性地址 $0x\\mathrm{E5412345}$ 进行单字节写入。虚拟机监控程序 (hypervisor) 使用 Intel 扩展页表 (EPT) 进行嵌套分页。假设索引提取和权限检查遵循标准的 PAE 语义，EPT 的索引提取和权限检查也遵循其标准语义，包括支持混合页面大小。\n\n客户机分页结构 (PAE)：\n- 索引为 $3$ 的页目录指针表条目 (PDPTE) 存在，并指向一个页目录，该页目录的页目录条目 (PDE) 均有效。您可以假设该 PDPTE 的权限不会在下面描述的 PDE 所隐含的权限之外，进一步限制监管者写入。\n- 在所引用的页目录中，索引为 $0x\\mathrm{12A}$ 的页目录条目被标记为存在，读/写位置为启用，用户/监管者位指示仅监管者访问，并且页面大小位置位（它映射一个 $2\\,\\text{MiB}$ 的页面）。此 PDE 中的“不可执行”位被清除。此 PDE 映射一个客户机物理 $2\\,\\text{MiB}$ 帧，其客户机物理基地址为 $0x\\mathrm{01A00000}$。\n\nEPT 结构：\n- 索引为 $0$ 的 EPT 页映射级别 $4$ (PML4) 条目是可读/可写/可执行的，并指向一个有效的 EPT 页目录指针表 (PDPT)。\n- 索引为 $0$ 的 EPT PDPT 条目是可读/可写/可执行的，并指向一个有效的 EPT 页目录 (PD)。\n- 索引为 $13$ 的 EPT PD 条目是可读/可写/可执行的，不是大页面条目，并指向一个有效的 EPT 页表 (PT)。\n- 索引为 $18$ 的 EPT 页表条目 (PTE) 是可读和可写的（可执行位被清除），并映射一个 $4\\,\\text{KiB}$ 的主机物理帧，其主机物理基地址为 $0x\\mathrm{00000000008F3000}$。\n\n假设在客户机和 EPT 遍历过程中的所有未指定条目都存在且正确对齐，并且没有其他处理器状态（如缓存控制）影响此访问的权限检查。\n\n任务：\n- 使用 PAE 地址转换和 EPT 地址转换的定义，导出与客户机写入访问相对应的最终主机物理地址。在每一步都明确验证权限是否允许监管者模式写入。如果任何权限会拒绝该访问，您必须在该点终止推导；否则，计算最终地址。\n- 将最终地址表示为带有 $0x$ 前缀的单个十六进制无符号整数。不要四舍五入。", "solution": "该问题要求对由客户机操作系统发起的写入访问执行两阶段内存地址转换。第一阶段使用客户机的分页结构 (PAE) 将客户机线性地址转换为客户机物理地址。第二阶段使用虚拟机监控程序的扩展页表 (EPT) 将得到的客户机物理地址转换为主机物理地址。在两个转换的每一步中，我们都必须验证访问权限是否允许监管者模式的写入。\n\n**第一阶段：客户机线性地址到客户机物理地址 (GPA) 的转换**\n\n客户机是一个启用了物理地址扩展 (PAE) 的 $32$ 位系统。一个 $32$ 位的线性地址使用三级页表结构进行转换。待转换的客户机线性地址是 $LA_g = 0x\\mathrm{E5412345}$。\n\n在 PAE 模式下，$32$ 位线性地址按如下方式分区：\n- 位 $31-30$：页目录指针表 (PDPTE) 的索引，$2$ 位。\n- 位 $29-21$：页目录 (PD) 的索引，$9$ 位。\n- 位 $20-0$：页内偏移量，$21$ 位（对于 $2\\,\\text{MiB}$ 页面）。\n\n我们解析客户机线性地址 $LA_g = 0x\\mathrm{E5412345}$：\n1.  **PDPTE 索引**：索引由地址的最高 $2$ 位给出。\n    $$ \\text{Index}_{\\text{PDPTE}} = \\frac{0x\\mathrm{E5412345}}{2^{30}} = \\lfloor \\frac{3846280005}{1073741824} \\rfloor = 3 $$\n    问题说明索引为 $3$ 的 PDPTE 存在，并且其权限不限制监管者写入。因此，在这一级别上访问是允许的。\n\n2.  **页目录 (PD) 索引**：索引由地址的位 $29-21$ 给出。\n    $$ \\text{Index}_{\\text{PD}} = \\left\\lfloor \\frac{0x\\mathrm{E5412345}}{2^{21}} \\right\\rfloor \\pmod{2^9} = \\left( \\frac{0x\\mathrm{E5412345}}{0x\\mathrm{200000}} \\right) \\ 0x\\mathrm{1FF} $$\n    $0x\\mathrm{E5412345} \\gg 21 = 0x\\mathrm{72A}$。PD 索引是 $0x\\mathrm{72A} \\ 0x\\mathrm{1FF} = 0x\\mathrm{12A}$。\n    问题说明索引为 $0x\\mathrm{12A}$ 的页目录条目 (PDE) 存在。\n\n3.  **权限检查和页面大小确定**：\n    问题指明了索引为 $0x\\mathrm{12A}$ 的 PDE 的属性：\n    - **存在位 (Present)**：该条目有效。\n    - **读/写位 (R/W)**：启用，允许写入访问。\n    - **用户/监管者位 (U/S)**：设置为仅监管者访问。客户机访问是在监管者模式下，因此这是允许的。\n    - **不可执行位 (NX)**：清除。这对于写入访问是无关紧要的，但也不构成限制。\n    - **页面大小位 (PS)**：置位。这表示该 PDE 映射一个大小为 $2\\,\\text{MiB}$ 的大页面。\n\n    该访问是监管者模式的写入，此 PDE 完全允许。由于 PS 位置位，这是客户机地址转换的最后一步。\n\n4.  **客户机物理地址 (GPA) 计算**：\n    对于一个 $2\\,\\text{MiB}$ 的大页面，客户机物理地址是 PDE 中的基物理地址与线性地址中的偏移量之和。\n    - 来自 PDE 的客户机物理基地址为 $0x\\mathrm{01A00000}$。\n    - 偏移量是线性地址的低 $21$ 位：\n      $$ \\text{Offset}_g = LA_g \\pmod{2^{21}} = 0x\\mathrm{E5412345} \\ 0x\\mathrm{1FFFFF} = 0x\\mathrm{12345} $$\n    - 得到的客户机物理地址是：\n      $$ \\text{GPA} = 0x\\mathrm{01A00000} + 0x\\mathrm{12345} = 0x\\mathrm{01A12345} $$\n\n**第二阶段：客户机物理地址 (GPA) 到主机物理地址 (HPA) 的转换**\n\n虚拟机监控程序使用 Intel 扩展页表 (EPT) 将 GPA 转换为主机物理地址 (HPA)。这涉及使用 GPA $0x\\mathrm{01A12345}$ 进行四级页表遍历。EPT 结构将一个物理地址划分为四个 $9$ 位索引和一个 $12$ 位偏移量。\n\n对于 EPT 遍历，GPA $0x\\mathrm{01A12345}$ 按如下方式解析：\n- 位 $47-39$：EPT 页映射级别 $4$ 表 (PML4T) 的索引。\n- 位 $38-30$：EPT 页目录指针表 (PDPT) 的索引。\n- 位 $29-21$：EPT 页目录 (PD) 的索引。\n- 位 $20-12$：EPT 页表 (PT) 的索引。\n- 位 $11-0$：$4\\,\\text{KiB}$ 页面内的偏移量。\n\n1.  **EPT PML4 索引**：由于 GPA $0x\\mathrm{01A12345}$ 是一个 $32$ 位地址，其第 $32$ 位到第 $47$ 位均为 $0$。\n    $$ \\text{Index}_{\\text{PML4}} = \\left\\lfloor \\frac{0x\\mathrm{01A12345}}{2^{39}} \\right\\rfloor \\pmod{2^9} = 0 $$\n    索引为 $0$ 的 EPT PML4 条目被指定为可读、可写和可执行。写入是允许的。\n\n2.  **EPT PDPT 索引**：GPA 的位 $38-30$ 也为 $0$。\n    $$ \\text{Index}_{\\text{PDPT}} = \\left\\lfloor \\frac{0x\\mathrm{01A12345}}{2^{30}} \\right\\rfloor \\pmod{2^9} = 0 $$\n    索引为 $0$ 的 EPT PDPT 条目被指定为可读、可写和可执行。写入是允许的。\n\n3.  **EPT PD 索引**：\n    $$ \\text{Index}_{\\text{PD}} = \\left\\lfloor \\frac{0x\\mathrm{01A12345}}{2^{21}} \\right\\rfloor \\pmod{2^9} = (0x\\mathrm{01A12345} \\gg 21) \\ 0x\\mathrm{1FF} = 0xD = 13 $$\n    索引为 $13$ 的 EPT PD 条目被指定为可读、可写和可执行，且不是大页面条目。写入是允许的，遍历继续到下一级。\n\n4.  **EPT PT 索引**：\n    $$ \\text{Index}_{\\text{PT}} = \\left\\lfloor \\frac{0x\\mathrm{01A12345}}{2^{12}} \\right\\rfloor \\pmod{2^9} = (0x\\mathrm{01A12345} \\gg 12) \\ 0x\\mathrm{1FF} = 0x\\mathrm{1A12} \\ 0x\\mathrm{1FF} = 0x\\mathrm{12} = 18 $$\n    索引为 $18$ 的 EPT 页表条目 (PTE) 是 EPT 遍历中的最后一个条目。它被指定为可读和可写，这允许客户机的写入访问。可执行位被清除对于数据写入不构成限制。此 PTE 映射一个 $4\\,\\text{KiB}$ 的主机物理帧。\n\n5.  **主机物理地址 (HPA) 计算**：\n    HPA 是 EPT PTE 中的主机物理基地址与 GPA 中的偏移量之和。\n    - 来自 PTE 的主机物理基地址为 $0x\\mathrm{00000000008F3000}$。\n    - 偏移量是 GPA 的低 $12$ 位：\n      $$ \\text{Offset}_h = \\text{GPA} \\pmod{2^{12}} = 0x\\mathrm{01A12345} \\ 0x\\mathrm{FFF} = 0x\\mathrm{345} $$\n    - 得到的主机物理地址是：\n      $$ \\text{HPA} = 0x\\mathrm{8F3000} + 0x\\mathrm{345} = 0x\\mathrm{8F3345} $$\n\n在客户机级别和 EPT 级别的转换过程中，所有针对监管者模式写入的权限检查均已通过。最终的主机物理地址已成功导出。", "answer": "$$\\boxed{0x\\mathrm{8F3345}}$$", "id": "3657979"}, {"introduction": "理解了底层的翻译机制后，我们可以探索它如何支持高级的系统优化。写时复制（Copy-on-Write, COW）是一种强大的技术，它通过延迟物理内存的复制来极大地加速进程或虚拟机的创建。这个练习 [@problem_id:3657999] 将向你展示，虚拟机监视器（hypervisor）如何通过精确地操纵扩展页表（EPT）条目来实现COW，从而让你理解理论概念是如何转化为实际的性能提升的。", "problem": "一个在支持 Intel 扩展页表 (EPT) 的 x86 平台上的虚拟机管理器 (hypervisor)，使用写时复制来实现快速的虚拟机克隆。在此设置中，中央处理器 (CPU) 执行两阶段地址转换：客户机虚拟地址使用客户机页表转换为客户机物理地址，然后客户机物理地址再使用 EPT 转换为宿主机物理地址。写入的硬件权限检查由该转换管道上各权限的交集来强制执行：只有当所有相关权限都允许写入时，写入才被允许；否则，将向相应的处理程序引发一个故障。\n\n考虑一个单一的虚拟机 fork 操作，该操作克隆一个父虚拟机以产生一个子虚拟机。该 hypervisor 在 EPT 叶条目级别实现写时复制，以便在两个虚拟机之间初步共享 $S$ 个不同的宿主机页帧。这 $S$ 个页面中的每一个当前都在父虚拟机中通过一个授予读写权限的 EPT 叶条目进行映射。为了在 fork 时建立写时复制共享，hypervisor 必须确保父虚拟机或子虚拟机后续对这些共享页面的任何写入都将被截获，以便可以创建一个私有副本。\n\n假设该 fork 操作遵循以下操作模型：\n- 对于 $S$ 个共享页面中的每一个，hypervisor 修改父虚拟机现有的 EPT 叶条目，以拒绝写入，同时继续允许读取。\n- 对于 $S$ 个共享页面中的每一个，hypervisor 在子虚拟机的 EPT 中安装一个相应的 EPT 叶条目，该条目映射到与父虚拟机相同的宿主机物理页面，并且同样拒绝写入但允许读取。\n- 覆盖这 $S$ 个页面的地址范围的父子虚拟机的上层 EPT 结构（非叶级别）已被分配或重用，无需修改。转换后备缓冲区（TLB）刷下、访问位或脏位的副作用，以及实际发生写故障时的任何后续更新，均不在此计算范围内。\n\n在这些条件下，计算在此次单一 fork 操作期间 hypervisor 必须执行的 EPT 叶条目更新的总数，并表示为共享页面数 $S$ 的函数。请以关于 $S$ 的闭式解析表达式形式给出您的答案。无需四舍五入，也无需单位。", "solution": "该问题已经过验证，被认为是科学上可靠、定义明确且客观的。它描述了操作系统和虚拟化技术中的一个标准过程，即使用硬件辅助内存虚拟化（Intel EPT）为虚拟机派生（forking）实现写时复制（COW）。问题陈述是自包含的，所有必要的参数和假设都已明确定义，从而能够得出一个唯一且有意义的解。\n\n目标是计算单个虚拟机 fork 操作所需的扩展页表（EPT）叶条目更新的总数，作为共享页面数 $S$ 的函数。\n\n问题指明，在 fork 过程中，hypervisor 为了建立 $S$ 个页面的 COW 共享，执行了以下操作：\n\n1.  **对父虚拟机的更新：**\n    问题陈述：“对于 $S$ 个共享页面中的每一个，hypervisor 修改父虚拟机现有的 EPT 叶条目，以拒绝写入，同时继续允许读取。”\n    EPT 叶条目是内存中的一个数据结构，用于定义页面的映射和权限。修改一个现有条目，例如通过清除写权限位，构成对该内存位置的一次更新。由于此操作对 $S$ 个共享页面中的每一个都执行一次，因此对父虚拟机的 EPT 叶条目更新次数恰好为 $S$。我们用 $N_{parent}$ 表示这个计数。\n    $$N_{parent} = S$$\n\n2.  **对子虚拟机的更新：**\n    问题陈述：“对于 $S$ 个共享页面中的每一个，hypervisor 在子虚拟机的 EPT 中安装一个相应的 EPT 叶条目，该条目映射到与父虚拟机相同的宿主机物理页面，并且同样拒绝写入但允许读取。”\n    子虚拟机以其自己独立的 EPT 结构开始。“安装”一个新的 EPT 叶条目意味着 hypervisor 必须创建此条目并将其写入子虚拟机的相应叶级别 EPT 页面中。写入新条目数据的行为是对 EPT 结构的一次更新。此操作也对 $S$ 个共享页面中的每一个执行一次。因此，对子虚拟机的 EPT 叶条目更新次数也为 $S$。我们用 $N_{child}$ 表示这个计数。\n    $$N_{child} = S$$\n\n问题明确要求计算 EPT 叶条目更新的*总*数。这个总数，我们称之为 $N_{total}$，是为父虚拟机的 EPT 执行的更新数与为子虚拟机的 EPT 执行的更新数之和。\n\n$$N_{total} = N_{parent} + N_{child}$$\n\n代入从问题描述中导出的值：\n\n$$N_{total} = S + S$$\n$$N_{total} = 2S$$\n\n问题指明，对上层 EPT 结构的修改、TLB 刷下以及发生写故障时的后续更新都应排除在此计数之外。上述计算严格遵守这些约束，仅计算在 fork 操作瞬间执行的 EPT 叶条目更新。\n\n因此，EPT 叶条目更新的总数是共享页面数的两倍。", "answer": "$$\\boxed{2S}$$", "id": "3657999"}, {"introduction": "在现代多核处理器上，内存虚拟化的性能不仅仅取决于地址翻译的速度，还取决于如何高效地管理页表更新。当页表条目被修改时，必须使所有处理器核心上的翻译后备缓冲器（TLB）中的旧条目失效，这一过程（称为TLB shootdown）可能非常耗时。这个练习 [@problem_id:3657962] 将让你扮演系统设计师的角色，分析并量化一种重要的优化策略——批处理更新——以减少TLB shootdown带来的开销，从而提升整个系统的性能。", "problem": "您正在设计一个虚拟机监控程序（hypervisor）的更新路径，该程序在一台拥有 $C$ 个物理核心的 $x86$ 计算机上使用扩展页表（EPT）进行嵌套分页。根据虚拟内存正确性的定义，对页表的任何更改都不能在任何转译后备缓冲器（TLB）中留下过时的缓存翻译。因此，在 EPT 条目更改后，必须通过 TLB 击落（shootdown）来使所有可能已缓存这些过时条目的核心上的条目失效。实现这一目标的标准机制是向参与的核心发送处理器间中断（IPI），并执行 EPT 上下文失效操作。考虑两种应用 $N$ 个 EPT 条目更新的策略：朴素策略和批处理策略。朴素策略是每应用一次 EPT 更新，就立即执行一次全局击落，然后再进行下一次更新。批处理策略通过将更新分组到大小为 $B$ 的固定大小批次中来延迟击落操作，每个批次执行一次全局击落。同时确保在此期间没有虚拟中央处理器（vCPU）使用过时的翻译执行（例如，通过暂停映射到该 EPT 的 vCPU，或持有该 EPT 的写锁，以便在批处理完成前没有 vCPU 可以运行）。您的批处理算法必须保持一个不变式，即更新后不会使用任何过时的 EPT 翻译；使用内存排序确保在发出击落指令前，所有 EPT 写入都已变得可见。\n\n假设更新线程的经过时间遵循以下成本模型：\n- 每个 EPT 条目更新耗时 $t_u = 0.12\\,\\mu\\text{s}$。\n- 在批处理策略中，每个更新条目的批次内簿记/标记会增加 $t_m = 0.03\\,\\mu\\text{s}$ 的成本。\n- 完成一次全局 TLB 击落的实际耗时 (wall-clock cost) 为\n$$t_s = (C-1)\\,t_{\\text{send}} + t_{\\text{ack}} + t_b,$$\n其中 $t_{\\text{send}} = 0.20\\,\\mu\\text{s}$ 是发送方对每个目标的 IPI 发出时间，$t_{\\text{ack}} = 2.0\\,\\mu\\text{s}$ 是最慢的接收方处理 IPI 并确认的时间，$t_b = 1.0\\,\\mu\\text{s}$ 是屏障/同步开销。\n- 参数：$C = 8$, $N = 4096$, $B = 128$。\n\n将加速比定义为 $S = T_{\\text{naive}}/T_{\\text{batched}}$，其中 $T_{\\text{naive}}$ 和 $T_{\\text{batched}}$ 分别是上述模型下朴素策略和批处理策略的经过时间。请在您的批处理设计中注意遵守 TLB/EPT 正确性不变式，并根据“更新的页表必须在过时翻译被使用前对所有核心可见”这一基本要求，确定 $S$ 的值。\n\n哪个选项最接近 $S$ 的正确值？\n\nA. $S \\approx 24.5$\n\nB. $S \\approx 29.3$\n\nC. $S \\approx 15.7$\n\nD. $S \\approx 128$", "solution": "问题陈述已经过验证，被认为是科学合理的、定义明确的、客观的且自洽的。唯一解所需的所有必要参数和定义均已提供，所描述的场景是操作系统和虚拟机监控程序设计中一个标准且现实的性能优化问题。\n\n目标是计算加速比 $S$，它被定义为朴素策略所用总时间 $T_{\\text{naive}}$ 与批处理策略所用总时间 $T_{\\text{batched}}$ 的比率。\n$$S = \\frac{T_{\\text{naive}}}{T_{\\text{batched}}}$$\n我们将根据提供的成本模型和参数来计算 $T_{\\text{naive}}$ 和 $T_{\\text{batched}}$。\n\n首先，我们计算单次全局 TLB 击落的成本 $t_s$。给出的公式如下：\n$$t_s = (C-1)\\,t_{\\text{send}} + t_{\\text{ack}} + t_b$$\n给定的参数值为：\n- 物理核心数, $C = 8$\n- 每个目标的 IPI 发出时间, $t_{\\text{send}} = 0.20\\,\\mu\\text{s}$\n- 最慢接收方的确认时间, $t_{\\text{ack}} = 2.0\\,\\mu\\text{s}$\n- 屏障/同步开销, $t_b = 1.0\\,\\mu\\text{s}$\n\n将这些值代入 $t_s$ 的方程中：\n$$t_s = (8-1) \\times 0.20\\,\\mu\\text{s} + 2.0\\,\\mu\\text{s} + 1.0\\,\\mu\\text{s}$$\n$$t_s = 7 \\times 0.20\\,\\mu\\text{s} + 3.0\\,\\mu\\text{s}$$\n$$t_s = 1.4\\,\\mu\\text{s} + 3.0\\,\\mu\\text{s} = 4.4\\,\\mu\\text{s}$$\n\n接下来，我们计算朴素策略的总时间 $T_{\\text{naive}}$。\n在朴素策略中，每次 EPT 条目更新后都立即进行一次全局 TLB 击落。这样一个周期的成本是更新成本 $t_u$ 和击落成本 $t_s$ 的总和。这个周期重复 $N$ 次。\n给定的参数是：\n- EPT 更新次数, $N = 4096$\n- EPT 条目更新时间, $t_u = 0.12\\,\\mu\\text{s}$\n\n总时间为：\n$$T_{\\text{naive}} = N \\times (t_u + t_s)$$\n$$T_{\\text{naive}} = 4096 \\times (0.12\\,\\mu\\text{s} + 4.4\\,\\mu\\text{s})$$\n$$T_{\\text{naive}} = 4096 \\times 4.52\\,\\mu\\text{s} = 18513.92\\,\\mu\\text{s}$$\n\n现在，我们计算批处理策略的总时间 $T_{\\text{batched}}$。\n在批处理策略中，$N$ 次更新被分成大小为 $B=128$ 的批次。因此，批次的数量为：\n$$\\text{批次数量} = \\frac{N}{B} = \\frac{4096}{128} = 32$$\n对于每个批次，过程如下：\n1.  执行 $B$ 次更新。这些更新的总时间为 $B \\times t_u$。\n2.  为 $B$ 次更新中的每一次执行簿记/标记操作。问题陈述中说明，每次更新条目会增加 $t_m = 0.03\\,\\mu\\text{s}$ 的成本。因此，一个批次的总标记成本为 $B \\times t_m$。\n3.  执行一次全局 TLB 击落，成本为 $t_s$。\n\n一个批次的总时间是这些成本的总和：$B \\times t_u + B \\times t_m + t_s$。\n批处理策略的总时间 $T_{\\text{batched}}$ 是每个批次的成本乘以批次数量：\n$$T_{\\text{batched}} = \\left(\\frac{N}{B}\\right) \\times \\left(B \\cdot t_u + B \\cdot t_m + t_s\\right)$$\n这可以通过代数方法简化，按成本类型分组：\n$$T_{\\text{batched}} = N \\cdot t_u + N \\cdot t_m + \\left(\\frac{N}{B}\\right) \\cdot t_s$$\n$$T_{\\text{batched}} = N(t_u + t_m) + \\left(\\frac{N}{B}\\right)t_s$$\n代入给定值：\n- $N = 4096$\n- $B = 128$\n- $t_u = 0.12\\,\\mu\\text{s}$\n- $t_m = 0.03\\,\\mu\\text{s}$\n- $t_s = 4.4\\,\\mu\\text{s}$\n\n$$T_{\\text{batched}} = 4096 \\times (0.12\\,\\mu\\text{s} + 0.03\\,\\mu\\text{s}) + \\left(\\frac{4096}{128}\\right) \\times 4.4\\,\\mu\\text{s}$$\n$$T_{\\text{batched}} = 4096 \\times (0.15\\,\\mu\\text{s}) + 32 \\times 4.4\\,\\mu\\text{s}$$\n$$T_{\\text{batched}} = 614.4\\,\\mu\\text{s} + 140.8\\,\\mu\\text{s}$$\n$$T_{\\text{batched}} = 755.2\\,\\mu\\text{s}$$\n\n最后，我们计算加速比 $S$：\n$$S = \\frac{T_{\\text{naive}}}{T_{\\text{batched}}} = \\frac{18513.92\\,\\mu\\text{s}}{755.2\\,\\mu\\text{s}}$$\n$$S \\approx 24.51515...$$\n\n计算出的加速比约为 $24.5$。我们现在评估给出的选项。\n\nA. $S \\approx 24.5$\n此选项与我们计算出的值 $S \\approx 24.515$ 相符。\n结论：**正确**\n\nB. $S \\approx 29.3$\n此值与我们的计算结果有显著差异。\n结论：**错误**\n\nC. $S \\approx 15.7$\n此值与我们的计算结果有显著差异。\n结论：**错误**\n\nD. $S \\approx 128$\n这个值等于批处理大小 $B$。它代表了高成本击落操作数量减少的倍数（朴素情况下的 $N$ 次击落与批处理情况下的 $N/B$ 次击落，减少因子为 $B$）。然而，加速比取决于总时间，总时间还包括更新成本（$t_u$）和标记成本（$t_m$）。总加速比将小于最主要成本部分（击落操作）的减少因子，因为其他成本（没有以相同因子减少）稀释了整体效益。\n结论：**错误**", "answer": "$$\\boxed{A}$$", "id": "3657962"}]}