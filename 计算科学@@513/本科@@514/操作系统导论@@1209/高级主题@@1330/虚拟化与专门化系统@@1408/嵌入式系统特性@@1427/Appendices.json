{"hands_on_practices": [{"introduction": "在许多嵌入式系统中，特别是那些没有硬件内存保护的系统中，堆栈溢出可能导致灾难性故障。本练习将演示一项关键的安全性分析：通过考虑中断服务程序可能出现的最大嵌套深度，来计算最坏情况下的堆栈使用量，从而确保您的系统在任何条件下都拥有足够的内存来可靠运行。[@problem_id:3638740]", "problem": "一个单核微控制器运行一个抢占式实时操作系统，该系统具有固定优先级的中断处理机制和一个统一栈：当前运行的任务和任何抢占它的中断服务程序 (ISR) 的帧都放置在同一个后进先出的栈上。在任何时刻，实时栈的内容是被中断任务的实时帧，其后按到达顺序拼接了所有嵌套ISR的帧，最近到达的ISR帧在最顶部。假设在任何地方都没有递归，每个ISR都是不可重入的，并且ISR内部的临界区仅在相对于抢占而言可忽略不计的持续时间内屏蔽相同或更低优先级的中断。系统没有单独的仅用于中断的栈，也没有内存保护单元。\n\n给定以下系统特性和测量值：\n- 在第一个中断可能到达前的瞬间，当前运行任务测得的最坏情况下实时栈使用量为 $S_{\\text{task}} = 1408$ 字节。\n- 有 $4$ 个具有固定不同优先级的ISR。它们被表示为 $\\text{ISR}_{1}$ (最高优先级)、$\\text{ISR}_{2}$、$\\text{ISR}_{3}$ 和 $\\text{ISR}_{4}$ (最低优先级)。工具链的栈分析器报告了每个ISR在活动时（包括其序言/尾声、寄存器保存、局部变量及其任何内部调用帧）相对于其调用者的帧已在栈上的情况下的额外栈使用量如下：\n  - $\\text{ISR}_{1}$ 的 $\\Delta S_{1} = 224$ 字节，\n  - $\\text{ISR}_{2}$ 的 $\\Delta S_{2} = 176$ 字节，\n  - $\\text{ISR}_{3}$ 的 $\\Delta S_{3} = 144$ 字节，\n  - $\\text{ISR}_{4}$ 的 $\\Delta S_{4} = 128$ 字节。\n- 中断控制器允许与这些优先级一致的完全抢占。在最坏情况下，一个较低优先级的ISR在运行时，可能会被任何在其执行期间到达的、优先级严格更高的ISR连续抢占。假设中断的到达可以以一种极端的方式对齐，以便在满足这些优先级的前提下最大化嵌套深度。\n- 为了检测罕见的溢出并为调试器哨兵值留出空间，工程策略规定，在最大实时使用量之上必须有一个固定的、大小为 $128$ 字节的未被触及的保护带。\n\n仅使用以下一般原则：(i) 栈是后进先出的，(ii) 抢占式固定优先级中断可以嵌套，使得瞬时实时栈等于被中断任务的帧加上所有当前活动ISR的帧，以及 (iii) 所需的分配量必须比最大可能的瞬时实时使用量多出一个固定的保护带大小，请确定能保证在最坏情况下不发生溢出的最小栈分配量 $S_{\\text{alloc}}$ (以字节为单位)。\n\n将你的最终答案表示为一个以字节为单位的整数。不要四舍五入；报告精确值。", "solution": "该问题要求计算一个具有固定优先级中断的抢占式实时系统所需的最小栈分配大小。该过程始于对问题陈述的正式验证。\n\n### 步骤1：提取给定信息\n问题陈述中明确提供的数据和条件如下：\n- **系统架构**：一个带有抢占式实时操作系统的单核微控制器。\n- **栈模型**：一个用于任务和中断服务程序 (ISR) 的统一的后进先出 (LIFO) 栈。\n- **任务栈使用量**：在可能发生抢占的时刻，运行中任务的最坏情况实时栈使用量为 $S_{\\text{task}} = 1408$ 字节。\n- **中断**：有 $4$ 个具有不同固定优先级的ISR。\n- **优先级**：优先级层次结构为 $\\text{ISR}_{1} > \\text{ISR}_{2} > \\text{ISR}_{3} > \\text{ISR}_{4}$，其中 $\\text{ISR}_{1}$ 具有最高优先级。\n- **ISR栈增量**：每个活动ISR的额外栈使用量为：\n  - $\\text{ISR}_{1}$ 的 $\\Delta S_{1} = 224$ 字节。\n  - $\\text{ISR}_{2}$ 的 $\\Delta S_{2} = 176$ 字节。\n  - $\\text{ISR}_{3}$ 的 $\\Delta S_{3} = 144$ 字节。\n  - $\\text{ISR}_{4}$ 的 $\\Delta S_{4} = 128$ 字节。\n- **抢占规则**：根据固定优先级允许完全抢占。一个较低优先级的ISR可以被任何优先级严格更高的ISR抢占。中断的到达可以对齐以最大化嵌套深度。\n- **安全余量**：在最大可能实时栈使用量之上，必须分配一个固定的 $S_{\\text{guard}} = 128$ 字节的保护带。\n- **目标**：确定最小总栈分配量 $S_{\\text{alloc}}$（以字节为单位）。\n\n### 步骤2：使用提取的给定信息进行验证\n根据既定的验证标准对问题进行评估。\n\n- **科学性**：该问题基于实时操作系统的公认原则，特别是针对栈内存的最坏情况执行分析 (WCEA)。具有固定优先级抢占式中断的统一栈模型是嵌入式系统工程中的一个标准场景。\n- **适定性**：该问题提供了所有必需的数值（$S_{\\text{task}}$、所有的 $\\Delta S_i$、$S_{\\text{guard}}$）和一个清晰、明确的过程（抢占式嵌套），以确定总栈分配的唯一解。\n- **客观性**：该问题以计算机工程和操作系统领域通用的精确、客观的语言陈述。术语如“抢占式”、“固定优先级”和“ISR”都有标准定义。\n\n问题陈述没有任何缺陷。它是一个科学合理、适定且客观的问题，与嵌入式操作系统的特性直接相关。\n\n### 步骤3：结论与行动\n问题是有效的。将推导解决方案。\n\n### 解决方案的推导\n核心任务是确定最大可能的瞬时实时栈使用量，记为 $S_{\\text{max\\_live}}$。然后，所需的总分配量 $S_{\\text{alloc}}$ 将是这个最大使用量加上强制性的保护带。\n\n该系统对中断采用统一栈和固定优先级抢占式调度模型。这意味着如果一个低优先级的ISR正在执行，一个更高优先级中断的到来将导致低优先级的ISR被挂起，而高优先级的ISR开始执行。新的、更高优先级ISR的栈帧被放置在现有栈的顶部，该栈已包含被抢占任务和被抢占的较低优先级ISR的帧。\n\n为了找到最坏情况下的栈使用量，我们必须确定导致函数调用和中断服务程序最大嵌套的事件序列。根据问题描述，当事件以“在满足这些优先级的前提下最大化嵌套深度”的方式对齐时，就会发生这种情况。\n\n当系统处于基础任务消耗最大栈的状态，然后一系列中断以优先级递增的顺序到达时，会发生最深的可能嵌套。最坏情况的场景展开如下：\n\n1.  主任务正在运行，并达到其自身的最大栈使用量 $S_{\\text{task}} = 1408$ 字节。\n2.  就在此时，一个对应于最低优先级ISR，即 $\\text{ISR}_{4}$ 的中断到达。任务被抢占，$\\text{ISR}_{4}$ 的帧被压入栈。栈使用量变为 $S_{\\text{task}} + \\Delta S_{4}$。\n3.  当 $\\text{ISR}_{4}$ 正在执行时，一个对应于次高优先级ISR，即 $\\text{ISR}_{3}$ 的中断到达。$\\text{ISR}_{4}$ 被抢占，$\\text{ISR}_{3}$ 的帧被压入栈。栈使用量现在是 $S_{\\text{task}} + \\Delta S_{4} + \\Delta S_{3}$。\n4.  这个过程沿着优先级链继续。当 $\\text{ISR}_{3}$ 正在执行时，它被 $\\text{ISR}_{2}$ 抢占。栈使用量变为 $S_{\\text{task}} + \\Delta S_{4} + \\Delta S_{3} + \\Delta S_{2}$。\n5.  最后，当 $\\text{ISR}_{2}$ 正在执行时，它被最高优先级的ISR，即 $\\text{ISR}_{1}$ 抢占。$\\text{ISR}_{1}$ 的帧被压入栈。\n\n在这一瞬间，就在 $\\text{ISR}_{1}$ 开始执行时，栈中包含了原始任务和所有四个ISR的帧。这代表了最大可能的实时栈使用量，因为不可能有进一步的抢占（$\\text{ISR}_{1}$ 是最高优先级），并且所有可能抢占的实体都同时在栈上处于活动状态。\n\n最大实时栈使用量 $S_{\\text{max\\_live}}$ 是基础任务的使用量和所有ISR使用量的总和：\n$$S_{\\text{max\\_live}} = S_{\\text{task}} + \\Delta S_{1} + \\Delta S_{2} + \\Delta S_{3} + \\Delta S_{4}$$\n代入给定值：\n$$S_{\\text{max\\_live}} = 1408 + 224 + 176 + 144 + 128$$\nISR栈贡献的总和是：\n$$\\sum_{i=1}^{4} \\Delta S_{i} = 224 + 176 + 144 + 128 = 672 \\text{ 字节}$$\n因此，最大实时栈使用量是：\n$$S_{\\text{max\\_live}} = 1408 + 672 = 2080 \\text{ 字节}$$\n\n问题规定，必须将一个固定的 $S_{\\text{guard}} = 128$ 字节的未被触及的保护带加到这个最大实时使用量上，以确定所需的总分配量 $S_{\\text{alloc}}$。\n$$S_{\\text{alloc}} = S_{\\text{max\\_live}} + S_{\\text{guard}}$$\n代入计算出的值和给定值：\n$$S_{\\text{alloc}} = 2080 + 128 = 2208 \\text{ 字节}$$\n\n这是保证即使在嵌套中断抢占的最坏情况下，也不会发生栈溢出，同时遵守所需安全保护带的最小栈大小。", "answer": "$$\\boxed{2208}$$", "id": "3638740"}, {"introduction": "嵌入式系统经常需要与传感器或网络接口，这些设备会产生突发性数据。数据丢失通常是不可接受的，因此正确设置输入缓冲区的大小至关重要。本练习将探讨一个基本的排队问题，通过分析数据到达和处理的速率，向您展示如何确定所需的最小缓冲区容量，以在不发生溢出的情况下吸收突发数据。[@problem_id:3638790]", "problem": "一个嵌入式微控制器处理来自一个传感器的事件，该传感器在特定操作条件下会发出一阵有限的消息突发。在任何此类突发期间，会在一个长度为 $T_{s}$ 的连续时间窗口内均匀产生 $B$ 条消息，从突发开始到突发结束，每 $T_{s}/B$ 秒产生一条消息。消息在被一个周期性软件任务消耗之前，会先进入一个容量有限的先进先出（FIFO）缓冲区排队。\n\n消费者是一个在中央处理器（CPU）上调度的周期性任务，其周期为 $T_{p}$。消费者任务的每个作业都从队列头部移除一条消息，并在下一个周期开始前完成处理；没有作业会移除超过一条消息。在最坏情况下的相位关系中，消费者的第一次消息完成发生在突发开始后的 $T_{p}$ 时刻，之后每隔 $T_{p}$ 的倍数时刻完成一次处理。突发开始时队列初始为空，且没有其他消息来源。\n\n仅使用累积到达和累积完成的基本定义，且不假设任何未经证明的排队公式，确定能保证在突发期间不丢弃任何消息的最小缓冲区容量 $N$（以整数个消息表示）。使用以下具体参数：$B = 50$，$T_{s} = 220\\,\\mathrm{ms}$，以及 $T_{p} = 40\\,\\mathrm{ms}$。将最终的缓冲区容量表示为整数个消息。除了答案固有的整数性外，不需要进行舍入。", "solution": "问题要求计算为防止周期性消费者任务处理有限突发到达的消息时发生丢失所需的最小缓冲区容量 $N$。最小容量必须等于能同时驻留在队列中的最大消息数。这可以通过分析随时间变化的累积消息到达数和累积完成数来确定。\n\n设 $t=0$ 代表突发事件的开始。问题陈述指明了在一个时间窗口内消息是均匀产生的。我们对此进行确定性建模。\n\n首先，我们定义累积到达函数 $A(t)$，它计算到时间 $t$ 为止已到达队列的消息总数。总共有 $B$ 条消息。消息的到达间隔时间是恒定的，为 $T_a = T_s/B$。对于问题陈述“从突发开始每 $T_s/B$ 秒一条消息”，一个标准且一致的解释是第 $k$ 条消息在时间 $t_k = k \\cdot (T_s/B)$ 到达，其中 $k \\in \\{1, 2, \\dots, B\\}$。因此，第一条消息在 $t_1 = T_s/B$ 到达，最后一条消息在 $t_B = B \\cdot (T_s/B) = T_s$ 到达。累积到达函数 $A(t)$ 是一个阶跃函数，定义如下：\n$$\nA(t) =\n\\begin{cases}\n0  & \\text{if } t < T_s/B \\\\\n\\lfloor \\frac{t}{T_s/B} \\rfloor = \\lfloor \\frac{tB}{T_s} \\rfloor  & \\text{if } T_s/B \\le t \\le T_s \\\\\nB  & \\text{if } t > T_s\n\\end{cases}\n$$\n\n接着，我们定义累积完成函数 $C(t)$，它计算到时间 $t$ 为止已被任务消耗的消息总数。消费者任务是周期性的，周期为 $T_p$。问题指定了最坏情况下的相位关系，即第一次完成发生在时间 $T_p$，随后的完成发生在 $T_p$ 的每个倍数时刻。因此，第 $j$ 条消息在时间 $j \\cdot T_p$ 完成。累积完成函数 $C(t)$ 也是一个阶跃函数：\n$$\nC(t) = \\lfloor \\frac{t}{T_p} \\rfloor, \\quad \\text{for } t \\ge 0\n$$\n\n在任意时刻 $t$ 队列中的消息数，记为 $Q(t)$，是累积到达数与累积完成数之差：\n$$\nQ(t) = A(t) - C(t)\n$$\n所需的最小缓冲区容量 $N$ 是 $Q(t)$ 在所有时间 $t \\ge 0$ 上的最大值。\n$$\nN = \\max_{t \\ge 0} Q(t) = \\max_{t \\ge 0} \\left( A(t) - C(t) \\right)\n$$\n在时间 $t=T_s$ 之后，没有更多消息到达，因此对于 $t > T_s$ 有 $A(t) = B$。然而，消费者任务继续处理消息，所以 $C(t)$ 持续增加。因此，对于 $t > T_s$，$Q(t)$ 将是一个非增函数。因此，最大队列长度必定发生在某个时间 $t \\le T_s$（或者在 $T_s$ 之后、下一次服务完成之前的某个瞬间）。\n\n队列长度 $Q(t)$ 只可能在消息到达的离散时刻增加。在任意两个连续到达（比如 $t_k$ 和 $t_{k+1}$）之间，$A(t)$ 是常数，而 $C(t)$ 是非减的。这意味着 $Q(t) = A(t) - C(t)$ 在任何区间 $(t_k, t_{k+1})$ 内是非增的。因此，$Q(t)$ 的最大值必定发生在某个到达时间 $t_k$。我们可以分析每次到达后无穷小的瞬间 $t_k^+$ 的队列长度。\n\n设 $Q_k$ 为第 $k$ 次到达（时间为 $t_k = k \\frac{T_s}{B}$）后瞬间的队列长度。此时，正好有 $k$ 条消息到达，所以 $A(t_k^+) = k$。已完成的消息数为 $C(t_k) = \\lfloor \\frac{t_k}{T_p} \\rfloor$。\n队列长度为：\n$$\nQ_k = k - \\left\\lfloor \\frac{k T_s/B}{T_p} \\right\\rfloor = k - \\left\\lfloor k \\frac{T_s}{B T_p} \\right\\rfloor \\quad \\text{for } k \\in \\{1, 2, \\dots, B\\}\n$$\n为了找到最大队列长度，我们必须找出当 $k$ 从 $1$ 到 $B$ 时 $Q_k$ 的最大值。让我们分析 $Q_k$ 作为 $k$ 的函数的行为。考虑差值 $Q_{k+1} - Q_k$：\n$$\nQ_{k+1} - Q_k = \\left( (k+1) - \\left\\lfloor (k+1) \\frac{T_s}{B T_p} \\right\\rfloor \\right) - \\left( k - \\left\\lfloor k \\frac{T_s}{B T_p} \\right\\rfloor \\right)\n$$\n$$\nQ_{k+1} - Q_k = 1 - \\left( \\left\\lfloor k \\frac{T_s}{B T_p} + \\frac{T_s}{B T_p} \\right\\rfloor - \\left\\lfloor k \\frac{T_s}{B T_p} \\right\\rfloor \\right)\n$$\n设 $x = k \\frac{T_s}{B T_p}$ 且 $\\alpha = \\frac{T_s}{B T_p}$。该差值为 $1 - (\\lfloor x+\\alpha \\rfloor - \\lfloor x \\rfloor)$。根据底函数（floor function）的性质，我们知道 $0 \\le \\lfloor x+\\alpha \\rfloor - \\lfloor x \\rfloor \\le \\lceil \\alpha \\rceil$。\n让我们用给定的参数计算 $\\alpha$：$B = 50$，$T_s = 220\\,\\mathrm{ms}$，以及 $T_p = 40\\,\\mathrm{ms}$。\n$$\n\\alpha = \\frac{220}{50 \\times 40} = \\frac{220}{2000} = \\frac{11}{100} = 0.11\n$$\n由于 $0 < \\alpha < 1$，项 $\\lfloor x+\\alpha \\rfloor - \\lfloor x \\rfloor$ 的值可以是 $0$ 或 $1$。\n因此，$Q_{k+1} - Q_k$ 的值要么是 $1 - 0 = 1$，要么是 $1 - 1 = 0$。在所有情况下，都有 $Q_{k+1} \\ge Q_k$。\n这证明了 $Q_k$ 是一个关于 $k$ 的非减函数。因此，$Q_k$ 的最大值将在 $k$ 取最大值时出现，即 $k=B$。\n\n最大队列长度是 $Q_B$：\n$$\nN = Q_B = B - \\left\\lfloor B \\frac{T_s}{B T_p} \\right\\rfloor = B - \\left\\lfloor \\frac{T_s}{T_p} \\right\\rfloor\n$$\n现在，我们将给定的数值代入这个表达式：\n$B = 50$\n$T_s = 220\\,\\mathrm{ms}$\n$T_p = 40\\,\\mathrm{ms}$\n$$\nN = 50 - \\left\\lfloor \\frac{220}{40} \\right\\rfloor\n$$\n$$\nN = 50 - \\lfloor 5.5 \\rfloor\n$$\n$5.5$ 的底函数值为 $5$。\n$$\nN = 50 - 5 = 45\n$$\n保证不丢失消息所需的最小缓冲区容量是 $45$ 条消息。缓冲区必须能够容纳 $45$ 条消息。这个最大值在时间 $t=T_s=220\\,\\mathrm{ms}$ 时达到，此时所有 $50$ 条消息都已到达，而已完成的消息有 $\\lfloor 220/40 \\rfloor = 5$ 条。队列中的消息数为 $50-5=45$。此后，不再有新消息到达，队列长度只会减少。", "answer": "$$\n\\boxed{45}\n$$", "id": "3638790"}, {"introduction": "保证所有任务都能在截止日期前完成，是实时系统面临的核心挑战，尤其是当任务需要共享CPU等资源时。本练习将深入探讨响应时间分析（RTA），这是一种验证可调度性的强大技术。您将应用优先级天花板协议来计算阻塞时间，并确定一个任务是否能在其他任务的干扰下，于其截止日期前完成工作。[@problem_id:3638756]", "problem": "考虑一个采用固定优先级速率单调调度 (RMS) 的单核嵌入式控制器。对共享资源的访问由优先级天花板协议 (PCP) 控制。系统中有四个独立的周期性任务 $\\tau_1$、$\\tau_2$、$\\tau_3$ 和 $\\tau_4$。每个任务 $\\tau_i$ 都有一个周期 $T_i$、一个最坏情况执行时间 $C_i$ 和一个相对截止时间 $D_i$；假设对所有 $i$ 都有 $D_i = T_i$。所有任务在时间 $t = 0$ 同步释放，且没有释放抖动、上下文切换开销或缓存相关的抢占延迟。允许抢占。优先级越高对应周期越短。\n\n任务参数（周期单位为毫秒）：\n- $\\tau_1$：$T_1 = 10$， $C_1 = 1.5$。在其执行过程中，$\\tau_1$ 在资源 $R_C$ 上执行一个长度为 $1$ 的临界区。\n- $\\tau_2$：$T_2 = 15$， $C_2 = 2$。$\\tau_2$ 不访问共享资源。\n- $\\tau_3$：$T_3 = 25$， $C_3 = 4$。在其执行过程中，$\\tau_3$ 在资源 $R_B$ 上执行一个长度为 $2$ 的临界区。\n- $\\tau_4$：$T_4 = 50$， $C_4 = 15$。在其执行过程中，$\\tau_4$ 执行三个不相交的临界区：在资源 $R_A$ 上的长度为 $5$，在资源 $R_B$ 上的长度为 $1$，以及在资源 $R_C$ 上的长度为 $2$。\n\n在 RMS 下，优先级顺序为 $\\tau_1 \\succ \\tau_2 \\succ \\tau_3 \\succ \\tau_4$。在 PCP 下，每个资源的天花板是所有使用该资源的任务中的最高任务优先级。\n\n仅使用 RMS 干扰和优先级天花板协议阻塞属性的基本定义，确定 $\\tau_3$ 可能遇到的最大阻塞时间 $B_{\\max}$，并计算其最坏情况响应时间 $R_3$。然后验证 $R_3 \\le D_3$ 是否成立。以毫秒表示最终响应时间，并将最终答案四舍五入到四位有效数字。", "solution": "首先对问题进行验证，以确保其具有科学依据、定义良好、客观，并包含足够的信息以得出唯一解。\n\n**步骤 1：提取给定信息**\n- 调度算法：固定优先级速率单调调度 (RMS)。\n- 资源协议：优先级天花板协议 (PCP)。\n- 任务：四个独立的周期性任务 $\\tau_1, \\tau_2, \\tau_3, \\tau_4$。\n- 任务模型：$D_i = T_i$，在 $t=0$ 时同步释放，无抖动，无开销。\n- 任务参数（周期和执行时间单位为毫秒）：\n    - $\\tau_1$：$T_1 = 10$， $C_1 = 1.5$。使用资源 $R_C$，时长 $1$ 毫秒。\n    - $\\tau_2$：$T_2 = 15$， $C_2 = 2$。不使用资源。\n    - $\\tau_3$：$T_3 = 25$， $C_3 = 4$。使用资源 $R_B$，时长 $2$ 毫秒。\n    - $\\tau_4$：$T_4 = 50$， $C_4 = 15$。使用 $R_A$（时长 $5$ 毫秒）、$R_B$（时长 $1$ 毫秒）和 $R_C$（时长 $2$ 毫秒）。\n- 目标：求出 $\\tau_3$ 的最大阻塞时间 $B_3$，计算其最坏情况响应时间 $R_3$，并验证其可调度性（$R_3 \\le D_3$）。\n\n**步骤 2：使用提取的给定信息进行验证**\n该问题基于实时系统理论的既定原则（RMS、PCP、响应时间分析）。参数一致，问题定义良好。总处理器利用率为 $U = \\frac{1.5}{10} + \\frac{2}{15} + \\frac{4}{25} + \\frac{15}{50} = 0.15 + 0.133\\dots + 0.16 + 0.30 = 0.743\\dots \\le 1$，这是单核系统可调度的必要条件。问题有效。\n\n**步骤 3：求解**\n\n求解过程首先确定共享资源的优先级天花板，然后计算任务 $\\tau_3$ 的最大阻塞时间，最后使用响应时间分析法求出 $R_3$。\n\n**优先级分配和资源天花板**\n在速率单调调度 (RMS) 下，任务优先级与其周期成反比。\n-   $T_1=10$, $T_2=15$, $T_3=25$, $T_4=50$。\n-   由于 $T_1 < T_2 < T_3 < T_4$，优先级排序为 $P(\\tau_1) > P(\\tau_2) > P(\\tau_3) > P(\\tau_4)$。设 $hp(i)$ 为优先级高于 $\\tau_i$ 的任务集合。因此，$hp(3) = \\{\\tau_1, \\tau_2\\}$。\n\n优先级天花板协议 (PCP) 为每个共享资源分配一个优先级天花板，其值等于可能锁定该资源的任何任务中的最高优先级。\n- 资源 $R_A$ 被以下任务使用：$\\{\\tau_4\\}$。天花板为 $C(R_A) = P(\\tau_4)$。\n- 资源 $R_B$ 被以下任务使用：$\\{\\tau_3, \\tau_4\\}$。天花板为 $C(R_B) = \\max\\{P(\\tau_3), P(\\tau_4)\\} = P(\\tau_3)$。\n- 资源 $R_C$ 被以下任务使用：$\\{\\tau_1, \\tau_4\\}$。天花板为 $C(R_C) = \\max\\{P(\\tau_1), P(\\tau_4)\\} = P(\\tau_1)$。\n\n**$\\tau_3$ 的最大阻塞时间 ($B_3$)**\n根据优先级天花板协议，一个任务 $\\tau_i$ 仅当一个较低优先级的任务 $\\tau_j$ 当前持有一个资源 $R_k$，且该资源的优先级天花板 $C(R_k)$ 大于或等于 $\\tau_i$ 的优先级时，$\\tau_i$ 才可能被 $\\tau_j$ 阻塞。这种阻塞的最大持续时间被限制为某个较低优先级任务的单个临界区的长度。\n\n我们需要找出任务 $\\tau_3$ 可能经历的最大阻塞时间 $B_3$。唯一优先级低于 $\\tau_3$ 的任务是 $\\tau_4$。我们检查 $\\tau_4$ 使用的资源，看它的哪个临界区会导致对 $\\tau_3$ 的阻塞。\n-   $\\tau_4$ 使用 $R_A$：天花板 $C(R_A) = P(\\tau_4)$。由于 $P(\\tau_4) < P(\\tau_3)$，这个临界区不能阻塞 $\\tau_3$。\n-   $\\tau_4$ 使用 $R_B$：天花板 $C(R_B) = P(\\tau_3)$。由于 $P(\\tau_3) \\ge P(\\tau_3)$，这个临界区可以阻塞 $\\tau_3$。$\\tau_4$ 在这个临界区上的执行时间是 $1$ 毫秒。\n-   $\\tau_4$ 使用 $R_C$：天花板 $C(R_C) = P(\\tau_1)$。由于 $P(\\tau_1) > P(\\tau_3)$，这个临界区可以阻塞 $\\tau_3$。$\\tau_4$ 在这个临界区上的执行时间是 $2$ 毫秒。\n\n最大阻塞时间 $B_3$ 是由较低优先级任务造成的所有可能阻塞临界区中的最大时长。\n$$ B_3 = \\max\\{1, 2\\} = 2 \\text{ ms} $$\n这是 $\\tau_3$ 所承受的 $B_{\\max}$ 的值。\n\n**$\\tau_3$ 的最坏情况响应时间 ($R_3$)**\n任务 $\\tau_i$ 的最坏情况响应时间由以下递归方程给出，该方程考虑了其自身的执行时间 $C_i$、来自较低优先级任务的阻塞 $B_i$ 以及来自较高优先级任务的干扰 $\\sum_{j \\in hp(i)} \\left\\lceil \\frac{R_i}{T_j} \\right\\rceil C_j$。\n$$ R_i^{(k+1)} = C_i + B_i + \\sum_{j \\in hp(i)} \\left\\lceil \\frac{R_i^{(k)}}{T_j} \\right\\rceil C_j $$\n对于任务 $\\tau_3$，方程为：\n$$ R_3 = C_3 + B_3 + \\left\\lceil \\frac{R_3}{T_1} \\right\\rceil C_1 + \\left\\lceil \\frac{R_3}{T_2} \\right\\rceil C_2 $$\n代入给定值：\n$$ R_3 = 4 + 2 + \\left\\lceil \\frac{R_3}{10} \\right\\rceil (1.5) + \\left\\lceil \\frac{R_3}{15} \\right\\rceil (2) $$\n$$ R_3 = 6 + 1.5 \\left\\lceil \\frac{R_3}{10} \\right\\rceil + 2 \\left\\lceil \\frac{R_3}{15} \\right\\rceil $$\n我们迭代求解这个方程。一个合适的初始猜测是 $R_3^{(0)} = C_3 + B_3 = 4 + 2 = 6$。\n-   迭代 1:\n    $$ R_3^{(1)} = 6 + 1.5 \\left\\lceil \\frac{6}{10} \\right\\rceil + 2 \\left\\lceil \\frac{6}{15} \\right\\rceil = 6 + 1.5(1) + 2(1) = 6 + 1.5 + 2 = 9.5 $$\n-   迭代 2:\n    $$ R_3^{(2)} = 6 + 1.5 \\left\\lceil \\frac{9.5}{10} \\right\\rceil + 2 \\left\\lceil \\frac{9.5}{15} \\right\\rceil = 6 + 1.5(1) + 2(1) = 6 + 1.5 + 2 = 9.5 $$\n由于 $R_3^{(2)} = R_3^{(1)}$，迭代已经收敛。$\\tau_3$ 的最坏情况响应时间是 $R_3 = 9.5$ 毫秒。\n\n**可调度性验证**\n如果一个任务的最坏情况响应时间小于或等于其相对截止时间，则该任务是可调度的。对于 $\\tau_3$，我们必须检查是否 $R_3 \\le D_3$。\n-   $R_3 = 9.5$ 毫秒。\n-   $D_3 = T_3 = 25$ 毫秒。\n条件 $9.5 \\le 25$ 满足，因此任务 $\\tau_3$ 是可调度的。\n\n问题要求最终响应时间四舍五入到四位有效数字。\n$$ R_3 = 9.500 \\text{ ms} $$", "answer": "$$\n\\boxed{9.500}\n$$", "id": "3638756"}]}