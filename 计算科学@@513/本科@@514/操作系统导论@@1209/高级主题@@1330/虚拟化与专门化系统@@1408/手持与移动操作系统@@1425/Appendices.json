{"hands_on_practices": [{"introduction": "功耗管理是移动操作系统设计的核心。本练习将探讨操作系统如何通过精细的调度决策，在满足数据吞吐量和低延迟等性能需求与最大限度降低能耗这一严格要求之间取得平衡，这在低功耗蓝牙（BLE）等技术中是一个普遍存在的挑战。通过这个练习 [@problem_id:3646045]，你将能够亲手量化分析这些在现实世界中至关重要的权衡关系。", "problem": "一款可穿戴传感器使用低功耗蓝牙（BLE）来维持与智能手机的连接。该可穿戴设备的操作系统每隔一个长度为 $\\tau$ 的连接间隔调度一次连接事件，在此期间它会发送恰好一个包含应用数据的通知，然后返回深度睡眠状态，直到下一次事件。假设以下具有科学依据的事实和参数：\n\n- BLE连接事件以周期 $\\tau$ 重复，最坏情况下的单向应用层延迟等于下一次事件的等待时间，即 $\\tau$（相对于射频时序，忽略主机和控制器的处理延迟）。\n- 周期性调度下的平均功率等于一个周期内消耗的总能量除以该周期时长。\n- 每个连接事件有一个固定的活动阶段能量成本 $E_{\\mathrm{act}}$ 和持续时间 $t_{\\mathrm{act}}$，它们不依赖于 $\\tau$。在间隔的其余时间里，设备以功率 $P_{\\mathrm{slp}}$ 睡眠。\n- BLE 要求连接间隔 $\\tau$ 是 $1.25\\ \\mathrm{ms}$ 的整数倍，并且位于 $[7.5\\ \\mathrm{ms}, 4\\ \\mathrm{s}]$ 的区间内。\n\n该可穿戴设备必须在每个连接事件发送一个通知，以 $R$ 的持续应用数据速率流式传输传感器数据。每个通知携带一个 $M$ 字节的应用负载。为了满足数据速率要求，每秒实现的吞吐量必须至少为 $R$。为了满足交互性约束，最坏情况下的单向延迟不得超过 $L_0$。\n\n给定：\n- $E_{\\mathrm{act}} = 60\\ \\mathrm{\\mu J}$，$t_{\\mathrm{act}} = 2.5\\ \\mathrm{ms}$，$P_{\\mathrm{slp}} = 9\\ \\mathrm{\\mu W}$，\n- $M = 27\\ \\mathrm{bytes}$，$R = 750\\ \\mathrm{bytes/s}$，\n- $L_0 = 34\\ \\mathrm{ms}$，\n\n使用第一性原理（周期平均功率的定义、BLE 时序和基本吞吐量）来确定连接间隔 $\\tau^{\\star}$ 的值，该值在满足延迟约束、数据速率可行性约束和量化约束的同时，最小化平均功耗。用毫秒表示最终的 $\\tau^{\\star}$。在最终的方框答案中不要包含任何单位。", "solution": "我们从周期性调度下平均功率的定义开始。如果一个系统重复一个持续时间为 $\\tau$ 的周期，并在该周期内消耗总能量 $E_{\\mathrm{tot}}(\\tau)$，则时间平均功率为\n$$\nP(\\tau) = \\frac{E_{\\mathrm{tot}}(\\tau)}{\\tau}.\n$$\n对于连接BLE的可穿戴设备，在每个长度为 $\\tau$ 的间隔中，有一个固定持续时间 $t_{\\mathrm{act}}$ 和固定能量成本 $E_{\\mathrm{act}}$ 的活动射频阶段，它们与 $\\tau$ 无关；此外还有一个持续时间为 $\\tau - t_{\\mathrm{act}}$、功率为 $P_{\\mathrm{slp}}$ 的睡眠阶段。因此，每个间隔的总能量为\n$$\nE_{\\mathrm{tot}}(\\tau) = E_{\\mathrm{act}} + P_{\\mathrm{slp}}\\big(\\tau - t_{\\mathrm{act}}\\big).\n$$\n代入平均功率表达式可得\n$$\nP(\\tau) = \\frac{E_{\\mathrm{act}} + P_{\\mathrm{slp}}(\\tau - t_{\\mathrm{act}})}{\\tau}\n= P_{\\mathrm{slp}} + \\frac{E_{\\mathrm{act}} - P_{\\mathrm{slp}}\\,t_{\\mathrm{act}}}{\\tau}.\n$$\n因为 $E_{\\mathrm{act}} > 0$、$P_{\\mathrm{slp}} > 0$ 且 $t_{\\mathrm{act}} > 0$，在实际系统中，分子 $E_{\\mathrm{act}} - P_{\\mathrm{slp}}\\,t_{\\mathrm{act}}$ 是非负的。在给定参数下，$E_{\\mathrm{act}} - P_{\\mathrm{slp}}\\,t_{\\mathrm{act}} = 60\\times 10^{-6}\\ \\mathrm{J} - 9\\times 10^{-6}\\ \\mathrm{W}\\cdot 2.5\\times 10^{-3}\\ \\mathrm{s} = 60\\times 10^{-6}\\ \\mathrm{J} - 22.5\\times 10^{-9}\\ \\mathrm{J} > 0$。因此\n$$\n\\frac{dP}{d\\tau} = -\\frac{E_{\\mathrm{act}} - P_{\\mathrm{slp}}\\,t_{\\mathrm{act}}}{\\tau^{2}} < 0 \\quad \\text{for } \\tau > 0,\n$$\n这表明 $P(\\tau)$ 在可行域上是关于 $\\tau$ 严格递减的。因此，为了最小化平均功率，我们应该选择约束允许的尽可能大的 $\\tau$。\n\n我们现在将约束形式化：\n\n1. 延迟约束。最坏情况下的单向延迟等于到下一次连接事件的等待时间，即 $L = \\tau$。因此，约束 $L \\le L_0$ 意味着\n$$\n\\tau \\le L_0.\n$$\n\n2. 吞吐量约束。每个事件一个通知，每 $\\tau$ 秒携带 $M$ 字节，因此实现的应用吞吐量为\n$$\n\\frac{M}{\\tau}\\ \\mathrm{bytes/s}.\n$$\n为了满足所需速率 $R$，我们必须有\n$$\n\\frac{M}{\\tau} \\ge R \\quad \\Longleftrightarrow \\quad \\tau \\le \\frac{M}{R}.\n$$\n\n3. BLE 量化和范围。BLE 连接间隔必须满足\n$$\n\\tau \\in \\{k \\cdot 1.25\\ \\mathrm{ms} \\mid k \\in \\mathbb{Z},\\ 7.5\\ \\mathrm{ms} \\le \\tau \\le 4\\ \\mathrm{s}\\}.\n$$\n\n因为 $P(\\tau)$ 随 $\\tau$ 递减，最优的 $\\tau^{\\star}$ 是满足项目1和2中两个上界，且为BLE允许的最大值。因此，在量化之前，\n$$\n\\tau_{\\max} = \\min\\!\\left(L_0,\\ \\frac{M}{R}\\right).\n$$\n然后，我们将 $\\tau_{\\max}$ 向下量化为不大于它的、最大的、在 $[7.5\\ \\mathrm{ms}, 4\\ \\mathrm{s}]$ 范围内的 $1.25\\ \\mathrm{ms}$ 的允许倍数。\n\n代入给定值。计算吞吐量所隐含的上限：\n$$\n\\frac{M}{R} = \\frac{27\\ \\mathrm{bytes}}{750\\ \\mathrm{bytes/s}} = 0.036\\ \\mathrm{s} = 36\\ \\mathrm{ms}.\n$$\n延迟所隐含的上限是\n$$\nL_0 = 34\\ \\mathrm{ms}.\n$$\n因此，\n$$\n\\tau_{\\max} = \\min\\!\\big(34\\ \\mathrm{ms},\\ 36\\ \\mathrm{ms}\\big) = 34\\ \\mathrm{ms}.\n$$\n将 $34\\ \\mathrm{ms}$ 向下量化为不大于它的、最大的 $1.25\\ \\mathrm{ms}$ 的允许倍数。设量化步长为 $\\Delta = 1.25\\ \\mathrm{ms}$。计算\n$$\nk = \\left\\lfloor \\frac{34\\ \\mathrm{ms}}{1.25\\ \\mathrm{ms}} \\right\\rfloor = \\left\\lfloor 27.2 \\right\\rfloor = 27,\n$$\n因此，不超过 $34\\ \\mathrm{ms}$ 的最大允许倍数是\n$$\n\\tau^{\\star} = k \\Delta = 27 \\times 1.25\\ \\mathrm{ms} = 33.75\\ \\mathrm{ms}.\n$$\n该值位于 BLE 允许的范围 $[7.5\\ \\mathrm{ms}, 4\\ \\mathrm{s}]$ 内，并同时满足延迟和吞吐量约束。由于 $P(\\tau)$ 是关于 $\\tau$ 严格递减的，这个 $\\tau^{\\star}$ 在满足约束条件下最小化了平均功率。", "answer": "$$\\boxed{33.75}$$", "id": "3646045"}, {"introduction": "流畅响应的用户界面是优秀移动操作系统的标志。本练习模拟了一个类 Android 系统中，从内核级通知到最终屏幕更新的复杂事件序列，以分析故障传播过程。通过精确计算故障的可见延迟和对用户界面的影响 [@problem_id:3646046]，你将具体地理解事件驱动架构、主线程排队以及显示同步等核心概念，这些都是保证用户体验的关键。", "problem": "您正在分析一个类Android手持操作系统中的故障传播，该系统使用Binder进程间通信（IPC）。在此系统中，客户端注册Binder死亡接收者，以便在远程服务进程死亡时收到通知。当远程服务进程被终止时，内核驱动程序会将其Binder节点标记为死亡，并向客户端进程中每个已注册的接收者发送一条死亡通知。客户端应用程序在Binder线程上处理此通知，该线程会向其主线程发送一条消息。主线程使用事件循环（Looper）按顺序处理消息，并在离散的显示刷新边界（垂直同步）以固定的刷新率渲染视觉变化。\n\n考虑在远程服务进程于时间 $t=0$ 被终止时，单个客户端应用程序具有以下特征：\n- 内核的Binder驱动程序在 $t_{d} = 0.2$ 毫秒内将死亡通知投递给客户端进程。\n- 客户端中的一个Binder线程需要 $t_{p} = 0.3$ 毫秒来运行死亡接收者回调并向主线程的消息队列发送一条消息。假设有足够的Binder线程，因此该客户端中的所有死亡接收者基本上都在时间 $t=t_{d}+t_{p}$ 同时发布消息。\n- 客户端应用程序的主线程有2条积压消息，分别需要2毫秒和1毫秒来处理，从 $t=0$ 开始连续处理，总计需要 $t_{q}=3$ 毫秒的工作时间。\n- 客户端有 $m=3$ 个用户体验（UX）组件，它们独立注册为Binder死亡接收者。每个组件都会发布一条主线程消息，该消息在处理时会更新组件的状态以反映该故障。每次此类更新都需要确定性的 $t_{u}=7$ 毫秒的主线程计算时间。主线程在处理完现有积压工作后，按任意顺序依次处理这三条更新消息。\n- 显示器以 $60\\ \\text{Hz}$ 的恒定速率刷新，因此刷新间隔为 $T_{v}=\\frac{50}{3}$ 毫秒。从 $t=0$ 到下一个刷新边界的时间是 $t_{\\text{next}}=\\frac{10}{3}$ 毫秒。主线程完成的UI变更在变更完成后的第一个显示刷新边界处才变得可见。\n\n将故障传播时间 $T_{f}$ 定义为从 $t=0$ 到应用程序用户界面中出现第一个可见的故障指示所经过的时间。将对UX组件的影响 $I$ 定义为，在每个组件的更新变得可见之前，所有 $m$ 个组件错过的显示帧总数，其中，对于一个组件，在 $t=0$ 之后、组件更新变得可见之前，每经过一个刷新间隔边界，其“错过帧”计数就加一。\n\n在上述假设下，计算 $T_{f}$ 和 $I$。将 $T_{f}$ 以毫秒表示，$I$ 以无量纲计数表示。无需四舍五入；请提供精确值。将您的最终答案以一个二元行向量 $\\left(T_{f}, I\\right)$ 的形式返回。[@problem_id:48]", "solution": "该问题提法得当，其科学基础在于操作系统和事件驱动编程的原理。所有必要的参数都已提供，定义明确无歧义。我们可以进行分步计算。\n\n首先，我们建立导致应用程序主线程处理故障通知的事件时间线。远程服务在时间 $t=0$ 被终止。\n\n1.  **消息投递到主线程的时间：**\n    内核的Binder驱动程序在 $t_{d} = 0.2$ 毫秒内将死亡通知投递给客户端进程。然后，客户端中的一个Binder线程需要 $t_{p} = 0.3$ 毫秒来执行其回调并向主线程的消息队列发布一条消息。因此，来自 $m=3$ 个UX组件的死亡通知消息都在时间 $t_{\\text{post}}$ 于主线程入队：\n    $$t_{\\text{post}} = t_{d} + t_{p} = 0.2 + 0.3 = 0.5 \\text{ ms}$$\n\n2.  **主线程工作时间线：**\n    在 $t=0$ 时，主线程有积压工作，需要 $t_{q}=3$ 毫秒才能完成。由于它从 $t=0$ 开始连续处理这项工作，积压工作将在 $t=3$ 毫秒时被清除。在 $t_{\\text{post}}=0.5$ 毫秒时发布的消息必须在队列中等待，直到主线程空闲。\n    主线程将在时间 $t_{\\text{start,1}}$ 开始处理三条死亡通知消息中的第一条：\n    $$t_{\\text{start,1}} = t_{q} = 3 \\text{ ms}$$\n    这些消息中的每一条都需要 $t_{u}=7$ 毫秒的计算时间。问题陈述它们按任意顺序依次处理。对于第一次故障传播，顺序无关紧要。第一条消息的处理将在 $t_{\\text{complete,1}}$ 完成：\n    $$t_{\\text{complete,1}} = t_{\\text{start,1}} + t_{u} = 3 + 7 = 10 \\text{ ms}$$\n\n3.  **显示刷新时间线：**\n    显示器以 $60\\ \\text{Hz}$ 的恒定速率刷新。刷新间隔 $T_{v}$ 为：\n    $$T_{v} = \\frac{1 \\text{ s}}{60} \\times \\frac{1000 \\text{ ms}}{1 \\text{ s}} = \\frac{1000}{60} \\text{ ms} = \\frac{50}{3} \\text{ ms}$$\n    问题陈述，从 $t=0$ 到下一个刷新边界的时间是 $t_{\\text{next}}=\\frac{10}{3}$ 毫秒。随后的刷新边界以 $T_{v}$ 的间隔发生。在 $t=0$ 之后的第 $k$ 个刷新边界的时间（对于 $k=0, 1, 2, \\dots$）由 $t_{\\text{refresh},k}$ 给出：\n    $$t_{\\text{refresh},k} = t_{\\text{next}} + k \\cdot T_{v} = \\frac{10}{3} + k \\frac{50}{3} = \\frac{10 + 50k}{3} \\text{ ms}$$\n    最初的几个刷新边界是：\n    $t_{\\text{refresh},0} = \\frac{10}{3} \\approx 3.33$ ms\n    $t_{\\text{refresh},1} = \\frac{10 + 50}{3} = \\frac{60}{3} = 20$ ms\n    $t_{\\text{refresh},2} = \\frac{10 + 100}{3} = \\frac{110}{3} \\approx 36.67$ ms\n    $t_{\\text{refresh},3} = \\frac{10 + 150}{3} = \\frac{160}{3} \\approx 53.33$ ms\n\n4.  **计算故障传播时间 $T_{f}$：**\n    $T_{f}$ 是直到第一个可见的故障指示出现的时间。UI变更在主线程完成变更后的第一个显示刷新边界处变得可见。第一个UI变更在 $t_{\\text{complete,1}} = 10$ 毫秒时完成。我们必须找到满足 $t_{\\text{refresh},k} > 10$ 毫秒的最小 $t_{\\text{refresh},k}$。\n    $t_{\\text{refresh},0} = \\frac{10}{3} < 10$ ms。\n    $t_{\\text{refresh},1} = 20 > 10$ ms。\n    因此，第一次更新在 $t=20$ 毫秒时变得可见。\n    $$T_{f} = 20 \\text{ ms}$$\n\n5.  **计算对UX组件的影响 $I$：**\n    为了计算 $I$，我们需要每个（$m=3$个）组件的可见时间。我们首先找到所有三个更新的完成时间。由于它们是按顺序处理的，并且每个都需要 $t_{u}=7$ 毫秒，它们的完成时间是：\n    $$t_{\\text{complete,1}} = 3 + 7 = 10 \\text{ ms}$$\n    $$t_{\\text{complete,2}} = t_{\\text{complete,1}} + t_{u} = 10 + 7 = 17 \\text{ ms}$$\n    $$t_{\\text{complete,3}} = t_{\\text{complete,2}} + t_{u} = 17 + 7 = 24 \\text{ ms}$$\n    注意，这组完成时间与处理顺序无关。\n\n    接下来，我们找到每个组件更新的可见时间，即其完成时间之后的第一个刷新边界。\n    - 组件1（在 $10$ 毫秒时完成）：在 $t_{\\text{vis,1}} = t_{\\text{refresh},1} = 20$ 毫秒时可见。\n    - 组件2（在 $17$ 毫秒时完成）：在 $t_{\\text{vis,2}} = t_{\\text{refresh},1} = 20$ 毫秒时可见（因为 $17 < 20$）。\n    - 组件3（在 $24$ 毫秒时完成）：在 $t_{\\text{vis,3}} = t_{\\text{refresh},2} = \\frac{110}{3}$ 毫秒时可见（因为 $20 < 24 < 110/3$）。\n\n    影响 $I$ 是所有组件错过的帧的总数。错过的帧是指在更新变得可见之前经过的刷新边界。\n    组件 $i$ 错过的帧数 $I_i$ 是满足 $t_{\\text{refresh},k} < t_{\\text{vis},i}$ 的边界 $t_{\\text{refresh},k}$ 的计数。\n\n    - 对于组件1：$t_{\\text{vis,1}} = 20$ 毫秒。在 $20$ 毫秒之前的边界是 $\\{t_{\\text{refresh},0} = 10/3 \\text{ ms}\\}$。所以，$I_1 = 1$。\n    - 对于组件2：$t_{\\text{vis,2}} = 20$ 毫秒。在 $20$ 毫秒之前的边界也是 $\\{t_{\\text{refresh},0} = 10/3 \\text{ ms}\\}$。所以，$I_2 = 1$。\n    - 对于组件3：$t_{\\text{vis,3}} = \\frac{110}{3}$ 毫秒。在 $\\frac{110}{3}$ 毫秒之前的边界是 $\\{t_{\\text{refresh},0} = 10/3 \\text{ ms}, t_{\\text{refresh},1} = 20 \\text{ ms}\\}$。所以，$I_3 = 2$。\n\n    总影响 $I$ 是各个影响之和：\n    $$I = I_1 + I_2 + I_3 = 1 + 1 + 2 = 4$$\n\n计算出的值为 $T_{f} = 20$ 毫秒和 $I=4$。\n要求的输出是一个二元行向量 $(T_f, I)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n20 & 4\n\\end{pmatrix}\n}\n$$", "id": "3646046"}, {"introduction": "移动应用需要频繁保存状态，但系统崩溃可能导致数据损坏，甚至引发持续的启动崩溃循环。本练习 [@problem_id:3646008] 让你像系统设计师一样思考，评估如预写日志（Write-Ahead Logging, WAL）等不同的事务机制，以保证数据更新的原子性。这突显了在易于发生故障的硬件上构建可靠应用程序时，采用健壮设计模式的重要性。", "problem": "一个智能手机应用程序将用户配置持久化存储在基于闪存的非易失性存储器 (NVM) 上的 SharedPreferences (SP) 文件中。SP 内容是一个小型的文本表示，最大大小为 $S_{\\max}$。该应用程序有时会快速连续执行多次偏好设置更新，然后崩溃。重启后，它会立即读取 SP 文件以重建状态，如果 SP 内容已损坏，可能会再次崩溃，从而导致崩溃循环。假设操作系统的故障模型是：崩溃可能在任何时候发生，不完整的写入可能导致撕裂页，文件系统重命名操作是原子的，以及对文件描述符的成功显式刷新会使数据持久化。\n\n您必须为 SP 设计一种事务性更新机制，以确保全有或全无的原子性，并在崩溃后恢复期间保证有界的回滚时间 $T_b$。原子性要求，如果发生崩溃，系统要么呈现更新前的状态，要么呈现整个更新后的状态，绝不能是两者的混合。有界回滚时间要求最坏情况下的恢复时间受到一个系统参数函数的上限约束，该函数在正常操作期间不会无限制增长。\n\n考虑以下参数和约束，这些是手持设备的典型值：\n\n- 最大 SP 大小 $S_{\\max} = 256\\,\\mathrm{KiB}$。\n- 允许使用预写式日志 (WAL)，最多有 $N_{\\max}$ 个待处理事务，其中 $N_{\\max} = 64$。\n- 每个日志条目的负载大小为 $e = 2\\,\\mathrm{KiB}$，并带有用于检测损坏的逐条目循环冗余校验 (CRC)。\n- 顺序读取吞吐量 $R_r = 200\\,\\mathrm{MiB/s}$，顺序写入吞吐量 $R_w = 100\\,\\mathrm{MiB/s}$。\n- 每次显式刷新的延迟 $f = 3\\,\\mathrm{ms}$。\n- 每个条目的 CRC 计算时间 $t_{\\mathrm{crc}} = 0.05\\,\\mathrm{ms}$。\n- 恢复期间的输入/输出 (I/O) 是顺序的（扫描日志和写入重建的 SP 文件），并且恢复过程执行所需的最少次数的显式刷新，以确保重建后的一致性 SP 变得持久化。\n\n哪个选项正确地指定了一种事务性设计，该设计能够防止由损坏的 SP 引起的崩溃循环，在所述故障模型下保证原子性，并使用给定参数得出恢复过程中最坏情况回滚时间 $T_b$ 的正确上限？\n\nA. 采用仅追加的 WAL，每个条目包含头部、负载和 CRC。对于每个事务：追加条目，显式刷新 WAL，然后通过重命名一个小的元数据文件来原子性地记录一个提交标记。恢复时：扫描 WAL 直到最后一个有效的 CRC；应用最多 $N_{\\max}$ 个条目来重建一个新的 SP 文件；显式刷新重建的 SP 并执行最小的元数据刷新以使其持久化。此设计保证了原子性，因为提交标记仅在持久化 WAL 追加之后出现，并通过 CRC 拒绝损坏的条目并回退到最后一个完整的状态来防止崩溃循环。最坏情况下的上限为\n$$\nT_b \\le \\underbrace{\\frac{N_{\\max} e}{R_r}}_{\\text{扫描日志}} + \\underbrace{N_{\\max} t_{\\mathrm{crc}}}_{\\text{CRC}} + \\underbrace{\\frac{S_{\\max}}{R_w}}_{\\text{写入SP}} + \\underbrace{2 f}_{\\text{刷新}} \\,,\n$$\n使用给定值计算得出 $T_b \\le 12.325\\,\\mathrm{ms}$。\n\nB. 对 SP 文件进行原地更新，并通过定期的显式刷新依赖文件系统的日志功能来保证一致性。恢复时：直接读取 SP 文件并解析。原子性由日志功能保证，回滚时间可忽略不计，约为 $T_b \\approx 0\\,\\mathrm{ms}$，因为不需要额外的处理。\n\nC. 采用仅追加的 WAL，每次追加后进行 CRC 和显式刷新，但没有后续的重建写入。恢复时：扫描 WAL 并接受最后一个有效 CRC 作为已提交状态，而不写入新的 SP 文件。最坏情况下的上限为\n$$\nT_b \\approx \\frac{N_{\\max} e}{R_r} + N_{\\max} t_{\\mathrm{crc}} = 3.825\\,\\mathrm{ms} \\,,\n$$\n因为只需要扫描和 CRC 计算。\n\nD. 采用双缓冲全文件写入，包含两个 SP 版本：写入一个完整的新 SP 文件，然后原子性地将其重命名以覆盖旧文件，期间不显式刷新新文件或目录元数据。恢复时：根据修改时间选择最新的 SP 并读取它。最坏情况下的上限为\n$$\nT_b \\le \\frac{S_{\\max}}{R_r} = 1.25\\,\\mathrm{ms} \\,,\n$$\n因为只需要读取一个文件，无需重建。", "solution": "我们将逐一分析每个选项，以确定其在原子性、防止崩溃循环和有界回滚时间方面的有效性。\n\n**选项 B: 不正确。**\n此方法依赖于文件系统的日志功能进行原地更新。文件系统日志（如 ext4 中的 journaling）主要保证文件系统元数据的一致性，但通常不为应用层数据写入提供完整的原子性保证。在写入一个大文件（如 256 KiB 的 SP 文件）的过程中发生崩溃，可能会导致“撕裂写入”（torn write），使得文件内容一部分是旧数据，一部分是新数据，从而文件损坏。应用程序在重启后读取这个损坏的文件，很可能导致解析失败和崩溃，形成崩溃循环。因此，该方法不能保证原子性。\n\n**选项 D: 不正确。**\n此方法采用双缓冲和原子重命名，这在理论上是实现原子更新的有效策略。然而，描述中明确指出“期间不显式刷新新文件或目录元数据”。这是一个致命缺陷。原子重命名操作依赖于底层文件系统目录条目的持久化。如果在写入新文件副本之后、重命名之前或期间发生崩溃，并且文件数据或目录更新尚未通过 `fsync` 等操作刷新到物理存储，那么系统重启后可能会看到不一致的状态（例如，新文件不完整，或目录未更新）。没有显式刷新，就无法在所述的故障模型下保证原子性。\n\n**选项 C: 不正确。**\n此方法采用仅追加的 WAL，但在恢复时只扫描日志以确定最新状态，而不将该状态合并回主 SP 文件。这意味着每次应用程序启动时，都必须重新读取和处理整个 WAL 来重建内存中的当前配置。由于 WAL 是仅追加的，其大小会随着时间的推移而增长（直到达到 $N_{\\max}$ 的限制），这会导致应用程序的启动时间不断增加。这违反了“有界回滚时间”($T_b$)的要求，因为该要求不仅意味着恢复过程本身是快速的，而且恢复后的系统性能（包括后续启动）也应该是可预测的，而不是受日志历史长度的拖累。\n\n**选项 A: 正确。**\n该选项描述了预写式日志（Write-Ahead Logging, WAL）的经典且健壮的实现，它满足所有要求：\n1.  **原子性保证**: 事务首先被写入日志文件并被持久化（通过显式刷新）。只有在日志条目安全存储后，才会更新一个提交标记。这种“先写日志”的原则确保了即使在任何步骤发生崩溃，系统也能恢复到一个一致的状态：要么是更新前的状态（如果崩溃发生在日志持久化之前），要么是更新后的状态（通过重播已提交的日志）。\n2.  **防止崩溃循环**: 恢复过程通过 CRC 校验来扫描日志，可以识别并忽略任何因不完整写入而损坏的条目。它只重播有效的、完整的日志条目，以此为基础重建一个全新的、保证内部一致的 SP 文件。然后，这个新文件通过原子操作（如重命名）成为当前版本。这个过程确保了应用程序永远不会读取到一个损坏或不一致的 SP 文件，从而防止了崩溃循环。\n3.  **有界回滚时间**: 最坏情况下的恢复（回滚）时间是有限且可计算的。它包括了扫描日志（最多 $N_{\\max}$ 个条目）、验证每个条目的 CRC、基于日志写入一个完整的新 SP 文件（最大 $S_{\\max}$），以及确保新文件和元数据持久化所需的最少刷新次数（这里建模为两次刷新：一次用于数据，一次用于元数据）。公式准确地反映了这些步骤的成本：\n    $$\n    T_b \\le \\underbrace{\\frac{N_{\\max} e}{R_r}}_{\\text{扫描日志}} + \\underbrace{N_{\\max} t_{\\mathrm{crc}}}_{\\text{CRC校验}} + \\underbrace{\\frac{S_{\\max}}{R_w}}_{\\text{写入SP}} + \\underbrace{2 f}_{\\text{两次刷新}}\n    $$\n    代入数值进行计算：\n    $T_b \\le \\frac{64 \\times 2\\,\\mathrm{KiB}}{200\\,\\mathrm{MiB/s}} + 64 \\times 0.05\\,\\mathrm{ms} + \\frac{256\\,\\mathrm{KiB}}{100\\,\\mathrm{MiB/s}} + 2 \\times 3\\,\\mathrm{ms}$\n    $T_b \\le \\frac{128\\,\\mathrm{KiB}}{200 \\times 1024\\,\\mathrm{KiB/s}} + 3.2\\,\\mathrm{ms} + \\frac{256\\,\\mathrm{KiB}}{100 \\times 1024\\,\\mathrm{KiB/s}} + 6\\,\\mathrm{ms}$\n    $T_b \\le 0.000625\\,\\mathrm{s} + 3.2\\,\\mathrm{ms} + 0.0025\\,\\mathrm{s} + 6\\,\\mathrm{ms}$\n    $T_b \\le 0.625\\,\\mathrm{ms} + 3.2\\,\\mathrm{ms} + 2.5\\,\\mathrm{ms} + 6\\,\\mathrm{ms} = 12.325\\,\\mathrm{ms}$\n    计算结果与选项中提供的值一致。因此，该选项在设计和分析上都是正确的。", "answer": "$$\\boxed{A}$$", "id": "3646008"}]}