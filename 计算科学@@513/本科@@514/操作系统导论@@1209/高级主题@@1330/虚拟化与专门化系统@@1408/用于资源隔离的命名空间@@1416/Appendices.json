{"hands_on_practices": [{"introduction": "本练习旨在通过一个简化的模型，帮助你从第一性原理上理解资源隔离的核心概念。我们将模拟 System V 进程间通信（IPC）对象在不同 IPC 命名空间中的可见性。通过编写一个程序来创建和列举这些资源，你将亲手验证一个基本原则：命名空间为系统资源创建了独立的、互不重叠的作用域，这是容器技术安全性的基石。[@problem_id:3662441]", "problem": "您需要编写一个完整、可运行的程序，模拟 System V 进程间通信 (IPC) 资源在不同 IPC 命名空间下的隔离行为。其目标是基于操作系统资源隔离的第一性原理进行推理，并产生一个可衡量的可见性指标。\n\n基本和核心定义：操作系统通过将资源标识符的作用域限定在特定命名空间内，来实现基于命名空间的资源隔离。对于 System V IPC，信号量和消息队列等资源由 IPC 命名空间进行逻辑分区。一个列出 IPC 对象的进程只能看到存在于其自身命名空间中的对象。形式上，设命名空间集合为 $N = \\{0, 1, 2, \\dots\\}$，IPC 对象集合为 $R$。每个 IPC 对象 $r \\in R$ 是一个元组 $(t, k, n)$，其中 $t \\in \\{\\text{sem}, \\text{mq}\\}$ 是类型（信号量或消息队列），$k \\in \\mathbb{Z}$ 是键（$k = -1$ 代表特殊的 $\\text{IPC\\_PRIVATE}$ 键，强制创建一个新对象），$n \\in N$ 是所属的命名空间标识符。在命名空间 $n$ 中的进程执行的列出操作，被定义为精确地枚举出所有者为 $n$ 的资源 $r \\in R$。这个隔离规则在实现资源隔离命名空间的现代操作系统中是一个经过充分测试的事实：命名空间边界限制了可见性，除非进行显式映射，否则对象不会在不同的命名空间之间共享。\n\n您必须实现一个遵循以下纯粹以数学和逻辑术语指定的规则的模拟：\n\n- 资源所有权规则：每个创建的 IPC 对象都与且仅与一个命名空间 $n$ 相关联。在此模型中，不存在跨命名空间的共享。\n- 列出可见性规则：从命名空间 $n$ 执行的列出操作只能看到所有者为 $n$ 的对象。因此，定义一个可见性函数 $V(A, B)$，用于计算从命名空间 $B$ 列出时，命名空间 $A$ 拥有的对象中有多少是可见的，隔离属性要求\n$$\nV(A, B) = \n\\begin{cases}\n|R_A|  \\text{if } A = B, \\\\\n0  \\text{if } A \\neq B,\n\\end{cases}\n$$\n其中 $R_A = \\{ r \\in R \\mid \\text{owner}(r) = A \\}$ 且 $|\\cdot|$ 表示基数。\n- 命名空间内键唯一性规则：对于任何非私有键 $k \\neq -1$，在命名空间 $n$ 中尝试创建类型为 $t$、键为 $k$ 的对象时，如果对象 $(t, k, n)$ 已存在，则不产生任何变化；否则，将添加一个新对象。这模拟了命名键在命名空间内按类型具有唯一绑定的常规效果。\n- 私有键创建规则：对于 $k = -1$（代表 $\\text{IPC\\_PRIVATE}$），每个创建请求都会产生一个唯一的新对象，即使使用 $k = -1$ 创建了多个对象也是如此。这些对象在列出时与命名对象一样被计数；特殊键只在创建时影响唯一性语义。\n\n您的程序必须纯粹在内存中构建命名空间和对象（不进行实际的操作系统调用），使用这些规则模拟创建操作，并为给定的测试套件计算可见性函数 $V(A, B)$。\n\n测试套件和参数：初始化两个命名空间 $A$ 和 $B$，其标识符分别为 $0$ 和 $1$。对于下面的每个测试用例，按规定创建对象，然后计算单个数值结果：$V(\\text{source}, \\text{list\\_from})$。\n\n- 测试用例 1（跨命名空间隔离的正常路径）：在命名空间 $A$ 中，创建 2 个键为 1 和 2 的信号量，以及 1 个键为 42 的消息队列。命名空间 $B$ 不创建任何对象。计算 $V(A, B)$。预期的隔离意味着 $V(A, B) = 0$。\n- 测试用例 2（空集的边界条件）：在两个命名空间中都不创建对象。计算 $V(A, A)$。预期为 0，因为 $|R_A| = 0$。\n- 测试用例 3（同一命名空间内多个对象的可见性）：在命名空间 $B$ 中，创建 3 个键为 10、11 和 12 的信号量，以及 2 个键为 20 和 21 的消息队列。命名空间 $A$ 不创建任何对象。计算 $V(B, B)$。预期基数 $|R_B| = 5$。\n- 测试用例 4（跨命名空间键冲突）：在命名空间 $A$ 中创建 1 个键为 5 的信号量，在命名空间 $B$ 中也创建 1 个键为 5 的信号量。计算 $V(B, A)$。隔离意味着结果为 0，即使键在不同命名空间中发生冲突。\n- 测试用例 5（命名空间内重复的命名键和私有创建）：在命名空间 $A$ 中，创建 2 个 $k = -1$ 的信号量（两个不同的 $\\text{IPC\\_PRIVATE}$ 信号量），以及 2 个键为 10 的消息队列（第二个是重复的，应无效果）。命名空间 $B$ 创建 1 个键为 99 的信号量。计算 $V(A, A)$。预期为 3，因为 2 个私有信号量加上 1 个唯一的消息队列，在 $A$ 中总共有 3 个对象。\n\n最终输出格式：您的程序应生成单行输出，其中包含五个测试用例的结果，形式为用方括号括起来的逗号分隔列表。例如，输出必须是 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$ 的形式，并按测试用例 1 到 5 的顺序准确反映计算出的 $V$ 值。不涉及物理单位。不使用角度。不涉及百分比。所有结果都是整数。", "solution": "问题陈述是有效的。它提出了一个定义明确、自成体系且具有科学依据的模拟任务，该任务基于操作系统资源管理的既定原则，特别是针对 System V IPC 对象的基于命名空间的隔离。规则以数学和逻辑的精度表达，测试用例清晰无歧义，并且明确指定了所需的输出。该问题是可形式化的，并能导出一个唯一、可验证的解决方案。\n\n该解决方案通过将所提供的形式化规则直接转化为计算模型来设计。其基本原则是严格的资源隔离，正如**列出可见性规则**所定义的那样。该规则是模拟的基石，并用数学方式表示为：\n$$\nV(A, B) = \n\\begin{cases}\n|R_A|  \\text{if } A = B, \\\\\n0  \\text{if } A \\neq B,\n\\end{cases}\n$$\n其中 $V(A, B)$ 是可见性函数，用于计算在命名空间 $B$ 中的进程看来，命名空间 $A$ 所拥有的对象数量，而 $|R_A|$ 是命名空间 $A$ 拥有的对象数量。该规则断言，可见性仅是一种命名空间内部的属性；不存在跨命名空间边界的可见性。\n\n我们的设计通过三个主要组件来具体实现此模型：用于 IPC 对象的数据结构、用于管理这些对象集合的机制，以及一组实现系统行为的函数。\n\n首先，一个 IPC 对象，被定义为一个元组 $(t, k, n)$，由一个 C `struct` 表示。此结构存储了对象的类型 $t \\in \\{\\text{sem}, \\text{mq}\\}$、其键 $k \\in \\mathbb{Z}$ 以及其所属的命名空间标识符 $n$。为了编程上的清晰，类型 ‘sem’ 和 ‘mq’ 被映射为整数常量。\n\n其次，所有现有 IPC 对象的集合 $R$ 被作为一个动态分配的链表来管理。这种数据结构便于根据创建操作的要求添加新对象。一个全局指针维护此列表的头部。一个专门的函数负责释放列表中的所有节点，以便在测试用例之间重置模拟状态。\n\n第三，操作逻辑通过一组函数实现：\n1.  一个创建函数 `create_object(type, key, namespace_id)`，强制执行**键唯一性规则**和**私有键创建规则**。\n    - 如果键 $k$ 为 $-1$（代表 `IPC_PRIVATE`），则无条件地创建一个新对象并添加到列表中。这模拟了为每个 `IPC_PRIVATE` 请求保证一个唯一资源的机制。\n    - 如果键 $k$ 不为 $-1$，函数首先查询现有对象列表，以确定是否已存在具有相同类型 $t$、键 $k$ 和命名空间 $n$ 的对象。仅当未找到此类对象时，才会创建并添加新对象。这正确地模拟了命名键在特定命名空间内唯一标识给定类型 IPC 资源的行为。\n\n2.  一个可见性计算函数 `compute_visibility(source_ns, list_from_ns)`，直接实现了 $V(A, B)$ 的定义。\n    - 如果源命名空间 `source_ns` 和列出命名空间 `list_from_ns` 不相同，根据可见性规则的 $A \\neq B$ 情况，函数立即返回 $0$。\n    - 如果命名空间相同，函数必须计算该命名空间的资源集基数 $|R_A|$。这是通过遍历整个 IPC 对象链表并计算有多少对象属于指定命名空间来完成的。\n\n主程序逻辑系统地执行所提供的 5 个测试用例。对于每个测试用例，它首先通过清除对象列表来重置模拟状态，然后按描述执行一系列 `create_object` 调用，最后使用指定的命名空间调用 `compute_visibility` 来计算结果。所有 5 个用例的结果被存储起来，然后按要求以单行、逗号分隔的形式打印出来。\n\n例如，在测试用例 5 中，我们计算 $V(A, A)$，其中命名空间 $A$ 的标识符为 0。创建序列如下：\n- `create_object(sem, -1, 0)`：向命名空间 0 添加对象 1。\n- `create_object(sem, -1, 0)`：向命名空间 0 添加对象 2（私有键规则）。\n- `create_object(mq, 10, 0)`：向命名空间 0 添加对象 3。\n- `create_object(mq, 10, 0)`：无效果（键唯一性规则）。\n- `create_object(sem, 99, 1)`：向命名空间 1 添加一个对象。\n当调用 `compute_visibility(0, 0)` 时，满足条件 $A=B$，程序会计算命名空间 0 中的对象。计数被正确确定为 3。对于测试用例 1，计算 $V(A, B)$ 时，满足条件 $A \\neq B$，函数无需检查对象列表即可正确返回 0。这种设计确保了模拟的健壮性和准确性，严格遵守了问题的形式化规范。", "answer": "```c\n#include", "id": "3662441"}, {"introduction": "在理解了基本的对象可见性隔离后，本练习将难度提升一步，引导你探索网络行为的隔离。网络命名空间赋予每个容器独立的网络协议栈，包括其专属的防火墙规则。这个练习要求你对这种行为进行建模，并通过计算主机和容器在处理相同网络流量时的丢包率差异，来量化隔离效果。这对于理解多租户环境下的网络安全至关重要。[@problem_id:3662439]", "problem": "要求您从操作系统资源隔离的基本原则出发，用纯逻辑形式化一个最小防火墙实验室，以证明在进程组的网络（NET）命名空间内应用的数据包过滤规则不会继承或应用主机的规则。为此，将数据包过滤建模为一个在每个命名空间中评估的确定性函数，并在一组固定的测试套件上，计算主机和容器命名空间之间数据包丢弃率的量化差异。\n\n使用的基本原理：\n- 在类Unix操作系统中，命名空间通过创建不相交的资源表实例来隔离资源视图。网络（NET）命名空间隔离与网络相关的资源，包括由Linux Netfilter及其命令行界面iptables操作的数据包过滤表。根据资源隔离原则，一个NET命名空间中的规则不适用于在另一个NET命名空间中评估的数据包。\n- 防火墙规则集可以建模为一个按首次匹配语义评估的有序列表：规则按顺序检查，第一个匹配的规则决定了操作。如果没有规则匹配，则应用链的默认策略。这反映了常见数据包过滤框架中经过充分测试的行为。\n\n模型规范：\n- 每个数据包是一个包含以下属性的元组：链 $c \\in \\{\\text{INPUT}, \\text{OUTPUT}\\}$、协议 $p \\in \\{\\text{TCP}, \\text{UDP}\\}$、目标端口 $d$（其中 $d \\ge 0$），以及一个信任标志 $t \\in \\{0,1\\}$（表示源是否受信任）。\n- 每个规则 $r$ 是一个元组 $(c_r, p_r, [\\ell_r, u_r], t_r, a_r)$，其中 $c_r$ 是链，$p_r$ 是协议，$[\\ell_r, u_r]$ 是一个闭合整数端口区间且 $\\ell_r \\le u_r$，$t_r \\in \\{0,1\\}$ 表示规则是否要求受信任的源（$t=1$）或不要求（$t=0$ 意味着不需要信任），而 $a_r \\in \\{\\text{ACCEPT}, \\text{DROP}\\}$ 是动作。一个规则 $r$ 匹配一个数据包 $(c, p, d, t)$ 当且仅当 $c = c_r$、$p = p_r$、$\\ell_r \\le d \\le u_r$，并且 $t_r=0$ 或者 $t=1$。\n- 一个命名空间的策略是一个有序的规则列表和每个链的默认动作。对数据包的评估过程是按顺序扫描规则，并应用第一个匹配规则的动作。如果没有规则匹配，则应用链的默认动作。\n- 设 $R_H$ 和 $R_C$ 分别表示主机和容器的规则列表，每个列表仅在各自的命名空间内进行评估。设 $P_H(c)$ 和 $P_C(c)$ 表示主机和容器对于链 $c$ 的默认动作。设 $S=\\{(c_i,p_i,d_i,t_i,n_i)\\}$ 为一个流的多重集，其中每个流条目指定了 $n_i$ 个具有相同属性的数据包。\n\n据此，定义一个策略在 $S$ 上的丢弃率 $r$ 为 $$r = \\frac{\\sum_i n_i \\cdot \\mathbf{1}[\\text{action}(c_i,p_i,d_i,t_i) = \\text{DROP}]}{\\sum_i n_i},$$ 其中 $\\mathbf{1}[\\cdot]$ 是指示函数，$\\text{action}(\\cdot)$ 由上述评估过程确定。每个测试用例要报告的量是容器和主机之间丢弃率的绝对差值 $$\\Delta = \\left| r_C - r_H \\right|.$$\n\n您的程序必须实现此模型，并为以下每个测试用例计算 $\\Delta$。不允许外部输入；所有参数都嵌入在程序中。不得依赖实际的iptables或操作系统调用；一切都根据模型进行符号化计算。\n\n测试套件：\n- 测试用例1（通过显式主机DROP实现的正常路径隔离）：\n    - 主机规则：一条规则，丢弃入站传输控制协议（TCP）端口 $80$ 的数据包，即 $(\\text{INPUT}, \\text{TCP}, [80,80], 0, \\text{DROP})$。\n    - 主机默认策略：两个链均默认为ACCEPT。\n    - 容器规则：无。\n    - 容器默认策略：两个链均默认为ACCEPT。\n    - 流 $S$：$50$ 个数据包 $(\\text{INPUT}, \\text{TCP}, 80, 0)$ 和 $50$ 个数据包 $(\\text{INPUT}, \\text{TCP}, 443, 0)$。\n- 测试用例2（规则排序和信任谓词）：\n    - 主机规则：首先，如果受信任，则ACCEPT入站TCP端口 $22$ 的数据包，即 $(\\text{INPUT}, \\text{TCP}, [22,22], 1, \\text{ACCEPT})$；然后，对所有入站TCP端口 $22$ 的数据包执行DROP，即 $(\\text{INPUT}, \\text{TCP}, [22,22], 0, \\text{DROP})$。\n    - 主机默认策略：两个链均默认为ACCEPT。\n    - 容器规则：一条规则，丢弃入站TCP端口 $22$ 的数据包，即 $(\\text{INPUT}, \\text{TCP}, [22,22], 0, \\text{DROP})$。\n    - 容器默认策略：两个链均默认为ACCEPT。\n    - 流 $S$：$30$ 个数据包 $(\\text{INPUT}, \\text{TCP}, 22, 1)$ 和 $70$ 个数据包 $(\\text{INPUT}, \\text{TCP}, 22, 0)$。\n- 测试用例3（默认策略边界条件）：\n    - 主机规则：无。\n    - 主机默认策略：两个链均默认为ACCEPT。\n    - 容器规则：无。\n    - 容器默认策略：两个链均默认为DROP。\n    - 流 $S$：$40$ 个数据包 $(\\text{INPUT}, \\text{TCP}, 5000, 0)$ 和 $60$ 个数据包 $(\\text{INPUT}, \\text{UDP}, 5000, 0)$。\n- 测试用例4（特定协议规则与容器例外）：\n    - 主机规则：一条规则，丢弃入站用户数据报协议（UDP）端口 $53$ 的数据包，即 $(\\text{INPUT}, \\text{UDP}, [53,53], 0, \\text{DROP})$。\n    - 主机默认策略：两个链均默认为ACCEPT。\n    - 容器规则：一条规则，如果受信任，则ACCEPT入站UDP端口 $53$ 的数据包，即 $(\\text{INPUT}, \\text{UDP}, [53,53], 1, \\text{ACCEPT})$。\n    - 容器默认策略：两个链均默认为ACCEPT。\n    - 流 $S$：$10$ 个数据包 $(\\text{INPUT}, \\text{UDP}, 53, 1)$，$10$ 个数据包 $(\\text{INPUT}, \\text{UDP}, 53, 0)$ 和 $10$ 个数据包 $(\\text{INPUT}, \\text{UDP}, 67, 0)$。\n\n您的程序必须生成单行输出，其中包含四个测试用例的结果，格式为方括号内的逗号分隔的十进制数列表，并按测试用例的顺序排列，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是测试用例 $i$ 的 $\\Delta$ 值，表示为小数点后恰好有六位的小数。不允许有其他输出。", "solution": "问题陈述已经过严格验证，被认为是**有效的**。它在科学上基于操作系统资源隔离的原则，特别是网络命名空间。该问题定义明确，为数据包过滤提供了一个完整且一致的形式化模型，并为四个不同的测试用例提供了所有必要的数据。目标明确，所需的输出格式也已精确指定。该模型虽然是真实世界防火墙的简化，但对于此任务而言，它是一个逻辑上合理且计算上易于处理的抽象。\n\n所展示的核心原则是现代操作系统中的资源隔离。通过创建一个独立的网络（NET）命名空间，一组进程（例如，在容器中）可以获得一个独立的网络堆栈。这包括它自己的网络接口、路由表，以及对此问题至重要的数据包过滤规则（例如，`iptables`）。在主机系统上建立的规则存在于主机的NET命名空间中，不会被容器的命名空间继承，也不会影响它。该问题要求通过对数据包过滤逻辑进行建模，并计算主机策略和容器策略之间数据包丢弃率的差异来量化这种隔离。\n\n该模型定义如下：\n数据包是一个元组 $(c, p, d, t)$，表示其链、协议、目标端口和信任状态。\n规则是一个元组 $(c_r, p_r, [\\ell_r, u_r], t_r, a_r)$，定义了匹配标准和动作。\n一个数据包 $(c, p, d, t)$ 匹配一个规则 $(c_r, p_r, [\\ell_r, u_r], t_r, a_r)$ 当且仅当满足以下所有条件：\n$1$. 链匹配：$c = c_r$。\n$2$. 协议匹配：$p = p_r$。\n$3$. 目标端口 $d$ 在规则的端口范围内：$\\ell_r \\le d \\le u_r$。\n$4$. 满足信任要求。规则的信任要求 $t_r$ 可以是 $0$（不需要信任）或 $1$（需要信任）。带有信任标志 $t$ 的数据包如果满足 $t \\ge t_r$，则满足此要求。这正确地模拟了这样一个逻辑：一个不需要信任的规则（$t_r=0$）将匹配任何数据包（$t=0$ 或 $t=1$），而一个需要信任的规则（$t_r=1$）将只匹配一个受信任的数据包（$t=1$）。\n\n一个命名空间的策略由一个有序规则列表 $R$ 和每个链的默认动作 $P(c)$ 组成。要确定给定数据包的动作，我们遍历列表 $R$。应用第一个匹配规则的动作 $a_r$。如果 $R$ 中没有规则匹配该数据包，则应用该数据包所在链 $c$ 的默认策略 $P(c)$。\n\n对于给定的策略和流的多重集 $S=\\{(c_i,p_i,d_i,t_i,n_i)\\}$，丢弃率 $r$ 是丢弃的数据包总数与数据包总数的比率：\n$$r = \\frac{\\sum_i n_i \\cdot \\mathbf{1}[\\text{action}(c_i,p_i,d_i,t_i) = \\text{DROP}]}{\\sum_i n_i}$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。最终要计算的量是容器和主机之间丢弃率的绝对差值 $\\Delta = \\left| r_C - r_H \\right|$。\n\n让我们追踪测试用例2的执行过程来说明该模型的应用。\n数据包总数：$30+70=100$。流为 $S = \\{(\\text{INPUT}, \\text{TCP}, 22, 1, 30), (\\text{INPUT}, \\text{TCP}, 22, 0, 70)\\}$。\n\n**主机策略评估 ($r_H$)**：\n- 主机规则 $R_H$：\n    $1$. $r_1 = (\\text{INPUT}, \\text{TCP}, [22,22], 1, \\text{ACCEPT})$\n    $2$. $r_2 = (\\text{INPUT}, \\text{TCP}, [22,22], 0, \\text{DROP})$\n- 主机默认策略 $P_H(\\text{INPUT})$: $\\text{ACCEPT}$。\n\n- 流1：$30$ 个类型为 $(\\text{INPUT}, \\text{TCP}, 22, 1)$ 的数据包。\n    - 对照 $r_1$ 检查：$c=\\text{INPUT}$，$p=\\text{TCP}$，$d=22$，$t=1$。规则匹配（$c, p, d$ 正确，且 $t \\ge t_r \\implies 1 \\ge 1$）。动作为 $\\text{ACCEPT}$。\n    - 流1中总共接受：$30$。\n\n- 流2：$70$ 个类型为 $(\\text{INPUT}, \\text{TCP}, 22, 0)$ 的数据包。\n    - 对照 $r_1$ 检查：$c=\\text{INPUT}$，$p=\\text{TCP}$，$d=22$，$t=0$。规则不匹配，因为信任条件 $t \\ge t_r \\implies 0 \\ge 1$ 为假。\n    - 对照 $r_2$ 检查：$c=\\text{INPUT}$，$p=\\text{TCP}$，$d=22$，$t=0$。规则匹配（$c, p, d$ 正确，且 $t \\ge t_r \\implies 0 \\ge 0$）。动作为 $\\text{DROP}$。\n    - 流2中总共丢弃：$70$。\n\n- 主机总结：总丢弃数据包 = $0 + 70 = 70$。总数据包 = $100$。\n- 主机丢弃率：$r_H = 70 / 100 = 0.7$。\n\n**容器策略评估 ($r_C$)**：\n- 容器规则 $R_C$：\n    $1$. $r_1 = (\\text{INPUT}, \\text{TCP}, [22,22], 0, \\text{DROP})$\n- 容器默认策略 $P_C(\\text{INPUT})$: $\\text{ACCEPT}$。\n\n- 流1：$30$ 个类型为 $(\\text{INPUT}, \\text{TCP}, 22, 1)$ 的数据包。\n    - 对照 $r_1$ 检查：$c=\\text{INPUT}$，$p=\\text{TCP}$，$d=22$，$t=1$。规则匹配（$c, p, d$ 正确，且 $t \\ge t_r \\implies 1 \\ge 0$）。动作为 $\\text{DROP}$。\n    - 流1中总共丢弃：$30$。\n\n- 流2：$70$ 个类型为 $(\\text{INPUT}, \\text{TCP}, 22, 0)$ 的数据包。\n    - 对照 $r_1$ 检查：$c=\\text{INPUT}$，$p=\\text{TCP}$，$d=22$，$t=0$。规则匹配（$c, p, d$ 正确，且 $t \\ge t_r \\implies 0 \\ge 0$）。动作为 $\\text{DROP}$。\n    - 流2中总共丢弃：$70$。\n\n- 容器总结：总丢弃数据包 = $30 + 70 = 100$。总数据包 = $100$。\n- 容器丢弃率：$r_C = 100 / 100 = 1.0$。\n\n**测试用例2的最终计算**：\n- $\\Delta_2 = |r_C - r_H| = |1.0 - 0.7| = 0.3$。\n\n将此相同的确定性过程应用于所有四个测试用例，以计算所需的值。该实现在以下C程序中完成，该程序封装了这些结构和逻辑。\n最终结果如下：\n- 测试用例1：$r_H = 50/100 = 0.5$，$r_C = 0/100 = 0.0$。$\\Delta_1 = |0.0 - 0.5| = 0.5$。\n- 测试用例2：$r_H = 70/100 = 0.7$，$r_C = 100/100 = 1.0$。$\\Delta_2 = |1.0 - 0.7| = 0.3$。\n- 测试用例3：$r_H = 0/100 = 0.0$，$r_C = 100/100 = 1.0$。$\\Delta_3 = |1.0 - 0.0| = 1.0$。\n- 测试用例4：$r_H = 20/30$，$r_C = 0/30 = 0.0$。$\\Delta_4 = |0.0 - 20/30| = 2/3 \\approx 0.666667$。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3662439"}, {"introduction": "作为一项综合性练习，本题将前面学到的概念融会贯通。构建一个容器并不仅仅是创建一个命名空间，而是要按照特定顺序精心编排一组命名空间。此问题模拟了真实容器运行时的核心逻辑，包括解决不同命名空间之间的依赖关系，以及通过用户（USER）命名空间进行权限管理。完成此练习将帮助你从一个更高的架构层面，理解隔离环境是如何被一步步构建和启动的。[@problem_id:3662442]", "problem": "您需要设计并实现一个完整的、可运行的程序，该程序在一个关于能力和依赖关系的形式化模型下，计算并记录一个有效的、最小的步骤序列，以建立一个使用操作系统命名空间的简化类容器运行时。其目标是从通过命名空间实现的资源隔离、能力获取和偏序约束等第一性原理出发进行推理，然后计算出一个满足这些约束并符合一个精确最小化标准的序列。\n\n推理的基本依据：\n- 命名空间为进程提供系统资源的隔离。在本问题中，我们考虑六种命名空间：进程标识符 (PID)、挂载 (MNT)、Unix 分时系统 (UTS)、进程间通信 (IPC)、网络 (NET) 和用户 (USER)。\n- 能力模型：进程拥有一个单一的抽象能力，表示为 $C$。创建除用户 (USER) 命名空间之外的任何命名空间都需要此能力。最初，当且仅当进程拥有特权时，才具备能力 $C$。创建一个 USER 命名空间会在新的用户命名空间内授予能力 $C$。这模拟了操作系统中广泛观察到的行为，即用户命名空间会向进程授予命名空间范围内的特权。\n- 步骤的偏序关系：某些配置步骤必须在相应的命名空间被创建之后才能进行；最后，启动目标进程必须在所有必需的创建和配置步骤都完成之后才能进行。\n\n您将实现以下形式化模型。\n\n1. 步骤及其代码。定义以下步骤代码，每个代码由一个整数表示：\n   - $1$：创建 USER 命名空间。\n   - $2$：创建 PID 命名空间。\n   - $3$：创建 MNT 命名空间。\n   - $4$：创建 UTS 命名空间。\n   - $5$：创建 IPC 命名空间。\n   - $6$：创建 NET 命名空间。\n   - $7$：在创建 MNT 后配置 MNT（例如，挂载一个伪文件系统）。\n   - $8$：在创建 UTS 后配置 UTS（例如，设置主机名）。\n   - $9$：在创建 NET 后配置 NET（例如，启用环回接口）。\n   - $10$：启动目标进程。\n\n2. 每个测试用例的输入。每个测试用例指定：\n   - 一个特权标志 $p \\in \\{0,1\\}$，其中 $p=1$ 表示进程初始拥有能力 $C$，$p=0$ 表示没有。\n   - 希望创建的命名空间，编码为六个布尔值 $(u, pid, mnt, uts, ipc, net)$，每个值在 $\\{0,1\\}$ 中，表示是否请求相应的命名空间。顺序为 $(\\text{USER}, \\text{PID}, \\text{MNT}, \\text{UTS}, \\text{IPC}, \\text{NET})$。\n\n3. 能力规则。设 $C$ 表示创建除 USER 外任何命名空间所需的能力：\n   - 最初，当且仅当 $p=1$ 时，$C=1$。\n   - 创建 USER 命名空间会为后续步骤设置 $C=1$。\n   - 如果 $p=0$ 且 $u=0$，那么任何创建 USER 以外命名空间的请求在该模型下都是不可能的，因为 $C=0$ 并且无法获取它。这样的测试用例被视为不可能。\n\n4. 依赖规则。有效的步骤序列必须满足：\n   - 如果 $u=1$ 并且 $(pid, mnt, uts, ipc, net)$ 中至少有一个为 $1$，则 USER 的创建（步骤 1）必须在所有其他存在的命名空间创建步骤之前发生。\n   - 对于 $(\\text{PID}, \\text{MNT}, \\text{UTS}, \\text{IPC}, \\text{NET})$ 中每个请求的命名空间 $X$，在日志中包含相应的创建步骤代码（2 到 6）。\n   - 如果 $mnt=1$，则包含步骤 7，并强制执行 $3 \\to 7$ 的先行关系。\n   - 如果 $uts=1$，则包含步骤 8，并强制执行 $4 \\to 8$ 的先行关系。\n   - 如果 $net=1$，则包含步骤 9，并强制执行 $6 \\to 9$ 的先行关系。\n   - 启动步骤 10 必须严格在所有已包含的创建和配置步骤之后发生。\n   - 如果完全没有请求命名空间，则序列仅包含步骤 10。\n\n5. 最小化标准。在所有满足上述条件的序列中，选择相对于步骤代码而言字典序最小的序列。形式上，定义由依赖规则导出的偏序的所有拓扑排序的集合。选择序列 $\\sigma$，使得对于任何其他有效序列 $\\tau$，都存在一个索引 $k$，满足对所有 $i  k$ 都有 $\\sigma_i = \\tau_i$ 且 $\\sigma_k  \\tau_k$。直观上，在当前已启用的步骤中，每当有选择点时，就选择可用的最小步骤代码。\n\n6. 不可能性处理。如果能力规则判定测试用例为不可能，则结果为空列表 $[\\,]$。\n\n您的任务是实现一个程序，针对下面提供的固定测试套件，为每个测试用例计算结果序列，并将所有结果汇总打印在一行上。\n\n测试套件。对于每个元组，第一个条目是 $p$，后面跟着 $(u, pid, mnt, uts, ipc, net)$：\n- 案例 1：$(0,\\;1,1,1,1,1,1)$。\n- 案例 2：$(0,\\;0,0,0,1,0,0)$。\n- 案例 3：$(1,\\;0,0,0,0,0,1)$。\n- 案例 4：$(1,\\;0,0,0,0,0,0)$。\n- 案例 5：$(1,\\;0,1,1,1,1,0)$。\n- 案例 6：$(0,\\;1,0,0,0,0,0)$。\n\n预期的结果类型。对于每个测试用例，结果是一个整数列表，表示计算出的日志序列中的步骤代码；在不可能的情况下，则为空列表。程序必须输出一行，其中包含用方括号括起来的、以逗号分隔的结果列表，其中每个元素本身也是一个用方括号括起来的列表。例如，一个有效的输出格式看起来像 $[\\,[1,2],\\,[\\,],\\,[3]\\,]$，但应使用上述测试套件的具体结果。输出字符串中不应插入任何空格。\n\n您的程序必须完全自包含，不需要任何输入，并以指定格式精确地生成一行输出。", "solution": "用户提出的问题是一个有效的、定义明确的算法挑战，其原理植根于操作系统的资源隔离。它要求在能力和依赖约束下，为一个简化的容器环境计算一个字典序最小的设置步骤序列。我将着手给出一个形式化的解决方案。\n\n这个问题可以建模为在一个有向无环图 (DAG) 中寻找一个特定的拓扑排序，其中节点代表系统任务，边代表依赖关系。“字典序最小”的要求意味着，在任何有多个任务可以执行的时刻，我们都必须选择那个具有最小整数步骤代码的任务。这可以通过使用 Kahn 算法的一个变体来实现，该变体使用一个最小优先队列。\n\n一个额外的约束是能力模型。创建非 USER 命名空间需要一种能力 $C$，该能力在初始时可能存在也可能不存在。通过创建 USER 命名空间可以获得此能力。这为某些任务引入了一个依赖于状态的就绪条件，该条件必须被整合到排序算法中。\n\n### 形式化模型与算法\n\n1.  **图的构建**：对每个测试用例，我们构建一个 DAG $G = (V, E)$。\n    *   顶点集 $V$ 由测试用例输入参数所需的所有步骤的整数代码组成。\n    *   边集 $E$ 代表先行约束：\n        *   如果步骤 $u$ 必须在步骤 $v$ 之前执行，则添加一条边 $u \\to v$。\n        *   这些依赖关系由问题的规则导出：\n            *   配置依赖：$3 \\to 7$ (MNT)，$4 \\to 8$ (UTS)，$6 \\to 9$ (NET)。\n            *   启动依赖：对于每个其他必需的步骤 $s \\in V \\setminus \\{10\\}$，添加一条边 $s \\to 10$。\n            *   USER 命名空间依赖：如果创建了 USER 命名空间 ($u=1$) 并且也请求了其他命名空间，则为每个其他请求的命名空间创建步骤 $k \\in \\{2, 3, 4, 5, 6\\}$ 添加一条边 $1 \\to k$。\n\n2.  **能力与不可能性**：\n    *   我们定义一个布尔状态变量 `has_capability`，如果进程是特权的 ($p=1$)，则初始化为 true，否则初始化为 false ($p=0$)。\n    *   如果 $p=0$，$u=0$（不创建 USER 命名空间），并且请求了任何其他命名空间，则该问题被视为不可能。在这种情况下，`has_capability` 初始为 false，并且无法将其设置为 true，从而使得步骤 $\\{2,3,4,5,6\\}$ 的创建变得不可能。结果序列为空。\n\n3.  **带能力门控的字典序最小拓扑排序**：该算法流程如下：\n    *   **初始化**：\n        *   计算 $V$ 中每个顶点的入度。顶点的入度是其传入边的数量。\n        *   初始化一个空的结果序列 $S$。\n        *   初始化一个最小优先队列 $Q$，用于存储准备执行的步骤。\n        *   初始化一个临时等待列表 $W$ (waitlist)，用于存放拓扑上就绪（入度为 $0$）但因能力要求而被阻塞的步骤。\n    *   **填充队列**：\n        *   找出 $V$ 中所有入度为 $0$ 的顶点 $v$。\n        *   对于每个这样的顶点 $v$：\n            *   如果 $v \\in \\{2, 3, 4, 5, 6\\}$（一个非 USER 命名空间的创建）且 `has_capability` 为 false，则将 $v$ 添加到等待列表 $W$。\n            *   否则，将 $v$ 添加到优先队列 $Q$。\n    *   **执行循环**：当 $Q$ 非空时：\n        *   从 $Q$ 中提取值最小的顶点 $u$。\n        *   将 $u$ 追加到结果序列 $S$。\n        *   如果 $u=1$（创建 USER），则将 `has_capability` 设置为 true。将等待列表 $W$ 中的所有顶点移动到优先队列 $Q$ 中，并清空 $W$。这表示能力已被获取，之前被阻塞的步骤现在已准备就绪。\n        *   对于 $u$ 的每个邻居 $v$（即，对于每条边 $u \\to v$）：\n            *   将 $v$ 的入度减一。\n            *   如果 $v$ 的入度变为 $0$：\n                *   检查 $v$ 的能力约束。如果 $v \\in \\{2, 3, 4, 5, 6\\}$ 且 `has_capability` 为 false，则将 $v$ 添加到 $W$。\n                *   否则，将 $v$ 添加到 $Q$。\n    *   **终止**：当 $Q$ 为空时，循环终止。序列 $S$ 就是字典序最小的有效步骤序列。\n\n该算法在尊重能力动态状态变化的同时，正确地找到了字典序最小的拓扑排序。对于少量顶点，最小优先队列可以通过一个简单的数组实现，在每一步扫描该数组以找到最小元素。\n\n### 示例演练：案例 1 $(0,\\;1,1,1,1,1,1)$\n\n1.  **顶点**：$V = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\}$。\n2.  **能力**：`has_capability` 初始为 false ($p=0$)。\n3.  **边与入度**：\n    *   $1 \\to \\{2,3,4,5,6\\}$。$\\{2,3,4,5,6\\}$ 的入度为 $1$。\n    *   $3 \\to 7$, $4 \\to 8$, $6 \\to 9$。$\\{7,8,9\\}$ 的入度为 $1$。\n    *   $\\{1, \\dots, 9\\} \\to 10$。$10$ 的入度为 $9$。\n    *   唯一入度为 $0$ 的顶点是 $1$。\n4.  **执行**：\n    *   **初始化**：$Q = \\{1\\}$，$W = \\{\\}$。$S = []$。\n    *   **步骤 1**：从 $Q$ 中弹出 $1$。$S = [1]$。将 `has_capability` 设置为 true。\n        *   将 $\\{2,3,4,5,6\\}$ 的入度减一，它们都变为 $0$。\n        *   由于 `has_capability` 现在为 true，将 $\\{2,3,4,5,6\\}$ 添加到 $Q$。现在 $Q = \\{2,3,4,5,6\\}$。\n    *   **步骤 2**：从 $Q$ 中弹出 $2$。$S = [1,2]$。将 $10$ 的入度减一。\n    *   **步骤 3**：从 $Q$ 中弹出 $3$。$S = [1,2,3]$。将 $7$ 的入度减一，其变为 $0$。将 $7$ 添加到 $Q$。$Q = \\{4,5,6,7\\}$。\n    *   **步骤 4**：从 $Q$ 中弹出 $4$。$S = [1,2,3,4]$。将 $8$ 的入度减一，其变为 $0$。将 $8$ 添加到 $Q$。$Q = \\{5,6,7,8\\}$。\n    *   **步骤 5**：从 $Q$ 中弹出 $5$。$S = [1,2,3,4,5]$。将 $10$ 的入度减一。\n    *   **步骤 6**：从 $Q$ 中弹出 $6$。$S = [1,2,3,4,5,6]$。将 $9$ 的入度减一，其变为 $0$。将 $9$ 添加到 $Q$。$Q = \\{7,8,9\\}$。\n    *   **步骤 7-9**：按顺序弹出 $7, 8, 9$。$S = [1,2,3,4,5,6,7,8,9]$。每次弹出后，将 $10$ 的入度减一。\n    *   **最后一步**：处理完 $9$ 之后，$10$ 的入度变为 $0$。将 $10$ 添加到 $Q$。弹出 $10$。$S = [1,2,3,4,5,6,7,8,9,10]$。\n\n最终计算出的序列是 $[1,2,3,4,5,6,7,8,9,10]$。这个有原则的方法适用于所有测试用例。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3662442"}]}