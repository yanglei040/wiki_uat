{"hands_on_practices": [{"introduction": "理论知识告诉我们，伙伴系统分配器会选择满足大小要求的最小块。但在现实世界中，内存分配不仅要考虑大小，还必须遵守硬件施加的严格对齐约束。这个练习模拟了这样一个场景，你将计算一个简单的64KB内存请求，在满足一个非常严格的$2^{20}$字节对齐要求后，会导致多大的内部碎片，从而直观地理解对齐要求是如何影响分配策略并放大内存浪费的。[@problem_id:3624829]", "problem": "一个基于伙伴系统的连续区域分配器被用来管理随机存取存储器 (RAM)。伙伴系统将空闲内存组织成块，其大小是基本单位乘以2的整数次幂。设基本单位为一页，大小为 $2^{12}$ 字节，因此一个阶为 $k$ 的块大小为 $2^{k} \\cdot 2^{12}$ 字节，并且根据其构造，每个阶为 $k$ 的块的起始地址都与 $2^{k} \\cdot 2^{12}$ 字节对齐。当一个大小为 $s$ 的请求到达时，分配器会选择满足 $2^{k} \\cdot 2^{12} \\ge s$ 的最小阶数 $k$，并返回该阶的一个块，产生的内部碎片等于分配的块大小与请求大小之差。\n\n假设一个执行直接内存访问 (DMA) 的设备施加了严格的对齐要求：返回给请求者的每个分配块都必须始于一个与 $2^{20}$ 字节对齐的地址。分配器通过选择一个其块大小能保证这种对齐的阶数来强制执行此要求。\n\n考虑一个大小为 $64$ 千字节的单一请求。使用 $1$ 千字节 $=$ $1024$ 字节。从上述定义和伙伴块的对齐属性出发，确定在没有对齐约束的情况下分配器会选择的最小阶数，以及在 $2^{20}$ 字节对齐约束下它必须选择的最小阶数。然后，使用这些结果，计算定义如下的内部碎片率：\n$$\\frac{\\text{分配的大小} - \\text{请求的大小}}{\\text{分配的大小}}。$$\n仅将此内部碎片率作为最终答案报告。将最终答案表示为小数，并四舍五入到四位有效数字。最终答案中不应包含任何单位。", "solution": "该问题要求我们确定在伙伴系统分配器和硬件设备施加的特定约束下，一个内存分配请求的内部碎片率。我们首先将给定信息形式化，然后进行分步计算。\n\n首先，我们建立系统的基本参数。\n内存的基本单位是一页，大小为 $2^{12}$ 字节。\n一个阶为 $k$ 的内存块的大小，我们记作 $B_k$，由以下公式给出：\n$$B_k = 2^k \\cdot 2^{12} = 2^{k+12} \\text{ 字节}$$\n根据其构造，一个阶为 $k$ 的块保证其起始内存地址是其自身大小 $B_k$ 的倍数。\n\n请求的内存区域大小为 $s = 64$ 千字节。我们使用提供的转换因子 $1$ 千字节 = $1024$ 字节 = $2^{10}$ 字节，将这个大小转换为字节。\n$$s = 64 \\times 1024 \\text{ 字节} = 2^6 \\times 2^{10} \\text{ 字节} = 2^{16} \\text{ 字节}$$\n\n问题要求考虑两种不同的分配场景，但最终答案仅取决于有对齐约束的场景。为求完整，我们在专注于最终计算之前将对两种场景都进行分析。\n\n1.  **没有特殊对齐约束的分配：**\n    分配器必须找到最小的阶数 $k$，使得块大小 $B_k$ 大于或等于请求的大小 $s$。\n    $$B_k \\ge s$$\n    $$2^{k+12} \\ge 2^{16}$$\n    对两边取以2为底的对数，我们得到：\n    $$k+12 \\ge 16$$\n    $$k \\ge 4$$\n    满足此条件的最小整数 $k$ 是 $k=4$。如果没有特殊约束，分配器会选择一个阶为 $4$ 的块。\n\n2.  **有特殊对齐约束的分配：**\n    一个直接内存访问 (DMA) 设备施加了更严格的要求：分配的块必须始于一个与 $2^{20}$ 字节对齐的地址。这意味着块的起始地址必须是 $2^{20}$ 的倍数。\n    伙伴系统保证一个阶为 $k$ 的块的起始地址是其大小 $B_k = 2^{k+12}$ 的倍数。\n    为了确保分配器可能返回的*任何*阶为 $k$ 的块都满足DMA的对齐要求，该块的自然对齐必须至少与所要求的对齐一样严格。因此，块大小 $B_k$ 必须是所要求的对齐边界 $2^{20}$ 字节的倍数。这意味着：\n    $$B_k \\ge 2^{20}$$\n    $$2^{k+12} \\ge 2^{20}$$\n    再次，取以2为底的对数：\n    $$k+12 \\ge 20$$\n    $$k \\ge 8$$\n    保证 $2^{20}$ 字节对齐的最小整数阶数 $k$ 是 $k=8$。\n\n分配器必须同时满足大小要求（$s = 2^{16}$ 字节）和对齐要求（$2^{20}$ 字节边界）。\n设 $k_{final}$ 是分配器选择的阶数。\n根据大小要求，我们需要 $B_{k_{final}} \\ge 2^{16}$，这意味着 $k_{final} \\ge 4$。\n根据对齐要求，我们需要 $k_{final} \\ge 8$。\n为同时满足这两个条件，分配器必须选择满足 $k_{final} \\ge 4$ 和 $k_{final} \\ge 8$ 的最小整数阶数 $k_{final}$。这样的最小整数是 $k_{final} = 8$。\n\n现在，我们可以计算分配的块的大小。\n分配的大小 $A$ 对应于阶数 $k_{final} = 8$ 的块大小：\n$$A = B_8 = 2^{8+12} = 2^{20} \\text{ 字节}$$\n\n请求的大小是 $s = 2^{16}$ 字节。\n内部碎片是分配的大小与请求的大小之差：\n$$\\text{内部碎片} = A - s = 2^{20} - 2^{16} \\text{ 字节}$$\n\n问题要求的是内部碎片率，其定义为：\n$$\\text{比率} = \\frac{\\text{分配的大小} - \\text{请求的大小}}{\\text{分配的大小}} = \\frac{A-s}{A}$$\n代入 $A$ 和 $s$ 的值：\n$$\\text{比率} = \\frac{2^{20} - 2^{16}}{2^{20}} = 1 - \\frac{2^{16}}{2^{20}} = 1 - 2^{16-20} = 1 - 2^{-4}$$\n$$2^{-4} = \\frac{1}{2^4} = \\frac{1}{16} = 0.0625$$\n$$\\text{比率} = 1 - 0.0625 = 0.9375$$\n\n问题要求答案以小数形式表示，并四舍五入到四位有效数字。计算出的值 $0.9375$ 已经恰好有四位有效数字（$9$、$3$、$7$、$5$）。因此，无需进一步四舍五入。", "answer": "$$\\boxed{0.9375}$$", "id": "3624829"}, {"introduction": "伙伴系统的优雅之处在于其分裂和合并的简洁性，但这也带来了其最主要的弱点：外部碎片。这个练习将通过一个思想实验，让你亲身体验这个问题。你将确定需要多少次微小的内存分配，才能“破坏”整个内存结构，以至于一个大的内存请求即使在总空闲空间足够的情况下也无法被满足，从而深刻理解碎片化是如何让可用内存变得“不可用”的。[@problem_id:3624862]", "problem": "一个内存分配器使用伙伴系统（buddy system）进行主内存管理。总共管理的主内存为 $1\\,\\text{MiB}$，定义为 $2^{20}$ 字节。最小可分配块大小为 $1\\,\\text{KiB}$，定义为 $2^{10}$ 字节。内存块按“阶”（order）进行管理：一个阶为 $i$ 的块大小为 $2^{10+i}$ 字节，其中整数 $i \\geq 0$。初始时，整个内存是一个处于最大阶的空闲块。\n\n分配器策略如下：为满足大小为 $s$ 的请求，它会选择满足 $2^{10+i} \\geq s$ 的最小阶 $i$，并查找是否存在一个阶为 $i$ 的空闲块；如果不存在，它会递归地分裂可用的最小更高阶的空闲块（在该阶中选择地址最低的空闲块），直到获得一个阶为 $i$ 的块。在各次分配之间不发生释放操作。\n\n考虑以下工作负载：\n- 首先，执行 $n$ 次连续的小块分配，每次分配的大小恰好为 $1\\,\\text{KiB}$。\n- 在这 $n$ 次分配之后，立即发出一个大小为 $256\\,\\text{KiB}$ 的大块分配请求。\n\n仅使用伙伴系统的核心定义和所述策略，确定使得这个 $256\\,\\text{KiB}$ 的大块请求失败的最小整数 $n$，即使此时剩余的总空闲内存可能超过 $256\\,\\text{KiB}$。你的推理必须明确说明先前的分裂操作如何阻止为大块请求形成合适的伙伴块。然后，简要提出一个可以避免此失败的缓解策略参数（例如，分裂预留规则），且无需改变总内存大小；你不需要量化其效果。\n\n你最终报告的答案必须是单个整数 $n$，不带单位。无需四舍五入。", "solution": "首先对问题进行验证，以确保其是适定（well-posed）的、有科学依据且一致的。\n\n### 步骤 1：提取已知条件\n- 总管理内存：$1\\,\\text{MiB}$，定义为 $2^{20}$ 字节。\n- 最小可分配块大小：$1\\,\\text{KiB}$，定义为 $2^{10}$ 字节。\n- 阶为 $i$ 的块大小：$S_i = 2^{10+i}$ 字节，其中整数 $i \\geq 0$。\n- 初始状态：整个内存是一个处于最大阶的空闲块。\n- 分配器策略：为满足大小为 $s$ 的请求，使用大小 $S_i \\geq s$ 的最小阶 $i$ 的块。如果阶为 $i$ 的空闲块不可用，则递归地分裂可用的最小更高阶的空闲块。分裂时，选择给定阶中地址最低的空闲块。\n- 工作负载：$n$ 次连续的大小恰好为 $1\\,\\text{KiB}$ 的分配，随后是一次大小为 $256\\,\\text{KiB}$ 的分配请求。\n- 在各次分配之间不发生释放操作。\n- 目标：确定使 $256\\,\\text{KiB}$ 请求失败的最小整数 $n$。提出一个缓解策略。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题描述了伙伴内存分配系统，这是操作系统中的一种标准算法。所有原则在事实上都是正确的，并且在计算机科学中是公认的。\n-   **适定性**：该问题是适定的。内存大小、块大小定义、分配策略和工作负载都已明确指定，这允许对唯一的整数 $n$ 进行确定性的计算。\n-   **客观性与完整性**：该问题以精确、客观的术语陈述。所有必要的参数都已提供。可以推导出最大块阶：$S_{i_{max}} = 2^{10+i_{max}} = 2^{20}$，这意味着 $i_{max}=10$。最小块大小 $2^{10}$ 字节对应于阶 $i=0$。阶的范围是从 $0$ 到 $10$。\n\n问题中包含一个条款，“……即使此时剩余的总空闲内存可能超过 $256\\,\\text{KiB}$，”这表明失败应该是由于碎片化而不是容量不足。严谨的分析（如下所示）表明，在给定策略下导致失败的最小 $n$ 值，其失败恰好是由于碎片化和总容量不足共同导致的。这并不会使问题无效，因为主要目标——找到导致失败的最小 $n$——仍然是可回答的。该条款正确地描述了伙伴系统的一个普遍现象，即使在本案例的边界条件下没有严格满足。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。将提供完整解答。\n\n### 解法\n\n解题过程首先确定大块分配请求在何种条件下失败，然后找出创建这些条件所需的最少小块分配次数。\n\n1.  **分析分配请求**\n    -   小块分配的大小为 $s_{small} = 1\\,\\text{KiB} = 2^{10}$ 字节。分配器必须找到一个阶为 $i$ 的块，其中 $S_i = 2^{10+i} \\ge 2^{10}$。满足条件的最小阶为 $i=0$。因此，每次小块分配消耗一个阶为 $0$ 的块。\n    -   大块分配的大小为 $s_{large} = 256\\,\\text{KiB} = 256 \\times 2^{10} = 2^8 \\times 2^{10} = 2^{18}$ 字节。分配器必须找到一个阶为 $j$ 的块，其中 $S_j = 2^{10+j} \\ge 2^{18}$。这意味着 $10+j \\ge 18$，所以最小整数阶为 $j=8$。大块请求需要一个阶为 $8$ 的块。\n\n2.  **分析内存结构**\n    -   总内存是一个阶为 $10$ 的单个块，大小为 $S_{10} = 2^{20}$ 字节。\n    -   大块请求需要一个阶为 $8$ 的块，大小为 $S_8 = 2^{18}$ 字节。\n    -   总内存空间可以从概念上划分为若干个不重叠的阶为 $8$ 的块。这样的块的数量为 $N_8 = \\frac{S_{10}}{S_8} = \\frac{2^{20}}{2^{18}} = 2^2 = 4$。\n    -   这四个阶为 $8$ 的块，我们称之为 $Q_0, Q_1, Q_2, Q_3$，占据了整个地址空间。\n        -   $Q_0$：地址范围 $[0, 2^{18}-1]$\n        -   $Q_1$：地址范围 $[2^{18}, 2 \\cdot 2^{18}-1]$\n        -   $Q_2$：地址范围 $[2 \\cdot 2^{18}, 3 \\cdot 2^{18}-1]$\n        -   $Q_3$：地址范围 $[3 \\cdot 2^{18}, 4 \\cdot 2^{18}-1]$\n    -   从一个阶为 $8$ 的块中可以创建出的阶为 $0$ 的块的数量为 $k = \\frac{S_8}{S_0} = \\frac{2^{18}}{2^{10}} = 2^8 = 256$。\n\n3.  **追踪分配过程**\n    -   分配策略是使用“地址最低的空闲块”。该策略有一个关键结果：分配器将从最低地址开始顺序地消耗内存来满足请求。它会先完全用尽 $Q_0$ 中可分配的阶为 $0$ 的块，然后再触及 $Q_1$，依此类推。\n    -   如果不存在阶为 $8$ 的空闲块，并且没有更高阶（$9$ 或 $10$）的空闲块可以分裂以创建一个阶为 $8$ 的块，那么对阶为 $8$ 的块的请求将失败。只有当所有四个原始的阶为 $8$ 的块（$Q_0, Q_1, Q_2, Q_3$）都已被“破坏”时，才会达到这种状态，即每个块都为了满足至少一次小块分配请求而被分裂。\n\n4.  **确定最小的 `n`**\n    -   要破坏 $Q_0$，一次小块分配（$n=1$）就足够了。它被放置在地址 $0$。然而，此时系统已经创建了许多阶的空闲块，包括一个阶为 $8$ 的块（$Q_0$ 的伙伴，即 $Q_1$）和一个阶为 $9$ 的块（$Q_0$ 和 $Q_1$ 父块的伙伴）。大块请求将会成功。\n    -   要破坏 $Q_1$，我们必须首先用尽 $Q_0$ 中所有的 $256$ 个阶为 $0$ 的块。这需要 $n=256$ 次分配。第 $(256+1)$ 次分配，即 $n=257$ 时，将是第一个从 $Q_1$ 中分配的，从而分裂它。\n    -   要破坏 $Q_2$，我们必须首先用尽 $Q_0$ 和 $Q_1$ 中所有的阶为 $0$ 的块。这需要 $n = 256 + 256 = 512$ 次分配。第 $(512+1)$ 次分配，即 $n=513$ 时，将分裂 $Q_2$。\n    -   要破坏 $Q_3$，我们必须首先用尽 $Q_0$、$Q_1$ 和 $Q_2$ 中所有的阶为 $0$ 的块。这需要 $n = 256 + 256 + 256 = 3 \\times 256 = 768$ 次分配。\n    -   让我们分析 $n=768$ 次小块分配后的状态。块 $Q_0, Q_1, Q_2$ 已完全被已分配的阶为 $0$ 的块填满。块 $Q_3$ 仍然是一个原始的、连续的、阶为 $8$ 的空闲块。随后对阶为 $8$ 的块的请求将立即由 $Q_3$ 满足。因此，当 $n=768$ 时，大块请求成功。\n    -   下一次小块分配，即 $n=769$ 时，必须从 $Q_3$ 中获取。为此，分配器必须分裂阶为 $8$ 的块 $Q_3$。这次分裂之后，所有四个原始的阶为 $8$ 的块都已被破坏。不再存在阶为 $8$ 的空闲块。此外，它们的阶为 $9$ 的父块和阶为 $10$ 的祖父块也都被分裂了。\n    -   因此，在 $n=769$ 次小块分配后，随后对阶为 $8$ 的块的请求将失败，因为任何空闲链表上都没有阶为 $8$ 或更高阶的可用块。这是保证失败的最小 $n$ 值。\n\n5.  **分析空闲内存**\n    -   当 $n=769$ 时，总共已分配的内存为 $769 \\times S_0 = 769 \\times 2^{10}$ 字节。\n    -   总内存为 $S_{10} = 2^{20} = 1024 \\times 2^{10}$ 字节。\n    -   总空闲内存为 $(1024 - 769) \\times 2^{10} = 255 \\times 2^{10}$ 字节，即 $255\\,\\text{KiB}$。\n    -   大块请求的大小是 $256\\,\\text{KiB}$。由于 $255\\,\\text{KiB}  256\\,\\text{KiB}$，该请求同样会因总内存不足而失败。在这种特定情况下，由碎片化导致的结构性失败与容量不足导致的失败恰好同时发生。\n\n6.  **提议的缓解策略**\n    -   问题的出现是因为小块分配被允许任意地碎片化大块。一种缓解策略是为大块请求预留大块。\n    -   一个合适的策略参数可以是**分裂预留阶**，记作 $i_{res}$。\n    -   修改后的策略将是：“一个阶为 $j \\geq i_{res}$ 的空闲块只能为了满足对一个阶为 $k \\geq i_{res}-1$（或某个类似的阈值）的块的请求而被分裂。”\n    -   对于本问题，设置 $i_{res}=8$ 意味着阶为 $8$ 及更高（即 $8, 9, 10$）的块不能为了满足对阶为 $0$ 的块的请求而被分裂。这将为大块请求保留大块库存，防止这种由碎片化引起的失败。小块分配将被限制在内存的一部分区域，而另一部分则为大块分配预留。", "answer": "$$\n\\boxed{769}\n$$", "id": "3624862"}, {"introduction": "与分裂相对应的是合并——将相邻的空闲伙伴块重新组合成更大的块，是回收内存的关键。本练习模拟了一个常见场景：部分物理内存区域被硬件设备永久保留，形成了无法使用的“空洞”。你的任务是，在存在这些“空洞”的情况下，推导出所有可能的合并操作完成后，系统中能形成的最大连续空闲块是多大。这个练习将帮助你理解合并的对齐规则，以及内存碎片化是如何从根本上限制内存回收效率的。[@problem_id:3624835]", "problem": "一个单处理器操作系统在一个大小为 $2^{20}$ 字节的连续物理区域上使用二进制伙伴内存分配器。最小可分配块的大小为 $2^{12}$ 字节。该分配器遵循标准的伙伴系统规则：内存被划分为多个块，其大小为最小块大小的2的幂次方倍；两个相同阶的空闲块会合并，当且仅当它们都为空闲且它们的组合起始地址按下一个更高阶块的大小（以字节为单位）对齐。一个阶为 $k$ 的块大小为 $2^{12} \\cdot 2^{k}$ 字节，并且必须起始于一个 $2^{12} \\cdot 2^{k}$ 的倍数的地址。\n\n在被管理的区域内有几个设备保留的子区域。保留的子区域被指定为半开字节区间 $[s,e)$，任何与任一保留子区域相交的最小块都被视为不可用，且不能被合并或分配。保留的子区域是：\n- $[1000, 6000)$\n- $[133632, 140120)$\n- $[260096, 264192)$\n- $[717800, 725800)$\n- $[918600, 920600)$\n\n假设在这些保留子区域之外，所有内存初始均为空闲，并且在伙伴系统规则允许的情况下，合并会贪婪地进行，但仅在完全可用的块之间进行。\n\n从以上定义出发，且不假设除这些定义之外的任何未经证实的伙伴系统属性，确定在所有与约束条件兼容的可能合并之后，区域中某处可以存在的完全空闲块的最大可实现连续阶数 $k$。请将您的最终答案报告为整数 $k$。", "solution": "该问题要求在一个由二进制伙伴系统管理的区域内，受限于几个保留子区域所施加的约束，找到一个完全空闲的连续内存块的最大阶数 $k$。\n\n首先，我们在一个离散框架中建立系统参数。总内存大小为 $M = 2^{20}$ 字节，最小可分配块大小为 $S_{\\min} = 2^{12}$ 字节，这对应于一个阶为 $k=0$ 的块。我们可以将整个内存区域建模为一个由 $N$ 个大小为 $S_{\\min}$ 的“基本块”组成的连续数组。这些块的数量为：\n$$N = \\frac{M}{S_{\\min}} = \\frac{2^{20} \\text{ 字节}}{2^{12} \\text{ 字节}} = 2^{8} = 256$$\n这些基本块可以从 $i=0$ 到 $i=255$ 进行索引。索引为 $i$ 的基本块的字节地址范围是 $[i \\cdot S_{\\min}, (i+1) \\cdot S_{\\min})$，计算结果为 $[i \\cdot 4096, (i+1) \\cdot 4096)$。\n\n接下来，我们必须确定哪些基本块因设备保留子区域而变得不可用。如果一个基本块的地址范围与任何指定的保留区域相交，则该基本块是不可用的。对于由半开区间 $[s, e)$ 给定的保留区域，如果基本块 $i$ 对应的区间 $[i \\cdot 4096, (i+1) \\cdot 4096)$ 与 $[s, e)$ 有非空交集，则该基本块会受到影响。受 $[s, e)$ 影响的基本块索引范围是从 $i_{start} = \\lfloor s / 4096 \\rfloor$ 到 $i_{end} = \\lfloor (e-1) / 4096 \\rfloor$。我们将此计算应用于每个保留子区域：\n1.  对于区域 $[1000, 6000)$：\n    $i_{start} = \\lfloor 1000 / 4096 \\rfloor = 0$。\n    $i_{end} = \\lfloor (6000 - 1) / 4096 \\rfloor = \\lfloor 5999 / 4096 \\rfloor = 1$。\n    受影响的基本块是索引为 $0$ 和 $1$ 的块。\n\n2.  对于区域 $[133632, 140120)$：\n    $i_{start} = \\lfloor 133632 / 4096 \\rfloor = 32$。\n    $i_{end} = \\lfloor (140120 - 1) / 4096 \\rfloor = \\lfloor 140119 / 4096 \\rfloor = 34$。\n    受影响的基本块是索引为 $32, 33, 34$ 的块。\n\n3.  对于区域 $[260096, 264192)$：\n    $i_{start} = \\lfloor 260096 / 4096 \\rfloor = 63$。\n    $i_{end} = \\lfloor (264192 - 1) / 4096 \\rfloor = \\lfloor 264191 / 4096 \\rfloor = 64$。\n    受影响的基本块是索引为 $63, 64$ 的块。\n\n4.  对于区域 $[717800, 725800)$：\n    $i_{start} = \\lfloor 717800 / 4096 \\rfloor = 175$。\n    $i_{end} = \\lfloor (725800 - 1) / 4096 \\rfloor = \\lfloor 725799 / 4096 \\rfloor = 177$。\n    受影响的基本块是索引为 $175, 176, 177$ 的块。\n\n5.  对于区域 $[918600, 920600)$：\n    $i_{start} = \\lfloor 918600 / 4096 \\rfloor = 224$。\n    $i_{end} = \\lfloor (920600 - 1) / 4096 \\rfloor = \\lfloor 920599 / 4096 \\rfloor = 224$。\n    受影响的基本块是索引为 $224$ 的块。\n\n通过取这些集合的并集，我们编制出不可用基本块的完整索引集，记为 $U$：\n$$U = \\{0, 1, 32, 33, 34, 63, 64, 175, 176, 177, 224\\}$$\n\n一个阶为 $k$ 的伙伴块大小为 $S_k = 2^{12} \\cdot 2^k$ 字节，对应于 $2^k$ 个基本块。对齐要求规定起始地址必须是 $S_k$ 的倍数。在我们的离散框架中，这意味着起始基本块索引（例如 $j$）必须是 $2^k$ 的倍数。这样一个块覆盖了基本块索引范围 $[j, j + 2^k - 1]$。要使该块“完全空闲”，其整个索引范围必须与不可用索引集 $U$ 不相交。\n\n我们在寻找最大的整数 $k$，使得存在一个整数 $m \\geq 0$，满足索引区间 $[m \\cdot 2^k, (m+1) \\cdot 2^k - 1]$ 与 $U$ 没有交集。最大可能的阶数是 $k=8$，它将覆盖整个区域（索引 $[0, 255]$）。我们按降序测试 $k$。\n\n测试 $k=6$：\n一个阶为 $6$ 的块由 $2^6 = 64$ 个基本块组成。可能的起始索引是 $64$ 的倍数，即 $0, 64, 128, 192$。我们检查相应的区间：\n-   索引为 $0$ 的块：对应于索引范围 $[0, 63]$。该范围与 $U$ 在 $\\{0, 1, 32, 33, 34, 63\\}$ 处相交。此块不空闲。\n-   索引为 $64$ 的块：对应于索引范围 $[64, 127]$。该范围与 $U$ 在 $\\{64\\}$ 处相交。此块不空闲。\n-   索引为 $128$ 的块：对应于索引范围 $[128, 191]$。该范围与 $U$ 在 $\\{175, 176, 177\\}$ 处相交。此块不空闲。\n-   索引为 $192$ 的块：对应于索引范围 $[192, 255]$。该范围与 $U$ 在 $\\{224\\}$ 处相交。此块不空闲。\n由于无法形成阶为 $6$ 的完全空闲块，因此最大可实现的阶数必须小于 $6$。\n\n测试 $k=5$：\n一个阶为 $5$ 的块由 $2^5 = 32$ 个基本块组成。可能的起始索引是 $32$ 的倍数：$0, 32, 64, 96, 128, 160, 192, 224$。我们寻找一个与 $U$ 不相交的区间。\n-   索引范围 $[0, 31]$：包含 $\\{0, 1\\} \\subset U$。不空闲。\n-   索引范围 $[32, 63]$：包含 $\\{32, 33, 34, 63\\} \\subset U$。不空闲。\n-   索引范围 $[64, 95]$：包含 $\\{64\\} \\subset U$。不空闲。\n-   索引范围 $[96, 127]$：我们检查其是否与 $U = \\{0, 1, 32, 33, 34, 63, 64, 175, 176, 177, 224\\}$ 相交。$U$ 中的任何元素都不在整数范围 $[96, 127]$ 内。因此，此块完全空闲。\n\n我们已经成功地找到了一个阶为 $k=5$ 的完全空闲块（具体来说，是对应于基本块索引 $[96, 127]$ 的那个）。由于我们已经证明了无法形成阶为 $k=6$ 的完全空闲块，因此可实现的最大连续阶数是 $5$。", "answer": "$$\\boxed{5}$$", "id": "3624835"}]}