{"hands_on_practices": [{"introduction": "内核内存分配器的核心挑战之一是高效地利用内存。此练习通过一个现实场景，引导您分析和解决“内碎片”问题——这是由于分配器提供的内存块大于实际请求而造成的空间浪费。通过基于实测工作负载数据优化分配策略，您将学习如何量化并最小化这种浪费，这是设计高性能分配器的关键一步。[@problem_id:3652158]", "problem": "一个内核使用分离式空闲列表分配器来管理小对象。每个大小为 $s$ 字节的分配请求都会被向上取整到满足 $c \\geq s$ 的最小可用大小类 $c$，并返回一个大小为 $c$ 的对象。对于一个大小为 $s$ 的请求，由大小类 $c$ 来满足时，其内部碎片定义为 $c - s$。预期内部碎片是在观测到的请求大小分布下，$c - s$ 的期望值。该分配器被限制为只能使用三个大小类，这些大小类从允许的集合 $C = \\{16, 32, 48, 64, 80, 96\\}$ 字节中选择，且最大的类固定为 $96$ 字节。\n\n你对系统进行检测，并获得了一个随时间稳定的请求大小的离散概率质量函数（PMF）。观测到的请求仅有以下大小（单位：字节）及其对应的概率：\n- $11$，概率为 $0.1$\n- $15$，概率为 $0.1$\n- $17$，概率为 $0.05$\n- $20$，概率为 $0.1$\n- $29$，概率为 $0.1$\n- $31$，概率为 $0.05$\n- $33$，概率为 $0.1$\n- $45$，概率为 $0.05$\n- $49$，概率为 $0.1$\n- $63$，概率为 $0.05$\n- $79$，概率为 $0.1$\n- $95$，概率为 $0.1$\n\n当前，分配器使用 $16$、$64$ 和 $96$ 字节这几个大小类，并表现出较高的内部碎片。你需要根据所述约束条件重新设计类的边界，以最小化预期内部碎片。\n\n从上述定义和观测到的 PMF 出发，通过从集合 $C$ 中选择最优的三个大小类（最大类固定为 $96$ 字节），计算可实现的最小预期内部碎片（单位：每请求字节数）。将你的答案四舍五入到四位有效数字。以“每请求字节数”为单位表示最终结果。", "solution": "首先对问题陈述进行验证过程。\n\n### 步骤 1：提取已知信息\n- **分配器类型**：用于小对象的分离式空闲列表分配器。\n- **分配规则**：大小为 $s$ 的请求向上取整到满足 $c \\geq s$ 的最小可用大小类 $c$。\n- **内部碎片的定义**：对于大小为 $s$ 的请求，由大小类 $c$ 来满足，其内部碎片为 $c - s$。\n- **目标**：最小化预期内部碎片，即在给定的请求大小分布下，$c - s$ 的期望值。\n- **大小类的约束条件**：\n    - 必须恰好使用三个大小类。\n    - 大小类必须从集合 $C = \\{16, 32, 48, 64, 80, 96\\}$ 字节中选择。\n    - 三个类中最大的一个固定为 $96$ 字节。\n- **请求大小（$s_i$，单位：字节）及其概率（$p_i$）的概率质量函数（PMF）**：\n    - $s_1=11$, $p_1=0.1$\n    - $s_2=15$, $p_2=0.1$\n    - $s_3=17$, $p_3=0.05$\n    - $s_4=20$, $p_4=0.1$\n    - $s_5=29$, $p_5=0.1$\n    - $s_6=31$, $p_6=0.05$\n    - $s_7=33$, $p_7=0.1$\n    - $s_8=45$, $p_8=0.05$\n    - $s_9=49$, $p_9=0.1$\n    - $s_{10}=63$, $p_{10}=0.05$\n    - $s_{11}=79$, $p_{11}=0.1$\n    - $s_{12}=95$, $p_{12}=0.1$\n- **当前（非最优）的类**：$\\{16, 64, 96\\}$ 字节。\n- **要求输出**：可实现的最小预期内部碎片，四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据指定标准对问题进行验证。\n- **科学性**：该问题在计算机科学领域，特别是操作系统设计方面，有充分的理论基础。分离式列表分配器、大小类和内部碎片等概念是内存管理中的基本主题。所提出的模型是一个标准（尽管是简化的）的真实世界工程设计问题的表示。\n- **适定性**：该问题是适定的。它定义了一个清晰的待最小化目标函数（预期内部碎片），一个离散且有限的优化变量（两个较小的大小类）选择集，并提供了所有必要的数据（请求大小的PMF）。搜索空间是有限的，保证了最小值的存在且是可计算的。给定概率的总和是 $\\sum p_i = 0.1+0.1+0.05+0.1+0.1+0.05+0.1+0.05+0.1+0.05+0.1+0.1 = 1.0$。PMF是有效的。\n- **客观性**：问题以精确、客观的语言陈述。所有的定义、约束和数据都是定量的且无歧义的。\n\n该问题没有验证标准中列出的任何缺陷。它在科学上是合理的，定义是完整的，并且计算上是可行的。\n\n### 步骤 3：结论与行动\n问题是 **有效的**。将提供解答。\n\n### 解答\n目标是找到一组由三个大小类 $\\{c_1, c_2, c_3\\}$ 组成的集合，以最小化预期内部碎片 $E[F]$。对于一个大小为 $s$ 的请求，从大小为 $c(s)$ 的块中分配时，碎片定义为 $F = c(s) - s$。预期碎片是每个请求大小的碎片之和，并按其概率加权：\n$$E[F] = \\sum_{i} p_i (c(s_i) - s_i)$$\n其中 $s_i$ 是请求大小，$p_i$ 是它们的概率，$c(s_i)$ 是大于或等于 $s_i$ 的最小类大小。\n\n约束条件是：\n1. 大小类从集合 $C = \\{16, 32, 48, 64, 80, 96\\}$ 中选择。\n2. 恰好有三个类，所以类集合是 $\\{c_1, c_2, c_3\\}$，且 $c_1  c_2  c_3$。\n3. 最大的类是固定的：$c_3 = 96$。\n\n这意味着我们必须从集合 $\\{16, 32, 48, 64, 80\\}$ 中选择两个类 $c_1$ 和 $c_2$，使得 $c_1  c_2$。可能的配对 $(c_1, c_2)$ 的数量由二项式系数 $\\binom{5}{2} = \\frac{5 \\times 4}{2} = 10$ 给出。我们必须为这 $10$ 种配置中的每一种计算预期碎片，并找出最小值。\n\nPMF 如下：\n$P(s=11)=0.1$, $P(s=15)=0.1$, $P(s=17)=0.05$, $P(s=20)=0.1$, $P(s=29)=0.1$, $P(s=31)=0.05$, $P(s=33)=0.1$, $P(s=45)=0.05$, $P(s=49)=0.1$, $P(s=63)=0.05$, $P(s=79)=0.1$, $P(s=95)=0.1$。\n\n对于任意选择的类 $\\{c_1, c_2, 96\\}$，大小为 $s$ 的请求分配如下：\n- 如果 $s \\le c_1$，则由类 $c_1$ 服务。\n- 如果 $c_1  s \\le c_2$，则由类 $c_2$ 服务。\n- 如果 $c_2  s \\le 96$，则由类 $96$ 服务。\n所有给定的请求大小都 $\\le 95$，因此它们都是可以服务的。\n\n我们现在系统地计算 $10$ 种可能的类集合中每一种的预期碎片 $E[F]$。\n\n1.  **类 $\\{16, 32, 96\\}$**：\n    $E[F] = 0.1(16-11) + 0.1(16-15) + 0.05(32-17) + 0.1(32-20) + 0.1(32-29) + 0.05(32-31) + 0.1(96-33) + 0.05(96-45) + 0.1(96-49) + 0.05(96-63) + 0.1(96-79) + 0.1(96-95) = 19.9$ 字节/请求。\n\n2.  **类 $\\{16, 48, 96\\}$**：\n    $E[F] = 0.1(16-11) + 0.1(16-15) + 0.05(48-17) + 0.1(48-20) + 0.1(48-29) + 0.05(48-31) + 0.1(48-33) + 0.05(48-45) + 0.1(96-49) + 0.05(96-63) + 0.1(96-79) + 0.1(96-95) = 17.5$ 字节/请求。\n\n3.  **类 $\\{16, 64, 96\\}$** （当前配置）：\n    $E[F] = 0.1(16-11) + 0.1(16-15) + 0.05(64-17) + 0.1(64-20) + 0.1(64-29) + 0.05(64-31) + 0.1(64-33) + 0.05(64-45) + 0.1(64-49) + 0.05(64-63) + 0.1(96-79) + 0.1(96-95) = 19.9$ 字节/请求。\n\n4.  **类 $\\{16, 80, 96\\}$**：\n    $E[F] = 0.1(16-11) + 0.1(16-15) + 0.05(80-17) + \\dots + 0.1(80-79) + 0.1(96-95) = 27.9$ 字节/请求。\n\n5.  **类 $\\{32, 48, 96\\}$**：\n    $E[F] = 0.1(32-11) + 0.1(32-15) + 0.05(32-17) + 0.1(32-20) + 0.1(32-29) + 0.05(32-31) + 0.1(48-33) + 0.05(48-45) + 0.1(96-49) + \\dots + 0.1(96-95) = 15.9$ 字节/请求。\n\n6.  **类 $\\{32, 64, 96\\}$**：\n    $E[F] = [0.1(32-11) + 0.1(32-15) + 0.05(32-17) + 0.1(32-20) + 0.1(32-29) + 0.05(32-31)] + [0.1(64-33) + 0.05(64-45) + 0.1(64-49) + 0.05(64-63)] + [0.1(96-79) + 0.1(96-95)]$\n    $E[F] = [2.1 + 1.7 + 0.75 + 1.2 + 0.3 + 0.05] + [3.1 + 0.95 + 1.5 + 0.05] + [1.7 + 0.1]$\n    $E[F] = 6.1 + 5.6 + 1.8 = 13.5$ 字节/请求。\n\n7.  **类 $\\{32, 80, 96\\}$**：\n    $E[F] = 6.1 + [0.1(80-33) + \\dots + 0.1(80-79)] + [0.1(96-95)] = 16.7$ 字节/请求。\n\n8.  **类 $\\{48, 64, 96\\}$**：\n    $E[F] = [0.1(48-11) + \\dots + 0.05(48-45)] + [0.1(64-49) + 0.05(64-63)] + [0.1(96-79) + 0.1(96-95)] = 19.1$ 字节/请求。\n\n9.  **类 $\\{48, 80, 96\\}$**：\n    $E[F] = [0.1(48-11) + \\dots + 0.05(48-45)] + [0.1(80-49) + \\dots + 0.1(80-79)] + [0.1(96-95)] = 19.9$ 字节/请求。\n\n10. **类 $\\{64, 80, 96\\}$**：\n    $E[F] = [0.1(64-11) + \\dots + 0.05(64-63)] + [0.1(80-79)] + [0.1(96-95)] = 27.9$ 字节/请求。\n\n每种配置的预期碎片总结如下：\n- $\\{16, 32, 96\\}: 19.9$\n- $\\{16, 48, 96\\}: 17.5$\n- $\\{16, 64, 96\\}: 19.9$\n- $\\{16, 80, 96\\}: 27.9$\n- $\\{32, 48, 96\\}: 15.9$\n- $\\{32, 64, 96\\}: 13.5$\n- $\\{32, 80, 96\\}: 16.7$\n- $\\{48, 64, 96\\}: 19.1$\n- $\\{48, 80, 96\\}: 19.9$\n- $\\{64, 80, 96\\}: 27.9$\n\n最小值为 $13.5$，这是通过大小类 $\\{32, 64, 96\\}$ 实现的。\n问题要求答案四舍五入到四位有效数字。值 $13.5$ 写成 $13.50$ 以满足此要求。\n可实现的最小预期内部碎片是 $13.50$ 字节/请求。", "answer": "$$\\boxed{13.50}$$", "id": "3652158"}, {"introduction": "除了应对内存碎片，分配器本身的管理开销也是一个重要的效率考量。此练习将对比两种管理元数据的基本策略：将元数据与每个对象存储在一起，或将其外部化集中管理。通过计算和比较这两种设计下的元数据开销，您将深入理解其各自的优缺点，并体会到“slab”式分配器设计的精妙之处。[@problem_id:3652204]", "problem": "一个内核内存分配器必须满足一个包含 $n$ 个大小相等的对象的请求流。每个对象的负载大小为 $s$ 字节。在一个朴素的“按对象”方案中，每个分配的对象都携带一个大小为 $h$ 字节的头部，用于存储分配器的元数据。在一个外部化方案中，元数据被移出单个对象，并以固定大小的区域（一个“slab”）为粒度进行分组：每个 slab 保留 $H$ 字节的元数据，并提供 $S$ 字节用于对象负载，没有按对象的头部。对象在 slab 中被紧密打包，没有额外的填充。假设没有其他开销来源，并且 slab 按需使用以顺序放置对象。\n\n仅使用以下基本定义：\n- 分配器元数据开销是分配器使用的、不属于应用程序负载的总字节数。\n- 一个 slab 中能容纳的对象数量是不超过 slab 中可用负载字节数与对象负载大小之比的最大整数。\n- 所需的 slab 数量是其总对象容量至少为 $n$ 的 slab 的最小整数数量。\n\n取 $s = 96$ 字节, $h = 24$ 字节, $S = 4096$ 字节, 以及 $H = 128$ 字节。对于两种设计，请从第一性原理推导出作为 $n$ 的函数的总分配器元数据开销。然后确定最小整数 $n^{\\star}$，使得外部化方案使用的元数据字节数严格少于“按对象”方案。\n\n最终答案仅提供 $n^{\\star}$ 的值。无需四舍五入，$n^{\\star}$ 也不需要单位（它是一个对象计数）。", "solution": "我们首先根据问题定义，分别为两种方案推导元数据开销的函数。\n\n### 1. “按对象”方案的开销\n在这种设计中，每个对象都附带一个大小为 $h$ 的元数据头部。因此，为 $n$ 个对象分配内存时，总的元数据开销 $O_p(n)$ 是头部大小与对象数量的乘积。\n$$O_p(n) = n \\times h$$\n\n### 2. 外部化（Slab）方案的开销\n在这种设计中，元数据开销来自每个所使用的“slab”的头部。我们需要先计算需要多少个 slab。\n\n首先，计算一个 slab 能容纳多少个对象。每个 slab 提供 $S$ 字节的负载空间，每个对象的负载大小为 $s$。因此，单个 slab 可容纳的对象数量 $k$ 是：\n$$k = \\left\\lfloor \\frac{S}{s} \\right\\rfloor$$\n\n接下来，计算为了容纳 $n$ 个对象需要多少个 slab。这是 $n$ 除以 $k$ 的结果向上取整，我们记为 $N_{slabs}(n)$：\n$$N_{slabs}(n) = \\left\\lceil \\frac{n}{k} \\right\\rceil$$\n\n每个 slab 的元数据开销为 $H$。因此，总的元数据开销 $O_e(n)$ 是 slab 数量与每个 slab 头部大小的乘积：\n$$O_e(n) = N_{slabs}(n) \\times H = \\left\\lceil \\frac{n}{k} \\right\\rceil \\times H$$\n\n### 3. 求解 $n^{\\star}$\n我们要找的是最小的整数 $n^{\\star}$，使得外部化方案的开销严格小于“按对象”方案的开销，即 $O_e(n^{\\star})  O_p(n^{\\star})$。\n\n代入给定的参数：\n- $s = 96$ 字节\n- $h = 24$ 字节\n- $S = 4096$ 字节\n- $H = 128$ 字节\n\n首先计算每个 slab 能容纳的对象数量 $k$：\n$$k = \\left\\lfloor \\frac{4096}{96} \\right\\rfloor = \\lfloor 42.666... \\rfloor = 42$$\n\n现在，我们的不等式是：\n$$\\left\\lceil \\frac{n}{42} \\right\\rceil \\times 128  n \\times 24$$\n\n我们需要找到满足这个不等式的最小整数 $n$。我们可以从小到大测试 $n$ 的值。\n\n当 $1 \\le n \\le 42$ 时，$\\lceil \\frac{n}{42} \\rceil = 1$。不等式简化为：\n$$1 \\times 128  24n$$\n$$128  24n$$\n$$n > \\frac{128}{24} = \\frac{16}{3} \\approx 5.333$$\n\n由于 $n$ 必须是整数，满足此条件的最小整数是 $n=6$。\n\n我们可以验证一下：\n- 对于 $n=5$，$O_e(5) = \\lceil 5/42 \\rceil \\times 128 = 1 \\times 128 = 128$。$O_p(5) = 5 \\times 24 = 120$。$128 \\not 120$。\n- 对于 $n=6$，$O_e(6) = \\lceil 6/42 \\rceil \\times 128 = 1 \\times 128 = 128$。$O_p(6) = 6 \\times 24 = 144$。$128  144$。\n\n因此，使得外部化方案开销更小的最小对象数量是 $n^{\\star}=6$。", "answer": "$$\\boxed{6}$$", "id": "3652204"}, {"introduction": "内核代码的执行环境并非总是理想的，特别是在中断处理等严苛的上下文中。此练习探讨了在中断服务程序中进行内存分配的极端情况，此时系统绝不允许任何形式的阻塞。您将推导出为何必须采用预留内存池的无锁分配方案，并学习如何根据峰值负载精确计算该内存池的大小，以确保系统的稳定性和响应性。[@problem_id:3652214]", "problem": "一个在单中央处理器（CPU）上运行的内核必须在中断处理程序期间执行固定大小的内存分配。在中断上下文中，抢占被禁用，并且禁止休眠。通用分配器可能会阻塞（例如，在等待互斥锁时），也可能触发页错误，这两者在中断上下文中都是不允许的。为保证系统能继续运行，内核设计者考虑使用一个专用于中断时分配的、预留的、每CPU、无锁的对象池。每次中断会立即从此池中分配恰好 $n$ 个对象，持有它们一段有界时间 $t_{h}$，然后将它们释放回池中。在持续峰值负载下，中断以速率 $\\lambda$ 到达该CPU。假设到达过程使得峰值速率 $\\lambda$ 可以维持足够长的时间，以至于在 $t_{h}$ 上的稳态平均是有意义的，并假设在中断上下文中不会发生从通用分配器进行的补充。\n\n从中断上下文施加的约束以及到达与释放之间的流量守恒原则出发，推导出中断上下文中的任何分配路径都必须是非阻塞的，并且必须完全由预留池来满足的要求。然后，仅使用关于对象到达速率和在系统中停留时间关系的第一性原理推理，得出一个为维持峰值中断速率而不发生分配失败所需的最小池容量 $P$（以对象数量计）的表达式。\n\n最后，根据以下参数计算您的表达式的值：\n- 峰值中断速率 $\\lambda = 1.2 \\times 10^{5}$ 中断/秒。\n- 每次中断的对象数 $n = 2$。\n- 每次中断的持有时间 $t_{h} = 2.0 \\times 10^{-4}$ 秒。\n\n将最终的 $P$ 表示为对象的纯计数（无单位）。无需进行舍入；报告在所述峰值条件下避免分配失败所需的确切整数。", "solution": "该问题是有效的。它在科学上基于操作系统设计的原理，特别是在像中断处理程序这样的受限执行上下文中的内存管理。问题提法恰当，提供了推导唯一且有意义的解决方案所需的所有信息。语言是客观的，该场景是计算机系统性能分析中的一个经典、可形式化的问题。\n\n问题的第一部分要求推导在中断上下文中使用来自预留池的非阻塞分配路径的必要性。在单个中央处理器（CPU）上的中断处理程序的基本约束是抢占被禁用，并且处理程序不能休眠或阻塞。禁用抢占可确保处理程序运行至完成，而不会被同一CPU上的其他任务中断。如果中断处理程序发生阻塞（例如，等待锁）或休眠（例如，在页错误后等待I/O），它将停止该CPU上的所有处理，导致系统冻结和潜在的死锁。通用内存分配器不适用于此上下文，因为它可能需要获取锁来管理全局堆，或者它可能尝试分配非物理驻留的内存，从而触发页错误。页错误是一个阻塞事件。因此，为保证系统能继续运行和稳定性，中断处理程序内的任何分配都必须来自一个保证非阻塞且不会导致页错误的分配器。一个预留的、每CPU、无锁的对象池满足这些严格的要求。内存是预先分配的，确保其驻留，而无锁设计确保分配请求可以在不阻塞的情况下得到满足。\n\n问题的第二部分要求推导维持峰值工作负载所需的最小池容量 $P$。这可以通过基于流量守恒的第一性原理论证来确定，该论证由排队论中的利特尔法则（Little's Law）形式化。设 $\\lambda$ 为单位时间的中断速率，$n$ 为每次中断分配的对象数量，$t_h$ 为每个对象被持有的固定时间。\n\n从池中分配对象的速率是中断速率与每次中断对象数的乘积。设此分配速率为 $R_{alloc}$。\n$$R_{alloc} = n \\lambda$$\n问题陈述系统处于持续峰值负载，这意味着一个稳态条件，其中对象分配的速率等于对象释放的速率。在时间 $t$ 分配的对象将在时间 $t + t_h$ 被释放。在任何给定时刻，当前正在使用的对象集（已分配但尚未释放）由在之前持续时间为 $t_h$ 的时间间隔内分配的所有对象组成。\n\n在任何时候正在使用的对象总数，我们记为 $N_{in\\_use}$，是对象分配速率和持有时间的乘积。\n$$N_{in\\_use} = R_{alloc} \\times t_h$$\n代入 $R_{alloc}$ 的表达式，我们得到：\n$$N_{in\\_use} = (n \\lambda) t_h$$\n为防止分配失败，池必须足够大以容纳所有同时在使用的对象。当池为空时发生分配请求，该请求就会失败。在指定的持续峰值负载下，正在使用的对象数量是恒定的。因此，池的最小容量 $P$ 必须等于这个数量。\n$$P = n \\lambda t_h$$\n此表达式给出了为确保在持续峰值中断速率 $\\lambda$ 下分配请求永不失败，池中所需的最小对象数量。\n\n最后，我们用给定的参数计算这个表达式的值：\n- 峰值中断速率 $\\lambda = 1.2 \\times 10^{5}$ 中断/秒。\n- 每次中断的对象数 $n = 2$。\n- 每次中断的持有时间 $t_{h} = 2.0 \\times 10^{-4}$ 秒。\n\n将这些值代入推导出的 $P$ 的公式中：\n$$P = (2) \\times (1.2 \\times 10^{5} \\, \\text{s}^{-1}) \\times (2.0 \\times 10^{-4} \\, \\text{s})$$\n$$P = 2 \\times 1.2 \\times 2.0 \\times 10^{5} \\times 10^{-4}$$\n$$P = 4.8 \\times 10^{5-4}$$\n$$P = 4.8 \\times 10^{1}$$\n$$P = 48$$\n所需的最小池容量为 $48$ 个对象。由于计算结果为一个精确整数，因此这是在指定峰值条件下避免分配失败所需的精确最小对象数。", "answer": "$$\\boxed{48}$$", "id": "3652214"}]}