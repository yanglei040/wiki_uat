{"hands_on_practices": [{"introduction": "步长调度（Stride Scheduling）是一种确定性的按比例共享调度算法，它通过为每个任务维护一个“步长”（stride）和“通行证”（pass）值来实现公平性。现实世界的操作系统，如 Linux，通常采用分层结构（例如，控制组 cgroups）来管理任务组的资源。这个练习将让你亲手模拟一个两级调度过程，从而加深对分层按比例共享机制工作原理的理解。[@problem_id:3673648]", "problem": "考虑一个运行分层比例份额调度器的单核中央处理器（CPU）。两个控制组（cgroups）$G_{1}$ 和 $G_{2}$ 竞争 CPU；在每个 cgroup 内部，任务根据其各自的任务份额进行竞争。调度器使用分层步进调度（hierarchical stride scheduling）来实现比例份额分配。在 cgroup 级别，调度器维护每个 cgroup 的通行值（pass value）和步进值（stride）。在每次调度决策时，它选择具有最小通行值的 cgroup（若出现平局，则选择数值索引较小的 cgroup），然后将该 cgroup 的通行值增加其步进值。在选定的 cgroup 内部，调度器维护每个任务的通行值和步进值，选择具有最小通行值的任务（若出现平局，则选择数值索引较小的任务），然后将该任务的通行值增加其步进值。所有通行值初始为 $0$。\n\n给定以下配置：\n- Cgroup 份额：$S_{G_{1}} = 3$，$S_{G_{2}} = 2$。\n- $G_{1}$ 中的任务份额：任务 $T_{1}$ 的份额为 $s_{1} = 2$，任务 $T_{2}$ 的份额为 $s_{2} = 1$。\n- $G_{2}$ 中的任务份额：任务 $T_{3}$ 的份额为 $s_{3} = 1$，任务 $T_{4}$ 的份额为 $s_{4} = 3$。\n\n分层步进调度使用以下步进常数：\n- cgroups 的全局常数 $K = 30$，由此得出 cgroup 的步进值为 $\\text{stride}(G_{i}) = \\frac{K}{S_{G_{i}}}$。\n- $G_{1}$ 的 cgroup 局部常数为 $K_{1} = 12$，$G_{2}$ 的 cgroup 局部常数为 $K_{2} = 12$，由此得出每个 cgroup 内任务的步进值为 $\\text{stride}(T_{j}) = \\frac{K_{g}}{s_{j}}$，其中 $K_{g}$ 是包含任务 $T_{j}$ 的 cgroup 的常数。\n\n任务的全局标识符定义如下：$T_{1}$ 的标识符为 $1$，$T_{2}$ 的标识符为 $2$，$T_{3}$ 的标识符为 $3$，$T_{4}$ 的标识符为 $4$。\n\n从所有通行值等于 $0$ 开始，计算在第 $11$ 次调度决策时被选中的任务的全局标识符（一个整数）。不需要四舍五入；请提供最终的整数标识符。", "solution": "该问题要求确定一个分层比例份额调度器在第 $11$ 个决策点调度的任务。调度策略被指定为分层步进调度。该过程是确定性的，由控制组（cgroups）和单个任务的通行值和步进值决定。\n\n首先，我们必须计算所有可调度实体的步进值。步进值与份额成反比，使用给定的常数计算。\n\ncgroup 的份额为 $S_{G_{1}} = 3$ 和 $S_{G_{2}} = 2$。cgroups 的全局常数为 $K = 30$。每个 cgroup 的步进值 $\\text{stride}(G_i)$ 由 $\\frac{K}{S_{G_i}}$ 给出。\ncgroup $G_1$ 的步进值为：\n$$ \\text{stride}(G_{1}) = \\frac{K}{S_{G_{1}}} = \\frac{30}{3} = 10 $$\ncgroup $G_2$ 的步进值为：\n$$ \\text{stride}(G_{2}) = \\frac{K}{S_{G_{2}}} = \\frac{30}{2} = 15 $$\n\n接下来，我们计算每个 cgroup 内任务的步进值。\n对于 cgroup $G_1$，任务为 $T_1$（份额 $s_1 = 2$）和 $T_2$（份额 $s_2 = 1$）。cgroup 局部常数为 $K_1 = 12$。该组中任务 $T_j$ 的步进值为 $\\frac{K_1}{s_j}$。\n任务 $T_1$ 的步进值为：\n$$ \\text{stride}(T_{1}) = \\frac{K_1}{s_{1}} = \\frac{12}{2} = 6 $$\n任务 $T_2$ 的步进值为：\n$$ \\text{stride}(T_{2}) = \\frac{K_1}{s_{2}} = \\frac{12}{1} = 12 $$\n\n对于 cgroup $G_2$，任务为 $T_3$（份额 $s_3 = 1$）和 $T_4$（份额 $s_4 = 3$）。cgroup 局部常数为 $K_2 = 12$。该组中任务 $T_j$ 的步进值为 $\\frac{K_2}{s_j}$。\n任务 $T_3$ 的步进值为：\n$$ \\text{stride}(T_{3}) = \\frac{K_2}{s_{3}} = \\frac{12}{1} = 12 $$\n任务 $T_4$ 的步进值为：\n$$ \\text{stride}(T_{4}) = \\frac{K_2}{s_{4}} = \\frac{12}{3} = 4 $$\n\n所有 cgroups 和任务的初始通行值为 $0$。设 $P(X)$ 表示实体 $X$ 的通行值。\n初始状态：$P(G_1) = 0$，$P(G_2) = 0$，$P(T_1) = 0$，$P(T_2) = 0$，$P(T_3) = 0$，$P(T_4) = 0$。\n我们现在模拟 $11$ 个步骤的调度过程。\n\n步骤 1：\n- Cgroup 选择：$P(G_1) = 0$ 且 $P(G_2) = 0$。平局由较小索引打破，因此选择 $G_1$。\n- 任务选择（在 $G_1$ 内）：$P(T_1) = 0$ 且 $P(T_2) = 0$。平局由较小索引打破，因此选择 $T_1$。\n- 调度对象：$T_1$。\n- 更新通行值：$P(T_1) \\leftarrow P(T_1) + \\text{stride}(T_1) = 0 + 6 = 6$。$P(G_1) \\leftarrow P(G_1) + \\text{stride}(G_1) = 0 + 10 = 10$。\n\n步骤 2：\n- Cgroup 选择：$P(G_1) = 10$, $P(G_2) = 0$。选择 $G_2$。\n- 任务选择（在 $G_2$ 内）：$P(T_3) = 0$, $P(T_4) = 0$。平局，选择 $T_3$。\n- 调度对象：$T_3$。\n- 更新通行值：$P(T_3) \\leftarrow 0 + 12 = 12$。$P(G_2) \\leftarrow 0 + 15 = 15$。\n\n步骤 3：\n- Cgroup 选择：$P(G_1) = 10$, $P(G_2) = 15$。选择 $G_1$。\n- 任务选择（在 $G_1$ 内）：$P(T_1) = 6$, $P(T_2) = 0$。选择 $T_2$。\n- 调度对象：$T_2$。\n- 更新通行值：$P(T_2) \\leftarrow 0 + 12 = 12$。$P(G_1) \\leftarrow 10 + 10 = 20$。\n\n步骤 4：\n- Cgroup 选择：$P(G_1) = 20$, $P(G_2) = 15$。选择 $G_2$。\n- 任务选择（在 $G_2$ 内）：$P(T_3) = 12$, $P(T_4) = 0$。选择 $T_4$。\n- 调度对象：$T_4$。\n- 更新通行值：$P(T_4) \\leftarrow 0 + 4 = 4$。$P(G_2) \\leftarrow 15 + 15 = 30$。\n\n步骤 5：\n- Cgroup 选择：$P(G_1) = 20$, $P(G_2) = 30$。选择 $G_1$。\n- 任务选择（在 $G_1$ 内）：$P(T_1) = 6$, $P(T_2) = 12$。选择 $T_1$。\n- 调度对象：$T_1$。\n- 更新通行值：$P(T_1) \\leftarrow 6 + 6 = 12$。$P(G_1) \\leftarrow 20 + 10 = 30$。\n\n步骤 6：\n- Cgroup 选择：$P(G_1) = 30$, $P(G_2) = 30$。平局，选择 $G_1$。\n- 任务选择（在 $G_1$ 内）：$P(T_1) = 12$, $P(T_2) = 12$。平局，选择 $T_1$。\n- 调度对象：$T_1$。\n- 更新通行值：$P(T_1) \\leftarrow 12 + 6 = 18$。$P(G_1) \\leftarrow 30 + 10 = 40$。\n\n步骤 7：\n- Cgroup 选择：$P(G_1) = 40$, $P(G_2) = 30$。选择 $G_2$。\n- 任务选择（在 $G_2$ 内）：$P(T_3) = 12$, $P(T_4) = 4$。选择 $T_4$。\n- 调度对象：$T_4$。\n- 更新通行值：$P(T_4) \\leftarrow 4 + 4 = 8$。$P(G_2) \\leftarrow 30 + 15 = 45$。\n\n步骤 8：\n- Cgroup 选择：$P(G_1) = 40$, $P(G_2) = 45$。选择 $G_1$。\n- 任务选择（在 $G_1$ 内）：$P(T_1) = 18$, $P(T_2) = 12$。选择 $T_2$。\n- 调度对象：$T_2$。\n- 更新通行值：$P(T_2) \\leftarrow 12 + 12 = 24$。$P(G_1) \\leftarrow 40 + 10 = 50$。\n\n步骤 9：\n- Cgroup 选择：$P(G_1) = 50$, $P(G_2) = 45$。选择 $G_2$。\n- 任务选择（在 $G_2$ 内）：$P(T_3) = 12$, $P(T_4) = 8$。选择 $T_4$。\n- 调度对象：$T_4$。\n- 更新通行值：$P(T_4) \\leftarrow 8 + 4 = 12$。$P(G_2) \\leftarrow 45 + 15 = 60$。\n\n步骤 10：\n- Cgroup 选择：$P(G_1) = 50$, $P(G_2) = 60$。选择 $G_1$。\n- 任务选择（在 $G_1$ 内）：$P(T_1) = 18$, $P(T_2) = 24$。选择 $T_1$。\n- 调度对象：$T_1$。\n- 更新通行值：$P(T_1) \\leftarrow 18 + 6 = 24$。$P(G_1) \\leftarrow 50 + 10 = 60$。\n\n步骤 11：\n- Cgroup 选择：$P(G_1) = 60$, $P(G_2) = 60$。平局，选择 $G_1$。\n- 任务选择（在 $G_1$ 内）：$P(T_1) = 24$, $P(T_2) = 24$。平局，选择 $T_1$。\n- 调度对象：$T_1$。\n\n在第 $11$ 次调度决策时选择的任务是 $T_1$。问题要求该任务的全局标识符。$T_1$ 的标识符被给定为 $1$。", "answer": "$$ \\boxed{1} $$", "id": "3673648"}, {"introduction": "理论算法通常假设使用无限精度的数字，但在真实的计算机中，我们必须处理有限位数的整数，这会带来一些微妙的挑战。本练习探讨了步长调度中一个关键的实现细节：当累加器（pass 值）超出整数表示范围时发生的回绕（wraparound）问题。你需要分析一个由于朴素比较而导致调度出现偏差的场景，并找出一个能够安全处理模运算、维护调度公平性的正确比较方法。[@problem_id:3673643]", "problem": "一个操作系统 (OS) 在单个中央处理器 (CPU) 上使用一个实现了步幅调度的比例份额调度器。每个进程 $i$ 有一个固定的正整数步幅 $s_i$ 和一个非递减的累加器 $pass_i$，每当该进程运行时，$pass_i$ 的值就增加 $s_i$。在每个选择步骤中，调度器在所有就绪进程中选择 $pass_i$ 值最小的进程，然后运行它一个时间片，并更新其 $pass_i := pass_i + s_i$。累加器 $pass_i$ 存储在一个 $N$ 位无符号整数中，因此其值在模数为 $2^N$ 的模运算下演变。\n\n基本事实：\n- 比例份额公平性是通过选择具有最小累积服务度量 $pass_i$ 的进程来实现的，因为较小的 $pass_i$ 表示到目前为止在调度器的伸缩轴上提供的服务较少。\n- 固定宽度的机器整数执行模 $2^N$ 的算术运算：对于任何整数 $x, y$，机器级的和是 $(x + y) \\bmod 2^N$。\n\n考虑 $N = 8$ 的情况，此时算术运算是模 $2^8 = 256$。三个进程 $P_1, P_2, P_3$ 的步幅分别为 $s_1 = 60$, $s_2 = 30$, $s_3 = 20$。在某次选择步骤之前，累加器的值是\n$$pass_1 = 240,\\quad pass_2 = 250,\\quad pass_3 = 245.$$\n假设系统在前一步刚刚调度了 $P_1$ 并更新了 $pass_1 := pass_1 + s_1$。由于 $N=8$，此更新为\n$$pass_1 := (240 + 60) \\bmod 256 = 300 \\bmod 256 = 44.$$\n因此，当前选择步骤的状态是\n$$pass_1 = 44,\\quad pass_2 = 250,\\quad pass_3 = 245.$$\n\n从基本原理出发：\n- 预期的顺序是真实（概念上）的非模 $pass$ 值的顺序，但机器只存储模 $2^N$ 的余数。\n- 一种朴素的无符号比较方法，直接使用 $\\{0,1,\\dots,2^N-1\\}$ 上的常规“小于”关系对余数进行排序，这可能在回绕点附近错误地排序值并使调度器产生偏差，因为一个刚刚超过回绕点的大真值（例如 $300$）在数值上会显得很小（例如 $44$）。任何正确的比较都必须尊重模运算和二进制补码表示，以便在两两之间的差值在半个范围内时，能够再现底层非模 $pass$ 值的预期顺序。\n\n假设系统被配置为：对于任意两个同时就绪的进程 $i$ 和 $j$，它们的 $pass$ 值的真实（非模）差值位于 $(-2^{N-1}, 2^{N-1})$ 区间内，这里该条件是满足的，因为没有单次增量超过 $2^{N-1}$ 且更新频繁发生。\n\n下列哪个/哪些选项既能正确处理回绕偏差，又能在给定状态下，通过一个模安全的最小比较器识别出下一个被选择的进程？选择所有适用的选项。\n\nA. 使用 $\\{0,\\dots,2^N-1\\}$ 上的常规无符号小于比较：选择存储的 $pass_i$ 值在数值上最小的进程。在给定状态下，这将选择 $P_1$，因为 $44$ 是最小的。\n\nB. 通过计算 $d := (a - b) \\bmod 2^N$ 并将 $d$ 解释为 $\\{-2^{N-1},\\dots,2^{N-1}-1\\}$ 中的有符号二进制补码整数来定义比较 $a \\prec b$。那么当且仅当 $d  0$ 时，$a \\prec b$。在给定状态下，这将选择 $P_3$。\n\nC. 定义当且仅当无符号差 $(a - b)$ 小于 $2^{N-1}$ 时，$a \\prec b$。在给定状态下，这将选择 $P_1$。\n\nD. 当任何加法溢出时，将所有 $pass_i$ 重置为 $0$ 以消除回绕，因为较小的值意味着较少的服务。在给定状态下，下一个选择应该是步幅最小的进程（即 $P_3$）。\n\nE. 等效于有符号比较，将原点移动 $2^{N-1}$：定义当且仅当使用无符号小于比较时，$((a + 2^{N-1}) \\bmod 2^N)  ((b + 2^{N-1}) \\bmod 2^N)$，$a \\prec b$。在给定状态下，这将选择 $P_3$。", "solution": "我们从比例份额步幅调度和固定宽度整数上的模运算的核心定义开始。\n\n1. 比例份额步幅调度：\n- 每个进程 $i$ 有一个步幅 $s_i \\in \\mathbb{N}$ 和一个累加器 $pass_i \\in \\mathbb{Z}$，后者概念化了总的伸缩服务量。\n- 调度器选择 $pass_i$ 最小的进程，运行一个时间片，然后设置 $pass_i := pass_i + s_i$。\n- 这个机制产生的分配与 $1/s_i$ 成正比，因为较小的步幅意味着更频繁的选择，以保持 $pass$ 值接近。\n\n2. 固定宽度整数算术：\n- 在硬件上，$pass_i$ 被存储为 $N$ 位无符号整数，因此所有更新都是模 $2^N$ 计算的。\n- 因此，对于任何更新 $pass_i := pass_i + s_i$，存储的值变为 $(pass_i + s_i) \\bmod 2^N$。\n- 存储值的集合是剩余类环 $\\mathbb{Z}_{2^N}$。\n\n3. 回绕时的排序挑战：\n- 预期的调度必须对概念上的、非模的 $pass$ 值进行排序以找到最小值。\n- 然而，朴素地比较余数可能会在回绕点附近错误排序值。例如，当 $N=8$ 时，一个概念上的值 $300$ 被存储为 $44$，因为 $300 \\equiv 44 \\pmod{256}$。将 $44$ 和 $250$ 作为无符号数直接比较会错误地声称 $44$ 更小，尽管在非模的意义上 $300 > 250$。\n\n4. 一个模安全的比较器：\n- 在二进制补码算术中，有符号整数将余数 $\\{0,\\dots,2^{N-1}-1\\}$ 表示为非负值，将 $\\{2^{N-1},\\dots,2^N-1\\}$ 表示为由 $2^N$ 偏移的负值。\n- 对于两个余数 $a, b \\in \\mathbb{Z}_{2^N}$，它们编码了概念值，且其真实差值 $(a - b)_{\\text{true}}$ 位于 $(-2^{N-1}, 2^{N-1})$ 内，那么对 $d := (a - b) \\bmod 2^N$ 的有符号二进制补码解释可以恢复 $(a - b)_{\\text{true}}$ 的符号：\n  - 如果 $(a - b)_{\\text{true}} > 0$，那么 $d \\in \\{1,\\dots,2^{N-1}-1\\}$，作为有符号数，其值 $d > 0$。\n  - 如果 $(a - b)_{\\text{true}}  0$，那么 $d \\in \\{2^{N-1}+1,\\dots,2^N-1\\}$，作为有符号数，其值 $d - 2^N  0$。\n- 因此，当且仅当 $d$ 的有符号解释为负时定义 $a \\prec b$，可以在半程窗口内再现非模值的正确顺序。等价地，将两个操作数都加上 $2^{N-1}$ 然后作为无符号数进行比较，可以实现相同的有符号排序，因为加上 $2^{N-1}$ 会旋转这个数值环，使得符号位成为能够适当翻转顺序的最高有效位。\n\n将这些原理应用于给定状态：\n- 前一次更新后的状态是 $pass_1 = 44$, $pass_2 = 250$, $pass_3 = 245$，其概念上的非模值（在当前周期内）为 $pass_1^{\\ast} = 300$, $pass_2^{\\ast} = 250$, $pass_3^{\\ast} = 245$。预期的最小值是 $pass_3^{\\ast} = 245$，因为 $245  250  300$。\n\n让我们测试每个选项。\n\n选项 A：\n- 提议：对余数使用无符号小于比较。根据此规则，我们直接比较 $44$, $250$, $245$ 并选择 $44$（即 $P_1$）。\n- 分析：这与预期顺序相矛盾，因为 $pass_1^{\\ast} = 300$ 大于 $250$ 和 $245$。回绕导致 $300 \\equiv 44 \\pmod{256}$，而朴素的比较器将 $44$ 视为最小值，这使选择偏向于最近发生回绕的累加器。\n- 结论：不正确。它展示了有偏差的行为而不是纠正它，并且所选进程 $P_1$ 在预期的概念顺序下不是正确的最小值。\n\n选项 B：\n- 提议：计算 $d := (a - b) \\bmod 2^N$ 并将 $d$ 解释为有符号数；当且仅当 $d  0$ 时声明 $a \\prec b$。\n- 首先，比较 $pass_1$ 和 $pass_2$：$d = (44 - 250) \\bmod 256 = (-206) \\bmod 256 = 50$。作为一个 $8$ 位有符号整数，$50$ 是正数，所以 $pass_1 \\succ pass_2$（即 $pass_1$ 更大）。\n- 接着，比较 $pass_2$ 和 $pass_3$：$d = (250 - 245) \\bmod 256 = 5$，有符号正数，所以 $pass_2 \\succ pass_3$。\n- 因此，$pass_3$ 是最小的，调度器选择 $P_3$。\n- 这与概念上的最小值相匹配：$245  250  300$，并且所有两两之差（$60$, $5$, $55$）都位于半程范围 $(-128, 128)$ 内。\n- 结论：正确。该比较器是模安全的，并得出正确的下一个选择 $P_3$。\n\n选项 C：\n- 提议：当且仅当无符号差 $(a - b)$ 小于 $2^{N-1}$ 时，$a \\prec b$。\n- 测试 $pass_1$ 与 $pass_2$：作为无符号数计算 $(a - b)$，$(44 - 250) \\bmod 256 = 50$，该值小于 $128$，所以该规则声明 $44 \\prec 250$，并会倾向于认为 $P_1$ 比 $P_2$ 小。\n- 但概念上的顺序是 $300 > 250$，所以 $P_1$ 不应该被认为比 $P_2$ 小。\n- 这个公式对于在半程范围内的差值翻转了期望的关系。条件 $(a - b)  2^{N-1}$ 表征的是接近程度，而不是顺序方向；在不考虑符号的情况下，它无法区分在线性化顺序中 $a$ 是在 $b$ 之前还是之后。\n- 结论：不正确。该标准错误地分类了方向并选择了 $P_1$，这是错误的。\n\n选项 D：\n- 提议：在溢出时将所有 $pass_i$ 重置为 $0$ 以避免回绕的复杂性，然后按最小步幅选择。\n- 分析：重置累加器会丢弃服务历史，从而破坏比例份额的公平性。调度器不应该按最小步幅选择；它应该按最小的 $pass_i$ 选择，以保持累积服务根据其份额在进程间平衡这一不变量。此外，将所有 $pass_i$ 重置为 $0$ 会产生与实际提供的服务无关的人为平局和偏差。即使试图从步幅大小重构一个顺序，那也不对应于最少的服务，并且会使系统偏离公平比例。\n- 结论：不正确。所提议的机制不是模安全的，违反了步幅调度的基本原则，并且基于最小步幅断言的下一个选择是没有根据的。\n\n选项 E：\n- 提议：将两个操作数都移动 $2^{N-1}$ 并作为无符号数比较：当且仅当 $((a + 2^{N-1}) \\bmod 2^N)  ((b + 2^{N-1}) \\bmod 2^N)$ 时，$a \\prec b$。\n- 这等效于有符号比较，因为加上 $2^{N-1}$ 将有符号范围 $\\{-2^{N-1},\\dots,2^{N-1}-1\\}$ 映射到无符号范围 $\\{0,\\dots,2^N-1\\}$，同时保持了顺序。\n- 计算转换后的值：对于 $N=8$, $2^{N-1} = 128$。我们得到\n  $$f(pass_1) = (44 + 128) \\bmod 256 = 172,$$\n  $$f(pass_2) = (250 + 128) \\bmod 256 = 378 \\bmod 256 = 122,$$\n  $$f(pass_3) = (245 + 128) \\bmod 256 = 373 \\bmod 256 = 117.$$\n- 将 $f(pass_i)$ 作为无符号数比较，得出 $117  122  172$，所以最小值是 $f(pass_3)$，因此 $pass_3$ 是最小的，$P_3$ 被选中。\n- 这与选项 B 的结果和概念上的最小值相匹配。\n- 结论：正确。该方法是模安全的，并选择了 $P_3$。\n\n总结：\n- 选项 B 和 E 是正确的，因为它们表达了尊重二进制补码算术的模安全比较，并正确地识别出 $P_3$ 是下一个进程。选项 A、C 和 D 是不正确的：A 说明了偏差，C 将大小与顺序方向混淆，D 通过丢弃累积服务破坏了公平性原则。", "answer": "$$\\boxed{BE}$$", "id": "3673643"}, {"introduction": "现代操作系统调度器（如 Linux 的完全公平调度器 CFS）大多采用“虚拟运行时”（virtual runtime）的概念来实现按比例共享。这种调度的公平性完全取决于如何正确地定义和更新虚拟运行时。本练习通过一个有缺陷的实现，让你辨析墙上时钟时间（wall-clock time）与实际 CPU 执行时间之间的关键区别，从而巩固对虚拟运行时真正含义的理解。[@problem_id:3673692]", "problem": "一个旨在实现比例份额调度的操作系统调度器，为每个线程 $i$ 维护一个称为虚拟运行时 $v_i(t)$ 的量，并总是选择 $v_i(t)$ 最小的线程来下次运行。比例份额调度的设计目标是，当一组线程可运行时，每个线程 $i$ 接收到的处理器服务份额与其正权重 $w_i$ 成比例。这意味着，对于任何一对可运行的线程 $i$ 和 $j$，它们在任何足够长的时间间隔内累积的处理器服务 $S_i$ 和 $S_j$ 的比率满足 $S_i/S_j = w_i/w_j$。与此目标一致的一个正确性不变量是，$v_i(t)$ 在一个时间间隔内的变化量应该是线程 $i$ 实际消耗的处理器时间的单调函数（根据其权重进行缩放），并且在线程未在处理器上执行时不应增加。\n\n考虑两个线程 $T_A$ 和 $T_B$，其权重分别为 $w_A = 2$ 和 $w_B = 1$。在一个长度为 $T  0$ 的墙钟时间间隔内，线程 $T_B$ 有 $p = 1/2$ 的时间比例因输入/输出而阻塞，使其总共只有 $(1-p)T$ 的墙钟时间内是可运行的，而线程 $T_A$ 持续可运行。该调度器有一个错误：即使线程没有在运行，它也使用墙钟时间来更新每个线程的 $v_i(t)$。假设 $v_A(0) = v_B(0) = 0$。\n\n基于上述目标和不变量，回答以下问题：\n\n- 在正确的比例份额核算下，计算在时间间隔 $[0,T]$ 内每个线程应接收到的总处理器服务 $S_A$ 和 $S_B$，并定性地描述在 $t=T$ 时 $v_A(T)$ 和 $v_B(T)$ 应如何比较。\n- 在那个无论线程 $i$ 是否运行都使用墙钟时间推进 $v_i(t)$ 的错误实现下，计算在 $[0,T]$ 上的 $\\Delta v_A$ 和 $\\Delta v_B$，并定性地描述这如何影响 $v_A(T)$ 和 $v_B(T)$ 的排序，以及当 $T_B$ 再次变为可运行时所产生的份额。\n\n以下哪项更改既指出了偏差的根本原因，又是能在保持 $v_i(t)$ 单调性的同时恢复比例份额公平性的最小修正？\n\nA. 将墙钟时间核算替换为每个线程的CPU上执行时间核算：仅当线程 $i$ 实际执行时才更新 $v_i$，增加的量与线程自身消耗的处理器时间成正比，与其权重 $w_i$ 成反比，即 $v_i \\leftarrow v_i + \\text{(on-CPU time of } i\\text{)} \\times f(w_i)$，其中 $f$ 是某个与比例份额公平性一致的固定归一化函数。\n\nB. 继续使用墙钟时间进行更新，但在唤醒时从 $v_i$ 中减去按其权重缩放的线程睡眠时长，即 $v_i \\leftarrow v_i - \\text{(sleep time)} \\times g(w_i)$，其中 $g$ 是一个合适的函数。\n\nC. 将所有虚拟运行时增量按每个瞬间可运行线程的数量进行缩放，即 $v_i \\leftarrow v_i + n_{\\text{runnable}} \\times \\text{(wall-clock increment)} \\times h(w_i)$，其中 $h$ 是某个函数，以便当存在更多线程时 $v_i$ 增长得更快。\n\nD. 冻结在 $[0,T]$ 期间执行输入/输出的任何线程的 $v_i$，这样即使其他线程在运行，它也不会增加，从而在唤醒时偏向交互式线程。\n\n选择唯一的最佳选项。", "solution": "该问题要求分析一个比例份额调度器，首先是在理想实现下，然后是在一个有错误的实现下，最后要找出对该错误的正确修复方法。\n\n### 问题验证\n\n问题陈述描述了一个使用虚拟运行时的比例份额调度器，这是操作系统中的一个标准概念（例如，与 Linux Completely Fair Scheduler 相关）。所有给定条件都已清晰定义：权重 $w_A=2$ 和 $w_B=1$，线程行为（一个是 CPU 密集型，一个是 I/O 密集型且 $p=1/2$），错误的性质（使用墙钟时间而非执行时间），以及初始条件（$v_A(0)=v_B(0)=0$）。提出的问题是具体的，并且可以根据这些给定条件来回答。该问题在计算机科学上具有科学依据，定义明确且客观。它不包含任何会妨碍严谨分析的矛盾或歧义。因此，该问题是有效的。\n\n### 解题推导\n\n设 $S_i$ 为线程 $T_i$ 的处理器服务时间，$v_i$ 为其虚拟运行时。权重为 $w_A=2$ 和 $w_B=1$。总墙钟时间间隔为 $T$。线程 $T_A$ 始终可运行。线程 $T_B$ 在 $(1-p)T = (1-1/2)T = T/2$ 的时间内可运行，并在 $pT = T/2$ 的时间内阻塞。\n\n**1. 正确的比例份额核算**\n\n在正确的实现下，处理器时间仅在*可运行*的线程集合中根据权重进行分享。\n\n*   **只有 $T_A$ 可运行的时间段：**这在 $T_B$ 阻塞时发生，总时长为 $T/2$。在此期间，$T_A$ 接收 $100\\%$ 的处理器服务。因此，$T_A$ 累积了 $T/2$ 的服务时间。\n*   **$T_A$ 和 $T_B$ 都可运行的时间段：**总时长为 $T/2$。在此期间，它们根据权重分享 CPU。总权重为 $w_A + w_B = 3$。\n    *   $T_A$ 的服务份额：$w_A / (w_A + w_B) = 2/3$。\n    *   $T_B$ 的服务份额：$w_B / (w_A + w_B) = 1/3$。\n    *   在此期间 $T_A$ 的处理器服务：$(2/3) \\times (T/2) = T/3$。\n    *   在此期间 $T_B$ 的处理器服务：$(1/3) \\times (T/2) = T/6$。\n\n*   **在 $[0, T]$ 上的总处理器服务：**\n    *   对于 $T_A$：$S_A = (\\text{当 } T_B \\text{ 阻塞时的服务}) + (\\text{两者都可运行时的服务}) = T/2 + T/3 = 5T/6$。\n    *   对于 $T_B$：$S_B = 0 + (\\text{两者都可运行时的服务}) = T/6$。\n    *   总 CPU 利用率是 $S_A + S_B = 5T/6 + T/6 = T$，这是正确的，因为 CPU 始终是繁忙的。\n\n*   **虚拟运行时 $v_A(T)$ 和 $v_B(T)$ 的比较：**\n    虚拟运行时的标准实现将其更新为 $\\Delta v_i = \\Delta S_i / w_i$。不变量指出，当线程未执行时，$v_i$ 不应增加。当 $T_B$ 阻塞时，其 $v_B$ 被冻结。同时，$T_A$ 运行，其 $v_A$ 增加。当 $T_B$ 再次变为可运行时，它将有一个小得多的虚拟运行时 ($v_B \\ll v_A$)。一个公平的调度器会给予 $T_B$ 优先权，让它“追赶”上来。调度器的目标是保持所有*可运行*线程的虚拟运行时大致相等。因此，在一个足够长的时间间隔 $T$ 结束时，在经历了阻塞和追赶的时期之后，一个行为良好的调度器应该已经将系统驱动到一个线程虚拟运行时平衡的状态。因此，定性地，我们预期 $v_A(T) \\approx v_B(T)$。\n\n**2. 错误实现分析**\n\n错误在于，即使线程 $i$ 没有运行，$v_i(t)$ 也是使用墙钟时间更新的。更新量与权重成反比。我们可以将变化率建模为 $dv_i/dt \\propto 1/w_i$。\n\n*   在时间间隔 $[0, T]$ 内，两个线程在整个墙钟时间 $T$ 期间都存在。\n*   设虚拟时间的变化为 $\\Delta v_i = (\\text{墙钟时间}) / w_i$。\n*   $v_A$ 的变化：$\\Delta v_A = v_A(T) - v_A(0) = T/w_A = T/2$。\n*   $v_B$ 的变化：$\\Delta v_B = v_B(T) - v_B(0) = T/w_B = T/1 = T$。\n*   因此，在时间 $T$，我们有 $v_B(T) = v_B(0) + T = T$ 和 $v_A(T) = v_A(0) + T/2 = T/2$。\n\n*   **对调度的影响：** 调度器总是选择 $v_i(t)$ 最小的线程。由于 $v_A(t)$ 的增长速率是 $v_B(t)$ 的一半（即 $dv_A/dt = (1/2) dv_B/dt$），并且它们从 $v_A(0)=v_B(0)=0$ 开始，因此对于所有 $t > 0$，$v_A(t)  v_B(t)$ 将始终成立。因此，只要线程 $T_A$ 是可运行的，调度器将*总是*选择它来运行。由于 $T_A$ 是持续可运行的，它将获得 $100\\%$ 的处理器服务，即 $S_A=T$ 且 $S_B=0$。这个错误导致线程 $T_B$ 完全饿死，彻底违背了比例份额的目标。$T_A$ 的高权重矛盾地给了它一个优势，而 $T_B$ 的低权重——结合其 I/O 活动——导致其虚拟时间累积得如此之快，以至于它永远没有机会运行。\n\n### 逐项分析选项\n\n错误的根本原因是，本应表示加权 CPU 消耗的虚拟运行时，却与墙钟时间的流逝挂钩。这错误地惩罚了线程因未运行（无论是阻塞还是被抢占）而花费的时间。\n\n**A. 将墙钟时间核算替换为每个线程的CPU上执行时间核算...**\n该选项建议仅当线程 $i$ 执行时才更新 $v_i$，其增量与消耗的 CPU 时间（$\\Delta S_i$）成正比，与其权重（$w_i$）成反比。这表示为 $v_i \\leftarrow v_i + \\Delta S_i \\times f(w_i)$，其中 $f(w_i) \\propto 1/w_i$。这是比例份额调度中虚拟运行时的规范、正确的实现。它确保了线程的虚拟时间仅在其真正使用处理器时才推进，直接修复了错误。此更改是最小的，因为它将不正确的时间源（墙钟时间）替换为正确的时间源（CPU上时间）。它还保持了单调性，因为消耗的 CPU 时间 ($S_i$) 是一个非递减量。\n**结论：正确。**\n\n**B. 继续使用墙钟时间进行更新，但在唤醒时从 $v_i$ 中减去按其权重缩放的线程睡眠时长...**\n该选项建议通过“退还”睡眠期间累积的虚拟时间来修补错误。虽然这可能部分解决 I/O 密集型线程的问题，但它有两个主要缺陷。首先，它违反了 $v_i(t)$ 的变化应为单调函数的既定不变量；减去一个值会使 $v_i(t)$ 非单调。其次，它没有修复使用墙钟时间进行核算的根本问题。当 $T_A$ 和 $T_B$ 都可运行时，它们的虚拟时间仍会基于墙钟时间增加，这意味着无论谁在运行，$v_B$ 仍会比 $v_A$ 增长得更快，导致 $T_B$ 饿死。这不是一个完整的修复。\n**结论：不正确。**\n\n**C. 将所有虚拟运行时增量按每个瞬间可运行线程的数量进行缩放...**\n此选项建议添加另一个缩放因子 $n_{\\text{runnable}}$，但保留了使用墙钟时间的根本缺陷。一个线程的虚拟运行时即使不在 CPU 上也会增加。例如，当 $T_B$ 阻塞时，$n_{\\text{runnable}}=1$，$v_A$ 和 $v_B$ 都会基于墙钟时间增加，这正是导致 $T_B$ 问题的行为。此修改没有解决根本原因。\n**结论：不正确。**\n\n**D. 冻结任何执行输入/输出的线程的 $v_i$...**\n该选项正确地认识到当线程因 I/O 阻塞时不应推进其虚拟运行时。然而，这是一个不完整的修复。与选项 B 一样，它未能解决多个线程都可运行的情况。有错误的调度器仍会使用墙钟时间同时推进所有可运行线程的虚拟运行时，即使是那些当前未执行的线程也是如此。这仍然会导致权重较低的可运行线程饿死，正如在错误实现分析中所描述的那样。最小且完整的修正必须将虚拟时间的更新基于*实际执行*，而不仅仅是过滤掉 I/O 周期。\n**结论：不正确。**\n\n总之，选项 A 是唯一一个正确识别了根本原因——使用墙钟时间——并提出了最小、完整的修正方案，该方案通过将虚拟时间基于实际的 CPU 执行时间来恢复公平性，这与比例份额调度器的基本原则是一致的。", "answer": "$$\\boxed{A}$$", "id": "3673692"}]}