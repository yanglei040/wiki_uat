{"hands_on_practices": [{"introduction": "操作系统内核的稳定运行是所有上层应用的基础。本练习将引导你探究一个经典的内核稳定性问题：计时器溢出。我们将分析一个基于内核滴答计数器（jiffies）实现的定时任务调度机制，并揭示不当处理无符号整数环绕运算（wrap-around arithmetic）和有符号数解释如何导致灾难性的系统崩溃。通过推导安全的超时参数边界 [@problem_id:3686534]，你将掌握预防此类底层错误的关键分析方法。", "problem": "操作系统 (OS) 内核维护着一个时钟节拍计数器，通常称为 jiffies 计数器，记作 $J$。计数器 $J$ 在每个时钟节拍上加 $1$，并在硬件中表示为一个 $b$ 位无符号整数，因此对 $J$ 的算术运算是模 $2^{b}$ 的。在时钟节拍时间 $t$，一个子系统调度了一个未来的检查，其时间为 $E \\equiv t + \\Delta t \\pmod{2^{b}}$，其中 $\\Delta t$ 是一个以 jiffies 为单位的正整数。\n\n内核用于判断当前时钟节拍值 $n$ 是否“到达或超过到期时间” $E$ 的断言是这样实现的：首先，计算 $b$ 位的差值 $D \\equiv E - n \\pmod{2^{b}}$；然后，将这个 $b$ 位量 $D$ 解释为范围在 $[-2^{b-1}, 2^{b-1} - 1]$ 内的有符号二进制补码整数；最后，当且仅当 $D \\le 0$ 时，宣告“到达或超过到期时间”。过去系统曾因某些较大的 $\\Delta t$ 值而崩溃，因为这些值会导致断言在调度时间 $n = t$ 就立即评估为真，从而引发乱序执行和故障。\n\n仅从以下基本事实出发：$b$ 位无符号算术是模 $2^{b}$ 的，并且二进制补码解释将 $b$ 位模式映射到有符号范围 $[-2^{b-1}, 2^{b-1} - 1]$。请推导 $\\Delta t$（以 jiffies 为单位）的最大整数值，该值能保证对于 $J$ 的每一种可能的回绕行为，断言对于所有的 $n \\in \\{t, t+1, \\dots, E-1\\}$ 都保持为假，而在 $n=E$ 时变为真（并在此后保持为真）。请将你的最终界限表示为以 $b$ 为变量的封闭形式解析表达式。无需四舍五入。以 jiffies 为单位表示该界限。", "solution": "问题要求解时间延迟 $\\Delta t$ 的最大正整数值，使得在时间 $t$ 调度、到期时间为 $E \\equiv t + \\Delta t \\pmod{2^b}$ 的计时器不会过早触发。系统的时间计数器 $J$ 是一个 $b$ 位无符号整数，因此所有时间算术都是模 $2^b$ 进行的。\n\n首先，我们必须形式化到期断言。检查在给定的时间 $n$ 进行。差值 $D$ 是作为一个 $b$ 位无符号整数计算的：\n$$D_u \\equiv E - n \\pmod{2^b}$$\n这个 $b$ 位整数模式代表一个无符号值 $D_u \\in [0, 2^b-1]$，然后被解释为一个有符号二进制补码整数 $D_s \\in [-2^{b-1}, 2^{b-1}-1]$。无符号值 $D_u$ 和有符号值 $D_s$ 之间的关系如下：\n$$\nD_s =\n\\begin{cases}\nD_u  & \\text{if } 0 \\le D_u  2^{b-1} \\\\\nD_u - 2^b  \\text{if } 2^{b-1} \\le D_u  2^b\n\\end{cases}\n$$\n“到达或超过到期时间”的断言是 $D_s \\le 0$。让我们确定对于哪些无符号值 $D_u$ 这个条件成立：\n1.  如果 $D_u \\in [1, 2^{b-1}-1]$，那么 $D_s = D_u  0$。断言为假。\n2.  如果 $D_u = 0$，那么 $D_s = 0$。断言 $D_s \\le 0$ 为真。\n3.  如果 $D_u \\in [2^{b-1}, 2^b-1]$，那么 $D_s = D_u - 2^b$。在此范围内，$D_s$ 的最大值是 $(2^b-1) - 2^b = -1$，最小值是 $2^{b-1} - 2^b = -2^{b-1}$。在这种情况下，$D_s \\le -1$。断言 $D_s \\le 0$ 为真。\n\n因此，“到达或超过到期时间”的断言为真，当且仅当无符号差值 $D_u$ 在范围 $[2^{b-1}, 2^b-1]$ 内，或者 $D_u=0$。反之，断言为假（“尚未到期”），当且仅当 $D_u \\in [1, 2^{b-1}-1]$。\n\n问题要求找到最大的正整数 $\\Delta t$，使其对于任何起始时间 $t$ 都满足两个条件：\n条件 A：对于从 $t$ 开始直到（但不包括）$E$ 的序列中的所有时钟节拍 $n$，断言为假。这个时钟节拍序列可以表示为 $n_k = (t+k) \\pmod{2^b}$，其中 $k \\in \\{0, 1, 2, \\dots, \\Delta t-1\\}$。\n条件 B：对于 $n=E$ 及所有后续时钟节拍，断言为真。\n\n我们来分析条件 A。对于每个 $k \\in \\{0, 1, \\dots, \\Delta t-1\\}$，我们必须确保断言为假。这意味着无符号差值 $D_u$ 必须落在“尚未到期”的范围 $[1, 2^{b-1}-1]$ 内。\n对于时钟节拍 $n_k = (t+k) \\pmod{2^b}$，无符号差值为：\n$$D_u(k) \\equiv E - n_k \\pmod{2^b}$$\n代入 $E$ 和 $n_k$ 的定义：\n$$D_u(k) \\equiv \\left( (t+\\Delta t)\\pmod{2^b} - (t+k)\\pmod{2^b} \\right) \\pmod{2^b}$$\n使用属性 $(a-b)\\pmod{m} \\equiv (a\\pmod{m} - b\\pmod{m})\\pmod{m}$，我们得到：\n$$D_u(k) \\equiv (t+\\Delta t - (t+k)) \\pmod{2^b} \\equiv (\\Delta t - k) \\pmod{2^b}$$\n因此，为了使条件 A 成立，我们需要：\n$$(\\Delta t - k) \\pmod{2^b} \\in [1, 2^{b-1}-1] \\quad \\forall k \\in \\{0, 1, \\dots, \\Delta t-1\\}$$\n我们来分析这个约束。\n如果我们选择一个 $\\Delta t$ 值，使得 $\\Delta t \\ge 2^{b-1}$，我们可以找到一个违反该条件的 $k$ 值。考虑 $k=0$（调度时刻）。差值为 $D_u(0) \\equiv \\Delta t \\pmod{2^b}$。如果 $2^{b-1} \\le \\Delta t  2^b$，那么 $D_u(0) = \\Delta t$，这在“已到期”的范围 $[2^{b-1}, 2^b-1]$ 内。这会导致立即的、过早的到期，也就是所描述的漏洞。\n更一般地，对于任何 $\\Delta t \\ge 2^{b-1}$，我们必须证明存在一个 $k \\in \\{0, 1, \\dots, \\Delta t-1\\}$ 违反该条件。我们选择 $k$ 使得 $\\Delta t - k = 2^{b-1}$。这得到 $k = \\Delta t - 2^{b-1}$。由于 $\\Delta t \\ge 2^{b-1}$，我们有 $k \\ge 0$。又因为 $2^{b-1}  0$，我们有 $k  \\Delta t$。所以这个 $k$ 值在指定范围内。对于这个 $k$，差值为：\n$$D_u(k) = (\\Delta t - (\\Delta t-2^{b-1})) \\pmod{2^b} = 2^{b-1} \\pmod{2^b} = 2^{b-1}$$\n这个值 $2^{b-1}$ 不在“尚未到期”的范围 $[1, 2^{b-1}-1]$ 内。因此，任何选择 $\\Delta t \\ge 2^{b-1}$ 都会导致在时钟节拍 $n = t + (\\Delta t - 2^{b-1})$ 时过早到期。因此，我们必须有 $\\Delta t  2^{b-1}$。\n\n现在，让我们考虑任何正整数 $\\Delta t$，使得 $\\Delta t \\le 2^{b-1}-1$。\n对于 $k \\in \\{0, 1, \\dots, \\Delta t-1\\}$，$\\Delta t - k$ 的值构成序列：\n$$\\Delta t, \\Delta t-1, \\dots, 2, 1$$\n由于 $1 \\le \\Delta t \\le 2^{b-1}-1$，这个序列中的每一项都是正数且小于 $2^b$。因此，模运算 $(\\dots)\\pmod{2^b}$ 没有影响。差值序列 $D_u(k)$ 就是 $\\{\\Delta t, \\Delta t-1, \\dots, 1\\}$。\n此外，由于该序列中的最大值是 $\\Delta t$，并且我们已经约束了 $\\Delta t \\le 2^{b-1}-1$，所以序列中的每个值都位于范围 $[1, 2^{b-1}-1]$ 内。这正是“尚未到期”的范围。\n因此，如果 $1 \\le \\Delta t \\le 2^{b-1}-1$，条件 A 得到满足。\n\n接下来，我们分析条件 B。在到期时钟节拍 $n=E$ 时，差值为：\n$$D_u \\equiv E - E \\pmod{2^b} = 0$$\n有符号解释为 $D_s=0$。断言 $D_s \\le 0$ 为真。这对任何 $\\Delta t$ 都成立。对于到期后的时钟节拍，例如，对于 $j \\ge 1$ 的 $n = (E+j) \\pmod{2^b}$：\n$$D_u \\equiv E - (E+j) \\pmod{2^b} = -j \\pmod{2^b}$$\n无符号结果将位于范围 $[2^b-j, 2^b-1]$ 内，这在“已到期”区域中（除非 $j$ 是 $2^b$ 的一个大倍数，在这种情况下差值为 $0$）。因此，条件 B 总是满足的。\n\n结合这些约束，计时器正确行为的要求是 $1 \\le \\Delta t  2^{b-1}$，或者更精确地说，由于 $\\Delta t$ 必须是整数，所以是 $1 \\le \\Delta t \\le 2^{b-1}-1$。问题要求 $\\Delta t$ 的最大整数值。这就是推导出的有效范围的上限。\n\n$\\Delta t$ 的最大整数值是 $2^{b-1}-1$。", "answer": "$$\n\\boxed{2^{b-1} - 1}\n$$", "id": "3686534"}, {"introduction": "在保证系统稳定之后，性能优化成为下一个核心议题。线程迁移是现代操作系统调度器的基本操作，但其性能开销常常被忽略。本练习将指导你从底层硬件原理出发，量化线程迁移带来的性能损失 $\\Delta M(C)$，它取决于线程的工作集缓存足迹 $C$。通过为缓存、翻译后备缓冲器（TLB）和调度器自身建立一个成本模型 [@problem_id:3686454]，你将学会如何剖析和预测基本操作系统操作的性能影响。", "problem": "您的任务是量化和建模操作系统调度器线程迁移所产生的开销，并将其表示为线程缓存足迹的函数。目标是设计一个程序，该程序能针对一小组测试场景，基于分层缓存和一致性共享内存的基本原理构建模型，并计算出以纳秒为单位的总迁移开销。该程序必须以单行形式输出结果，结果为一个由方括号括起来、用逗号分隔的列表。\n\n调度器迁移将一个正在运行的线程从一个处理器核心移动到另一个，这会使其在该核心的私有缓存中的数据失效。在包含一级（L1）、二级（L2）和共享末级缓存（LLC）的分层缓存设计下，我们关注迁移后主要的冷启动开销部分。假设以下原理和核心定义是您推导的基础：\n\n- 缓存行是缓存填充的最小单位。设缓存行大小为 $\\ell$ 字节。\n- 大小为 $S_3$ 字节的共享末级缓存（LLC）最多可容纳 $\\left\\lfloor S_3 / \\ell \\right\\rfloor$ 个缓存行；如果线程的工作集足迹 $C$ 超过 $S_3$，则 LLC 最多只能提供 $\\left\\lfloor S_3 / \\ell \\right\\rfloor$ 个缓存行，其余部分必须从主内存中获取。\n- 转译后备缓冲器（TLB）是每个核心独有的；一次迁移会丢弃 TLB 状态，并要求为每个被访问的独立页面至少重新填充一个 TLB 条目。设页面大小为 $P$ 字节。\n- 设从 LLC 重新填充每行的成本为 $t_{\\text{llc}}$ 纳秒，从主内存重新填充每行的成本为 $t_{\\text{mem}}$ 纳秒。设每页的 TLB 重载成本为 $t_{\\text{tlb}}$ 纳秒。设每次迁移的固定调度器簿记成本为 $t_{\\text{sched}}$ 纳秒。\n\n您必须仅从这些基本原理出发，推导出一个单次迁移开销 $\\Delta M(C)$ 的模型，该模型需要计入必须从 LLC 与主内存中获取的缓存行数量，以及必须在目标核心的 TLB 中重新建立的页面翻译数量。在推导模型时，请使用以下逻辑约束：\n\n- 一个大小为 $C$ 的足迹所对应的独立缓存行数量为 $\\lceil C / \\ell \\rceil$。\n- 每次迁移，LLC 最多可提供 $\\left\\lfloor S_3 / \\ell \\right\\rfloor$ 个缓存行；任何额外所需的行都从主内存中获取。\n- 该足迹所牵涉到的页面数量为 $\\lceil C / P \\rceil$。\n\n那么，对于给定的迁移次数 $m$，总开销为 $T(m, C)$，您必须为每个测试用例计算该值。\n\n物理和数值单位要求：您的最终输出应以纳秒为单位，表示为四舍五入到两位小数的浮点值。\n\n您的程序必须实现上述模型，并为以下测试套件生成结果。请完全按照给定的参数进行计算。所有大小单位均为字节，所有时间成本单位均为纳秒。\n\n常量（所有测试用例通用）：\n- 缓存行大小 $\\ell = 64$。\n- LLC 大小 $S_3 = 8{,}388{,}608$。\n- 页面大小 $P = 4{,}096$。\n- 从 LLC 重新填充每行的成本 $t_{\\text{llc}} = 30$。\n- 从主内存重新填充每行的成本 $t_{\\text{mem}} = 100$。\n- 每页 TLB 重载成本 $t_{\\text{tlb}} = 5$。\n- 每次迁移的调度器簿记成本 $t_{\\text{sched}} = 1{,}500$。\n\n测试套件（每个用例指定了足迹 $C$ 和迁移次数 $m$）：\n- 用例 A（理想情况，小足迹可容纳于 LLC）：$C = 262{,}144$, $m = 10$。\n- 用例 B（大足迹，超出 LLC 容量）：$C = 33{,}554{,}432$, $m = 3$。\n- 用例 C（边界条件，足迹恰好等于 LLC 容量）：$C = 8{,}388{,}608$, $m = 1$。\n- 用例 D（边缘情况，零次迁移）：$C = 1{,}048{,}576$, $m = 0$。\n- 用例 E（边缘情况，足迹小于一个缓存行）：$C = 32$, $m = 5$。\n\n最终输出格式规范：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。第 $i$ 个元素必须是第 $i$ 个测试用例的总迁移开销 $T(m, C)$，单位为纳秒，并四舍五入到两位小数。例如，输出应类似于 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_i$ 都是一个浮点数。", "solution": "已对用户提供的问题进行分析，并确定其为**有效**问题。该问题在科学上植根于计算机体系结构原理，问题适定、客观，并包含足够的信息来为每个测试用例推导出唯一的解决方案。\n\n目标是为大小为 $C$ 的缓存足迹的线程，在经历 $m$ 次调度器迁移时产生的总开销 $T(m, C)$ 推导出一个模型。此模型将基于所提供的关于缓存、内存和 TLB 行为的第一性原理。\n\n总开销 $T(m, C)$ 是迁移次数 $m$ 与单次迁移开销 $\\Delta M(C)$ 的乘积。如果 $m=0$，则总开销为 $0$。对于 $m  0$：\n$$T(m, C) = m \\cdot \\Delta M(C)$$\n\n单次迁移开销 $\\Delta M(C)$ 是问题中定义的三个不同组成部分的总和：\n$1$. 固定的调度器簿记成本 $t_{\\text{sched}}$。\n$2$. 重载转译后备缓冲器（TLB）的可变成本，我们将其表示为 $\\text{Cost}_{\\text{TLB}}(C)$。\n$3$. 重新填充处理器缓存的可变成本，我们将其表示为 $\\text{Cost}_{\\text{cache}}(C)$。\n\n因此，单次迁移开销为：\n$$\\Delta M(C) = t_{\\text{sched}} + \\text{Cost}_{\\text{TLB}}(C) + \\text{Cost}_{\\text{cache}}(C)$$\n\n现在，我们将根据所提供的原理推导每个可变组成部分的功能形式。\n\n首先，我们对 TLB 重载成本 $\\text{Cost}_{\\text{TLB}}(C)$ 进行建模。一次迁移会使核心的 TLB 失效。其成本与线程足迹所占用的独立内存页面数量成正比。给定页面大小为 $P$ 字节，足迹大小为 $C$ 字节，则页面数量 $N_P(C)$ 是比率 $C/P$ 的向上取整。\n$$N_P(C) = \\left\\lceil \\frac{C}{P} \\right\\rceil$$\n在每页重载成本为 $t_{\\text{tlb}}$ 的情况下，总的 TLB 开销为：\n$$\\text{Cost}_{\\text{TLB}}(C) = N_P(C) \\cdot t_{\\text{tlb}} = \\left\\lceil \\frac{C}{P} \\right\\rceil \\cdot t_{\\text{tlb}}$$\n\n其次，我们对缓存重新填充成本 $\\text{Cost}_{\\text{cache}}(C)$ 进行建模。一次迁移迫使新核心将其本地缓存填充入线程的工作集。数据以大小为 $\\ell$ 的缓存行为单位进行获取。对于大小为 $C$ 的足迹，所需的唯一缓存行总数由下式给出：\n$$N_L(C) = \\left\\lceil \\frac{C}{\\ell} \\right\\rceil$$\n这些缓存行要么从共享的末级缓存（LLC）获取，要么从主内存获取。LLC 的容量是有限的。LLC 可以容纳的最大缓存行数量是：\n$$N_{L3}^{\\text{max}} = \\left\\lfloor \\frac{S_3}{\\ell} \\right\\rfloor$$\n其中 $S_3$ 是 LLC 的大小（以字节为单位）。\n\n该模型为获取这些缓存行的来源区分了两种情况：\n- 如果线程所需的缓存行数 $N_L(C)$ 不超过 LLC 的容量 $N_{L3}^{\\text{max}}$，则假定所有行都驻留在 LLC 中，并从那里获取。\n- 如果所需的缓存行数 $N_L(C)$ 超过 LLC 的容量 $N_{L3}^{\\text{max}}$，LLC 只能提供其容量上限的缓存行。剩余的行必须从速度慢得多的主内存中获取。\n\n我们可以通过定义从 LLC 获取的行数 $N_{\\text{from\\_llc}}(C)$ 和从主内存获取的行数 $N_{\\text{from\\_mem}}(C)$ 来将其形式化：\n$$N_{\\text{from\\_llc}}(C) = \\min\\left( N_L(C), N_{L3}^{\\text{max}} \\right)$$\n$$N_{\\text{from\\_mem}}(C) = N_L(C) - N_{\\text{from\\_llc}}(C) = \\max\\left(0, N_L(C) - N_{L3}^{\\text{max}}\\right)$$\n\n总的缓存重新填充成本是来自两个来源的成本之和，使用它们各自的每行重新填充成本 $t_{\\text{llc}}$ 和 $t_{\\text{mem}}$：\n$$\\text{Cost}_{\\text{cache}}(C) = \\left( N_{\\text{from\\_llc}}(C) \\cdot t_{\\text{llc}} \\right) + \\left( N_{\\text{from\\_mem}}(C) \\cdot t_{\\text{mem}} \\right)$$\n\n结合所有组成部分，单次迁移开销 $\\Delta M(C)$ 的完整公式是：\n$$\\Delta M(C) = t_{\\text{sched}} + \\left( \\left\\lceil \\frac{C}{P} \\right\\rceil \\cdot t_{\\text{tlb}} \\right) + \\left( \\min\\left(\\left\\lceil \\frac{C}{\\ell} \\right\\rceil, \\left\\lfloor \\frac{S_3}{\\ell} \\right\\rfloor\\right) \\cdot t_{\\text{llc}} \\right) + \\left( \\max\\left(0, \\left\\lceil \\frac{C}{\\ell} \\right\\rceil - \\left\\lfloor \\frac{S_3}{\\ell} \\right\\rfloor\\right) \\cdot t_{\\text{mem}} \\right)$$\n\n现在我们使用提供的常量将此模型应用于测试套件：\n- $\\ell = 64$ 字节\n- $S_3 = 8,388,608$ 字节\n- $P = 4,096$ 字节\n- $t_{\\text{llc}} = 30$ 纳秒\n- $t_{\\text{mem}} = 100$ 纳秒\n- $t_{\\text{tlb}} = 5$ 纳秒\n- $t_{\\text{sched}} = 1,500$ 纳秒\n\n首先，我们计算 LLC 的缓存行容量：\n$$N_{L3}^{\\text{max}} = \\left\\lfloor \\frac{8,388,608}{64} \\right\\rfloor = \\lfloor 131,072 \\rfloor = 131,072 \\text{ 行}$$\n\n**用例 A**：$C = 262,144$, $m = 10$\n- $N_L(C) = \\lceil 262,144 / 64 \\rceil = 4,096$ 行\n- $N_P(C) = \\lceil 262,144 / 4,096 \\rceil = 64$ 页\n- 由于 $N_L(C) \\le N_{L3}^{\\text{max}}$，所有行都来自 LLC。\n- $\\Delta M(C) = 1,500 + (64 \\cdot 5) + (4,096 \\cdot 30) = 1,500 + 320 + 122,880 = 124,700$ 纳秒\n- $T(m, C) = 10 \\cdot 124,700 = 1,247,000$ 纳秒\n\n**用例 B**：$C = 33,554,432$, $m = 3$\n- $N_L(C) = \\lceil 33,554,432 / 64 \\rceil = 524,288$ 行\n- $N_P(C) = \\lceil 33,554,432 / 4,096 \\rceil = 8,192$ 页\n- 由于 $N_L(C)  N_{L3}^{\\text{max}}$，行同时来自 LLC 和内存。\n- $N_{\\text{from\\_llc}} = 131,072$；$N_{\\text{from\\_mem}} = 524,288 - 131,072 = 393,216$\n- $\\Delta M(C) = 1,500 + (8,192 \\cdot 5) + (131,072 \\cdot 30) + (393,216 \\cdot 100)$\n- $\\Delta M(C) = 1,500 + 40,960 + 3,932,160 + 39,321,600 = 43,296,220$ 纳秒\n- $T(m, C) = 3 \\cdot 43,296,220 = 129,888,660$ 纳秒\n\n**用例 C**：$C = 8,388,608$, $m = 1$\n- $N_L(C) = \\lceil 8,388,608 / 64 \\rceil = 131,072$ 行\n- $N_P(C) = \\lceil 8,388,608 / 4,096 \\rceil = 2,048$ 页\n- 这里 $N_L(C) = N_{L3}^{\\text{max}}$，因此所有行都来自 LLC。\n- $\\Delta M(C) = 1,500 + (2,048 \\cdot 5) + (131,072 \\cdot 30) = 1,500 + 10,240 + 3,932,160 = 3,943,900$ 纳秒\n- $T(m, C) = 1 \\cdot 3,943,900 = 3,943,900$ 纳秒\n\n**用例 D**：$C = 1,048,576$, $m = 0$\n- 由于 $m = 0$，没有发生迁移。\n- $T(m, C) = 0$ 纳秒\n\n**用例 E**：$C = 32$, $m = 5$\n- $N_L(C) = \\lceil 32 / 64 \\rceil = 1$ 行\n- $N_P(C) = \\lceil 32 / 4,096 \\rceil = 1$ 页\n- 由于 $N_L(C) \\le N_{L3}^{\\text{max}}$，所有行都来自 LLC。\n- $\\Delta M(C) = 1,500 + (1 \\cdot 5) + (1 \\cdot 30) = 1,500 + 5 + 30 = 1,535$ 纳秒\n- $T(m, C) = 5 \\cdot 1,535 = 7,675$ 纳秒\n\n最终结果四舍五入到两位小数后为：A: $1,247,000.00$、B: $129,888,660.00$、C: $3,943,900.00$、D: $0.00$、E: $7,675.00$。", "answer": "```\n[1247000.00, 129888660.00, 3943900.00, 0.00, 7675.00]\n```", "id": "3686454"}, {"introduction": "高级性能工程不仅在于分析，更在于动态调优。内核工作队列是处理异步任务的关键机制，但任务积压 $Q(t)$ 可能导致系统延迟过高甚至不稳定。本练习将介绍一种更主动的性能管理方法：应用反馈控制理论来设计一个动态调整参数 $\\Delta(t)$ 的控制器。通过构建一个能够自动稳定工作队列负载的系统 [@problem_id:3686449]，你将体验到如何运用工程控制原理来保证复杂系统的性能和响应能力。", "problem": "Linux内核的一个工作队列处理来自中断处理程序的延迟任务。设工作队列的积压由一个连续时间函数 $Q(t)$ 表示，该函数计算在时间 $t$ 排队的任务数量。操作系统使用内核检测来监控 $Q(t)$，并通过调整一个并发控制输入 $\\Delta(t)$ 来进行调优，该输入通过在中央处理器（CPU）上分配额外的工作线程来增加工作队列的服务容量。\n\n假设基于队列中流量守恒的以下科学模型：积压动态由 $\\,\\frac{dQ}{dt} = \\lambda - \\mu(t)\\,$ 给出，其中 $\\lambda$ 是持续到达率，$\\mu(t)$ 是瞬时服务率。未调优时的基线服务率为 $\\mu_{0}$，通过 $\\Delta(t)$ 调整并发性会线性增加服务，因此 $\\mu(t) = \\mu_{0} + \\gamma \\,\\Delta(t)$。参数 $\\gamma$ 表示每单位并发性所带来的服务容量的边际增加。为了防止在突发负载下出现内存耗尽和潜在的内核崩溃，您的任务是将 $Q(t)$ 稳定在目标积压 $Q^{\\star}$ 附近，该目标积压的选择是为了保持平均等待时间在可接受范围内。\n\n您已获知通过监控测得和表征的以下量：\n- 持续到达率 $\\,\\lambda = 480\\,$ 任务数/秒。\n- 基线服务率 $\\,\\mu_{0} = 420\\,$ 任务数/秒。\n- 每单位并发性的服务增益 $\\,\\gamma = 120\\,$ 任务数/秒每单位 $\\,\\Delta$。\n- 目标积压 $\\,Q^{\\star} = 50\\,$ 任务数。\n\n基于测量的积压设计一个比例反馈控制，\n$$\n\\Delta(t) = \\Delta_{0} + k\\,(Q(t) - Q^{\\star}),\n$$\n其中 $\\Delta_{0}$ 是一个恒定偏移量，其选择是为了在 $Q(t) = Q^{\\star}$ 时使 $Q^{\\star}$ 成为一个平衡点，而 $k$ 是待确定的比例增益。假设 $Q(t)$ 的测量是瞬时的，并且该模型在感兴趣的工作状态下有效。\n\n仅从守恒定律 $\\,\\frac{dQ}{dt} = \\lambda - \\mu(t)\\,$ 和上述线性服务模型出发，推导出 $e(t) = Q(t) - Q^{\\star}$ 的闭环误差动态，并计算保证误差幅度在 $\\,T = 0.5\\,$ 秒内衰减到其初始幅度的二十分之一的最小 $k$ 值，即 $\\,|e(T)| \\leq \\frac{1}{20}\\,|e(0)|\\,$。将 $k$ 的最终答案以 任务数$^{-1}$ 为单位表示，并四舍五入到四位有效数字。", "solution": "首先对用户提供的问题进行严格的验证过程。\n\n### 步骤 1：提取给定条件\n-   积压动态：$\\frac{dQ}{dt} = \\lambda - \\mu(t)$\n-   瞬时服务率：$\\mu(t) = \\mu_{0} + \\gamma \\,\\Delta(t)$\n-   比例反馈控制律：$\\Delta(t) = \\Delta_{0} + k\\,(Q(t) - Q^{\\star})$\n-   持续到达率：$\\lambda = 480\\,$ 任务数/秒\n-   基线服务率：$\\mu_{0} = 420\\,$ 任务数/秒\n-   服务增益：$\\gamma = 120\\,$ 任务数/秒每单位 $\\Delta$\n-   目标积压：$Q^{\\star} = 50\\,$ 任务数\n-   误差定义：$e(t) = Q(t) - Q^{\\star}$\n-   衰减条件：$|e(T)| \\leq \\frac{1}{20}\\,|e(0)|$\n-   时间范围：$T = 0.5\\,$ 秒\n\n### 步骤 2：使用提取的给定条件进行验证\n1.  **科学依据**：该问题使用一阶线性微分方程来模拟队列动态，这是排队论和控制系统中一个标准且有效的简化方法。比例反馈控制的使用是控制工程中的一个基本概念。所有概念在物理学、工程学和计算机科学中都已成熟。\n2.  **适定性**：该问题是适定的。它提供了足够的信息和一个明确的目标：找到满足给定性能标准的特定参数 $k$。预期会有一个唯一的解。\n3.  **客观性**：问题以精确、量化且无偏见的语言陈述。\n4.  **缺陷评估**：该问题不违反科学原理，不是比喻性的，是自包含的，物理上是合理的，结构良好，并且不是微不足道的。问题的背景，即*操作系统*中的*系统性能调优*，是恰当的。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。将推导解答。\n\n问题要求推导闭环误差动态，并计算比例增益 $k$ 以满足特定的性能要求。\n\n首先，我们确定恒定偏移量 $\\Delta_{0}$。它的选择是为了使目标积压 $Q^{\\star}$ 成为系统的平衡点。在平衡状态下，积压是恒定的，所以 $\\frac{dQ}{dt} = 0$，且 $Q(t) = Q^{\\star}$。\n当 $Q(t) = Q^{\\star}$ 时，控制输入为：\n$$\n\\Delta(t) = \\Delta_{0} + k(Q^{\\star} - Q^{\\star}) = \\Delta_{0}\n$$\n在此平衡点，服务率为：\n$$\n\\mu(t) = \\mu_{0} + \\gamma \\Delta_{0}\n$$\n将此代入积压动态方程，并令导数为零：\n$$\n\\frac{dQ}{dt} = \\lambda - (\\mu_{0} + \\gamma \\Delta_{0}) = 0\n$$\n由此，我们解出 $\\Delta_{0}$：\n$$\n\\gamma \\Delta_{0} = \\lambda - \\mu_{0} \\implies \\Delta_{0} = \\frac{\\lambda - \\mu_{0}}{\\gamma}\n$$\n代入给定的数值：\n$$\n\\Delta_{0} = \\frac{480 - 420}{120} = \\frac{60}{120} = 0.5\n$$\n并发控制输入 $\\Delta(t)$ 是无量纲的，这意味着 $\\gamma$ 的单位是 任务数/秒。这与其在服务率方程中的作用是一致的。\n\n接下来，我们推导误差 $e(t) = Q(t) - Q^{\\star}$ 的闭环动态。误差的导数为 $\\frac{de}{dt} = \\frac{d}{dt}(Q(t) - Q^{\\star}) = \\frac{dQ}{dt}$，因为 $Q^{\\star}$ 是一个常数。\n我们将服务率 $\\mu(t)$ 的完整表达式代入积压动态：\n$$\n\\frac{dQ}{dt} = \\lambda - \\mu(t) = \\lambda - \\left( \\mu_{0} + \\gamma \\Delta(t) \\right)\n$$\n现在，代入控制律 $\\Delta(t) = \\Delta_{0} + k(Q(t) - Q^{\\star}) = \\Delta_{0} + k e(t)$：\n$$\n\\frac{de}{dt} = \\lambda - \\left( \\mu_{0} + \\gamma (\\Delta_{0} + k e(t)) \\right)\n$$\n重新整理各项：\n$$\n\\frac{de}{dt} = (\\lambda - \\mu_{0} - \\gamma \\Delta_{0}) - \\gamma k e(t)\n$$\n根据我们对 $\\Delta_{0}$ 的设计，括号中的项为零：$\\lambda - \\mu_{0} - \\gamma \\Delta_{0} = 0$。因此，误差动态简化为一个一阶线性齐次常微分方程：\n$$\n\\frac{de}{dt} = - \\gamma k e(t)\n$$\n该微分方程的解是一个指数函数：\n$$\ne(t) = e(0) \\exp(-\\gamma k t)\n$$\n其中 $e(0)$ 是 $t=0$ 时的初始误差。为了使误差衰减，系统必须是稳定的，这要求指数为负。由于 $\\gamma = 120  0$，我们必须有 $k  0$。\n\n问题要求误差幅度在 $T = 0.5$ 秒内衰减到其初始幅度的二十分之一。在数学上，这表示为 $|e(T)| \\leq \\frac{1}{20}|e(0)|$。\n代入 $e(t)$ 的解：\n$$\n|e(0) \\exp(-\\gamma k T)| \\leq \\frac{1}{20}|e(0)|\n$$\n假设初始误差不为零，即 $e(0) \\neq 0$，我们可以除以 $|e(0)|$。由于 $\\exp(x)$ 总是正的，我们可以去掉绝对值符号：\n$$\n\\exp(-\\gamma k T) \\leq \\frac{1}{20}\n$$\n为了找到保证此条件的最小 $k$ 值，我们取等式：\n$$\n\\exp(-\\gamma k T) = \\frac{1}{20}\n$$\n对两边取自然对数：\n$$\n-\\gamma k T = \\ln\\left(\\frac{1}{20}\\right) = -\\ln(20)\n$$\n解出 $k$：\n$$\nk = \\frac{\\ln(20)}{\\gamma T}\n$$\n现在，我们代入 $\\gamma$ 和 $T$ 的数值：\n$$\nk = \\frac{\\ln(20)}{120 \\times 0.5} = \\frac{\\ln(20)}{60}\n$$\n使用计算器计算 $\\ln(20)$ 的值：\n$$\n\\ln(20) \\approx 2.99573227\n$$\n因此，\n$$\nk \\approx \\frac{2.99573227}{60} \\approx 0.04992887\n$$\n$k$ 的单位必须与控制律 $\\Delta(t) = \\Delta_{0} + k e(t)$ 一致。由于 $\\Delta(t)$ 是无量纲的，而 $e(t)$ 的单位是任务数，所以 $k$ 的单位必须是 任务数$^{-1}$。问题要求答案以 任务数$^{-1}$ 为单位，这是一致的。\n将结果四舍五入到四位有效数字，我们得到：\n$$\nk \\approx 0.04993\n$$", "answer": "$$\n\\boxed{0.04993}\n$$", "id": "3686449"}]}