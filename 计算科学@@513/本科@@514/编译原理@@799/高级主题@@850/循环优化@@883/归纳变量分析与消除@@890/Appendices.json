{"hands_on_practices": [{"introduction": "本练习将带你实践归纳变量优化的经典案例。我们将处理一个循环，其中包含一个依赖于循环计数器的乘法运算，并将其转换为一个只使用加法的更高效版本，从而阐释强度削减的核心原理。这个练习有助于建立对编译器如何用低开销操作替代高开销操作的基础理解。[@problem_id:3644333]", "problem": "在编译器原理的全局优化策略背景下，考虑一个归纳变量的强度削弱。设 $A$ 是一个整数数组，定义为对于所有整数 $k$，$A[k] = k$。设 $L$、$U$、$s$ 和 $c$ 为整数，其中 $s \\in \\mathbb{Z}_{0}$，$U  L$，且 $s$ 整除 $U - L$。考虑以下将值累加到标量 $sum$ 的程序片段：\n- 初始化 $sum := 0$。\n- 对于 $i := L$；当 $i  U$ 时；执行 $i := i + s$：\n  - 令 $x := i \\cdot 2 + c$。\n  - 更新 $sum := sum + A[x]$。\n\n仅使用循环的操作语义和归纳变量的定义，推导此循环的一个强度削弱版本。该版本将循环内的乘以 2 操作替换为一个派生变量的增量操作，该派生变量在每次迭代中由一个循环不变量进行更新，同时保持程序对 $sum$ 的可观察行为不变。通过显式地关联转换前后累加的值，证明该转换是语义保持的。\n\n最后，计算循环退出时 $sum$ 值的闭式解析表达式，用 $L$、$U$、$s$ 和 $c$ 表示。将您的答案表示为单个简化的解析表达式。无需四舍五入，不涉及单位。最终答案必须是单个表达式。", "solution": "该问题要求做三件事：首先，对给定的程序片段执行循环强度削弱；其次，证明此转换是语义保持的；第三，计算累加器变量 `sum` 最终值的闭式解析表达式。\n\n问题陈述已经过验证，具有科学依据、问题定义明确且客观。它包含了所有必要信息，没有矛盾之处。\n\n原始程序片段如下：\n- 初始化 $sum := 0$。\n- 对于 $i := L$；当 $i  U$ 时；执行 $i := i + s$：\n  - 令 $x := i \\cdot 2 + c$。\n  - 更新 $sum := sum + A[x]$。\n\n给定条件如下：\n- $A$ 是一个数组，满足对于所有整数 $k$，$A[k] = k$。\n- $L, U, s, c$ 是整数。\n- $s \\in \\mathbb{Z}_{0}$，$U  L$，且 $s$ 整除 $U - L$。\n\n**第一部分：循环强度削弱**\n\n变量 $i$ 是循环的基本归纳变量。它被初始化为 $L$，并在每次迭代中增加一个循环不变量 $s$。\n变量 $x$ 是一个派生归纳变量，因为它在每次迭代中的值是基本归纳变量 $i$ 的线性函数：$x = 2i + c$。\n\n我们来分析在连续迭代中 $i$ 和 $x$ 的值。设 $i_j$ 和 $x_j$ 分别为第 $j$ 次迭代中（其中 $j=0, 1, 2, \\dots$）$i$ 和 $x$ 的值。\n下一次迭代中 $i$ 的值 $i_{j+1}$ 为 $i_{j+1} = i_j + s$。\n$x$ 的相应值 $x_{j+1}$ 为：\n$$x_{j+1} = 2 \\cdot i_{j+1} + c = 2 \\cdot (i_j + s) + c = (2 \\cdot i_j + c) + 2 \\cdot s$$\n注意到 $x_j = 2 \\cdot i_j + c$，我们得到递推关系：\n$$x_{j+1} = x_j + 2s$$\n这表明 $x$ 的值在每次迭代中增加一个循环不变量常数 $2s$。因此，乘法 $i \\cdot 2$ 可以被一个加法替换。这就是强度削弱的核心。\n\n我们引入一个新变量，称之为 $x'$，用来追踪 $x$ 的值。\n1.  在循环之前，$x'$ 必须被初始化为 $x$ 在第一次迭代中应有的值。$i$ 的初始值是 $L$，所以我们初始化 $x' := 2 \\cdot L + c$。\n2.  在循环内部，我们使用 $x'$ 来代替表达式 $2 \\cdot i + c$。对 `sum` 的更新变为 $sum := sum + A[x']$。\n3.  在使用 $x'$ 之后，我们使用推导出的递推关系为下一次迭代更新它：$x' := x' + 2s$。\n\n强度削弱后的程序片段如下：\n- 初始化 $sum := 0$。\n- 初始化 $x' := 2 \\cdot L + c$。\n- 对于 $i := L$；当 $i  U$ 时；执行 $i := i + s$：\n  - 更新 $sum := sum + A[x']$。\n  - 更新 $x' := x' + 2s$。\n\n**第二部分：语义保持证明**\n\n我们必须证明强度削弱后的循环计算出的 `sum` 最终值与原始循环相同。\n设循环控制变量 $i$ 取值的序列为 $i_0, i_1, \\dots, i_{N-1}$，其中 $N$ 是总迭代次数。我们有 $i_j = L + j \\cdot s$。\n\n在原始循环中，第 $j$ 次迭代使用的 $x$ 值为 $x_j$：\n$$x_j = 2 \\cdot i_j + c = 2(L + j \\cdot s) + c = 2L + c + 2sj$$\n加到 `sum` 上的值序列是 $A[x_0], A[x_1], \\dots, A[x_{N-1}]$。\n\n在转换后的循环中，使用了一个新变量 $x'$。我们将其在第 $j$ 次迭代开始时的值表示为 $x'_j$。\n- 初始化：在循环开始前，$x'$ 被初始化为 $x'_0 = 2L + c$。这是在第一次迭代（$j=0$）中使用的值。\n- 更新：在第 $j$ 次迭代结束时，$x'$ 被更新以用于第 $j+1$ 次迭代：$x'_{j+1} = x'_j + 2s$。\n\n我们可以通过展开递推关系来找到 $x'_j$ 的闭式解：\n$x'_0 = 2L + c$\n$x'_1 = x'_0 + 2s = (2L+c) + 2s$\n$x'_2 = x'_1 + 2s = (2L+c) + 2s + 2s = 2L+c + 2(2s)$\n通过归纳法，第 $j$ 次迭代中使用的 $x'$ 值为：\n$$x'_j = 2L + c + j \\cdot 2s$$\n比较原始循环中的值 $x_j$ 和转换后循环中的值 $x'_j$，我们发现对于所有 $j=0, 1, \\dots, N-1$，$x_j = x'_j$。\n由于两个循环中用作数组 $A$ 索引的值序列是相同的（$x_0, x_1, \\dots$ 和 $x'_0, x'_1, \\dots$），并且 `sum` 变量在两种情况下都初始化为 0，因此加到 `sum` 上的值序列 $A[x_j]$ 是相同的。所以，`sum` 的最终值相同，该转换是语义保持的。\n\n**第三部分：`sum` 的闭式表达式**\n\n`sum` 的最终值是所有循环迭代中 $A[x]$ 的总和。由于 $A[k]=k$，这也就是 $x$ 本身值的总和。\n$$sum = \\sum_{j=0}^{N-1} x_j$$\n首先，我们确定迭代次数 $N$。只要 $i  U$，循环就会继续。$i$ 的取值为 $L, L+s, L+2s, \\dots, L+(N-1)s$。当 $i \\ge U$ 时循环终止。所以，最后一次迭代是满足 $L+(N-1)s  U$ 的那次迭代。\n$$ (N-1)s  U-L \\implies N-1  \\frac{U-L}{s} \\implies N  \\frac{U-L}{s} + 1 $$\n我们已知 $s$ 整除 $U-L$。设 $\\frac{U-L}{s} = K$，其中 $K$ 是一个正整数。\n条件变为 $N  K+1$。由于 $N$ 必须是整数，所以迭代次数为 $N=K$。\n因此，迭代次数为 $N = \\frac{U-L}{s}$。\n\n现在我们计算总和。被相加的项 $x_j = 2L + c + 2sj$ 构成一个等差数列。\n等差数列的和由公式 $S_N = \\frac{N}{2}(\\text{首项} + \\text{末项})$ 给出。\n- 项数：$N = \\frac{U-L}{s}$。\n- 首项 ($j=0$)：$x_0 = 2L + c$。\n- 末项 ($j=N-1$)：$x_{N-1} = 2L + c + 2s(N-1)$。\n\n总和为：\n$$ sum = \\frac{N}{2}(x_0 + x_{N-1}) = \\frac{N}{2}((2L+c) + (2L+c+2s(N-1))) $$\n$$ sum = \\frac{N}{2}(4L + 2c + 2s(N-1)) = N(2L+c+s(N-1)) $$\n现在，代入 $N = \\frac{U-L}{s}$：\n$$ sum = \\left(\\frac{U-L}{s}\\right) \\left(2L+c+s\\left(\\frac{U-L}{s}-1\\right)\\right) $$\n$$ sum = \\left(\\frac{U-L}{s}\\right) (2L+c+(U-L)-s) $$\n简化括号内的表达式：\n$$ sum = \\left(\\frac{U-L}{s}\\right) (L+U+c-s) $$\n这就是 `sum` 的最终闭式解析表达式。", "answer": "$$ \\boxed{\\frac{(U-L)(L+U+c-s)}{s}} $$", "id": "3644333"}, {"introduction": "真实世界的代码常常包含条件性中断或提前退出，这会使优化变得复杂。本练习挑战你在一个带有 `break` 语句的循环中正确应用归纳变量消除。关键在于仔细分析程序状态，确保转换对所有可能的执行路径都有效，这突显了语义保持的重要性。[@problem_id:3645851]", "problem": "当条件 $A[i]  k$ 满足时，一个循环通过 break 提前退出。该循环使用索引 $i$ 作为基本归纳变量，并维护一个单独的计数器 $iter$，该计数器仅用于日志记录（累加校验和）。考虑以下循环语义的规范，其中每次迭代内的所有更新都按所示顺序发生：\n- 初始化：$i \\leftarrow 0$, $iter \\leftarrow 1$, $checksum \\leftarrow 0$。\n- 当 $i  n$ 时：\n  - 如果 $A[i]  k$，则 break。\n  - $checksum \\leftarrow checksum + iter$。\n  - $iter \\leftarrow iter + 2$。\n  - $i \\leftarrow i + 1$。\n\n假设 $A$ 是一个长度为 $n$ 的一维数组，其元素由等差数列 $A[i] = a + d \\cdot i$ 定义，适用于所有满足 $0 \\le i  n$ 的整数 $i$，其中 $a$ 和 $d$ 是固定的整数且 $d  0$。假设 $iter$ 在循环外不被使用，也不用于控制流。机器模型是标准的顺序执行模型：每个循环体实例构成一次迭代，按程序顺序执行，break 会立即终止循环，而不执行该次迭代中后续的语句。\n\n仅使用编译器理论中的以下基本概念：\n- 基本归纳变量（BIV）是在每次循环体执行时都以固定增量变化的变量（例如，对于某个常数 $c$，$i \\leftarrow i + c$）。\n- 派生归纳变量（DIV）是任何可以在一个一致的程序点上表示为 BIV 的仿射函数的循环变量（例如，$x = \\alpha \\cdot i + \\beta$，其中 $i$ 是一个 BIV，$\\alpha$、$\\beta$ 是常数），前提是该表达式在该程序点有效，且变量 $x$ 没有以破坏仿射关系的方式被其他方式修改。\n- 一个保语义转换必须在转换后程序中所有可达的原始执行的有限前缀上，保持所有关注的程序点上观测到的值不变。\n\n任务：\n1. 在更新 $checksum$ 的程序点，识别哪个变量是基本归纳变量，哪个是派生归纳变量。推导在该点对每次到达它的迭代都成立的、用 $i$ 表示 $iter$ 的仿射关系，推导过程不假设 $a$、$d$、$k$ 或 $n$ 的任何具体数值。\n2. 使用此仿射关系从循环中消除 $iter$，同时在每条执行路径上（包括通过 break 提前退出）都保持 $checksum$ 中累加的精确值。说明在存在提前退出的情况下，使得这种消除能够保持语义的关键条件是什么。\n3. 现在将参数实例化为 $n = 50$、$a = 7$、$d = 3$ 和 $k = 61$。计算循环终止时 $checksum$ 的确切最终值。你的最终答案必须是一个实数值，不需要四舍五入。", "solution": "在尝试求解之前，将首先验证问题的科学合理性、自洽性和完整性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **初始化**：$i \\leftarrow 0$, $iter \\leftarrow 1$, $checksum \\leftarrow 0$。\n- **循环条件**：`while` $i  n$。\n- **循环体（按顺序）**：\n    1. `if` $A[i] > k$, `break`。\n    2. $checksum \\leftarrow checksum + iter$。\n    3. $iter \\leftarrow iter + 2$。\n    4. $i \\leftarrow i + 1$。\n- **数组定义**：$A[i] = a + d \\cdot i$ for $0 \\le i  n$。\n- **参数约束**：$a, d$ 是整数；$d > 0$。\n- **变量角色**：$i$ 是基本归纳变量（BIV）。$iter$ 仅用于日志记录。\n- **执行模型**：标准顺序执行；`break` 是立即的。\n- **理论基础**：BIV、派生归纳变量（DIV）和保语义转换的定义。\n- **任务**：\n    1. 识别 BIV 和 DIV，并推导在 $checksum$ 更新点上的仿射关系 $iter = f(i)$。\n    2. 解释如何消除 $iter$ 以及在存在提前退出时保持语义的条件。\n    3. 对于 $n = 50$，$a = 7$，$d = 3$ 和 $k = 61$，计算 $checksum$ 的最终值。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在编译器理论领域内定义明确，特别关注归纳变量分析和强度削弱，这是一种标准的优化技术。\n- **科学性/事实性**：该问题基于已确立的计算机科学原理。归纳变量和程序语义的概念是编译器设计的基础。没有违反任何科学定律。\n- **适定性**：问题描述足够详细。初始状态、循环不变量、更新规则和终止条件都已明确说明，从而可以得出一个唯一的、可确定的解。\n- **客观性与完整性**：问题以精确、客观的语言陈述。所有必要的参数和定义都已提供。它不包含任何矛盾。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。将着手制定解决方案。\n\n### 解答\n\n**任务 1：识别归纳变量和仿射关系**\n\n基本归纳变量（BIV）是在每次循环迭代中其值都以一个固定常量改变的变量。变量 $i$ 初始化为 $0$，并在每次没有提前退出的迭代中通过 $i \\leftarrow i + 1$ 更新。因此，它符合 BIV 的定义，增量为 $1$。\n\n派生归纳变量（DIV）是其值可以表示为 BIV 的仿射函数的变量，即 $x = \\alpha \\cdot i + \\beta$，其中 $\\alpha$ 和 $\\beta$ 是常数。我们研究 $iter$ 是否是相对于 BIV $i$ 的一个 DIV。\n\n让我们追踪每次迭代开始时 $i$ 和 $iter$ 的值，该程序点与 $checksum$ 更新发生的程序点相同（因为更新发生在循环体内 $i$ 和 $iter$ 被修改之前）。\n- 在迭代 $i=0$ 之前：$i=0$, $iter=1$。\n- 在迭代 $i=1$ 之前：上一次迭代（$i=0$）完成，所以 $i$ 变为 $0+1=1$，$iter$ 变为 $1+2=3$。\n- 在迭代 $i=2$ 之前：上一次迭代（$i=1$）完成，所以 $i$ 变为 $1+1=2$，$iter$ 变为 $3+2=5$。\n\n我们观察到一个模式。令 $iter_i$ 为给定索引 $i$ 的循环体开始时 $iter$ 的值。\n对于 $i=0$, $iter_0 = 1 = 2(0)+1$。\n对于 $i=1$, $iter_1 = 3 = 2(1)+1$。\n对于 $i=2$, $iter_2 = 5 = 2(2)+1$。\n\n这表明存在仿射关系 $iter = 2i + 1$。我们用归纳法证明这一点。\n- **基本情况**：对于第一次迭代（$i=0$），初始值为 $iter=1$。公式给出 $2(0)+1=1$。基本情况成立。\n- **归纳步骤**：假设对于某个迭代 $j \\ge 0$，在迭代开始时 $iter$ 的值为 $2j+1$。如果这次迭代完成，下一次迭代开始时的值将被更新。$i$ 的新值将是 $j+1$。$iter$ 的新值将是 $(2j+1)+2 = 2j+3$。我们可以将其重写为 $2(j+1)+1$。这与下一个索引 $j+1$ 的仿射关系形式相匹配。\n\n因此，关系式 $iter = 2i + 1$ 在更新 $checksum$ 的程序点上成立，适用于到达此点的每一次迭代 $i$。所以，$i$ 是 BIV，而 $iter$ 是相对于 $i$ 的 DIV，其中 $\\alpha=2$ 且 $\\beta=1$。\n\n**任务 2：消除 `iter` 与语义保持**\n\n给定仿射关系 $iter = 2i + 1$，我们可以执行强度削弱转换。原始更新是 $checksum \\leftarrow checksum + iter$。我们替换 $iter$ 的表达式：\n$checksum \\leftarrow checksum + (2i + 1)$。\n\n转换后的循环变为：\n- 初始化：$i \\leftarrow 0$, $checksum \\leftarrow 0$。\n- `while` $i  n$:\n    - `if` $A[i] > k$, `break`。\n    - $checksum \\leftarrow checksum + (2i + 1)$。\n    - $i \\leftarrow i + 1$。\n\n变量 $iter$ 及其更新 $iter \\leftarrow iter + 2$ 现在是死代码，因为题目说明了 $iter$ 在此累加之外不被使用。它们可以通过死代码消除来移除。\n\n即使存在提前退出，使这种消除能够保持语义的关键条件是，仿射关系 $iter = 2i+1$ 在使用 $iter$ 的*特定程序点*（即 $checksum$ 更新点）上成立。`break` 语句在此点*之前*有条件地执行。\n- 如果对于索引 $i$，`break` 条件满足，循环终止，语句 $checksum \\leftarrow checksum + iter$ 不会为这个 $i$ 执行。在转换后的循环中，语句 $checksum \\leftarrow checksum + (2i+1)$ 也不会执行。行为是相同的。\n- 如果对于索引 $i$，`break` 条件不满足，$checksum$ 更新会被执行。在这一点上，$iter$ 的值保证为 $2i+1$。转换后的代码使用这个等价表达式，导致加到 $checksum$ 上的值相同。\n因此，该转换在所有可能的执行路径上都保持了语义。\n\n**任务 3：计算最终的 `checksum`**\n\n给定参数 $n = 50$，$a = 7$，$d = 3$ 和 $k = 61$。\n数组元素由 $A[i] = a + d \\cdot i = 7 + 3i$ 定义。\n如果 $A[i] > k$，循环会提前终止，即：\n$7 + 3i > 61$\n$3i > 54$\n$i > 18$\n\n由于 $i$ 必须是整数，满足此条件的第一个 $i$ 的值是 $i = 19$。\n这意味着循环将对 $i = 0, 1, 2, \\dots, 18$ 执行。当循环开始对 $i=19$ 进行迭代时，条件 $A[19] > 61$ 将为真（$7 + 3(19) = 64 > 61$），并且 `break` 语句将被执行。因此，对于 $i=19$ 或任何后续索引，将不会执行 $checksum$ 更新。\n\n$checksum$ 的最终值是所有执行到 $checksum$ 更新的迭代中 $(2i+1)$ 项的总和。这对应于 $i$ 从 $0$ 到 $18$ 的范围。\n$$ checksum_{final} = \\sum_{i=0}^{18} (2i + 1) $$\n我们可以拆分这个求和：\n$$ checksum_{final} = \\left( \\sum_{i=0}^{18} 2i \\right) + \\left( \\sum_{i=0}^{18} 1 \\right) $$\n$$ checksum_{final} = 2 \\left( \\sum_{i=0}^{18} i \\right) + (18 - 0 + 1) \\cdot 1 $$\n前 $N$ 个非负整数的和由公式 $\\sum_{i=0}^{N} i = \\frac{N(N+1)}{2}$ 给出。对于 $N=18$：\n$$ \\sum_{i=0}^{18} i = \\frac{18(18+1)}{2} = \\frac{18 \\times 19}{2} = 9 \\times 19 = 171 $$\n将此代入 $checksum_{final}$ 的表达式中：\n$$ checksum_{final} = 2(171) + 19 $$\n$$ checksum_{final} = 342 + 19 = 361 $$\n另外，我们也可以认识到这个求和是前 19 个奇数的和（$2(0)+1, 2(1)+1, \\dots, 2(18)+1$）。前 $m$ 个奇数的和是 $m^2$。这里，有 $m=19$ 个项（从 $i=0$ 到 $i=18$），所以和是 $19^2 = 361$。\n$checksum$ 的最终值是 $361$。", "answer": "$$\\boxed{361}$$", "id": "3645851"}, {"introduction": "编译器优化并非在真空中进行，它受到目标硬件的制约。这个问题让你扮演编译器设计者的角色，为一种RISC架构优化内存访问。你需要确定最佳的循环步长以最大化性能，同时遵守机器指令集的限制，这展示了高级优化中涉及的实际权衡。[@problem_id:3645833]", "problem": "考虑编译器中间表示中的一个循环，该循环通过从单个循环计数器派生的线性索引表达式，对两个数组进行累加计算。设 $A$ 和 $B$ 是 $32$ 位整数数组，因此每个元素的大小为 $e=4$ 字节。该循环为\n$$\n\\text{for } i = 0,1,2,\\dots,N-1:\\quad x \\leftarrow x + g\\!\\left(A[2i + c_1],\\, B[3i + c_2]\\right),\n$$\n其中 $N=4080$ 且 $c_1,c_2 \\in \\mathbb{Z}$ 是固定的偏移量，其选择可确保所有访问都在数组边界内。假设在一个精简指令集计算机 (RISC) 架构中，指针增量使用单个立即数加法指令，其立即数字段是一个有符号的 $12$ 位常数。这使得可表示的字节增量受限于 $I_{\\max} = 2047$。\n\n你需要执行归纳变量分析与消除。将 $i$ 形式化为基本归纳变量 (BIV)，并识别出 $2i+c_1$ 和 $3i+c_2$ 都是归纳变量的线性函数。引入指针变量 $p_A$ 和 $p_B$，使得循环被重写为使用独立的指针增量，其步长与选定的 BIV 步长 $s \\in \\mathbb{Z}_{0}$（以迭代次数为单位）成比例，从而从地址算术中消除 $i$。在这个转换后的循环中，每次迭代的指针更新量（以字节为单位）为：\n$$\n\\Delta_A(s) = (2s)\\,e,\\qquad \\Delta_B(s) = (3s)\\,e.\n$$\n\n在以下约束条件下：\n- 两个指针增量都必须能编码为单个立即数加法指令，即 $|\\Delta_A(s)| \\leq I_{\\max}$ 和 $|\\Delta_B(s)| \\leq I_{\\max}$。\n- BIV 步长必须能整除循环总次数，以避免产生余数循环，即 $s \\mid N$。\n\n选择 $s$ 以通过减少迭代次数来最小化动态循环开销，这等同于在满足上述约束的条件下最大化 $s$。确定最优步长 $s^{\\ast}$。\n\n你的最终答案必须是 $s^{\\ast}$ 的单个整数值。无需四舍五入，最终的方框答案中不应包含任何单位。", "solution": "问题要求为循环变换（特别是归纳变量消除）找到最优步长 $s^{\\ast}$。目标是在架构和循环结构约束下，最大化步长 $s \\in \\mathbb{Z}_{0}$，以最小化总循环迭代次数。\n\n该问题可以形式化为一个优化问题：\n最大化 $s$\n约束条件为：\n1.  数组 A 和 B 的指针增量必须能在单个指令内编码。\n2.  步长 $s$ 必须能整除总迭代次数 $N$。\n\n让我们对每个约束进行数学分析。\n\n已知条件如下：\n- 循环总次数为 $N=4080$。\n- 数组 $A$ 和 $B$ 的元素大小为 $e=4$ 字节（对于32位整数）。\n- 指针增量指令的最大立即数值为 $I_{\\max} = 2047$。\n- 每次转换后循环迭代（对应于 $s$ 次原始迭代的步长）的指针增量为 $\\Delta_A(s) = (2s)e$ 和 $\\Delta_B(s) = (3s)e$。\n- 步长 $s$ 必须是正整数，即 $s \\in \\mathbb{Z}_{0}$。\n\n约束 1：指令编码\n指针增量的字节大小不得超过指令立即数字段可表示的最大值。这由以下公式给出：\n$$|\\Delta_A(s)| \\leq I_{\\max}$$\n$$|\\Delta_B(s)| \\leq I_{\\max}$$\n\n由于 $s$ 是一个正整数（$s  0$）且元素大小 $e=4$ 是正数，增量 $\\Delta_A(s)$ 和 $\\Delta_B(s)$ 总是正数。因此，绝对值符号是多余的。约束变为：\n$$(2s)e \\leq I_{\\max}$$\n$$(3s)e \\leq I_{\\max}$$\n\n我们可以解这些关于 $s$ 的不等式。\n对于第一个涉及数组 $A$ 的不等式：\n$$s \\leq \\frac{I_{\\max}}{2e}$$\n代入给定值 $I_{\\max} = 2047$ 和 $e=4$：\n$$s \\leq \\frac{2047}{2 \\times 4} = \\frac{2047}{8} = 255.875$$\n\n对于第二个涉及数组 $B$ 的不等式：\n$$s \\leq \\frac{I_{\\max}}{3e}$$\n代入给定值 $I_{\\max} = 2047$ 和 $e=4$：\n$$s \\leq \\frac{2047}{3 \\times 4} = \\frac{2047}{12} \\approx 170.583$$\n\n为了使 $s$ 成为一个有效的步长，它必须同时满足这两个条件。因此，$s$ 必须小于或等于两个上界中的最小值：\n$$s \\leq \\min\\left(\\frac{2047}{8}, \\frac{2047}{12}\\right)$$\n更严格（更小）的界限来自第二个不等式：\n$$s \\leq \\frac{2047}{12}$$\n由于 $s$ 必须是整数，我们对该值取下整：\n$$s \\leq \\left\\lfloor \\frac{2047}{12} \\right\\rfloor$$\n为了求下整，我们执行除法：$2047 = 12 \\times 170 + 7$。因此，$\\lfloor \\frac{2047}{12} \\rfloor = 170$。\n因此，指令编码约束对步长施加了一个上界：\n$$s \\leq 170$$\n\n约束 2：循环划分\n问题陈述，所选步长 $s$ 必须能整除总循环次数 $N$，以避免出现“余数”或“收尾”循环。这是一个可除性约束：\n$$s \\mid N$$\n给定 $N=4080$，这意味着 $s$ 必须是 $4080$ 的一个因数。\n\n结合约束条件\n我们正在寻找最优步长 $s^{\\ast}$，它是满足以下两个约束条件的 $s$ 的最大值：\n1.  $s \\leq 170$\n2.  $s \\mid 4080$\n\n问题现在简化为找到 $4080$ 的小于或等于 $170$ 的最大因数。\n我们可以通过从 $170$ 开始向下检查整数，看它们是否是 $4080$ 的因数来找到这个值。我们找到的第一个这样的整数将是 $s$ 的最大可能值。\n\n让我们测试 $s=170$。我们需要检查 $170$ 是否能整除 $4080$。\n$$\\frac{4080}{170} = \\frac{408}{17}$$\n执行除法：\n$17 \\times 20 = 340$。\n$408 - 340 = 68$。\n$17 \\times 4 = 68$。\n所以，$17 \\times 24 = 408$。\n因此，$\\frac{4080}{170} = 24$。\n由于结果是整数，所以 $170$ 是 $4080$ 的一个因数。\n\n值 $s=170$ 满足两个约束条件：\n1.  $170 \\leq 170$ (成立)\n2.  $170 \\mid 4080$ (成立)\n\n因为我们寻求最大化 $s$，并且我们找到了一个值 $s=170$，它既满足可除性约束，也是编码约束所允许的最大值，所以这必定是最优步长。\n任何大于 $170$ 的 $s$ 值都会违反 $\\Delta_B$ 的编码约束。任何小于 $170$ 的 $4080$ 的因数都会导致一个次优（更小）的步长。\n因此，最优步长是 $s^{\\ast} = 170$。\n使用此步长，转换后的循环将运行 $N/s^{\\ast} = 4080/170 = 24$ 次迭代，从而显著减少循环开销。新循环体内的指针增量将是 $\\Delta_A = 2 \\times 170 \\times 4 = 1360$ 字节和 $\\Delta_B = 3 \\times 170 \\times 4 = 2040$ 字节。两者都小于或等于 $I_{\\max}=2047$。", "answer": "$$\\boxed{170}$$", "id": "3645833"}]}