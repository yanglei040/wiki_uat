{"hands_on_practices": [{"introduction": "在进行任何循环优化之前，首要且最关键的步骤是验证其合法性——即确保转换不会改变程序的原始语义。此练习 [@problem_id:3652959] 为您提供了使用数据依赖向量这一基本工具进行此项验证的实践。通过分析给定的内存访问模式，您将学会如何系统地识别依赖关系并判断循环交换是否会破坏程序的正确性。", "problem": "您正在一个面向随机存取存储器（RAM）并采用行主序数组布局的编译器中，分析一个完美嵌套的双层循环。该程序操作一个大小为 $N \\times N$（其中 $N \\geq 3$）的二维数组 $A$，且数组 $A$ 在循环嵌套之前已被初始化。循环索引在以下有限的凸迭代空间中进行迭代：\n- 对于外层循环，$i$ 的范围是从 $1$ 到 $N-1$。\n- 对于内层循环，$j$ 的范围是从 $1$ 到 $N-1$。\n\n循环体对 $A$ 执行两次写操作和一次读操作，如下所示：\n- 一次对 $A[i][j]$ 的写操作，\n- 一次对 $A[i][j+1]$ 的写操作，\n- 一次从 $A[i+1][j]$ 的读操作。\n\n假设没有别名（aliasing）并且没有修改 $A$ 的中间函数调用。程序的语义仅取决于对 $A$ 的内存操作的相对顺序。\n\n任务：使用数据依赖（流依赖、反依赖和输出依赖）的基本定义以及嵌套循环的方向/距离向量，将原始执行顺序视为以 $i$ 为外层、$j$ 为内层的字典序，记为 $(i,j)$。考虑将循环交换为 $(j,i)$，并通过检查置换后的方向向量来确定语义是否被保留。一次循环交换是合法的，当且仅当它不违反任何数据依赖关系。使用方向向量分析时，此条件等价于：对于每个循环携带的依赖，其方向向量在交换后不能是字典序负的（例如，形如 (-, +) 或 (-, 0) 的向量）。\n\n定义合法性指示符 $L$ 如下\n$$\nL =\n\\begin{cases}\n1,  \\text{如果从 } (i,j) \\text{ 到 } (j,i) \\text{ 的交换保留语义},\\\\\n0,  \\text{否则。}\n\\end{cases}\n$$\n\n仅使用方向/距离向量推理作为基本依据，计算此循环嵌套的 $L$。答案必须是等于 $0$ 或 $1$ 的单个实数。不允许进行重命名变换（例如值分裂或创建临时变量）。您无需提供任何四舍五入，也没有物理单位适用。", "solution": "该问题要求我们确定交换一个完美嵌套的双层循环的合法性。合法性由一个指示变量 $L$ 表示，其中 $L=1$ 表示交换合法，否则 $L=0$。合法性分析必须基于使用方向向量形式化的数据依赖关系。\n\n首先，让我们建立分析的框架。循环嵌套的执行在迭代向量 $(i,j)$ 的集合上定义了一个字典序。如果 $i_1  i_2$ 或者 ($i_1 = i_2$ 且 $j_1  j_2$)，则迭代 $(i_1, j_1)$ 在迭代 $(i_2, j_2)$ 之前执行，记为 $(i_1, j_1) \\prec (i_2, j_2)$。\n\n如果满足以下条件，则存在从迭代 $\\vec{I}_1 = (i_1, j_1)$ 中的一个操作到迭代 $\\vec{I}_2 = (i_2, j_2)$ 中的一个操作的数据依赖：\n1. 两个操作访问相同的内存位置。\n2. 至少有一个操作是写操作。\n3. 执行顺序为 $\\vec{I}_1 \\prec \\vec{I}_2$。\n\n循环体包含对大小为 $N \\times N$ 的二维数组 $A$ 的三个内存操作：\n- $S_1$：对 $A[i][j]$ 的一次写操作。\n- $S_2$：对 $A[i][j+1]$ 的一次写操作。\n- $S_3$：从 $A[i+1][j]$ 的一次读操作。\n\n迭代空间由 $1 \\le i \\le N-1$ 和 $1 \\le j \\le N-1$ 定义。\n\n一个依赖由一个距离向量 $\\vec{d} = \\vec{I}_2 - \\vec{I}_1 = (i_2-i_1, j_2-j_1) = (d_i, d_j)$ 和一个方向向量 $\\vec{v} = (\\text{sgn}(d_i), \\text{sgn}(d_j))$ 来表征，其中 $\\text{sgn}$ 是符号函数。要使一个依赖成为循环携带的（loop-carried），其距离向量必须是字典序正的，即 $\\vec{d} \\succ (0,0)$。\n\n我们分析两个不同迭代 $\\vec{I}_1$ 和 $\\vec{I}_2$（其中 $\\vec{I}_1 \\prec \\vec{I}_2$）之间所有可能的操作对，以找出所有循环携带的依赖关系。\n\n1.  **流依赖（写后读，RAW）：** 从在 $\\vec{I}_1$ 的写操作到在 $\\vec{I}_2$ 的读操作。\n    - $S_1(\\vec{I}_1) \\to S_3(\\vec{I}_2)$：从 `写 A[i_1][j_1]` 到 `读 A[i_2+1][j_2]`。\n      为了发生内存冲突，需要满足 $i_1 = i_2+1$ 和 $j_1 = j_2$。这给出的距离向量分量为 $d_i = i_2 - i_1 = -1$。由于 $d_i  0$，$\\vec{I}_1$ 将在 $\\vec{I}_2$ 之后执行，这违反了依赖条件 $\\vec{I}_1 \\prec \\vec{I}_2$。因此，不存在依赖。\n    - $S_2(\\vec{I}_1) \\to S_3(\\vec{I}_2)$：从 `写 A[i_1][j_1+1]` 到 `读 A[i_2+1][j_2]`。\n      为了发生冲突，需要满足 $i_1 = i_2+1$ 和 $j_1+1 = j_2$。这给出的距离向量分量为 $d_i = i_2 - i_1 = -1$，再次违反了 $\\vec{I}_1 \\prec \\vec{I}_2$。不存在依赖。\n\n2.  **反依赖（读后写，WAR）：** 从在 $\\vec{I}_1$ 的读操作到在 $\\vec{I}_2$ 的写操作。\n    - $S_3(\\vec{I}_1) \\to S_1(\\vec{I}_2)$：从 `读 A[i_1+1][j_1]` 到 `写 A[i_2][j_2]`。\n      为了发生冲突，需要满足 $i_1+1 = i_2$ 和 $j_1 = j_2$。\n      距离向量为 $\\vec{d} = (i_2-i_1, j_2-j_1) = (1, 0)$。\n      条件 $\\vec{I}_1 \\prec \\vec{I}_2$ 得到满足，因为 $i_2 = i_1+1 > i_1$。\n      如果存在有效的迭代向量，则此依赖存在。对于 $N \\ge 3$，我们可以选择 $i_1=1, j_1=1$，得到 $\\vec{I}_1 = (1,1)$ 和 $\\vec{I}_2 = (2,1)$。两者都在迭代空间内。\n      方向向量为 $\\vec{v}_1 = (\\text{sgn}(1), \\text{sgn}(0)) = (+, 0)$。\n\n    - $S_3(\\vec{I}_1) \\to S_2(\\vec{I}_2)$：从 `读 A[i_1+1][j_1]` 到 `写 A[i_2][j_2+1]`。\n      为了发生冲突，需要满足 $i_1+1 = i_2$ 和 $j_1 = j_2+1$。\n      距离向量为 $\\vec{d} = (i_2-i_1, j_2-j_1) = (1, -1)$。\n      条件 $\\vec{I}_1 \\prec \\vec{I}_2$ 得到满足，因为 $i_2 = i_1+1 > i_1$。\n      如果存在有效的迭代向量，则此依赖存在。我们需要 $1 \\le i_1 \\le N-2$ 和 $2 \\le j_1 \\le N-1$。对于 $N \\ge 3$，我们可以选择 $i_1=1, j_1=2$，得到 $\\vec{I}_1=(1,2)$ 和 $\\vec{I}_2=(2,1)$。两者都是有效的迭代。\n      方向向量为 $\\vec{v}_2 = (\\text{sgn}(1), \\text{sgn}(-1)) = (+, -)$。\n\n3.  **输出依赖（写后写，WAW）：** 从在 $\\vec{I}_1$ 的写操作到在 $\\vec{I}_2$ 的写操作。\n    - $S_1(\\vec{I}_1) \\to S_1(\\vec{I}_2)$：从 `写 A[i_1][j_1]` 到 `写 A[i_2][j_2]`。冲突意味着 $\\vec{I}_1 = \\vec{I}_2$，因此没有循环携带的依赖。\n    - $S_2(\\vec{I}_1) \\to S_2(\\vec{I}_2)$：从 `写 A[i_1][j_1+1]` 到 `写 A[i_2][j_2+1]`。冲突意味着 $\\vec{I}_1 = \\vec{I}_2$，因此没有循环携带的依赖。\n    - $S_1(\\vec{I}_1) \\to S_2(\\vec{I}_2)$：从 `写 A[i_1][j_1]` 到 `写 A[i_2][j_2+1]`。\n      为了发生冲突，需要满足 $i_1=i_2$ 和 $j_1=j_2+1$。这给出的距离向量分量为 $d_j = j_2 - j_1 = -1$。由于 $d_i=0$，这要求 $j_1  j_2$ 才能构成有效依赖，但这与 $j_1 > j_2$ 相矛盾。不存在依赖。\n    - $S_2(\\vec{I}_1) \\to S_1(\\vec{I}_2)$：从 `写 A[i_1][j_1+1]` 到 `写 A[i_2][j_2]`。\n      为了发生冲突，需要满足 $i_1=i_2$ 和 $j_1+1=j_2$。\n      距离向量为 $\\vec{d} = (i_2-i_1, j_2-j_1) = (0, 1)$。\n      条件 $\\vec{I}_1 \\prec \\vec{I}_2$ 得到满足，因为 $i_1=i_2$ 且 $j_2 = j_1+1 > j_1$。\n      这个依赖是有效的。对于 $N \\ge 3$，选择 $i_1=1, j_1=1$，得到 $\\vec{I}_1=(1,1)$ 和 $\\vec{I}_2=(1,2)$。\n      方向向量为 $\\vec{v}_3 = (\\text{sgn}(0), \\text{sgn}(1)) = (0, +)$。\n\n循环携带的依赖关系由其方向向量总结如下：\n- $\\vec{v}_1 = (+, 0)$\n- $\\vec{v}_2 = (+, -)$\n- $\\vec{v}_3 = (0, +)$\n\n根据问题陈述，从 $(i,j)$ 到 $(j,i)$ 的循环交换是合法的，当且仅当对于每个依赖方向向量 $\\vec{v} = (v_i, v_j)$，置换后的向量 $\\vec{v}' = (v_j, v_i)$ 不是字典序负的。\n\n让我们测试我们的方向向量：\n1.  对于 $\\vec{v}_1 = (+, 0)$，置换后的向量是 $\\vec{v}'_1 = (0, +)$。这是字典序正的。这个依赖不阻止交换。\n2.  对于 $\\vec{v}_2 = (+, -)$，置换后的向量是 $\\vec{v}'_2 = (-, +)$。第一个分量是负的（'-'）。这个向量是字典序负的。这个依赖的存在使得循环交换非法。\n3.  对于 $\\vec{v}_3 = (0, +)$，置换后的向量是 $\\vec{v}'_3 = (+, 0)$。这是字典序正的。这个依赖不阻止交换。\n\n方向向量为 $\\vec{v}_2 = (+, -)$ 的反依赖的存在使得从 $(i,j)$ 到 $(j,i)$ 的循环交换非法。这个依赖在交换后会反转，意味着一个本应在另一个操作之前发生的操作将会在其之后发生，从而违反了程序的语义。例如，从 $\\vec{I}_1=(1,2)$ 到 $\\vec{I}_2=(2,1)$ 的反依赖确保了在迭代 $(1,2)$ 的 `读 A[2][2]` 操作发生在迭代 $(2,1)$ 的 `写 A[2][2]` 操作之前。交换后，迭代向量变为 $(j,i)$。读操作发生在 $(2,1)$，而写操作发生在 $(1,2)$。由于 $(1,2) \\prec (2,1)$，写操作将在读操作之前执行，这是不正确的。\n\n由于循环交换是非法的，合法性指示符 $L$ 为 $0$。", "answer": "$$\\boxed{0}$$", "id": "3652959"}, {"introduction": "在确认了循环交换的合法性之后，下一个自然的问题是“我们为什么要这么做？”。答案通常在于性能，尤其是改善内存局部性。这个练习 [@problem_id:3652895] 旨在通过构建一个量化的成本模型来深入探讨这一动机，将抽象的编译器转换与具体的硬件行为（如缓存命中和未命中）联系起来，从而让您亲身体会到循环交换对性能的潜在影响。", "problem": "考虑两个以行主序存储的稠密二维矩形数组：一个形状为 $N \\times M$ 的数组 $A$ 和一个形状为 $M \\times N$ 的数组 $B$，其中 $N$ 和 $M$ 是正整数，满足 $N \\geq 1$ 和 $M \\geq 1$。在行主序布局中，元素 $A[i][j]$ 相对于 $A$ 的基地址的偏移量为 $i \\cdot M + j$，而 $B[j][i]$ 相对于 $B$ 的基地址的偏移量为 $j \\cdot N + i$。考虑一个执行类似转置计算的嵌套迭代空间 $\\{(i,j) \\mid 0 \\leq i \\leq N-1,\\ 0 \\leq j \\leq M-1\\}$：对于每个 $(i,j)$，读取 $A[i][j]$ 的值并将其写入 $B[j][i]$。循环交换（Loop interchange）会改变 $i$ 和 $j$ 的迭代顺序。\n\n使用以下基本依据进行局部性和成本建模：\n- 在行主序中，与最右侧索引关联的维度在内存中是连续的。因此，当 $i$ 为外层循环、$j$ 为内层循环时，对 $A[i][j]$ 的访问是内存中的步长为1（连续访问），而对 $B[j][i]$ 的访问是步长为 $k = N$ 的流。当 $j$ 为外层循环、$i$ 为内层循环（交换后）时，对 $B[j][i]$ 的访问变为步长为1，而对 $A[i][j]$ 的访问变为步长为 $k' = M$ 的流。\n- 一个缓存行（cache line）包含 $L$ 个元素（假设 $L \\geq 1$ 是一个整数），并且数组足够大，以至于一旦缓存行被逐出，就不会有时间局部性复用；忽略行内空间局部性之外的容量和冲突影响。\n- 对于读取操作，一次缓存命中（cache hit）的成本为 $h_r$ 个周期，一次缓存未命中（cache miss）的成本为 $c_r$ 个周期，其中 $c_r \\geq h_r \\geq 0$。\n- 对于写入操作，假设采用写时分配（write-allocate）、写回（write-back）策略：对一个不在缓存中的缓存行的首次写入会产生分配并最终写回的成本，为 $c_{wa}$ 个周期；对同一驻留行的后续写入命中成本为 $h_w$ 个周期，其中 $c_{wa} \\geq h_w \\geq 0$。\n- 对于步长为1的流，每访问 $L$ 个元素会发生一次未命中，然后是 $L-1$ 次命中。对于步长为 $s$ 且 $s \\geq L$ 的流，假设每次访问都映射到不同的缓存行，因此都会未命中。\n\n通过指出每种循环顺序下哪个数组的步长为1、哪个数组的步长为k，来为这两种循环顺序提供一个具体的例子，然后构建如下的成本模型。令 $C_{\\text{orig}}$ 表示当 $i$ 为外层循环、$j$ 为内层循环时的总预期执行成本（以周期为单位），令 $C_{\\text{int}}$ 表示当 $j$ 为外层循环、$i$ 为内层循环时（交换后的顺序）的总预期执行成本（以周期为单位）。在上述假设下，并进一步假设 $k = N \\geq L$ 和 $k' = M \\geq L$，推导出一个关于 $N$、$M$、$L$、$c_r$、$h_r$、$c_{wa}$ 和 $h_w$ 的、单一的、完全简化的、闭式解析表达式，用于表示差值\n$$\\Delta C \\triangleq C_{\\text{int}} - C_{\\text{orig}}$$\n你的最终答案必须是单一的解析表达式。如果你引入任何辅助量，它们必须通过代数消元，以使最终表达式仅依赖于 $N$、$M$、$L$、$c_r$、$h_r$、$c_{wa}$ 和 $h_w$。以周期为单位表示最终的成本差异。不需要进行四舍五入。", "solution": "首先提取所有给定条件，然后评估其科学合理性、完整性和客观性，从而对问题进行验证。\n\n### 步骤1：提取给定条件\n- **数组和存储**:\n  - 数组 $A$：稠密、矩形、二维，形状为 $N \\times M$。\n  - 数组 $B$：稠密、矩形、二维，形状为 $M \\times N$。\n  - 两个数组都以行主序存储。\n  - $N$ 和 $M$ 是正整数，满足 $N \\geq 1$ 和 $M \\geq 1$。\n- **地址偏移**:\n  - $A[i][j]$ 的地址偏移为 $i \\cdot M + j$。\n  - $B[j][i]$ 的地址偏移为 $j \\cdot N + i$。\n- **计算**:\n  - 迭代空间: $\\{(i,j) \\mid 0 \\leq i \\leq N-1,\\ 0 \\leq j \\leq M-1\\}$。\n  - 操作：对于每个 $(i,j)$，从 $A[i][j]$ 读取一个元素并写入 $B[j][i]$。\n- **循环顺序**:\n  - 原始顺序 ($C_{\\text{orig}}$)：$i$ 是外层循环，$j$ 是内层循环。\n  - 交换后顺序 ($C_{\\text{int}}$)：$j$ 是外层循环，$i$ 是内层循环。\n- **局部性和步长**:\n  - 原始顺序：对 $A[i][j]$ 的访问步长为1。对 $B[j][i]$ 的访问步长为 $k=N$。\n  - 交换后顺序：对 $B[j][i]$ 的访问步长为1。对 $A[i][j]$ 的访问步长为 $k'=M$。\n- **缓存和成本模型**:\n  - 缓存行大小：$L$ 个元素，$L \\geq 1$ 是一个整数。\n  - 时间局部性复用：假设在外层循环迭代之间被逐出的缓存行没有时间局部性复用。\n  - 读取成本：一次缓存命中成本为 $h_r$ 个周期；一次缓存未命中成本为 $c_r$ 个周期，其中 $c_r \\geq h_r \\geq 0$。\n  - 写入策略：写时分配、写回。\n  - 写入成本：一次未命中（分配并写回）成本为 $c_{wa}$ 个周期；一次命中成本为 $h_w$ 个周期，其中 $c_{wa} \\geq h_w \\geq 0$。\n- **流访问成本假设**:\n  - 步长为1的流：每 $L$ 个元素有一次未命中，随后是 $L-1$ 次命中。\n  - 步长为 $s$ 且 $s \\geq L$ 的流：每次访问都是一次未命中。\n- **推导的特定假设**:\n  - $k = N \\geq L$。\n  - $k' = M \\geq L$。\n- **目标**:\n  - 推导出一个关于 $N, M, L, c_r, h_r, c_{wa}, h_w$ 的、单一的、完全简化的、闭式解析表达式，用于表示 $\\Delta C \\triangleq C_{\\text{int}} - C_{\\text{orig}}$。\n\n### 步骤2：使用提取的给定条件进行验证\n问题定义明确且科学合理。\n- **科学依据**：该问题基于计算机体系结构（缓存、内存布局）和编译器优化（循环交换）的基本概念。成本模型是用于性能分析的标准简化抽象。行主序的地址计算是正确的。\n- **适定性**：提供了构建确定性成本模型所需的所有必要常量、变量和函数关系。目标陈述清晰，可以从给定的前提推导出唯一解。\n- **客观性**：问题以精确的技术语言陈述，没有主观性或歧义。\n- **完整性和一致性**：问题是自洽的。约束条件 $N \\geq L$ 和 $M \\geq L$ 已针对模型的相应部分（高步长访问）进行了规定。所提供的信息中没有矛盾之处。\n\n### 步骤3：结论与行动\n问题是**有效的**。将按要求推导解决方案。\n\n### 解决方案推导\n计算的总成本是所有内存访问成本的总和。共有 $N \\cdot M$ 次迭代，每次迭代涉及一次从数组 $A$ 的读取和一次向数组 $B$ 的写入。内存访问总次数为 $2 \\cdot N \\cdot M$。\n\n首先，我们如前所述确定每种循环顺序的访问模式。\n- **原始循环顺序**：`for i from 0 to N-1 { for j from 0 to M-1 { B[j][i] = A[i][j]; } }`。关于 $j$ 的内层循环访问 $A[i][0], A[i][1], \\dots, A[i][M-1]$ 和 $B[0][i], B[1][i], \\dots, B[M-1][i]$。如给定条件所述，对 $A$ 的访问是步长为1，对 $B$ 的访问是步长为 $N$。\n- **交换后循环顺序**：`for j from 0 to M-1 { for i from 0 to N-1 { B[j][i] = A[i][j]; } }`。关于 $i$ 的内层循环访问 $A[0][j], A[1][j], \\dots, A[N-1][j]$ 和 $B[j][0], B[j][1], \\dots, B[j][N-1]$。如给定条件所述，对 $A$ 的访问是步长为 $M$，对 $B$ 的访问是步长为1。\n\n我们现在为 $C_{\\text{orig}}$ 和 $C_{\\text{int}}$ 构建成本模型。\n\n**原始循环顺序的成本 ($C_{\\text{orig}}$)**\n\n1.  **从A读取的成本 ($C_{A, \\text{orig}}^{\\text{read}}$)**：对 $A$ 的访问模式是步长为1。根据模型，每访问 $L$ 个元素，会发生1次未命中和 $L-1$ 次命中。读取的元素总数为 $N \\cdot M$。\n    - 未命中次数 = $\\frac{N \\cdot M}{L}$。\n    - 命中次数 = $N \\cdot M \\cdot (1 - \\frac{1}{L}) = N \\cdot M \\cdot \\frac{L-1}{L}$。\n    - 总读取成本：$C_{A, \\text{orig}}^{\\text{read}} = \\left(\\frac{N \\cdot M}{L}\\right) c_r + \\left(N \\cdot M \\cdot \\frac{L-1}{L}\\right) h_r$。\n    - 化简得：$C_{A, \\text{orig}}^{\\text{read}} = \\frac{N \\cdot M}{L} (c_r + (L-1)h_r) = N \\cdot M \\left( h_r + \\frac{c_r - h_r}{L} \\right)$。\n\n2.  **向B写入的成本 ($C_{B, \\text{orig}}^{\\text{write}}$)**：对 $B$ 的访问模式是步长为 $N$。给定假设 $N \\geq L$。因此，每次对 $B$ 的访问都是一次缓存未命中。在写时分配策略下，每次未命中产生的成本为 $c_{wa}$。\n    - 总写入成本：$C_{B, \\text{orig}}^{\\text{write}} = (N \\cdot M) \\cdot c_{wa}$。\n\n3.  **总原始成本 ($C_{\\text{orig}}$)**:\n    $$C_{\\text{orig}} = C_{A, \\text{orig}}^{\\text{read}} + C_{B, \\text{orig}}^{\\text{write}} = N \\cdot M \\left( h_r + \\frac{c_r - h_r}{L} \\right) + N \\cdot M \\cdot c_{wa}$$\n    $$C_{\\text{orig}} = N \\cdot M \\left( h_r + c_{wa} + \\frac{c_r - h_r}{L} \\right)$$\n\n**交换后循环顺序的成本 ($C_{\\text{int}}$)**\n\n1.  **从A读取的成本 ($C_{A, \\text{int}}^{\\text{read}}$)**：对 $A$ 的访问模式是步长为 $M$。给定假设 $M \\geq L$。因此，每次对 $A$ 的访问都是一次缓存未命中。\n    - 总读取成本：$C_{A, \\text{int}}^{\\text{read}} = (N \\cdot M) \\cdot c_r$。\n\n2.  **向B写入的成本 ($C_{B, \\text{int}}^{\\text{write}}$)**：对 $B$ 的访问模式是步长为1。这与原始循环顺序下的读取情况类似，但使用的是写入成本。每写入 $L$ 个元素，会发生1次写入未命中（成本为 $c_{wa}$）和 $L-1$ 次写入命中（成本为 $h_w$）。\n    - 未命中次数 = $\\frac{N \\cdot M}{L}$。\n    - 命中次数 = $N \\cdot M \\cdot \\frac{L-1}{L}$。\n    - 总写入成本：$C_{B, \\text{int}}^{\\text{write}} = \\left(\\frac{N \\cdot M}{L}\\right) c_{wa} + \\left(N \\cdot M \\cdot \\frac{L-1}{L}\\right) h_w$。\n    - 化简得：$C_{B, \\text{int}}^{\\text{write}} = \\frac{N \\cdot M}{L} (c_{wa} + (L-1)h_w) = N \\cdot M \\left( h_w + \\frac{c_{wa} - h_w}{L} \\right)$。\n\n3.  **总交换后成本 ($C_{\\text{int}}$)**:\n    $$C_{\\text{int}} = C_{A, \\text{int}}^{\\text{read}} + C_{B, \\text{int}}^{\\text{write}} = N \\cdot M \\cdot c_r + N \\cdot M \\left( h_w + \\frac{c_{wa} - h_w}{L} \\right)$$\n    $$C_{\\text{int}} = N \\cdot M \\left( c_r + h_w + \\frac{c_{wa} - h_w}{L} \\right)$$\n\n**成本差异的推导 ($\\Delta C$)**\n\n现在，我们计算差值 $\\Delta C = C_{\\text{int}} - C_{\\text{orig}}$。\n$$\\Delta C = N \\cdot M \\left( c_r + h_w + \\frac{c_{wa} - h_w}{L} \\right) - N \\cdot M \\left( h_r + c_{wa} + \\frac{c_r - h_r}{L} \\right)$$\n提取公因式 $N \\cdot M$:\n$$\\frac{\\Delta C}{N \\cdot M} = \\left( c_r + h_w + \\frac{c_{wa}}{L} - \\frac{h_w}{L} \\right) - \\left( h_r + c_{wa} + \\frac{c_r}{L} - \\frac{h_r}{L} \\right)$$\n按成本参数对各项进行分组：\n$$\\frac{\\Delta C}{N \\cdot M} = (c_r - \\frac{c_r}{L}) - (h_r - \\frac{h_r}{L}) - (c_{wa} - \\frac{c_{wa}}{L}) + (h_w - \\frac{h_w}{L})$$\n$$\\frac{\\Delta C}{N \\cdot M} = c_r\\left(1 - \\frac{1}{L}\\right) - h_r\\left(1 - \\frac{1}{L}\\right) - c_{wa}\\left(1 - \\frac{1}{L}\\right) + h_w\\left(1 - \\frac{1}{L}\\right)$$\n提取公因式 $\\left(1 - \\frac{1}{L}\\right)$:\n$$\\frac{\\Delta C}{N \\cdot M} = \\left(1 - \\frac{1}{L}\\right) (c_r - h_r - c_{wa} + h_w)$$\n$$\\frac{\\Delta C}{N \\cdot M} = \\frac{L-1}{L} (c_r - h_r + h_w - c_{wa})$$\n最后，乘以 $N \\cdot M$ 得到 $\\Delta C$ 的完全简化表达式：\n$$\\Delta C = N \\cdot M \\cdot \\frac{L-1}{L} (c_r - h_r + h_w - c_{wa})$$\n该表达式仅是指定变量 $N, M, L, c_r, h_r, c_{wa}$ 和 $h_w$ 的函数，符合要求。", "answer": "$$\\boxed{N \\cdot M \\cdot \\frac{L-1}{L} (c_r - h_r + h_w - c_{wa})}$$", "id": "3652895"}, {"introduction": "真实世界的算法常常涉及比简单矩形更复杂的循环结构。此练习 [@problem_id:3652944] 将我们对合法性和性能的理解扩展到常见的三角形迭代空间。成功解决这个问题不仅需要进行标准的依赖性分析，还需要掌握变换循环边界的关键实践技能，这对于处理非完美嵌套或非矩形循环至关重要。", "problem": "考虑一个定义了三角形迭代空间 $\\mathcal{D} = \\{(i,j) \\mid 0 \\le j \\le i  n\\}$ 的两层循环嵌套，其中 $n$ 是一个正整数。循环体由单个语句 $S(i,j)$ 组成，该语句向由 $(i,j)$ 索引的内存位置写入数据，并且当 $j \\ge 1$ 时，读取由 $(i,j-1)$ 索引的内存位置：\n$$\nS(i,j):\\quad X[i,j] \\leftarrow F\\big(X[i,j],\\,X[i,j-1]\\big) \\quad \\text{for } j \\ge 1,\n$$\n而对于边界情况 $j=0$，\n$$\nS(i,0):\\quad X[i,0] \\leftarrow F_0\\big(X[i,0]\\big),\n$$\n其中 $F(\\cdot,\\cdot)$ 和 $F_0(\\cdot)$ 是无副作用的纯函数。原始执行顺序是按 $(i,j)$ 的字典序：迭代 $(i_s,j_s)$ 先于 $(i_t,j_t)$ 当且仅当 $i_s  i_t$ 或者 $i_s = i_t$ 且 $j_s  j_t$。\n\n你需要基于以下基本原则进行推理：\n- 如果 $S(i_t,j_t)$ 读取了 $S(i_s,j_s)$ 写入的内存位置，那么就存在从 $S(i_s,j_s)$ 到 $S(i_t,j_t)$ 的数据依赖。执行过程必须保证源迭代在所选的字典序中先于汇迭代，以保持程序语义。\n- 依赖方向向量 $(d_i,d_j)$ 由依赖向量（汇迭代索引 - 源迭代索引）的每个分量的符号（+、0 或 -）组成。\n- 将调度从 $(i,j)$ 置换为 $(j,i)$ 的循环交换是合法的，前提是对于每个依赖关系，其方向向量在交换后不能是字典序负的（即，交换后向量的第一个非零分量不能是‘-’）。\n\n任务：\n1. 使用上述定义，确定在原始顺序 $(i,j)$ 下，由 $S(i,j)$ 在 $\\mathcal{D}$ 内引起的依赖方向向量。\n2. 阐明为确保从 $(i,j)$ 到 $(j,i)$ 的循环交换是合法的，这些依赖方向向量需要满足的条件，并用置换后的方向向量进行说明。\n3. 推导交换后保持三角形迭代空间的变换后边界，使得交换后的迭代空间 $\\mathcal{D}'$ 作为索引对集合满足 $\\mathcal{D}' = \\mathcal{D}$，但按 $(j,i)$ 的字典序排序。\n4. 在保持三角形迭代空间的交换后边界下，计算 $S$ 的动态执行总次数，表示为 $n$ 的函数。请以单一闭式表达式给出最终答案。无需四舍五入。", "solution": "在进行求解之前，首先分析问题的有效性。\n\n**问题验证**\n\n*   **步骤 1：提取已知条件**\n    *   迭代空间：$\\mathcal{D} = \\{(i,j) \\mid 0 \\le j \\le i  n\\}$，其中 $n$ 是一个正整数。\n    *   对于 $j \\ge 1$ 的语句：$S(i,j): X[i,j] \\leftarrow F\\big(X[i,j],\\,X[i,j-1]\\big)$。\n    *   对于 $j=0$ 的语句：$S(i,0): X[i,0] \\leftarrow F_0\\big(X[i,0]\\big)$。\n    *   执行顺序：按 $(i,j)$ 的字典序。\n    *   数据依赖定义：如果汇语句 $S(i_t,j_t)$ 读取了源语句 $S(i_s,j_s)$ 写入的内存位置，则存在从源到汇的数据依赖。\n    *   依赖方向向量定义：由依赖向量（汇索引 - 源索引）的分量符号（+、0、-）组成。\n    *   交换为 $(j,i)$ 的合法性条件：置换后的依赖方向向量必须是字典序正的。\n\n*   **步骤 2：使用提取的已知条件进行验证**\n    该问题是编译原理和高性能计算领域中一个定义明确的练习。所有术语，如迭代空间、数据依赖、方向向量和循环交换，都是标准的且使用正确。该问题是自洽的、客观的，并且在其领域内有科学依据。它不违反任何数学或逻辑原理，并且是适定的，可以导出一个唯一且有意义的解。\n\n*   **步骤 3：结论与行动**\n    问题有效。下面将制定完整的解决方案。\n\n**解**\n\n本解答按指定顺序处理四个任务。\n\n**1. 依赖方向向量**\n当一个语句实例（汇）读取由另一个语句实例（源）先前写入的内存位置时，就会产生数据依赖。我们分析当 $j \\ge 1$ 时的语句 $S(i,j)$，即 $X[i,j] \\leftarrow F\\big(X[i,j],\\,X[i,j-1]\\big)$。\n\n如果汇迭代 $S(i_t, j_t)$ 读取了由源迭代 $S(i_s, j_s)$ 写入的位置，则存在依赖。\n*   源 $S(i_s, j_s)$ 写入的内存位置是 $X[i_s, j_s]$。\n*   汇 $S(i_t, j_t)$ 读取的内存位置是 $X[i_t, j_t-1]$。此读取操作的条件是 $j_t \\ge 1$。\n\n为了存在流依赖（flow dependence），源写入的位置必须与汇读取的位置相同。因此，它们的索引必须相等：\n$$i_s = i_t$$\n$$j_s = j_t - 1$$\n这建立了源-汇对之间的关系。源迭代是 $(i_s, j_s) = (i_t, j_t-1)$，汇迭代是 $(i_t, j_t)$。\n\n为了使这种依赖在程序中存在，源迭代和汇迭代都必须位于迭代空间 $\\mathcal{D}$ 内：\n*   汇：$(i_t, j_t) \\in \\mathcal{D} \\implies 0 \\le j_t \\le i_t  n$。\n*   源：$(i_t, j_t-1) \\in \\mathcal{D} \\implies 0 \\le j_t-1 \\le i_t  n$。\n\n条件 $j_t-1 \\ge 0$ 意味着 $j_t \\ge 1$，这与发生读取访问的条件一致。因此，对于所有满足 $1 \\le j_t \\le i_t  n$ 的迭代 $(i_t, j_t)$，都存在这样的依赖。\n\n从源到汇的依赖向量是 $(\\Delta i, \\Delta j) = (i_t - i_s, j_t - j_s) = (i_t - i_t, j_t - (j_t-1)) = (0, 1)$。\n依赖方向向量 $(d_i, d_j)$ 是从依赖向量各分量的符号推导出来的：\n*   $d_i$: 由于 $i_t - i_s = 0$，方向是 $0$。\n*   $d_j$: 由于 $j_t - j_s = 1 > 0$，方向是 $+$。\n\n此循环嵌套中唯一的循环携带依赖由方向向量 $(0, +)$ 表征。该向量在原始 $(i,j)$ 顺序下是字典序正的，这证实了原始循环执行的有效性。\n\n**2. 循环交换的合法性**\n将执行顺序从 $(i,j)$ 变换为 $(j,i)$ 的循环交换是合法的，当且仅当所有依赖向量在以与循环相同的方式置换其分量后，仍然保持字典序为正。\n原始的依赖方向向量是 $(0, +)$。\n将循环顺序置换为 $(j,i)$ 后，依赖方向向量的分量也相应置换，得到新的向量 $(+, 0)$。\n为检验合法性，我们检查这个置换后的向量是否是字典序正的。一个向量是字典序正的，如果其第一个非零分量是‘+’。在向量 $(+, 0)$ 中，第一个分量是 $+$。因此，该向量是字典序正的，条件得到满足。循环交换是合法的。\n\n**3. 变换后的循环边界**\n原始迭代空间 $\\mathcal{D}$ 由以下不等式集合定义：\n$$0 \\le j \\le i  n$$\n这可以表示为对 $\\mathcal{D}$ 中任意点 $(i,j)$ 的三个约束条件：\n1. $j \\ge 0$\n2. $i \\ge j$\n3. $i \\le n-1$\n\n为了找到交换后循环（其中 $j$ 是外层循环，$i$ 是内层循环）的边界，我们首先确定 $j$ 的总体范围。根据约束 (1)，$j$ 的下界是 $0$。根据约束 (2) 和 (3)，我们有 $j \\le i$ 和 $i \\le n-1$，这意味着 $j \\le n-1$。综合这些，外层 $j$ 循环的运行范围是：\n$$0 \\le j \\le n-1$$\n对于此范围内的任意固定值 $j$，我们找到内层 $i$ 循环的边界。约束 (2) 和 (3) 直接提供了这些边界：\n$$j \\le i \\le n-1$$\n因此，保持迭代空间的变换后循环嵌套是：\n`for j from` $0$ `to` $n-1$:\n`  for i from` $j$ `to` $n-1$:\n`    S(i,j)`\n变换后的边界是 $j \\in [0, n-1]$ 和 $i \\in [j, n-1]$。\n\n**4. 动态执行总次数**\n语句 $S$ 的动态执行总次数是迭代空间 $\\mathcal{D}$ 的基数 $|\\mathcal{D}|$，该基数在循环交换变换中保持不变。我们可以使用新的、交换后的循环边界来计算这个次数。执行总次数 $N$ 是对变换后迭代空间的求和：\n$$N = \\sum_{j=0}^{n-1} \\sum_{i=j}^{n-1} 1$$\n我们首先计算内层和，它计算了对于一个固定的 $j$，$i$ 循环的迭代次数：\n$$\\sum_{i=j}^{n-1} 1 = (n-1) - j + 1 = n - j$$\n将此结果代回外层求和得到：\n$$N = \\sum_{j=0}^{n-1} (n - j)$$\n这是一个等差级数。我们可以通过令 $k = n-j$ 来重新索引。当 $j$ 的范围从 $0$ 到 $n-1$ 时，$k$ 的范围从 $n$ 递减到 $1$。该和等价于：\n$$N = \\sum_{k=1}^{n} k$$\n这是前 $n$ 个正整数的和，其著名的闭式解为：\n$$N = \\frac{n(n+1)}{2}$$\n这个表达式表示了 $S$ 的动态执行总次数，是 $n$ 的一个函数。", "answer": "$$\\boxed{\\frac{n(n+1)}{2}}$$", "id": "3652944"}]}