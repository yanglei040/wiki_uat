{"hands_on_practices": [{"introduction": "在深入探讨性能优化之前，首要任务是确保代码转换的正确性。循环不变代码外提（Loop unswitching）必须精确地保留原始程序的语义，即使在存在复杂的控制流（如 `continue` 语句）时也是如此。本练习旨在通过一个包含 `continue` 语句的示例，检验您对循环不变代码外提如何重构循环并保持其原有行为的理解。[@problem_id:3654403]", "problem": "考虑一个具有类C控制流语义的命令式语言中的以下循环。分支上的条件是循环不变的，意味着它在循环的迭代中不会改变，并且没有异常退出（没有异常或非局部 goto）。continue 语句的语义如下：在循环内部遇到时，执行会立即跳转到循环的更新表达式，然后进行下一次迭代的循环头部测试。\n\n原始循环：\nfor (int $i$ = $0$; $i  N$; ++$i$) {\n  if ($flag$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  } else {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n  }\n  $S_3(i)$;\n  $T(i)$;\n}\n\n假设如下：\n- 布尔值 $flag$ 是循环不变的：它在循环内部不会被修改，因此对于每次迭代 $i$ 其值都是相同的。\n- 函数和语句 $A(i)$、$B(i)$、$logA(i)$、$logB(i)$、$S_1(i)$、$S_2(i)$、$S_3(i)$ 和 $T(i)$ 可能有副作用，但不会改变 $i$、$N$ 或 $flag$，也不会导致异常控制流。\n- 循环体唯一的提前退出是通过所示的 continue 语句。\n- 不存在会因复制循环体而被违反的数据依赖（例如，没有对共享的循环不变状态的写操作，这种写操作会因判断外提而被错误地复制）。\n\n循环判断外提（Loop unswitching）是一种转换，它通过复制循环并将特化版本置于不变条件的每个分支下，从而将循环不变条件从循环中提升出来。该转换必须保留由 continue 语句所隐含的每次迭代的控制流和副作用顺序。对于所有的 $N$ 和 $flag$ 的两种取值，以下哪个转换后的程序正确地应用了循环判断外提以保留原始语义？\n\nA)\nif ($flag$) {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n}\n\nB)\nif ($flag$) {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    $S_3(i)$;\n    $T(i)$;\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    $S_3(i)$;\n    $T(i)$;\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n  }\n}\n\nC)\nfor (int $i$ = $0$; $i  N$; ++$i$) {\n  if ($flag$) {\n    if ($A(i)$) { $logA(i)$; }  // continue removed\n    $S_1(i)$;\n  } else {\n    if ($B(i)$) { $logB(i)$; }  // continue removed\n    $S_2(i)$;\n  }\n  $S_3(i)$;\n  $T(i)$;\n}\n\nD)\nif ($flag$) {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n  }\n}\n// $S_3(i)$ and $T(i)$ executed outside the unswitched loops (missing per-iteration placement)\n\n选择在循环判断外提下保留了原始的每次迭代语义的选项，包括正确处理由 continue 引起的提前退出和副作用顺序。", "solution": "用户提供了一个关于编译器优化技术“循环判断外提”的问题。任务是验证问题陈述的有效性，如果有效，则确定所提议的代码转换中哪一个正确地保留了原始循环的语义。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n问题提供了以下内容：\n- **原始循环代码：**\n  ```c\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($flag$) {\n      if ($A(i)$) { $logA(i)$; continue; }\n      $S_1(i)$;\n    } else {\n      if ($B(i)$) { $logB(i)$; continue; }\n      $S_2(i)$;\n    }\n    $S_3(i)$;\n    $T(i)$;\n  }\n  ```\n- **控制流语义：**\n    - 该语言是类C的。\n    - `continue` 使执行跳转到循环更新（`++$i$`），然后是循环测试（`$i  N$`），从而跳过当前迭代中循环体的剩余部分。\n- **假设：**\n    - 布尔变量 `$flag$` 是循环不变的（其值在整个循环执行期间是恒定的）。\n    - 函数和语句 `$A(i)$, $B(i)$, $logA(i)$, $logB(i)$, $S_1(i)$, $S_2(i)$, $S_3(i), T(i)$` 可能有副作用，但不会修改 `$i$`、`$N$` 或 `$flag$`。\n    - 除了指定的 `continue` 语句外，没有异常控制流（例如异常、`goto`）。\n    - 不存在会因循环复制而被违反的数据依赖。\n- **核心任务：**\n    - 循环判断外提被定义为通过复制循环将循环不变条件从循环中提升出来。\n    - 正确的转换必须保留每次迭代的控制流和副作用顺序。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题陈述进行评估。\n- **科学性：** 该问题设置在编译器优化的背景下，这是计算机科学的一个标准主题。循环判断外提是一种成熟的技术。类C语义被精确定义。该问题在科学上和事实上都是合理的。\n- **适定性：** 该问题要求在一组选项中确定哪一个转换与原始代码在语义上等价。这是一个定义明确的问题，基于程序控制流的逻辑分析，有唯一的正确答案。\n- **客观性：** 该问题是根据代码和明确的语义规则陈述的。其正确性标准——保留语义——是客观且可验证的。\n- **完整性与一致性：** 该问题提供了所有必要的信息：原始代码、执行规则（`continue` 语义）以及关键假设（`$flag$` 的循环不变性、不存在某些副作用）。整个设定是自洽且无矛盾的。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。它是编译器原理领域中一个形式良好的问题。可以继续进行求解过程。\n\n### 推导与选项分析\n\n基本任务是追踪原始循环单次迭代的执行路径，并确保转换后的代码能精确地复制该路径。\n\n**原始循环分析**\n\n我们来分析任意一次迭代 `$i$` 的操作序列。\n1.  对循环不变条件 `if ($flag$)` 进行求值。\n2.  **情况 `$flag$` 为真：**\n   - 对条件 `$A(i)$` 进行求值。\n   - 如果 `$A(i)$` 为真，则执行 `$logA(i)$`，并触发 `continue` 语句。这会立即跳过 `$S_1(i)$、`$S_3(i)` 和 `$T(i)$` 的执行。循环进入下一次迭代（`++$i$`）。\n   - 如果 `$A(i)$` 为假，则执行 `$S_1(i)$`，然后是 `$S_3(i)` 和 `$T(i)$`。循环随后进入下一次迭代。\n    *`$flag$` 为真时的总结：\n      - 路径1：`$A(i)$` 为真 $\\implies$ 执行 `$logA(i)$`。\n      - 路径2：`$A(i)$` 为假 $\\implies$ 执行 `$S_1(i), S_3(i), T(i)$`。\n3.  **情况 `$flag$` 为假：**\n   - 对条件 `$B(i)$` 进行求值。\n   - 如果 `$B(i)$` 为真，则执行 `$logB(i)$`，并触发 `continue` 语句。这会立即跳过 `$S_2(i)$、`$S_3(i)` 和 `$T(i)$` 的执行。循环进入下一次迭代。\n   - 如果 `$B(i)$` 为假，则执行 `$S_2(i)$`，然后是 `$S_3(i)` 和 `$T(i)$`。循环随后进入下一次迭代。\n    *`$flag$` 为假时的总结：\n      - 路径1：`$B(i)$` 为真 $\\implies$ 执行 `$logB(i)$`。\n      - 路径2：`$B(i)$` 为假 $\\implies$ 执行 `$S_2(i), S_3(i), T(i)$`。\n\n**循环判断外提转换**\n\n该转换将 `if ($flag$)` 移到循环外部，创建了两个特化的循环。\n\n- **`if` 分支（当 `$flag$` 为真时）：** 循环体应该只包含当 `$flag$` 为真时执行的代码。根据我们的分析，这部分代码是：\n  ```c\n  if ($A(i)$) { $logA(i)$; continue; }\n  $S_1(i)$;\n  $S_3(i)$;\n  $T(i)$;\n  ```\n  这是因为 `$S_3(i)$` 和 `$T(i)$` 是所有不执行 `continue` 的路径所共有的。\n\n- **`else` 分支（当 `$flag$` 为假时）：** 循环体应该只包含当 `$flag$` 为假时执行的代码。根据我们的分析，这部分代码是：\n  ```c\n  if ($B(i)$) { $logB(i)$; continue; }\n  $S_2(i)$;\n  $S_3(i)$;\n  $T(i)$;\n  ```\n\n将这些组合到判断外提的结构中，得到以下正确的转换：\n```c\nif ($flag$) {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n}\n```\n\n现在，我们根据这个推导出的正确转换来评估每个提供的选项。\n\n**逐项分析**\n\n**A)**\n```c\nif ($flag$) {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n    $S_3(i)$;\n    $T(i)$;\n  }\n}\n```\n此代码与从基本原理推导出的转换完全匹配。对于 `$flag$` 为真的情况，如果 `$A(i)$` 为真，它正确地执行 `$logA(i)$` 并跳过其余部分；否则执行 `$S_1(i), S_3(i), T(i)$`。对于 `$flag$` 为假的情况，它对 `$B(i)` 和 `$S_2(i)` 也做了同样的处理。对于所有情况，控制流和副作用顺序都得到了保留。\n**结论：正确。**\n\n**B)**\n```c\nif ($flag$) {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    $S_3(i)$;\n    $T(i)$;\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  }\n} // ... else 分支也类似\n```\n这个转换错误地重排了语句的顺序。在原始循环中，如果 `$flag$` 为真且 `$A(i)$` 为真，则 `$S_3(i)` 和 `$T(i)` *不会*被执行。在这个转换后的代码中，`$S_3(i)` 和 `$T(i)` 在每次迭代开始时都无条件执行。这违反了原始程序的语义。\n**结论：不正确。**\n\n**C)**\n```c\nfor (int $i$ = $0$; $i  N$; ++$i$) {\n  if ($flag$) {\n    if ($A(i)$) { $logA(i)$; }  // continue removed\n    $S_1(i)$;\n  } // ... else 分支也类似\n  $S_3(i)$;\n  $T(i)$;\n}\n```\n这不是循环判断外提；这是对原始循环的修改，其中 `continue` 语句被移除了。在原始循环中，如果 `$flag$` 为真且 `$A(i)$` 为真，`continue` 会阻止 `$S_1(i)`、`$S_3(i)` 和 `$T(i)` 的执行。在这个修改后的代码中，无论 `$A(i)$` 的值如何，所有这些语句都会被执行。这显著地改变了控制流。\n**结论：不正确。**\n\n**D)**\n```c\nif ($flag$) {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($A(i)$) { $logA(i)$; continue; }\n    $S_1(i)$;\n  }\n} else {\n  for (int $i$ = $0$; $i  N$; ++$i$) {\n    if ($B(i)$) { $logB(i)$; continue; }\n    $S_2(i)$;\n  }\n}\n// S_3(i) and T(i) executed outside the unswitched loops...\n```\n这个转换从复制的循环内部省略了语句 `$S_3(i)` 和 `$T(i)`。在原始代码中，`$S_3(i)` 和 `$T(i)` 在每次没有遇到 `continue` 的迭代中都会执行。通过将它们从循环体中移除，此转换未能保留原始程序的行为和副作用。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3654403"}, {"introduction": "从正确性转向性能，代码转换的一个主要动机是改善内存访问模式。本练习将探讨循环不变代码外提如何通过创建针对不同数据布局的特化循环，显著影响缓存效率。我们将通过一个矩阵乘法的假设场景，使用一个简化的缓存模型来量化分析不同内存访问模式导致的缓存行填充差异，从而揭示空间局部性的重要性。[@problem_id:3654402]", "problem": "考虑维度为 $n \\times n$ 的方阵 $A$、$B$ 和 $C$，它们在主内存中以连续的行主序布局存储，每个元素占用 $w$ 字节。要执行的计算是由三重嵌套循环顺序 $(i,k,j)$ 定义的矩阵乘积累加：对于每个固定的 $i$，对于每个 $k$，根据一个指示 $A$ 是否已预转置的循环不变量标志 $t$ 从 $A$ 中读取一个标量，然后使用 $B$ 的整个第 $k$ 行来更新 $C$ 的第 $i$ 行中的所有元素。具体来说，对于每对 $(i,k)$，当 $t$ 为假（未转置）时，代码读取 $A[i][k]$；当 $t$ 为真（已转置）时，读取 $A[k][i]$。该值被绑定到一个标量，然后在对 $j$ 的内层循环中重复使用，并对所有 $j \\in \\{0,1,\\dots,n-1\\}$ 进行累加 $C[i][j] \\leftarrow C[i][j] + a \\cdot B[k][j]$。\n\n关于 $t$ 的分支相对于 $i$、$k$ 和 $j$ 循环是循环不变量。应用称为循环判断外提（loop unswitching）的变换，为该计算生成两个特化版本：一个用于 $t=\\text{false}$ 的情况，另一个用于 $t=\\text{true}$ 的情况。使用以下缓存模型和假设来估算仅由读取 $A$ 引起的缓存行为：\n\n- 处理器有一个一级（L1）缓存，该缓存是全相联的，采用最近最少使用（LRU）替换策略，缓存行大小为 $L$ 字节。\n- 令 $p = \\frac{L}{w}$ 表示一个缓存行能容纳的矩阵元素数量；假设 $p$ 是一个正整数，并且 $n$ 是 $p$ 的整数倍。\n- 对于给定的 $(i,k)$ 读取的每个 $A$ 元素，在整个对 $j$ 的内层循环中都会被重用，而无需额外的 $A$ 加载。但由于对 $B$ 的流式访问和对 $C$ 的更新，不同 $(i,k)$ 对之间 $A$ 的缓存行的重用可以忽略不计。因此，在给定的外层循环迭代 $i$ 中，当首次访问 $A$ 某个缓存行中的任何元素时，记为一次缓存行填充，并且不计算后续的跨迭代重用。\n- 不包括任何来自 $B$ 或 $C$ 的缓存行为；只计算由访问 $A$ 引起的缓存行填充。\n\n从行主序寻址的定义和循环判断外提的基本属性出发，推导出在每个特化版本（$t=\\text{false}$ 和 $t=\\text{true}$）中，整个计算过程中由读取 $A$ 引起的 L1 缓存行填充总数，然后为这两个总数之间的差值提供一个单一的闭式解析表达式，定义为\n$$\\Delta = \\text{fills}_{t=\\text{true}} - \\text{fills}_{t=\\text{false}}。$$\n\n请用 $n$ 和 $p$ 表示您的最终答案。无需进行数值计算；请提供精确的解析表达式。", "solution": "所述问题是有效的。它在科学上基于计算机体系结构和编译器优化的原理，特别是缓存行为分析和循环变换。该问题定义明确，具有所有必要的参数（$n$，$p$）、清晰的计算模型和明确的目标。语言是客观的，其假设虽然简化，但是明确且一致的。\n\n核心任务是分析由于循环判断外提产生的两种不同情况下访问矩阵 $A$ 的缓存行填充次数。循环判断外提是一种编译器优化，它将循环不变量的条件分支移到循环外部，并在分支的每个路径内复制循环体。\n\n原始的循环结构是：\n`for i = 0 to n-1:`\n  `for k = 0 to n-1:`\n    `if t:`\n      `a = A[k][i]`\n    `else:`\n      `a = A[i][k]`\n    `for j = 0 to n-1:`\n      `C[i][j] += a * B[k][j]`\n\n对循环不变量标志 $t$ 应用循环判断外提，会产生两个独立的代码块：\n\n情况 1：$t=\\text{false}$\n`for i = 0 to n-1:`\n  `for k = 0 to n-1:`\n    `a = A[i][k]`\n    `for j = 0 to n-1:`\n      `C[i][j] += a * B[k][j]`\n\n情况 2：$t=\\text{true}$\n`for i = 0 to n-1:`\n  `for k = 0 to n-1:`\n    `a = A[k][i]`\n    `for j = 0 to n-1:`\n      `C[i][j] += a * B[k][j]`\n\n我们现在将根据所提供的缓存模型，分析每种情况下读取矩阵 $A$ 时的缓存行填充次数。矩阵以连续的行主序布局存储。元素 $A[r][c]$ 的内存地址可以表示为 $\\text{Addr}(A[r][c]) = \\text{Addr}(A[0][0]) + (r \\cdot n + c) \\cdot w$，其中 $w$ 是每个元素的字节大小。\n\n一个缓存行的大小为 $L$ 字节，包含 $p = \\frac{L}{w}$ 个元素。问题规定我们必须根据以下规则计算缓存填充：“在给定的外层循环迭代 $i$ 中，当首次访问 $A$ 某个缓存行中的任何元素时，记为一次缓存行填充，并且不计算后续的跨迭代重用。” 这意味着我们对外部 $i$ 循环的每次迭代的分析是独立的，我们将每次迭代的填充次数相加。\n\n**对 $t=\\text{false}$（非转置访问）的分析**\n\n在这种情况下，对矩阵 $A$ 的访问模式是 $A[i][k]$。对于访问 $A$ 来说，循环的顺序是 $i$ 作为外层循环，$k$ 作为内层循环。\n对于一个固定的外层循环索引 $i$，内层循环 `for k = 0 to n-1` 访问元素 $A[i][0], A[i][1], \\dots, A[i][n-1]$。\n这一访问序列对应于对矩阵 $A$ 的第 $i$ 行的顺序扫描。由于矩阵是行主序布局，这些元素在内存中是连续的。\n当访问 $A[i][0]$ 时，发生一次缓存未命中，包含该行前 $p$ 个元素（从 $A[i][0]$ 到 $A[i][p-1]$）的缓存行被加载。这算作 1 次缓存行填充。\n随后的 $p-1$ 次访问，即对 $A[i][1], \\dots, A[i][p-1]$ 的访问，将是缓存命中。\n下一次访问，即对 $A[i][p]$ 的访问，将导致另一次缓存未命中，加载该行的第二个缓存行。这个过程会持续遍及整行。\n由于一行包含 $n$ 个元素，每个缓存行容纳 $p$ 个元素，并且 $n$ 是 $p$ 的整数倍，所以构成单行的缓存行数恰好是 $\\frac{n}{p}$。\n因此，对于外层循环的每次迭代（对于每个固定的 $i$），访问 $A$ 的一整行会导致 $\\frac{n}{p}$ 次缓存行填充。\n\n根据指定的计数规则，我们将外层循环所有迭代（从 $i=0$ 到 $i=n-1$）的这些填充次数相加。\n总填充次数为：\n$$ \\text{fills}_{t=\\text{false}} = \\sum_{i=0}^{n-1} \\frac{n}{p} = n \\cdot \\frac{n}{p} = \\frac{n^2}{p} $$\n\n**对 $t=\\text{true}$（转置访问）的分析**\n\n在这种情况下，对矩阵 $A$ 的访问模式是 $A[k][i]$。\n对于一个固定的外层循环索引 $i$，内层循环 `for k = 0 to n-1` 访问元素 $A[0][i], A[1][i], \\dots, A[n-1][i]$。\n这一访问序列对应于对矩阵 $A$ 的第 $i$ 列的扫描。\n我们来检查这个序列中两个连续访问的内存位置：$A[k][i]$ 和 $A[k+1][i]$。\n$\\text{Addr}(A[k][i]) = \\text{Addr}(A[0][0]) + (k \\cdot n + i) \\cdot w$\n$\\text{Addr}(A[k+1][i]) = \\text{Addr}(A[0][0]) + ((k+1) \\cdot n + i) \\cdot w$\n它们的地址差为：\n$$ \\Delta \\text{Addr} = ((k+1)n + i)w - (kn + i)w = nw $$\n连续内存访问之间的步幅是 $n \\cdot w$ 字节。\n一个缓存行的大小是 $L = p \\cdot w$ 字节。\n问题陈述 $n$ 是 $p$ 的倍数，这意味着 $n \\ge p$。因此，步幅 $n \\cdot w$ 大于或等于缓存行大小 $p \\cdot w$。这意味着列访问序列 $A[0][i], A[1][i], \\dots, A[n-1][i]$ 中的每个元素都位于不同的缓存行中。\n\n为更严谨起见，我们来分析元素 $A[k][i]$ 的缓存行索引。为简单起见，假设矩阵基地址为 0，则地址 $(kn+i)w$ 的缓存行索引为 $\\lfloor \\frac{(kn+i)w}{L} \\rfloor = \\lfloor \\frac{kn+i}{p} \\rfloor$。\n由于 $n$ 是 $p$ 的倍数，我们可以写成 $n = m \\cdot p$，其中整数 $m \\ge 1$。\n$A[k][i]$ 的行索引为 $\\lfloor \\frac{k(mp)+i}{p} \\rfloor = \\lfloor km + \\frac{i}{p} \\rfloor = km + \\lfloor \\frac{i}{p} \\rfloor$。\n对于固定的 $i$，随着 $k$ 的递增，项 $km$ 确保了从 $0$ 到 $n-1$ 的每个 $k$ 值都会产生一个唯一的缓存行索引。具体来说，如果 $k_1 \\ne k_2$，那么 $A[k_1][i]$ 和 $A[k_2][i]$ 的行索引将会不同。\n因此，在对 $k$ 的内层循环中的 $n$ 次访问，每次都会导致一次缓存未命中。\n对于外层循环的每次迭代（对于每个固定的 $i$），会有 $n$ 次缓存行填充。\n\n将外层循环从 $i=0$ 到 $i=n-1$ 的所有迭代的次数相加：\n$$ \\text{fills}_{t=\\text{true}} = \\sum_{i=0}^{n-1} n = n \\cdot n = n^2 $$\n\n**计算差值**\n\n问题要求计算差值 $\\Delta = \\text{fills}_{t=\\text{true}} - \\text{fills}_{t=\\text{false}}$。\n代入推导出的表达式：\n$$ \\Delta = n^2 - \\frac{n^2}{p} $$\n提取公因式 $n^2$ 得到最终的解析表达式：\n$$ \\Delta = n^2 \\left(1 - \\frac{1}{p}\\right) $$\n这个表达式表示了从一种空间局部性好的访问模式（在行主序矩阵上进行行式访问）切换到一种非局部性模式（列式访问）时，缓存未命中次数的增加量。", "answer": "$$ \\boxed{n^2 \\left(1 - \\frac{1}{p}\\right)} $$", "id": "3654402"}, {"introduction": "循环不变代码外提最强大的功能之一是为其他更高级的优化（如SIMD矢量化）创造条件。本练习模拟了一个图像处理任务，其中循环内的分支阻碍了矢量化；通过应用循环不变代码外提，我们可以消除该分支，从而释放SIMD的威力。您将计算并分析此项优化带来的预期加速比，从而体会到它在现实场景中的巨大潜力。[@problem_id:3654460]", "problem": "一个图像处理循环遍历一张图像，并为每个像素根据一个在进入循环前只设置一次的循环不变量 $colorSpace$ 来选择一个转换例程。两种可能的例程实现了标准化的转换：\n- 如果 $colorSpace$ 是文本字符串 \"RGB\"，该例程使用 $Y = 0.2126 R + 0.7152 G + 0.0722 B$ 从红、绿、蓝分量计算亮度 $Y$。\n- 如果 $colorSpace$ 是文本字符串 \"YCbCr\"，该例程直接使用 $Y$ 分量作为亮度，无需进行额外的算术运算。\n\n在基线实现中，$colorSpace$ 在循环体内对每个像素都进行检查，这阻碍了向量化，并为每次迭代增加了固定的分支开销。应用循环判断外提 (loop unswitching) 后，通过复制循环将分支提升到循环外部：一个专门用于 \"RGB\" 的循环和一个专门用于 \"YCbCr\" 的循环。这种转换使得对每个专用循环进行单指令多数据 (SIMD) 向量化成为可能。\n\n假设以下条件，均与一个以时钟周期为单位的简单吞吐量成本模型一致：\n- 基线（判断外提前）标量循环每次迭代产生 $c_b = 1$ 个时钟周期的分支开销，并且无法被向量化。\n- 标量操作成本为：每次乘法 $c_m = 1$ 个周期，每次加法 $c_a = 1$ 个周期，每次加载 $c_l = 1$ 个周期，每次存储 $c_s = 1$ 个周期。\n- 每个向量的 SIMD 向量化操作成本为：每次向量乘法 $c^{\\text{vec}}_m = 1$ 个周期，每次向量加法 $c^{\\text{vec}}_a = 1$ 个周期，每次向量加载 $c^{\\text{vec}}_l = 1$ 个周期，每次向量存储 $c^{\\text{vec}}_s = 1$ 个周期。\n- SIMD 宽度为 $w = 8$ 像素，图像尺寸为 $W = 2048$ 和 $H = 1024$，因此像素总数 $N = W \\cdot H$ 可被 $w$ 整除，没有余数循环。\n- 对于 \"RGB\" 例程，每个像素有：$n_m = 3$ 次乘法和 $n_a = 2$ 次加法，以及 $n_l = 3$ 次加载（用于 $R, G, B$）和 $n_s = 1$ 次存储（用于 $Y$）。\n- 对于 \"YCbCr\" 例程，每个像素有：$n_m = 0$ 次乘法和 $n_a = 0$ 次加法，以及 $n_l = 1$ 次加载（用于 $Y$）和 $n_s = 1$ 次存储（用于 $Y$）。\n- 循环判断外提后，分支不在像素循环内执行；假设其一次性成本与 $N$ 相比可以忽略不计。\n- 在程序的多次运行中，$colorSpace$ 等于文本字符串 \"RGB\" 的概率为 $p = 0.6$；否则它等于文本字符串 \"YCbCr\"，概率为 $1 - p$。\n\n仅使用循环不变性、循环判断外提以及针对加载、存储、乘法和加法的标准加性吞吐量模型（以周期为单位）的定义，从第一性原理推导因循环判断外提及随后的 SIMD 向量化所带来的期望加速比 $S$ 的解析表达式。$S$ 定义为每个像素的期望基线周期数与每个像素的期望判断外提后周期数的比值。在给定参数下对 $S$ 进行数值计算。将最终答案表示为一个无量纲实数，并四舍五入到四位有效数字。", "solution": "问题要求推导由循环判断外提及随后的 SIMD 向量化产生的期望加速比 $S$ 的解析表达式。加速比定义为基线实现中每个像素的期望处理时间与优化实现中每个像素的期望处理时间的比值。我们将使用所提供的加性吞吐量成本模型从第一性原理推导此表达式。\n\n设 $C_{\\text{baseline}}$ 为基线实现中每个像素的执行时间（以周期为单位），$C_{\\text{optimized}}$ 为优化实现的时间。加速比 $S$ 是它们期望值的比率：\n$$S = \\frac{E[C_{\\text{baseline}}]}{E[C_{\\text{optimized}}]}$$\n期望 $E[\\cdot]$ 是对由 $colorSpace$ 变量的值决定的两个可能代码路径计算的，其概率分别为 \"RGB\" 的 $p$ 和 \"YCbCr\" 的 $1-p$。\n\n首先，我们确定基线实现的每像素期望成本 $E[C_{\\text{baseline}}]$。在这种情况下，循环包含一个为每个像素执行的条件分支，这会产生固定的开销 $c_b$ 并阻止向量化。处理是标量的。\n\n对于 \"RGB\" 路径，每像素成本 $C_{\\text{baseline, RGB}}$ 是算术和内存操作成本之和，再加上分支开销。给定的操作数量为 $n_m = 3$ 次乘法，$n_a = 2$ 次加法，$n_l = 3$ 次加载，和 $n_s = 1$ 次存储。标量成本为 $c_m = 1, c_a = 1, c_l = 1, c_s = 1$。分支开销为 $c_b=1$。\n$$C_{\\text{baseline, RGB}} = (n_m \\cdot c_m + n_a \\cdot c_a + n_l \\cdot c_l + n_s \\cdot c_s) + c_b$$\n$$C_{\\text{baseline, RGB}} = (3 \\cdot 1 + 2 \\cdot 1 + 3 \\cdot 1 + 1 \\cdot 1) + 1 = (3 + 2 + 3 + 1) + 1 = 9 + 1 = 10 \\text{ cycles/pixel}$$\n\n对于 \"YCbCr\" 路径，操作数量为 $n_m = 0, n_a = 0, n_l = 1, n_s = 1$。每像素成本 $C_{\\text{baseline, YCbCr}}$ 为：\n$$C_{\\text{baseline, YCbCr}} = (n_m \\cdot c_m + n_a \\cdot c_a + n_l \\cdot c_l + n_s \\cdot c_s) + c_b$$\n$$C_{\\text{baseline, YCbCr}} = (0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1) + 1 = (0 + 0 + 1 + 1) + 1 = 2 + 1 = 3 \\text{ cycles/pixel}$$\n\n每像素的期望基线成本是这两个成本的加权平均，使用概率 $p = 0.6$：\n$$E[C_{\\text{baseline}}] = p \\cdot C_{\\text{baseline, RGB}} + (1-p) \\cdot C_{\\text{baseline, YCbCr}}$$\n$$E[C_{\\text{baseline}}] = 0.6 \\cdot 10 + (1-0.6) \\cdot 3 = 6.0 + 0.4 \\cdot 3 = 6.0 + 1.2 = 7.2 \\text{ cycles/pixel}$$\n\n接下来，我们确定优化实现的每像素期望成本 $E[C_{\\text{optimized}}]$。循环判断外提后，条件分支被提升出循环。两个产生的专用循环中的每一个都可以使用 SIMD 指令进行向量化，每个操作的宽度为 $w=8$ 像素。循环内的分支开销被消除了。\n\n对于 \"RGB\" 路径，向量化循环一次处理 $w$ 个像素。每个包含 $w$ 个像素的向量的成本 $C_{\\text{vec, RGB}}$ 是使用向量化操作成本计算的，这些成本均被给定为每次向量操作 $1$ 个周期 ($c^{\\text{vec}}_m = c^{\\text{vec}}_a = c^{\\text{vec}}_l = c^{\\text{vec}}_s = 1$)。\n$$C_{\\text{vec, RGB}} = n_m \\cdot c^{\\text{vec}}_m + n_a \\cdot c^{\\text{vec}}_a + n_l \\cdot c^{\\text{vec}}_l + n_s \\cdot c^{\\text{vec}}_s$$\n$$C_{\\text{vec, RGB}} = 3 \\cdot 1 + 2 \\cdot 1 + 3 \\cdot 1 + 1 \\cdot 1 = 3 + 2 + 3 + 1 = 9 \\text{ cycles/vector}$$\n每像素成本 $C_{\\text{optimized, RGB}}$ 是此成本除以 SIMD 宽度 $w$：\n$$C_{\\text{optimized, RGB}} = \\frac{C_{\\text{vec, RGB}}}{w} = \\frac{9}{8} \\text{ cycles/pixel}$$\n\n对于 \"YCbCr\" 路径，每个包含 $w$ 像素的向量的成本 $C_{\\text{vec, YCbCr}}$ 是：\n$$C_{\\text{vec, YCbCr}} = n_m \\cdot c^{\\text{vec}}_m + n_a \\cdot c^{\\text{vec}}_a + n_l \\cdot c^{\\text{vec}}_l + n_s \\cdot c^{\\text{vec}}_s$$\n$$C_{\\text{vec, YCbCr}} = 0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 0 + 0 + 1 + 1 = 2 \\text{ cycles/vector}$$\n每像素成本 $C_{\\text{optimized, YCbCr}}$ 是：\n$$C_{\\text{optimized, YCbCr}} = \\frac{C_{\\text{vec, YCbCr}}}{w} = \\frac{2}{8} = \\frac{1}{4} \\text{ cycles/pixel}$$\n\n优化的每像素期望成本是这两个成本的加权平均：\n$$E[C_{\\text{optimized}}] = p \\cdot C_{\\text{optimized, RGB}} + (1-p) \\cdot C_{\\text{optimized, YCbCr}}$$\n$$E[C_{\\text{optimized}}] = 0.6 \\cdot \\frac{9}{8} + (1-0.6) \\cdot \\frac{2}{8} = \\frac{0.6 \\cdot 9 + 0.4 \\cdot 2}{8} = \\frac{5.4 + 0.8}{8} = \\frac{6.2}{8} = 0.775 \\text{ cycles/pixel}$$\n\n现在我们可以构建加速比 $S$ 的完整解析表达式：\n$$S = \\frac{p \\cdot C_{\\text{baseline, RGB}} + (1-p) \\cdot C_{\\text{baseline, YCbCr}}}{p \\cdot C_{\\text{optimized, RGB}} + (1-p) \\cdot C_{\\text{optimized, YCbCr}}}$$\n$$S = \\frac{p \\cdot ((n_{m}^{\\text{RGB}} c_m + \\dots) + c_b) + (1-p) \\cdot ((n_{m}^{\\text{YCbCr}} c_m + \\dots) + c_b)}{p \\cdot \\frac{1}{w}(n_{m}^{\\text{RGB}} c_m^{\\text{vec}} + \\dots) + (1-p) \\cdot \\frac{1}{w}(n_{m}^{\\text{YCbCr}} c_m^{\\text{vec}} + \\dots)}$$\n这个表达式代表了从第一性原理推导出的通用公式。\n\n最后，我们代入计算出的期望成本来求出 $S$ 的数值：\n$$S = \\frac{E[C_{\\text{baseline}}]}{E[C_{\\text{optimized}}]} = \\frac{7.2}{0.775}$$\n$$S = \\frac{7.2}{0.775} = \\frac{7200}{775} = \\frac{1440}{155} = \\frac{288}{31} \\approx 9.29032258...$$\n四舍五入到四位有效数字，加速比为 $9.290$。", "answer": "$$\n\\boxed{9.290}\n$$", "id": "3654460"}]}