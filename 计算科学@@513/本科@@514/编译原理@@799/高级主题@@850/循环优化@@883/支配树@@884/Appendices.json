{"hands_on_practices": [{"introduction": "本练习是构建静态单赋值（SSA）形式的一项基础训练。为变量计算最小的 $\\phi$ 函数集合是迭代支配边界（$DF^{+}$）的一个直接应用。本问题将引导你在一个具有多条路径和循环的控制流图上完成整个过程，从而巩固你对定义点如何“传播”对合并点节点需求的理解。[@problem_id:3638854]", "problem": "考虑一个控制流图 (CFG)，它有一个单一入口块 $B_{0}$ 以及以下基本块和有向边。块用 $B_{i}$ 表示，边 $B_{i} \\to B_{j}$ 表示控制流可能从 $B_{i}$ 转移到 $B_{j}$。\n\n该CFG为：\n- $B_{0} \\to B_{1}$\n- $B_{1} \\to B_{2}$ and $B_{1} \\to B_{3}$\n- $B_{2} \\to B_{4}$\n- $B_{3} \\to B_{5}$ and $B_{3} \\to B_{6}$\n- $B_{5} \\to B_{4}$\n- $B_{6} \\to B_{7}$ and $B_{6} \\to B_{8}$\n- $B_{7} \\to B_{6}$ (循环回边)\n- $B_{8} \\to B_{4}$\n- $B_{4} \\to B_{9}$ and $B_{4} \\to B_{10}$\n- $B_{9} \\to B_{11}$\n- $B_{10} \\to B_{11}$\n- $B_{11} \\to B_{12}$\n- $B_{12} \\to B_{13}$ and $B_{12} \\to B_{14}$\n- $B_{13} \\to B_{12}$ (循环回边)\n- $B_{14} \\to B_{15}$\n\n假设单个程序变量 $x$ 仅在以下不相交的块中被定义（赋值）：\n- $B_{2}$, $B_{5}$, $B_{7}$, $B_{9}$, 和 $B_{13}$。\n\n你需要确定在使用迭代支配边界的静态单赋值 (SSA) 构造下，变量 $x$ 的$\\phi$函数插入点的最小集合。请仅使用以下基本定义：\n\n- 支配：一个节点 $d$ 支配一个节点 $n$，如果从入口节点 $B_{0}$ 到 $n$ 的每条路径都包含 $d$。如果 $d$ 支配 $n$ 且 $d \\neq n$，我们称 $d$ 严格支配 $n$。\n- 支配树：由每个节点（入口节点除外）的直接支配节点构成的树。节点的直接支配节点定义为唯一严格支配该节点，但并不严格支配该节点的任何其他严格支配节点的节点。\n- 支配边界 (DF)：对于一个节点 $n$，其支配边界 $\\mathrm{DF}(n)$ 是所有节点 $y$ 的集合，其中 $n$ 支配 $y$ 的至少一个前驱，但 $n$ 并不严格支配 $y$。\n- 迭代支配边界：对于一个节点集合 $S$，其迭代支配边界 $\\mathrm{DF}^{+}(S)$ 是包含 $\\mathrm{DF}(S)$ 且在重复应用 $\\mathrm{DF}$ 下闭合的最小集合，即从 $\\mathrm{DF}(S)$ 开始，在映射 $X \\mapsto X \\cup \\mathrm{DF}(X)$ 下的最小不动点。\n\n从这些定义和给定的 CFG 出发，计算属于最小集合 $\\mathrm{DF}^{+}(S)$ 的不同块的数量，其中 $S = \\{B_{2}, B_{5}, B_{7}, B_{9}, B_{13}\\}$。你的最终答案应为一个精确整数，等于在此 CFG 中使用 $\\mathrm{DF}^{+}$ 进行最小化非剪枝插入时，变量 $x$ 所需的$\\phi$函数数量。", "solution": "该问题要求根据变量 $x$ 在控制流图 (CFG) 中的定义位置，计算其所需的$\\phi$函数数量。根据静态单赋值 (SSA) 形式的构造原则，这等同于找到迭代支配边界的大小，记为 $|\\mathrm{DF}^{+}(S)|$，其中 $S$ 是包含 $x$ 定义的基本块集合。\n\n定义块的集合为 $S = \\{B_{2}, B_{5}, B_{7}, B_{9}, B_{13}\\}$。\n\n$\\mathrm{DF}^{+}(S)$ 的计算需要三个主要步骤：\n1.  确定给定 CFG 的支配关系，并构建支配树。\n2.  为每个相关节点 $n$ 计算其支配边界 $\\mathrm{DF}(n)$。\n3.  通过重复应用 $\\mathrm{DF}$ 算子直至达到不动点，计算迭代支配边界 $\\mathrm{DF}^{+}(S)$。\n\n**步骤 1：支配树构建**\n\n如果从入口块 $B_{0}$ 到节点 $n$ 的每条路径都必须经过节点 $d$，则称节点 $d$ 支配节点 $n$。节点 $n$ 的直接支配节点 $\\mathrm{idom}(n)$ 是 $n$ 的唯一严格支配节点，并且是在从入口到 $n$ 的任何路径上最接近 $n$ 的。通过找到每个块（入口块 $B_{0}$ 除外）的直接支配节点，我们可以构建支配树。\n\n根据 CFG 结构，直接支配节点如下：\n- $\\mathrm{idom}(B_{1}) = B_{0}$\n- $\\mathrm{idom}(B_{2}) = B_{1}$\n- $\\mathrm{idom}(B_{3}) = B_{1}$\n- $\\mathrm{idom}(B_{4}) = B_{1}$ (路径 $B_{0} \\to B_{1} \\to B_{2} \\to B_{4}$，$B_{0} \\to B_{1} \\to B_{3} \\to B_{5} \\to B_{4}$ 等，在分叉并在 $B_{4}$ 重新汇合之前，都必须经过 $B_{1}$)\n- $\\mathrm{idom}(B_{5}) = B_{3}$\n- $\\mathrm{idom}(B_{6}) = B_{3}$ (块 $B_{6}$ 是一个循环的头部，从 $B_{3}$ 进入)\n- $\\mathrm{idom}(B_{7}) = B_{6}$\n- $\\mathrm{idom}(B_{8}) = B_{6}$\n- $\\mathrm{idom}(B_{9}) = B_{4}$\n- $\\mathrm{idom}(B_{10}) = B_{4}$\n- $\\mathrm{idom}(B_{11}) = B_{4}$ (从 $B_{9}$ 和 $B_{10}$ 出发的路径在 $B_{11}$ 重新汇合)\n- $\\mathrm{idom}(B_{12}) = B_{11}$ (块 $B_{12}$ 是一个循环的头部，从 $B_{11}$ 进入)\n- $\\mathrm{idom}(B_{13}) = B_{12}$\n- $\\mathrm{idom}(B_{14}) = B_{12}$\n- $\\mathrm{idom}(B_{15}) = B_{14}$\n\n最终的支配树的父子关系由 $(\\mathrm{idom}(n) \\to n)$ 定义。\n\n**步骤 2：支配边界 (DF) 计算**\n\n支配边界 $\\mathrm{DF}(n)$ 是所有节点 $y$ 的集合，满足 $n$ 支配 $y$ 的一个前驱，但 $n$ 并不严格支配 $y$。我们需要为集合 $S$ 中的块计算 DF，然后为任何添加到我们的 $\\phi$ 节点集中的块计算 DF。\n\n初始集合 $S = \\{B_{2}, B_{5}, B_{7}, B_{9}, B_{13}\\}$ 的 DF：\n- $\\mathrm{DF}(B_{2})$: $B_{2}$ 支配其后继节点的前驱（即其自身）。其后继节点是 $B_{4}$。$B_{2}$ 并不严格支配 $B_{4}$。因此，$\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$。\n- $\\mathrm{DF}(B_{5})$: $B_{5}$ 支配其后继节点的前驱（即其自身）。其后继节点是 $B_{4}$。$B_{5}$ 并不严格支配 $B_{4}$。因此，$\\mathrm{DF}(B_{5}) = \\{B_{4}\\}$。\n- $\\mathrm{DF}(B_{7})$: $B_{7}$ 通过一条回边有一个后继节点 $B_{6}$。$B_{7}$ 支配其后继节点的前驱（即其自身）。$B_{7}$ 并不严格支配循环头 $B_{6}$。因此，$\\mathrm{DF}(B_{7}) = \\{B_{6}\\}$。\n- $\\mathrm{DF}(B_{9})$: $B_{9}$ 支配其后继节点的前驱（即其自身）。其后继节点是 $B_{11}$。$B_{9}$ 并不严格支配 $B_{11}$。因此，$\\mathrm{DF}(B_{9}) = \\{B_{11}\\}$。\n- $\\mathrm{DF}(B_{13})$: $B_{13}$ 通过一条回边有一个后继节点 $B_{12}$。$B_{13}$ 支配其后继节点的前驱（即其自身）。$B_{13}$ 并不严格支配循环头 $B_{12}$。因此，$\\mathrm{DF}(B_{13}) = \\{B_{12}\\}$。\n\n**步骤 3：迭代支配边界 ($DF^{+}$) 计算**\n\n需要$\\phi$函数的节点集合（我们记为 $\\Phi$）是满足 $\\Phi = \\mathrm{DF}(S \\cup \\Phi)$ 的最小集合。我们可以使用工作列表算法将其计算为最小不动点。\n\n设 $W$ 是一个工作列表，其中包含需要处理其 DF 的块。\n设 $\\Phi$ 是放置$\\phi$函数的块的集合。\n\n1.  初始化 $\\Phi = \\emptyset$ 和 $W = S = \\{B_{2}, B_{5}, B_{7}, B_{9}, B_{13}\\}$。\n\n2.  处理初始工作列表：\n    - 从 $W$ 中弹出 $B_{2}$。计算 $\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$。由于 $B_{4} \\notin \\Phi$，将 $B_{4}$ 添加到 $\\Phi$ 和 $W$ 中。\n      $\\Phi = \\{B_{4}\\}$, $W = \\{B_{5}, B_{7}, B_{9}, B_{13}, B_{4}\\}$。\n    - 从 $W$ 中弹出 $B_{5}$。计算 $\\mathrm{DF}(B_{5}) = \\{B_{4}\\}$。由于 $B_{4} \\in \\Phi$，无操作。\n      $\\Phi = \\{B_{4}\\}$, $W = \\{B_{7}, B_{9}, B_{13}, B_{4}\\}$。\n    - 从 $W$ 中弹出 $B_{7}$。计算 $\\mathrm{DF}(B_{7}) = \\{B_{6}\\}$。由于 $B_{6} \\notin \\Phi$，将 $B_{6}$ 添加到 $\\Phi$ 和 $W$ 中。\n      $\\Phi = \\{B_{4}, B_{6}\\}$, $W = \\{B_{9}, B_{13}, B_{4}, B_{6}\\}$。\n    - 从 $W$ 中弹出 $B_{9}$。计算 $\\mathrm{DF}(B_{9}) = \\{B_{11}\\}$。由于 $B_{11} \\notin \\Phi$，将 $B_{11}$ 添加到 $\\Phi$ 和 $W$ 中。\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}\\}$, $W = \\{B_{13}, B_{4}, B_{6}, B_{11}\\}$。\n    - 从 $W$ 中弹出 $B_{13}$。计算 $\\mathrm{DF}(B_{13}) = \\{B_{12}\\}$。由于 $B_{12} \\notin \\Phi$，将 $B_{12}$ 添加到 $\\Phi$ 和 $W$ 中。\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$。\n\n3.  对 $S$ 的第一遍处理完成。现在我们处理被添加到 $W$ 中的块。为此，我们需要它们的 DF。\n    - $\\mathrm{DF}(B_{4})$: 从 $B_{4}$ 出发的任何路径都停留在由 $B_{4}$ 支配的子图中。没有从 $B_{4}$ 支配的节点到非 $B_{4}$ 严格支配的节点的边。因此，$\\mathrm{DF}(B_{4}) = \\emptyset$。\n    - $\\mathrm{DF}(B_{6})$: $B_{6}$ 支配 $B_{8}$，$B_{8}$ 的后继是 $B_{4}$。$B_{6}$ 并不严格支配 $B_{4}$，所以 $B_{4} \\in \\mathrm{DF}(B_{6})$。同时，$B_{6}$ 支配 $B_{7}$，$B_{7}$ 的后继是 $B_{6}$。$B_{6}$ 并不严格支配其自身，所以 $B_{6} \\in \\mathrm{DF}(B_{6})$。因此，$\\mathrm{DF}(B_{6}) = \\{B_{4}, B_{6}\\}$。\n    - $\\mathrm{DF}(B_{11})$: 与 $B_{4}$ 对称地，$\\mathrm{DF}(B_{11}) = \\emptyset$。\n    - $\\mathrm{DF}(B_{12})$: $B_{12}$ 支配 $B_{13}$，$B_{13}$ 的后继是 $B_{12}$。$B_{12}$ 并不严格支配其自身。因此，$\\mathrm{DF}(B_{12}) = \\{B_{12}\\}$。\n\n4.  继续处理工作列表：\n    - 从 $W$ 中弹出 $B_{4}$。计算 $\\mathrm{DF}(B_{4}) = \\emptyset$。无变化。\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\{B_{6}, B_{11}, B_{12}\\}$。\n    - 从 $W$ 中弹出 $B_{6}$。计算 $\\mathrm{DF}(B_{6}) = \\{B_{4}, B_{6}\\}$。$B_{4}$ 和 $B_{6}$ 都已在 $\\Phi$ 中。无变化。\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\{B_{11}, B_{12}\\}$。\n    - 从 $W$ 中弹出 $B_{11}$。计算 $\\mathrm{DF}(B_{11}) = \\emptyset$。无变化。\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\{B_{12}\\}$。\n    - 从 $W$ 中弹出 $B_{12}$。计算 $\\mathrm{DF}(B_{12}) = \\{B_{12}\\}$。$B_{12}$ 已在 $\\Phi$ 中。无变化。\n      $\\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$, $W = \\emptyset$。\n\n5.  工作列表 $W$ 现在为空。算法终止。\n\n需要$\\phi$函数的块的最小集合是 $\\mathrm{DF}^{+}(S) = \\Phi = \\{B_{4}, B_{6}, B_{11}, B_{12}\\}$。\n问题要求的是该集合中不同块的数量。\n该集合的大小为 $|\\Phi| = 4$。", "answer": "$$\\boxed{4}$$", "id": "3638854"}, {"introduction": "在通用算法的基础上，本练习侧重于程序分析中循环这一关键情况。循环头是特殊的控制流合并点，它们的支配边界对于正确处理循环携带的依赖关系至关重要。通过这个例子，你将精确地看到支配边界的形式化理论如何识别出循环头是放置 $\\phi$ 函数的正确位置，该函数用于合并变量的初始值和来自先前迭代的值。[@problem_id:3638820]", "problem": "考虑以下控制流图（CFG），其基本块标记为 $S$、$H$、$B$、$B_1$、$B_2$、$B_3$、$J$ 和 $T$。有向边为：$S \\to H$、$H \\to B$、$H \\to T$、$B \\to B_1$、$B \\to B_2$、$B_1 \\to J$、$B_2 \\to B_3$、$B_3 \\to J$ 和 $J \\to H$。块 $H$ 是循环头，回边是 $J \\to H$。假设一个标量变量 $x$ 最初在 $S$ 中定义，在两个不同的循环体块 $B_1$ 和 $B_3$ 中被更新，并在 $J$ 处（在走回边之前）、在 $H$ 处的循环继续测试中，以及在循环退出后的 $T$ 处被使用。静态单赋值（SSA）形式将使用迭代支配边界方法构建，并假设根据上述使用情况指定的活跃性进行剪枝 SSA 放置。\n\n任务：\n- 计算给定CFG的支配集和以 $S$ 为根的直接支配树。\n- 从第一性原理出发，计算循环头 $H$ 的支配边界，并论证该集合中的每个元素。\n- 仅使用支配、直接支配者和支配边界的定义，通过其定义位置的迭代支配边界来确定 $x$ 的最小 SSA $\\phi$-函数放置。特别解释 $H$ 的支配边界如何指导循环携带值的 $\\phi$-函数放置。\n- 最后，报告在给定的活跃性假设下，使用迭代支配边界进行最小 SSA 放置后，必须包含变量 $x$ 的 $\\phi$-函数的不同基本块的总数。\n\n你的最终答案必须是一个等于变量 $x$ 的 $\\phi$-函数所在的不同基本块数量的整数。不要包含任何单位。不需要四舍五舍。", "solution": "问题陈述是有效的。这是一个定义明确的编译器理论问题，其基础是控制流图（CFG）、支配者分析和静态单赋值（SSA）形式构建的既定原则。给定的条件是自足且一致的，允许得出唯一的解。\n\n该问题描述了一个CFG，其基本块集合为 $V = \\{S, H, B, B_1, B_2, B_3, J, T\\}$。入口块是 $S$。有向边集合为 $E = \\{(S, H), (H, B), (H, T), (B, B_1), (B, B_2), (B_1, J), (B_2, B_3), (B_3, J), (J, H)\\}$。变量 $x$ 在块 $\\{S, B_1, B_3\\}$ 中定义，并在块 $\\{H, J, T\\}$ 中使用。\n\n**1. 支配集和直接支配树**\n\n如果从入口节点 $S$到节点 $M$ 的每条路径都包含节点 $N$，则称节点 $N$ 支配节点 $M$。如果 $N$ 支配 $M$ 且 $N \\neq M$，则称 $N$ 严格支配 $M$。$M$ 的直接支配者，记为 $idom(M)$，是在任何从入口出发的路径上离 $M$ 最近的严格支配者。\n\n通过分析从入口节点 $S$ 到每个其他节点的所有路径，我们计算出每个节点 $N \\in V$ 的支配集 $Dom(N)$：\n- $Dom(S) = \\{S\\}$\n- $Dom(H) = \\{S, H\\}$。任何到 $H$ 的路径要么是 $S \\to H$，要么通过循环本身再次经过 $H$。\n- $Dom(B) = \\{S, H, B\\}$。任何到 $B$ 的路径形式为 $S \\to \\dots \\to H \\to B$。\n- $Dom(T) = \\{S, H, T\\}$。任何到 $T$ 的路径形式为 $S \\to \\dots \\to H \\to T$。\n- $Dom(B_1) = \\{S, H, B, B_1\\}$。任何到 $B_1$ 的路径形式为 $S \\to \\dots \\to H \\to B \\to B_1$。\n- $Dom(B_2) = \\{S, H, B, B_2\\}$。任何到 $B_2$ 的路径形式为 $S \\to \\dots \\to H \\to B \\to B_2$。\n- $Dom(B_3) = \\{S, H, B, B_2, B_3\\}$。任何到 $B_3$ 的路径形式为 $S \\to \\dots \\to H \\to B \\to B_2 \\to B_3$。\n- $Dom(J) = \\{S, H, B, J\\}$。到 $J$ 的路径有 $S \\to \\dots \\to B_1 \\to J$ 和 $S \\to \\dots \\to B_3 \\to J$。$B_1$ 和 $B_3$ 的共同支配者是 $\\{S, H, B\\}$，所以这些节点必须在任何到 $J$ 的路径上。\n\n根据支配集，我们确定除 $S$ 外每个节点 $N$ 的直接支配者 $idom(N)$：\n- $idom(H) = S$\n- $idom(B) = H$\n- $idom(T) = H$\n- $idom(B_1) = B$\n- $idom(B_2) = B$\n- $idom(B_3) = B_2$\n- $idom(J) = B$。$J$ 的前驱是 $B_1$ 和 $B_3$。在支配树中，$B_1$ 和 $B_3$ 的最低公共祖先是 $B$。\n\n得到的以 $S$ 为根的直接支配树是：\n$S$ 是 $H$ 的父节点。\n$H$ 是 $B$ 和 $T$ 的父节点。\n$B$ 是 $B_1$、$B_2$ 和 $J$ 的父节点。\n$B_2$ 是 $B_3$ 的父节点。\n\n**2. 循环头 $H$ 的支配边界**\n\n节点 $N$ 的支配边界，记为 $DF(N)$，是所有节点 $Y$ 的集合，其中 $N$ 支配 $Y$ 在CFG中的一个直接前驱，但 $N$ 并不严格支配 $Y$。形式上：\n$$DF(N) = \\{ Y \\in V \\mid (\\exists P \\in pred_{CFG}(Y) \\text{ s.t. } N \\in Dom(P)) \\land (N \\notin Dom(Y) \\setminus \\{Y\\}) \\}$$\n我们从这个第一性原理出发计算 $DF(H)$。我们必须找到节点 $Y$，使得 $H$ 支配 $Y$ 的一个前驱 $P$，但 $H$ 不严格支配 $Y$。不被 $H$ 严格支配的节点集合是 $\\{S, H\\}$。我们只需检查这两个节点作为 $Y$ 的候选者。\n- **候选 $Y=S$**：在给定的CFG中，节点 $S$ 没有前驱。条件 $(\\exists P \\in pred_{CFG}(S))$ 为假。因此，$S \\notin DF(H)$。\n- **候选 $Y=H$**：$H$ 的前驱是 $S$ 和 $J$。\n    - 考虑前驱 $P=S$：$H$ 不支配 $S$（实际上是 $S$ 支配 $H$），所以这个前驱不满足条件。\n    - 考虑前驱 $P=J$：$H$ 支配 $J$，因为 $Dom(J) = \\{S, H, B, J\\}$。条件的第一个部分得到满足。现在我们检查第二个部分：$H$ 是否不严格支配 $H$？是的，$H$ 支配它自身，但不是严格支配。条件的第二个部分也得到满足。\n因此，$H \\in DF(H)$。\n\n由于没有其他节点可以在 $H$ 的支配边界中，我们得出结论 $DF(H) = \\{H\\}$。这个结果是循环头的典型特征；它们是来自循环外部和来自循环回边的控制流的合并点。\n\n**3. 最小 SSA $\\phi$-函数放置**\n\n变量 $x$ 的最小 $\\phi$-函数集放置在包含 $x$ 定义的块集的迭代支配边界 $IDF(Defs(x))$ 处。初始定义位置是 $Defs(x) = \\{S, B_1, B_3\\}$。$IDF$ 是通过一个工作列表算法计算的。\n\n首先，我们需要定义位置以及我们随后放置 $\\phi$-函数的任何位置的支配边界。\n- $DF(S) = \\emptyset$，因为 $S$ 没有前驱，并且它唯一的后继 $H$ 被 $S$ 严格支配。\n- $DF(B_1) = \\{J\\}$。$B_1$ 有一个后继 $J$。$J$ 的一个前驱是 $B_1$，它被 $B_1$ 支配。然而，$B_1$ 并不严格支配 $J$（实际上是 $B$ 支配 $J$）。因此，$J \\in DF(B_1)$。\n- $DF(B_3) = \\{J\\}$。$J$ 的一个前驱是 $B_3$，它被 $B_3$ 支配。然而，$B_3$ 并不严格支配 $J$。因此，$J \\in DF(B_3)$。\n- $DF(J) = \\{H\\}$。$H$ 的一个前驱是 $J$，它被 $J$ 支配。然而，$J$ 并不严格支配 $H$。因此，$H \\in DF(J)$。\n- $DF(H) = \\{H\\}$，如前所述。\n\n工作列表算法过程如下：\n- 初始化工作列表 $W = \\{S, B_1, B_3\\}$。初始化有 $\\phi$-函数的节点集合 $\\Phi = \\emptyset$。\n- **步骤 1**：从 $W$ 中弹出 $S$。计算 $DF(S) = \\emptyset$。没有新的 $\\phi$-函数被添加。$W = \\{B_1, B_3\\}$。\n- **步骤 2**：从 $W$ 中弹出 $B_1$。计算 $DF(B_1) = \\{J\\}$。由于 $J \\notin \\Phi$，向 $J$ 添加一个 $\\phi$-函数。更新 $\\Phi = \\{J\\}$ 并将 $J$ 添加到工作列表：$W = \\{B_3, J\\}$。\n- **步骤 3**：从 $W$ 中弹出 $B_3$。计算 $DF(B_3) = \\{J\\}$。由于 $J \\in \\Phi$，不执行任何操作。$W = \\{J\\}$。\n- **步骤 4**：从 $W$ 中弹出 $J$。计算 $DF(J) = \\{H\\}$。由于 $H \\notin \\Phi$，向 $H$ 添加一个 $\\phi$-函数。更新 $\\Phi = \\{J, H\\}$ 并将 $H$ 添加到工作列表：$W = \\{H\\}$。\n- **步骤 5**：从 $W$ 中弹出 $H$。计算 $DF(H) = \\{H\\}$。由于 $H \\in \\Phi$，不执行任何操作。$W = \\emptyset$。\n\n工作列表现在为空。算法终止。需要 $\\phi$-函数的块集为 $\\Phi = \\{J, H\\}$。\n\n问题指定了*剪枝* SSA 放置，这意味着只有当变量 $x$ 在节点 $Y$ 的入口处是活跃的（live）时，才会在 $Y$ 处放置 $\\phi$-函数。\n- 在 $J$ 处放置了一个 $\\phi$-函数。问题陈述 $x$ 在 $J$ 处被使用。因此，$x$ 在进入 $J$ 时是活跃的，这个 $\\phi$-函数是必要的。\n- 在 $H$ 处放置了一个 $\\phi$-函数。问题陈述 $x$ 在 $H$ 处用于循环测试。因此，$x$ 在进入 $H$ 时是活跃的，这个 $\\phi$-函数是必要的。\n活跃性分析证实了这两个 $\\phi$-函数都是必需的。\n\n在循环头 $H$ 处放置 $\\phi$-函数对于处理循环携带值至关重要。如果一个 $x$ 的值在一次迭代中定义，并在后续迭代中使用，则认为它是循环携带的。在这种情况下，$x$ 的定义发生在循环体（$B_1$, $B_3$）中。这些定义在块 $J$ 处到达迭代的末尾。回边 $J \\to H$ 将这个值带到下一次迭代的开始。循环头 $H$ 是 $x$ 的两组不同到达定义的合并点：来自 $S$ 的初始值（首次进入时）和来自 $J$ 的前一次迭代的值。支配边界的形式化方法正确地将 $H$ 识别为这个合并点。迭代算法首先找到循环体内部两条路径的汇合点 $J$（$DF(B_1) \\cup DF(B_3) = \\{J\\}$）。然后，将 $J$ 视为一个新的定义位置，算法找到循环本身的汇合点（$DF(J)=\\{H\\}$）。因此，$H$ 处的 $\\phi$-函数正确地合并了 $x$ 的初始值和 $x$ 的循环携带值。\n\n**4. 最终计数**\n\n必须为 $x$ 包含 $\\phi$-函数的不同基本块的集合是 $\\{J, H\\}$。这类块的总数是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3638820"}, {"introduction": "大多数编译器分析都是为“行为良好”或可约的控制流图设计的。本练习将挑战你超越这一假设，去分析一个不可约图，其中循环内没有单个节点能支配所有块。你将根据支配的定义来诊断不可约性，并应用一种标准的修复技术——节点分裂——来恢复基于支配者分析所需的属性。[@problem_id:3638857]", "problem": "考虑以下控制流图 (CFG)，其具有唯一的入口节点 $S$ 和唯一的出口节点 $T$。节点为 $S, A, B, C, D, E, F, T$。有向边如下：\n- $S \\to A$，\n- $A \\to B$，$A \\to C$，$A \\to F$，\n- $F \\to D$，\n- $B \\to D$，\n- $D \\to C$，\n- $C \\to E$，\n- $E \\to B$，$E \\to T$。\n\n此 CFG 在节点集 $\\{B, C, D, E\\}$ 上包含一个强连通分量 (SCC)，其中有循环 $B \\to D \\to C \\to E \\to B$。我们将此 SCC 视为一个候选循环。\n\n您将使用以下基本定义：\n- 支配：在一个入口为 $S$ 的 CFG 中，如果从 $S$ 到节点 $Y$ 的每一条路径都包含节点 $X$，则节点 $X$ 支配节点 $Y$。\n- 循环头：循环头是支配其循环体中所有节点的节点。\n- 可规约流图：如果每个循环都是单入口的，则一个 CFG 是可规约的；等价地，每个循环都有一个单一的循环头，该循环头支配循环体中的所有节点。\n- 不可规约流图：如果存在某个循环，有多个从 SCC 外部进入 SCC 不同节点的独立入口边，因此没有单个节点能支配整个 SCC，则一个 CFG 是不可规约的。\n\n任务：\n1) 仅使用上述定义，通过检查 $B$ 是否支配 $C$ 和 $D$ 来论证节点 $B$ 是否可以作为 SCC $\\{B, C, D, E\\}$ 的循环头。根据您的推理，判断该 SCC 相对于 $B$ 是否是不可规约的。\n\n2) 为了修复不可规约性，应用以下确定性的节点分裂过程，其中 $B$ 被指定为循环头 $H$：\n   - 在 SCC 上通过边 $B \\to D$、$D \\to C$、$C \\to E$、$E \\to B$ 定义唯一的朝向循环头的后继映射。对于任何 $v \\in \\{B,C,D,E\\}$，这个选择都导出一个唯一的朝向循环头的路径，通向 $H = B$，通过重复遵循此映射直到到达 $B$。\n   - 对于每一条边 $(u \\to v)$，其中 $u \\notin \\{B,C,D,E\\}$ 且 $v \\in \\{B,C,D,E\\}$ 且 $v \\neq B$，沿着从 $v$ 到 $B$ 的朝向循环头的路径执行节点分裂：\n     • 为从 $v$ 开始到 $B$ 之前的朝向循环头的路径上的每个节点创建新的副本。如果路径是 $v = w_{0} \\to w_{1} \\to \\dots \\to w_{k-1} \\to w_{k} = B$，则创建新节点 $w_{0}', w_{1}', \\dots, w_{k-1}'$。\n     • 将 $(u \\to v)$ 重定向到 $(u \\to w_{0}')$，并为 $i = 0, \\dots, k-2$ 添加边 $w_{i}' \\to w_{i+1}'$ 和 $w_{k-1}' \\to B$。\n     • 对于从任何 $w_{i}$ 到 SCC 外部节点的任何原始出口边，从 $w_{i}'$ 添加相同的出口边到那个外部目标。\n     • 不要在不同的外部入口边之间共享副本；每个外部入口都会沿着其通向 $B$ 的路径生成其自己的一组新副本。\n   - 如果 $v = B$ (循环头)，则对 $(u \\to v)$ 不执行任何操作。\n\n3) 设 $N$ 为通过此修复过程在给定 CFG 上创建的新节点副本的总数。计算 $N$。您的最终答案必须是一个实数。无需四舍五入。", "solution": "我们从支配、循环头以及可规约与不可规约流图的定义开始。\n\n步骤 1：检测不可规约性和非支配关系。\n- SCC $\\{B, C, D, E\\}$ 通过 $B \\to D \\to C \\to E \\to B$ 形成一个循环，所以这四个节点是相互可达的。这是一个候选循环。\n- 进入此 SCC 的外部入口边是从 SCC 外部的节点指向 SCC 内部的节点的边。从边列表中可以看出：\n  • $A \\to B$ 在 $B$ 进入 SCC。\n  • $A \\to C$ 在 $C$ 进入 SCC。\n  • $F \\to D$ 在 $D$ 进入 SCC。\n  因此，有三条不同的入口边进入 SCC，分别指向 $B$、$C$ 和 $D$。\n- 要测试 $B$ 是否能成为循环头，我们必须验证 $B$ 是否支配 SCC 中的每一个节点。使用支配的定义，检查 $C$ 和 $D$：\n  • 对于 $C$：存在一条路径 $S \\to A \\to C$，它到达 $C$ 而不经过 $B$。因此，并非每一条从 $S$ 到 $C$ 的路径都包含 $B$，所以 $B$ 不支配 $C$。\n  • 对于 $D$：存在一条路径 $S \\to A \\to F \\to D$，它到达 $D$ 而不经过 $B$。因此，$B$ 不支配 $D$。\n  由于 $B$ 未能支配至少 $C$ 和 $D$，$B$ 不能作为该 SCC 的循环头。存在多个外部入口 $(A \\to C)$ 和 $(F \\to D)$ 进入 SCC 的不同节点，根据单入口准则，这意味着该 SCC 相对于 $B$ 是不可规约的。\n\n步骤 2：应用带有朝向循环头的后继映射的确定性节点分裂修复。\n- 朝向循环头的后继映射被指定为 $B \\to D$、$D \\to C$、$C \\to E$、$E \\to B$。这为 SCC 中的任何节点产生了到达 $B$ 的唯一朝向循环头的路径：\n  • 从 $C$：$C \\to E \\to B$。\n  • 从 $D$：$D \\to C \\to E \\to B$。\n  • 从 $E$：$E \\to B$。\n  • 从 $B$：已在 $B$。\n- 我们必须处理每一个外部入口 $(u \\to v)$，其中 $u \\notin \\{B,C,D,E\\}$ 且 $v \\in \\{B,C,D,E\\}, v \\neq B$。\n\n存在两条这样的边：\n- 边 $(A \\to C)$，其中 $v = C \\neq B$。\n  • 从 $C$ 到 $B$ 的朝向循环头的路径是 $C \\to E \\to B$。此路径上严格在 $B$ 之前的节点是 $C$ 和 $E$。\n  • 创建新副本 $C_{1}$ 和 $E_{1}$。\n  • 将 $A \\to C$ 重定向到 $A \\to C_{1}$。\n  • 添加边 $C_{1} \\to E_{1}$ 和 $E_{1} \\to B$。\n  • 复制从原始节点到 SCC 外部的出口边：$E$ 有一个出口边 $E \\to T$，因此添加 $E_{1} \\to T$。在原始图中，节点 $C$ 没有到 SCC 外部的出口，因此 $C_{1}$ 不需要复制出口边。\n  • 此外部入口贡献的新节点数量为 $2$ (节点 $C_{1}$ 和 $E_{1}$)。\n\n- 边 $(F \\to D)$，其中 $v = D \\neq B$。\n  • 从 $D$ 到 $B$ 的朝向循环头的路径是 $D \\to C \\to E \\to B$。此路径上严格在 $B$ 之前的节点是 $D$、$C$ 和 $E$。\n  • 创建新副本 $D_{2}$、$C_{2}$ 和 $E_{2}$。\n  • 将 $F \\to D$ 重定向到 $F \\to D_{2}$。\n  • 添加边 $D_{2} \\to C_{2}$、$C_{2} \\to E_{2}$ 和 $E_{2} \\to B$。\n  • 复制从原始节点到 SCC 外部的出口边：$E$ 有出口边 $E \\to T$，因此添加 $E_{2} \\to T$。在原始图中，节点 $D$ 和 $C$ 没有到 SCC 外部的出口，因此 $D_{2}$ 或 $C_{2}$ 不需要复制出口边。\n  • 此外部入口贡献的新节点数量为 $3$ (节点 $D_{2}$、$C_{2}$ 和 $E_{2}$)。\n\n根据流程，副本不在不同的外部入口之间共享。因此，创建的新节点总数是这两个入口贡献数量的总和。\n\n步骤 3：计算 $N$。\n- 来自 $(A \\to C)$：$2$ 个新节点。\n- 来自 $(F \\to D)$：$3$ 个新节点。\n因此，\n$$\nN = 2 + 3 = 5\n$$\n\n步骤 4：后置条件检查（此修复在概念上为何有效）。\n- 经过这些转换后，从 SCC $\\{B, C, D, E\\}$ 外部进入原始 SCC 节点的唯一剩余边是 $A \\to B$ (循环头)。被重定向的边现在进入新的副本，然后到达 $B$ 或在 $T$ 退出，而不会进入除 $B$ 之外的任何原始 SCC 节点。\n- 因此，从 $S$ 到原始 SCC 中任何节点的每条路径都必须经过 $B$，所以 $B$ 现在支配了 SCC 中的所有节点，使得该循环成为单入口，并且 CFG 相对于该循环是可规约的。\n- 计算出的 $N$ 量化了在指定的确定性流程下通过节点分裂进行修复的规模。\n\n因此，创建的新节点副本总数为 $5$。", "answer": "$$\\boxed{5}$$", "id": "3638857"}]}