{"hands_on_practices": [{"introduction": "值编号的核心思想是识别程序中语义上等价的计算。本练习将通过一个简单的场景，带你初探值编号的威力。我们将处理一个包含多个常量算术表达式的直线代码序列，并运用常量折叠技术来揭示它们是如何被归入同一个等价类的。[@problem_id:3681968] 这个基础练习旨在帮助你建立对值编号如何发现和利用计算结果同一性的直观理解。", "problem": "在针对顺序代码的局部值编号中，编译器根据选定的等价概念将表达式划分到不同的等价类中，并为等价的表达式分配相同的值编号。考虑一个基本块，它按顺序执行以下三个赋值语句：$x := 7 + 5$，$y := 12$，$z := 3 \\times 4$。假设该值编号算法在整数算术上运行，并使用以下基本原则和规则：\n\n- 基本语义：在 $+$、$-$、$\\times$ 和精确 $\\div$ 下的整数算术遵循 $+$ 和 $\\times$ 的标准结合律和交换律公理，并且 $\\times$ 对 $+$ 满足分配律。整数上的常量表达式通过常量折叠被求值为单个整数常量。\n- 等价定义：如果两个表达式在此基本块上下文中对于所有执行都求值为相同的整数，则它们是等价的。特别地，同一整数常量的所有出现都是等价的；任何通过常量折叠得到该整数的表达式也与之等价。\n- 规范化：每个整数常量 $k$ 都有一个唯一的规范代表；所有与 $k$ 等价的表达式都映射到同一个代表。\n- 值编号协议：从上到下扫描语句，当首次遇到一个规范代表时，将最小的未使用正整数作为其值编号分配给它；之后任何与现有代表等价的表达式都将重用其值编号。\n\n从一个空的值表开始，将这些规则应用于这三个语句。处理完所有三个语句后，出现的不同值编号的总数是多少？请以单个整数形式提供你的答案。无需四舍五入。", "solution": "问题陈述根据所需标准进行解析和验证。\n\n**步骤1：提取已知条件**\n- **代码：** 一个包含三个顺序赋值语句的基本块：\n    1.  $x := 7 + 5$\n    2.  $y := 12$\n    3.  $z := 3 \\times 4$\n- **算法：** 局部值编号。\n- **初始状态：** 值表为空。\n- **规则：**\n    1.  **语义：** 标准整数算术与常量折叠。像 $a+b$ 或 $c \\times d$ 这样的表达式（其中 $a, b, c, d$ 是整数常量）被求值为单个整数常量。\n    2.  **等价性：** 如果两个表达式在基本块内求值为相同的整数值，则它们是等价的。\n    3.  **规范化：** 每个整数常量作为其等价类的唯一规范代表。\n    4.  **编号协议：** 按顺序处理语句。首次看到一个规范代表时，为其分配最小的未使用正整数作为其值编号。其规范代表已在表中的后续表达式重用现有的值编号。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，定义明确且客观。它描述了编译器理论中的一个标准算法（局部值编号），具有清晰、无歧义的规则集和明确定义的初始状态。语言正式而精确。问题是自包含且一致的。未发现任何缺陷。\n\n**结论：** 问题有效。\n\n**步骤3：推导解决方案**\n我们将根据指定的规则模拟值编号过程，跟踪值表的状态，该表将规范代表（整数常量）映射到其分配的值编号。同时也会跟踪已使用的值编号集合。\n\n- **初始状态：**\n  - 值表：`{}` (空)\n  - 不同值编号的集合：$\\emptyset$\n  - 下一个可用的值编号：$1$\n\n- **处理语句1：`$x := 7 + 5$`**\n  1.  右侧（RHS）是表达式 $7 + 5$。\n  2.  根据常量折叠规则，对该表达式求值。结果是整数常量 $12$。\n  3.  因此，表达式 $7 + 5$ 的规范代表是 $12$。\n  4.  我们检查值表中是否存在规范代表 $12$。它不存在，因为表是空的。\n  5.  由于这是第一次遇到规范代表 $12$，我们为其分配下一个可用的值编号，即 $1$。\n  6.  值表更新为：`ValueTable[12] = 1`。\n  7.  变量 $x$ 与值编号 $1$ 相关联。\n  - **语句1之后的状态：**\n    - 值表：`{12 -> 1}`\n    - 不同值编号的集合：$\\{1\\}$\n    - 下一个可用的值编号：$2$\n\n- **处理语句2：`$y := 12$`**\n  1.  右侧是表达式 $12$。\n  2.  这个表达式已经是整数常量，所以它的规范代表是 $12$。\n  3.  我们检查值表中是否存在规范代表 $12$。它存在；`ValueTable[12]` 是 $1$。\n  4.  根据协议，我们重用现有的值编号。表达式 $12$ 的值编号是 $1$。\n  5.  没有分配新的值编号。\n  6.  变量 $y$ 与值编号 $1$ 相关联。\n  - **语句2之后的状态：**\n    - 值表：`{12 -> 1}`\n    - 不同值编号的集合：$\\{1\\}$\n    - 下一个可用的值编号：$2$\n\n- **处理语句3：`$z := 3 \\times 4$`**\n  1.  右侧是表达式 $3 \\times 4$。\n  2.  应用常量折叠，该表达式求值为整数常量 $12$。\n  3.  因此，表达式 $3 \\times 4$ 的规范代表是 $12$。\n  4.  我们检查值表中是否存在规范代表 $12$。它存在；`ValueTable[12]` 是 $1$。\n  5.  我们重用现有的值编号。表达式 $3 \\times 4$ 的值编号是 $1$。\n  6.  没有分配新的值编号。\n  7.  变量 $z$ 与值编号 $1$ 相关联。\n  - **语句3之后的状态：**\n    - 值表：`{12 -> 1}`\n    - 不同值编号的集合：$\\{1\\}$\n    - 下一个可用的值编号：$2$\n\n**结论：**\n处理完所有三个语句后，我们建立了一个等价类，由规范整数 $12$ 表示。该类被分配了值编号 $1$。表达式 $7 + 5$、$12$ 和 $3 \\times 4$ 都是等价的。在整个过程中分配的所有不同值编号的集合是 $\\{1\\}$。不同值编号的总数是该集合的基数，即 $1$。", "answer": "$$\\boxed{1}$$", "id": "3681968"}, {"introduction": "真实的程序充满了分支和合并，这给跨基本块识别等价表达式带来了挑战。本练习将我们从局部值编号带入全局值编号 (GVN) 的世界，通过一个典型的控制流图来模拟这一情景。你将看到，静态单赋值 (SSA) 形式和 $\\phi$ 函数如何协同工作，使得在不同执行路径上的表达式（例如 $p + q$ 和 $r + s$）也能被证明是等价的。[@problem_id:3681958] 这个练习是理解现代编译器如何在复杂的代码结构中进行全局优化的关键一步。", "problem": "考虑以下程序片段，它由一个带有钻石形状和一处汇合的控制流图（CFG; Control Flow Graph）表示，并以静态单赋值形式（SSA; Static Single Assignment form）编写。程序从块 $B_0$ 开始，然后分支到块 $B_1$ 和 $B_2$，最后在块 $B_3$ 汇合。变量 $a$ 和 $b$ 是输入，并且在分支之前没有被重新定义。这些块是：\n\n- $B_0$: $a := \\text{input}()$; $b := \\text{input}()$; if $\\text{cond}$ then goto $B_1$ else goto $B_2$.\n- $B_1$: $p := a$; $q := b$; $x := p + q$; goto $B_3$.\n- $B_2$: $r := a$; $s := b$; $y := r + s$; goto $B_3$.\n- $B_3$: $t := \\phi(x, y)$; \\text{return } $t$.\n\n假设一个全局值编号（GVN; Global Value Numbering）算法具有以下特性：\n- 将每个值的定义（包括副本）与一个值编号相关联。\n- 为副本 $u := v$ 赋予与 $v$ 相同的值编号。\n- 为一个二元运算 $op(u_1, u_2)$ 分配一个仅由 $op$ 以及 $u_1$ 和 $u_2$ 的值编号决定的值编号。\n- 对于一个 $\\phi$ 函数，如果所有传入的操作数具有相同的值编号，则该 $\\phi$ 函数也获得相同的值编号。\n\n此题意在建模一种情况：相同的表达式出现在不同的路径上，但这是在经过不同的替换之后才发生的，具体来说，一条路径上有 $x := p + q$，另一条路径上有 $y := r + s$，并且由于之前的副本操作，有 $p = r$ 和 $q = s$。\n\n下列哪个陈述最能描述 GVN 在 $B_3$ 中推断出的结论及其原因？\n\nA. $B_1$ 和 $B_2$ 内的局部值编号足以证明 $x$ 和 $y$ 在汇合点是等价的，因此全局算法是不必要的。\n\nB. 因为副本操作使得 $p$ 和 $r$ 共享一个值编号，$q$ 和 $s$ 共享一个值编号，所以 GVN 会为 $x$ 和 $y$ 分配相同的值编号；因此，在 $B_3$ 处，$t := \\phi(x, y)$ 也会获得该值编号。\n\nC. 如果不利用 $+$ 的交换律，GVN 无法证明 $x$ 和 $y$ 是等价的，因此它们会得到不同的值编号，而 $t$ 在 $B_3$ 处会得到一个新的值编号。\n\nD. 汇合处的 $\\phi$ 函数必须总是引入一个与其操作数不同的新值编号，即使操作数共享相同的值编号，因为合并本质上是非等价的。", "solution": "用户提供了一个关于在以静态单赋值（SSA）形式表示的程序上进行全局值编号（GVN）的问题陈述。任务是验证该问题的有效性，如果有效，则推导出关于指定 GVN 算法行为的正确结论。\n\n### 步骤 1：提取已知条件\n\n- **控制流图 (CFG)**：一个钻石结构，包含一个起始块 $B_0$，两个到块 $B_1$ 和 $B_2$ 的条件分支，以及一个汇合块 $B_3$。\n- **SSA形式的程序**:\n    - **块 $B_0$**: $a := \\text{input}()$; $b := \\text{input}()$; if $\\text{cond}$ then goto $B_1$ else goto $B_2$。\n    - **块 $B_1$**: $p := a$; $q := b$; $x := p + q$; goto $B_3$。\n    - **块 $B_2$**: $r := a$; $s := b$; $y := r + s$; goto $B_3$。\n    - **块 $B_3$**: $t := \\phi(x, y)$; \\text{return } $t$。\n- **输入变量**: $a$ 和 $b$ 是输入，并且在分支之前没有被重新定义。\n- **GVN 算法规则**:\n    1.  每个值的定义都与一个值编号相关联。\n    2.  副本 $u := v$ 获得与 $v$ 相同的值编号。\n    3.  二元运算 $op(u_1, u_2)$ 获得一个仅由 $op$ 以及 $u_1$ 和 $u_2$ 的值编号决定的值编号。\n    4.  对于一个 $\\phi$ 函数，如果所有传入的操作数具有相同的值编号，则该 $\\phi$ 函数也获得相同的值编号。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述为一个程序片段和一种特定的全局值编号算法变体提供了清晰且自包含的描述。\n- **科学依据**：控制流图、静态单赋值形式、$\\phi$-函数和全局值编号等概念是编译器设计和优化理论中基础且成熟的原则。该设置为用于说明这些概念的标准教科书示例。\n- **问题适定**：该问题是适定的。程序结构被明确定义，支配算法行为的规则也已列出。这些规则足以确定性地追踪值编号在整个程序中的分配过程。通过应用这些规则可以得出一个唯一的结论。\n- **客观性**：该问题以计算机科学中常见的精确、客观和技术性语言陈述。它没有歧义、主观性和观点。\n- **结论**：该问题不违反任何无效性标准。这是一个来自编译器原理领域的有效、形式良好的问题。\n\n### 步驟 3：判定与行动\n该问题是 **有效的**。现在將通过应用给定的 GVN 规则到程序片段来继续解決问题。\n\n### 解题推导\n\n令 $\\text{VN}(v)$ 表示分配给变量 $v$ 的值编号。我们将追踪值编号在控制流图中的分配过程。\n\n1.  **块 $B_0$**：\n    - 变量 $a$ 和 $b$ 从外部输入初始化。由于它们代表可能不同的值，因此被分配不同的值编号。\n    - 设 $\\text{VN}(a) = 1$。\n    - 设 $\\text{VN}(b) = 2$。\n    - 这些值编号是“全局的”，并且对所有被支配的块（$B_1$、$B_2$ 和 $B_3$）都可用。\n\n2.  **通过块 $B_1$ 的路径**：\n    - $p := a$: 这是一个副本操作。根据 GVN 规则 2，$p$ 获得与 $a$ 相同的值编号。因此，$\\text{VN}(p) = \\text{VN}(a) = 1$。\n    - $q := b$: 这也是一个副本。根据 GVN 规则 2，$q$ 获得与 $b$ 相同的值编号。因此，$\\text{VN}(q) = \\text{VN}(b) = 2$。\n    - $x := p + q$: 这是一个二元运算。根据 GVN 规则 3，$x$ 的值编号由运算符（$+$）及其操作数（$p$ 和 $q$）的值编号决定。该值编号代表抽象值 $\\text{value}(1) + \\text{value}(2)$。\n    - 我们可以将这个复合值编号表示为 $\\text{VN}(x) = f(+, \\text{VN}(p), \\text{VN}(q)) = f(+, 1, 2)$。我们可以为此分配一个新的整数，比如 $\\text{VN}(x) = 3$。\n\n3.  **通过块 $B_2$ 的路径**：\n    - $r := a$: 一个副本操作。使用 $a$ 的全局已知值编号，$\\text{VN}(r) = \\text{VN}(a) = 1$。\n    - $s := b$: 一个副本操作。使用 $b$ 的全局已知值编号，$\\text{VN}(s) = \\text{VN}(b) = 2$。\n    - $y := r + s$: 一个二元运算。$y$ 的值编号由运算符（$+$）以及 $r$ 和 $s$ 的值编号决定。\n    - $\\text{VN}(y) = f(+, \\text{VN}(r), \\text{VN}(s)) = f(+, 1, 2)$。\n    - GVN 算法将识别出这是与 $x$ 的表达式相同的运算符和操作数值编号的组合。因此，$y$ 被分配与 $x$ 相同的值编号。\n    - $\\text{VN}(y) = \\text{VN}(x) = 3$。\n\n4.  **在块 $B_3$ 处汇合**：\n    - $t := \\phi(x, y)$: 这个 $\\phi$-函数合并了来自通过 $B_1$ 路径的 $x$ 的值和来自通过 $B_2$ 路径的 $y$ 的值。\n    - 我们已经确定 $\\text{VN}(x) = 3$ 和 $\\text{VN}(y) = 3$。\n    - 我们现在应用 GVN 规则 4：“对于一个 $\\phi$ 函数，如果所有传入的操作数具有相同的值编号，则该 $\\phi$ 函数也获得相同的值编号。”\n    - 由于 $\\phi$-函数的两个操作数 $x$ 和 $y$ 具有相同的值编号（$3$），所以分配给 $t$ 的 $\\phi$-函数的结果也获得此值编号。\n    - 因此，$\\text{VN}(t) = 3$。\n\n分析表明，GVN 成功地证明了表达式 $p+q$ 和 $r+s$ 在不同控制流路径上的等价性，并且这种等价性通过汇合点的 $\\phi$-函数传播。\n\n### 逐项分析\n\n**A. $B_1$ 和 $B_2$ 内的局部值编号足以证明 $x$ 和 $y$ 在汇合点是等价的，因此全局算法是不必要的。**\n- **分析**：局部值编号仅限于单个基本块。对 $B_1$ 的 LVN 过程将根据 $a$ 和 $b$ 的局部副本确定 $x$ 的值。一个单独的对 $B_2$ 的 LVN 过程将根据其局部副本确定 $y$ 的值。然而，LVN 无法建立 $B_1$ 中的变量与 $B_2$ 中的变量之间的关系。为了证明 $\\text{VN}(x) = \\text{VN}(y)$，算法必须知道 $\\text{VN}(p) = \\text{VN}(r)$ 和 $\\text{VN}(q) = \\text{VN}(s)$，这需要关于 $a$ 和 $b$ 的信息跨块传播。这正是*全局*算法的功能。\n- **判定**：不正确。\n\n**B. 因为副本操作使得 $p$ 和 $r$ 共享一个值编号，$q$ 和 $s$ 共享一个值编号，所以 GVN 会为 $x$ 和 $y$ 分配相同的值编号；因此，在 $B_3$ 处，$t := \\phi(x, y)$ 也会获得该值编号。**\n- **分析**：这个陈述准确地总结了推导过程。$p$ 和 $r$（都是 $a$ 的副本）的等价性以及 $q$ 和 $s$（都是 $b$ 的副本）的等价性是关键。这导致 $x$ 和 $y$ 都是将相同的操作（$+$）应用于具有相同值编号的操作数，从而得出 $\\text{VN}(x) = \\text{VN}(y)$。该陈述通过应用为 $\\phi$-函数明确说明的规则（GVN 规则 4）得出了正确的结论，即当所有操作数都等价时，结果 $t$ 会继承其操作数的值编号。\n- **判定**：正确。\n\n**C. 如果不利用 $+$ 的交换律，GVN 无法证明 $x$ 和 $y$ 是等价的，因此它们会得到不同的值编号，而 $t$ 在 $B_3$ 处会得到一个新的值编号。**\n- **分析**：如推导所示，$x$ 和 $y$ 的表达式分别是 $p+q$ 和 $r+s$。在解析副本后，就值编号而言，两个表达式都等价于 $a+b$。GVN 算法从值编号的有序对 $(\\text{VN}(p), \\text{VN}(q))$ 计算 $\\text{VN}(x)$，并从 $(\\text{VN}(r), \\text{VN}(s))$ 计算 $\\text{VN}(y)$。由于 $\\text{VN}(p) = \\text{VN}(r)$ 且 $\\text{VN}(q) = \\text{VN}(s)$，操作数值编号的有序对是相同的。不需要交换律。如果 $B_2$ 中的表达式是 $y := s + r$，那么就需要交换律，这需要算法知道 $f(+, v_1, v_2) = f(+, v_2, v_1)$。但这里不是这种情况。\n- **判定**：不正确。\n\n**D. 汇合处的 $\\phi$ 函数必须总是引入一个与其操作数不同的新值编号，即使操作数共享相同的值编号，因为合并本质上是非等价的。**\n- **分析**：这个陈述对 $\\phi$-函数做出了一个一般性声明，但这与问题陈述中提供的规则直接矛盾。GVN 规则 4 明确定义了这种情况下的行为：“如果所有传入的操作数具有相同的值编号，则该 $\\phi$ 函数也获得相同的值编号。” 我们必须遵循给定的规则。虽然可能存在不同的 GVN 实现，但此处指定的实现是在此条件下通过 $\\phi$-节点传播值编号的。\n- **判定**：不正确。", "answer": "$$\\boxed{B}$$", "id": "3681958"}, {"introduction": "优化并非总是安全的，编译器必须严格遵守语言的语义规则，尤其是处理与外部世界交互的操作时。这个练习探讨了一个关键的边界情况：`volatile` 内存访问。通过分析对一个 `volatile` 地址的连续读取，你将理解为什么编译器不能简单地将它们视为等价计算并优化掉其中一个。[@problem_id:3682025] 本练习强调了“可观察行为”和副作用在优化中的核心地位，揭示了所有优化的首要原则——正确性高于一切。", "problem": "编译器执行全局值编号 (GVN)，其核心结构是一个一致性映射 (congruence map)，该映射将应用于操作数的操作符与一个规范值编号关联起来。正确性的基础是可观察等价性的定义：一个优化是健全的，当且仅当它保持了程序的可观察行为。特别是，可能与输入/输出或外部状态交互的操作是可观察的，如果消除或合并这些操作可能改变观察结果，则绝不能这样做。此外，值编号依赖于这样一个原则：如果一个操作符是确定性的且无副作用，那么将其应用于同一同余类中的操作数，会产生位于同一同余类中的结果。\n\n考虑在一种中间表示中的以下顺序代码，其中指针 $p$ 指向一个可能映射到设备寄存器的内存位置：\n\n$x = \\mathrm{volatile}(*p)$\n\n$y = \\mathrm{volatile}(*p)$\n\n$z = x + y$\n\n假设程序文本中恰好有 $2$ 次 `volatile` 加载，并且没有对 $*p$ 的显式写入，同时假设目标语言规定，一次 $\\mathrm{volatile}$ 加载具有可观察行为，并且即使地址和程序可见的内存状态未改变，连续读取也可能产生不同的值。GVN 的实现使用一个一致性映射，该映射以操作符签名及其操作数的值编号为键。该映射既用于检测也用于创建等价类。\n\n以下哪个陈述最能描述在值编号中对 $\\mathrm{volatile}$ 加载的健全处理方法，以及应如何在一致性映射中表示易变性？\n\nA. 因为在 $x = \\mathrm{volatile}(*p)$ 和 $y = \\mathrm{volatile}(*p)$ 中操作符和操作数在文本上是相同的，所以 $x$ 和 $y$ 必须被置于同一同余类中；编译器可以用 $x$ 替换 $y$。\n\nB. `volatile` 加载必须被视为即使操作数相同也会产生新的、不可等同的值。在一致性映射中用一个易变性标签扩展操作符签名，确保每次 `volatile` 加载都产生一个唯一的值编号，从而防止与在相同地址上的任何其他 `volatile` 加载发生基于查找的等价。\n\nC. 只要程序文本中没有对 $*p$ 的介入性写入，就可以将 $x$ 和 $y$ 等同起来，因为程序可见的内存状态没有改变。\n\nD. 如果别名分析证明 $p$ 指向一个无别名区域，那么 $x$ 和 $y$ 就可以被等同起来；易变性只在存在别名时才重要。\n\nE. 在值编号中将 `volatile` 加载建模为 $p$ 的纯函数，但为每个基本块分配一个单一的唯一值编号以限制优化范围。", "solution": "用户希望我分析一个关于编译器中全局值编号 (GVN) 及其与 `volatile` 内存访问交互的问题。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- 一个优化是健全的，当且仅当它保持了程序的可观察行为。\n- 与输入/输出或外部状态交互的操作是可观察的。\n- 一个确定性且无副作用的操作符，当应用于同一同余类中的操作数时，其产生的结果也在同一同余类中。\n- 代码段是：\n  $x = \\mathrm{volatile}(*p)$\n  $y = \\mathrm{volatile}(*p)$\n  $z = x + y$\n- $p$ 是一个指向可能为设备寄存器的内存位置的指针。\n- 程序文本中恰好有 2 次 `volatile` 加载，没有对 $*p$ 的显式写入。\n- 一次 `volatile` 加载具有可观察行为。\n- 即使地址和程序可见的内存状态未改变，连续的 `volatile` 加载也可能产生不同的值。\n- GVN 使用一个以操作符签名和操作数值编号为键的一致性映射。\n\n**第2步：使用提取的已知条件进行验证**\n该问题陈述在科学上基于编译器构造的原理，特别是程序优化和中间表示。全局值编号、可观察等价性以及 `volatile` 关键字的语义是计算机科学和系统编程（例如，在 C 和 C++ 等语言中）的标准主题。问题提取得很好，要求在标准优化框架 (GVN) 内对一个特定情况（`volatile` 加载）进行健全的处理。语言客观而精确。前提条件是一致的，并提供了足够的信息来确定正确的方法。该问题不违反任何无效性标准。\n\n**第3步：结论与行动**\n该问题是**有效的**。我将继续进行解决方案推导和选项分析。\n\n### 解决方案推导\n\n任何编译器优化正确性的核心原则是保持程序的可观察行为。问题陈述明确定义了一次 `volatile` 加载具有可观察行为。它还指出，从同一地址 `*p` 进行的两次连续 `volatile` 加载可能会产生不同的值。\n\n我们来分析一下代码：\n$1. \\ x = \\mathrm{volatile}(*p)$\n$2. \\ y = \\mathrm{volatile}(*p)$\n$3. \\ z = x + y$\n\n`volatile` 访问的基本特性是它必须严格按照其在源代码中出现的方式执行。编译器被禁止相对于其他 `volatile` 访问重新排序 `volatile` 访问，也禁止将其优化掉。在这种情况下，程序语义要求在内存位置 `*p` 处发生两次不同的读取操作。第一次读取的结果存储在 $x$ 中，第二次读取的结果存储在 $y$ 中。\n\n全局值编号 (GVN) 是一种优化技术，用于识别保证计算出相同值的表达式。如果它找到两个这样的表达式，它可以用第一个结果的简单副本来替换第二个计算。例如，如果编译器确定 `a op b` 和 `c op d` 是等价的（即 `op` 相同，且 `a` 和 `c` 的值编号、`b` 和 `d` 的值编号分别相等），它将为这两个表达式的结果分配相同的值编号。\n\n让我们将此应用于给定的问题。这两个操作是 `volatile(*p)`。操作符是 `volatile load`，操作数是地址 `p`。对于这两个指令，`p` 的值编号是相同的。一个天真实现的 GVN 会为其一致性映射使用一个像 `` `(VOLATILE_LOAD, value_number(p))` `` 这样的键。当遇到第一条指令 $x = \\mathrm{volatile}(*p)$ 时，它会为 $x$ 创建一个新的值编号，比如 $v_1$，并存储映射 `` `(VOLATILE_LOAD, value_number(p)) -> v_1` ``。当遇到第二条指令 $y = \\mathrm{volatile}(*p)$ 时，它会查找相同的键 `` `(VOLATILE_LOAD, value_number(p))` ``，找到已存在的值编号 $v_1$，并将其赋给 $y$。这将意味着 $x$ 和 $y$ 是等价的，允许编译器将代码转换为：\n\n$1. \\ x = \\mathrm{volatile}(*p)$\n$2. \\ y = x$\n$3. \\ z = x + y$\n\n这种转换用一次寄存器复制替换了第二次 `volatile` 加载，将对 `volatile` 位置 `*p` 的读取次数从两次减少到一次。然而，问题陈述指出，`volatile` 加载是一种可观察行为，并且连续读取可能会产生不同的值。假设第一次读取产生 $v_{read1}$，第二次读取产生 $v_{read2}$，其中 $v_{read1} \\neq v_{read2}$。原始程序将计算 $z = v_{read1} + v_{read2}$。优化后的程序将计算 $z = v_{read1} + v_{read1}$。这些结果是不同的，意味着优化改变了程序的可观察行为。这是一个不健全的转换。\n\n因此，一个健全的 GVN 实现必须将每次 `volatile` 加载视为产生一个新的、唯一的值，该值不能与任何其他值等同，即使是由文本上相同的 `volatile` 加载产生的值也不行。为实现这一点，GVN 机制必须确保对 `volatile` 加载的一致性映射查找永远不会因先前的 `volatile` 加载而成功。这意味着每次 `volatile` 加载都必须为映射生成一个唯一的键，或者 `volatile` 加载必须完全绕过查找机制，总是生成一个新的值编号。\n\n### 逐项分析选项\n\n**A. 因为在 $x = \\mathrm{volatile}(*p)$ 和 $y = \\mathrm{volatile}(*p)$ 中操作符和操作数在文本上是相同的，所以 $x$ 和 $y$ 必须被置于同一同余类中；编译器可以用 $x$ 替换 $y$。**\n这个陈述描述了一种不健全的优化。如上所述，将 $x$ 和 $y$ 等同起来并消除第二次 `volatile` 加载违反了 `volatile` 的语义并改变了程序的可观察行为。由于 `volatile` 限定符的存在，操作的文本相同性是无关紧要的。\n结论：**不正确**。\n\n**B. `volatile` 加载必须被视为即使操作数相同也会产生新的、不可等同的值。在一致性映射中用一个易变性标签扩展操作符签名，确保每次 `volatile` 加载都产生一个唯一的值编号，从而防止与在相同地址上的任何其他 `volatile` 加载发生基于查找的等价。**\n这个陈述正确地指出了对 `volatile` 加载的必要处理方法。它们必须总是产生一个新的值编号。所提出的实现策略——为每次 `volatile` 加载使用一个唯一的标签来扩展操作符签名——是实现这一目标的健全方法。例如，第一次加载的一致性映射键可以是 `` `(LOAD, vn(p), id_1)` ``，第二次加载的键可以是 `` `(LOAD, vn(p), id_2)` ``，其中 `id_1 != id_2`。这将防止第二次加载在映射中“命中”，从而强制为 $y$ 创建一个新的、不同的值编号。这保留了两次独立的、可观察的加载操作。\n结论：**正确**。\n\n**C. 只要程序文本中没有对 $*p$ 的介入性写入，就可以将 $x$ 和 $y$ 等同起来，因为程序可见的内存状态没有改变。**\n这个陈述从根本上误解了 `volatile`。`volatile` 的目的是为了表明内存位置可以被当前程序线程的控制和可见范围之外的方式（例如，硬件、中断服务例程、另一个线程）改变。在程序代码中没有写入操作不足以保证该值是稳定的。因此，将 $x$ 和 $y$ 等同起来是不安全的。\n结论：**不正确**。\n\n**D. 如果别名分析证明 $p$ 指向一个无别名区域，那么 $x$ 和 $y$ 就可以被等同起来；易变性只在存在别名时才重要。**\n这个陈述错误地将别名与易变性混为一谈。别名分析确定多个指针是否可以引用同一内存位置。易变性是关于内存位置的值是否会不可预测地改变。这些是正交的概念。一个 `volatile` 内存位置即使没有别名也必须小心处理，因为它的值仍然可以被外部代理修改。$p$ 的无别名状态并不能使其消除 `volatile` 加载变得安全。\n结论：**不正确**。\n\n**E. 在值编号中将 `volatile` 加载建模为 $p$ 的纯函数，但为每个基本块分配一个单一的唯一值编号以限制优化范围。**\n这个陈述内部矛盾且不正确。将 `volatile` 加载建模为纯函数与其真实语义完全相反。纯函数是确定性的且无副作用的，而 `volatile` 加载（从编译器的角度看）是非确定性的，并且具有可观察的副作用（读取本身）。此外，每个基本块分配一个单一的唯一值编号仍然会错误地将同一基本块内的两次 `volatile` 加载（如问题中的 `x` 和 `y`）等同起来，导致与选项 A 中描述的相同的不健全优化。\n结论：**不正确**。", "answer": "$$\\boxed{B}$$", "id": "3682025"}]}