{"hands_on_practices": [{"introduction": "强度削减的一个典型应用是将高开销的乘法运算替换为一系列计算开销更低的移位和加法运算。这个练习将引导你通过一个具体的例子，比较两种不同的转换策略：一种是基于常数二进制表示的直接方法，另一种是利用因子分解的更优方法。通过这个练习[@problem_id:3672269]，你将亲身体会到编译器在生成高效代码时所做的权衡与决策，并加深对指令成本模型的理解。", "problem": "一个编译器执行强度削减，通过将与一个正的编译时常数相乘的操作替换为一系列左移和加法操作。考虑一个具有以下成本模型的目标平台：每次左移一位的成本为 $s$ 个单位，每次两个先前计算出的值相加的成本为 $a$ 个单位。假设初始值 $x$ 已存于寄存器中，成本为零，并且不允许使用减法。左移运算符 $x \\ll k$ 表示值 $2^{k} x$。\n\n你将对三个常数 $c \\in \\{\\,45,\\,75,\\,119\\,\\}$，比较计算 $c x$ 的两种策略：\n\n- 二进制分解策略：推导一个操作序列，首先通过对 $x$ 进行左移来构建所有2的幂的倍数 $2^{i} x$（其中 $0 \\le i \\le \\lfloor \\log_{2}(c) \\rfloor$），然后使用加法将对应于 $c$ 的二进制展开中为1的比特位的子集求和。从基本原理（二进制表示和操作计数）推导该策略的总成本。\n\n- 最小加法链策略：推导一个移位-加法序列，通过重用中间结果、在有利时对 $c$ 进行因式分解以及策略性地应用左移来最小化加法总数。利用二进制表示的基本性质（例如，非2的幂的常数至少需要一次加法）以及在不允许减法的情况下形成所需的非2的幂的中间结果的必要性来证明其最小性。\n\n使用具体成本参数 $s = 1$ 和 $a = 2$。对于每个常数 $c$，计算二进制分解策略的成本和你的最小加法链策略的成本，并报告该 $c$ 的节省成本，即二者之差（二进制分解策略成本减去最小加法链策略成本）。最后，将所有三个常数的节省成本相加，并提供这个单一数字作为你的最终答案。将最终节省的成本表示为原始成本计数（无量纲）。无需四舍五入。", "solution": "题目要求在给定的操作成本模型下，对三个不同的常数 $c$ 计算 $c x$ 时，使用最小加法链策略相对于二进制分解策略所实现的总节省成本。\n\n首先，我们来形式化地定义成本模型和两种策略。\n\n**成本模型：**\n-   左移一位的成本为 $s$。题目指定 $s=1$。\n-   两个先前计算出的值相加的成本为 $a$。题目指定 $a=2$。\n-   初始值 $x$ 可用，成本为零。\n-   不允许使用减法。\n-   操作 $y \\ll k$ 计算 $2^k y$。题目说明“每次左移一位的成本为 $s$ 个单位”，这意味着操作 $y \\ll k$ 是作为 $k$ 次连续的单比特移位实现的。我们必须假设这些移位操作作用于值 $y$，如果 $y$ 是一个中间结果，那么这些移位不一定能从对 $x$ 的移位链接而来。因此，$y \\ll k$ 的成本是 $k \\times s$。当 $s=1$ 时，成本为 $k$。\n\n**策略1：二进制分解策略**\n设 $c$ 为正整数常数。设其二进制表示为 $c = \\sum_{i=0}^{m} b_i 2^i$，其中 $m = \\lfloor \\log_{2}(c) \\rfloor$ 且 $b_i \\in \\{0, 1\\}$。\n该策略分两个阶段定义：\n1.  **构造2的幂**：“构建所有2的幂的倍数 $2^i x$（其中 $0 \\le i \\le m$）”。最高效的方法是按顺序进行：\n    -   $v_0 = x$ (成本 $0$)\n    -   $v_1 = v_0 \\ll 1 = 2x$ (成本 $s$)\n    -   $v_2 = v_1 \\ll 1 = 4x$ (成本 $s$)\n    -   ...\n    -   $v_m = v_{m-1} \\ll 1 = 2^m x$ (成本 $s$)\n    这会生成所有必需的幂 $\\{2^1 x, 2^2 x, \\dots, 2^m x\\}$。此阶段的总成本为 $m \\times s$。\n2.  **求和**：将对应于 $c$ 的二进制展开中为1的比特位的 $\\{2^i x\\}$ 子集求和。设 $b(c)$ 为 $c$ 的二进制表示中1比特位的数量（也称为汉明权重或置位数）。我们需要对 $b(c)$ 个项求和。对 $k$ 个项求和需要 $k-1$ 次加法。此阶段的成本为 $(b(c) - 1) \\times a$。\n\n二进制分解策略的总成本 $C_B(c)$ 为：\n$$C_B(c) = m \\times s + (b(c) - 1) \\times a$$\n当 $s=1$ 且 $a=2$ 时：\n$$C_B(c) = \\lfloor \\log_{2}(c) \\rfloor + 2(b(c) - 1)$$\n\n**策略2：最小加法链策略**\n该策略旨在通过重用中间结果并利用 $c$ 的数论性质（如因式分解），找到计算 $c x$ 的最佳移位和加法序列。目标是找到一个序列，使其总成本 $C_M(c)$ 最小。我们必须证明所找到序列的最小性。与一个非2的幂的常数相乘必须至少涉及一次加法。\n\n我们现在分析每个常数 $c \\in \\{45, 75, 119\\}$。\n\n**情况1：$c = 45$**\n\n1.  **二进制分解成本 ($C_B(45)$)**：\n    -   $45$ 的二进制表示是 $101101_2$。\n    -   $45 = 32 + 8 + 4 + 1 = 2^5 + 2^3 + 2^2 + 2^0$。\n    -   $m = \\lfloor \\log_{2}(45) \\rfloor = 5$。\n    -   1比特位的数量为 $b(45) = 4$。\n    -   $C_B(45) = m \\cdot s + (b(45)-1) \\cdot a = 5 \\cdot 1 + (4-1) \\cdot 2 = 5 + 6 = 11$。\n\n2.  **最小加法链成本 ($C_M(45)$)**：\n    -   我们可以将 $45$ 因式分解为 $45 = 5 \\times 9$。这表明可以先计算 $5x$，然后将结果乘以 $9$。\n    -   计算 $y = 5x$：$y = x + 4x = x + (x \\ll 2)$。\n        -   `t1 = x  2` (成本 $2s=2$)\n        -   `y = x + t1` (成本 $a=2$)\n        -   计算 $5x$ 的成本是 $2s+a = 4$。\n    -   计算 $45x = 9y$：$9y = y + 8y = y + (y \\ll 3)$。\n        -   `t2 = y  3` (成本 $3s=3$)\n        -   `res = y + t2` (成本 $a=2$)\n        -   从 $y$ 计算 $9y$ 的成本是 $3s+a = 5$。\n    -   总成本是每步成本之和：$C_M(45) = (2s+a) + (3s+a) = 5s+2a = 5(1)+2(2) = 9$。\n    -   **最小性证明**：要生成一个非2的幂的倍数，至少需要一次加法。$45$ 不是两个2的幂的和，所以如果我们只将 $x$ 的移位版本相加，一次加法是不够的。一个包含两次加法的序列，比如我们找到的这个，是最小性的一个候选。其成本为 $9$。另一种因式分解 $45 = 3 \\times 15$ 会导致成本为 $10$。其他组合方式，如 $45x=32x+13x$，被证明成本更高。成本 $9$ 来自于两次加法和总共 $5$ 次单比特移位。这比二进制策略的成本 $11$ 有所改进，并且广泛的搜索证实了其最优性。\n\n3.  **$c=45$ 的节省成本**：\n    -   节省成本$(45) = C_B(45) - C_M(45) = 11 - 9 = 2$。\n\n**情况2：$c = 75$**\n\n1.  **二进制分解成本 ($C_B(75)$)**：\n    -   $75$ 的二进制表示是 $1001011_2$。\n    -   $75 = 64 + 8 + 2 + 1 = 2^6 + 2^3 + 2^1 + 2^0$。\n    -   $m = \\lfloor \\log_{2}(75) \\rfloor = 6$。\n    -   1比特位的数量为 $b(75) = 4$。\n    -   $C_B(75) = m \\cdot s + (b(75)-1) \\cdot a = 6 \\cdot 1 + (4-1) \\cdot 2 = 6 + 6 = 12$。\n\n2.  **最小加法链成本 ($C_M(75)$)**：\n    -   我们将 $75$ 因式分解为 $75 = 3 \\times 25 = 3 \\times 5 \\times 5$。\n    -   计算 $y = 3x$：$y = x + (x \\ll 1)$。\n        -   成本：$s+a=1+2=3$。\n    -   计算 $z = 5y$：$z = y + (y \\ll 2)$。\n        -   从 $y$ 开始的成本：$2s+a=2+2=4$。\n    -   计算 $75x = 5z$：$5z = z + (z \\ll 2)$。\n        -   从 $z$ 开始的成本：$2s+a=2+2=4$。\n    -   总成本是每步成本之和：$C_M(75) = (s+a) + (2s+a) + (2s+a) = 5s + 3a = 5(1) + 3(2) = 11$。\n    -   **最小性证明**：该计算涉及三次加法。总移位成本为 $1s+2s+2s=5s$。总成本为 $11$。这比二进制成本 $12$ 要好。任何与形如 $2^k+1$ 的奇数（如 $3=2^1+1$ 和 $5=2^2+1$）相乘的操作都可以通过一次加法完成。由于 $75=3 \\times 5 \\times 5$，三次加法似乎是最小的。其他分解方式，如 $75x = 15x + (15x \\ll 2)$，也导致成本为 $11$。成本 $11$ 似乎是最小的。\n\n3.  **$c=75$ 的节省成本**：\n    -   节省成本$(75) = C_B(75) - C_M(75) = 12 - 11 = 1$。\n\n**情况3：$c = 119$**\n\n1.  **二进制分解成本 ($C_B(119)$)**：\n    -   $119$ 的二进制表示是 $1110111_2$。\n    -   $119 = 64 + 32 + 16 + 4 + 2 + 1 = 2^6+2^5+2^4+2^2+2^1+2^0$。\n    -   $m = \\lfloor \\log_{2}(119) \\rfloor = 6$。\n    -   1比特位的数量为 $b(119) = 6$。\n    -   $C_B(119) = m \\cdot s + (b(119)-1) \\cdot a = 6 \\cdot 1 + (6-1) \\cdot 2 = 6 + 10 = 16$。\n\n2.  **最小加法链成本 ($C_M(119)$)**：\n    -   我们将 $119$ 因式分解为 $119 = 7 \\times 17$。\n    -   计算 $y=7x$。由于不允许减法，$7x=8x-x$ 不是一个选项。我们可以使用 $7x = x+6x = x+(3x \\ll 1)$。\n        -   计算 $3x$：$x + (x \\ll 1)$。成本 $s+a=3$。\n        -   从 $3x$ 计算 $7x$：$y = x + ((x+(x \\ll 1)) \\ll 1)$。这可以分步进行：\n            1. `t1 = x  1` (成本 `s=1`)\n            2. `t2 = x + t1` (`3x`) (成本 `a=2`)\n            3. `t3 = t2  1` (`6x`) (成本 `s=1`)\n            4. `y = x + t3` (`7x`) (成本 `a=2`)\n        -   计算 $7x$ 的成本为 $2s+2a = 2+4=6$。\n    -   计算 $119x = 17y$：$17y = y + 16y = y + (y \\ll 4)$。\n        -   从 $y$ 开始的成本：$4s+a=4+2=6$。\n    -   总成本：$C_M(119) = (\\text{计算 } 7x \\text{ 的成本}) + (\\text{计算 } 17y \\text{ 的成本}) = (2s+2a)+(4s+a) = 6s+3a = 6(1)+3(2) = 12$。\n    -   **最小性证明**：这个序列使用了 $3$ 次加法和总共 $6$ 次单比特移位。成本为 $12$，比 $16$ 节省了显著的成本。常数 $7$ 不能通过一次加法构成，至少需要两次。常数 $17$ 的形式是 $2^4+1$，需要一次加法。因此，基于因式分解 $7 \\times 17$ 的序列至少需要 $2+1=3$ 次加法。我们的方法使用了 $3$ 次加法，因此在加法次数上是最小的。总成本 $12$ 是最小的。\n\n3.  **$c=119$ 的节省成本**：\n    -   节省成本$(119) = C_B(119) - C_M(119) = 16 - 12 = 4$。\n\n**总节省成本**\n总节省成本是每个常数的节省成本之和：\n总节省成本 = 节省成本$(45) +$ 节省成本$(75) +$ 节省成本$(119)$\n总节省成本 = $2 + 1 + 4 = 7$。", "answer": "$$\\boxed{7}$$", "id": "3672269"}, {"introduction": "在现代处理器上，整数除法的开销远高于乘法，因此将常量除法替换为乘法和移位是一种非常有效的强度削减。然而，这种转换并非显而易见，它需要找到一个精确的“魔数”（magic number）和一个移位数，以保证在有限精度整数运算下结果的等价性。这个练习[@problem_id:3672258]将带你从第一性原理出发，推导这些关键参数，并证明其在整个无符号整数范围内的正确性，揭示这一高级优化技巧背后的数学原理。", "problem": "您正在一个 $32$ 位架构的系统程序中优化一个循环，其中所有整数值都表示为 $32$ 位无符号整数。该循环重复计算无符号整数商 $y = \\left\\lfloor x / 10 \\right\\rfloor$，其中 $x \\in \\{0,1,\\dots,2^{32}-1\\}$。为了降低成本，您考虑进行强度削减：将编译时常数除法替换为预计算常数乘法和右移。乘法在 $64$ 位累加器中执行，以便在移位前获得完整的 $64$ 位乘积。\n\n任务：\n- 精确说明变换\n$$\n\\left\\lfloor \\frac{x}{10} \\right\\rfloor \\;\\;\\text{替换为}\\;\\; \\left\\lfloor \\frac{x\\cdot M}{2^{s}} \\right\\rfloor\n$$\n何时可以安全使用，以及在真实的中央处理器（CPU）上通常何时是有益的。\n- 从第一性原理出发，推导最小的位移 $s \\in \\mathbb{N}$ 和相应的整数乘数 $M \\in \\mathbb{N}$，使得对于所有 $x \\in \\{0,1,\\dots,2^{32}-1\\}$，\n$$\n\\left\\lfloor \\frac{x}{10} \\right\\rfloor \\;=\\; \\left\\lfloor \\frac{x\\cdot M}{2^{s}} \\right\\rfloor,\n$$\n成立，假设中间乘积 $x\\cdot M$ 为 $64$ 位，并进行 $s$ 位的逻辑右移。\n- 通过建立与 $x$ 无关的界限来证明其正确性，从而对范围内的所有 $x$ 暗示上述等式成立。证明过程仅从关于商-余数分解 $x = 10q + r$（其中 $q = \\left\\lfloor x/10 \\right\\rfloor$ 且 $r \\in \\{0,1,\\dots,9\\}$）的基本事实以及向下取整函数的性质出发。\n\n将您的最终答案报告为序偶 $(M,s)$。不允许使用代码。您的最终数值答案必须是精确的；不需要四舍五入。", "solution": "该问题要求分析强度削减优化，该优化将常数无符号整数除法（特别是 $\\left\\lfloor x/10 \\right\\rfloor$）替换为与常数 $M$ 相乘并右移 $s$ 位。$x$ 的定义域是 $32$ 位无符号整数集 $\\{0, 1, \\dots, 2^{32}-1\\}$。\n\n首先，我们讨论这种变换在什么条件下是安全和有益的。\n安全性要求满足两个条件：\n1.  数学正确性：等式 $\\left\\lfloor \\frac{x}{10} \\right\\rfloor = \\left\\lfloor \\frac{x\\cdot M}{2^{s}} \\right\\rfloor$ 必须对每个 $x \\in \\{0, 1, \\dots, 2^{32}-1\\}$ 都成立。\n2.  实现正确性：中间乘积 $x \\cdot M$ 不得溢出指定的 $64$ 位累加器。由于 $x  2^{32}$，如果我们选择一个也能放入 $32$ 位字长的乘数 $M$（即 $M  2^{32}$），则乘积 $x \\cdot M$ 将小于 $2^{32} \\cdot 2^{32} = 2^{64}$，从而可以容纳在一个 $64$ 位无符号整数中。我们的推导将得出这样一个 $M$。\n\n在中央处理器（CPU）上，如果乘法和移位的总执行时间小于除法的执行时间，则此变换是有益的。对于几乎所有现代处理器架构，整数除法都是比整数乘法和位移操作开销大得多（在延迟和吞吐量方面）的操作。例如，一个硬件除法操作可能需要几十个时钟周期，而乘法通常可以在单个周期内完成或者被深度流水线化。因此，这种强度削减几乎总是有利于性能。\n\n接下来，我们推导最小的位移 $s \\in \\mathbb{N}$ 和相应的乘数 $M \\in \\mathbb{N}$。\n目标是找到整数常数 $M$ 和 $s$，使得对于所有 $x \\in \\{0, 1, \\dots, 2^{32}-1\\}$：\n$$ \\left\\lfloor \\frac{x}{10} \\right\\rfloor = \\left\\lfloor \\frac{x \\cdot M}{2^s} \\right\\rfloor $$\n令 $q = \\left\\lfloor \\frac{x}{10} \\right\\rfloor$。该等式成立当且仅当对所有 $x$ 满足以下条件：\n$$ q \\le \\frac{x \\cdot M}{2^s}  q+1 $$\n我们希望比率 $\\frac{M}{2^s}$ 是 $\\frac{1}{10}$ 的一个良好近似。由于整数除法会截断，我们应该从上方逼近。让我们设 $\\frac{M}{2^s} = \\frac{1}{10} + \\epsilon$，其中 $\\epsilon$ 为某个小的正误差。\n这可以写成 $M = \\frac{2^s}{10} + \\epsilon \\cdot 2^s$。为了使 $M$ 为整数，我们可以写成 $10M = 2^s + k$，其中 $k = 10 \\cdot \\epsilon \\cdot 2^s$ 必须是一个正整数。这意味着 $10M > 2^s$。\n\n让我们分析来自 $q \\le \\frac{x \\cdot M}{2^s}  q+1$ 的两个不等式。\n根据问题陈述，我们使用商-余数分解 $x = 10q+r$，其中 $r \\in \\{0, 1, \\dots, 9\\}$。\n\n1.  左不等式：$q \\le \\frac{xM}{2^s}$。\n    代入 $x=10q+r$ 和 $M=(2^s+k)/10$：\n    $$ q \\le \\frac{(10q+r)(2^s+k)}{10 \\cdot 2^s} $$\n    $$ 10q \\cdot 2^s \\le (10q+r)(2^s+k) = 10q \\cdot 2^s + 10qk + r \\cdot 2^s + rk $$\n    $$ 0 \\le 10qk + r(2^s+k) $$\n    由于 $q \\ge 0$，$r \\ge 0$，$s \\in \\mathbb{N}$，并且我们寻求 $k$ 为一个正整数，所以这个不等式总是成立的。\n\n2.  右不等式：$\\frac{xM}{2^s}  q+1$。\n    $$ \\frac{(10q+r)(2^s+k)}{10 \\cdot 2^s}  q+1 $$\n    $$ (q + \\frac{r}{10}) (1 + \\frac{k}{2^s})  q+1 $$\n    $$ q + \\frac{qk}{2^s} + \\frac{r}{10} + \\frac{rk}{10 \\cdot 2^s}  q+1 $$\n    $$ \\frac{qk}{2^s} + \\frac{r}{10} + \\frac{rk}{10 \\cdot 2^s}  1 $$\n    两边乘以 $10 \\cdot 2^s$ 以消去分母：\n    $$ 10qk + r \\cdot 2^s + rk  10 \\cdot 2^s $$\n    $$ k(10q+r)  (10-r) \\cdot 2^s $$\n    $$ kx  (10-r) \\cdot 2^s $$\n    这个不等式必须对所有 $x \\in \\{0, 1, \\dots, 2^{32}-1\\}$ 成立，其中 $r = x \\pmod{10}$。\n    左侧 $kx$ 随 $x$ 增加而增加。右側 $(10-r) \\cdot 2^s$ 取决于 $r$。为了确保这对所有 $x$ 都成立，我们可以建立一个充分条件。由于 $x  2^{32}$，一个充分条件是对所有 $r \\in \\{0, \\dots, 9\\}$ 都有 $k \\cdot 2^{32} \\le (10-r) \\cdot 2^s$。右侧在 $r$ 最大化时最小，即 $r=9$。这给出了最严格的条件：\n    $$ k \\cdot 2^{32} \\le (10-9) \\cdot 2^s = 2^s $$\n    $$ k \\le 2^{s-32} $$\n    由于 $k$ 必须是正整数，这意味着 $1 \\le k \\le 2^{s-32}$，这要求 $s-32 \\ge 0$，因此 $s \\ge 32$。\n\n    我们还有约束条件 $10M = 2^s+k$，意味着 $2^s+k$ 必须能被 $10$ 整除。这等价于 $2^s+k \\equiv 0 \\pmod{10}$。\n    我们需要找到最小的整数 $s \\ge 32$，使得存在一个整数 $k \\ge 1$ 同时满足这两个条件。\n    让我们从 $32$ 开始测试 $s$ 的值：\n    - 对于 $s=32$：$2^{32} \\pmod{10}$。$2$ 的幂对 $10$ 取模的周期为 $(2, 4, 8, 6)$（指数分别为 $(1, 2, 3, 4)$），然后重复。因为 $32$是 $4$ 的倍数，所以 $2^{32} \\equiv 6 \\pmod{10}$。条件 $2^{32}+k \\equiv 0 \\pmod{10}$ 变为 $6+k \\equiv 0 \\pmod{10}$，所以最小的正整数 $k$ 是 $4$。现在我们检查 $k \\le 2^{s-32}$：$4 \\le 2^{32-32} = 2^0 = 1$。这是错误的。所以 $s=32$ 不是一个解。\n    - 对于 $s=33$：$2^{33} \\equiv 2 \\pmod{10}$。我们需要 $2+k \\equiv 0 \\pmod{10}$，所以最小的 $k$ 是 $8$。检查：$8 \\le 2^{33-32} = 2^1 = 2$。错误。\n    - 对于 $s=34$：$2^{34} \\equiv 4 \\pmod{10}$。我们需要 $4+k \\equiv 0 \\pmod{10}$，所以最小的 $k$ 是 $6$。检查：$6 \\le 2^{34-32} = 2^2 = 4$。错误。\n    - 对于 $s=35$：$2^{35} \\equiv 8 \\pmod{10}$。我们需要 $8+k \\equiv 0 \\pmod{10}$，所以最小的 $k$ 是 $2$。检查：$2 \\le 2^{35-32} = 2^3 = 8$。这是正确的。\n\n    因此，最小的整数位移是 $s=35$。相应的乘数 $M$ 用 $k=2$ 求得：\n    $$ 10M = 2^{35} + 2 $$\n    $$ M = \\frac{2^{35} + 2}{10} = \\frac{34359738368 + 2}{10} = \\frac{34359738370}{10} = 3435973837 $$\n    这个 $M$ 的值小于 $2^{32}-1=4294967295$，所以它可以装入一个 $32$ 位无符号整数寄存器中。\n\n最后，我们证明序偶 $(M, s)=(3435973837, 35)$ 的正确性。\n我们必须验证对于所有 $x \\in \\{0, \\dots, 2^{32}-1\\}$，条件 $kx  (10-r)2^s$ 在 $k=2, s=35, r=x\\pmod{10}$ 时成立。该条件是 $2x  (10-r)2^{35}$。\n对于给定的 $r \\in \\{0, \\dots, 9\\}$，不等式对于具有该余数的最大 $x$ 值 $x_{max, r}$ 是最受限制的。右侧对于 $r=9$ 是最小的。所以需要检查的总体最坏情况是 $r=9$：\n$$ 2 \\cdot x  (10-9) \\cdot 2^{35} = 2^{35} $$\n$$ x  2^{34} $$\n最大的 $32$ 位无符号整数是 $2^{32}-1$。由于 $x_{max} = 2^{32}-1  2^{34}$，该条件对所有 $x$ 都成立。\n\n我们还必须验证中间乘积 $x \\cdot M$ 不超过 $64$ 位容量，即 $x \\cdot M  2^{64}$。当 $x_{max} = 2^{32}-1$ 时，乘积最大。\n$$ (2^{32}-1) \\cdot M = (2^{32}-1) \\cdot \\frac{2^{35}+2}{10} $$\n我们需要证明这小于 $2^{64}$。\n$$ (2^{32}-1)(2^{35}+2)  10 \\cdot 2^{64} $$\n$$ 2^{67} + 2 \\cdot 2^{32} - 2^{35} - 2  10 \\cdot 2^{64} $$\n$$ 8 \\cdot 2^{64} + 2^{33} - 2^{35} - 2  10 \\cdot 2^{64} $$\n$$ 8 \\cdot 2^{64} - 7 \\cdot 2^{32} - 2  10 \\cdot 2^{64} $$\n这简化为 $-7 \\cdot 2^{32} - 2  2 \\cdot 2^{64}$，这显然是正确的。\n中间乘積不会溢出。该变换是安全且正确的。\n\n推导出的值为 $M=3435973837$ 和 $s=35$。", "answer": "$$\\boxed{(3435973837, 35)}$$", "id": "3672258"}, {"introduction": "任何优化都必须以保持程序原始语义为前提，强度削减也不例外。一个看似简单和数学上合理的替换，可能会因为编程语言的特定语义规则而变得不再安全。本练习[@problem_id:3672310]通过分析一个常见的优化（用位与运算 `` 代替对2的幂的模运算 `%`），探讨了有符号整数、负数处理以及不同语言（如C、Java和Python）对求余运算符的不同定义如何影响优化的正确性。这有助于培养在进行底层优化时对语言规范保持警惕的严谨思维。", "problem": "一位编译器设计者考虑进行一项强度削减优化，在一个紧凑循环中用按位掩码 $i \\  \\ 7$ 替换计算 $i \\% 8$，以避免除法运算。请判断在哪些语言和符号性条件下，这种替换能够保持程序语义。请以基本定义为出发点：在数学中，对于任意整数 $i$ 和正模数 $m$，余数 $r$ 是满足 $0 \\le r  m$ 且 $i \\equiv r \\pmod{m}$ 的唯一整数；在主流编程语言中，取余运算符的定义可能基于截断除法或向下取整除法，这会影响 $r$ 的符号。同时，回想一下，对于二进制表示，用 $2^k - 1$ 进行掩码操作可以提取表示的低 $k$ 位。分析这些定义与符号性以及语言的整数语义之间的相互作用。选择所有正确的陈述。\n\nA. 在 C (自 C99 起) 和 C++ (自 C++11 起) 中，用 $i \\  \\ 7$ 替换 $i \\% 8$ 对于所有整型类型（包括负值）都是安全的，因为这两个操作都是在二补数表示上定义的。\n\nB. 在 C 和 C++ 中，如果 $i$ 是无符号类型，或者 $i$ 是有符号类型且在运行时已知 $i \\ge 0$，那么用 $i \\  \\ 7$ 替换 $i \\% 8$ 是安全的。\n\nC. 在 Java (运行于 Java 虚拟机 (JVM) 上) 中，对于负数 $i$，该替换是不安全的，因为 $i \\% 8$ 可能为负，而 $i \\  \\ 7$ 的结果总是在 $[0,7]$ 范围内。\n\nD. 在 Python 中，替换 $i \\% 8 \\to i \\  \\ 7$ 对所有整数都是安全的，因为 Python 将 $i \\% 8$ 定义为满足 $0 \\le r  8$ 和 $i \\equiv r \\pmod{8}$ 的唯一 $r$，这与低 3 位 $i \\  \\ 7$ 的值相等。\n\nE. 在 C 和 C++ 中，当 $i$ 是一个负的有符号整数时，计算 $i \\  \\ 7$ 会触发未定义行为 (UB)，这就是为什么在这些情况下替换是不安全的。", "solution": "该问题要求分析编译器优化 `i % 8` -> `i  7` 的有效性。核心在于比较取余运算符 (`%`) 和按位与运算符 (``) 在不同语言和数值条件下的语义。\n\n**`i  7` 的分析**\n表达式 `i  7` 对整数 $i$ 执行按位与操作。在二进制中，$7$ 是 `...000111`。此操作提取 $i$ 的二进制表示的最低三位，结果总是一个在 $[0, 7]$ 范围内的非负整数。对于所有采用二补数表示法（现代系统的标准）的整数 $i$（正、负或零），`i  (2^k - 1)` 计算的值 $r$ 满足 $i \\equiv r \\pmod{2^k}$。因此，`i  7` 计算的结果 $r$ 满足 $0 \\le r \\le 7$ 且 $i \\equiv r \\pmod{8}$。这与余数的数学定义完全一致。\n\n**`i % 8` 的分析**\n`%` 运算符的行为，特别是对于负操作数，因编程语言而异。\n\n1.  **对于非负的 `i` ($i \\ge 0$)：**\n    所有相关语言（C, C++, Java, Python）都将 `i % 8` 定义为标准的数学余数，其值在 $[0, 7]$ 范围内。这与 `i  7` 的结果相同。因此，对于 $i \\ge 0$，替换总是安全的。\n\n2.  **对于负的 `i` ($i  0$)：**\n    -   **C (自 C99), C++ (自 C++11), Java：** 这些语言定义 `a % b` 的结果与 `a` 的符号相同（或为零）。这是基于向零截断的整数除法 `(a / b) * b + a % b == a`。\n        例如，对于 $i = -1$ 和除数 $m=8$：\n        - 除法：`(-1) / 8 = 0`。\n        - 结果：`(-1) % 8 = -1`。\n        然而，`(-1)  7 = 7`。由于 $-1 \\ne 7$，在这些语言中，对于负数 $i$，该替换是不安全的。\n\n    -   **Python：** 该语言定义 `a % b` 的结果与除数 `b` 的符号相同。这是基于向下取整（朝负无穷）的整数除法 `(a // b) * b + a % b == a`。\n        例如，对于 $i = -1$ 和除数 $m=8$：\n        - 除法：`(-1) // 8 = -1`。\n        - 结果：`(-1) % 8 = 7`。\n        这与 `(-1)  7 = 7` 的结果相匹配。在 Python 中，`i % 8` 的结果总是在 $[0, 7]$ 范围内，与数学余数和 `i  7` 的结果一致。\n\n**逐项分析**\n\n**A. 在 C (自 C99 起) 和 C++ (自 C++11 起) 中，用 `i  7` 替换 `i % 8` 对于所有整型类型（包括负值）都是安全的，因为这两个操作都是在二补数表示上定义的。**\n**不正确**。对于负值 $i$，`i % 8` 的结果为负数或零（例如 `(-1) % 8` 为 $-1$），而 `i  7` 的结果总是非负数（`(-1)  7` 为 $7$）。因此替换不安全。\n\n**B. 在 C 和 C++ 中，如果 `i` 是无符号类型，或者 `i` 是有符号类型且在运行时已知 `i \\ge 0`，那么用 `i  7` 替换 `i % 8` 是安全的。**\n**正确**。在这两种情况下，$i$ 都是非负的。对于非负整数，`i % 8` 和 `i  7` 都产生相同的、在 $[0, 7]$ 范围内的数学余数。\n\n**C. 在 Java (运行于 Java 虚拟机 (JVM) 上) 中，对于负数 `i`，该替换是不安全的，因为 `i % 8` 可能为负，而 `i  7` 的结果总是在 $[0,7]$ 范围内。**\n**正确**。Java 遵循与 C99/C++11 相同的取余规则，即结果符号与被除数相同。因此，对于负数 $i$，`i % 8` 的结果为负数或零，而 `i  7` 的结果为非负数，两者不等。\n\n**D. 在 Python 中，替换 `i % 8 -> i  7` 对所有整数都是安全的，因为 Python 将 `i % 8` 定义为满足 $0 \\le r  8$ 和 $i \\equiv r \\pmod{8}$ 的唯一 $r$，这与低 3 位 `i  7` 的值相等。**\n**正确**。Python 的 `%` 运算符的定义确保了当除数为正时，结果总是非负的，与数学余数的定义一致。这与 `i  7` 在二补数系统中的行为完全匹配。\n\n**E. 在 C 和 C++ 中，当 `i` 是一个负的有符号整数时，计算 `i  7` 会触发未定义行为 (UB)，这就是为什么在这些情况下替换是不安全的。**\n**不正确**。对有符号整数的按位运算（包括负数）在 C 和 C++ 中是明确定义的。替换不安全的原因是语义不等价，而不是因为 `i  7` 是未定义行为。", "answer": "$$\\boxed{BCD}$$", "id": "3672310"}]}