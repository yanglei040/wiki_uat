{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。控制流完整性（CFI）的一个常见应用场景是保护 `switch` 语句，因为它们常常被编译器转换成使用跳转表的间接跳转。这个练习将带你动手实践如何运用区间算术（一种静态分析技术）来为一个跳转表索引推导出精确而高效的安全边界检查，以确保跳转目标不会越界。通过这个练习，你将掌握将CFI应用于真实代码结构的基本技能。[@problem_id:3632863]", "problem": "编译器将一个结构化的多分支语句降级（lowers）为一个由整数表达式索引的跳转表。在控制流完整性（Control Flow Integrity, CFI）的约束下，每个间接分支都必须被插桩（instrumented），以确保其只能跳转到静态确定的有效基本块集合中的目标。考虑一个基于整数情况的结构化 switch 语句，编译器已将其布局为一个覆盖了 case 标签 $0, 1, \\dots, 20$ 的连续跳转表和一个独立的默认块。用于寻址该表的索引由程序变量 $x$ 和 $y$ 计算得出，公式如下：\n$$\nj \\;=\\; \\left(\\left\\lfloor \\frac{3x - 2y + 7}{2} \\right\\rfloor \\right) \\bmod 64,\n$$\n其中 $\\lfloor \\cdot \\rfloor$ 表示向下取整函数，取模运算产生 $\\{0,1,\\dots,63\\}$ 中的非负余数。静态范围分析确定了在 switch 语句的程序点处，输入变量的范围为 $x \\in [-4,12]$ 和 $y \\in [1,9]$。\n\n你需要为跳转表类型的 switch 语句提出一种符合 CFI 规范的插桩方法，该方法在执行间接跳转之前，对计算出的索引使用单个边界检查。请使用区间算术以及整数向下取整和取模运算的明确语义，推导出最紧的常量上界 $U$，使得插入一个形式为“仅当 $j  U$ 时执行间接跳转，否则跳转到默认块”的守卫（guard）能够保证对于所有 $x \\in [-4,12]$ 和 $y \\in [1,9]$，间接跳转只能以条目 $0$ 到 $20$ 为目标。\n\n请提供满足条件的最小常量 $U$ 作为最终答案。无需四舍五入。", "solution": "目标是为一个形式为 $j  U$ 的安全检查确定最小整数常量 $U$。这个检查必须保证任何由 $j$ 索引的间接跳转都只以跳转表的有效条目为目标，这些有效条目被指定为 $\\{0, 1, \\dots, 20\\}$。该检查还必须是正确的，即它必须允许所有有效且可达的跳转目标。索引 $j$ 是基于已知范围的程序变量 $x$ 和 $y$ 计算得出的。\n\n索引 $j$ 由以下表达式给出：\n$$\nj = \\left(\\left\\lfloor \\frac{3x - 2y + 7}{2} \\right\\rfloor \\right) \\bmod 64\n$$\n静态分析提供的变量 $x$ 和 $y$ 的范围是 $x \\in [-4, 12]$ 和 $y \\in [1, 9]$。我们假设 $x$ 和 $y$ 可以是这些闭区间内的任何实数。取模运算的定义是产生一个在 $\\{0, 1, \\dots, 63\\}$ 中的非负余数。\n\n首先，我们必须通过对表达式应用区间算术来确定 $j$ 的所有可能值的集合。设向下取整函数的参数为 $V$：\n$$\nV = \\frac{3x - 2y + 7}{2}\n$$\n我们推导分子 $3x - 2y + 7$ 的区间：\n1.  项 $3x$：由于 $x \\in [-4, 12]$，乘以 $3$ 得到 $3x \\in [3 \\times (-4), 3 \\times 12] = [-12, 36]$。\n2.  项 $-2y$：由于 $y \\in [1, 9]$，所以 $2y \\in [2, 18]$。对该区间取反得到 $-2y \\in [-18, -2]$。\n3.  将 $3x$、$-2y$ 和常量 $7$ 的区间相加：\n    下界为 $-12 + (-18) + 7 = -23$。\n    上界为 $36 + (-2) + 7 = 41$。\n    因此，$3x - 2y + 7 \\in [-23, 41]$。\n\n现在，我们通过除以 $2$ 来找到 $V$ 的区间：\n$$\nV \\in \\left[\\frac{-23}{2}, \\frac{41}{2}\\right] = [-11.5, 20.5]\n$$\n\n令 $k = \\lfloor V \\rfloor = \\lfloor \\frac{3x - 2y + 7}{2} \\rfloor$。由于向下取整函数是非递减的，我们可以通过对 $V$ 的区间端点取整来找到 $k$ 的范围。\n$k$ 的最小值为 $\\lfloor -11.5 \\rfloor = -12$。\n$k$ 的最大值为 $\\lfloor 20.5 \\rfloor = 20$。\n$V$ 的区间是连续的，宽度为 $20.5 - (-11.5) = 32$，大于 $1$。因此，$k$ 可以取其最小值和最大值之间的任何整数值。\n所以，$k$ 的可能值集合为 $\\{-12, -11, \\dots, 19, 20\\}$。\n\n接下来，我们计算最终索引 $j = k \\bmod 64$。我们分析 $k$ 值的两种情况：\n1.  对于非负的 $k$，其中 $k \\in \\{0, 1, \\dots, 20\\}$：\n    在此范围内，$j = k \\bmod 64 = k$。\n    因此，$k$ 的这部分范围产生的索引集合为 $\\{0, 1, \\dots, 20\\}$。这些都是有效的跳转目标。\n2.  对于负的 $k$，其中 $k \\in \\{-12, -11, \\dots, -1\\}$：\n    题目规定取模运算产生非负余数。这对应于数学定义 $a \\bmod n = a - n \\lfloor a/n \\rfloor$。对于负数 $a$ 和正数 $n$，这通常实现为 $a \\bmod n = (a \\% n + n) \\% n$。对于我们这里的情况，可以简化为 $a+n$。\n    对于 $k = -1$, $j = -1 \\bmod 64 = 63$。\n    对于 $k = -2$, $j = -2 \\bmod 64 = 62$。\n    ...\n    对于 $k = -12$, $j = -12 \\bmod 64 = 52$。\n    因此，$k$ 的这部分范围产生的索引集合为 $\\{52, 53, \\dots, 63\\}$。这些都是无效的跳转目标，因为它们位于有效范围 $\\{0, 1, \\dots, 20\\}$ 之外。\n\n综合这两种情况，索引 $j$ 的所有可能计算值的集合 $S$ 为：\n$$\nS = \\{0, 1, \\dots, 20\\} \\cup \\{52, 53, \\dots, 63\\}\n$$\n控制流完整性（CFI）守卫是 `if (j  U) jump() else default()`。这个机制必须满足两个条件：\n1.  **安全性**：它必须阻止所有跳转到无效目标的行为。任何通过检查（即 $j  U$）的计算索引 $j$ 都必须是一个有效的目标。通过检查的计算索引集合是 $S \\cap \\{0, 1, \\dots, U-1\\}$。这个集合必须是有效目标集合 $\\{0, 1, \\dots, 20\\}$ 的子集。\n    $$\n    S \\cap \\{0, 1, \\dots, U-1\\} \\subseteq \\{0, 1, \\dots, 20\\}\n    $$\n    $S$ 中的无效索引是 $\\{52, 53, \\dots, 63\\}$。为了使条件成立，这些无效索引都不能通过 $j  U$ 的检查。这意味着对于任何 $j_{invalid} \\in \\{52, 53, \\dots, 63\\}$，我们必须有 $j_{invalid} \\ge U$。限制性最强的情况是这些无效索引中最小的那个，即 $52$。所以，我们必须有 $52 \\ge U$。\n\n2.  **正确性**：它不能阻止有效的程序执行。所有可达的有效 case 标签都必须被检查所允许。可达的有效目标集合是 $\\{0, 1, \\dots, 20\\}$。对于这些值中的每一个 $j_{valid}$，检查 $j_{valid}  U$ 都必须为真。\n    这必须对所有 $j \\in \\{0, 1, \\dots, 20\\}$ 成立。限制性最强的情况是这些有效索引中最大的那个，即 $20$。所以，我们必须有 $20  U$。\n\n综合这两个条件，$U$ 必须是满足 $20  U$ 且 $U \\le 52$ 的整数。这意味着 $U$ 可以是范围 $[21, 52]$ 内的任何整数。\n问题要求的是*最小*的此类常量 $U$。这对应于在不违反正确性的前提下，使检查尽可能地紧凑。满足 $20  U$ 的最小整数值是 $21$。该值也满足 $U \\le 52$。\n\n因此，最小常量上界是 $U=21$。使用这个边界，检查变为 $j  21$。\n- 如果计算出的索引 $j$ 在 $\\{0, 1, \\dots, 20\\}$ 中，则检查 $j  21$ 通过，并执行有效的跳转。\n- 如果计算出的索引 $j$ 在 $\\{52, 53, \\dots, 63\\}$ 中，则检查 $j  21$ 失败，程序正确地分支到默认块，从而防止了无效跳转。\n这满足了所有要求。", "answer": "$$\\boxed{21}$$", "id": "3632863"}, {"introduction": "除了针对特定的代码结构，通用的编译器优化也能极大地增强CFI的精度。本练习将向你展示，部分求值（Partial Evaluation）和常量传播等优化技术，如何通过在编译时确定程序变量的值，来显著缩小间接调用的潜在目标集。通过这个计算，你将能够量化这种改进带来的好处，并理解编译器优化与程序安全性之间的协同作用。[@problem_id:3632876]", "problem": "编译器在间接调用点强制实施控制流完整性（CFI），要求动态目标属于静态计算的目标集 $T$。考虑一个程序，其中间接调用的目标由一个表驱动的分派器选择，该分派器由一个三元组 $(\\text{type}, \\text{op}, \\text{mode})$ 索引。计算 $T$ 的静态分析基于以下保守但一致的事实，这些事实在任何特化之前都成立：\n- 有 $N$ 种不同的运行时类型可能到达该调用点。\n- 对于每种运行时类型，静态分析认为恰好有 $u$ 个操作与该类型在该调用点配对是安全的。\n- 对于每个安全的 $(\\text{type}, \\text{op})$ 对，恰好有 $v$ 种模式被认为是安全的。\n\n所有量 $N$、$u$ 和 $v$ 都是正整数。假设如上所述，安全判断在类型和操作之间是一致的。\n\n现在假设编译器在计算用于强制执行的 $T'$ 之前，执行了部分求值（PE）和常量传播。以下编译时事实变得已知：\n- 到达调用点的运行时类型是单个已知的常量类型。\n- 一个全局配置常量强制分派器将每种安全 $(\\text{type}, \\text{op})$ 对的模式限制为大小为 $v_{s}$ 的子集，其中 $v_{s}$ 是一个正整数且 $v_{s} \\leq v$。\n- 一个先前的特化步骤用一个常量替换了数据相关的操作过滤器，将已知类型的安全操作集限制为大小为 $w$ 的子集，其中 $w$ 是一个正整数且 $w \\leq u$。\n\n在这些假设下，使用有限集的基本计数原理，将CFI目标集建模为在相应分析后仍然可行的所有处理程序条目的集合。使用第一性原理（CFI的定义即为将动态目标限制在一个静态确定的有限集中，部分求值的定义即为针对已知常量的特化，以及独立有限选择的基数的乘法法则），推导目标集大小绝对减少量的闭式符号表达式，\n$$\\Delta \\;=\\; \\lvert T \\rvert \\;-\\; \\lvert T' \\rvert$$,\n其中 $T$ 是特化前计算的，$T'$ 是特化后计算的。请用 $N$、$u$、$v$、$w$ 和 $v_{s}$ 将你的最终答案表示为单个解析表达式。", "solution": "### 解题推导\n\n问题的核心是确定两个目标集 $T$（特化前）和 $T'$（特化后）的基数，然后计算它们的差值。问题陈述指出，目标由一个三元组 $(\\text{type}, \\text{op}, \\text{mode})$ 索引。因此，有效目标总数就是可以形成的唯一有效三元组的总数。我们将使用基本的计数乘法法则，该法则指出，如果一个过程可以分解为一系列独立的选择，那么总的结果数是每个阶段选项数量的乘积。\n\n首先，我们计算在进行任何特化之前初始目标集的大小 $\\lvert T \\rvert$。\n1.  `type` 的选择可以是可能到达调用点的 $N$ 个不同运行时类型中的任意一个。因此，三元组的第一个元素有 $N$ 个选项。\n2.  对于这 $N$ 个类型中的每一个，静态分析都认为恰好有 $u$ 个操作是安全的。因此，对于任何给定的 `type` 选择，`op` 有 $u$ 个选项。\n3.  对于每个安全的 $(\\text{type}, \\text{op})$ 对，恰好有 $v$ 个安全模式。因此，对于三元组前两个元素的任何给定选择，`mode` 有 $v$ 个选项。\n\n由于这些选择是独立的，有效三元组 $(\\text{type}, \\text{op}, \\text{mode})$ 的总数是每个阶段选项数量的乘积。\n$$\\lvert T \\rvert = N \\times u \\times v$$\n\n接下来，我们计算在应用部分求值和其他优化后，特化目标集的大小 $\\lvert T' \\rvert$。\n1.  编译器确定到达的运行时类型是单个已知的常量。这将 `type` 的选项数量从 $N$ 减少到 $1$。\n2.  对于这一个已知的类型，一个特化步骤已将安全操作集限制为一个大小为 $w$ 的子集。因此，现在 `op` 有 $w$ 个选项。\n3.  一个全局配置常量将每个安全 $(\\text{type}, \\text{op})$ 对所允许的模式数量限制为一个大小为 $v_s$ 的子集。这意味着对于我们单个已知的类型及其任意一个 $w$ 个安全操作，`mode` 有 $v_s$ 个选项。\n\n再次对特化情况应用乘法法则：\n$$\\lvert T' \\rvert = 1 \\times w \\times v_s = w v_s$$\n\n问题要求计算目标集大小的绝对减少量，即 $\\Delta = \\lvert T \\rvert - \\lvert T' \\rvert$。代入我们推导出的 $\\lvert T \\rvert$ 和 $\\lvert T' \\rvert$ 的表达式：\n$$\\Delta = (Nuv) - (wv_s)$$\n\n该表达式表示被编译器的特化和常量传播优化所剪除的控制流路径总数。它是一个关于给定参数 $N$、$u$、$v$、$w$ 和 $v_{s}$ 的闭式符号表达式。", "answer": "$$\\boxed{Nuv - w v_{s}}$$", "id": "3632876"}, {"introduction": "为了获得更高的分析精度，现代编译器会采用更复杂的分析框架。本练习将探讨如何利用静态单赋值（SSA）形式和值域分析来精确追踪一个函数指针在不同控制流路径上的可能取值。通过为指针计算出一个紧凑的取值区间，并将其与CFI策略允许的合法目标集合求交集，我们可以进一步精确化我们的CFI策略，这充分展示了现代静态分析技术在安全加固中的强大能力。[@problem_id:3632873]", "problem": "考虑一个编译器，它通过将调用目标限制在一个已知的合法函数入口地址等价类中，来实现针对间接调用的控制流完整性（Control Flow Integrity, CFI）。该编译器执行静态单赋值（Static Single Assignment, SSA）转换，然后在区间抽象域中应用值域分析，以过近似地估计间接调用点处函数指针的可能值。静态单赋值（SSA）形式确保每个变量仅被赋值一次，并使用一个 $\\phi$ 函数来合并来自前驱基本块的值。区间抽象域将变量的可能值集合表示为一个闭区间 $[l,u]$（其中 $l \\leq u$），该分析使用单调传递函数和在 $\\phi$ 节点处的凸包连接来计算一个可靠的过近似。\n\n给定一个函数指针变量的以下 SSA 片段：\n- 基地址 $B$ 是一个已知常量，其值为 $B = 1000$。\n- 在基本块 $b_1$ 中，一个经过处理的循环索引 $y$ 满足 $y \\in [2,6]$，函数指针被赋值为 $fp_1 := B + 4y$。\n- 在基本块 $b_2$ 中，一个整数 $z$ 满足 $z \\in [9,13]$，一个偏移量 $w$ 满足 $w \\in [0,3]$。函数指针被赋值为 $fp_2 := B + 3z + 5$，然后通过有界调整被修正为 $fp_2' := fp_2 + 4w$。\n- 在汇合块 $b_3$ 中，SSA 合并为 $fp_3 := \\phi(fp_1, fp_2')$。区间值域分析在 $\\phi$ 节点处使用凸包作为连接操作。\n- 在间接调用之前，有一个守卫条件，仅当 $fp_3 \\leq 1050$ 时才允许调用；否则控制流将转向错误处理程序。假设分析通过与 $(-\\infty,1050]$ 求交集，将此守卫条件纳入到调用路径上 $fp_3$ 的区间中。\n\n此调用点的 CFI 等价类是允许目标的离散集合\n$$T = \\{1008, 1012, 1016, 1020, 1024, 1032, 1036, 1040, 1044, 1048, 1052\\}.$$\n\n仅使用 SSA、区间算术和单调数据流分析的基本性质，推导出值域分析为 $b_3$ 中调用路径上的 $fp_3$ 计算出的区间 $I$，然后计算交集 $T \\cap I$，以确定经过基于区间的目标剪枝后剩余的合法被调用目标的数量。将最终答案报告为基数 $\\lvert T \\cap I \\rvert$。无需四舍五入。将最终答案表示为单个数字。", "solution": "目标是确定在应用值域分析后，一个间接调用可能的合法函数目标的数量。这需要计算函数指针可能值的区间，并将其与允许的目标地址集合求交集。该交集的基数即为最终答案。\n\n过程如下：\n1.  计算源于基本块 $b_1$ 的函数指针 $fp_1$ 的区间。\n2.  计算源于基本块 $b_2$ 的函数指针 $fp_2'$ 的区间。\n3.  通过取 $fp_1$ 和 $fp_2'$ 区间的凸包，计算合并后的函数指针 $fp_3$ 的区间。\n4.  通过纳入守卫条件来修正 $fp_3$ 的区间。\n5.  确定最终区间与合法目标集 $T$ 的交集，并求其基数。\n\n令 $I_x$ 表示变量 $x$ 的可能值区间。对于加法和与常量 $c$ 相乘的区间算术定义如下：\n$$[a, b] + [d, e] = [a+d, b+e]$$\n$$c \\cdot [a, b] = [\\min(ca, cb), \\max(ca, cb)]$$\n\n步骤 1：计算 $fp_1$ 的区间。\n基地址是一个常量，$B = 1000$。\n在基本块 $b_1$ 中，变量 $y$ 的区间为 $I_y = [2, 6]$。\n函数指针 $fp_1$ 被赋值为 $fp_1 := B + 4y$。\n使用区间算术，我们首先计算 $4y$ 的区间：\n$$I_{4y} = 4 \\cdot I_y = 4 \\cdot [2, 6] = [4 \\cdot 2, 4 \\cdot 6] = [8, 24]$$\n现在，我们加上常量基地址 $B=1000$，它可以表示为区间 $[1000, 1000]$：\n$$I_{fp_1} = [1000, 1000] + I_{4y} = [1000, 1000] + [8, 24] = [1000+8, 1000+24] = [1008, 1024]$$\n\n步骤 2：计算 $fp_2'$ 的区间。\n在基本块 $b_2$ 中，变量 $z$ 和 $w$ 的区间分别为 $I_z = [9, 13]$ 和 $I_w = [0, 3]$。\n指针 $fp_2$ 首先被赋值为 $fp_2 := B + 3z + 5$。\n$3z$ 的区间为：\n$$I_{3z} = 3 \\cdot I_z = 3 \\cdot [9, 13] = [27, 39]$$\n那么 $fp_2$ 的区间为：\n$$I_{fp_2} = [1000, 1000] + I_{3z} + [5, 5] = [1000+27+5, 1000+39+5] = [1032, 1044]$$\n接着，$fp_2'$ 被赋值为 $fp_2' := fp_2 + 4w$。\n$4w$ 的区间为：\n$$I_{4w} = 4 \\cdot I_w = 4 \\cdot [0, 3] = [0, 12]$$\n$fp_2'$ 的区间是 $fp_2$ 和 $4w$ 区间的和：\n$$I_{fp_2'} = I_{fp_2} + I_{4w} = [1032, 1044] + [0, 12] = [1032+0, 1044+12] = [1032, 1056]$$\n\n步骤 3：计算守卫条件之前 $fp_3$ 的合并区间。\n在汇合块 $b_3$ 中，$fp_3$ 的值由 $\\phi$ 函数决定：$fp_3 := \\phi(fp_1, fp_2')$。\n区间域的连接操作符是凸包。两个区间 $[a, b]$ 和 $[c, d]$ 的凸包是 $[\\min(a, c), \\max(b, d)]$。\n令 $I_{fp_3, \\text{pre-guard}}$ 为考虑守卫条件之前 $fp_3$ 的区间。\n$$I_{fp_3, \\text{pre-guard}} = \\text{convex\\_hull}(I_{fp_1}, I_{fp_2'}) = \\text{convex\\_hull}([1008, 1024], [1032, 1056])$$\n下界是 $\\min(1008, 1032) = 1008$。\n上界是 $\\max(1024, 1056) = 1056$。\n因此，合并后的区间是：\n$$I_{fp_3, \\text{pre-guard}} = [1008, 1056]$$\n\n步骤 4：使用守卫条件修正区间。\n分析纳入了守卫条件 $fp_3 \\leq 1050$。这个约束对应于区间 $(-\\infty, 1050]$。在调用路径上 $fp_3$ 的最终区间（我们记为 $I$）是守卫条件前区间与守卫条件施加的区间的交集。\n$$I = I_{fp_3, \\text{pre-guard}} \\cap (-\\infty, 1050]$$\n$$I = [1008, 1056] \\cap (-\\infty, 1050] = [1008, 1050]$$\n\n步骤 5：计算与合法目标集 $T$ 交集的基数。\n允许的目标集合被给定为：\n$$T = \\{1008, 1012, 1016, 1020, 1024, 1032, 1036, 1040, 1044, 1048, 1052\\}$$\n最终剪枝后的目标集合是 $T \\cap I$。我们需要找到所有满足 $1008 \\leq t \\leq 1050$ 的元素 $t \\in T$。\n让我们筛选集合 $T$：\n- $1008$: $1008 \\in [1008, 1050]$ (是)\n- $1012$: $1012 \\in [1008, 1050]$ (是)\n- $1016$: $1016 \\in [1008, 1050]$ (是)\n- $1020$: $1020 \\in [1008, 1050]$ (是)\n- $1024$: $1024 \\in [1008, 1050]$ (是)\n- $1032$: $1032 \\in [1008, 1050]$ (是)\n- $1036$: $1036 \\in [1008, 1050]$ (是)\n- $1040$: $1040 \\in [1008, 1050]$ (是)\n- $1044$: $1044 \\in [1008, 1050]$ (是)\n- $1048$: $1048 \\in [1008, 1050]$ (是)\n- $1052$: $1052 \\notin [1008, 1050]$ (否)\n\n得到的集合是：\n$$T \\cap I = \\{1008, 1012, 1016, 1020, 1024, 1032, 1036, 1040, 1044, 1048\\}$$\n这个集合的基数是它包含的元素数量。数一下元素个数，我们发现有 $10$ 个。\n$$|T \\cap I| = 10$$\n这就是基于区间的目标剪枝后剩余的合法被调用目标的数量。", "answer": "$$\\boxed{10}$$", "id": "3632873"}]}