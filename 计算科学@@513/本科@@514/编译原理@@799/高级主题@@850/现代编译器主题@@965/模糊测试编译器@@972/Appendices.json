{"hands_on_practices": [{"introduction": "编译器经常利用未定义行为 (Undefined Behavior, UB) 进行激进的优化，它们假设UB永远不会发生。本实践 [@problem_id:3642978] 引导你构建一个测试工具，通过模拟一个具有明确UB语义的玩具语言，来揭示这类优化中的错误。你将学习如何通过“变异”程序（系统性地移除UB检查）来验证编译器的行为是否与一个更安全的、有明确定义的语义模型保持一致，从而掌握一种发现由UB假设引发的编译器错误的强大技术。", "problem": "您将进入一个简化场景，通过使用变异算子检测对未定义行为的依赖，来探索编译器模糊测试。任务是为一个模拟整数计算和未定义行为概念的玩具表达式语言构建一个小型的解释器，应用一个系统的、移除未定义行为保护分支的变异算子，并在一组有限的输入环境测试套件上，比较原始程序（在确定语义下解释）与变异后程序的输出。\n\n基本原理与定义：\n- 编译器优化正确性的指导原则是语义保持：优化不得改变程序的可观察语义。如果编译器依赖未定义行为（UB），它可能会假设某些确定语义所不保证的条件。我们通过一种可能无法产生确定整数结果的部分语义来建模UB。\n- 考虑一个基于整数输入和变量 $x$、$y$、$z$ 的玩具表达式语言，它包含以下表达式：常量、变量、加法、减法、乘法、带检查的除法、确定性谓词和条件表达式。形式上，表达式 $E$ 由以下部分构建：\n  1. $E ::= c$ 其中 $c \\in \\mathbb{Z}$，\n  2. $E ::= x \\mid y \\mid z$，\n  3. $E ::= E_1 + E_2 \\mid E_1 - E_2 \\mid E_1 \\times E_2$，\n  4. $E ::= \\mathrm{div\\_checked}(E_1,E_2)$，\n  5. $E ::= \\mathrm{is\\_defined}(E)$，\n  6. $E ::= \\mathrm{if}(C, T, F)$ 其中 $C$ 是一个条件表达式，其结果为一个整数，该整数被解释为布尔值（非零为真，零为假）。\n- 语义将表达式映射到一个确定的整数或一个未定义的结果。令 $\\llbracket E \\rrbracket(\\rho)$ 表示在为变量 $x$、$y$ 和 $z$ 赋予整数值的环境 $\\rho$ 下对 $E$ 的求值。我们定义：\n  1. 常量和变量：$\\llbracket c \\rrbracket(\\rho) = \\langle \\mathrm{def}, c \\rangle$, $\\llbracket x \\rrbracket(\\rho) = \\langle \\mathrm{def}, \\rho(x) \\rangle$，对于 $y$ 和 $z$ 同理。\n  2. 二元算术：对于 $E_1 \\circ E_2$，其中 $\\circ \\in \\{+, -, \\times\\}$，如果 $\\llbracket E_1 \\rrbracket(\\rho)$ 或 $\\llbracket E_2 \\rrbracket(\\rho)$ 未定义，则结果未定义；否则结果为整数算术运算的结果。\n  3. 带检查的除法：如果任一操作数未定义，或者除数求值为 $0$，则 $\\llbracket \\mathrm{div\\_checked}(E_1,E_2) \\rrbracket(\\rho)$ 未定义；否则结果为整数除法 $E_1 / E_2$。\n  4. 确定性谓词：$\\llbracket \\mathrm{is\\_defined}(E) \\rrbracket(\\rho) = \\langle \\mathrm{def}, b \\rangle$，其中如果 $\\llbracket E \\rrbracket(\\rho)$ 是确定的，则 $b = 1$，否则 $b = 0$。该谓词本身不会变为未定义。\n  5. 条件语句：$\\llbracket \\mathrm{if}(C,T,F) \\rrbracket(\\rho)$ 首先对 $C$ 求值。如果 $C$ 未定义，确定语义将其视为假，选择 $F$；如果 $C$ 已定义且非零，则求值并返回 $\\llbracket T \\rrbracket(\\rho)$；如果 $C$ 已定义且为零，则求值并返回 $\\llbracket F \\rrbracket(\\rho)$。如果所选分支的求值结果为未定义，则整个表达式的结果也为未定义。\n\n变异算子：\n- 变异算子通过移除检查确定性的保护逻辑，来建模一类依赖于未定义行为的编译器转换。该算子 $\\mathcal{M}$ 作用于抽象语法树，并将任何形如 $\\mathrm{if}(\\mathrm{is\\_defined}(E), T, F)$ 的条件表达式替换为分支 $T$，从而系统地移除了“未定义”分支 $F$。该算子递归地进入子表达式，以生成一个变异后的程序 $\\mathcal{M}(E)$。\n\n任务：\n- 按照上述定义实现玩具语言的解释器，并实现变异算子 $\\mathcal{M}$。\n- 对于下面的每个测试用例，将程序实例化为抽象语法树 $E$，应用 $\\mathcal{M}$ 获得变异后的程序 $\\mathcal{M}(E)$，并在指定的输入环境 $\\rho$ 下比较 $\\llbracket E \\rrbracket(\\rho)$ 和 $\\llbracket \\mathcal{M}(E) \\rrbracket(\\rho)$ 的输出。环境 $\\rho$ 是一个三元组 $(x,y,z) \\in \\mathbb{Z}^3$。如果两个结果都是确定的且整数值相等，则认为它们相等；否则它们不相等。\n- 您的程序的最终输出必须是单独一行，其中包含一个由方括号括起来的、以逗号分隔的整数0或1的列表。列表中的每个条目对应一个测试用例，如果变异后的程序在所有列出的环境下与原始程序是可观察等价的，则该条目为1，否则为0。\n\n测试套件：\n- 测试用例 1 (带回退机制的基本受保护除法)：\n  - 程序 $E_1 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{div\\_checked}(x,y) + 1,\\, 0)$。\n  - 环境：$(10,2,0)$, $(10,0,0)$, $(0,5,0)$, $(-9,3,0)$。\n- 测试用例 2 (始终确定的保护，正常路径)：\n  - 程序 $E_2 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x \\times 2,\\, -1)$。\n  - 环境：$(7,123,0)$, $(-8,42,0)$, $(0,999,0)$。\n- 测试用例 3 (嵌套保护，多个潜在的未定义点)：\n  - 程序 $E_3 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)),\\, \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z),\\, 7),\\, 8)$。\n  - 环境：$(12,3,2)$, $(12,0,2)$, $(12,3,0)$, $(0,10,2)$, $(9,-3,-3)$。\n- 测试用例 4 (由于分支相同，移除保护是语义保持的)：\n  - 程序 $E_4 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x + 0,\\, x + 0)$。\n  - 环境：$(5,100,0)$, $(-1,2,0)$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i \\in \\{0,1\\}$ 对应于测试用例 i 的等价性检查。", "solution": "用户提供的问题陈述是有效的。这是一个在计算机科学领域内，特别是在编译器理论和程序语义方面的适定、有科学依据的问题。它提供了一个形式系统，包括一种玩具编程语言、一种包含未定义行为概念的确定操作语义，以及一个旨在模拟依赖于未定义行为假设的编译器优化的变异算子。任务是实现这个系统，将其应用于一组给定的测试用例，并确定原始程序与变异后程序之间的可观察等价性。该问题是自洽的、逻辑一致且无歧义的。\n\n解决方案的步骤如下：首先，构建必要的数据结构来表示该语言的抽象语法树（AST）。然后，实现两个主要函数：一个根据指定语义计算表达式值的解释器，以及一个根据给定算子规则转换表达式AST的变异函数。最后，通过构建程序的AST，对其进行变异，并在一个输入环境套件上比较原始AST和变异后AST的求值结果，来执行每个测试用例。\n\n### 1. 数据表示与语义\n\n一个表达式 $E$ 在AST中被表示为一个节点。每个节点包含一个类型标签和与该类型对应的有效负载（例如，一个常量值、一个变量标识符，或指向子节点以进行操作的指针）。\n\n求值语义 $\\llbracket E \\rrbracket(\\rho)$ 将一个表达式 $E$ 和一个环境 $\\rho$（一个从变量 $x, y, z$ 到整数值的映射）映射到一个结果。该结果是一个序对 $\\langle \\text{状态}, \\text{值} \\rangle$，其中状态为确定或未定义。这是通过使用一个包含布尔标志和整数值的结构体来实现的。\n\n解释器是一个递归函数 `eval(E, rho)`，它遍历AST。\n- 对于常量和变量，它直接从AST节点或环境 $\\rho$ 返回确定的值。\n- 对于算术运算 $E_1 \\circ E_2$ （其中 $\\circ \\in \\{+, -, \\times\\}$），它递归地对 $E_1$ 和 $E_2$ 求值。如果任一子求值导致未定义状态，则该运算的结果也为未定义。否则，执行整数运算。\n- 对于 $\\mathrm{div\\_checked}(E_1, E_2)$，它遵循算术运算的逻辑，但增加了一个对除数的检查：如果 $\\llbracket E_2 \\rrbracket(\\rho)$ 的值为 $0$，则结果为未定义。\n- 谓词 $\\llbracket \\mathrm{is\\_defined}(E) \\rrbracket(\\rho)$ 对 $E$ 求值。如果 $\\llbracket E \\rrbracket(\\rho)$ 是确定的，它返回一个确定的结果 $\\langle \\mathrm{def}, 1 \\rangle$；如果不是，则返回 $\\langle \\mathrm{def}, 0 \\rangle$。此操作本身从不产生未定义结果。\n- 条件语句 $\\llbracket \\mathrm{if}(C, T, F) \\rrbracket(\\rho)$ 是独特的。它首先对条件 $C$ 求值。如果 $\\llbracket C \\rrbracket(\\rho)$ 未定义，语义规定将其视为假条件，因此对假分支 $F$ 求值。如果 $\\llbracket C \\rrbracket(\\rho)$ 已定义，其整数值被视为布尔值（$0$ 为假，非零为真）以选择 $T$ 或 $F$ 分支进行求值。\n\n### 2. 变异算子\n\n变异算子 $\\mathcal{M}$ 被实现为一个递归函数 `mutate(E)`，它构建一个新的、变异后的AST。该转换是组合式的：\n- 对于除 `if` 之外的表达式类型，算子对子表达式进行递归，并使用变异后的子表达式重建相同类型的表达式。例如，$\\mathcal{M}(E_1+E_2) = \\mathcal{M}(E_1) + \\mathcal{M}(E_2)$。\n- 对于条件表达式 $\\mathrm{if}(C, T, F)$，算子检查条件 $C$。\n  - 如果 $C$ 的形式为 $\\mathrm{is\\_defined}(E')$，则整个 `if` 表达式被替换为对真分支 $T$ 进行变异的结果。即 $\\mathcal{M}(\\mathrm{if}(\\mathrm{is\\_defined}(E'), T, F)) = \\mathcal{M}(T)$。这模拟了编译器假设保护条件总是为真，从而消除检查和假分支。\n  - 否则，算子递归进入所有三个子表达式：$\\mathcal{M}(\\mathrm{if}(C, T, F)) = \\mathrm{if}(\\mathcal{M}(C), \\mathcal{M}(T), \\mathcal{M}(F))$。\n\n### 3. 测试用例分析\n\n对于一个给定的测试用例，当且仅当对于每个指定的环境 $\\rho$，$\\llbracket E \\rrbracket(\\rho)$ 和 $\\llbracket \\mathcal{M}(E) \\rrbracket(\\rho)$ 的结果要么都未定义，要么都已定义且具有相同的整数值时，一个程序才与其变异版本是可观察等价的。\n\n**测试用例 1：** $E_1 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{div\\_checked}(x,y) + 1,\\, 0)$\n- 变异后的程序：$\\mathcal{M}(E_1) = \\mathcal{M}(\\mathrm{div\\_checked}(x,y) + 1) = \\mathrm{div\\_checked}(x,y) + 1$。\n- 环境 $(10, 0, 0)$：\n  - $\\llbracket E_1 \\rrbracket((10,0,0))$: $\\mathrm{div\\_checked}(10,0)$ 未定义。$\\mathrm{is\\_defined}(\\dots)$ 为假 ($0$)。`if` 语句对假分支求值，得到确定的结果 $0$。\n  - $\\llbracket \\mathcal{M}(E_1) \\rrbracket((10,0,0))$: $\\mathrm{div\\_checked}(10,0) + 1$ 试图计算除以零，导致未定义的结果。\n- 结果不同（$0$ vs. 未定义）。因此，等价性为 $0$。\n\n**测试用例 2：** $E_2 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x \\times 2,\\, -1)$\n- 变异后的程序：$\\mathcal{M}(E_2) = \\mathcal{M}(x \\times 2) = x \\times 2$。\n- 条件 $\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1))$ 对任何整数 $x$ 始终为真，因为除以 $1$ 总是确定的。\n- 因此，$\\llbracket E_2 \\rrbracket(\\rho)$ 总是对真分支 $x \\times 2$ 求值，这与变异后的程序 $\\mathcal{M}(E_2)$ 相同。\n- 程序对所有输入都是等价的。因此，等价性为 $1$。\n\n**测试用例 3：** $E_3 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)),\\, \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z),\\, 7),\\, 8)$\n- 变异后的程序：变异算子被递归应用。外层 `if` 的条件匹配该模式，因此它被其真分支的变异结果所取代。真分支是另一个也匹配该模式的 `if`。\n  - $\\mathcal{M}(E_3) = \\mathcal{M}(\\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)), \\dots, 7))$\n  - $= \\mathcal{M}(\\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z)) = \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z)$。\n- 环境 $(12, 0, 2)$：\n  - $\\llbracket E_3 \\rrbracket((12,0,2))$: $\\mathrm{div\\_checked}(12,0)$ 未定义。外层的 `is_defined` 为假 ($0$)。`if` 语句对假分支求值，得到确定的结果 $8$。\n  - $\\llbracket \\mathcal{M}(E_3) \\rrbracket((12,0,2))$: 由于第一项，$\\mathrm{div\\_checked}(12,0) + \\mathrm{div\\_checked}(0,2)$ 是未定义的。\n- 结果不同（$8$ vs. 未定义）。因此，等价性为 $0$。\n\n**测试用例 4：** $E_4 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x + 0,\\, x + 0)$\n- 变异后的程序：$\\mathcal{M}(E_4) = \\mathcal{M}(x+0) = x+0$。\n- 条件 $\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1))$ 始终为真。原始程序总是对真分支 $x+0$ 求值。\n- 真分支和假分支是相同的，而变异后的程序也等价于 $x+0$。因此，原始程序和变异程序对于所有输入都将产生相同的结果。\n- 程序是等价的。因此，等价性为 $1$。\n\n测试用例的最终结果是 $[0, 1, 0, 1]$。", "answer": "```c\n#include", "id": "3642978"}, {"introduction": "无用代码消除 (Dead Code Elimination, DCE) 是一项基础的编译器优化，但当代码包含不易察觉的副作用时，这项优化很容易出错。本实践 [@problem_id:3643049] 将指导你运用“蜕变测试” (Metamorphic Testing) 这一强大的模糊测试技术来验证DCE的正确性。你将通过构造和比较两个程序变体（一个执行被测代码块，一个不执行）来学习如何自动检测编译器是否错误地移除了具有全局状态、volatile内存或原子操作等副作用的代码。", "problem": "要求您在对编译器进行模糊测试（fuzzing）的背景下，为死代码消除（dead code elimination）设计并实现一个蜕变测试生成器和检查器。目标是捕获一个在常量守卫（constant guards）下成立的语义保持关系，并检测因遗漏副作用（side effects）而导致的违规行为。您将使用一个小型、确定性的命令式核心，该核心对可观察输出进行建模。最终交付物必须是一个完整的、可运行的程序，该程序能以指定的确切格式产生单行输出。\n\n本练习的基本原理源于编译器理论中的两条原则：\n- 语义保持优化（Semantics-preserving optimization）：如果一个变换将程序 $P$ 映射到 $P'$，使得对于所有初始状态，两者都产生相同的可观察行为，则该变换是有效的。\n- 死代码消除（Dead Code Elimination, DCE）：不影响程序可观察行为的代码可以被消除。对于一个常量守卫，如果一个代码块由一个可证明恒为假的条件守护，那么当该代码块没有副作用时，执行或移除该代码块都不得改变可观察输出。\n\n我们将程序的可见行为定义为执行后测得的输出向量。设程序为一个函数 $E(P, \\sigma) \\rightarrow \\mathbf{o}$，它将程序 $P$ 和初始状态 $\\sigma$ 映射到一个输出向量 $\\mathbf{o}$。对于一个常量守卫 $G \\in \\{0,1\\}$ 和一个代码块 $B$：\n- 如果 $B$ 是纯的（没有副作用且不改变可观察输出），那么 $G = 0$ 的程序和 $G = 1$ 的同一程序必须具有相同的 $\\mathbf{o}$，即 $E(P; G \\!=\\! 0, \\sigma) = E(P; G \\!=\\! 1, \\sigma)$。\n- 如果 $B$ 具有副作用（例如，写入全局状态、写入易失性位置、原子操作），那么切换常量守卫可能会改变 $\\mathbf{o}$，这表明 $B$ 影响了可观察行为，因此在 DCE 下不得被消除。\n\n您的任务是：\n1. 为一个小型、安全的命令式操作子集实现一个确定性求值器，其可观察输出如下：\n   - 一个根据输入 $a$ 和 $b$ 计算出的结果 $r = a \\cdot b + b + a$。\n   - 一个全局状态 $g$。\n   - 一个易失性接收器 $v$。\n   - 一个原子计数器 $c$。\n   可观察输出向量为 $\\mathbf{o} = [r, g, v, c]$。\n\n2. 实现一个蜕变检查器，它对程序的两个版本进行求值：一个版本将常量守卫设置为 $0$（受保护的代码块不执行），另一个版本将常量守卫设置为 $1$（受保护的代码块执行）。对于每个测试用例，计算距离\n   $$ d = |r_0 - r_1| + |g_0 - g_1| + |v_0 - v_1| + |c_0 - c_1|, $$\n   其中 $\\mathbf{o}_0 = [r_0, g_0, v_0, c_0]$ 是 $G = 0$ 时的输出，$\\mathbf{o}_1 = [r_1, g_1, v_1, c_1]$ 是 $G = 1$ 时的输出。$d = 0$ 的值表示在死代码消除下具有蜕变等价性；$d \\neq 0$ 的值则揭示了可能由副作用引起的可观察差异。\n\n3. 使用一个固定的测试套件，该套件涵盖：\n   - 一般情况，即受保护的代码块是纯的且不影响输出。\n   - 边界条件，例如空代码块。\n   - 重要的边界情况，即受保护的代码块包含副作用（全局写入、易失性写入、原子操作）。\n\n该迷你语言在受保护的代码块内支持以下指令类型：\n- 对局部变量 $x$ 的纯局部算术运算：加上一个常量和乘以一个常量。\n- 副作用操作：\n  - 将全局状态 $g$ 增加一个常量。\n  - 向易失性接收器 $v$ 写入一个常量。\n  - 对原子计数器 $c$ 执行原子性的“取值并加”操作，增加一个常量。\n\n基础程序使用输入 $(a,b)$ 并计算 $r = a \\cdot b + b + a$，如果受保护的代码块是纯的，则该计算独立于此代码块。在任何测试中，受保护的代码块都不会直接修改 $r$。\n\n测试套件（所有初始状态和常量均为整数，选择这些值是为了避免未定义行为）：\n- 用例 1（仅纯局部更改）：\n  - 输入：$(a,b) = (3,4)$。\n  - 初始状态：$(g,v,c) = (10,100,0)$。\n  - 代码块：将局部变量 x 加 5，然后将局部变量 x 乘以 2。\n  - 预期的蜕变结果：$d = 0$。\n- 用例 2（全局副作用）：\n  - 输入：$(a,b) = (2,5)$。\n  - 初始状态：$(g,v,c) = (0,0,0)$。\n  - 代码块：将全局变量 g 增加 7。\n  - 预期的蜕变结果：$d = 7$。\n- 用例 3（空代码块边界）：\n  - 输入：$(a,b) = (0,0)$。\n  - 初始状态：$(g,v,c) = (0,0,0)$。\n  - 代码块：空。\n  - 预期的蜕变结果：$d = 0$。\n- 用例 4（易失性副作用）：\n  - 输入：$(a,b) = (7,1)$。\n  - 初始状态：$(g,v,c) = (0,3,2)$。\n  - 代码块：通过增量方式向易失性接收器 v 写入 3。\n  - 预期的蜕变结果：$d = 3$。\n- 用例 5（原子副作用）：\n  - 输入：$(a,b) = (4,2)$。\n  - 初始状态：$(g,v,c) = (1,0,5)$。\n  - 代码块：对 c 执行原子性的“取值并加”操作，增加 5。\n  - 预期的蜕变结果：$d = 5$。\n- 用例 6（混合纯操作和副作用）：\n  - 输入：$(a,b) = (1,3)$。\n  - 初始状态：$(g,v,c) = (2,8,0)$。\n  - 代码块：将局部变量 x 加 1，将全局变量 g 增加 4，向 v 进行易失性写入 2，对 c 进行原子加 1。\n  - 预期的蜕变结果：$d = 7$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含按测试套件用例顺序排列的结果，结果为逗号分隔的列表，并用方括号括起来：\n  - 对于上述测试套件，程序必须按以下格式打印单行：\n    $[d_1,d_2,d_3,d_4,d_5,d_6]$.\n- 不应打印任何额外文本。\n\n不涉及物理单位。角度不适用。如果需要，请将任何小数表示为十进制数，尽管本测试套件仅使用整数。", "solution": "用户提供了一个有效的问题陈述。该问题在科学上基于编译器理论的原理，特别是关于语义保持优化（如死代码消除，DCE）和副作用处理。该问题定义明确，具有清晰的目标、确定性的计算模型以及一套完整的测试用例和预期结果。语言客观且正式。注意到“易失性写入”操作的措辞存在轻微歧义，但通过遵循所提供预期结果的一致性解释得以解决。\n\n核心任务是为编译器的 DCE 优化实现一个蜕变测试。蜕变测试是一种在形式化谕示（formal oracle，即预期正确输出的来源）不可用时，用于验证软件属性的技术。它转而检查不同程序输入及其相应输出之间数学关系（称为蜕变关系）的保持情况。\n\n在此背景下，蜕变关系涉及一个包含由常量条件守护的代码块 $B$ 的程序 $P$。设 $E(P, \\sigma) \\rightarrow \\mathbf{o}$ 是一个函数，它在初始状态 $\\sigma$ 下执行程序 $P$ 以产生一个可观察的输出向量 $\\mathbf{o}$。两个测试输入是同一程序的两个变体：一个变体中代码块 $B$ 由一个恒为假的条件（例如 `if (0)`）守护，另一个变体中守卫条件恒为真（例如 `if (1)`）。\n\n如果代码块 $B$ 是“纯”的，意味着它对程序的可观察状态没有副作用，那么一个正确的 DCE 优化可以完全消除该代码块及其守卫。在这种情况下，无论该代码块名义上是否被执行，可观察输出都必须相同。这得出了蜕变关系：\n$$\nE(P; G = 0, \\sigma) = E(P; G = 1, \\sigma)\n$$\n其中 $G \\in \\{0, 1\\}$ 是常量守卫。\n\n然而，如果代码块 $B$ 包含副作用（例如，修改全局变量、执行 I/O 或执行原子操作），那么即使它对某个特定的计算结果没有贡献，它也不再是“死代码”。一个正确的编译器不能消除这样的代码块，其执行会改变可观察状态。这会导致对蜕变关系的违反，即 $E(P; G = 0, \\sigma) \\neq E(P; G = 1, \\sigma)$。检测这种差异是我们测试的目标。\n\n可观察输出向量定义为 $\\mathbf{o} = [r, g, v, c]$，其中：\n- $r$ 是一个计算结果，$r = a \\cdot b + b + a$，由程序输入 $(a,b)$ 导出。\n- $g$ 是一个全局整型变量。\n- $v$ 是一个易失性整型接收器，用于模拟一个其修改是可观察副作用的内存位置。\n- $c$ 是一个原子整型计数器，用于模拟在并发上下文中必须正确处理的状态。\n\n为了量化两个程序变体输出之间的差异，我们计算输出向量 $\\mathbf{o}_0$（对于守卫 $G=0$）和 $\\mathbf{o}_1$（对于守卫 $G=1$）之间的曼哈顿距离 $d$：\n$$\nd = |r_0 - r_1| + |g_0 - g_1| + |v_0 - v_1| + |c_0 - c_1|\n$$\n距离 $d=0$ 表示蜕变关系成立，表明受保护的代码块相对于可观察状态是纯的。距离 $d \\neq 0$ 表示关系被破坏，正确地识别了副作用的存在。\n\n实现策略如下：\n1.  定义数据结构来表示测试用例参数（`TestCase`）、初始状态（`InitialState`）、程序的运行时状态（`RuntimeState`，包括 `_Atomic` 计数器）和最终输出向量（`OutputVector`）。\n2.  实现一个求值函数 `evaluate`，用于模拟程序执行。该函数接受一个测试用例和一个守卫值（$0$ 或 $1$）作为输入。它初始化 `RuntimeState`，计算结果 $r$，并且如果守卫为 $1$，则调用一个辅助函数 `execute_guarded_block` 来应用受保护代码块内的操作。最后，它组装并返回 `OutputVector`。\n3.  `execute_guarded_block` 函数使用 `switch` 语句为 6 个测试用例中的每一个实现逻辑。它通过指针修改传入的 `RuntimeState`。涉及全局状态 $g$、易失性接收器 $v$ 和原子计数器 $c$ 的操作直接修改 `RuntimeState` 结构中的相应字段。原子操作使用 `stdatomic.h` 中的函数正确实现，以模拟编译器必须遵守的语义。\n4.  `main` 函数将测试套件定义为 `TestCase` 结构体数组。它遍历此数组，为每个测试用例调用 `evaluate` 函数（守卫分别为 $G=0$ 和 $G=1$）以获得 $\\mathbf{o}_0$ 和 $\\mathbf{o}_1$。\n5.  对于每个测试用例，它计算距离 $d$ 并存储它。\n6.  最后，它以精确的格式 $[d_1,d_2,d_3,d_4,d_5,d_6]$ 打印所有计算出的距离。\n\n问题描述中的一个轻微歧义，“write $X$ to $Y$ by increment”（通过增量将 $X$ 写入 $Y$），对于易失性写入和全局写入均被解释为 `Y += X`，因为这种解释是唯一能产生所提供的预期结果的解释，从而确保了内部一致性。", "answer": "```c\n#include", "id": "3643049"}, {"introduction": "许多高级编译器优化，例如循环不变量代码外提 (Loop Invariant Code Motion, LICM)，其安全性高度依赖于精确的静态分析，特别是别名分析 (Alias Analysis)。本实践 [@problem_id:3643001] 让你扮演编译器设计者和模糊测试者的双重角色，去实现一个用于验证LICM安全性的核心逻辑。你将基于一个形式化的内存模型来判定一个循环内的加载操作是否能被安全地外提，从而深入理解优化与分析之间的复杂相互作用，以及如何设计模糊测试用例来攻击这种依赖关系。", "problem": "您需要编写一个完整、可运行的程序，该程序使用一个简化的、可靠的别名分析模型来评估在循环不变代码外提（LICM）下将加载操作移出循环的安全性。其目的是模拟一个模糊测试工具，该工具生成指针密集型模式，并验证LICM是否仅外提那些通过无别名推理可证明为不变的加载。\n\n基本原理。从编译器理论中的以下标准定义开始：\n\n- 内存地址被建模为序对 $\\left(i, o\\right)$，其中 $i$ 是一个内存对象标识符（一个用于区分不同分配的整数索引），$o$ 是该对象内的字节偏移量。两个地址 $\\left(i, o\\right)$ 和 $\\left(j, p\\right)$ 发生别名，当且仅当 $i = j$ 且 $o = p$。\n- 循环归纳变量 $k$ 在整数范围内以单位步长变化，$k \\in \\left[L, U\\right)$，其中 $L$ 和 $U$ 是整数，迭代集合为 $\\{L, L+1, \\dots, U-1\\}$。\n- 加载地址是循环变量的仿射（线性）函数，$o_L(k) = a_L \\cdot k + b_L$，其中 $a_L$ 和 $b_L$ 是整数。存储地址类似，$o_S(k) = a_S \\cdot k + b_S$。\n- 循环不变表达式是指其值在循环的各次迭代中不发生变化的表达式。对于加载地址，这意味着 $a_L = 0$（因此 $o_L(k) = b_L$ 对所有 $k$ 都是常量）。\n- 循环不变代码外提（LICM）可以将循环内的加载操作提升到循环之前的位置，当且仅当该加载的地址是循环不变的，并且所读取的内存位置不被循环内的任何存储操作所覆盖（clobber）。在上述别名模型下，这意味着对于任何迭代 $k \\in [L,U)$，都不得存在地址与该加载地址发生别名的存储操作。\n\n您的程序必须实现以下逻辑推导和决策过程：\n\n1.  对于给定的加载地址 $o_L(k) = a_L \\cdot k + b_L$，外提的一个必要条件是地址的循环不变性。即，检查 $a_L = 0$。如果 $a_L \\neq 0$，则该加载不能被外提。\n2.  假设 $a_L = 0$，则加载地址是对象 $i_L$ 内的常量偏移量 $b_L$。对于循环中每个地址为 $o_S(k) = a_S \\cdot k + b_S$ 且写入对象 $i_S$ 的存储操作：\n    - 如果 $i_S \\neq i_L$，根据不同对象的定义，该存储不可能与加载发生别名，可以忽略。\n    - 如果 $i_S = i_L$ 且 $a_S = 0$，则该存储与加载发生别名，当且仅当 $b_S = b_L$。\n    - 如果 $i_S = i_L$ 且 $a_S \\neq 0$，则该存储与加载发生别名，当且仅当存在一个整数 $k \\in [L, U)$ 使得 $a_S \\cdot k + b_S = b_L$。这等价于存在一个整数解\n        $$ k = \\frac{b_L - b_S}{a_S} $$\n        该解同时满足 $a_S \\mid (b_L - b_S)$ 和 $L \\le k  U$。\n3.  LICM外提是安全的，当且仅当地址是循环不变的，并且循环中没有任何存储操作在任何迭代中与加载发生别名。\n\n建模说明：\n\n- 别名模型通过构造将不同的内存对象标识符视为不相交的，这代表了从分配来源或限定不相交性推导出的无别名证明。在同一对象内，别名问题简化为偏移量的整数相等性问题。\n- 循环是单位步长的，因此迭代集是一个连续的整数区间。您必须使用精确的整数算术来测试可除性和边界。\n\n输入模型。没有输入。您的程序必须嵌入并评估以下固定的测试套件。每个测试包含边界 $L$、$U$、一个加载描述 $(i_L, a_L, b_L)$ 以及一个存储列表 $\\{(i_{S_t}, a_{S_t}, b_{S_t})\\}_{t=1}^m$。\n\n测试套件：\n\n- 测试 $1$：$L=0$, $U=10$, 加载 $(i_L=0, a_L=0, b_L=16)$; 存储 $\\{(1, 1, 0)\\}$。\n- 测试 $2$：$L=0$, $U=7$, 加载 $(i_L=0, a_L=0, b_L=16)$; 存储 $\\{(0, 0, 24)\\}$。\n- 测试 $3$：$L=0$, $U=5$, 加载 $(i_L=0, a_L=0, b_L=16)$; 存储 $\\{(0, 0, 16)\\}$。\n- 测试 $4$：$L=0$, $U=4$, 加载 $(i_L=2, a_L=0, b_L=8)$; 存储 $\\{(2, 4, 0)\\}$。\n- 测试 $5$：$L=0$, $U=3$, 加载 $(i_L=5, a_L=0, b_L=8)$; 存储 $\\{(5, 3, 1)\\}$。\n- 测试 $6$：$L=0$, $U=5$, 加载 $(i_L=1, a_L=2, b_L=0)$; 存储 $\\{\\}$。\n- 测试 $7$：$L=0$, $U=10$, 加载 $(i_L=6, a_L=0, b_L=8)$; 存储 $\\{(7, 0, 8), (6, 0, 12), (6, 2, 1)\\}$。\n\n您的程序必须为每个测试计算布尔决策“可以安全外提”，该决策根据上述推导得出，结果为 $1$ 表示“可以安全外提”，$0$ 表示“不可以安全外提”。\n\n最终输出格式。您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表，格式完全如下\n$$ [r_1,r_2,r_3,r_4,r_5,r_6,r_7] $$\n其中每个 $r_t$ 对于测试 $t$ 是 $0$ 或 $1$。输出字符串中不允许有空格。此问题中没有物理单位，也没有角度，任何分数值都必须按规定使用精确的整数算术进行计算。", "solution": "该问题要求实现一个决策过程，以确定将加载指令移出循环的安全性，这是一种常见的编译器优化，称为循环不变代码外提（LICM）。安全性检查基于一个已定义的内存地址和别名分析模型。解决方案是通过系统地应用所提供的规则得出的。\n\n内存地址是一个序对 $(i, o)$，其中 $i$ 是一个整数对象标识符，而 $o$ 是一个字节偏移量。两个地址 $(i, o)$ 和 $(j, p)$ 之间发生别名，当且仅当 $i = j$ 且 $o = p$。加载和存储的循环相关地址被建模为循环归纳变量 $k$ 的仿射函数，其中 $k$ 在整数范围 $[L, U)$ 上迭代，即 $k \\in \\{L, L+1, \\dots, U-1\\}$。加载地址偏移量为 $o_L(k) = a_L \\cdot k + b_L$，存储地址偏移量为 $o_S(k) = a_S \\cdot k + b_S$。\n\n决策过程遵循一个两步的逻辑进展。\n\n首先，只有当一个加载的有效地址是循环不变时，才能考虑将其外提。这意味着它的值在一次迭代到下一次迭代之间不会改变。对于地址函数 $o_L(k) = a_L \\cdot k + b_L$，这要求循环归纳变量 $k$ 的系数必须为零。\n$$ a_L = 0 $$\n如果 $a_L \\neq 0$，加载地址会随每次迭代而改变，使其本质上是循环变化的。这样的加载不能被外提，过程判定其为不安全。\n\n其次，如果加载地址是循环不变的（即 $a_L = 0$，所以地址是对象 $i_L$ 内的常量偏移量 $b_L$），我们必须保证循环内的任何存储指令都不会修改（覆盖）这个内存位置。这需要检查循环中的每一个存储与加载的关系。对于每一个由 $(i_S, a_S, b_S)$ 描述的存储，我们分析潜在的别名。\n\n别名分析按以下情况对每个存储进行区分处理：\n1.  **不相交的内存对象**：如果存储操作的对象与加载操作的对象不同，即 $i_S \\neq i_L$，根据问题的定义，它们保证不会发生别名。该存储相对于加载是良性的。\n\n2.  **相同的内存对象，不变的存储地址**：如果存储到相同的对象（$i_S = i_L$），并且其地址也是循环不变的（$a_S = 0$），那么加载和存储都访问常量偏移量。当且仅当这些常量偏移量相等时，才会发生别名：\n    $$ b_S = b_L $$\n    如果此条件成立，则加载在每次迭代中都会被覆盖，外提是不安全的。\n\n3.  **相同的内存对象，变化的存储地址**：如果存储到相同的对象（$i_S = i_L$），但其地址是循环变化的（$a_S \\neq 0$），那么如果存在某个整数迭代 $k$ 在范围 $[L, U)$ 内，使得存储的地址等于加载的地址，就会发生别名。我们必须为整数 $k$ 求解以下方程：\n    $$ a_S \\cdot k + b_S = b_L $$\n    整理以求解 $k$：\n    $$ k = \\frac{b_L - b_S}{a_S} $$\n    为了存在别名，必须同时满足两个条件：\n    a. 该方程必须有整数解 $k$。这当且仅当分子是分母的整数倍时成立，可以使用模运算符进行检查：$(b_L - b_S) \\pmod{a_S} = 0$。\n    b. 整数解 $k$ 必须落在循环的迭代集合内，即 $L \\le k  U$。\n\n如果对于任何一个存储，通过情况2或情况3检测到别名，则无别名的保证被违反，外提是不安全的。\n\nLICM被判定为安全，当且仅当加载地址是循环不变的（$a_L = 0$）并且循环内绝对没有任何存储在任何迭代 $k \\in [L, U)$ 中与加载的地址发生别名。程序为每个测试用例实现了这一逻辑，对于“可以安全外提”产生结果 $1$，对于“不可以安全外提”产生结果 $0$。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3643001"}]}