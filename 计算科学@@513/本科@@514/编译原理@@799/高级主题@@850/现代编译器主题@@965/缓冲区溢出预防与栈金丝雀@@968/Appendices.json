{"hands_on_practices": [{"introduction": "理论知识是实践的基石。在我们将栈金丝雀应用于实际代码之前，首先必须理解编译器实现它所面临的基本权衡。这个练习旨在通过一个简化的成本模型，让你分析两种不同的金丝雀检查代码生成策略。通过计算和比较它们的静态插桩复杂度和动态运行时开销，你将亲身体会到编译器设计中一个核心的挑战：如何在代码结构、编译时复杂度和最终程序的性能之间做出明智的选择[@problem_id:3625563]。", "problem": "编译器插入栈金丝雀（stack canary）插桩来缓解缓冲区溢出。考虑一个包含 $m$ 个函数集合 $\\{f_{1},\\dots,f_{m}\\}$ 的程序。对于函数 $f_{i}$，令 $n_{i}$ 为其返回语句的数量（即其控制流图（CFG）中的退出点数量）。编译器可以为金丝雀检查选择两种代码生成策略：\n- 策略 $\\mathcal{P}$（per-exit）：在每个返回语句处直接插入一个金丝雀检查。\n- 策略 $\\mathcal{S}$（single-epilogue）：通过将每个返回重写为到唯一尾声（epilogue）块的无条件跳转，来将函数重构为单个尾声。该尾声块执行一次金丝雀检查，然后返回。\n\n假设采用以下实际成本模型，其中所有成本均为正常数，且独立于 $i$ 和输入：\n- 在函数序言（prologue）中写入金丝雀的成本为每次动态调用 $c_{\\text{pro}}$ 个周期。\n- 执行一次金丝雀检查的成本为每次执行检查的动态调用点 $c_{\\text{chk}}$ 个周期。\n- 在策略 $\\mathcal{S}$ 中，每次动态调用时，在唯一执行路径上插入的到尾声的无条件跳转成本为 $c_{\\text{jmp}}$ 个周期。\n- 对于策略 $\\mathcal{P}$，假设除了返回本身之外没有引入额外的跳转；金丝雀检查被内联放置在每个返回处。\n\n设在某次特定执行期间，$f_{i}$ 的动态调用次数为 $k_{i}$，并定义总动态调用次数为 $K \\coloneqq \\sum_{i=1}^{m} k_{i}$。假设每次调用都恰好执行 $1$ 个返回点（也就是说，只采用一条退出路径），并且不存在如 $longjmp$ 之类的非局部退出。忽略所有缓存和流水线副作用；将成本建模为所有调用的单次调用成本之和。\n\n任务：\n- 仅使用上述定义和标准渐进符号，根据 $n_{i}$ 论证策略 $\\mathcal{P}$ 和策略 $\\mathcal{S}$ 的单函数静态插桩复杂性类别，并解释它们为何不同。\n- 然后，当使用两种策略中成本更高的一种时，推导整个程序执行过程中最坏情况下的总附加运行时成本（以周期为单位）的紧凑闭式表达式，该表达式应表示为 $K$、$c_{\\text{pro}}$、$c_{\\text{chk}}$ 和 $c_{\\text{jmp}}$ 的函数。以单个简化的解析表达式形式提供此最终最坏情况总成本。不需要四舍五入。最终表达式中不应包含单位。", "solution": "问题陈述经评估有效。它在科学上基于编译器设计和计算机安全的原理，特别是关于基于栈的缓冲区溢出缓解。该问题定义明确，提供了一套清晰一致的定义、假设和成本模型。它客观且无歧义，允许进行严谨、形式化的求解。\n\n我们将按顺序解决这两个任务：首先是静态插桩复杂性，其次是最坏情况下的总附加运行时成本。\n\n### 第一部分：静态插桩复杂性\n\n静态插桩复杂性指的是编译器在编译时修改单个函数 $f_{i}$ 代码的任务的计算复杂性。此复杂性是作为返回语句数量 $n_{i}$ 的函数进行分析的。\n\n对于策略 $\\mathcal{P}$（per-exit），编译器必须对函数 $f_{i}$ 执行以下操作：\n1.  在函数的控制流图（CFG）中识别所有 $n_{i}$ 个返回语句（退出点）。\n2.  在每个这 $n_{i}$ 个位置，插入与金丝雀检查相对应的指令序列。\n\n所执行的工作与必须修改的位置数量成正比。由于 $n_{i}$ 个不同的位置需要插入代码，因此策略 $\\mathcal{P}$ 的静态插桩复杂性属于复杂性类别 $\\Theta(n_{i})$。\n\n对于策略 $\\mathcal{S}$（single-epilogue），编译器必须对函数 $f_{i}$ 执行以下操作：\n1.  创建一个新的基本块，用作公共尾声。该块包含金丝雀检查指令，后跟一个返回指令。此步骤的复杂性相对于 $n_{i}$ 是常数，即 $\\Theta(1)$。\n2.  识别所有 $n_{i}$ 个原始返回语句。\n3.  在每个这 $n_{i}$ 个位置，将返回指令替换为指向新创建的公共尾声块的无条件跳转指令。\n\n主要工作是遍历并修改 $n_{i}$ 个原始返回点。因此，策略 $\\mathcal{S}$ 的静态插桩复杂性也属于复杂性类别 $\\Theta(n_{i})$。\n\n问题问及它们为何不同。虽然两种策略都属于相同的渐进复杂性类别 $\\Theta(n_{i})$，但插桩的性质及其对最终机器代码的影响有显著不同。\n-   **操作类型**：策略 $\\mathcal{P}$ 在 $n_{i}$ 个位置执行*代码插入*。策略 $\\mathcal{S}$ 在 $n_{i}$ 个位置执行*代码替换*（或*修补*），并创建一个新代码块。\n-   **代码大小（代码膨胀）**：对于策略 $\\mathcal{P}$，添加的代码总大小是金丝雀检查代码序列大小的 $n_{i}$ 倍。对于策略 $\\mathcal{S}$，添加的代码包括一个检查代码实例加上 $n_{i}$ 个跳转指令。如果检查代码序列明显大于跳转指令，策略 $\\mathcal{S}$ 会导致代码大小显著减小，尤其是在 $n_{i}$ 很大时。\n-   **CFG 修改**：策略 $\\mathcal{P}$ 仅修改现有基本块的内容。策略 $\\mathcal{S}$ 通过创建一个新节点（尾声块）并将 $n_{i}$ 个终止边重定向到这个新节点来改变 CFG 本身的结构。\n\n总而言之，尽管它们的编译时算法复杂性与 $n_{i}$ 的伸缩方式相同，但这两种策略在实现细节、对最终代码大小的影响以及对控制流图的修改方面有所不同。\n\n### 第二部分：最坏情况下的总附加运行时成本\n\n附加运行时成本是每次函数调用时由金丝雀插桩引入的动态开销。我们首先确定每种策略的单次调用成本。此成本独立于函数索引 $i$ 和返回数量 $n_{i}$，因为问题陈述中指出每次调用恰好执行一条返回路径。\n\n设 $C_{\\mathcal{P}}$ 为策略 $\\mathcal{P}$ 的单次调用附加成本。\n-   在函数序言中写入一个金丝雀，成本为 $c_{\\text{pro}}$。\n-   在唯一执行的退出路径上，执行一次内联金丝雀检查，成本为 $c_{\\text{chk}}$。\n-   没有引入额外的跳转。\n因此，单次调用成本为 $C_{\\mathcal{P}} = c_{\\text{pro}} + c_{\\text{chk}}$。\n\n设 $C_{\\mathcal{S}}$ 为策略 $\\mathcal{S}$ 的单次调用附加成本。\n-   在函数序言中写入一个金丝雀，成本为 $c_{\\text{pro}}$。\n-   执行的退出路径被重写为到尾声的无条件跳转。此跳转成本为 $c_{\\text{jmp}}$。\n-   尾声执行一次金丝雀检查，成本为 $c_{\\text{chk}}$。\n因此，单次调用成本为 $C_{\\mathcal{S}} = c_{\\text{pro}} + c_{\\text{jmp}} + c_{\\text{chk}}$。\n\n问题要求计算使用两种策略中“成本更高”的一种时的总成本。我们必须比较 $C_{\\mathcal{P}}$ 和 $C_{\\mathcal{S}}$。\n$$C_{\\mathcal{S}} - C_{\\mathcal{P}} = (c_{\\text{pro}} + c_{\\text{jmp}} + c_{\\text{chk}}) - (c_{\\text{pro}} + c_{\\text{chk}}) = c_{\\text{jmp}}$$\n问题陈述所有成本均为正常数，所以 $c_{\\text{jmp}} > 0$。这意味着 $C_{\\mathcal{S}} > C_{\\mathcal{P}}$。因此，就动态运行时成本而言，策略 $\\mathcal{S}$ 始终是成本更高的策略。\n\n任何单次函数调用的最坏情况附加成本是两种成本中的最大值：\n$$C_{\\text{worst-per-call}} = \\max(C_{\\mathcal{P}}, C_{\\mathcal{S}}) = C_{\\mathcal{S}} = c_{\\text{pro}} + c_{\\text{chk}} + c_{\\text{jmp}}$$\n整个程序执行过程中的总附加运行时成本是每次动态调用的成本之和。由于最坏情况下的单次调用成本是恒定的，我们将此成本乘以总动态调用次数 $K$。\n$$C_{\\text{total-worst}} = K \\times C_{\\text{worst-per-call}}$$\n代入 $C_{\\text{worst-per-call}}$ 的表达式，我们得到：\n$$C_{\\text{total-worst}} = K (c_{\\text{pro}} + c_{\\text{chk}} + c_{\\text{jmp}})$$\n这就是最坏情况下总附加运行时成本的紧凑闭式表达式。", "answer": "$$\n\\boxed{K(c_{\\text{pro}} + c_{\\text{chk}} + c_{\\text{jmp}})}\n$$", "id": "3625563"}, {"introduction": "从抽象的性能模型转向现实世界的工程决策，是成为一名优秀工程师的关键一步。本练习将你置于一个资源受限的嵌入式系统设计场景中，你的任务是为一个安全关键的控制单元选择合适的栈金丝雀大小。你必须在三个相互冲突的约束之间找到最佳平衡点：安全需求（攻击被检测到的概率）、实时性要求（CPU周期预算）和内存限制（SRAM预算）。这个问题将帮助你理解安全特性的实现并非没有代价，它需要根据具体应用场景进行精确的量化分析和权衡[@problem_id:3625579]。", "problem": "一个嵌入式控制单元使用编译器插入的栈金丝雀来缓解基于栈的缓冲区溢出。一个大小为 $k$ 位的栈金丝雀被放置在每个受保护函数的栈帧中，并在函数返回时进行检查。假设以下基本事实成立：当金丝雀值从所有 $k$ 位字符串中均匀随机抽取，并在***尝试期间保密时，***攻击者的溢出在单次尝试中无声地通过检查的概率为 $2^{-k}$；每个活动的受保护栈帧恰好持有一个金丝雀；复制和比较金丝雀产生的成本与处理的字节数成线性关系。\n\n该设备是单线程的，并运行一个周期性控制循环。中央处理器（CPU）的频率为 $f = 80 \\times 10^{6}$ 周期/秒，循环周期为 $T = 2 \\times 10^{-3}$ 秒。在最坏情况下，在一个周期内，有 $W = 40$ 次受保护函数激活（每次激活创建一个受保护的栈帧，随后销毁它）。编译器用于放置和检查金丝雀的代码序列，其每次激活的固定开销为 $c_{0} = 10$ 个周期，另有与金丝雀大小成比例的额外开销为 $c_{1} = 6$ 个周期/字节，此开销包括了函数序言和尾声的总和。设计者施加了严格的预算，要求金丝雀处理所消耗的 CPU 周期数不得超过每个周期可用 CPU 周期的 $r = 0.015$。\n\n专门用于存储同时活动的栈帧中金丝雀的静态随机存取存储器（SRAM）预算为 $B = 256$ 字节。最多可以有 $D_{\\max} = 40$ 个受保护的栈帧同时活动（最坏情况下的调用深度）。每个金丝雀以整数个字节存储，因此 $k$ 必须是 $8$ 的倍数，每个金丝雀占用 $\\lceil k/8 \\rceil$ 字节。\n\n安全要求是，在单次尝试中，未被检测到的栈破坏尝试的概率必须最多为 $p_{\\mathrm{req}} = 10^{-9}$。在这些约束和假设下，选择 $k$（以位为单位）以最小化开销，同时满足安全要求且不违反时间或 SRAM 约束。给出与所有约束一致的唯一最小的可行 $k$ 值。请以整数位数形式给出最终答案。", "solution": "目标是确定栈金丝雀大小的唯一最小可行整数值（用 $k$ 表示，单位为位），该值需满足所有给定的约束。这些约束涉及安全性、时间（CPU开销）和内存（SRAM使用）。问题还规定 $k$ 必须是 $8$ 的倍数，并且目标是最小化开销。总开销是 $k$ 的一个增函数，因此最小化开销等同于找到 $k$ 的最小可行值。\n\n我们将依次分析每个约束，以推导出 $k$ 的有效范围。\n\n1.  **安全性约束：**\n    攻击者单次溢出尝试未被检测到的概率由 $2^{-k}$ 给出。此概率不得大于所要求的最大概率 $p_{\\mathrm{req}} = 10^{-9}$。这建立了不等式：\n    $$2^{-k} \\le 10^{-9}$$\n    为了解出 $k$，我们对不等式两边取以 2 为底的对数。\n    $$\\log_{2}(2^{-k}) \\le \\log_{2}(10^{-9})$$\n    使用对数性质 $\\log_b(a^c) = c\\log_b(a)$，上式可化简为：\n    $$-k \\le -9 \\log_{2}(10)$$\n    两边乘以 $-1$ 会使不等号反向：\n    $$k \\ge 9 \\log_{2}(10)$$\n    我们可以使用换底公式计算 $\\log_{2}(10)$ 的值：$\\log_{2}(10) = \\frac{\\ln(10)}{\\ln(2)} \\approx \\frac{2.302585}{0.693147} \\approx 3.321928$。\n    $$k \\ge 9 \\times 3.321928 \\approx 29.89735$$\n    由于 $k$ 必须是整数，满足安全性要求的 $k$ 的最小值为 $30$。\n    $$k \\ge 30$$\n\n2.  **时间约束：**\n    在一个控制循环周期 $T = 2 \\times 10^{-3}$ 秒内，可用的CPU总周期数是CPU频率 $f$ 与周期时长的乘积。\n    $C_{\\text{total}} = f \\times T = (80 \\times 10^{6}) \\times (2 \\times 10^{-3}) = 160000$ 周期\n    用于金丝雀处理的预算是此总数的 $r = 0.015$。\n    $C_{\\text{budget}} = r \\times C_{\\text{total}} = 0.015 \\times 160000 = 2400$ 周期\n    每次激活的金丝雀操作成本包括一个固定的开销 $c_{0} = 10$ 个周期，以及一个与金丝雀大小（以字节为单位）成比例的可变部分。由于 $k$ 是 $8$ 的倍数，其大小（以字节为单位）是 $k/8$。可变开销为 $c_{1} = 6$ 周期/字节。每次激活的成本是：\n    $$C_{\\text{activation}} = c_{0} + c_{1} \\times \\frac{k}{8} = 10 + 6 \\times \\frac{k}{8} = 10 + \\frac{3}{4}k$$\n    在最坏情况下，每个周期有 $W = 40$ 次受保护函数激活。每个周期的总开销不得超过预算。\n    $$W \\times C_{\\text{activation}} \\le C_{\\text{budget}}$$\n    $$40 \\times \\left(10 + \\frac{3}{4}k\\right) \\le 2400$$\n    两边除以 $40$：\n    $$10 + \\frac{3}{4}k \\le 60$$\n    $$\\frac{3}{4}k \\le 50$$\n    $$k \\le \\frac{200}{3} \\approx 66.667$$\n    由于 $k$ 必须是整数，时间约束意味着 $k \\le 66$。\n\n3.  **SRAM 约束：**\n    用于金丝雀的 SRAM 预算为 $B = 256$ 字节。此内存必须能容纳最坏情况下同时活动的栈帧数（$D_{\\max} = 40$）所需的金丝雀。每个金丝雀的内存使用量是 $k/8$ 字节。\n    SRAM 总使用量为 $S_{\\text{used}} = D_{\\max} \\times \\frac{k}{8}$。这不能超过预算 $B$。\n    $$D_{\\max} \\times \\frac{k}{8} \\le B$$\n    $$40 \\times \\frac{k}{8} \\le 256$$\n    $$5k \\le 256$$\n    $$k \\le \\frac{256}{5} = 51.2$$\n    由于 $k$ 必须是整数，这意味着 $k \\le 51$。这个上界比时间约束得出的上界更严格。\n\n4.  **综合约束与最小化：**\n    我们必须找到一个同时满足所有推导条件的整数 $k$：\n    - 来自安全性约束：$k \\ge 30$。\n    - 来自 SRAM 约束：$k \\le 51$。\n    - 来自问题陈述：$k$ 必须是 $8$ 的倍数。\n\n    结合这些不等式，$k$ 的可行范围是 $30 \\le k \\le 51$。我们现在找出此范围内的 $8$ 的倍数：\n    $8$ 的倍数是 $8, 16, 24, 32, 40, 48, 56, \\dots$。\n    位于区间 $[30, 51]$ 内的倍数是 $32$、$40$ 和 $48$。\n    $k$ 的所有可行值的集合是 $\\{32, 40, 48\\}$。\n\n    问题要求选择 $k$ 以最小化开销。总开销为 $C_{\\text{canary}} = 40 \\times (10 + \\frac{3}{4}k)$，这是 $k$ 的一个单调递增函数。因此，为了最小化开销，我们必须从可行解集中选择最小的值。\n    集合 $\\{32, 40, 48\\}$ 中的最小值是 $32$。\n\n    因此，满足所有要求的唯一最小可行金丝雀大小是 $k=32$ 位。", "answer": "$$\\boxed{32}$$", "id": "3625579"}, {"introduction": "安全防护机制并非总是“一刀切”的。一个先进的编译器能够通过精确的静态分析，智能地优化运行时检查，从而在保证安全的前提下最大程度地减少性能开销。这个练习探讨了这样一个高级优化场景：在递归函数中，编译器通过“健全的范围分析”证明了在某个递归深度之后，缓冲区溢出不可能发生。基于这一证明，我们是否可以安全地省略这些深层调用的金丝雀检查？通过计算节省的性能开销并论证其安全性，你将深入理解静态分析与动态安全机制如何协同工作，以实现既安全又高效的程序[@problem_id:3625643]。", "problem": "一个用于具有自动存储期（栈）语言的现代编译器使用栈金丝雀（stack canaries）来防御缓冲区溢出。在标准方案中，编译器在每个函数的栈帧中，在局部缓冲区和控制数据之间插入一个金丝雀值。在函数进入时，写入金丝雀会产生固定的周期成本；在函数退出时，检查金丝雀也会产生固定的周期成本。考虑一个最大递归深度为 $d$ 的递归函数，这意味着在递归峰值时，调用栈上有 $d$ 个该函数的活动栈帧。假设没有尾调用消除，并且函数在到达基本情况后会一直返回到原始调用者。\n\n仅使用以下基本事实：\n- 每次递归调用都会分配一个新的栈帧，因此在递归峰值时，该函数的活动栈帧数量恰好为 $d$。\n- 对于编译器为其配备金丝雀的每个栈帧，函数序言（prologue）会写入一次金丝雀，函数尾声（epilogue）会检查一次；这些是每个栈帧的常数时间操作。\n- 累计金丝雀成本是整个调用和返回路径上所有配备金丝雀的栈帧的单帧成本之和。\n\n假设测得的周期成本如下：在函数序言中写入金丝雀的成本为 $c_{w} = 9$ 个周期，在函数尾声中检查金丝雀的成本为 $c_{v} = 21$ 个周期。递归深度为 $d = 19$。一个可靠的范围分析（sound range analysis）证明，对于所有深度超过阈值深度 $t = 7$ 的栈帧（深度从最外层调用计为1，每次递归调用加1），在函数的参数不变量下，所有局部缓冲区的写入都在边界之内。根据此证明，一个编译器优化提议在那些深度严格大于 $t$ 的内部栈帧中省略金丝雀的插入，但保留深度为 $1$ 到 $t$ 的栈帧中的金丝雀。\n\n任务：\n1. 根据第一性原理和上述事实，推导在 (i) 完全配备（每个栈帧都有金丝雀）和 (ii) 选择性配备（仅在深度至多为 $t$ 的栈帧中设置金丝雀）两种情况下，累计金丝雀周期成本的表达式，用 $c_{w}$、$c_{v}$、$d$ 和 $t$ 表示。\n2. 使用提供的数值，计算选择性配备相对于完全配备所节省的确切周期数。以单个整数形式给出最终答案。\n3. 基于所述的证明条件，简要论证在内部栈帧（深度大于 $t$）中省略金丝雀是否能保持安全性，并阐明支持你结论的原则。你的论证不应改变任务2中要求的数值结果。\n\n无需近似计算；请为节省的周期数提供一个精确的整数。最终答案框中不要包含任何单位。", "solution": "该问题要求分析一项编译器优化（在递归函数中选择性地省略栈金丝雀）所带来的计算成本节约。解决方案将首先推导成本的一般表达式，然后计算具体的数值节约量，最后根据所提供的信息论证该优化的安全性。\n\n我们先定义给定的参数：\n- $d$：最大递归深度。\n- $t$：省略金丝雀的深度阈值。金丝雀用于深度 $k$ 满足 $1 \\le k \\le t$ 的情况。\n- $c_w$：在函数序言中写入金丝雀的周期成本。\n- $c_v$：在函数尾声中验证金丝雀的周期成本。\n\n递归函数的执行包括一个“调用”阶段，其中递归从深度 $1$ 加深到 $d$；以及一个“返回”阶段，其中函数从深度 $d$ 返回到 $1$。问题陈述中提到没有尾调用消除，因此 $d$ 次调用中的每一次都会创建一个新的栈帧，并且每个栈帧随后在返回时被销毁。\n\n**任务1：累计成本表达式的推导**\n\n**(i) 完全配备成本 ($C_{\\text{full}}$)**\n在完全配备的情况下，从深度 $k=1$ 到 $k=d$ 的每个栈帧都由一个金丝雀保护。\n在调用阶段，在 $d$ 个函数调用的每一个序言中都会写入一个金丝雀。写入金丝雀的总成本是栈帧数乘以每帧的写入成本：\n$$C_{\\text{write, full}} = d \\cdot c_w$$\n在返回阶段，当 $d$ 个函数中的每一个返回时，其尾声都会检查金丝雀。验证金丝雀的总成本是栈帧数乘以每帧的验证成本：\n$$C_{\\text{verify, full}} = d \\cdot c_v$$\n累计金丝雀周期成本是整个执行路径上所有写入和验证成本的总和。\n$$C_{\\text{full}} = C_{\\text{write, full}} + C_{\\text{verify, full}} = d \\cdot c_w + d \\cdot c_v$$\n提取公因数 $d$，我们得到完全配备下的总成本表达式：\n$$C_{\\text{full}} = d (c_w + c_v)$$\n\n**(ii) 选择性配备成本 ($C_{\\text{selective}}$)**\n在选择性配备的情况下，金丝雀仅在深度 $k$ 满足 $1 \\le k \\le t$ 的栈帧中插入和检查。深度 $k > t$ 的栈帧不配备金丝雀。\n因此，配备金丝雀的栈帧数量为 $t$。\n在调用阶段，仅为前 $t$ 个栈帧（深度 $1$ 到 $t$）写入金丝雀。总写入成本为：\n$$C_{\\text{write, selective}} = t \\cdot c_w$$\n同样，在返回阶段，仅对这相同的 $t$ 个栈帧检查金丝雀。总验证成本为：\n$$C_{\\text{verify, selective}} = t \\cdot c_v$$\n选择性配备的累计金丝雀周期成本是这些成本的总和：\n$$C_{\\text{selective}} = C_{\\text{write, selective}} + C_{\\text{verify, selective}} = t \\cdot c_w + t \\cdot c_v$$\n提取公因数 $t$，我们得到选择性配备下的总成本表达式：\n$$C_{\\text{selective}} = t (c_w + c_v)$$\n\n**任务2：节省周期数的计算**\n\n节省的周期数（我们表示为 $S$）是完全配备成本与选择性配备成本之间的差值。\n$$S = C_{\\text{full}} - C_{\\text{selective}}$$\n代入任务1中推导的表达式：\n$$S = d(c_w + c_v) - t(c_w + c_v)$$\n提取公因数 $(c_w + c_v)$:\n$$S = (d - t)(c_w + c_v)$$\n这个表达式表示对于深度大于 $t$ 的 $(d-t)$ 个栈帧，每个栈帧都省去了一次写入和一次检查所带来的节约。\n\n现在，我们代入给定的数值：\n- $d = 19$\n- $t = 7$\n- $c_w = 9$ 周期\n- $c_v = 21$ 周期\n\n计算如下：\n$$S = (19 - 7)(9 + 21)$$\n$$S = (12)(30)$$\n$$S = 360$$\n因此，该优化所节省的确切周期数为 $360$。\n\n**任务3：安全性的论证**\n\n支持此优化安全性的基本原则是：只有当其旨在防范的威胁确实可能发生时，安全缓解措施才是必要的。\n问题陈述中提到，一个“可靠的范围分析证明，对于所有深度超过阈值深度 $t=7$ 的栈帧……所有局部缓冲区的写入都在边界之内”。\n栈金丝雀是一种专门设计用于检测基于栈的缓冲区溢出的防御机制，而缓冲区溢出是越界内存写入的后果。金丝雀被放置在栈上的局部缓冲区和控制数据（如返回地址）之间。如果缓冲区写入溢出其预定边界，它将覆盖金丝雀。函数的尾声会检查金丝雀的值是否被改变，如果被改变，它可以终止程序以防止执行可能被劫持的控制流。\n术语“可靠的范围分析”意味着一个保证正确的形式化证明。该证明确定，对于深度大于 $t$ 的栈帧，任何缓冲区写入都不会超过其分配的边界。如果不可能发生越界写入，那么在这些特定的栈帧中，缓冲区溢出就是不可能的。\n因此，在这些栈帧中设置金丝雀是多余的。它所防范的事件已经被证明不会发生。在深度大于 $t$ 的栈帧中省略金丝雀不会引入漏洞，因为金丝雀所检测的根本条件（缓冲区溢出）已被静态地证明不存在。程序的安全性得以保持，因为它现在依赖于可靠范围分析的形式化证明的正确性，而不是依赖于金丝雀对那些特定栈帧的运行时检测。", "answer": "$$\\boxed{360}$$", "id": "3625643"}]}