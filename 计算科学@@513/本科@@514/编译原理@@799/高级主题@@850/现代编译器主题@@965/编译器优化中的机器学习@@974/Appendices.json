{"hands_on_practices": [{"introduction": "在编译器优化中，许多决策都涉及在潜在收益和风险之间进行权衡。本练习模拟了一个经典的场景：推测性代码移动。我们将探讨如何利用机器学习模型的预测来进行量化的成本效益分析，从而决定是否将一个循环不变量的加载操作提升到循环之外。这个练习的核心是建立一个期望成本模型，让你能够基于模型预测的概率，科学地计算出优化的盈亏平衡点，这对于理解如何在不确定性下做出最优决策至关重要。 [@problem_id:3656426]", "problem": "一个即时优化编译器考虑采用推测性代码移动，在别名关系不确定时将一个循环不变的内存加载提升出循环。为保证正确性，编译器在循环的前置首部插入一个运行时守卫，用于检查非别名情况；如果守卫通过，该加载被提升并在循环前执行一次；如果守卫失败，则执行回退到原始循环。编译器使用机器学习（ML）根据代码特征来预测守卫通过的概率。假设以下科学上真实的成本模型，以处理器周期为单位表示：\n-   不进行推测时，每次循环迭代执行该加载的成本为 $c_{l} = 4$。\n-   运行时守卫的一次性成本为 $c_{g} = 20$。\n-   如果守卫通过，在循环外执行一次提升后的加载，成本为 $c_{o} = 4$。\n-   如果守卫失败，除了执行原始循环外，还有 $c_{f} = 12$ 的回退开销（例如，由于错误预测恢复和控制转移）。\n\n设循环有 $N$ 次迭代。一个逻辑回归模型通过 sigmoid 函数 $\\sigma(u) = \\frac{1}{1+\\exp(-u)}$（其中 $u = \\mathbf{w}^{\\top}\\mathbf{x} + b$）从特征向量 $\\mathbf{x}$、权重向量 $\\mathbf{w}$ 和偏置 $b$ 预测守卫通过的概率 $p$。对于此程序，设\n$\\mathbf{w} = (0.8,\\,-0.5,\\,1.2)$，$\\mathbf{x} = (0.4,\\,0.6,\\,0.3)$，且 $b = -0.1$。\n请使用基于期望和逻辑函数基本定义的、有原则的期望成本分析，确定实值阈值 $N^{\\star}$，使得当 $N > N^{\\star}$ 时，守卫提升策略的期望总周期数严格小于基线（非推测性）策略的周期数。根据给定的数值计算 $N^{\\star}$，并将您的最终答案表示为单个实数。将答案四舍五入到四位有效数字。", "solution": "题目要求计算循环迭代次数的阈值 $N^{\\star}$，当迭代次数超过此阈值时，推测性代码提升策略比基线非推测性策略更高效。这需要进行期望成本分析。\n\n首先，我们定义两种策略的总周期成本。设 $N$ 为循环迭代次数。给定的成本如下：\n-   原始循环中每次迭代加载的成本：$c_{l} = 4$。\n-   运行时守卫的一次性成本：$c_{g} = 20$。\n-   如果守卫通过，提升后加载的一次性成本：$c_{o} = 4$。\n-   如果守卫失败，一次性回退开销：$c_{f} = 12$。\n\n基线策略在所有 $N$ 次迭代中都在循环内部执行加载。其总成本 $C_{base}$ 为：\n$$C_{base} = N c_{l}$$\n\n守卫提升策略是推测性的。其成本取决于运行时守卫的结果。设 $p$ 为守卫通过（非别名）的概率。因此，守卫失败的概率是 $1-p$。\n\n-   如果守卫通过（概率为 $p$），总成本包括守卫成本和单次提升后加载的成本。加载不在循环内执行。\n    $$C_{pass} = c_{g} + c_{o}$$\n-   如果守卫失败（概率为 $1-p$），总成本包括守卫成本、回退开销以及执行原始循环的成本，其中加载仍在每次迭代中执行。\n    $$C_{fail} = c_{g} + c_{f} + N c_{l}$$\n\n推测性策略的期望总成本 $E[C_{spec}]$ 是这两种结果的加权平均值：\n$$E[C_{spec}] = p \\cdot C_{pass} + (1-p) \\cdot C_{fail}$$\n$$E[C_{spec}] = p(c_{g} + c_{o}) + (1-p)(c_{g} + c_{f} + N c_{l})$$\n\n题目要求找到阈值 $N^{\\star}$，使得当 $N > N^{\\star}$ 时，推测性策略严格更优，即其期望成本小于基线成本：\n$$E[C_{spec}]  C_{base}$$\n$$p(c_{g} + c_{o}) + (1-p)(c_{g} + c_{f} + N c_{l})  N c_{l}$$\n\n我们现在求解这个关于 $N$ 的不等式。展开左侧：\n$$p c_{g} + p c_{o} + c_{g} + c_{f} + N c_{l} - p c_{g} - p c_{f} - p N c_{l}  N c_{l}$$\n合并同类项，我们得到：\n$$c_{g} + p c_{o} + c_{f} - p c_{f} + (1-p) N c_{l}  N c_{l}$$\n为了分离 $N$，我们将所有含 $N$ 的项移到一边：\n$$c_{g} + c_{f} + p(c_{o} - c_{f})  N c_{l} - (1-p) N c_{l}$$\n$$c_{g} + c_{f} + p(c_{o} - c_{f})  N c_{l} (1 - (1-p))$$\n$$c_{g} + c_{f} + p(c_{o} - c_{f})  p N c_{l}$$\n由于 $p > 0$ 且 $c_{l} > 0$，我们可以除以 $p c_{l}$ 而不改变不等式的方向：\n$$N > \\frac{c_{g} + c_{f} + p(c_{o} - c_{f})}{p c_{l}}$$\n这就给出了阈值 $N^{\\star}$ 的表达式：\n$$N^{\\star} = \\frac{c_{g} + c_{f} + p(c_{o} - c_{f})}{p c_{l}}$$\n\n接下来，我们必须使用给定的逻辑回归模型计算概率 $p$。sigmoid 函数的输入是 $u = \\mathbf{w}^{\\top}\\mathbf{x} + b$。给定的向量为 $\\mathbf{w} = (0.8,\\,-0.5,\\,1.2)$ 和 $\\mathbf{x} = (0.4,\\,0.6,\\,0.3)$。形式上，它们是列向量：\n$$\\mathbf{w} = \\begin{pmatrix} 0.8 \\\\ -0.5 \\\\ 1.2 \\end{pmatrix}, \\quad \\mathbf{x} = \\begin{pmatrix} 0.4 \\\\ 0.6 \\\\ 0.3 \\end{pmatrix}$$\n偏置为 $b = -0.1$。我们计算 $u$：\n$$u = \\mathbf{w}^{\\top}\\mathbf{x} + b = \\begin{pmatrix} 0.8  -0.5  1.2 \\end{pmatrix} \\begin{pmatrix} 0.4 \\\\ 0.6 \\\\ 0.3 \\end{pmatrix} - 0.1$$\n$$u = (0.8)(0.4) + (-0.5)(0.6) + (1.2)(0.3) - 0.1$$\n$$u = 0.32 - 0.30 + 0.36 - 0.1 = 0.02 + 0.36 - 0.1 = 0.28$$\n概率 $p$ 是 sigmoid 函数 $\\sigma(u)$ 的输出：\n$$p = \\sigma(u) = \\frac{1}{1 + \\exp(-u)} = \\frac{1}{1 + \\exp(-0.28)}$$\n\n现在我们将给定的数值代入 $N^{\\star}$ 的表达式中：\n$c_{l} = 4$, $c_{g} = 20$, $c_{o} = 4$, $c_{f} = 12$。\n$$N^{\\star} = \\frac{20 + 12 + p(4 - 12)}{p \\cdot 4} = \\frac{32 - 8p}{4p} = \\frac{8 - 2p}{p} = \\frac{8}{p} - 2$$\n代入 $p$ 的表达式：\n$$N^{\\star} = \\frac{8}{\\frac{1}{1 + \\exp(-0.28)}} - 2 = 8(1 + \\exp(-0.28)) - 2$$\n$$N^{\\star} = 8 + 8\\exp(-0.28) - 2 = 6 + 8\\exp(-0.28)$$\n现在我们计算数值：\n$$\\exp(-0.28) \\approx 0.75578374$$\n$$N^{\\star} \\approx 6 + 8(0.75578374) = 6 + 6.0462699$$\n$$N^{\\star} \\approx 12.0462699$$\n四舍五入到四位有效数字，我们得到：\n$$N^{\\star} \\approx 12.05$$\n\n因此，对于任何大于 12.05 的循环迭代次数 $N$，守卫提升策略的期望成本都严格小于基线成本。", "answer": "$$\\boxed{12.05}$$", "id": "3656426"}, {"introduction": "机器学习模型并非永远正确，因此在将它们集成到编译器中时，评估其预测错误带来的风险至关重要。本练习将引导你分析不同优化策略对模型预测错误的敏感度。你将学习如何量化“错误预测惩罚”，即因模型做出错误决策而导致的性能损失。通过这个练习，你会发现，并非所有优化的风险都相同，理解这一点对于构建一个稳健的、由机器学习驱动的编译器至关重要。 [@problem_id:3656416]", "problem": "考虑一个使用机器学习（ML）来调整优化遍（optimization passes）的编译器。结果质量（QoR）被定义为预期运行时间。设基线预期运行时间为 $Q_0 = 1.00$ 秒。对于每个遍 $i$，启用它会根据模型\n$$\nQ_{\\text{enable},i} = Q_0 (1 - s_i) + h_i,\n$$\n来改变运行时间，其中 $s_i$ 是真实的分数加速比（$0 \\le s_i  1$），$h_i$ 是以秒为单位的开销（例如，由于代码大小增加或寄存器压力增大）。如果机器学习策略预测的净运行时间 $Q_0 (1 - \\hat{s}_i) + h_i$ 严格小于基线 $Q_0$，它将启用遍 $i$。这等价于 $\\hat{s}_i > h_i / Q_0$。由于 $Q_0 = 1.00$，决策规则简化为 $\\hat{s}_i > h_i$。\n\n假设机器学习模型对每个遍 $i$ 的预测在 $s_i$ 上具有大小为 $\\Delta = 0.02$ 的绝对误差，即 $\\hat{s}_i = s_i \\pm \\Delta$。对于每个遍，将其在误差幅度 $\\Delta$ 下的误预测惩罚（misprediction penalty）定义为：与该遍的最优决策相比，由于对该遍做出错误决策（当最优选择是禁用时启用，或当最优选择是启用时禁用）而可能导致的最大预期运行时间增量，并假设所有其他遍保持不变。对于遍 $i$ 的最优决策是，如果 $Q_{\\text{enable},i}  Q_0$ 则启用，否则禁用。\n\n四个优化遍具有以下真实参数：\n- 循环展开（Loop Unrolling）: $s_A = 0.06$, $h_A = 0.04$。\n- 指令调度（Instruction Scheduling）: $s_B = 0.04$, $h_B = 0.01$。\n- 函数内联（Function Inlining）: $s_C = 0.09$, $h_C = 0.08$。\n- 寄存器压力减小（Register Pressure Reduction）: $s_D = 0.025$, $h_D = 0.03$。\n\n当模型误差为 $\\Delta = 0.02$ 时，哪个单独的优化遍会产生最大的预期运行时间误预测惩罚？\n\n选项：\n- A. 循环展开\n\n- B. 指令调度\n\n- C. 函数内联\n\n- D. 寄存器压力减小", "solution": "用户希望我验证问题，如果问题有效，则求解具有最大误预测惩罚的优化遍。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   基线预期运行时间：$Q_0 = 1.00$ 秒。\n-   启用遍 $i$ 的运行时间模型：$Q_{\\text{enable},i} = Q_0 (1 - s_i) + h_i$。\n-   $s_i$：真实的分数加速比，$0 \\le s_i  1$。\n-   $h_i$：以秒为单位的开销。\n-   机器学习策略决策规则：如果 $\\hat{s}_i > h_i$，则启用遍 $i$。\n-   机器学习模型预测误差：$\\hat{s}_i = s_i \\pm \\Delta$，绝对误差幅度 $\\Delta = 0.02$。这被解释为预测值 $\\hat{s}_i$ 位于区间 $[s_i - \\Delta, s_i + \\Delta]$ 内。\n-   最优决策规则：如果 $Q_{\\text{enable},i}  Q_0$，则启用遍 $i$，这简化为 $s_i > h_i$。否则，禁用。\n-   误预测惩罚定义：与最优决策相比，由错误决策导致的最大可能预期运行时间增量。\n-   遍 A (循环展开): $s_A = 0.06$, $h_A = 0.04$。\n-   遍 B (指令调度): $s_B = 0.04$, $h_B = 0.01$。\n-   遍 C (函数内联): $s_C = 0.09$, $h_C = 0.08$。\n-   遍 D (寄存器压力减小): $s_D = 0.025$, $h_D = 0.03$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，它使用一个简化但合理的线性模型来为编译器优化性能的权衡建模。为此目的使用机器学习是计算机科学中的一个有效概念。该问题是适定（well-posed）的，提供了所有必要的定义、数据和一个明确的问题。所有术语如“误预测惩罚”都得到了明确定义。数据是一致的，并且没有违反任何给定的约束。该问题需要仔细应用定义，而不是一个简单的或结构不良的问题。\n\n**步骤3：结论与行动**\n问题有效。我将继续进行解答。\n\n### 解题推导\n\n分析的目的是找出哪个遍具有最大的误预测惩罚。这个惩罚是当基于机器学习的决策与最优决策相比是错误的时，所产生的运行时间增量。\n\n首先，让我们将运行时间和决策形式化。禁用遍 $i$ 时的基线运行时间是 $Q_{\\text{disable},i} = Q_0 = 1.00$ 秒。启用遍 $i$ 时的运行时间是 $Q_{\\text{enable},i} = Q_0(1-s_i) + h_i = 1.00(1-s_i) + h_i = 1 - s_i + h_i$。\n\n最优决策是在启用该遍能减少运行时间时启用它，即 $Q_{\\text{enable},i}  Q_{\\text{disable},i}$。\n$$\n1 - s_i + h_i  1\n$$\n$$\ns_i > h_i\n$$\n所以，最优策略是：如果 $s_i > h_i$ 则启用，如果 $s_i \\le h_i$ 则禁用。\n\n基于机器学习的策略根据预测的加速比 $\\hat{s}_i$ 做出决策。如果 $\\hat{s}_i > h_i$，它就启用该遍。如果机器学习策略的决策与最优决策不同，就会发生误预测。\n\n误预测惩罚是错误行为的运行时间与最优行为的运行时间之间的差值。对于一个错误的决策，有两种情况：\n\n1.  **错误启用：** 最优决策是禁用（$s_i \\le h_i$），但机器学习模型却启用（$\\hat{s}_i > h_i$）。\n    -   最优决策（禁用）的运行时间：$Q_{opt} = Q_0 = 1.00$。\n    -   错误决策（启用）的运行时间：$Q_{wrong} = 1 - s_i + h_i$。\n    -   惩罚 = $Q_{wrong} - Q_{opt} = (1 - s_i + h_i) - 1 = h_i - s_i$。由于 $s_i \\le h_i$，该值为非负数。\n\n2.  **错误禁用：** 最优决策是启用（$s_i > h_i$），但机器学习模型却禁用（$\\hat{s}_i \\le h_i$）。\n    -   最优决策（启用）的运行时间：$Q_{opt} = 1 - s_i + h_i$。\n    -   错误决策（禁用）的运行时间：$Q_{wrong} = Q_0 = 1.00$。\n    -   惩罚 = $Q_{wrong} - Q_{opt} = 1 - (1 - s_i + h_i) = s_i - h_i$。由于 $s_i > h_i$，该值为正数。\n\n在这两种情况下，如果发生误预测，惩罚的大小为 $|s_i - h_i|$。\n\n只有当机器学习模型的预测 $\\hat{s}_i$ 能够跨越决策边界 $h_i$ 时，才可能发生误预测。已知模型的预测 $\\hat{s}_i$ 位于区间 $[s_i - \\Delta, s_i + \\Delta]$ 内，其中 $\\Delta = 0.02$。当且仅当这个可能的预测区间包含阈值 $h_i$ 时，才会发生误预测。\n-   情况1（错误启用，$s_i \\le h_i$）：只有当 $s_i + \\Delta > h_i$ 时，才可能出现预测 $\\hat{s}_i > h_i$。\n-   情况2（错误禁用，$s_i > h_i$）：只有当 $s_i - \\Delta \\le h_i$ 时，才可能出现预测 $\\hat{s}_i \\le h_i$。\n\n综合这两种情况，当且仅当 $s_i - \\Delta \\le h_i \\le s_i + \\Delta$ 时，才可能发生误预测，这等价于 $|s_i - h_i| \\le \\Delta$。\n\n如果 $|s_i - h_i| > \\Delta$，区间 $[s_i - \\Delta, s_i + \\Delta]$ 不包含 $h_i$。所有可能的预测 $\\hat{s}_i$ 都与真实值 $s_i$ 位于阈值 $h_i$ 的同一侧。因此，机器学习策略将总是做出正确的决策，误预测惩罚为 $0$。\n\n因此，遍 $i$ 的误预测惩罚（表示为 $P_i$）为：\n$$\nP_i = \\begin{cases} |s_i - h_i|  \\text{如果 } |s_i - h_i| \\le \\Delta \\\\ 0  \\text{如果 } |s_i - h_i| > \\Delta \\end{cases}\n$$\n给定 $\\Delta = 0.02$。我们现在为每个遍计算 $P_i$。\n\n**A. 循环展开**\n-   $s_A = 0.06$, $h_A = 0.04$。\n-   差值：$|s_A - h_A| = |0.06 - 0.04| = 0.02$。\n-   条件：$|s_A - h_A| \\le \\Delta$ 是否成立？是，$0.02 \\le 0.02$。\n-   可能发生误预测。最优选择是启用（$s_A > h_A$）。$\\hat{s}_A = s_A - \\Delta = 0.04$ 的预测将导致“禁用”决策（因为 $0.04 \\ngtr 0.04$）。\n-   惩罚：$P_A = |s_A - h_A| = 0.02$ 秒。\n\n**B. 指令调度**\n-   $s_B = 0.04$, $h_B = 0.01$。\n-   差值：$|s_B - h_B| = |0.04 - 0.01| = 0.03$。\n-   条件：$|s_B - h_B| \\le \\Delta$ 是否成立？否，$0.03 > 0.02$。\n-   不可能发生误预测。预测区间为 $[0.04-0.02, 0.04+0.02] = [0.02, 0.06]$。所有可能的 $\\hat{s}_B$ 都大于 $h_B = 0.01$，所以机器学习模型将总是正确地启用该遍。\n-   惩罚：$P_B = 0$ 秒。\n\n**C. 函数内联**\n-   $s_C = 0.09$, $h_C = 0.08$。\n-   差值：$|s_C - h_C| = |0.09 - 0.08| = 0.01$。\n-   条件：$|s_C - h_C| \\le \\Delta$ 是否成立？是，$0.01 \\le 0.02$。\n-   可能发生误预测。最优选择是启用（$s_C > h_C$）。在 $[0.07, 0.08]$ 范围内的预测将导致错误的“禁用”决策。\n-   惩罚：$P_C = |s_C - h_C| = 0.01$ 秒。\n\n**D. 寄存器压力减小**\n-   $s_D = 0.025$, $h_D = 0.03$。\n-   差值：$|s_D - h_D| = |0.025 - 0.03| = |-0.005| = 0.005$。\n-   条件：$|s_D - h_D| \\le \\Delta$ 是否成立？是，$0.005 \\le 0.02$。\n-   可能发生误预测。最优选择是禁用（$s_D  h_D$）。在 $(0.03, 0.045]$ 范围内的预测将导致错误的“启用”决策。\n-   惩罚：$P_D = |s_D - h_D| = 0.005$ 秒。\n\n**结论**\n比较惩罚值：\n-   $P_A = 0.02$\n-   $P_B = 0$\n-   $P_C = 0.01$\n-   $P_D = 0.005$\n最大的误预测惩罚是 $0.02$ 秒，对应于循环展开遍。\n\n### 逐项分析\n\n-   **A. 循环展开**：计算出的误预测惩罚为 $P_A = 0.02$ 秒。这是四个遍中的最大值（$0.02 > 0$，$0.02 > 0.01$，$0.02 > 0.005$）。因此，该遍产生最大的误预测惩罚。**正确**。\n\n-   **B. 指令调度**：对于此遍， $|s_B - h_B| = 0.03 > \\Delta = 0.02$。鉴于模型的误差幅度，不可能发生误预测。惩罚为 $P_B = 0$。这不是最大的惩罚。**错误**。\n\n-   **C. 函数内联**：计算出的误预测惩罚为 $P_C = 0.01$ 秒。这小于循环展开的惩罚（$0.01  0.02$）。**错误**。\n\n-   **D. 寄存器压力减小**：计算出的误预测惩罚为 $P_D = 0.005$ 秒。这小于循环展开和函数内联的惩罚。**错误**。\n\n产生最大误预测惩罚的单个遍是循环展开。", "answer": "$$\\boxed{A}$$", "id": "3656416"}, {"introduction": "将机器学习模型应用于编译过程的每个函数会带来巨大的计算开销，因此缓存预测结果是提高效率的关键。然而，缓存必须是“安全的”，即当代码在编译早期阶段发生变化时，我们必须能够判断缓存的预测是否仍然有效。本练习要求你从第一性原理出发，设计并实现一个安全的缓存重用规则。你将结合使用哈希技术来验证代码的关键部分是否未变，并使用一个基于模型属性的误差界限来容忍非关键部分的变化，从而深入了解在动态环境中部署机器学习的实际工程挑战。 [@problem_id:3656494]", "problem": "您正在为一个编译器构建一个用于机器学习预测的缓存，该编译器在每个函数的基础上使用这些预测来指导优化。每个函数都由一个中间表示（IR）表示，从中提取一个定长的特征向量。早期的IR遍（pass）可能会在重用缓存的预测之前改变IR，因此您的缓存必须使用一个从IR签名派生的代码哈希和一个有原则的失效规则来确保安全性。您的任务是从第一性原理出发，形式化重用条件，并实现一个程序将其应用于一个小型测试套件。\n\n基本基础：\n- 一个特征提取器将一个函数的IR映射到一个数值特征向量 $\\mathbf{f} \\in \\mathbb{R}^{d}$，对于相同的IR状态，该向量在多次编译中是一致的。\n- 一个确定性的机器学习模型通过函数 $M:\\mathbb{R}^{d} \\to \\mathbb{R}$ 将特征映射到一个标量预测值 $y \\in \\mathbb{R}$。\n- 一个确定性的哈希函数 $H$ 将一个字符串和一个整数元组映射到一个机器字，并用于派生缓存键。碰撞是可能的，但很罕见，在本练习中被忽略。\n- 特征维度的一个子集在一组早期IR遍下被指定为“稳定的”。设 $\\mathbf{s} \\in \\{0,1\\}^{d}$ 是一个二进制掩码，如果第 $i$ 个特征被包含在哈希签名中并被视为对稳定性至关重要，则 $s_{i}=1$。\n- 失效规则必须是安全的，这意味着如果缓存被重用，重用的预测值与早期遍后假设的重新计算的预测值之间的偏差，必须以一种可从模型结构和观察到的IR差异中推导出的方式进行限定。\n\n本问题中使用的模型和表示：\n- 模型是线性的：$M(\\mathbf{f}) = \\mathbf{w}^{\\top}\\mathbf{f} + b$，其中权重向量为 $\\mathbf{w} \\in \\mathbb{R}^{d}$，偏置为 $b \\in \\mathbb{R}$。\n- 通过将函数标识符字符串与由 $\\mathbf{s}$ 选择的特征子向量一起哈希，来构建每个函数的缓存键。\n- 设 $\\mathbf{f}^{(0)}$ 是早期遍之前的特征，$\\mathbf{f}^{(1)}$ 是早期遍之后的特征。哈希签名在插入时从 $\\mathbf{f}^{(0)}$ 构建，在查找时从 $\\mathbf{f}^{(1)}$ 构建。\n- 失效规则必须仅依赖于：两个哈希签名的相等性，以及一个对由于未被哈希的特征维度（那些 $s_{i}=0$ 的维度）的差异而可能导致的 $M(\\cdot)$ 变化的界限。该界限应从模型结构和基本不等式中得出，不假设任何预言机（oracle）。\n\n设计要求：\n- 推导、证明并实现一个保守的重用条件，该条件使用：\n  - 已哈希子向量的哈希签名相等性。\n  - 一个容忍度参数 $\\tau \\in \\mathbb{R}_{\\ge 0}$，它为因未哈希特征的差异而导致模型输出的允许变化设定上限。容忍度作为配置的一部分提供。\n- 如果条件指示可以安全重用，则为该测试用例返回一个为 $1$ 的重用标志；否则返回 $0$。\n\n所有测试用例的配置：\n- 维度 $d = 4$。\n- 权重向量 $\\mathbf{w} = \\langle 0.4, -0.1, 0.2, 0.05 \\rangle$。\n- 偏置 $b = 0.0$。\n- 稳定性掩码 $\\mathbf{s} = \\langle 1, 0, 1, 0 \\rangle$。\n- 容忍度 $\\tau = 0.15$。\n\n测试套件：\n对于每个测试用例，您将获得一个函数标识符、一个初始特征向量 $\\mathbf{f}^{(0)} \\in \\mathbb{Z}^{d}$ 和一个遍处理后的特征向量 $\\mathbf{f}^{(1)} \\in \\mathbb{Z}^{d}$。\n\n- Case A: identifier “foo”, $\\mathbf{f}^{(0)} = \\langle 10, 3, 2, 5 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 10, 4, 2, 4 \\rangle$.\n- Case B: identifier “bar”, $\\mathbf{f}^{(0)} = \\langle 0, 0, 0, 0 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 0, 1, 0, 0 \\rangle$.\n- Case C: identifier “baz”, $\\mathbf{f}^{(0)} = \\langle 7, 2, 3, 1 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 8, 2, 3, 1 \\rangle$.\n- Case D: identifier “qux”, $\\mathbf{f}^{(0)} = \\langle 9, 9, 9, 9 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 9, 13, 9, 3 \\rangle$.\n- Case E: identifier “edge”, $\\mathbf{f}^{(0)} = \\langle 1, 1, 1, 1 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 1, 1, 1, 1 \\rangle$.\n\n程序要求：\n- 实现一个完整的程序，该程序：\n  - 编码上述模型和配置。\n  - 从函数标识符和被掩码的特征子向量计算缓存签名。\n  - 使用您推导出的安全失效规则为每个测试用例决定是否重用。\n- 最终输出格式：\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的整数列表的结果（例如，“[$1,0,1$]”），按 A、B、C、D、E 的顺序为每个测试用例提供一个整数，其中 $1$ 表示“重用缓存的预测”，$0$ 表示“失效并重新计算”。", "solution": "我们使用线性模型和将特征分解为已哈希（对稳定性至关重要）和未哈希（容忍变化）分量的方法，来形式化缓存和失效问题。\n\n基本定义：\n- 设特征维度为 $d \\in \\mathbb{N}$。这里 $d = 4$。\n- 设线性模型为 $M(\\mathbf{f}) = \\mathbf{w}^{\\top}\\mathbf{f} + b$，其中 $\\mathbf{w} \\in \\mathbb{R}^{d}$ 和 $b \\in \\mathbb{R}$ 是由先前训练设定的固定常数。对于本测试，$\\mathbf{w} = \\langle 0.4, -0.1, 0.2, 0.05 \\rangle$ 且 $b = 0.0$。\n- 设稳定性掩码为 $\\mathbf{s} \\in \\{0,1\\}^{d}$，且 $\\mathbf{s} = \\langle 1, 0, 1, 0 \\rangle$。索引 $i$ 若 $s_{i}=1$ 则被包含在代码哈希签名中。\n- 设函数标识符为字符串 $\\text{id}$。令 $H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}))$ 表示标识符和子向量 $\\text{proj}_{\\mathbf{s}}(\\mathbf{f}) = \\{ f_{i} \\mid s_{i}=1 \\}$ 的一个确定性的64位哈希。\n- 对每个函数，我们观察到一对 $(\\mathbf{f}^{(0)}, \\mathbf{f}^{(1)})$，其中 $\\mathbf{f}^{(0)}$ 在早期IR遍之前，$\\mathbf{f}^{(1)}$ 在它们之后。\n\n基于原则的安全失效规则推导：\n- 缓存应仅在满足以下两个条件时重用：\n  1. 已哈希的对稳定性至关重要的内容的等效性得到保持。这通过 $H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(0)})) = H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(1)}))$ 来体现。这依赖于 $H$ 的确定性以及掩码 $\\mathbf{s}$ 表征了其变化必须强制失效的子空间的假设。\n  2. 由未哈希特征的差异引起的模型输出变化是可证明地小的。对于线性模型，对于任意 $\\mathbf{u}, \\mathbf{v} \\in \\mathbb{R}^{d}$，\n     $$\n     \\left|M(\\mathbf{u}) - M(\\mathbf{v})\\right| = \\left|\\mathbf{w}^{\\top}(\\mathbf{u}-\\mathbf{v})\\right|.\n     $$\n     使用掩码 $\\mathbf{s}$ 将差异分解为已哈希和未哈希的坐标。如果已哈希的坐标未改变（由哈希相等性强制），则只有未哈希的坐标产生贡献。设 $\\Delta \\mathbf{f} = \\mathbf{f}^{(1)} - \\mathbf{f}^{(0)}$。考虑索引集 $U = \\{ i \\mid s_{i} = 0 \\}$。则\n     $$\n     \\left|M(\\mathbf{f}^{(1)}) - M(\\mathbf{f}^{(0)})\\right| = \\left|\\sum_{i \\in U} w_{i} \\Delta f_{i}\\right| \\le \\sum_{i \\in U} \\left|w_{i}\\right| \\cdot \\left|\\Delta f_{i}\\right|.\n     $$\n     该不等式源于实数的三角不等式。这仅使用逐坐标的绝对变化和绝对权重，就为模型输出偏差提供了最坏情况的界限。如果此界限小于或等于一个容忍度 $\\tau \\in \\mathbb{R}_{\\ge 0}$（由系统设计者设定），则在指定的容忍度下重用缓存的预测是安全的；否则，失效。\n\n因此，保守的重用规则是：\n- 当且仅当同时满足以下两个条件时重用：\n  - $H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(0)})) = H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(1)}))$, 且\n  - $\\sum_{i: s_{i}=0} \\left|w_{i}\\right| \\cdot \\left|f^{(1)}_{i} - f^{(0)}_{i}\\right| \\le \\tau$。\n\n算法设计：\n- 使用一个固定的64位滚动哈希，将函数标识符与被掩码的整数特征混合，计算 $h_{0} = H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(0)}))$ 和 $h_{1} = H(\\text{id}, \\text{proj}_{\\mathbf{s}}(\\mathbf{f}^{(1)}))$。确定性确保相同的输入产生相同的输出。\n- 如果 $h_{0} \\ne h_{1}$，返回重用标志 $0$。\n- 否则，计算未哈希部分的偏差界限 $B = \\sum_{i: s_{i}=0} \\left|w_{i}\\right| \\cdot \\left|f^{(1)}_{i} - f^{(0)}_{i}\\right|$ 并与 $\\tau$ 比较；如果 $B \\le \\tau$，返回重用标志 $1$，否则返回 $0$。\n\n对所提供测试套件的手动推理，其中 $\\mathbf{w} = \\langle 0.4, -0.1, 0.2, 0.05 \\rangle$, $b = 0.0$, $\\mathbf{s} = \\langle 1, 0, 1, 0 \\rangle$, 且 $\\tau = 0.15$：\n- Case A: “foo”, $\\mathbf{f}^{(0)} = \\langle 10, 3, 2, 5 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 10, 4, 2, 4 \\rangle$。哈希坐标（0-索引：0和2）未改变。未哈希坐标（0-索引：1和3）的差异：$\\left|\\Delta f_{1}\\right| = |4-3| = 1$, $\\left|\\Delta f_{3}\\right| = |4-5| = 1$。界限 $B = |w_1| \\cdot |\\Delta f_1| + |w_3| \\cdot |\\Delta f_3| = |-0.1|\\cdot 1 + |0.05|\\cdot 1 = 0.1 + 0.05 = 0.15 \\le 0.15$。重用标志 $1$。\n- Case B: “bar”, $\\mathbf{f}^{(0)} = \\langle 0, 0, 0, 0 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 0, 1, 0, 0 \\rangle$。哈希坐标未改变。未哈希坐标的差异：$\\left|\\Delta f_{1}\\right| = |1-0| = 1$, $\\left|\\Delta f_{3}\\right| = |0-0| = 0$。界限 $B = |-0.1|\\cdot 1 + |0.05|\\cdot 0 = 0.1 \\le 0.15$。重用标志 $1$。\n- Case C: “baz”, $\\mathbf{f}^{(0)} = \\langle 7, 2, 3, 1 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 8, 2, 3, 1 \\rangle$。哈希坐标 $f_0$ 发生变化，因此 $h_{0} \\ne h_{1}$，失效。重用标志 $0$。\n- Case D: “qux”, $\\mathbf{f}^{(0)} = \\langle 9, 9, 9, 9 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 9, 13, 9, 3 \\rangle$。哈希坐标未改变。未哈希坐标的差异：$\\left|\\Delta f_{1}\\right| = |13-9| = 4$, $\\left|\\Delta f_{3}\\right| = |3-9| = 6$。界限 $B = |-0.1| \\cdot 4 + |0.05| \\cdot 6 = 0.4 + 0.3 = 0.7 > 0.15$。失效。重用标志 $0$。\n- Case E: “edge”, $\\mathbf{f}^{(0)} = \\langle 1, 1, 1, 1 \\rangle$, $\\mathbf{f}^{(1)} = \\langle 1, 1, 1, 1 \\rangle$。特征完全相同，所以签名相等且界限 $B=0$。重用标志 $1$。\n\n因此，预期的重用标志序列为 $\\langle 1, 1, 0, 0, 1 \\rangle$。\n\n该实现使用64位FNV风格的混合算法为标识符和被掩码的特征确定性地计算哈希签名，通过绝对值评估未哈希坐标上的界限，与 $\\tau$ 进行比较，并以指定格式打印标志。", "answer": "[1,1,0,0,1]", "id": "3656494"}]}