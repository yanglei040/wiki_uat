{"hands_on_practices": [{"introduction": "编译器优化常常假设加法结合律等基本代数定律成立。本练习将通过一个具体的计算揭示，对于浮点数运算，这一假设并不总是正确。通过在一个明确定义的浮点数系统中计算 $(a+b)+c$ 和 $a+(b+c)$ 的值，你将亲眼见证舍入误差和灾难性抵消如何破坏数学等价性，这是验证数值代码时一个至关重要的洞察 [@problem_id:3642459]。", "problem": "形式化验证编译器优化正确性的一个核心步骤是证明源程序片段和目标程序片段在语言语义下是可观察等价的。考虑一门语言，其算术语义遵循电气和电子工程师协会 (IEEE) 标准 $754$ 的“四舍五入，平局取偶”舍入规则，但为了使推理明确，我们用一个数学上理想化的十进制浮点模型来代替通常的二进制浮点。在此模型中，可表示的浮点数集合由所有形式为 $\\pm d_{0}.d_{1}d_{2}\\times 10^{e}$ 的规格化十进制数组成，这些数恰有 $p=3$ 位有效数字，其中 $d_{0}\\in\\{1,2,\\dots,9\\}$，$d_{1},d_{2}\\in\\{0,1,\\dots,9\\}$，且 $e\\in\\mathbb{Z}$ 是一个无界指数；此外，数字 $0$ 也是可表示的。令 $\\mathrm{fl}(x)$ 表示将实数 $x$ 舍入到此模型中最接近的可表示数的结果，其中平局情况通过选择最低有效位 $d_{2}$ 为偶数的可表示数来打破。定义浮点加法为 $x\\oplus y \\triangleq \\mathrm{fl}(x+y)$。\n\n一种广泛使用的重结合优化在加法是结合性的假设下，将 $(a+b)+c$ 替换为 $a+(b+c)$。在存在浮点舍入的情况下，这个假设可能不成立，这是形式化验证编译器正确性时的一个关键问题。\n\n使用上述基数为 $10$、精度为 $p=3$、舍入规则为“四舍五入，平局取偶”的十进制浮点语义，令\n- $a = 1.00\\times 10^{5}$，\n- $b = -1.00\\times 10^{5}$，\n- $c = 1.23\\times 10^{0}$。\n\n计算下式的精确实数值\n$$D \\triangleq \\bigl((a\\oplus b)\\oplus c\\bigr)\\;-\\;\\bigl(a\\oplus (b\\oplus c)\\bigr).$$\n将你的最终答案表示为精确的十进制数。不要对最终答案进行舍入。", "solution": "首先验证问题，以确保其具有科学依据、问题明确且客观。\n\n### 步骤 1：提取已知条件\n- **十进制浮点模型：**\n  - 可表示数集：$\\pm d_{0}.d_{1}d_{2}\\times 10^{e}$ 和 $0$。\n  - 精度：$p=3$ 位有效数字。\n  - 数字：$d_{0}\\in\\{1,2,\\dots,9\\}$，$d_{1},d_{2}\\in\\{0,1,\\dots,9\\}$。\n  - 指数：$e\\in\\mathbb{Z}$ (无界)。\n- **舍入规则：** $\\mathrm{fl}(x)$ 将实数 $x$ 舍入到最接近的可表示数。平局情况通过选择最低有效位 $d_{2}$ 为偶数的可表示数来打破。\n- **浮点加法：** $x\\oplus y \\triangleq \\mathrm{fl}(x+y)$。\n- **给定值：**\n  - $a = 1.00\\times 10^{5}$\n  - $b = -1.00\\times 10^{5}$\n  - $c = 1.23\\times 10^{0}$\n- **待计算量：** $D \\triangleq \\bigl((a\\oplus b)\\oplus c\\bigr)\\;-\\;\\bigl(a\\oplus (b\\oplus c)\\bigr)$ 的精确实数值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是一个定义明确的数值分析练习，具体涉及浮点算术的性质。它使用一个简化但严格定义的十进制模型来说明浮点加法的非结合性，这是计算机科学和编译器设计中的一个关键概念。\n- **科学依据：** 该问题基于浮点表示和舍入的基本原理，类似于现实世界中的 IEEE $754$ 标准。它在科学上是合理的。\n- **问题明确性：** 所有术语、函数（$\\mathrm{fl}$、$\\oplus$）和数字格式都已精确定义。给定的值是明确的。通过直接应用指定的规则可以确定唯一的解。\n- **客观性：** 该问题以形式化的数学语言陈述，没有任何主观性或歧义。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整的解答。\n\n### 求解过程\n目标是计算 $D \\triangleq \\bigl((a\\oplus b)\\oplus c\\bigr)\\;-\\;\\bigl(a\\oplus (b\\oplus c)\\bigr)$ 的值。我们将分别计算这两个项。给定值为：\n$a = 1.00 \\times 10^{5} = 100000$\n$b = -1.00 \\times 10^{5} = -100000$\n$c = 1.23 \\times 10^{0} = 1.23$\n\n所有三个给定值（$a, b, c$）在指定的浮点模型中都是可表示的数。例如，$a=1.00\\times 10^5$ 符合形式 $d_0.d_1d_2 \\times 10^e$，其中 $d_0=1, d_1=0, d_2=0$ 且 $e=5$。\n\n**1. 计算 $\\bigl((a\\oplus b)\\oplus c\\bigr)$**\n\n首先，我们计算内部表达式 $a\\oplus b$：\n$$a\\oplus b \\triangleq \\mathrm{fl}(a+b)$$\n精确的实数和为：\n$$a+b = (1.00 \\times 10^{5}) + (-1.00 \\times 10^{5}) = 100000 - 100000 = 0$$\n问题陈述指明 $0$ 是一个可表示的数。对一个可表示的数进行舍入，结果是其本身。\n$$a\\oplus b = \\mathrm{fl}(0) = 0$$\n接下来，我们将 $c$ 加到这个结果上，计算完整的表达式：\n$$(a\\oplus b)\\oplus c = 0 \\oplus c \\triangleq \\mathrm{fl}(0+c)$$\n精确的和为：\n$$0+c = 0 + 1.23 = 1.23$$\n我们必须将 $1.23$ 舍入到最接近的可表示数。一个可表示数的形式为 $\\pm d_{0}.d_{1}d_{2}\\times 10^{e}$。数字 $1.23$ 可以写成 $1.23\\times 10^{0}$。当 $d_0=1$, $d_1=2$, $d_2=3$ 时，这符合指定的三位有效数字的规格化形式。因此，$1.23$ 是一个可表示的数。\n$$\\mathrm{fl}(1.23) = 1.23$$\n因此，第一项是：\n$$\\bigl((a\\oplus b)\\oplus c\\bigr) = 1.23$$\n\n**2. 计算 $\\bigl(a\\oplus (b\\oplus c)\\bigr)$**\n\n首先，我们计算内部表达式 $b\\oplus c$：\n$$b\\oplus c \\triangleq \\mathrm{fl}(b+c)$$\n精确的实数和为：\n$$b+c = (-1.00 \\times 10^{5}) + (1.23 \\times 10^{0}) = -100000 + 1.23 = -99998.77$$\n现在，我们必须将实数 $x = -99998.77$ 舍入到最接近的具有 $p=3$ 位有效数字的可表示数。我们将 $x$ 写成规格化的科学记数法：\n$$x = -9.999877 \\times 10^{4}$$\n指数为 $e=4$。我们需要将尾数 $9.999877$ 舍入到三位有效数字。形式为 $d_0.d_1d_2$ 的两个最接近的候选尾数是 $9.99$ 和下一个可表示的尾数。将 $9.99$ 的最后一位加一得到 $10.0$。\n这导出了两个候选的可表示数：\n- 向下舍入：$-10.0 \\times 10^4 = -1.00 \\times 10^5$。更精确地说，绝对值恰好“较小”的可表示数是 $-9.99 \\times 10^4 = -99900$。令其为 $N_1$。\n- 向上舍入：绝对值恰好“较大”的可表示数是 $-1.00 \\times 10^5 = -100000$。令其为 $N_2$。\n这两个数的中点是 $\\frac{(-99900) + (-100000)}{2} = -99950$。\n我们的值是 $x=-99998.77$。由于 $|x| = 99998.77$ 大于中点的绝对值 $|-99950|=99950$，我们向远离零的方向舍入。因此，我们舍入到绝对值更大的数，即 $N_2=-100000$。\n或者，我们比较距离：\n$$|x - N_1| = |-99998.77 - (-99900)| = |-98.77| = 98.77$$\n$$|x - N_2| = |-99998.77 - (-100000)| = |1.23| = 1.23$$\n由于 $1.23  98.77$，最接近的可表示数是 $N_2 = -100000 = -1.00 \\times 10^{5}$。\n没有出现平局，所以“平局取偶”规则未被调用。\n$$b\\oplus c = \\mathrm{fl}(-99998.77) = -1.00 \\times 10^{5}$$\n这个结果等于 $b$ 的原始值。这种将一个小数加到一个非常大的数上，经过舍入后大数没有发生变化的现象，被称为“淹没”或“吸收”。\n\n接下来，我们计算完整的表达式：\n$$a\\oplus (b\\oplus c) = a \\oplus (-1.00 \\times 10^{5})$$\n这被定义为 $\\mathrm{fl}\\left(a + (-1.00 \\times 10^{5})\\right)$。精确的和为：\n$$a + (-1.00 \\times 10^{5}) = (1.00 \\times 10^{5}) + (-1.00 \\times 10^{5}) = 0$$\n和之前一样，$\\mathrm{fl}(0) = 0$。\n因此，第二项是：\n$$\\bigl(a\\oplus (b\\oplus c)\\bigr) = 0$$\n\n**3. $D$ 的最终计算**\n\n最后，我们计算差值 $D$：\n$$D = \\bigl((a\\oplus b)\\oplus c\\bigr) \\;-\\; \\bigl(a\\oplus (b\\oplus c)\\bigr) = 1.23 - 0 = 1.23$$\n结果表明浮点加法不具有结合性。差值 $D$ 不为零，这突显了编译器在没有形式化证明的情况下对浮点表达式执行重结合优化时可能出现的正确性问题。", "answer": "$$\\boxed{1.23}$$", "id": "3642459"}, {"introduction": "与结合律类似，乘法分配律 $x \\times (y+z) = x \\times y + x \\times z$ 也是编译器优化的一个常见目标。本练习旨在探索由分配律导致的不同运算顺序如何引起不同的舍入误差累积。你不仅将计算两种求值顺序产生的差异，还将推导该变换在何种条件下才是安全的，这是形式化验证中的一项基本技能 [@problem_id:3642458]。", "problem": "考虑一个编译器可能应用于算术表达式的源码级代数重写：将乘法分配到加法上，即用 $x \\times y + x \\times z$ 替换 $x \\times (y+z)$。在实数算术中，根据分配律，这种变换是正确的。然而，在浮点算术中，其正确性取决于编译器所采用的舍入语义。为从第一性原理出发进行推理，我们使用以下浮点求值和舍入的操作模型：\n\n- 机器浮点数集 $\\mathbb{F}$ 由基数为$10$的规格化数构成，这些数包含 $3$ 位有效数字（尾数为 $d_{1}.d_{2}d_{3}$，其中 $d_{1} \\in \\{1,\\dots,9\\}$ 且 $d_{2},d_{3} \\in \\{0,\\dots,9\\}$），再乘以10的某个整数次幂。\n- 舍入函数 $R : \\mathbb{R} \\to \\mathbb{F}$ 使用“向最近舍入，偶数优先”的规则，将任意实数输入映射到 $\\mathbb{F}$ 中最接近的元素。具体来说，当首个被舍弃的数字是 $5$ 且所有后续被舍弃的数字都为 $0$ 时，$R$ 会进行舍入，使得最后保留的数字变为偶数；否则，$R$ 会舍入到最接近的可表示值。\n- 表达式求值被定义为在每次基本运算后应用 $R$。对于变量 $u,v \\in \\mathbb{F}$，其语义为\n$$\\llbracket u \\rrbracket = u,\\quad \\llbracket u+v \\rrbracket = R(\\llbracket u \\rrbracket + \\llbracket v \\rrbracket),\\quad \\llbracket u \\times v \\rrbracket = R(\\llbracket u \\rrbracket \\times \\llbracket v \\rrbracket),$$\n且组合遵循抽象语法树的规则（即，$x \\times (y+z)$ 的求值过程是先计算 $\\llbracket y+z \\rrbracket$，然后乘以 $x$，每次运算后都进行舍入）。\n\n设程序变量为机器可表示的值 $x = 9.99 \\times 10^{6}$、$y = 1.00$ 和 $z = 5.00 \\times 10^{-3}$，它们都是 $\\mathbb{F}$ 的成员。\n\n1. 使用上述语义，分别计算 $\\llbracket x \\times (y+z) \\rrbracket$ 和 $\\llbracket x \\times y + x \\times z \\rrbracket$ 的值，并计算它们的绝对差\n$$\\Delta = \\left|\\,\\llbracket x \\times y + x \\times z \\rrbracket - \\llbracket x \\times (y+z) \\rrbracket\\,\\right|.$$\n将 $\\Delta$ 以单个实数值的形式给出。\n\n2. 除了进行计算，还需陈述一个充分条件，使得代数重写 $x \\times (y+z) \\to x \\times y + x \\times z$ 在此浮点模型下是保持语义的。该条件需用“在 $R$ 下的精确可表示性”来表述，且应从上述核心定义推导得出，而非依赖未经证明的启发式方法。\n\n给出 $\\Delta$ 的最终数值答案，不带单位。最终数字无需指定舍入规则，因为在此设定下它是一个精确值。", "solution": "该问题被验证为具有科学依据、良构且客观。它提出了一个简化但一致的浮点算术模型，用以分析编译器优化的正确性。所有定义和数值均已提供，从而可以得到唯一解。因此，我们可以着手进行推导。\n\n该问题要求我们完成两项任务：首先，在特定的浮点语义下计算两个表达式的数值差异；其次，陈述一个使该代数恒等式成立的通用充分条件。\n\n浮点系统 $\\mathbb{F}$ 由形如 $d_{1}.d_{2}d_{3} \\times 10^e$ 的数构成，其中 $d_{1} \\in \\{1, \\dots, 9\\}$，$d_{2}, d_{3} \\in \\{0, \\dots, 9\\}$，$e$ 为整数。舍入规则 $R$ 是“向最近舍入，偶数优先”。给定的机器可表示值为：\n$x = 9.99 \\times 10^{6}$\n$y = 1.00 = 1.00 \\times 10^{0}$\n$z = 5.00 \\times 10^{-3}$\n\n**第1部分：计算绝对差 $\\Delta$**\n\n首先，我们根据指定的语义 $R(x \\times R(y+z))$ 对表达式 $\\llbracket x \\times (y+z) \\rrbracket$ 进行求值。\n\n1.  计算内部的和，$y+z$：\n    $$y+z = 1.00 + 5.00 \\times 10^{-3} = 1.00 + 0.005 = 1.005$$\n2.  将结果舍入以符合 $\\mathbb{F}$ 的格式。该值为 $1.005 \\times 10^0$。我们必须将其舍入到 $3$ 位有效数字。需要保留的数字是 $1.00$。首个被舍弃的数字是 $5$，且所有后续被舍弃的数字都是零。这是一个需要打破平局的情况。舍入规则是“偶数优先”，这意味着我们舍入后要使最后保留的数字为偶数。最后保留的数字是 $1.00$ 中的第二个 $0$。由于 $0$ 已经是偶数，我们向下舍入。\n    $$R(1.005) = 1.00$$\n    所以，$\\llbracket y+z \\rrbracket = 1.00 \\times 10^{0}$。我们将此中间结果记为 $t_1 = 1.00$。\n\n3.  计算 $x$ 与中间结果 $t_1$ 的乘积：\n    $$x \\times t_1 = (9.99 \\times 10^{6}) \\times 1.00 = 9.99 \\times 10^{6}$$\n4.  对最终乘积进行舍入。结果 $9.99 \\times 10^{6}$ 已经是集合 $\\mathbb{F}$ 的一个成员。因此，舍入没有影响。\n    $$R(9.99 \\times 10^{6}) = 9.99 \\times 10^{6}$$\n    因此，第一个表达式的值为：\n    $$\\llbracket x \\times (y+z) \\rrbracket = 9.99 \\times 10^{6}$$\n\n接下来，我们根据语义 $R(R(x \\times y) + R(x \\times z))$ 对表达式 $\\llbracket x \\times y + x \\times z \\rrbracket$ 进行求值。\n\n1.  计算第一个乘积，$x \\times y$：\n    $$x \\times y = (9.99 \\times 10^{6}) \\times 1.00 = 9.99 \\times 10^{6}$$\n    这个值已经在 $\\mathbb{F}$ 中，所以 $R(x \\times y) = 9.99 \\times 10^{6}$。我们称之为 $t_{xy} = \\llbracket x \\times y \\rrbracket$。\n\n2.  计算第二个乘积，$x \\times z$：\n    $$x \\times z = (9.99 \\times 10^{6}) \\times (5.00 \\times 10^{-3}) = (9.99 \\times 5.00) \\times 10^{3} = 49.95 \\times 10^{3}$$\n    为了将其规格化为 $d_1.d_2d_3 \\times 10^e$ 的形式，我们将其写为 $4.995 \\times 10^{4}$。\n\n3.  将此乘积舍入以符合 $\\mathbb{F}$ 的格式。我们必须将 $4.995 \\times 10^4$ 舍入到 $3$ 位有效数字。需要保留的数字是 $4.99$。首个被舍弃的数字是 $5$，表明出现平局。最后保留的数字是 $9$，是奇数。“偶数优先”规则要求我们进行舍入以使最后一位数字变为偶数，这意味着要向上舍入。\n    $$R(4.995 \\times 10^{4}) = 5.00 \\times 10^{4}$$\n    我们称之为 $t_{xz} = \\llbracket x \\times z \\rrbracket$。\n\n4.  计算两个中间结果的和，$t_{xy} + t_{xz}$：\n    $$t_{xy} + t_{xz} = 9.99 \\times 10^{6} + 5.00 \\times 10^{4}$$\n    为了执行加法，我们先对齐指数：\n    $$9.99 \\times 10^{6} + 0.05 \\times 10^{6} = (9.99 + 0.05) \\times 10^{6} = 10.04 \\times 10^{6}$$\n    或者，用定点表示法：$9990000 + 50000 = 10040000$。\n    以 $\\mathbb{F}$ 的规格化形式表示，此值为 $1.004 \\times 10^{7}$。\n\n5.  对最终的和进行舍入。我们必须将 $1.004 \\times 10^7$ 舍入到 $3$ 位有效数字。需要保留的数字是 $1.00$。首个被舍弃的数字是 $4$，小于 $5$。因此，我们向下舍入。\n    $$R(1.004 \\times 10^{7}) = 1.00 \\times 10^{7}$$\n    因此，第二个表达式的值为：\n    $$\\llbracket x \\times y + x \\times z \\rrbracket = 1.00 \\times 10^{7}$$\n\n最后，我们计算绝对差 $\\Delta$：\n$$\\Delta = |\\llbracket x \\times y + x \\times z \\rrbracket - \\llbracket x \\times (y+z) \\rrbracket|$$\n$$\\Delta = |1.00 \\times 10^{7} - 9.99 \\times 10^{6}|$$\n$$\\Delta = |10000000 - 9990000| = |10000| = 10000$$\n\n**第2部分：语义保持的充分条件**\n\n我们正在寻找一个关于 $x, y, z \\in \\mathbb{F}$ 的充分条件，以使该代数重写是语义保持的，即：\n$$\\llbracket x \\times (y+z) \\rrbracket = \\llbracket x \\times y + x \\times z \\rrbracket$$\n使用给定的语义定义，该等式为：\n$$R(x \\times R(y+z)) = R(R(x \\times y) + R(x \\times z))$$\n在实数算术中，分配律保证了 $x \\times (y+z) = x \\times y + x \\times z$。浮点算术中的差异源于每次运算后应用的舍入函数 $R$。\n\n一个确保等式成立的直接方法是要求那些需要舍入的中间计算不引入任何误差。如果子表达式的实数值结果都能在 $\\mathbb{F}$ 中精确表示，那么舍入函数 $R$ 对于这些特定值就成为一个恒等函数。\n\n让我们假设以下三个条件成立：\n1.  和 $y+z$ 在 $\\mathbb{F}$ 中是精确可表示的。这等价于 $R(y+z) = y+z$。\n2.  积 $x \\times y$ 在 $\\mathbb{F}$ 中是精确可表示的。这等价于 $R(x \\times y) = x \\times y$。\n3.  积 $x \\times z$ 在 $\\mathbb{F}$ 中是精确可表示的。这等价于 $R(x \\times z) = x \\times z$。\n\n在这些假设下，让我们重新评估主等式的两边。\n左边变为：\n$$\\llbracket x \\times (y+z) \\rrbracket = R(x \\times R(y+z)) = R(x \\times (y+z))$$\n右边变为：\n$$\\llbracket x \\times y + x \\times z \\rrbracket = R(R(x \\times y) + R(x \\times z)) = R((x \\times y) + (x \\times z))$$\n根据实数的分配律，两边外部舍入函数 $R$ 的参数是相同的：$x \\times (y+z) = (x \\times y) + (x \\times z)$。由于舍入函数 $R$ 是一个函数，它会将相同的输入映射到相同的输出。因此，等式 $\\llbracket x \\times (y+z) \\rrbracket = \\llbracket x \\times y + x \\times z \\rrbracket$ 得以保证。\n\n因此，一个用“在 $R$ 下的精确可表示性”来表述的充分条件是，在整个大计算中所有三个子表达式的结果都能在浮点数集 $\\mathbb{F}$ 中精确表示。形式上：\n如果运算 $(y+z)$、$(x \\times y)$ 和 $(x \\times z)$ 的实数值结果都能在浮点数集 $\\mathbb{F}$ 中精确表示，那么变换 $x \\times (y+z) \\to x \\times y + x \\times z$ 就是语义保持的。这等价于陈述 $R(y+z) = y+z$，$R(x \\times y) = x \\times y$，以及 $R(x \\times z) = x \\times z$。", "answer": "$$\\boxed{10000}$$", "id": "3642458"}, {"introduction": "形式化验证不仅要处理有限数值的舍入误差，还必须正确处理像 IEEE 754 标准定义的异常值。本练习挑战了看似显而易见的代数恒等式 $x/x = 1$，揭示了它在输入为零、无穷大或“非数”(NaN)时的失效。通过为特殊情况定义形式语义并进行分析，你将理解为何验证编译器变换必须严格遵循算术模型的完整规范，包括其异常行为 [@problem_id:3642454]。", "problem": "考虑一种简单的表达式语言，该语言包含变量和基于电气与电子工程师协会 (IEEE) 754 标准的浮点值算术运算。一个表达式求值的可观察行为被定义为一个序对 $(v, f)$，其中 $v$ 是结果值，$f \\in \\{0,1\\}$ 指示在求值期间是否引发了无效操作异常。对于本问题，你可以假设在默认舍入模式下，并忽略信令非数值输入的情况下，IEEE 754 算术具有以下经过充分检验的事实：\n- 对于任何有限非零值 $x$，除法 $x/x$ 的结果恰好为 $1$ 并且不会引发无效操作异常。\n- 除法 $0/0$ 产生一个静默非数值并引发无效操作异常。\n- 除法 $\\infty/\\infty$ 产生一个静默非数值并引发无效操作异常。\n- 任何带有静默非数值操作数的算术运算会将静默非数值作为结果传播，并且不会引发无效操作异常，已明确说明的特定无效情况除外。\n\n一项编译器优化将表达式 $x/x$ 替换为常量 $1$。设常量的语义为其值且不产生任何异常，因此对常量 $1$ 求值会得到可观察序对 $(1, 0)$。设原始表达式 $x/x$ 在输入 $x$ 上的可观察语义表示为 $\\llbracket x/x \\rrbracket(x)$，优化后表达式的语义表示为 $\\llbracket 1 \\rrbracket$。\n\n1. 为 $\\llbracket x/x \\rrbracket(x)$ 定义一个精确的大步语义（big-step semantics），该语义与上述事实一致，并能捕捉以下不相交输入类别的值和无效操作异常行为：静默非数值、零（包括 $+0$ 和 $-0$）、无穷大（包括 $+\\infty$ 和 $-\\infty$）以及有限非零数。你的语义必须为每个类别产生一个可观察序对 $(v,f)$。\n\n2. 使用你的语义，从形式上证明为什么对于 $x$ 为零、无穷大或静默非数值的输入，就可观察行为 $(v,f)$ 而言，替换 $x/x \\to 1$ 不是语义保持的。\n\n3. 假设 $x$ 从这四个类别的分布中抽取，其概率为 $\\mathbb{P}[\\text{quiet not-a-number}] = \\frac{1}{50}$，$\\mathbb{P}[\\text{zero}] = \\frac{1}{100}$，$\\mathbb{P}[\\text{infinite}] = \\frac{1}{200}$，且剩余的概率质量分配给有限非零数。在此模型下，计算 $\\llbracket x/x \\rrbracket(x)$ 的可观察行为与 $\\llbracket 1 \\rrbracket$ 的可观察行为不同的概率。请将你的最终答案以四位有效数字的单个数字形式给出。", "solution": "### 步骤 1：问题验证\n\n#### 已知条件提取\n本问题提供了以下数据、定义和条件：\n- **可观察行为**：表达式的求值产生一个序对 `$(v, f)$`，其中 `$v$` 是结果值，`$f \\in \\{0,1\\}$` 是一个标志，指示是否引发了无效操作异常（`$f=1$`）或未引发（`$f=0$`）。\n- **浮点事实（IEEE 754 简化）**：\n    1. 对于任何有限非零值 `$x$`，除法 `$x/x$` 的结果为 `$1$`，且不引发无效操作异常（`$f=0$`）。\n    2. 除法 `$0/0$` 产生一个静默非数值（`qNaN`）并引发无效操作异常（`$f=1$`）。\n    3. 除法 `$\\infty/\\infty$` 产生一个 `qNaN` 值并引发无效操作异常（`$f=1$`）。\n    4. 带有 `qNaN` 操作数的算术运算会将 `qNaN` 作为结果传播，并且不引发无效操作异常（`$f=0$`），已明确说明的特定情况除外。\n- **编译器优化**：表达式 `$x/x$` 被替换为常量 `$1$`。\n- **语义**：\n    - 原始表达式的语义表示为 `$\\llbracket x/x \\rrbracket(x)$`。\n    - 常量 `$C$` 的语义是其值且没有异常。因此，`$\\llbracket 1 \\rrbracket$` 产生可观察序对 `$(1, 0)$`。\n- **输入类别**：输入 `$x$` 可归为四个不相交的类别之一：静默非数值、零（包括 `$+0$` 和 `$-0$`）、无穷大（包括 `$+\\infty$` 和 `$-\\infty$`）以及有限非零数。\n- **概率**：\n    - `$\\mathbb{P}[\\text{quiet not-a-number}] = \\frac{1}{50}$`\n    - `$\\mathbb{P}[\\text{zero}] = \\frac{1}{100}$`\n    - `$\\mathbb{P}[\\text{infinite}] = \\frac{1}{200}$`\n    - 剩余的概率质量分配给有限非零数。\n\n#### 验证\n- **科学依据**：本问题在计算机科学原理，特别是编译器理论和计算机算术方面有充分的依据。所陈述的事实是对 IEEE 754 浮点标准的正确和标准的简化。\n- **良定性**：本问题是良定的。它要求完成三个不同的任务：定义形式语义，使用该语义证明一个属性，以及根据给定的分布计算概率。每个部分都明确规定，并能得出一个唯一的、稳定的、有意义的解。\n- **客观性**：本问题以精确、客观和形式化的语言陈述，没有歧义或主观论断。\n\n该问题是自包含的、一致的，并且没有违反任何无效标准。它是一个有效的形式化问题。\n\n### 步骤 2：解答\n\n#### 1. $\\llbracket x/x \\rrbracket(x)$ 的大步语义\n\n设 `$x_{in}$` 是变量 `$x$` 的输入值。大步语义 `$\\llbracket x/x \\rrbracket(x_{in})$` 将此输入映射到一个可观察序对 `$(v,f)$`。我们根据所提供的事实，通过考虑四个不相交的输入类别来构建该语义。设 `qNaN` 表示一个静默非数值。\n\n- **类别：有限非零数。** 根据事实 1，对于有限非零输入 `$x_{in}$`，除法 `$x_{in}/x_{in}$` 的求值结果为 `$1$`，且不引发无效操作异常。因此，`$v=1$` 且 `$f=0$`。\n- **类别：零。** 根据事实 2，对于 `$x_{in}=0$`，除法 `$0/0$` 产生 `qNaN` 并引发无效操作异常。因此，`$v=\\text{qNaN}$` 且 `$f=1$`。\n- **类别：无穷大。** 根据事实 3，对于 `$x_{in}=\\infty$`，除法 `$\\infty/\\infty$` 产生 `qNaN` 并引发无效操作异常。因此，`$v=\\text{qNaN}$` 且 `$f=1$`。\n- **类别：静默非数值。** 根据事实 4，带有 `qNaN` 操作数的运算会传播 `qNaN` 而不引发新的异常。因此，对于 `$x_{in}=\\text{qNaN}$`，除法 `$\\text{qNaN}/\\text{qNaN}$` 的结果为 `qNaN`，且不引发无效操作异常。因此，`$v=\\text{qNaN}$` 且 `$f=0$`。\n\n我们可以将此案例分析形式化为分段定义的语义：\n$$\n\\llbracket x/x \\rrbracket(x_{in}) = \\begin{cases}\n(1, 0)  \\text{if } x_{in} \\text{ is a finite nonzero number} \\\\\n(\\text{qNaN}, 1)  \\text{if } x_{in} \\in \\{+0, -0\\} \\\\\n(\\text{qNaN}, 1)  \\text{if } x_{in} \\in \\{+\\infty, -\\infty\\} \\\\\n(\\text{qNaN}, 0)  \\text{if } x_{in} \\text{ is a quiet not-a-number}\n\\end{cases}\n$$\n\n#### 2. 非等价性证明\n\n编译器优化将表达式 `$x/x$` 替换为常量 `$1$`。优化后表达式的语义给出为 `$\\llbracket 1 \\rrbracket = (1, 0)$`。这意味着对于任何输入值 `$x_{in}$`，优化后的代码都会产生可观察序对 `$(1, 0)`。\n\n为了证明转换 `$x/x \\to 1$` 不是语义保持的，我们必须证明对于某些输入 `$x_{in}$`，`$\\llbracket x/x \\rrbracket(x_{in}) \\neq \\llbracket 1 \\rrbracket$`。我们检查 `$x$` 为零、无穷大或静默非数值的情况。\n\n- **情况：`$x_{in}$` 为零。**\n  根据我们的语义，`$\\llbracket x/x \\rrbracket(0) = (\\text{qNaN}, 1)$`。\n  优化后的语义为 `$\\llbracket 1 \\rrbracket = (1, 0)$`。\n  由于 `$(\\text{qNaN}, 1) \\neq (1, 0)$`，语义不被保持。结果值和异常标志都不同。\n\n- **情况：`$x_{in}$` 为无穷大。**\n  根据我们的语义，`$\\llbracket x/x \\rrbracket(\\infty) = (\\text{qNaN}, 1)$`。\n  优化后的语义为 `$\\llbracket 1 \\rrbracket = (1, 0)$`。\n  由于 `$(\\text{qNaN}, 1) \\neq (1, 0)$`，语义不被保持。同样，值和标志都不同。\n\n- **情况：`$x_{in}$` 为静默非数值。**\n  根据我们的语义，`$\\llbracket x/x \\rrbracket(\\text{qNaN}) = (\\text{qNaN}, 0)$`。\n  优化后的语义为 `$\\llbracket 1 \\rrbracket = (1, 0)$`。\n  由于 `$(\\text{qNaN}, 0) \\neq (1, 0)$`，语义不被保持。结果值不同，尽管异常标志相同。\n\n在所有三个指定类别中——零、无穷大和静默非数值——原始表达式的可观察行为都与优化后表达式的可观察行为不同。因此，替换 `$x/x \\to 1$` 不是一个语义保持的转换。它仅在 `$x$` 是有限非零数的前提下有效。\n\n#### 3. 行为不匹配的概率\n\n`$\\llbracket x/x \\rrbracket(x)$` 的可观察行为与 `$\\llbracket 1 \\rrbracket$` 的可观察行为不同，当且仅当 `$\\llbracket x/x \\rrbracket(x_{in}) \\neq (1, 0)`。\n\n从第 1 部分定义的语义中，我们可以看到：\n- 如果 `$x_{in}$` 是一个有限非零数，`$\\llbracket x/x \\rrbracket(x_{in}) = (1, 0)$`。在这种情况下，行为匹配。\n- 如果 `$x_{in}$` 是零，`$\\llbracket x/x \\rrbracket(x_{in}) = (\\text{qNaN}, 1) \\neq (1, 0)$`。行为不同。\n- 如果 `$x_{in}$` 是无穷大，`$\\llbracket x/x \\rrbracket(x_{in}) = (\\text{qNaN}, 1) \\neq (1, 0)$`。行为不同。\n- 如果 `$x_{in}$` 是静默非数值，`$\\llbracket x/x \\rrbracket(x_{in}) = (\\text{qNaN}, 0) \\neq (1, 0)$`。行为不同。\n\n因此，原始表达式的可观察行为与优化后表达式的可观察行为不同，当且仅当输入 `$x$` 属于以下三个类别之一：静默非数值、零或无穷大。\n\n问题指出这些输入类别是不相交的。因此，行为不同的概率（我们称此事件为 `$D$`）是 `$x$` 落入这三个类别中每一个的概率之和。\n\n$$\n\\mathbb{P}[D] = \\mathbb{P}[\\text{quiet not-a-number}] + \\mathbb{P}[\\text{zero}] + \\mathbb{P}[\\text{infinite}]\n$$\n\n代入给定的概率：\n$$\n\\mathbb{P}[D] = \\frac{1}{50} + \\frac{1}{100} + \\frac{1}{200}\n$$\n\n为了将这些分数相加，我们找到一个公分母，即 `$200$`：\n$$\n\\mathbb{P}[D] = \\frac{1 \\times 4}{50 \\times 4} + \\frac{1 \\times 2}{100 \\times 2} + \\frac{1}{200}\n$$\n$$\n\\mathbb{P}[D] = \\frac{4}{200} + \\frac{2}{200} + \\frac{1}{200} = \\frac{4+2+1}{200} = \\frac{7}{200}\n$$\n\n为了将其表示为四位有效数字的小数：\n$$\n\\frac{7}{200} = 0.035\n$$\n要将 `$0.035$` 写成四位有效数字，我们添加后缀零：`$0.03500$`。有效数字是 `$3$`、`$5$`、`$0$` 和 `$0$`。", "answer": "$$\\boxed{0.03500}$$", "id": "3642454"}]}