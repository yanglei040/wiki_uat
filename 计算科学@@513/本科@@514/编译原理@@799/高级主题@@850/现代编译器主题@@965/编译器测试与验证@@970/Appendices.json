{"hands_on_practices": [{"introduction": "现代编译器依靠复杂的静态分析来支持代码优化。活性分析（Liveness Analysis）是一个典型的例子，它用于确定在程序的每个点上哪些变量是“活”的（即其值在未来可能被使用）。这个练习 [@problem_id:3629971] 让你亲身体验定义活性分析的核心数据流方程，通过编写一个验证器，你将学会如何测试分析过程本身的正确性，这是信任并应用其后续优化的关键一步。", "problem": "您的任务是根据编译器测试与验证的数学原理，在一组控制流图（CFG）上验证后向数据流活性分析。控制流图（CFG）是一种有向图，其节点代表程序点（基本块或语句），边代表可能的控制流转换。对于一个节点 $n$，其后继节点集合表示为 $\\mathrm{succ}(n)$。活性分析为每个节点 $n$ 附加了两组变量集合：$LIVE\\_IN[n]$ 和 $LIVE\\_OUT[n]$。每个节点 $n$ 还有集合 $USE[n]$（在任何重定义之前读取的变量）和 $DEF[n]$（在该节点中定义的变量）。变量来自一个有限全集 $\\{v_0, v_1, \\dots, v_{K-1}\\}$。\n\n后向活性分析的基本定义如下：\n- $LIVE\\_OUT[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} LIVE\\_IN[s]$,\n- $LIVE\\_IN[n] = USE[n] \\cup \\left(LIVE\\_OUT[n] \\setminus DEF[n]\\right)$.\n\n您的程序必须为每个提供的测试用例验证候选集合 $LIVE\\_IN/LIVE\\_OUT$ 是否在CFG中的每个节点上同时满足这些方程。每个测试用例包括：\n- 节点数 $N$ 和变量数 $K$，\n- 每个节点 $n \\in \\{0,1,\\dots,N-1\\}$ 的后继节点列表 $\\mathrm{succ}(n)$，\n- $USE[n]$ 和 $DEF[n]$ 集合，\n- 候选的 $LIVE\\_IN[n]$ 和 $LIVE\\_OUT[n]$ 集合。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。如果测试用例中所有方程都满足，则使用 $1$ 表示真，否则使用 $0$ 表示假。不允许有其他输出。\n\n测试套件（所有集合都是 $\\{v_0, v_1, \\dots\\}$ 的子集，所有节点索引都是 $\\{0,\\dots,N-1\\}$ 中的整数）：\n\n- 测试用例1（分裂与汇合）：\n  - $N = 4$, $K = 3$。\n  - 后继节点：\n    - $\\mathrm{succ}(0) = [\\,1, 2\\,]$，\n    - $\\mathrm{succ}(1) = [\\,3\\,]$，\n    - $\\mathrm{succ}(2) = [\\,3\\,]$，\n    - $\\mathrm{succ}(3) = [\\,]$。\n  - 集合：\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{v_0\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{v_1\\}$,\n    - $USE[2] = \\{\\}$, $DEF[2] = \\{v_0\\}$,\n    - $USE[3] = \\{v_1\\}$, $DEF[3] = \\{\\}$。\n  - 候选活性集合：\n    - $LIVE\\_IN[0] = \\{v_1\\}$, $LIVE\\_OUT[0] = \\{v_0,v_1\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{v_1\\}$,\n    - $LIVE\\_IN[2] = \\{v_1\\}$, $LIVE\\_OUT[2] = \\{v_1\\}$,\n    - $LIVE\\_IN[3] = \\{v_1\\}$, $LIVE\\_OUT[3] = \\{\\}$。\n\n- 测试用例2（与测试用例1相同的CFG；故意错误的 $LIVE\\_OUT[0]$）：\n  - $N = 4$, $K = 3$。\n  - 后继节点：与测试用例1相同。\n  - 集合：与测试用例1相同。\n  - 候选活性集合：\n    - $LIVE\\_IN[0] = \\{v_1\\}$, $LIVE\\_OUT[0] = \\{v_0\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{v_1\\}$,\n    - $LIVE\\_IN[2] = \\{v_1\\}$, $LIVE\\_OUT[2] = \\{v_1\\}$,\n    - $LIVE\\_IN[3] = \\{v_1\\}$, $LIVE\\_OUT[3] = \\{\\}$。\n\n- 测试用例3（边界情况：退出节点使用一个变量）：\n  - $N = 2$, $K = 1$。\n  - 后继节点：\n    - $\\mathrm{succ}(0) = [\\,1\\,]$，\n    - $\\mathrm{succ}(1) = [\\,]$。\n  - 集合：\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{\\}$。\n  - 候选活性集合：\n    - $LIVE\\_IN[0] = \\{v_0\\}$, $LIVE\\_OUT[0] = \\{v_0\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{\\}$。\n\n- 测试用例4（带有汇合与退出的循环）：\n  - $N = 4$, $K = 3$。\n  - 后继节点：\n    - $\\mathrm{succ}(0) = [\\,1\\,]$，\n    - $\\mathrm{succ}(1) = [\\,2\\,]$，\n    - $\\mathrm{succ}(2) = [\\,1, 3\\,]$，\n    - $\\mathrm{succ}(3) = [\\,]$。\n  - 集合：\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{v_0\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{v_1\\}$,\n    - $USE[2] = \\{v_1\\}$, $DEF[2] = \\{\\}$,\n    - $USE[3] = \\{v_2\\}$, $DEF[3] = \\{\\}$。\n  - 候选活性集合：\n    - $LIVE\\_IN[0] = \\{v_2\\}$, $LIVE\\_OUT[0] = \\{v_0,v_2\\}$,\n    - $LIVE\\_IN[1] = \\{v_0,v_2\\}$, $LIVE\\_OUT[1] = \\{v_0,v_1,v_2\\}$,\n    - $LIVE\\_IN[2] = \\{v_0,v_1,v_2\\}$, $LIVE\\_OUT[2] = \\{v_0,v_2\\}$,\n    - $LIVE\\_IN[3] = \\{v_2\\}$, $LIVE\\_OUT[3] = \\{\\}$。\n\n- 测试用例5（带有不可达节点的边缘情况）：\n  - $N = 3$, $K = 2$。\n  - 后继节点：\n    - $\\mathrm{succ}(0) = [\\,1\\,]$，\n    - $\\mathrm{succ}(1) = [\\,]$，\n    - $\\mathrm{succ}(2) = [\\,]$。\n  - 集合：\n    - $USE[0] = \\{\\}$, $DEF[0] = \\{v_1\\}$,\n    - $USE[1] = \\{v_0\\}$, $DEF[1] = \\{\\}$,\n    - $USE[2] = \\{v_1\\}$, $DEF[2] = \\{\\}$。\n  - 候选活性集合：\n    - $LIVE\\_IN[0] = \\{v_0\\}$, $LIVE\\_OUT[0] = \\{v_0\\}$,\n    - $LIVE\\_IN[1] = \\{v_0\\}$, $LIVE\\_OUT[1] = \\{\\}$,\n    - $LIVE\\_IN[2] = \\{v_1\\}$, $LIVE\\_OUT[2] = \\{\\}$。\n\n您的程序必须在内部构造这些测试用例（无输入），并为每个用例的每个节点检查上述两个方程。要求的输出是一行包含 $N_{tests}$ 个整数的列表，每个测试用例一个，按顺序排列，当所有节点都满足两个方程时使用 $1$，否则使用 $0$，并严格按照 `[r_1,r_2,...,r_N_tests]` 的格式打印。", "solution": "用户提供了一个问题，要求验证多个控制流图（CFG）的活性分析结果。\n\n### 步骤1：提取已知信息\n- **任务**：对于给定的一组测试用例，根据后向活性分析的基本数据流方程，验证候选的活性集合（$LIVE\\_IN$，$LIVE\\_OUT$）。\n- **活性分析方程**：\n  1. $LIVE\\_OUT[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} LIVE\\_IN[s]$\n  2. $LIVE\\_IN[n] = USE[n] \\cup \\left(LIVE\\_OUT[n] \\setminus DEF[n]\\right)$\n- **定义**：\n  - $n$：CFG中的一个节点，来自集合 $\\{0, 1, \\dots, N-1\\}$。\n  - $\\mathrm{succ}(n)$：节点 $n$ 的后继节点集合。\n  - $USE[n]$：在节点 $n$ 处定义前使用的变量集合。\n  - $DEF[n]$：在节点 $n$ 处定义的变量集合。\n  - 变量：来自有限全集 $\\{v_0, v_1, \\dots, v_{K-1}\\}$。\n- **输出格式**：一行，包含一个用方括号括起来的逗号分隔列表，其中为每个测试用例提供验证结果（$1$ 表示真，$0$ 表示假）。例如：`[1,0,1,...]`。\n- **测试用例**：提供了五个测试用例，每个都指定了节点数 $N$、变量数 $K$、每个节点的后继节点列表、每个节点的 $USE$ 和 $DEF$ 集合，以及每个节点的候选 $LIVE\\_IN$ 和 $LIVE\\_OUT$ 集合。\n\n### 步骤2：使用提取的已知信息进行验证\n- **科学严谨性**：该问题植根于计算机科学的核心领域——编译原理。关于CFG和活性分析数据流方程的定义是该领域的标准、正确和基础的内容。该问题是科学上合理的。\n- **问题定义明确**：任务是根据一对明确的数学方程验证一组给定的数据。对于每个测试用例中的每个节点，所有必要的数据都已提供。验证过程是确定性的：计算每个方程的右侧，并与给定的左侧进行比较。每个测试用例都存在一个唯一且明确的布尔结果（真/假）。该问题是定义明确的。\n- **客观性**：问题使用形式化数学符号陈述，并提供了具体的、客观的数据。验证标准是由方程定义的集合的严格相等性。没有歧义或主观性。\n- **完整性和一致性**：每个测试用例的所有必要组件（$N, K$、后继节点列表、$USE, DEF, LIVE\\_IN, LIVE\\_OUT$ 集合）都已完全指定。没有矛盾之处。\n- **可行性**：测试用例涉及小图和少量变量，使其在计算上非常简单，非常适合作为示例程序。\n\n### 步骤3：结论与行动\n该问题是**有效**的。它是一个来自编译器设计领域的定义明确、科学合理且客观的问题。我将继续提供一个解决方案。\n\n### 基于原则的设计\n解决方案将通过系统地将后向活性分析的两个基本方程应用于每个测试用例CFG中的每个节点，来验证提供的活性分析数据。\n\n**1. 数据表示：**\n变量集合（$USE$，$DEF$，$LIVE\\_IN$，$LIVE\\_OUT$）是小的有限全集 $\\{v_0, v_1, \\dots, v_{K-1}\\}$ 的子集。这种结构非常适合使用位掩码表示。一个集合将由一个整数表示，如果变量 $v_i$ 在集合中，则第 $i$ 位为 $1$，否则为 $0$。这允许使用按位逻辑进行高效的集合运算：\n- **集合并集 ($A \\cup B$)**：实现为按位或（`A | B`）。\n- **集合交集 ($A \\cap B$)**：实现为按位与（`A  B`）。\n- **集合差集 ($A \\setminus B$)**：实现为 `A  (~B)`，其中 `~` 是按位非运算符。\n\n**2. CFG和测试用例结构：**\n为了组织每个测试用例的数据，将使用 `struct` 的层次结构：\n- `Node` 结构体将封装单个节点的所有数据：其 $USE$、$DEF$、$LIVE\\_IN$ 和 $LIVE\\_OUT$ 集合（作为整数位掩码）、其后继节点的数量，以及一个指向后继节点索引数组的指针。\n- `TestCase` 结构体将表示一个完整的测试场景，包含节点数 $N$、变量数 $K$ 和一个指向 `Node` 结构体数组的指针。\n\n**3. 验证算法：**\n将创建一个函数 `validate_test_case`，用于确定单个测试用例的有效性。该函数将遍历从 $0$ 到 $N-1$ 的每个节点 $n$ 并执行两次检查：\n\n- **检查1：$LIVE\\_OUT[n]$ 验证**\n  方程为 $LIVE\\_OUT[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} LIVE\\_IN[s]$。\n  为了验证这一点，算法将通过初始化一个空集（值为 $0$ 的整数）来计算右侧，然后遍历节点 $n$ 的所有后继节点 $s$。在每次迭代中，它与 `LIVE_IN[s]` 执行按位或运算。然后将最终结果与提供的 `LIVE_OUT[n]` 进行比较。\n\n- **检查2：$LIVE\\_IN[n]$ 验证**\n  方程为 $LIVE\\_IN[n] = USE[n] \\cup (LIVE\\_OUT[n] \\setminus DEF[n])$。\n  该算法分两步计算右侧。首先，它使用按位操作 `LIVE_OUT[n]  (~DEF[n])` 计算集合差 $LIVE\\_OUT[n] \\setminus DEF[n]$。其次，它使用按位或将此结果与 $USE[n]$ 进行并集运算。然后将这个最终计算出的值与提供的 `LIVE\\_IN[n]` 进行比较。\n\n如果对于CFG中的任何节点，这两项检查中的任何一项失败，则整个测试用例被视为无效，函数返回 $0$。如果所有节点的所有检查都通过，则测试用例有效，函数返回 $1$。\n\n**4. 主执行逻辑：**\n`main` 函数将静态定义问题中指定的所有五个测试用例的数据。这些定义将用于初始化一个 `TestCase` 结构体数组。然后程序将遍历此数组，为每个测试用例调用 `validate_test_case`，并存储 $0$ 或 $1$ 的结果。最后，它将以指定的格式 `[r_1,r_2,r_3,r_4,r_5]` 将收集到的结果打印到标准输出。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n// [Solution code to be inserted here]\n```", "id": "3629971"}, {"introduction": "激进的优化，例如重排内存操作，可以带来显著的性能提升，但如果处理不当，则有破坏程序逻辑的风险。这类转换的安全性取决于精确的别名分析（Alias Analysis），该分析用于判断两个指针是否可能指向同一内存位置。这个练习 [@problem_id:3630025] 让你测试分析（别名）与转换（指令重排）之间的相互作用，通过模拟优化前后的程序行为，你可以凭经验验证优化是否保留了程序的原始语义，从而将理论分析与实际的编译器验证联系起来。", "problem": "给定一种语言的单线程确定性执行模型，其中内存被建模为有限的整数数组。设内存状态为一个全函数 $\\sigma : \\{0, 1, \\dots, L-1\\} \\to \\mathbb{Z}$，其中 $L$ 是内存长度。考虑两个数组 $A$ 和 $B$，它们表示为同一底层内存 $M$ 的连续子范围，其基址索引分别为 $a$ 和 $b$，长度分别为 $n_A$ 和 $n_B$。数组 $A$ 占据地址 $\\{a, a+1, \\dots, a+n_A-1\\}$，数组 $B$ 占据地址 $\\{b, b+1, \\dots, b+n_B-1\\}$。两个指针 $p$ 和 $q$ 分别以逻辑索引 $i$ 和 $j$ 指向 $A$ 和 $B$，因此 $p$ 引用地址 $a+i$，$q$ 引用地址 $b+j$。设 $c$ 为一个固定的整数常量。\n\n在此模型中，原始程序片段按程序顺序执行以下操作序列：\n1. $v_1 := *p$,\n2. $v_2 := *q$,\n3. $*q := v_2 + c$,\n4. $*p := v_1 + v_2$.\n\n一个优化器可能会尝试重排加载/存储操作。被测试的重排将对 $*q$ 的存储操作提前，越过对 $*p$ 的加载操作，从而产生以下序列：\n1. $v_2 := *q$,\n2. $*q := v_2 + c$,\n3. $v_1 := *p$,\n4. $*p := v_1 + v_2$.\n\n别名分析的目的是保守地确定内存引用之间的关系。定义：\n- $p$ 和 $q$ 之间“可能别名”（may-alias）为真，如果 $A$ 和 $B$ 的子范围重叠，即 $\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1)$。\n- “必不别名”（must-not-alias）为真，如果子范围不重叠，即 $\\max(a, b)  \\min(a+n_A-1, b+n_B-1)$。\n\n在单线程顺序语义下，当且仅当对于所有输入，最终内存状态和产生的值都相等时，一次重排才是语义保持的。从基本原则出发，一个存储操作仅当它不会改变一个加载操作所观察到的值时，才能被提前至该加载操作之前。在本例中，这当且仅当地址 $a+i$ 和 $b+j$ 不同时成立。\n\n你的任务是编写一个完整的、可运行的程序，该程序：\n- 对于每个提供的测试用例，使用给定的初始内容 $\\sigma$ 和参数 $(L, a, n_A, b, n_B, i, j, c)$ 构建内存 $M$。\n- 通过模拟原始序列和重排后序列，并比较受影响地址处的最终内容，计算一个布尔值 $s$，该值表明上述重排对于特定的指针 $p$ 和 $q$ 是否是语义保持的。\n- 仅基于它们的子范围重叠 $(\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1))$，计算一个布尔值 $m$，该值表明 $A$ 和 $B$ 是否可能别名。\n- 生成单行输出，其中包含结果，形式为由方括号括起来的逗号分隔的 $[s, m]$ 对列表，所有布尔值都以整数（$0$ 表示 false，$1$ 表示 true）打印。格式必须严格如下：\n`[[s_1,m_1],[s_2,m_2],...,[s_T,m_T]]`\n其中 $T$ 是测试用例的数量。\n\n测试套件：\n使用以下五个测试用例。在每个用例中，$L=10$ 且 $M$ 按给定方式初始化。所有索引都是从零开始的。$L, a, n_A, b, n_B, i, j, c$ 的值出现在内存初始化器后面的括号中。\n\n1. $M = [10,20,30,40,50,60,70,80,90,100]$, $(L=10, a=0, n_A=4, b=5, n_B=4, i=1, j=2, c=3)$。数组不相交，$p$ 在地址 $1$，$q$ 在地址 $7$。\n2. $M = [1,3,5,7,9,11,13,15,17,19]$, $(L=10, a=2, n_A=4, b=3, n_B=4, i=1, j=0, c=4)$。数组重叠，且 $p$ 和 $q$ 指向同一地址 $3$。\n3. $M = [2,4,6,8,10,12,14,16,18,20]$, $(L=10, a=2, n_A=5, b=4, n_B=5, i=0, j=3, c=5)$。数组部分重叠；$p$ 在地址 $2$，$q$ 在地址 $7$。\n4. $M = [0,1,2,3,4,5,6,7,8,9]$, $(L=10, a=0, n_A=5, b=5, n_B=5, i=4, j=0, c=2)$。数组相邻但不相交；$p$ 在地址 $4$，$q$ 在地址 $5$。\n5. $M = [9,8,7,6,5,4,3,2,1,0]$, $(L=10, a=1, n_A=7, b=1, n_B=7, i=3, j=3, c=1)$。数组相同；$p$ 和 $q$ 都在地址 $4$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，形式为由方括号括起来的逗号分隔列表，每个测试用例贡献一个 $[s,m]$ 对，其中 $s$ 和 $m$ 是整数 $0$ 或 $1$。例如，对于三个用例，输出将类似于 `[[1,0],[0,1],[1,1]]`。您的程序必须为上述五个测试用例生成且仅生成一行此格式的输出。", "solution": "我们从单线程顺序程序语义的原则和别名分析的核心定义中推导出给定重排的安全性。\n\n设内存状态是地址集合 $\\mathcal{A} = \\{0, 1, \\dots, L-1\\}$ 上的一个函数 $\\sigma : \\mathcal{A} \\to \\mathbb{Z}$。从地址 $\\alpha \\in \\mathcal{A}$ 加载的操作语义是产生值 $\\sigma(\\alpha)$ 并且不改变状态。将值 $w \\in \\mathbb{Z}$ 存储到地址 $\\alpha$ 的语义是产生一个新状态 $\\sigma'$，使得 $\\sigma'(\\alpha) = w$ 且 $\\forall \\beta \\neq \\alpha, \\sigma'(\\beta) = \\sigma(\\beta)$。在单线程程序中，语义是顺序的：程序作为一系列状态转换来执行，其中加载操作观察当前状态，而存储操作更新它。\n\n定义地址 $\\alpha_p = a+i$ 和 $\\alpha_q = b+j$。原始序列执行如下：\n1. $v_1 := \\sigma(\\alpha_p)$,\n2. $v_2 := \\sigma(\\alpha_q)$,\n3. $\\sigma_1 := \\sigma[\\alpha_q \\mapsto (v_2 + c)]$,\n4. $\\sigma_2 := \\sigma_1[\\alpha_p \\mapsto (v_1 + v_2)]$.\n\n重排后的序列执行如下：\n1. $v_2' := \\sigma(\\alpha_q)$,\n2. $\\sigma'_1 := \\sigma[\\alpha_q \\mapsto (v_2' + c)]$,\n3. $v_1' := \\sigma'_1(\\alpha_p)$,\n4. $\\sigma'_2 := \\sigma'_1[\\alpha_p \\mapsto (v_1' + v_2')]$.\n\n我们比较 $\\sigma_2$ 和 $\\sigma'_2$ 来确定语义是否保持。考虑两种情况：\n\n情况 1：$\\alpha_p \\neq \\alpha_q$。在原始序列中，步骤 3 中对 $\\alpha_q$ 的存储不影响步骤 1 中从 $\\alpha_p$ 读取的值，因为加载发生在存储之前。在重排后的序列中，对 $\\alpha_q$ 的存储发生在从 $\\alpha_p$ 加载之前，但由于 $\\alpha_p \\neq \\alpha_q$，$\\alpha_p$ 处的值不受对 $\\alpha_q$ 存储的影响。因此，$v_1' = \\sigma(\\alpha_p) = v_1$，$v_2' = \\sigma(\\alpha_q) = v_2$，并且最终的赋值是相同的：$\\sigma_2(\\alpha_q) = v_2 + c = \\sigma'_2(\\alpha_q)$ 和 $\\sigma_2(\\alpha_p) = v_1 + v_2 = \\sigma'_2(\\alpha_p)$，所有其他地址也相等。因此，当 $\\alpha_p \\neq \\alpha_q$ 时，重排是语义保持的。\n\n情况 2：$\\alpha_p = \\alpha_q$。在原始序列中，我们有：\n- $v_1 = \\sigma(\\alpha_p)$,\n- $v_2 = \\sigma(\\alpha_p)$,\n- 步骤 3 后, $\\sigma_1(\\alpha_p) = v_2 + c$,\n- 步骤 4 后, $\\sigma_2(\\alpha_p) = v_1 + v_2$.\n\n在重排后的序列中：\n- $v_2' = \\sigma(\\alpha_p)$,\n- 步骤 2 后, $\\sigma'_1(\\alpha_p) = v_2' + c$,\n- 然后 $v_1' = \\sigma'_1(\\alpha_p) = v_2' + c$,\n- 步骤 4 后, $\\sigma'_2(\\alpha_p) = v_1' + v_2' = (v_2' + c) + v_2' = 2 v_2' + c$.\n\n比较 $\\alpha_p$ 处的最终值，在原始序列中我们有 $\\sigma_2(\\alpha_p) = v_1 + v_2 = 2 \\sigma(\\alpha_p)$（因为 $v_1 = v_2 = \\sigma(\\alpha_p)$），而在重排后的序列中我们有 $\\sigma'_2(\\alpha_p) = 2 \\sigma(\\alpha_p) + c$。由于 $c$ 通常为非零，状态会不同。即使 $c=0$，序列在中间观察值上仍然不同，并且通常这种转换是不安全的，因为它改变了在 $\\alpha_p$ 处加载所读取的值。因此，当 $\\alpha_p = \\alpha_q$ 时，重排不是语义保持的。\n\n此分析表明，被测重排的正确性的充要条件是 $\\alpha_p \\neq \\alpha_q$。从别名分析的角度来看，一个保守的“可能别名”结果表明运行时地址可能相等。在数组 $A$ 和 $B$ 的表述中，“可能别名”被定义为 $A$ 和 $B$ 的子范围重叠：$\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1)$。如果“可能别名”为真，一个遵守别名分析的编译器就绝不能应用此重排，因为它在没有进一步信息的情况下无法保证对所有执行都有 $\\alpha_p \\neq \\alpha_q$。如果“必不别名”为真（无重叠），那么对于任何在界限内的有效 $i$ 和 $j$，$\\alpha_p \\neq \\alpha_q$ 都成立，该重排是安全的。\n\n程序的算法设计：\n- 对于每个测试用例，将内存数组 $M$ 初始化为给定的内容。\n- 计算 $\\alpha_p = a+i$ 和 $\\alpha_q = b+j$。断言两者都位于 $\\{0, 1, \\dots, L-1\\}$ 中。\n- 通过将 $M$ 复制到一个工作数组中并执行操作来模拟原始序列，以生成 $\\sigma_2$。\n- 通过将 $M$ 复制到第二个工作数组中并执行操作来模拟重排后的序列，以生成 $\\sigma'_2$。\n- 当且仅当在两个最终状态中 $\\alpha_p$ 和 $\\alpha_q$ 处的值相等时，计算布尔值 $s$ 为 $1$；否则，$s = 0$。\n- 当且仅当 $\\max(a, b) \\le \\min(a+n_A-1, b+n_B-1)$ 时，计算布尔值 $m$ 为 $1$；否则，$m = 0$。\n- 以要求的单行格式 `[[s_1,m_1],[s_2,m_2],...,[s_T,m_T]]` 输出所有测试用例的结果。\n\n将此应用于问题中的五个测试用例：\n- 情况 1：$\\alpha_p = 1, \\alpha_q = 7$，范围不相交，$s = 1, m = 0$。\n- 情况 2：$\\alpha_p = 3, \\alpha_q = 3$，范围重叠且地址相同，$s = 0, m = 1$。\n- 情况 3：$\\alpha_p = 2, \\alpha_q = 7$，范围重叠但地址不同，$s = 1, m = 1$。\n- 情况 4：$\\alpha_p = 4, \\alpha_q = 5$，范围相邻但不相交，$s = 1, m = 0$。\n- 情况 5：$\\alpha_p = 4, \\alpha_q = 4$，范围相同且地址相同，$s = 0, m = 1$。\n\n这些结果具体地验证了加载/存储重排必须遵守可能别名关系：当可能别名为真时，在 $\\alpha_p = \\alpha_q$ 的情况下执行重排会产生不同的语义，因此一个保守的编译器将避免此转换，除非它能证明不存在别名。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n// [Solution code to be inserted here]\n```", "id": "3630025"}]}