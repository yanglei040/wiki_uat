{"hands_on_practices": [{"introduction": "看似简单的算术运算，在不同编程语言或编译器中的行为可能存在细微差异。整数除法就是一个典型的例子，其取整方式会影响商和余数的结果。本练习将引导你探索两种常见的整数除法语义——“向零截断”和“向下取整”，并构建一个可执行的测试预言机（oracle）来精确识别和比较这些行为，这是编译器差异化测试中确保跨平台一致性的核心技能之一。[@problem_id:3637968]", "problem": "设计并实现一个完整的、可运行的程序，作为可执行的预言机（oracle），用于对编译器在整数除法和取余语义上进行差分测试。重点是检测在实现向零舍入除法与向负无穷舍入（floor）除法的编译器之间的不一致性。您必须从编译器理论和离散数学的第一性原理推导出算法，然后在一个自包含的程序中实现它。\n\n给定一组整数输入对 $(x,y)$，其中 $x,y \\in \\mathbb{Z}$。对于每对输入，您的程序必须计算两种整数除法语义：\n\n1. 向零截断（Truncation-toward-zero）除法语义，这是C编程语言标准等几种主流语言所定义的；它产生一个商 $q_{tz}$ 和一个余数 $r_{tz}$，旨在反映将 $x/y$ 向零舍入的结果。\n2. 向下取整（Floor-division）除法语义，这是多种语言和规范所定义的；它产生一个商 $q_{f}$ 和一个余数 $r_{f}$，旨在反映将 $x/y$ 向下舍入到不大于它的最大整数。\n\n您的推导必须基于整数的欧几里得分解：对于任何 $x \\in \\mathbb{Z}$ 和 $y \\in \\mathbb{Z}$（其中 $y \\neq 0$），存在 $q \\in \\mathbb{Z}$ 和 $r \\in \\mathbb{Z}$ 使得\n$$\nx = q \\cdot y + r.\n$$\n该分解在给定的舍入约定下将 $q$ 定义为商，将 $r$ 定义为余数。您不能假设任何快捷公式。相反，必须从上述分解结合以下公认事实来推导算法步骤：\n- 绝对值函数 $|z|$，对于 $z \\in \\mathbb{Z}$。\n- 向下取整函数 $\\lfloor z \\rfloor$ 和向上取整函数 $\\lceil z \\rceil$，对于 $z \\in \\mathbb{R}$。\n- 符号函数 $\\operatorname{sgn}(z)$，根据 $z$ 是负数、零还是正数，分别产生 $-1$、 $0$ 或 $1$。\n\n目标是为每个测试用例 $(x,y)$ 生成：\n- 向零截断的商 $q_{tz}$ 和余数 $r_{tz}$。\n- 向下取整的商 $q_{f}$ 和余数 $r_{f}$。\n- 一个布尔不匹配指示符 $m$，定义为：当且仅当 $q_{tz} \\neq q_{f}$ 或 $r_{tz} \\neq r_{f}$ 时，$m = 1$，否则 $m = 0$。\n- 一个有效性指示符 $v$，定义为：如果 $y \\neq 0$，则 $v = 1$；否则 $v = 0$。当 $v = 0$ 时，遇到除零错误，两种语义都应被视为未定义行为。在这种情况下，您必须为商和余数输出中立值（为两个商和两个余数都选择 $0$），并设置 $m = 0$。\n- 为了进行运行时自检，您必须计算两个布尔不变量：\n  - $p_{tz}$，当且仅当向零截断的余数满足 $|r_{tz}|  |y|$ 且 $r_{tz}$ 的符号与 $x$ 相同或为零时，$p_{tz} = 1$；否则，$p_{tz} = 0$。\n  - $p_{f}$，当且仅当向下取整的余数满足以下符号一致的边界条件时，$p_{f} = 1$：当 $y > 0$ 时，$0 \\le r_{f}  |y|$；当 $y  0$ 时，$-|y|  r_{f} \\le 0$；否则，$p_{f} = 0$。\n\n您的推导必须从欧几里得分解以及向下取整、向上取整、绝对值和符号函数的定义开始，并逻辑地推导出计算 $(q_{tz}, r_{tz})$ 和 $(q_{f}, r_{f})$ 的算法，尽可能只使用对非负值的整数运算。\n\n所有计算均使用有符号的 $64$ 位整数。如果 $y = 0$，则根据经典编译器理论，将两种语义都视为未定义行为，并设置 $v = 0$。\n\n测试套件：\n您必须实现以下有序的测试用例集，每个用例为一个数对 $(x,y)$：\n- $(7,3)$\n- $(-3,2)$\n- $(3,-2)$\n- $(-7,-3)$\n- $(0,5)$\n- $(5,5)$\n- $(1234567890123456789,10)$\n- $(-1234567890123456789,10)$\n- $(9,-1)$\n- $(5,0)$\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身也是一个列表：\n$$\n[\\,[v,q_{tz},r_{tz},q_{f},r_{f},m,p_{tz},p_{f}],\\ldots\\,]\n$$\n例如，整体形状必须为 $[\\text{case}_1,\\text{case}_2,\\ldots,\\text{case}_{10}]$，不含多余的空格或文本。此单行是您的程序应产生的唯一输出。\n\n此问题不涉及任何物理单位、角度单位或百分比；所有计算值均为整数或表示为整数的布尔值。", "solution": "该问题是有效的。它在科学上基于离散数学和计算机科学的既定原理，特别是整数除法理论及其在编程语言中的实现。它的提法是适定的，提供了一套完整且一致的定义、约束和测试用例，从而可以推导出唯一且可验证的解决方案。所有术语都得到了客观和形式化的定义。\n\n解决方案是从整数 $x$ 和 $y$（其中 $y \\neq 0$）的基本欧几里得分解推导出来的：\n$$\nx = q \\cdot y + r\n$$\n在这里，$q$ 是商，$r$ 是余数。不同的整数除法语义源于根据实数 $x/y$ 选择商 $q$ 的不同规则。我们将推导向零截断和向下取整除法语义的算法。所有计算都将使用有符号的 $64$ 位整数。\n\n**1. 向零截断除法语义 ($q_{tz}, r_{tz}$)**\n\n这种语义在 C 语言和许多其他语言中是标准，它通过截断实数 $z = x/y$（即移除其小数部分）来定义商 $q_{tz}$，这等同于向 $0$ 舍入。\n\n截断函数 $\\operatorname{trunc}(z)$ 可以使用向下取整和向上取整函数进行形式化定义：\n$$\n\\operatorname{trunc}(z) = \\begin{cases} \\lfloor z \\rfloor  \\text{if } z \\ge 0 \\\\ \\lceil z \\rceil  \\text{if } z  0 \\end{cases}\n$$\n因此，商 $q_{tz}$ 是：\n$$\nq_{tz} = \\operatorname{trunc}(x/y)\n$$\n相应的余数 $r_{tz}$ 则由分解公式唯一确定：\n$$\nr_{tz} = x - q_{tz} \\cdot y\n$$\n这种语义的一个关键属性是，余数 $r_{tz}$ 的符号总是与被除数 $x$ 的符号相同，或者为 $0$。形式上，如果 $r_{tz} \\neq 0$，则 $\\operatorname{sgn}(r_{tz}) = \\operatorname{sgn}(x)$。此外，余数的绝对值严格小于除数的绝对值：$|r_{tz}|  |y|$。这些属性构成了不变量 $p_{tz}$ 的基础。\n\n在 C 语言中，针对有符号整数的内置整数运算符 `/` 和 `%` 被指定为实现向零截断语义。因此，对于 $y \\neq 0$，我们可以直接计算：\n- $q_{tz} = x / y$\n- $r_{tz} = x \\% y$\n\n**2. 向下取整除法语义 ($q_{f}, r_{f}$)**\n\n这种语义通过将实数 $z = x/y$ 向负无穷方向舍入来定义商 $q_{f}$。这正是向下取整函数 $\\lfloor z \\rfloor$ 的定义。\n\n商 $q_f$ 定义为：\n$$\nq_{f} = \\lfloor x/y \\rfloor\n$$\n余数 $r_f$ 随后定义为：\n$$\nr_{f} = x - q_{f} \\cdot y = x - \\lfloor x/y \\rfloor \\cdot y\n$$\n根据向下取整函数的定义，我们有 $\\lfloor z \\rfloor \\le z  \\lfloor z \\rfloor + 1$。代入 $z = x/y$ 和 $q_f = \\lfloor x/y \\rfloor$，我们得到 $q_f \\le x/y  q_f + 1$。\n- 如果 $y > 0$，两边乘以 $y$ 得到 $q_f \\cdot y \\le x  q_f \\cdot y + y$。减去 $q_f \\cdot y$ 得到 $0 \\le x - q_f \\cdot y  y$。因此，$0 \\le r_f  y$。\n- 如果 $y  0$，两边乘以 $y$ 会反转不等号：$q_f \\cdot y \\ge x > q_f \\cdot y + y$。减去 $q_f \\cdot y$ 得到 $0 \\ge x - q_f \\cdot y > y$。因此，$y  r_f \\le 0$。\n\n关于 $r_f$ 的这两个条件（当 $y>0$ 时，$0 \\le r_f  |y|$；当 $y0$ 时，$-|y|  r_f \\le 0$）与不变量 $p_f$ 的定义相匹配。\n\n**3. 实现的算法推导**\n\n虽然 $q_{tz}$ 和 $r_{tz}$ 可以在 C 语言中直接计算，但我们必须使用可用的整数运算推导出计算 $q_f$ 和 $r_f$ 的算法。我们将 $q_f$ 与已经计算出的 $q_{tz}$ 关联起来。\n\n- **情况 1：$x/y \\ge 0$（即 $x$ 和 $y$ 符号相同，或 $x=0$）。**\n在这种情况下，$\\operatorname{trunc}(x/y) = \\lfloor x/y \\rfloor$。因此，$q_f = q_{tz}$。相应地，$r_f = x - q_f \\cdot y = x - q_{tz} \\cdot y = r_{tz}$。两种语义之间没有区别。\n\n- **情况 2：$x/y  0$（即 $x$ 和 $y$ 符号不同）。**\n  - 如果 $x/y$ 是整数（即 $x$ 是 $y$ 的倍数，因此 $r_{tz} = 0$），那么 $\\operatorname{trunc}(x/y) = x/y = \\lfloor x/y \\rfloor$。同样，$q_f = q_{tz}$ 且 $r_f = r_{tz}$。\n  - 如果 $x/y$ 不是整数（即 $r_{tz} \\neq 0$），那么 $\\lfloor x/y \\rfloor = \\lceil x/y \\rceil - 1 = \\operatorname{trunc}(x/y) - 1$。这意味着 $q_f = q_{tz} - 1$。\n    那么余数 $r_f$ 是：\n    $$\n    r_f = x - q_f \\cdot y = x - (q_{tz} - 1) \\cdot y = (x - q_{tz} \\cdot y) + y = r_{tz} + y\n    $$\n\n这导出了一个完整的算法：\n1.  使用 C 运算符 `/` 和 `%` 计算 $q_{tz}$ 和 $r_{tz}$。\n2.  检查 $x$ 和 $y$ 是否符号不同且 $r_{tz}$ 不为零。\n3.  如果此条件为真，则 $q_f = q_{tz} - 1$ 且 $r_f = r_{tz} + y$。\n4.  否则，$q_f = q_{tz}$ 且 $r_f = r_{tz}$。\n\n**4. 特殊情况和指示符**\n\n- **除以零 ($y=0$)：** 这是未定义行为。问题规定输出应为中立值。有效性指示符 $v$ 被设置为 $0$。所有商和余数的输出 ($q_{tz}, r_{tz}, q_f, r_f$) 都被设置为 $0$。不匹配指示符 $m$ 被设置为 $0$。对于不变量，由于 $|r_{tz}|  |y|$ 变为 $|0||0|$（假），$p_{tz}$ 为 $0$。对于 $p_f$ 的两个条件都失败了，因为 $y$ 既不是正数也不是负数，所以 $p_f$ 也为 $0$。输出元组为 $[0,0,0,0,0,0,0,0]$。\n\n- **指示符：** 对于每个有效情况 ($y \\neq 0$)：\n    - $v = 1$。\n    - $m = 1$ 如果 $q_{tz} \\neq q_f$ 或 $r_{tz} \\neq r_{f}$，否则 $m=0$。\n    - $p_{tz} = 1$ 如果 $|r_{tz}|  |y|$ 并且 $(\\operatorname{sgn}(r_{tz}) = \\operatorname{sgn}(x) \\text{ 或 } r_{tz} = 0)$。符号条件可以通过 `(x >= 0  r_tz >= 0) || (x = 0  r_tz = 0)` 来检查。\n    - $p_f = 1$ 如果 $(y > 0 \\text{ 且 } 0 \\le r_f  y)$ 或 $(y  0 \\text{ 且 } y  r_f \\le 0)$。\n\n推导到此完成。该逻辑现在可以用于 C 程序的实现。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include\n```", "id": "3637968"}, {"introduction": "当我们有多种方式编写同一个程序，并且没有一个“黄金标准”版本可供比较时，如何测试编译器的优化器呢？我们将运用一种名为“蜕变测试”（metamorphic testing）的强大技术，利用一个已知的数学属性——等差数列求和公式——作为一个绝对正确的预言机。通过这个练习，你将学会创建一个测试工具，用以验证多个结构迥异的循环实现，从而能够发现那些仅在特定代码模式下才会暴露的、最隐蔽的优化错误。[@problem_id:3637908]", "problem": "设计并实现一个完整、可运行的程序，该程序实例化一个实用的差分测试框架，用于利用基于循环的程序的蜕变属性来测试编译器。其基本依据包括：(i) 良定义代码的确定性程序执行语义；(ii) 无溢出情况下的标准整数算术定律；以及 (iii) 一个等差数列恒等式（一个经过充分检验的数学事实）：对于任意非负整数 $n$，从 $0$ 到 $n-1$ 的连续整数求和满足\n$$\n\\sum_{i=0}^{n-1} i \\;=\\; \\frac{n(n-1)}{2}.\n$$\n您的任务是利用此恒等式作为蜕变测试中编译器无关的预言机：多个语法上不同但语义上等价的循环结构必须计算出相同的求和数值结果，并且该结果必须等于该封闭形式恒等式。如果编译器的优化器引入了错误，不同的循环变体可能会相互不一致，或与预言机不一致。\n\n要求：\n1. 构建 $8$ 个循环变体，每个变体都使用不同的控制流形态计算总和 $\\sum_{i=0}^{n-1} i$，包括但不限于：\n   - 一个使用后置递增的规范计数循环，\n   - 一个使用前置递增的计数循环，\n   - 一个倒序计数的反向循环，\n   - 一个 while 循环，\n   - 一个 do-while 循环，\n   - 一个从两端收敛的成对双索引求和，\n   - 一个使用后置递减归纳变量的循环，\n   - 一个使用显式跳转或等效控制结构的结构等价循环。\n   这些变体必须没有未定义行为。所有算术运算必须在无符号 $64$ 位整数算术中执行，以避免有符号溢出。确保选择的整数范围不会导致所提供的测试套件发生无符号 $64$ 位溢出。\n\n2. 实现一个封闭形式的预言机函数，对于给定的非负整数 $n$，该函数返回 $\\frac{n(n-1)}{2}$，并且在所提供的测试套件中，中间乘积不会溢出。您必须在整数算术中通过先除以 $2$ 再进行乘法来实现它，以使中间乘积保持在范围内；例如，如果 $n$ 是偶数，则计算 $(n/2)\\cdot(n-1)$，如果 $n$ 是奇数，则计算 $n\\cdot\\big((n-1)/2\\big)$。\n\n3. 差分测试框架：\n   - 对于每个测试值 $n$，计算每个循环变体和预言机的结果。\n   - 对于每个 $n$，输出一个布尔值，该值当且仅当所有循环变体产生相同的值且该值等于预言机时为真。\n\n4. 测试套件：\n   使用以下 $8$ 个测试值作为 $n$ 的集合，这些值旨在覆盖正常路径和类边界行为，同时在 $64$ 位算术中保持高效和溢出安全：\n   - $n \\in \\{0, 1, 2, 3, 10, 127, 1000, 200000\\}$。\n\n5. 输出格式：\n   您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个布尔值必须表示为整数 $1$（真）和 $0$（假）。该列表的顺序必须与上述测试套件中的 $n$ 值相对应。例如，所有检查都通过的输出必须如下所示：\n   $[1,1,1,1,1,1,1,1]$。\n\n无需外部输入。代码必须是自包含和确定性的。\n\n科学真实性和约束：\n- 所有计算都必须使用无符号 $64$ 位整数执行，以避免有符号溢出和未定义行为，并且所选的测试套件确保总和 $\\frac{n(n-1)}{2}$ 位于 $[0, 2^{64}-1]$ 的范围内。\n- 确保所有循环形式对于 $n=0$ 和较小的 $n$ 都能正确终止。\n- 推理必须纯粹是逻辑和数学上的；不适用任何物理单位。", "solution": "当前问题要求设计并实现一个用于编译器的差分测试框架。本练习的核心原则基于蜕变测试的概念，这是一种用于生成测试预言机的强大技术。在这种范式中，我们利用被测函数的已知属性（或称蜕变关系）来验证其输出，而无需为所有输入预先计算一组预期结果。如果某个属性被违反，则很可能存在错误。\n\n在这里，“被测函数”不是单段代码，而是编译过程本身，特别是 C 编译器的优化阶段。该蜕变属性源自一个基本的数学恒等式：前 $n$ 个非负整数的和由封闭形式表达式 $\\sum_{i=0}^{n-1} i = \\frac{n(n-1)}{2}$ 给出。\n\n测试策略如下：我们创建多个语法上不同的 C 函数，这些函数在语义上都旨在计算同一个总和 $\\sum_{i=0}^{n-1} i$。一个正确无误的编译器应该为这些变体中的每一个生成机器码，在没有未定义行为或算术溢出的情况下，这些机器码应产生完全相同的数值结果。此外，该结果必须与一个实现了封闭形式恒等式 $\\frac{n(n-1)}{2}$ 的可信“预言机”函数计算的值相匹配。任何循环变体之间，或变体与预言机之间的差异，都表明可能存在编译器缺陷，即某个优化可能错误地改变了程序的语义。\n\n该实现包括三个主要部分：测试预言机、循环变体集合以及测试框架。\n\n**1. 测试预言机**\n\n预言机提供了衡量所有循环变体的基准真相。它使用直接的数学公式 $S(n) = \\frac{n(n-1)}{2}$ 来计算总和。为了防止中间整数溢出（对于非常大的 $n$，朴素地计算 $n \\cdot (n-1)$ 可能会发生溢出），该实现被设计为首先执行除以 $2$ 的操作。因为对于任何整数 $n$，$n$ 或 $n-1$ 必有一个是偶数，所以这个除法总能得到一个整数。计算方式如下：\n- 如果 $n$ 是偶数：$S(n) = (n/2) \\cdot (n-1)$\n- 如果 $n$ 是奇数：$S(n) = n \\cdot ((n-1)/2)$\n所有算术运算均使用 `unsigned long long` 类型，该类型保证至少有 $64$ 位宽，足以在不溢出的情况下容纳给定测试套件的所有中间和最终结果。对于 $n = 200000$，最大的和是 $19,999,900,000$，远在一个 $64$ 位无符号整数的范围内（约 $1.84 \\times 10^{19}$）。\n\n**2. 循环变体**\n\n实现了一组 $8$ 个不同的循环函数来计算总和。这些变体被设计成具有不同的控制流结构，从而测试编译器中不同的潜在优化路径。每个函数接受一个 `unsigned long long` 参数 $n$ 并返回计算出的总和。所有循环都经过精心构造，以确保没有未定义行为，并能正确处理边缘情况，特别是 $n=0$ 和 $n=1$。这些变体是：\n- **规范的 `for` 循环（后置递增）：** 最常见的求和循环，`for (i = 0; i  n; i++)`。\n- **`for` 循环（前置递增）：** 使用 `++i` 而非 `i++`。对于此循环体功能相同，但语法上不同。\n- **反向 `for` 循环：** 从 $n$ 倒数到 $1$，在每一步中对 `i-1` 求和。这测试了对递减计数循环的优化。使用条件 `i > 0` 是为了确保无符号类型的安全性。\n- **`while` 循环：** 规范 `for` 循环的直接转换，将初始化、条件和更新语句分开。\n- **`do-while` 循环：** 此变体至少执行一次，因此需要一个显式检查来正确处理 $n=0$ 的情况，此时不应进入循环体。\n- **成对求和：** 使用两个索引变量，$low$ 从 $0$ 开始，$high$ 从 $n-1$ 开始，向中间收敛。在每一步中，`sum += low + high`。如果 $n$ 是奇数，则需要额外的一步来加上中间的元素。\n- **后置递减循环：** 此变体使用 `for(;;)` 无限循环结构，并带有一个基于后置递减运算符 (`i--`) 的 `break` 条件，提供了另一种独特的控制流。\n- **基于 `goto` 的循环：** 使用显式标签和 `goto` 语句模仿 `while` 循环的结构，直接测试编译器对非结构化控制流的处理。\n\n**3. 测试框架**\n\n`main` 函数作为测试框架。它定义了 $n$ 的测试套件，其中包括值 $\\{0, 1, 2, 3, 10, 127, 1000, 200000\\}$。对于此套件中的每个 $n$ 值，该框架执行以下步骤：\n- 它使用 `oracle_sum` 函数计算预期结果。\n- 它遍历一个函数指针数组，其中每个指针引用 $8$ 个循环变体之一。\n- 对于每个变体，它用 $n$ 调用该函数，并将其返回值与预言机的结果进行比较。\n- 如果任何变体产生的结果偏离了预言机，则当前 $n$ 的标志被设置为 $0$（假）。如果所有变体都与预言机匹配，则标志保持为 $1$（真）。\n- 最后，程序打印单行输出：一个由这些布尔标志（表示为 $1$ 或 $0$）组成的逗号分隔列表，用方括号括起来，与 $n$ 的测试值序列相对应。\n\n这个完整的结构提供了一个自包含、确定性的程序，可作为对 C 编译器基于循环的整数算术实现的实用蜕变测试。一个正确的编译器应该产生输出 `[1,1,1,1,1,1,1,1]`。", "answer": "```c\n// This program implements a differential testing harness for C compilers.\n// It uses a known mathematical identity as a metamorphic relation to verify\n// that multiple, structurally distinct loop constructs produce identical results.\n#include\n```", "id": "3637908"}]}