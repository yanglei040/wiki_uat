{"hands_on_practices": [{"introduction": "理论联系实际是掌握任何复杂概念的关键。理解三色标记不变量的性能影响，是深入学习垃圾回收机制的重要一步。这个练习将引导你量化写屏障（Write Barrier）带来的开销，并通过一个具体的对比场景，揭示不同的编程范式（如使用不可变数据结构）如何显著影响这一开销，从而让你对系统性能优化有更直观的认识。[@problem_id:3679450]", "problem": "一个执行增量标记-清除的垃圾回收器 (GC) 使用堆的三色抽象：每个对象都被着色为白色（未到达）、灰色（已到达但未完全扫描）或黑色（已到达且已完全扫描）。三色标记不变量规定，在回收周期内，不能存在从黑色对象到白色对象的指针。写屏障是运行时使用的一种机制，用于在存在修改器（mutator）写入的情况下维护此不变量。\n\n考虑在一个使用Dijkstra风格着色（新分配的对象初始为白色）的增量标记回收器下，一个应用级数据结构的两种实现。在这两种实现中，逻辑操作发生在GC处于标记阶段时，并且修改器和回收器任意交错执行。\n\n基准可变实现：\n- 每个逻辑操作平均对已存在的可变对象执行 $m = 40$ 次指针写入。\n- 在标记阶段，对于任何给定的修改写入，接收者对象为黑色的概率是 $p_{B} = 0.7$，并且独立地，该写入指向的新目标对象为白色的概率是 $p_{W} = 0.6$。\n\n带尾部共享的持久化不可变实现：\n- 每个逻辑操作分配 $L = 12$ 个新的不可变节点，每个节点有 $c = 3$ 个指针字段，在分配时初始化以指向现有节点，从而利用尾部共享。\n- 新分配的节点在分配时是白色的。初始化这些新节点字段的写入操作发生在这些新节点颜色发生任何改变之前。\n- 每个操作对现有状态的唯一修改是更新一个全局根变量，使其指向新构建的头节点。在这次根更新时，根变量（接收者）为黑色的概率是 $p_{R} = 0.95$。\n\n仅使用三色标记不变量的定义以及“写屏障仅用于防止创建从黑色接收者到白色目标的指针”这一事实，从第一性原理推导出，从基准可变实现切换到带尾部共享的持久化不可变实现后，被消除的受写屏障保护的存储操作的期望比例。将此期望消除比例表示为单个十进制实数，并四舍五入到四位有效数字。", "solution": "用户希望我解决一个关于垃圾回收和三色标记不变量的问题。\n\n这是我的计划：\n1.  **验证问题陈述**：我需要执行我严格的验证流程。\n    *   **第一步：提取已知条件**：我将列出问题中提供的所有数字、变量和条件。\n    *   **第二步：验证**：我将检查问题是否具有科学依据、是否定义明确、是否客观，并且不属于任何无效类别。\n        *   该问题关于编译器原理，特别是垃圾回收，这是一个标准的计算机科学主题。\n        *   三色抽象和不变量是并发和增量GC中的基本概念。\n        *   Dijkstra风格的写屏障是一种已知的技术。\n        *   问题提供了数值（$m$、$p_B$、$p_W$、$L$、$c$、$p_R$）并要求进行定量比较。\n        *   两种实现（可变与持久化）的定义似乎是连贯的。\n        *   问题是具体的：“从第一性原理推导出被消除的受写屏障保护的存储操作的期望比例”。\n\n2.  **解决问题（如果有效）**：\n    *   问题的核心是计算每个实现中每次逻辑操作的写屏障调用期望次数。\n    *   写屏障被要求“仅用于防止创建从黑色接收者到白色目标的指针”。\n    *   因此，当且仅当发生指针写入`obj.field = target`，其中`obj`是黑色的而`target`是白色的时，才会触发写屏障。\n\n    **基准可变实现的分析：**\n    *   每次逻辑操作有 $m = 40$ 次指针写入。\n    *   这些写入是针对“已存在的可变对象”。\n    *   对于任何给定的写入，接收者对象为黑色的概率是 $p_B = 0.7$。\n    *   新的目标对象为白色的概率是 $p_W = 0.6$。\n    *   问题说明这些概率是独立的。\n    *   单次写入触发屏障的概率是接收者为黑色且目标为白色的概率。\n    *   $P(\\text{每次写入触发屏障}) = P(\\text{接收者为黑色} \\cap \\text{目标为白色})$。\n    *   由于它们是独立的，$P(\\text{每次写入触发屏障}) = P(\\text{接收者为黑色}) \\times P(\\text{目标为白色}) = p_B \\times p_W$。\n    *   每次逻辑操作触发屏障的期望次数是写入次数乘以每次写入的概率。\n    *   设 $E_{mutable}$ 为可变实现中每次逻辑操作的写屏障调用期望次数。\n    *   $E_{mutable} = m \\times (p_B \\times p_W)$。\n\n    **持久化不可变实现的分析：**\n    *   此实现每次逻辑操作有两种类型的写入。\n    *   **类型1：新节点的初始化。**\n        *   分配了 $L = 12$ 个新节点。\n        *   每个新节点有 $c = 3$ 个指针字段。\n        *   总初始化写入次数 = $L \\times c = 12 \\times 3 = 36$。\n        *   问题陈述：“新分配的节点在分配时是白色的。”\n        *   并且“初始化这些新节点字段的写入操作发生在这些新节点颜色发生任何改变之前。”\n        *   这意味着这些写入的接收者（新分配的节点）始终是**白色**的。\n        *   只有当接收者是**黑色**时才会触发写屏障。\n        *   因此，这 $L \\times c$ 次初始化写入都不会触发写屏障。触发概率为 $0$。\n        *   接收者是白色的，因此不满足“黑色接收者”的条件。目标是什么颜色无关紧要。\n        *   这部分的屏障触发次数为 $0$。\n\n    *   **类型2：全局根变量的更新。**\n        *   存在“一次全局根变量的更新”。这是一次指针写入。\n        *   这次写入的接收者是“根变量”。问题陈述“根变量（接收者）为黑色的概率是 $p_R = 0.95$”。\n        *   让我们注意术语。一个“根变量”不是堆上的对象，而是一个位置（例如，在寄存器或栈上），它指向一个堆对象。问题说“根变量（接收者）为黑色的概率”。这是一种稍微不精确的语言。在三色方案中，根本身是标记的起点。屏障保护的是*对一个对象字段的*写入。`obj.field = value`。如果`value`是一个指向白色对象的指针，而`obj`是黑色的，我们就有问题了。问题说“更新一个全局根变量，使其指向新构建的头节点”。这更像是`root = new_head`。这个写入并没有修改一个*已存在的*堆对象。然而，从GC的角度来看，根集合实际上是一个“黑色”实体（或最初是灰色）。让我们重读不变量：“不能存在从黑色对象到白色对象的指针”。根不是一个对象。但是一次`root = new_head`的写入可以被解释为从“根集合”到`new_head`创建了一个新指针。如果我们认为根集合本身是黑色的，而`new_head`是白色的，那么这个写入就创建了一个`黑色 -> 白色`的指针。这似乎是预期的解释。\n        *   让我们尝试另一种解释。也许“根变量”是某个C风格的`struct Root { Node* head; }`。我们正在执行`g_root.head = new_head`。在这种情况下，`g_root`是接收者对象。问题陈述“根变量（接收者）为黑色的概率是 $p_R = 0.95$”。这样更具一致性。接收者对象`g_root`为黑色的概率是$p_R$。\n        *   目标的颜色是什么？目标是“新构建的头节点”。\n        *   问题说“新分配的节点在分配时是白色的。”并且初始化写入发生在任何颜色变化之前。\n        *   所以，“新构建的头节点”是 $L$ 个新节点之一，在根更新时它是**白色**的。\n        *   因此，对于这次单一的根更新写入：\n            *   接收者为黑色的概率 = $p_R = 0.95$。\n            *   目标为白色的概率 = $1$ （它是一个新节点）。\n            *   这次写入触发屏障的概率是 $p_R \\times 1 = p_R$。\n        *   设 $E_{immutable}$ 为不可变实现中每次逻辑操作的写屏障调用期望次数。\n        *   $E_{immutable} = (L \\times c \\times 0) + (1 \\times p_R) = p_R$。\n\n    **计算：**\n    *   $E_{mutable} = m \\times p_B \\times p_W = 40 \\times 0.7 \\times 0.6$。\n    *   $E_{mutable} = 40 \\times 0.42 = 16.8$。\n    *   $E_{immutable} = p_R = 0.95$。\n    *   问题要求的是“被消除的受写屏障保护的存储操作的期望比例”。\n    *   消除的存储操作数量 = $E_{mutable} - E_{immutable}$。\n    *   消除的存储操作比例 = $\\frac{E_{mutable} - E_{immutable}}{E_{mutable}} = 1 - \\frac{E_{immutable}}{E_{mutable}}$。\n    *   消除的比例 = $1 - \\frac{0.95}{16.8}$。\n\n    我们来计算这个值：\n    *   $0.95 / 16.8 \\approx 0.0565476...$\n    *   $1 - 0.0565476... \\approx 0.9434523...$\n    *   问题要求将答案四舍五入到四位有效数字。\n    *   $0.9435$。\n\n    让我们再次检查一下解释。\n    *   **可变实现：** $m=40$ 次写入。接收者为黑色的概率为 $p_B=0.7$。目标为白色的概率为 $p_W=0.6$。假设独立。期望屏障数 = $40 \\times 0.7 \\times 0.6 = 16.8$。这看起来很可靠。\n    *   **不可变实现：** 这是棘手的部分。“分配 $L = 12$ 个新的不可变节点，每个节点有 $c = 3$ 个指针字段，在分配时初始化”。所以有 $12 \\times 3 = 36$ 次写入。这些写入的接收者是“新的不可变节点”。“新分配的节点在分配时是白色的。”“初始化这些新节点字段的写入操作发生在这些新节点颜色发生任何改变之前。”这证实了这36次写入的接收者是白色的。对于`黑色 -> 白色`的指针需要屏障。由于接收者是白色的，这36次写入不需要屏障。期望屏障数 = $36 \\times 0 = 0$。\n    *   然后，“每个操作对现有状态的唯一修改是更新一个全局根变量，使其指向新构建的头节点。”这是一次写入。“在这次根更新时，根变量（接收者）为黑色的概率是 $p_R = 0.95$。”这为那一次写入提供了接收者颜色的概率。“...使其指向新构建的头节点。”这证实了目标是一个新的（因此是白色的）节点。\n\n    一切看起来都一致。一旦期望值设定好，计算就很直接了。\n\n    **最终计算检查：**\n    $E_{mutable} = 40 \\times 0.7 \\times 0.6 = 16.8$\n    $E_{immutable} = 0.95$\n    消除的比例 $F = \\frac{E_{mutable} - E_{immutable}}{E_{mutable}} = \\frac{16.8 - 0.95}{16.8} = \\frac{15.85}{16.8}$\n\n    $15.85 / 16.8 = 0.94345238095...$\n    四舍五入到四位有效数字：\n    第一个非零数字是9。\n    接下来的三个是4、3、4。\n    第四位有效数字（4）后面的数字是5。由于它大于或等于5，我向上取整。\n    所以 $0.94345...$ 变为 $0.9435$。\n\n    整个过程看起来很可靠。我现在将构建输出。\n\n    **验证阶段：**\n    *   **第一步：提取已知条件：**\n        *   主题：垃圾回收中的三色标记不变量。\n        *   不变量：不能存在从黑色对象到白色对象的指针。\n        *   写屏障触发条件：创建从黑色接收者到白色目标的指针。\n        *   着色方案：Dijkstra风格，新分配的对象初始为白色。\n        *   可变实现：\n            *   每次操作的平均指针写入次数：$m = 40$。\n            *   写入到已存在的可变对象中。\n            *   接收者为黑色的概率：$p_{B} = 0.7$。\n            *   目标为白色的概率：$p_{W} = 0.6$。\n            *   声明这些概率是独立的。\n        *   不可变实现：\n            *   每次操作的新不可变节点数：$L = 12$。\n            *   每个新节点的指针字段数：$c = 3$。\n            *   新节点的初始化发生在节点为白色时。\n            *   每次操作对一个全局根变量进行单次修改。\n            *   根变量（接收者）为黑色的概率：$p_{R} = 0.95$。\n            *   根更新的目标是一个新构建的（白色）节点。\n        *   任务：推导被消除的受写屏障保护的存储操作的期望比例。\n        *   输出格式：单个十进制实数，四舍五入到四位有效数字。\n\n    *   **第二步：使用提取的已知条件进行验证：**\n        *   **科学性**：是。该问题基于计算机科学中标准且完善的概念（垃圾回收、三色标记、写屏障、持久化数据结构）。所有概念都得到了正式定义和正确使用。\n        *   **定义明确**：是。问题提供了所有必要的数值数据和概率假设来计算唯一的期望值。问题是精确的。\n        *   **客观性**：是。语言是技术性的且无偏见的。它描述了两种算法，并要求基于给定参数进行定量比较。\n        *   我没有发现任何缺陷。该问题不是：\n            1.  **不健全**：这是一个教科书式的计算机科学问题。\n            2.  **不可形式化**：它完全可以形式化为一个概率计算。\n            3.  **不完整/矛盾**：所有数据都已提供。两种场景是不同的且内部一致的。\n            4.  **不切实际**：该场景是系统编程中一个标准的性能分析问题。所给的概率只是模型的参数。\n            5.  **不适定**：可以推导出一个唯一答案。\n            6.  **琐碎/同义反复**：需要基于所提供模型进行逐步推理和计算。\n            7.  **超出科学可验证性**：这是一个基于模型的数学推导，是标准的科学/工程活动。\n\n    *   **第三步：结论和行动：**\n        *   问题是**有效的**。我将继续进行详细的解答。\n\n    **解答编写阶段：**\n    1.  陈述原理：对于一次写入`receiver.field = target`，如果`receiver`是黑色的且`target`是白色的，则会触发写屏障。\n    2.  计算可变实现的期望屏障触发次数 $E_{mut}$。\n        *   每次操作的写入次数为 $m$。\n        *   单次写入触发屏障的概率为 $P(\\text{接收者为黑色}) \\times P(\\text{目标为白色}) = p_B p_W$。\n        *   $E_{mut} = m \\cdot p_B \\cdot p_W$。\n        *   代入数值：$E_{mut} = 40 \\times 0.7 \\times 0.6 = 16.8$。\n    3.  计算不可变实现的期望屏障触发次数 $E_{imm}$。\n        *   将写入分为两类。\n        *   类型1：初始化写入。写入次数 = $L \\cdot c = 12 \\times 3 = 36$。\n        *   对于这些写入，接收者是新分配的节点，是白色的。接收者为黑色的概率是 $0$。\n        *   类型1写入的期望屏障数是 $L \\cdot c \\cdot 0 = 0$。\n        *   类型2：根更新写入。写入次数 = $1$。\n        *   对于这次写入，接收者为黑色的概率是 $p_R = 0.95$。\n        *   目标是新构建的节点，是白色的。目标为白色的概率是 $1$。\n        *   类型2写入的期望屏障数是 $1 \\cdot p_R \\cdot 1 = p_R$。\n        *   $E_{imm} = 0 + p_R = 0.95$。\n    4.  计算被消除的屏障的比例。\n        *   每次操作消除的屏障数量：$E_{mut} - E_{imm}$。\n        *   消除的屏障比例：$F = \\frac{E_{mut} - E_{imm}}{E_{mut}} = 1 - \\frac{E_{imm}}{E_{mut}}$。\n        *   代入数值：$F = 1 - \\frac{0.95}{16.8}$。\n        *   计算数值并四舍五入到四位有效数字。\n        *   $F = 1 - 0.0565476... \\approx 0.943452... \\approx 0.9435$。\n\n    所有检查都通过了。我准备生成最终的响应。", "answer": "$$\n\\boxed{0.9435}\n$$", "id": "3679450"}, {"introduction": "在理解了写屏障的基本成本后，下一步自然是探索如何对其进行优化。现代高性能应用常常涉及大规模数据操作，例如批量内存复制，这对写屏障的效率提出了极高要求。这个练习将带你进入写屏障设计的前沿，探索如何利用向量化（SIMD）、卡片标记（Card Marking）和布隆过滤器（Bloom Filter）等高级技术，在确保三色不变式正确性的前提下，实现高效的并发内存管理。[@problem_id:3679528]", "problem": "在一个带有垃圾回收（GC）的托管运行时中，一个变异器（mutator）使用批量拷贝操作 $memcpy$ 将一个引用数组从源数组 $S$ 拷贝到目标数组 $D$。为了在并发增量标记期间避免违反三色标记不变量，我们需要 Dijkstra 写屏障来强制执行 $B \\not\\to W$ 不变量（即没有黑色对象指向白色对象）。该运行时实现了单指令多数据（SIMD）向量化，其通道宽度为 $w$，以每次迭代处理 $w$ 个引用的数据块来执行 $memcpy$。堆是使用卡片标记来组织的：每个卡片覆盖 $c$ 个数组槽位，数组总共有 $n$ 个元素。假设在拷贝的瞬间，任何单个被拷贝的引用指向一个白色对象的概率是 $p$，且各元素之间是相互独立的。\n\n你需要评估用于 $memcpy$ 的屏障设计，这些设计旨在向量化下高效地维护 $B \\not\\to W$，并在使用保守近似时对误报（false positives）进行定量推理。考虑以下具体参数：$n = 8192$，$w = 8$，$c = 128$ 以及 $p = 0.01$。在一种设计中，通过每个对象存储的颜色位图来精确检查其是否为白色；在另一种设计中，当当前的白色对象集合包含 $n_w = 10^{5}$ 个对象时，使用一个具有 $m = 2^{22}$ 位和 $k = 3$ 个哈希函数的布隆过滤器（BF）来保守地近似判断对象是否为白色。假设布隆过滤器没有漏报（false negatives），其误报概率为 $p_{\\mathrm{bf}} \\approx \\left(1 - e^{-k n_w / m}\\right)^{k}$。\n\n在这些假设下，哪些选项是正确的？\n\nA. 一种向量化的 Dijkstra 屏障，对于每个包含 $w$ 个引用的 SIMD 数据块，它从精确的颜色位图中收集 $w$ 个白色状态位，并且只对目标为白色的通道进行条件性着色，该屏障始终维护 $B \\not\\to W$。在 $memcpy$ 过程中预期被着色的目标数量是 $n p$，如果位图是精确的，则没有误报。\n\nB. 一种保守的卡片着色屏障，它将 $memcpy$ 触及的每个目标卡片标记为灰色，而不检查所引用对象的颜色，该屏障维护了 $B \\not\\to W$。在给定参数下，预期误报着色的卡片数量是 $\\dfrac{n}{c} \\left(1 - (1-p)^{c}\\right)$。\n\nC. 一种向量化的屏障，它为每个通道检查布隆过滤器，并对布隆过滤器返回为阳性的目标进行着色，该屏障维护了 $B \\not\\to W$。在给定参数下，预期的误报着色数量是 $n (1-p) \\, p_{\\mathrm{bf}}$，其中 $p_{\\mathrm{bf}} \\approx \\left(1 - e^{-k n_w / m}\\right)^{k}$。\n\nD. 一种屏障，它通过将单个 $(D,\\;n)$ 范围描述符推入一个工作列表来推迟所有着色操作，并且仅在 $memcpy$ 完成后才执行着色，期间不与回收器协调，该屏障能维护 $B \\not\\to W$，因为拷贝在数组级别上是原子的。", "solution": "这个问题的核心在于在并发垃圾回收期间维护三色不变量，特别是强不变量，即黑色对象不得指向白色对象，记作 $B \\not\\to W$。写屏障是由变异器（应用程序代码）执行的一种机制，用于通知回收器指针发生了修改，从而防止违反此不变量。我们正在考虑一个 `memcpy` 操作，`$\\text{memcpy}(D, S, n)$`，它将 $n$ 个引用从源数组 $S$ 拷贝到目标数组 $D$。我们假设包含数组 $D$ 的对象是黑色的；否则，写屏障就不是必需的，因为从灰色或白色对象发出的新指针不会创建 $B \\to W$ 边。Dijkstra 风格的写屏障通过确保以下方式来强制执行该不变量：如果一个指向白色对象的引用被存储在一个黑色对象中，那么在回收器可能错过它之前，目标白色对象会被着色为灰色。\n\n给定的参数是：\n- 数组元素总数: $n = 8192$\n- SIMD 向量宽度: $w = 8$\n- 卡片大小: $c = 128$ 个数组槽位\n- 引用指向白色对象的概率: $p = 0.01$\n- 对于布隆过滤器 (BF):\n    - 位数: $m = 2^{22}$\n    - 哈希函数数量: $k = 3$\n    - 白色对象数量: $n_w = 10^5$\n- 布隆过滤器的误报概率由 $p_{\\mathrm{bf}} \\approx \\left(1 - e^{-k n_w / m}\\right)^{k}$ 给出。\n\n让我们根据这些原则和参数来评估每个选项。\n\n### 选项 A 评估\n**声明：** 一种向量化的 Dijkstra 屏障，对于每个包含 $w$ 个引用的 SIMD 数据块，它从精确的颜色位图中收集 $w$ 个白色状态位，并且只对目标为白色的通道进行条件性着色，该屏障始终维护 $B \\not\\to W$。在 `memcpy` 过程中预期被着色的目标数量是 $n p$，如果位图是精确的，则没有误报。\n\n**分析：**\n1.  **不变量维护：** 该屏障设计检查每个被拷贝的引用。对于每个指向白色对象的引用，它将目标对象着色为灰色。由于目标对象 $D$ 是黑色的，一个新的指针 `D[i] -> T`（其中 $T$ 是白色的）会创建一个 $B \\to W$ 边。通过将 $T$ 着色为灰色，新的边变成了 $B \\to G$，这不会违反不变量。这个过程对每个引用都执行，因此在整个 `$\\text{memcpy}$` 过程中不变量都得以维护。SIMD 向量化的使用是一个影响性能但不影响屏障逻辑正确性的实现细节。\n\n2.  **定量分析：** 我们需要找出预期被着色的目标数量。设 $X_i$ 是第 $i$ 个元素的伯努利随机变量，如果目标是白色的，则 $X_i=1$，否则 $X_i=0$。问题陈述 $P(X_i=1) = p$。被着色的目标总数是 $N_{shaded} = \\sum_{i=1}^{n} X_i$。根据期望的线性性质，预期的被着色目标数量是：\n    $$E[N_{shaded}] = E\\left[\\sum_{i=1}^{n} X_i\\right] = \\sum_{i=1}^{n} E[X_i] = \\sum_{i=1}^{n} P(X_i=1) = \\sum_{i=1}^{n} p = n p$$\n    问题陈述颜色位图是“精确的”，这意味着它的误报率为 $0$，漏报率也为 $0$。只有真正是白色的对象才会被着色。因此，没有误报。\n\n**结论：** 该屏障的逻辑描述是合理的，它正确地维护了 $B \\not\\to W$ 不变量，并且对着色数量和误报的定量分析是正确的。\n\n**判定：** 正确。\n\n### 选项 B 评估\n**声明：** 一种保守的卡片着色屏障，它将 `memcpy` 触及的每个目标卡片标记为灰色，而不检查所引用对象的颜色，该屏障维护了 $B \\not\\to W$。在给定参数下，预期误报着色的卡片数量是 $\\dfrac{n}{c} \\left(1 - (1-p)^{c}\\right)$。\n\n**分析：**\n1.  **不变量维护：** 该屏障在内存卡片这一更粗的粒度上操作。通过“将每个触及的目标卡片标记为灰色”，我们理解为这意味着该卡片被“弄脏”（dirtied）。黑色对象中的一个脏卡片向 GC 发出信号，表示必须重新扫描该内存区域以查找指向白色对象的新指针。这次重新扫描会找到任何新创建的 $B \\to W$ 指针，并通过将目标着色为灰色来修复它们。因此，这种保守方法确实维护了不变量。\n\n2.  **定量分析：** 屏障标记了 `$\\text{memcpy}$` 触及的*每一个*卡片。`$\\text{memcpy}$` 覆盖 $n = 8192$ 个槽位，每个卡片覆盖 $c = 128$ 个槽位。触及的卡片数量为 $\\frac{n}{c} = \\frac{8192}{128} = 64$。策略是标记所有这 $64$ 个卡片。\n    “误报”卡片着色意味着一个卡片被标记为脏卡，即使写入该卡片槽位的引用中没有一个指向白色对象。\n    让我们计算一个卡片成为误报的概率。\n    - 单个引用*不*指向白色对象的概率是 $1-p$。\n    - 由于引用是独立的，一个卡片中*所有* $c$ 个引用都*不*指向白色对象的概率是 $(1-p)^c$。这是一个卡片不包含指向白色对象的指针的概率。\n    - 该策略无论如何都会对着色卡片。所以，如果卡片被着色（这总是发生）并且它不包含指向白色对象的指针，那么就发生了误报。因此，概率是 $P(\\text{误报}) = (1-p)^c$。\n    - 误报卡片的预期数量是被着色的卡片总数乘以这个概率。由于所有 $\\frac{n}{c}$ 个卡片都被着色，期望值为：\n      $$E[\\text{误报}] = \\frac{n}{c} \\times (1-p)^c$$\n    现在，让我们检查选项中的公式：$\\dfrac{n}{c} \\left(1 - (1-p)^{c}\\right)$。\n    项 $1 - (1-p)^c$ 是一个卡片中*至少有一个*引用指向白色对象的概率。这是一个卡片是“真阳性”（即，它确实需要被扫描）的概率。因此，选项中的公式计算的是*真阳性*卡片的预期数量，而不是误报卡片的数量。\n\n**结论：** 屏障维护了不变量，但是误报的预期数量的公式是不正确的。\n\n**判定：** 不正确。\n\n### 选项 C 评估\n**声明：** 一种向量化的屏障，它为每个通道检查布隆过滤器，并对布隆过滤器返回为阳性的目标进行着色，该屏障维护了 $B \\not\\to W$。在给定参数下，预期的误报着色数量是 $n (1-p) \\, p_{\\mathrm{bf}}$，其中 $p_{\\mathrm{bf}} \\approx \\left(1 - e^{-k n_w / m}\\right)^{k}$。\n\n**分析：**\n1.  **不变量维护：** 该屏障使用布隆过滤器来近似白色对象的集合。布隆过滤器的一个关键特性是它可能有误报（false positives），但没有漏报（false negatives）。“没有漏报”意味着如果一个对象确实在集合中（即，是白色的），布隆过滤器保证会返回阳性。因此，任何对真正白色对象的引用都会触发着色机制。这确保了不会创建 $B \\to W$ 边，因此不变量得以维护。代价是某些非白色对象也可能触发着色（误报）。\n\n2.  **定量分析：** 我们被要求计算*误报*着色的预期数量。对于一个引用，如果满足两个条件，就会发生误报着色事件：\n    a. 目标对象*不是*白色的。这个概率是 $1-p$。\n    b. 对这个非白色对象的布隆过滤器测试返回了阳性结果。根据定义，这个概率是布隆过滤器的误报率，$p_{\\mathrm{bf}}$。\n    假设布隆过滤器的哈希函数与对象的颜色属性无关，单个引用的误报着色概率是这些概率的乘积：$P(\\text{误报着色}) = (1-p) \\times p_{\\mathrm{bf}}$。\n    在整个包含 $n$ 个元素的 `$\\text{memcpy}$` 过程中，根据期望的线性性质，误报着色的总预期数量是：\n    $$E[\\text{误报着色}] = \\sum_{i=1}^{n} P(\\text{第 i 个引用的误报}) = n \\times (1-p) \\times p_{\\mathrm{bf}}$$\n    这与选项中提供的公式相匹配。$p_{\\mathrm{bf}}$ 的公式本身就是布隆过滤器误报率的标准近似值。\n\n**结论：** 屏障正确地维护了不变量，并且误报的预期数量的公式推导是正确的。\n\n**判定：** 正确。\n\n### 选项 D 评估\n**声明：** 一种屏障，它通过将单个 $(D,\\;n)$ 范围描述符推入一个工作列表来推迟所有着色操作，并且仅在 `memcpy` 完成后才执行着色，期间不与回收器协调，该屏障能维护 $B \\not\\to W$，因为拷贝在数组级别上是原子的。\n\n**分析：**\n1.  **不变量维护：** 这个策略在并发上下文中存在根本性缺陷。`$\\text{memcpy}$` 操作相对于 GC 来说不是原子的。并发回收器可能在任何时候被调度运行，包括在 `$\\text{memcpy}$` 执行的中途。考虑以下事件序列：\n    1.  变异器开始 `$\\text{memcpy}$`。它将一个指向白色对象 $W$ 的引用拷贝到 `D[i]` 中。此时存在一个 $B \\to W$ 边。\n    2.  变异器被抢占，并发 GC 线程运行。\n    3.  选项声明“不与回收器协调”。这意味着 GC 不知道有延迟的工作列表。GC 执行其标记阶段，发现 $W$ 无法从任何灰色对象到达，并将其颜色保留为白色。\n    4.  GC 完成标记并开始清扫。它回收所有白色对象的内存，包括 $W$。\n    5.  变异器线程恢复。它可能继续或完成其 `$\\text{memcpy}$`。对象 $D$ 现在在 `D[i]` 处包含一个悬空指针，指向已被释放并可能被重新分配的内存。这是一个严重的内存安全违规。\n    并发写屏障的核心目的就是防止这种精确的竞争条件。在没有同步协议强制回收器在完成标记前处理延迟工作的情况下推迟修复，会破坏整个系统。\n\n2.  **原子性声明：** “拷贝在数组级别上是原子的”这一说法对于任何非平凡大小的数组都是错误的。`$\\text{memcpy}$` 是一个库函数，其内部执行一个循环。它可以在任何点被操作系统调度器抢占。即使是拷贝内存块的单个硬件指令（如 x86 上的 `$\\text{rep movs}$`）也可能被中断。\n\n**结论：** 这个提议的屏障未能维护三色不变量，并引入了一个导致内存损坏的关键竞争条件。\n\n**判定：** 不正确。", "answer": "$$\\boxed{AC}$$", "id": "3679528"}]}