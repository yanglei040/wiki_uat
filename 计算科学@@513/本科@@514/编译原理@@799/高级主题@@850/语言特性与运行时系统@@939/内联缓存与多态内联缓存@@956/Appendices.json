{"hands_on_practices": [{"introduction": "任何成功的即时编译（JIT）优化的基石都是正确性。这个练习将探讨一个关键场景，其中不完整的守卫（guard）可能导致灾难性的失败，包括垃圾回收（GC）的不安全性。通过分析这个问题 [@problem_id:3646156]，你将理解为什么专业化的代码路径不仅需要验证对象的布局（shape），还需要验证字段的类型，这是确保 JIT 系统稳定和安全的核心原则。", "problem": "一个即时 (JIT) 编译器中的动态对象系统使用隐藏类（也称为形状）来表示对象布局，并采用内联缓存 (IC) 和多态内联缓存 (PIC) 进行属性访问特化。其基本基础由以下广为接受的定义和不变量组成：一个 IC 通过在执行特化于某个属性的代码之前测试接收者的该属性来保护一个特化；一个 PIC 链接多个此类守卫；一个隐藏类布局标识了从字段名到内存偏移的映射；用于加载、存储和算术的机器指令选择是依赖于表示的；并且垃圾回收器 (GC) 在根扫描期间必须能够区分指针值和非指针值。考虑一个对象，其隐藏类标识符为 $L$，字段 $f$ 位于偏移量 $k$ 处，以及一个特化的 JIT 序列，该序列在 $L$ 上设置守卫，然后将 $o[k]$ 作为未装箱的 $32$ 位整数加载，并执行假设类型为 $T = \\text{int32}$ 的算术运算。该 PIC 链有 $n$ 个分支，每个分支仅由类似于 $L$ 的布局标识符守卫。\n\n在时间 $t_1$，程序向 $f$ 写入一个未装箱的整数，因此加载和算术操作是有效的。在时间 $t_2$，随后的赋值将 $f$ 重新类型化为一个堆分配的双精度浮点数对象，将其字段的运行时类型更改为指针（可能带有装箱或带标签的表示），同时保持偏移量 $k$ 和隐藏类标识符 $L$ 不变。JIT 代码和 PIC 仍然安装着，并且守卫继续匹配 $L$。\n\n基于上述基本定义和不变量，并且不假设任何将字段类型与布局绑定的特定于引擎的捷径，当类型改变但偏移量保持不变时，以下哪个陈述最能描述所需的守卫信息和失败模式？\n\nA. 仅守卫布局标识符 $L$ 是足够的，因为偏移量 $k$ 唯一地确定了正确的表示，并且任何运行时类型的改变都必须改变 $L$。\n\nB. 守卫必须同时包含布局标识符 $L$ 和字段类型 $T$（或逻辑上等效的按槽位的类型纪元），因为机器指令的选择依赖于 $T$；否则，当类型改变但 $k$ 和 $L$ 保持不变时，PIC 会静默地执行错误选择的指令，从而产生不正确的算术结果，并且如果将指针视为非指针（反之亦然），则可能导致 GC 不安全性。\n\nC. 在向 $f$ 进行存储操作期间的写屏障确保了 GC 安全性和 PIC 的正确性，因此类型守卫是不必要的；如果类型在 $k$ 保持不变的情况下发生改变，写屏障将更新或使 PIC 失效。\n\nD. 当字段类型改变时，仅由布局标识符守卫的 PIC 将总是未命中，因为任何重新类型化都必然会改变隐藏类标识符 $L$，即使内存偏移量 $k$ 未改变。\n\n选择唯一的最佳选项。", "solution": "该问题陈述在编译器设计和动态语言运行时系统领域是一个有效、自洽且有科学依据的问题。它提出了一个经典场景，用以说明与即时 (JIT) 编译和类型特化相关的正确性和安全性挑战。其前提与现代高性能虚拟机的基本原则是一致的。\n\n### 从第一性原理推导\n\n该问题定义了一个具有以下关键组件和行为的系统：\n1.  **隐藏类（或形状）**：一个由 `$L$` 标识的隐藏类，定义了对象的内存布局，特别是从像 `$f$` 这样的字段名到内存偏移 `$k$` 的映射。\n2.  **特化的 JIT 代码**：为属性访问生成一个机器指令序列。此代码基于对接收者对象的假设进行特化。\n3.  **内联缓存 (IC/PIC)**：特化代码由一个检查来守卫。在本问题中，该守卫被指定为对隐藏类标识符的检查：`对象的隐藏类 == L 吗？`。\n4.  **表示依赖性**：机器指令的选择（例如，用于加载值或执行算术运算）取决于数据的运行时表示（例如，`integer`、`double`、`pointer`）。这被作为一个基本不变量给出。\n5.  **垃圾回收 (GC) 安全性**：GC 必须能够区分指针和非指针，以正确地追踪活动对象的图。\n\n场景展开如下：\n- 一个对象有一个隐藏类 `$L$`。存在一个 JIT 编译的序列用于访问其字段 `$f$`。该序列由一个对 `$L$` 的检查来守卫。\n- 特化代码假设偏移量 `$k$` 处的值是一个未装箱的 `$32$-bit integer (`$T = \\text{int32}$`)。因此，它使用整数加载指令和整数算术指令。\n- 在时间 `$t_1$`，这个假设是正确的。字段 `$f$` 包含一个整数，特化代码正确执行。\n- 在时间 `$t_2$`，字段 `$f$` 被更新为一个新值：一个指向堆分配的双精度浮点数的指针。\n- 关键的是，问题陈述指出，这次更新*不会*改变对象的隐藏类标识符 `$L$`。\n\n现在，让我们分析在时间 `$t_2$` 之后，当特化的 JIT 代码在这个修改过的对象上执行时会产生什么后果：\n\n1.  **守卫执行**：PIC 的守卫检查对象的隐藏类。由于它仍然是 `$L$`，守卫**通过**。程序继续执行特化的、但现在已不正确的代码。\n\n2.  **指令执行**：特化代码是在假设偏移量 `$k$` 处的值为 `$ \\text{int32} $` 的情况下生成的。它将执行一个整数加载指令来从 `object + k` 读取数据。然而，该位置的位现在表示一个内存地址（一个指针）。假设在 `$64$-bit 架构上，一个指针是一个 `$64$-bit` 的值。整数加载可能只读取此指针的前 `$32$` 位。\n\n3.  **失败模式 1：数据损坏/不正确的算术**：用于整数算术的机器代码将对这些位进行操作。例如，一条 `ADD` 指令会将指针的位（或其一部分）当作整数来执行加法。结果在计算上将是无意义的。这是一个会损坏程序数据状态的静默错误。\n\n4.  **失败模式 2：GC 不安全性**：这是最严重的后果。JIT 编译器维护元数据（通常称为栈映射 (stack maps) 或对象指针映射 (OopMaps)），这些元数据在特定的“安全点”通知 GC 寄存器和栈上每个值的类型。特化代码的元数据将报告从 `$o[k]$` 加载并保存在寄存器中的值是一个整数。GC 在扫描机器状态时，会看到指针的位模式，但根据元数据，会将其解释为非指针值。因此，GC 将**不会**追踪此指针。它所指向的堆分配的双精度浮点数对象将看起来不可达，并被错误地垃圾回收。程序之后任何通过另一个有效引用来使用这块（现已释放的）内存的尝试，都将导致释放后使用、内存损坏或程序崩溃。\n\n从此分析可以清楚地看出，如果 `$L$` 不能完全确定其描述的所有字段的表示，那么仅在隐藏类 `$L$` 上设置守卫是不足够的。为了确保正确性和安全性，守卫必须更加精确。它不仅必须验证对象的布局（通过 `$L$`），还必须验证所访问字段的具体表示。\n\n### 选项评估\n\n让我们基于此推导来评估每个选项。\n\n**A. 仅守卫布局标识符 $L$ 是足够的，因为偏移量 $k$ 唯一地确定了正确的表示，并且任何运行时类型的改变都必须改变 $L$。**\n- 该陈述做出了一个断言：“任何运行时类型的改变都必须改变 `$L$`”。这与问题的核心前提直接矛盾，该前提明确设定了一个场景，其中字段类型发生变化但“`$L$` 保持不变”。问题要求我们分析的正是该场景的后果。因此，该选项在问题上下文中基于一个错误的前提。\n- **结论**：**不正确**。\n\n**B. 守卫必须同时包含布局标识符 $L$ 和字段类型 $T$（或逻辑上等效的按槽位的类型纪元），因为机器指令的选择依赖于 $T$；否则，当类型改变但 $k$ 和 $L$ 保持不变时，PIC 会静默地执行错误选择的指令，从而产生不正确的算术结果，并且如果将指针视为非指针（反之亦然），则可能导致 GC 不安全性。**\n- 该陈述准确地概括了我们推导出的结论。\n- “守卫必须同时包含布局标识符 `$L$` 和字段类型 `$T$`”：正确。这是特化安全的必要条件。\n- “因为机器指令的选择依赖于 `$T$`”：正确。这是一个给定的不变量。\n- “当类型改变但 `$k$` 和 `$L$` 保持不变时，PIC 会静默地执行错误选择的指令”：正确。仅靠 `$L$` 的守卫是不够的，并且会通过，导致执行不匹配的代码。\n- “从而产生不正确的算术结果，并且可能导致 GC 不安全性”：正确。这是我们识别出的两个主要失败模式。GC 不安全部分尤其关键。\n- 括号中的内容“（或逻辑上等效的按槽位的类型纪元）”正确地指出了这种字段特定类型守卫的一个常见且复杂的实现细节，从而增强了该陈述的可信度。\n- **结论**：**正确**。\n\n**C. 在向 $f$ 进行存储操作期间的写屏障确保了 GC 安全性和 PIC 的正确性，因此类型守卫是不必要的；如果类型在 $k$ 保持不变的情况下发生改变，写屏障将更新或使 PIC 失效。**\n- 写屏障是在存储操作期间执行的一种机制。设计一种在字段类型改变时使相关的 JIT 代码失效的写屏障是可能的。这样的系统将是一种*缓解策略*。然而，该选项声称这使得*类型守卫变得不必要*。这是一个有缺陷的结论。*读取路径*特化正确的根本逻辑要求是其假设得到验证。守卫在执行时进行此验证。写屏障是一种作用于*写入路径*的*失效机制*。仅仅依赖失效机制可能很脆弱（例如，由于并发系统中的数据竞争），并且它并不能改变这样一个事实：即所描述的 PIC 在没有更精确的守卫的情况下，在逻辑上是不安全的。问题要求描述*所需的守卫信息*，这是读取路径的一个属性。选项 B 直接解决了这个根本要求，而选项 C 描述了一种辅助机制，并错误地否定了对根本守卫的需求。\n- **结论**：**不正确**。\n\n**D. 当字段类型改变时，仅由布局标识符守卫的 PIC 将总是未命中，因为任何重新类型化都必然会改变隐藏类标识符 $L$，即使内存偏移量 $k$ 未改变。**\n- 这个选项与选项 A 有相同的缺陷。它假设“任何重新类型化都必然会改变隐藏类标识符 `$L$`”。这与问题陈述相矛盾，后者明确定义了一个 `$L$` 不变的场景。如果这个选项为真，那么问题中的场景就不会发生，PIC 将会简单地未命中，从而避免了静默的正确性和安全性失败。问题的目的正是要分析这个断言为假的情况。\n- **结论**：**不正确**。", "answer": "$$\\boxed{B}$$", "id": "3646156"}, {"introduction": "当一个调用点变得多态（polymorphic）时，编译器需要一种有效的方式来处理多种接收者类型。这个练习 [@problem_id:3646106] 将我们的注意力从单个守卫转移到多态内联缓存（PIC）的结构上。它挑战你应用算法思维（如哈夫曼编码）来设计最高效的 PIC，从而将理论性能模型与实际的编译器实现决策联系起来。", "problem": "在一种即时（JIT）编译语言中，一个动态调用点使用内联缓存（IC）来加速对接收者类型的方法分派。当该调用点变为超态时，编译器会构建一个多态内联缓存（PIC）。有两种表示策略可用：\n- 一个对接收者类标签进行相等性测试的线性链，终止于包含目标内联存根的叶节点。\n- 一个二叉决策树，其中每个内部节点以单位成本评估接收者类标签上的一个布尔谓词，并向左或向右分支；每个叶节点恰好对应一个接收者类，并包含其内联存根。\n\n假设在此调用点有六个接收者类，其经验频率（概率）分别为 $p_{1} = 0.35$，$p_{2} = 0.25$，$p_{3} = 0.15$，$p_{4} = 0.10$，$p_{5} = 0.08$ 和 $p_{6} = 0.07$，且满足 $\\sum_{i=1}^{6} p_{i} = 1$。一次分派的成本定义为到达匹配的叶节点之前执行的谓词评估次数。对于任何表示，期望分派成本为 $\\sum_{i=1}^{6} p_{i} \\cdot d(i)$，其中 $d(i)$ 是类 $i$ 的深度（谓词评估的次数）。\n\n任务：\n1. 构建一个使 $\\sum_{i=1}^{6} p_{i} \\cdot d(i)$ 最小化的二叉决策树，并计算其最小期望成本。\n2. 构建一个最优线性链，并计算其期望成本。\n3. 令 $\\Delta$ 为最优线性链的期望成本与最优二叉决策树的期望成本之差，即 $\\Delta = \\left(\\text{最优链期望成本}\\right) - \\left(\\text{最优树期望成本}\\right)$。\n\n请以单个实数的形式提供 $\\Delta$ 的值。如果您进行了任何近似计算，请以小数或分数的形式精确表示最终答案；不要使用百分号。无需四舍五入。", "solution": "用户希望我验证并解决该问题。\n\n### 步骤1：提取已知条件\n- **问题类型**：编译器优化，具体为多态内联缓存（PIC）性能。\n- **接收者类**：有 $6$ 个接收者类。\n- **类频率（概率）**：$p_{1} = 0.35$, $p_{2} = 0.25$, $p_{3} = 0.15$, $p_{4} = 0.10$, $p_{5} = 0.08$ 和 $p_{6} = 0.07$。题目说明了 $\\sum_{i=1}^{6} p_{i} = 1$。\n- **PIC 策略**：\n    1.  **线性链**：一系列相等性测试。链中第 $k$ 个类的成本是 $k$ 次谓词评估。\n    2.  **二叉决策树**：一个二叉树，其中内部节点是谓词，叶节点是目标存根。一个类的成本是其深度，定义为从根到其叶节点的路径上的谓词评估次数。\n- **目标函数**：最小化期望分派成本，这是一个加权平均值，定义为 $E = \\sum_{i=1}^{6} p_{i} \\cdot d(i)$，其中 $d(i)$ 是类 $i$ 的分派成本（深度）。\n- **任务**：计算 $\\Delta = (\\text{最优链期望成本}) - (\\text{最优树期望成本})$。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题在计算机科学领域有充分的依据，特别是在编译器设计和性能优化领域。内联缓存、多态内联缓存和分派成本分析都是标准的、成熟的概念。所提出的优化问题是一个经典问题。\n2.  **适定性**：问题定义清晰。输入（概率）、两种PIC策略的成本模型以及要最小化的目标函数都已明确指定。任务是找出两个唯一确定的最优值之间的特定数值差异。\n3.  **客观性**：问题陈述是形式化和定量的，没有任何主观或模棱两可的语言。\n4.  **缺陷检查清单**：\n    - 科学/事实不健全：无。前提是标准的计算机科学原理。\n    - 无法形式化：无。该问题是一个形式化的优化任务。它与其它主题无关。\n    - 不完整/矛盾：无。所有必要的概率都已提供，且总和为 $1$。成本定义清晰。\n    - 不切实际/不可行：无。频率分布是一个程序运行时行为的合理示例。\n    - 不适定：无。寻找最优加权树的问题可以通过 Huffman 算法解决，该算法能产生唯一的最小期望成本。最优线性链可通过简单的排序过程找到。\n    - 伪深刻/琐碎：无。该问题需要特定算法（Huffman 编码）的知识和分析推理能力。它并非微不足道。\n    - 超出科学可验证性：无。解决方案是可以通过算法推导和验证的。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个完整的、有理有据的解决方案。\n\n### 解决方案\n\n该问题要求我们计算两种不同的多态内联缓存（PIC）表示的最小期望分派成本，并找出它们之间的差值。\n\n**1. 最优二叉决策树成本**\n\n构建一个使期望分派成本 $E_{\\text{tree}} = \\sum_{i} p_{i} \\cdot d(i)$ 最小化的二叉决策树的任务，等同于为一组具有给定概率的符号寻找最优前缀码的问题。这个问题可以通过 Huffman 算法解决。在此背景下，叶节点 $i$ 的深度 $d(i)$ 是从根到该叶节点的路径上的内部节点数，因为每个内部节点都对应一次谓词评估。\n\n给定的概率为：$p_{1} = 0.35$, $p_{2} = 0.25$, $p_{3} = 0.15$, $p_{4} = 0.10$, $p_{5} = 0.08$ 和 $p_{6} = 0.07$。\n\n我们应用 Huffman 算法：\n1.  从一个叶节点列表开始，每个叶节点对应一个类，并按其概率加权。初始概率列表为：$0.35, 0.25, 0.15, 0.10, 0.08, 0.07$。\n2.  重复地将两个概率最低的节点合并成一个新的内部节点，其概率是其子节点概率之和。\n\n- **步骤1**：合并两个概率最低的节点 $p_{6}=0.07$ 和 $p_{5}=0.08$。这会创建一个概率为 $0.07 + 0.08 = 0.15$ 的新内部节点。\n  节点概率列表变为：$0.35, 0.25, 0.15$ (对应 $p_{3}$), $0.15$ (新), $0.10$。排序后得到：$0.35, 0.25, 0.15, 0.15, 0.10$。\n\n- **步骤2**：合并两个新的概率最低的节点，$p_{4}=0.10$ 和其中一个 $0.15$ 节点。我们选择原来的 $p_{3}=0.15$。这会创建一个概率为 $0.10 + 0.15 = 0.25$ 的新内部节点。\n  节点概率列表变为：$0.35, 0.25$ (对应 $p_{2}$), $0.25$ (新), $0.15$ (来自步骤1)。排序后得到：$0.35, 0.25, 0.25, 0.15$。\n\n- **步骤3**：合并两个新的概率最低的节点，即 $0.15$ 节点（来自步骤1）和原来的 $p_{2}=0.25$ 节点。这会创建一个概率为 $0.15 + 0.25 = 0.40$ 的新内部节点。\n  节点概率列表变为：$0.40$ (新), $0.35$ (对应 $p_1$), $0.25$ (来自步骤2)。排序后得到：$0.40, 0.35, 0.25$。\n\n- **步骤4**：合并两个新的概率最低的节点，即 $0.25$ 节点（来自步骤2）和原来的 $p_{1}=0.35$ 节点。这会创建一个概率为 $0.25 + 0.35 = 0.60$ 的新内部节点。\n  节点概率列表变为：$0.60$ (新), $0.40$ (来自步骤3)。\n\n- **步骤5**：合并最后两个概率为 $0.40$ 和 $0.60$ 的节点。这会创建根节点，其概率为 $0.40 + 0.60 = 1.0$。\n\n通过此构造，我们可以确定每个类 $i$ 的深度 $d(i)$：\n- $p_{1}=0.35$：路径经过根节点 ($1.0$)，然后是概率为 $0.60$ 的节点。深度 $d(1)=2$。\n- $p_{2}=0.25$：路径经过根节点 ($1.0$)，然后是概率为 $0.40$ 的节点。深度 $d(2)=2$。\n- $p_{3}=0.15$：路径经过根节点 ($1.0$)、概率为 $0.60$ 的节点、概率为 $0.25$ 的节点。深度 $d(3)=3$。\n- $p_{4}=0.10$：路径经过根节点 ($1.0$)、概率为 $0.60$ 的节点、概率为 $0.25$ 的节点。深度 $d(4)=3$。\n- $p_{5}=0.08$：路径经过根节点 ($1.0$)、概率为 $0.40$ 的节点、概率为 $0.15$ 的节点。深度 $d(5)=3$。\n- $p_{6}=0.07$：路径经过根节点 ($1.0$)、概率为 $0.40$ 的节点、概率为 $0.15$ 的节点。深度 $d(6)=3$。\n\n二叉树的最小期望成本为：\n$$ E_{\\text{tree}} = \\sum_{i=1}^{6} p_{i} d(i) $$\n$$ E_{\\text{tree}} = (0.35)(2) + (0.25)(2) + (0.15)(3) + (0.10)(3) + (0.08)(3) + (0.07)(3) $$\n$$ E_{\\text{tree}} = 0.70 + 0.50 + 0.45 + 0.30 + 0.24 + 0.21 $$\n$$ E_{\\text{tree}} = 2.40 $$\n（注：无论在 Huffman 构造过程中如何选择打破平局，都会得到相同的最小成本。）\n\n**2. 最优线性链成本**\n\n对于一个线性相等性测试链，链中位置为 $k$ 的类的成本 $d(i)$ 为 $k$。为了最小化期望成本 $E_{\\text{chain}} = \\sum_{k=1}^{6} p_{i_{k}} \\cdot k$，我们必须按照概率的降序排列这些类。这将最高的概率与最低的成本（深度）配对。\n\n排序后的概率为：\n- 位置 $k=1$: $p_{1} = 0.35$\n- 位置 $k=2$: $p_{2} = 0.25$\n- 位置 $k=3$: $p_{3} = 0.15$\n- 位置 $k=4$: $p_{4} = 0.10$\n- 位置 $k=5$: $p_{5} = 0.08$\n- 位置 $k=6$: $p_{6} = 0.07$\n\n这个最优线性链的期望成本是：\n$$ E_{\\text{chain}} = (0.35)(1) + (0.25)(2) + (0.15)(3) + (0.10)(4) + (0.08)(5) + (0.07)(6) $$\n$$ E_{\\text{chain}} = 0.35 + 0.50 + 0.45 + 0.40 + 0.40 + 0.42 $$\n$$ E_{\\text{chain}} = 2.52 $$\n\n**3. 期望成本之差**\n\n问题要求计算 $\\Delta$ 的值，即最优线性链的期望成本与最优二叉决策树的期望成本之差。\n$$ \\Delta = E_{\\text{chain}} - E_{\\text{tree}} $$\n$$ \\Delta = 2.52 - 2.40 $$\n$$ \\Delta = 0.12 $$\n\n期望成本的差值为 $0.12$。这个值表示对于此特定工作负载，使用最优二叉决策树相比于最优线性链，每次分派所获得的平均性能提升。", "answer": "$$\\boxed{0.12}$$", "id": "3646106"}, {"introduction": "内联缓存的核心机制是通过在运行时动态修改机器码来实现的。这个练习 [@problem_id:3646199] 深入探讨了这一过程在现代多核处理器上的底层实现代价。你需要对代码补丁（code patch）的性能成本进行建模，同时考虑缓存一致性等复杂的硬件效应，从而全面理解动态优化所需付出的系统级开销。", "problem": "一个用于动态语言的即时编译器（just-in-time compiler）使用内联缓存（inline caches, ICs）和多态内联缓存（polymorphic inline caches, PICs）在运行时通过修补短代码序列来特化调用点。考虑一个多核系统，该系统有 $T$ 个相同的核心，共享一个一致性内存层级结构。该结构通过一个共享广播互连为指令强制执行写-无效（write-invalidate）一致性。每个核心上的指令缓存（I-cache）通过显式的无效化确认来保持一致性：一个核心在收到指令无效化请求后，会处理它，然后通过互连发送一个确认信号。互连将所有的一致性消息和确认信号进行无重叠的串行化处理。\n\n对一个调用点的 IC 或 PIC 修补可能会跨越多个缓存行。假设一个特定的修补会无效化 $B$ 个不同的指令缓存行。修补线程在一个单独的源核心上运行，并对这 $B$ 行中的每一行都遵循以下严格串行化的逐行协议，只有在当前行被所有其他核心完全确认后，才会处理下一行：\n\n- 将该行的代码修补写入应用到源核心的数据缓存，本地耗费 $L_{w}$ 个周期。\n- 在源核心上执行本地指令缓存同步（以避免执行过时的指令），耗费 $L_{i}$ 个周期。\n- 发出一个完整的内存屏障，以保证写入操作在后续无效化操作之前的顺序，耗费 $L_{f}$ 个周期。\n- 在互连上广播该行的指令无效化消息；该广播占用互连 $L_{b}$ 个周期。\n- 另外 $T-1$ 个核心中的每一个，在收到无效化消息后，花费 $L_{s}$ 个周期来无效化相应的 I-cache 行并清空其前端，然后发送一个占用互连 $L_{r}$ 个周期的确认信号。来自不同核心的确认信号一旦开始，就会在互连上无间隙地背靠背串行化，源核心必须在接收到所有 $T-1$ 个确认信号后才能继续执行。\n\n假设以下源于一致性基本原理的最坏情况但现实的条件：广播在占用互连 $L_{b}$ 个周期后同时传递到所有核心；在 $T-1$ 个远程核心上的 $L_{s}$ 服务在这些核心之间完全重叠；互连上没有其他流量；以及不同行的逐行操作在时间上不重叠。\n\n在这些假设下，推导一个封闭形式的表达式，用于表示源核心在所有 $B$ 行和所有 $T$ 个核心上完成修补所经历的最坏情况下的总停顿时间（以周期为单位）。您的最终答案必须是一个单一的解析表达式，用 $B$、$T$、$L_{w}$、$L_{i}$、$L_{f}$、$L_{b}$、$L_{s}$ 和 $L_{r}$ 表示，并应以周期为单位。不要进行近似或四舍五入；请提供精确的表达式。", "solution": "任务是为源核心在执行与内联缓存（IC）或多态内联缓存（PIC）修补相关的自修改代码操作时所经历的停顿时间进行建模。我们从适用于自修改代码的一致性和同步基本原理出发：\n\n- 在写-无效一致性下，要使代码修改对执行是安全的，需要确保没有核心会继续执行过时的指令。一个标准的机制是向所有核心广播一条指令无效化消息，并在执行新指令前等待确认无效化已处理的确认信号。这为自修改代码提供了顺序和可见性保证。\n- 在一个串行化消息的共享互连上，一次广播会占用互连一段固定的时间，后续的确认消息也会被串行化。如果远程核心的服务时间是独立的，并在消息传递后开始，那么在最坏情况下，这些服务延迟可以在核心之间重叠，而它们的确认信号传输由于串行化而不能重叠。\n\n我们现在计算每个缓存行的停顿时间，然后扩展到 $B$ 行。\n\n对于单个缓存行，源核心执行以下步骤及其成本：\n\n1. 本地修补写入：$L_{w}$ 个周期。这是源核心无法与指定的串行化协议中后续步骤重叠的本地工作，因此它对停顿时间有累加性的贡献。\n\n2. 本地指令缓存同步：$L_{i}$ 个周期。这确保源核心不会从其自身的 I-cache 中执行过时的指令，并且必须在继续之前完成，因此它也有累加性的贡献。\n\n3. 完整内存屏障：$L_{f}$ 个周期。这对写入操作相对于后续的无效化操作进行排序，并有累加性的贡献。\n\n4. 广播无效化：互连被占用 $L_{b}$ 个周期。由于互连串行化消息且没有其他流量，这个 $L_{b}$ 对任何确认信号可以发送之前的时间有累加性的贡献。在此模型中，广播在完成这 $L_{b}$ 的占用后，同时传递到所有远程核心。\n\n5. 远程服务和确认：\n   - 在收到无效化消息后，$T-1$ 个远程核心中的每一个都执行无效化和前端清空工作，耗费 $L_{s}$ 个周期。因为所有远程核心同时收到广播然后开始服务，所以这些 $L_{s}$ 成本在 $T-1$ 个核心之间完全重叠。因此，在任何确认信号可以发出之前的总延迟就是 $L_{s}$，而不是 $(T-1)L_{s}$。\n   - 服务之后，每个远程核心发出一个占用互连 $L_{r}$ 个周期的确认信号。确认信号在互连上是串行化的。总共有 $T-1$ 个这样的确认信号，在最坏情况下，一旦第一个开始，它们就会无间隙地背靠背传输，在第一个确认信号开始后贡献 $(T-1)L_{r}$ 个周期。由于第一个确认信号可以在消息传递后经过 $L_{s}$ 时间立即开始，因此从广播发出到收到最后一个确认信号的总时间是 $L_{b} + L_{s} + (T-1)L_{r}$。\n\n汇总这些贡献，每行的停顿时间 $S_{\\text{line}}$ 是\n$$\nS_{\\text{line}} \\;=\\; L_{w} \\;+\\; L_{i} \\;+\\; L_{f} \\;+\\; \\bigl(L_{b} \\;+\\; L_{s} \\;+\\; (T-1)L_{r}\\bigr).\n$$\n\n根据问题的串行化假设，各行被严格地一个接一个处理，行与行之间没有时间重叠。因此，跨越 $B$ 行的总停顿时间是\n$$\nS_{\\text{total}} \\;=\\; B \\cdot S_{\\text{line}} \\;=\\; B\\left(L_{w} + L_{i} + L_{f} + L_{b} + L_{s} + (T-1)L_{r}\\right).\n$$\n\n该表达式以周期为单位，并且如要求的那样，仅依赖于给定的参数 $B$、$T$、$L_{w}$、$L_{i}$、$L_{f}$、$L_{b}$、$L_{s}$ 和 $L_{r}$。", "answer": "$$\\boxed{B\\left(L_{w}+L_{i}+L_{f}+L_{b}+L_{s}+(T-1)L_{r}\\right)}$$", "id": "3646199"}]}