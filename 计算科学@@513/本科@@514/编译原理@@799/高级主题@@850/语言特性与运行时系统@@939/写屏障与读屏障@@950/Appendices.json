{"hands_on_practices": [{"introduction": "理论联系实践的第一步是深刻理解一个概念的核心必要性。本练习旨在探讨写屏障（write barrier）存在的根本原因，通过分析编译器优化（如死代码消除）与垃圾回收（GC）正确性之间的精妙互动来加深理解。通过思考在何种条件下可以安全地省略一个写屏障，你将学会从垃圾回收器“可观察”状态的角度来审视内存操作，从而掌握写屏障不变式的本质。[@problem_id:3683370]", "problem": "考虑一个使用分代垃圾回收 (GC) 并且通过写屏障维护一个记录老年代到新生代引用的记忆集的语言运行时。令 $O$ 表示老年代对象的集合，$Y$ 表示新生代对象的集合。在时间 $t$ 进行一次次要回收时，记忆集的不变量是：对于每一个 $o \\in O$ 和字段 $g$，如果在回收开始时指针值 $o.g(t) \\in Y$，那么包含 $o$ 的卡片页（card）必须被记录在记忆集中，以便回收器扫描它。\n\n假设一个编译器正在考虑对一个对象 $x$ 的同一字段的两次连续指针写入进行无用存储消除：\n- 首先在时间 $t_0$ 执行 $x.f := p$，紧接着\n- 在时间 $t_1$ 执行 $x.f := q$，其中 $t_0 < t_1$，\n并且第一次写入 $x.f := p$ 当前有关联的写屏障。\n\n假设：\n- 一次次要回收只能在线程安全点（例如，在 $t_s$）开始，\n- 写屏障用于维护老年代到新生代引用的记忆集信息，\n- 不同的屏障实现可能是值条件的（仅当存储的值在 $Y$ 中时才记录）或无条件卡片标记（对老年代对象的任何指针存储都标记其卡片页）。\n\n在下列哪些条件下，编译器可以移除与第一次存储 $x.f := p$ 相关的写屏障，而不会违反记忆集的不变量？选择所有适用的选项。\n\nA. $x \\in Y$（即，$x$ 分配在新生代中），无论 $p$ 和 $q$ 的年龄以及调度如何。\n\nB. 在 $t_0$ 和 $t_1$ 之间没有安全点（因此在 $(t_0, t_1)$ 之间没有次要 GC 可以启动），无论屏障是值条件的还是无条件的。\n\nC. $p \\notin Y$（例如，$p$ 是 $\\text{null}$ 或已晋升的对象），与 $x$ 和 $q$ 的年龄以及调度无关。\n\nD. 运行时采用读屏障来维护记忆集，因此可以省略存储操作上的写屏障。", "solution": "任务是确定在哪些条件下，编译器可以安全地移除两次连续写入中第一次写入 $x.f := p$ 相关的写屏障，而不会违反垃圾回收器的记忆集不变量。\n\n问题陈述定义了系统和不变量：\n- 系统使用分代垃圾回收器 (GC)，有老年代 ($O$) 和新生代 ($Y$) 。\n- 系统维护一个记忆集来跟踪从 $O$ 中对象到 $Y$ 中对象的指针。这是通过写屏障完成的。\n- 在时间 $t$ 进行一次次要回收时，记忆集的不变量是：对于每一个 $o \\in O$ 中的对象及其字段 $g$，如果指针值 $o.g(t)$ 是 $Y$ 中的一个对象，那么包含 $o$ 的卡片页必须在记忆集中。\n- 正在考虑的代码序列是在时间 $t_0$ 执行 $x.f := p$，紧接着在时间 $t_1$ 执行 $x.f := q$。\n- 我们正在考虑消除与第一次存储 $x.f := p$ 相关的写屏障。\n- GC 只能在线程安全点发生。\n\n仅当存储操作 `object.field := value` 有可能创建一个老年代到新生代的指针（即 `object` $\\in O$ 且 `value` $\\in Y$），并且该指针可能被垃圾回收器观察到，同时这一事实没有通过其他方式记录时，与该存储操作关联的写屏障才是必需的。如果第一次写入的屏障被移除，系统的正确性将依赖于第二次写入的屏障，以及中间状态（$x.f = p$）要么不是一个老年代到新生代的指针，要么不会被 GC 观察到的条件。\n\n让我们评估每个选项：\n\n**A. $x \\in Y$（即，$x$ 分配在新生代中），无论 $p$ 和 $q$ 的年龄以及调度如何。**\n\n记忆集不变量专门适用于源自老年代 $O$ 中对象的指针。该不变量的表述为“对于每一个 $o \\in O$...”。如果被修改字段的对象 $x$ 本身就在新生代中（$x \\in Y$），那么 $x \\notin O$。因此，存储在 $x$ 字段中的任何指针（即 $x.f := p$）都不会创建一个老年代到新生代的指针。它可能创建一个新生代到新生代或新生代到老年代的指针，这两种情况都不会被用于次要回收的记忆集所跟踪。由于不变量的基本前提条件（源对象在 $O$ 中）未被满足，因此对 $x$ 的任何字段的任何存储都不需要写屏障。因此，编译器可以安全地移除 $x.f := p$ 的屏障。\n\n结论：**正确**。\n\n**B. 在 $t_0$ 和 $t_1$ 之间没有安全点（因此在 $(t_0, t_1)$ 之间没有次要 GC 可以启动），无论屏障是值条件的还是无条件的。**\n\n垃圾回收被限制在线程执行中被称为安全点的静止点发生。该条件指出，在时间 $t_0$ 的第一次写入和时间 $t_1$ 的第二次写入之间不存在安全点。这意味着这两次写入的序列相对于垃圾回收器是原子的。\n\n因此，任何 GC 只能观察到在时间 $t_0$ 之前或在时间 $t_1$ 或之后堆的状态。\n- 在 $t_0$ 之前发生的 GC 不受这些写入的影响。\n- 在 $t_1$ 或之后发生的 GC 将观察到 $x.f$ 持有值 $q$ 的状态。$x.f$ 持有值 $p$ 的中间状态是短暂的，永远不会对 GC 可见。\n\n因此，对于不变量而言，唯一重要的状态是最终状态 $x.f = q$。第二次写入 $x.f := q$ 的写屏障（假设存在，因为问题只问及省略第一个屏障）在 $x \\in O$ 和 $q \\in Y$ 的情况下足以维护不变量。第一次写入 $x.f := p$ 上的写屏障是多余的，因为它将记录的状态永远不会被 GC 观察到。编译器可以安全地移除它。\n\n结论：**正确**。\n\n**C. $p \\notin Y$（例如，$p$ 是 $\\text{null}$ 或已晋升的对象），与 $x$ 和 $q$ 的年龄以及调度无关。**\n\n这个条件规定，第一次写入所存储的值 $p$ 不是指向新生代中对象的指针。\n\n写屏障的目的是确保记忆集不变量得以维持。不变量要求如果一个对象 $o \\in O$ 指向了 $Y$ 中的对象，则需要记录该对象 $o$。写入操作 $x.f := p$ 仅在 $x \\in O$ 和 $p \\in Y$ 的情况下才会创建与不变量相关的指针。由于该条件明确指出 $p \\notin Y$，因此这次写入不能创建老年代到新生代的指针。\n\n让我们分析在任何可能的安全点时间 $t_s \\ge t_0$ 的状态：\n- 如果 GC 在 $t_s$ （其中 $t_0 \\le t_s < t_1$）开始，此时状态为 $x.f = p$。由于 $p \\notin Y$，即使 $x \\in O$，不变量也不要求因为这个指针而将 $x$ 放入记忆集中。因此，处理此状态不需要为这次写入设置屏障。\n- 如果 GC 在 $t_s \\ge t_1$ 开始，此时状态为 $x.f = q$。此状态的正确性由第二次存储 $x.f := q$ 上的写屏障来保证。\n\n这对于提到的两种屏障类型都成立：\n- *值条件*屏障会检查 $p \\in Y$ 是否成立，发现其为假，则不执行任何操作。因此移除该屏障是安全的。\n- *无条件卡片标记*屏障在 $x \\in O$ 的情况下可能会标记 $x$ 的卡片页。然而，这种标记在技术上是不必要的，因为回收器随后的扫描不会从这个赋值中发现新的老年代到新生代的指针。移除该屏障是一个保留了正确性的有效优化。\n\n因此，由于写入 $x.f := p$ 不会创建不变量所关注的特定类型的指针，其关联的写屏障可以被安全地移除。\n\n结论：**正确**。\n\n**D. 运行时采用读屏障来维护记忆集，因此可以省略存储操作上的写屏障。**\n\n这个选项引入了一个与问题设定直接矛盾的前提。问题明确指出，该语言运行时“通过**写屏障**维护一个记录老年代到新生代引用的记忆集”。问题的答案必须是在所描述系统内有效的条件。提议改变基本的 GC 机制（从写屏障改为读屏障）并没有为在问题所述的背景下的优化提供一个有效条件。这实质上是改变了问题，而不是解决问题。\n\n结论：**不正确**。", "answer": "$$\\boxed{ABC}$$", "id": "3683370"}, {"introduction": "在理解了何时必须执行写屏障之后，下一步是量化其带来的实际影响。本练习构建了一个精确的数学模型，用于分析一种常见的分代式GC实现——卡片标记（card marking）所产生的内存开销。通过推导和计算被“弄脏”的内存区域（卡片）的最小数量，你将具体地看到内存布局、对齐方式和访问模式是如何直接影响垃圾回收效率的，从而将抽象的算法与具体的性能指标联系起来。[@problem_id:3683420]", "problem": "一个托管运行时使用分代垃圾回收（GC），其写屏障在堆上维护一个卡表。堆是字节寻址的，并被划分为大小相等的连续区域，称为“卡”（card）。一个卡的大小为 $C$ 字节，其整数索引定义为目标地址除以 $C$ 的向下取整值。当一个指向年轻代对象的指针被存入一个老年代对象时，写屏障会标记包含目标地址的卡。\n\n考虑一个老年代对象，其基地址 $b$ 按 $A$ 字节对齐，即 $b \\equiv 0 \\pmod{A}$。该对象包含一个连续排列的指针字段数组，其中第 $i$ 个指针字段的起始地址为 $b + i s$，其中 $s$ 是指针大小（以字节为单位），且 $i \\in \\{0, 1, \\dots, n\\}$。假设循环\n\n对于 $i = 0..n$：\n- 将一个指向年轻代对象的指针存入偏移量为 $b + i s$ 的字段中\n\n被执行，并且每次存储操作，写屏障都会标记相应的卡。假设每次存储只标记包含目标字段第一个字节的卡。\n\n仅使用上述定义，从第一性原理推导出一个闭式表达式，用于表示在整个循环中可能被标记的不同卡表条目的最小可能数量，该表达式是 $n, s, C, A$ 的函数，并考虑到约束条件 $b$ 必须满足 $b \\equiv 0 \\pmod{A}$ 但可以在所有此类对齐地址上变化。然后，使用具体参数 $n = 4095$，$s = 8$ 字节，$C = 128$ 字节，$A = 16$ 字节，计算这个最小数量。请给出精确的最终数值答案，无需四舍五入。", "solution": "题目要求计算在一个循环中，当指针被存入老年代对象内的数组时，被写屏障标记的不同卡表条目的最小可能数量。\n\n设给定条件如下：\n- 每个卡的大小，$C$。\n- 指针的大小，$s$。\n- 数组中指针字段的数量为 $n+1$，索引为 $i \\in \\{0, 1, \\dots, n\\}$。\n- 对象的基地址 $b$ 按 $A$ 字节对齐，即 $b \\equiv 0 \\pmod{A}$。\n- 第 $i$ 个指针字段的地址是 $b + i s$。\n- 地址 `addr` 的卡索引是 $\\lfloor \\text{addr} / C \\rfloor$。\n- 写屏障标记与被写入字段的第一个字节对应的卡，因此对于第 $i$ 次存储，被标记的卡索引是 $k_i(b) = \\lfloor \\frac{b+is}{C} \\rfloor$。\n\n对于给定的基地址 $b$，被标记的不同卡的总数是循环中生成的唯一卡索引集合的大小：\n$$N(b) = \\left| \\left\\{ \\lfloor \\frac{b+is}{C} \\rfloor \\mid i \\in \\{0, 1, \\dots, n\\} \\right\\} \\right|$$\n我们需要找到在所有可能的有效基地址 $b$ 上 $N(b)$ 的最小值，其中 $b$ 必须是 $A$ 的倍数。设这个最小值为 $N_{min}$。\n$$N_{min} = \\min_{b: b \\equiv 0 \\pmod{A}} N(b)$$\n\n为了分析 $N(b)$，我们来研究连续两次存储操作的卡索引之差：\n$$k_{i+1}(b) - k_i(b) = \\left\\lfloor \\frac{b+(i+1)s}{C} \\right\\rfloor - \\left\\lfloor \\frac{b+is}{C} \\right\\rfloor$$\n设 $x = \\frac{b+is}{C}$ 且 $y = \\frac{s}{C}$。这个差值为 $\\lfloor x+y \\rfloor - \\lfloor x \\rfloor$。根据向下取整函数的性质，我们知道对于任意实数 $x, y$，$\\lfloor x+y \\rfloor - \\lfloor x \\rfloor$ 的值要么是 $\\lfloor y \\rfloor$，要么是 $\\lfloor y \\rfloor + 1$。\n因此，差值 $k_{i+1}(b) - k_i(b)$ 只能取两个值之一：$\\lfloor s/C \\rfloor$ 或 $\\lfloor s/C \\rfloor + 1$。这个观察是推导的关键，并且与 $b$ 和 $i$ 无关。\n\n我们根据指针大小 $s$ 和卡大小 $C$ 之间的关系考虑两种情况。\n\n情况 1：$s \\ge C$\n在这种情况下，$\\lfloor s/C \\rfloor \\ge 1$。\n因此，连续卡索引之间的差值为：\n$$k_{i+1}(b) - k_i(b) \\ge \\lfloor s/C \\rfloor \\ge 1$$\n这表明对于 $i \\in \\{0, 1, \\dots, n\\}$，$k_i(b)$ 是一个严格递增序列。\n$$k_0(b) < k_1(b) < k_2(b) < \\dots < k_n(b)$$\n由于所有卡索引都不同，被标记的不同卡的总数等于存储操作的总数，即 $n+1$。这个结果对任何有效的基地址 $b$ 都成立。\n因此，如果 $s \\ge C$，被标记的卡的最小数量是 $N_{min} = n+1$。\n\n情况 2：$s < C$\n在这种情况下，$\\lfloor s/C \\rfloor = 0$。\n连续卡索引之间的差值为：\n$$k_{i+1}(b) - k_i(b) \\in \\{0, 1\\}$$\n这意味着卡索引序列 $k_i(b)$ 是非递减的，并且每一步最多增加 1。因此，被标记的卡索引集合 $\\{k_0(b), k_1(b), \\dots, k_n(b)\\}$ 构成一个从最小索引 $k_0(b)$ 到最大索引 $k_n(b)$ 的连续整数范围。\n这个连续范围中不同元素的数量为：\n$$N(b) = k_n(b) - k_0(b) + 1 = \\left\\lfloor \\frac{b+ns}{C} \\right\\rfloor - \\left\\lfloor \\frac{b}{C} \\right\\rfloor + 1$$\n使用恒等式 $\\lfloor x+y \\rfloor - \\lfloor x \\rfloor = \\lfloor \\{x\\} + y \\rfloor$，其中 $\\{x\\}=x-\\lfloor x \\rfloor$ 是 $x$ 的小数部分：\n$$N(b) = \\left\\lfloor \\left\\{\\frac{b}{C}\\right\\} + \\frac{ns}{C} \\right\\rfloor + 1$$\n我们可以将小数部分 $\\{b/C\\}$ 表示为 $(b \\pmod C) / C$。\n$$N(b) = \\left\\lfloor \\frac{b \\pmod C}{C} + \\frac{ns}{C} \\right\\rfloor + 1 = \\left\\lfloor \\frac{(b \\pmod C) + ns}{C} \\right\\rfloor + 1$$\n为了找到卡的最小数量 $N_{min}$，我们必须通过选择一个满足对齐约束 $b \\equiv 0 \\pmod A$ 的最优基地址 $b$ 来最小化 $N(b)$。由于 $n, s, C$ 是固定的，最小化 $N(b)$ 等价于最小化 $b \\pmod C$ 这一项。\n\n约束条件 $b \\equiv 0 \\pmod A$ 意味着 $b$ 是 $A$ 的倍数，即对于某个整数 $k$，有 $b=kA$。我们需要找到 $(kA) \\pmod C$ 的最小非负值。集合 $\\{ (kA) \\pmod C \\mid k \\in \\mathbb{Z} \\}$ 正是 $A$ 和 $C$ 的最大公约数的所有非负倍数的集合，即 $\\{ m \\cdot \\gcd(A, C) \\mid m \\in \\mathbb{Z}, m \\ge 0 \\}$。这个集合中的最小值是 $0$。\n当 $b$ 同时是 $A$ 和 $C$ 的倍数时，可以得到 $b \\pmod C$ 的这个最小值。这样的 $b$ 是存在的；例如，我们可以选择 $b$ 为 $A$ 和 $C$ 的最小公倍数的任意倍数，例如 $b = \\text{lcm}(A, C)$。这个选择满足 $b \\equiv 0 \\pmod A$。\n令 $b \\pmod C = 0$ 可以最小化 $N(b)$。被标记的卡的最小数量为：\n$$N_{min} = \\left\\lfloor \\frac{0 + ns}{C} \\right\\rfloor + 1 = \\left\\lfloor \\frac{ns}{C} \\right\\rfloor + 1$$\n\n结合两种情况，被标记的卡的最小数量的闭式表达式为：\n$$ N_{min} = \\begin{cases} \\left\\lfloor \\frac{ns}{C} \\right\\rfloor + 1 & \\text{如果 } s < C \\\\ n+1 & \\text{如果 } s \\ge C \\end{cases} $$\n\n现在，我们使用具体参数 $n = 4095$，$s = 8$ 字节，$C = 128$ 字节，$A = 16$ 字节来计算这个最小数量。\n\n首先，我们比较 $s$ 和 $C$：\n$s = 8$ 且 $C = 128$。\n因为 $8 < 128$，所以我们有 $s < C$。因此我们使用情况2的公式。\n$$N_{min} = \\left\\lfloor \\frac{ns}{C} \\right\\rfloor + 1$$\n代入给定值：\n$$N_{min} = \\left\\lfloor \\frac{4095 \\times 8}{128} \\right\\rfloor + 1$$\n我们简化分数：\n$$\\frac{4095 \\times 8}{128} = \\frac{4095}{16}$$\n现在我们进行除法运算：\n$$4095 = 16 \\times 255 + 15$$\n所以，分数值为：\n$$\\frac{4095}{16} = 255 + \\frac{15}{16} = 255.9375$$\n对该值向下取整：\n$$\\left\\lfloor \\frac{4095}{16} \\right\\rfloor = \\lfloor 255.9375 \\rfloor = 255$$\n最后，我们加 1 得到被标记的卡的最小数量：\n$$N_{min} = 255 + 1 = 256$$\n可以被标记的不同卡表条目的最小数量是 $256$。", "answer": "$$\n\\boxed{256}\n$$", "id": "3683420"}, {"introduction": "除了内存开销，写屏障的CPU执行效率同样至关重要。本练习引导你对两种主流的写屏障实现策略——内联（inline）与非内联（out-of-line）调用——进行性能建模与比较。你将运用概率论和计算机体系结构中的分支预测模型，来量化分析不同实现方式的成本与收益，这有助于理解底层硬件特性与上层代码结构如何共同决定系统性能，并培养在设计中进行权衡取舍的能力。[@problem_id:3683412]", "problem": "您面临一个计算建模任务，该任务基于编译器原理和垃圾回收屏障设计。写屏障 (wb) 是编译器发出或注入的一小段代码，用于在带垃圾回收的运行时中维护分代不变量：在每次指针存储时，屏障会检查一个条件，并可选地执行慢路径操作（例如，在记忆集中记录该指针存储）。两种实现策略很常见：内联屏障（在每个存储点发出屏障主体）和非内联屏障（调用共享的屏障函数）。\n\n请为一个屏障建模，该屏障为快路径决策执行单个条件分支。设快路径被采用的概率为 $p_{\\text{fast}} \\in [0,1]$，慢路径被采用的概率为 $p_{\\text{slow}} = 1 - p_{\\text{fast}}$。假设每次屏障调用的分支结果都是具有上述概率的独立伯努利试验。假设处理器对该条件分支使用一个简单的一位最后结果分支预测器：它对下一次调用的预测等于同个静态分支上一次调用的结果。设基准分支执行成本为 $c_{\\text{branch}}$ 周期，分支预测错误的惩罚为 $c_{\\text{misp}}$ 周期，慢路径工作成本为 $c_{\\text{slow}}$ 周期。对于非内联屏障，每次调用还包括 $c_{\\text{callret}}$ 周期的额外调用/返回开销。对于内联屏障，调用/返回开销为 $0$ 周期。\n\n您的任务是：\n- 从第一性原理出发，推导在独立伯努利模型下，一位最后结果预测器的期望分支预测命中率 $h$。\n- 推导内联实现（表示为 $E_{\\text{inline}}$）和非内联实现（表示为 $E_{\\text{out}}$）每次屏障调用的期望周期数，用 $p_{\\text{fast}}$、$c_{\\text{branch}}$、$c_{\\text{misp}}$、$c_{\\text{slow}}$ 和 $c_{\\text{callret}}$ 表示。\n- 实现一个程序，为提供的测试套件评估 $h$、$E_{\\text{inline}}$ 和 $E_{\\text{out}}$。\n\n使用以下测试套件，所有成本以周期表示，概率以小数表示：\n1. $p_{\\text{fast}} = 0.999$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 15$, $c_{\\text{slow}} = 30$, $c_{\\text{callret}} = 4$。\n2. $p_{\\text{fast}} = 0.990$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 15$, $c_{\\text{slow}} = 30$, $c_{\\text{callret}} = 4$。\n3. $p_{\\text{fast}} = 1.000$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 15$, $c_{\\text{slow}} = 30$, $c_{\\text{callret}} = 4$。\n4. $p_{\\text{fast}} = 0.995$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 15$, $c_{\\text{slow}} = 30$, $c_{\\text{callret}} = 0$。\n5. $p_{\\text{fast}} = 0.999$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 30$, $c_{\\text{slow}} = 60$, $c_{\\text{callret}} = 8$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表由五个子列表组成，每个子列表按 $[E_{\\text{inline}}, E_{\\text{out}}, h]$ 的顺序列出三个浮点数，所有数值四舍五入到六位小数，且整个集合用方括号括起来。例如：\n\"[[e1_inline,e1_out,h1],[e2_inline,e2_out,h2],[e3_inline,e3_out,h3],[e4_inline,e4_out,h4],[e5_inline,e5_out,h5]]\"\n\n注意：垃圾回收（GC）是写屏障所支持的自动内存管理技术；此处指定的一位预测器是一个简化的、明确定义的教学模型。除了周期之外，不使用任何物理单位；概率必须是不带百分号的小数。该问题具有普遍适用性，仅需纯粹的数学推理和计算，无需任何特定于硬件的测量。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于计算机体系结构和编译器设计的原理，问题定义良好，并以客观、正式的语言表述。为获得唯一解所需的所有必要参数和定义均已提供，且不存在内部矛盾。因此，我们可以进行正式的推导和求解。\n\n目标是推导分支预测命中率和写屏障期望执行成本的表达式，然后为给定的一组参数计算这些值。\n\n### 1. 期望分支预测命中率（$h$）的推导\n\n问题指定了一个一位最后结果分支预测器。该预测器对下一个分支的状态就是当前分支的结果。如果下一个分支的结果与当前分支的结果相同，则预测正确（一次“命中”）。\n\n设在第 $n$ 次调用时，屏障条件分支的结果为随机变量 $O_n$。结果可以是“快路径”（我们用 $F$ 表示）或“慢路径”（用 $S$ 表示）。问题陈述，每次调用都是一个独立的伯努利试验，其概率为：\n$P(O_n = F) = p_{\\text{fast}}$\n$P(O_n = S) = p_{\\text{slow}} = 1 - p_{\\text{fast}}$\n\n对第 $n+1$ 次调用的分支预测，记为 $P_{n+1}$，是第 $n$ 次调用的分支结果。因此，$P_{n+1} = O_n$。\n\n如果在第 $n+1$ 次调用时预测与结果匹配，即 $P_{n+1} = O_{n+1}$，则发生分支预测命中。代入预测器的逻辑，如果 $O_n = O_{n+1}$，则发生一次命中。\n\n期望预测命中率 $h$ 是此事件的概率：\n$h = P(\\text{a hit occurs}) = P(O_{n+1} = O_n)$\n\n我们可以通过考虑发生命中的两种互斥方式来计算此概率：连续两次结果都是快路径，或者连续两次结果都是慢路径。根据全概率定律：\n$h = P(O_{n+1} = F \\text{ and } O_n = F) + P(O_{n+1} = S \\text{ and } O_n = S)$\n\n由于分支结果是独立事件，联合概率是各自概率的乘积：\n$h = P(O_{n+1} = F) \\cdot P(O_n = F) + P(O_{n+1} = S) \\cdot P(O_n = S)$\n\n给定每次试验的稳态概率：\n$h = p_{\\text{fast}} \\cdot p_{\\text{fast}} + p_{\\text{slow}} \\cdot p_{\\text{slow}}$\n\n这导出了命中率的最终表达式：\n$$h = p_{\\text{fast}}^2 + p_{\\text{slow}}^2$$\n代入 $p_{\\text{slow}} = 1 - p_{\\text{fast}}$：\n$h = p_{\\text{fast}}^2 + (1 - p_{\\text{fast}})^2 = p_{\\text{fast}}^2 + (1 - 2p_{\\text{fast}} + p_{\\text{fast}}^2) = 2p_{\\text{fast}}^2 - 2p_{\\text{fast}} + 1$。\n\n因此，预测错误的概率是 $1 - h$：\n$1 - h = 1 - (p_{\\text{fast}}^2 + p_{\\text{slow}}^2) = p_{\\text{fast}}(1 - p_{\\text{fast}}) + p_{\\text{slow}}(1 - p_{\\text{slow}}) = p_{\\text{fast}}p_{\\text{slow}} + p_{\\text{slow}}p_{\\text{fast}} = 2p_{\\text{fast}}p_{\\text{slow}}$。\n\n### 2. 每次调用的期望周期数（$E_{\\text{inline}}$ 和 $E_{\\text{out}}$）的推导\n\n根据期望的线性性质，每次屏障调用的期望总成本是其组成部分操作的期望成本之和。\n\n任何屏障调用的成本组成部分如下：\n1.  **基准分支成本：** 此成本 $c_{\\text{branch}}$ 在每次调用时都会产生。其期望值就是 $c_{\\text{branch}}$。\n2.  **分支预测错误惩罚：** 此成本 $c_{\\text{misp}}$ 仅在预测错误时产生。预测错误的概率是 $1 - h$。期望成本为 $c_{\\text{misp}} \\cdot P(\\text{预测错误}) = c_{\\text{misp}}(1 - h)$。\n3.  **慢路径工作成本：** 此成本 $c_{\\text{slow}}$ 仅在采用慢路径时产生。其概率为 $p_{\\text{slow}}$。期望成本为 $c_{\\text{slow}} \\cdot p_{\\text{slow}}$。\n4.  **调用/返回开销成本：** 此成本 $c_{\\text{callret}}$ 取决于实现方式。对于内联屏障，此成本为 $0$。对于非内联屏障，此成本为 $c_{\\text{callret}}$，并在每次调用时产生。\n\n**内联屏障的期望成本 ($E_{\\text{inline}}$)：**\n内联实现的总期望成本是分支、预测错误惩罚和慢路径工作的期望成本之和。\n$E_{\\text{inline}} = (\\text{期望分支成本}) + (\\text{期望预测错误惩罚}) + (\\text{期望慢路径工作成本})$\n$$E_{\\text{inline}} = c_{\\text{branch}} + c_{\\text{misp}}(1 - h) + c_{\\text{slow}}p_{\\text{slow}}$$\n代入 $1-h$ 的表达式：\n$$E_{\\text{inline}} = c_{\\text{branch}} + c_{\\text{misp}}(2p_{\\text{fast}}p_{\\text{slow}}) + c_{\\text{slow}}p_{\\text{slow}}$$\n\n**非内联屏障的期望成本 ($E_{\\text{out}}$)：**\n非内联实现会产生与内联版本相同的所有成本，此外每次调用还会增加一个恒定的调用/返回开销 $c_{\\text{callret}}$。\n$E_{\\text{out}} = E_{\\text{inline}} + c_{\\text{callret}}$\n$$E_{\\text{out}} = c_{\\text{branch}} + c_{\\text{misp}}(1 - h) + c_{\\text{slow}}p_{\\text{slow}} + c_{\\text{callret}}$$\n代入 $1-h$ 的表达式：\n$$E_{\\text{out}} = c_{\\text{branch}} + c_{\\text{misp}}(2p_{\\text{fast}}p_{\\text{slow}}) + c_{\\text{slow}}p_{\\text{slow}} + c_{\\text{callret}}$$\n\n这些公式为计算测试套件所需的值提供了必要的关系。", "answer": "[[1.059970, 5.059970, 0.998002],[1.597000, 5.597000, 0.980200],[1.000000, 5.000000, 1.000000],[1.299250, 1.299250, 0.990050],[1.119940, 9.119940, 0.998002]]", "id": "3683412"}]}