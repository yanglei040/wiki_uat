{"hands_on_practices": [{"introduction": "去虚拟化并非总能带来净收益，因为它常常需要引入运行时类型检查（即“守卫”）。这个练习将引导你建立一个简约的成本效益模型，从而量化这种权衡。通过推导预期性能增益的表达式，你将学会像编译器设计者一样，基于量化模型做出优化决策，并理解优化效果对性能剖析数据准确性的敏感度 [@problem_id:3637422]。", "problem": "一个编译器正在考虑对一门面向对象语言中的多态调用点进行去虚拟化。在基线情况下，调用是通过虚拟分派执行的，其每次调用的延迟是一个常数 $c_{indirect}$ 个周期。在去虚拟化的情况下，编译器会插入一个在每次调用时都执行的运行时类型守卫，如果预测的热点接收者类存在，则执行直接调用；否则，它会回退到原始的间接调用。假设一个基于全期望定律和以下基本事实的线性期望成本模型：直接调用的延迟是一个常数 $c_{direct}$ 个周期；守卫在每次调用时都会产生一个常数 $c_{guard}$ 个周期的开销；热点接收者情况出现的概率为 $p_{hot}$。从这些基本原理出发，推导出去虚拟化相对于基线的每次调用期望性能增益 $g$ 的表达式。\n\n对于一个特定的调用点，测量得出 $c_{indirect} = 17$ 个周期，$c_{direct} = 4$ 个周期，以及 $c_{guard} = 3$ 个周期。一次配置文件引导的优化（PGO）运行估计 $p_{hot}$ 为 $p_{hot}^{est} = 0.88$，但随后在即时（JIT）编译器中的运行时采样显示，真实的热点情况概率为 $p_{hot}^{true} = 0.786$。\n\n任务：\n- 使用推导出的 $g$ 的表达式，计算在估计概率下的期望增益 $g^{est}$ 和在真实概率下的期望增益 $g^{true}$。\n- 推导一阶灵敏度 $\\frac{\\partial g}{\\partial p_{hot}}$，并用它来量化 $g$ 如何随 $p_{hot}$ 的错误估计而变化。\n- 报告期望增益的绝对误差 $|g^{true} - g^{est}|$，以周期为单位。将你的答案四舍五入到四位有效数字，并以周期表示。", "solution": "基线的每次调用期望成本是 $c_{indirect}$，因为每次调用都是间接分派的。在去虚拟化的情况下，运行时类型守卫在每次调用时都会执行，并带来一个常数 $c_{guard}$ 个周期的开销。以概率 $p_{hot}$，会以成本 $c_{direct}$ 进行直接调用；以概率 $1 - p_{hot}$，会以成本 $c_{indirect}$ 进行间接调用。根据全期望定律和期望的线性性质，去虚拟化的期望成本为\n$$\n\\text{Cost}_{\\text{devirt}} = c_{guard} + p_{hot}\\,c_{direct} + (1 - p_{hot})\\,c_{indirect}.\n$$\n每次调用的期望增益 $g$ 是基线成本减去去虚拟化后的成本：\n$$\ng = c_{indirect} - \\left(c_{guard} + p_{hot}\\,c_{direct} + (1 - p_{hot})\\,c_{indirect}\\right).\n$$\n代数化简此表达式：\n\n$$\n\\begin{aligned}\ng &= c_{indirect} - c_{guard} - p_{hot}\\,c_{direct} - (1 - p_{hot})\\,c_{indirect} \\\\\n  &= c_{indirect} - c_{guard} - p_{hot}\\,c_{direct} - c_{indirect} + p_{hot}\\,c_{indirect} \\\\\n  &= p_{hot}\\,(c_{indirect} - c_{direct}) - c_{guard}.\n\\end{aligned}\n$$\n\n这就是从基本期望值推理得出的期望增益模型。\n\n接下来，计算在估计概率下和真实概率下的期望增益。使用 $c_{indirect} = 17$，$c_{direct} = 4$ 和 $c_{guard} = 3$，我们有 $c_{indirect} - c_{direct} = 17 - 4 = 13$。\n\n对于估计值 $p_{hot}^{est} = 0.88$，\n\n$$\ng^{est} = p_{hot}^{est}\\,(c_{indirect} - c_{direct}) - c_{guard} = 0.88 \\cdot 13 - 3 = 11.44 - 3 = 8.44.\n$$\n\n\n对于真实概率 $p_{hot}^{true} = 0.786$，\n\n$$\ng^{true} = p_{hot}^{true}\\,(c_{indirect} - c_{direct}) - c_{guard} = 0.786 \\cdot 13 - 3 = 10.218 - 3 = 7.218.\n$$\n\n\n由于错误估计导致的期望增益的绝对误差为\n\n$$\n|g^{true} - g^{est}| = |7.218 - 8.44| = | -1.222| = 1.222.\n$$\n\n\n为分析灵敏度，对 $g$ 关于 $p_{hot}$ 求导：\n\n$$\n\\frac{\\partial g}{\\partial p_{hot}} = c_{indirect} - c_{direct}.\n$$\n\n因此，对于一个小的变化 $\\Delta p_{hot}$，$g$ 的一阶变化近似为\n\n$$\n\\Delta g \\approx \\frac{\\partial g}{\\partial p_{hot}} \\,\\Delta p_{hot} = (c_{indirect} - c_{direct})\\,\\Delta p_{hot}.\n$$\n\n因为 $g$ 与 $p_{hot}$ 是精确线性的，所以对于任何 $\\Delta p_{hot}$，这个一阶近似都是精确的：\n\n$$\ng(p_{hot}^{true}) - g(p_{hot}^{est}) = (c_{indirect} - c_{direct})\\,(p_{hot}^{true} - p_{hot}^{est}).\n$$\n\n这里，$\\Delta p_{hot} = p_{hot}^{true} - p_{hot}^{est} = 0.786 - 0.88 = -0.094$，所以\n\n$$\n|g^{true} - g^{est}| = |(c_{indirect} - c_{direct})\\,\\Delta p_{hot}| = |13 \\cdot (-0.094)| = 1.222.\n$$\n\n\n四舍五入到四位有效数字并以周期表示，绝对误差是 $1.222$ 个周期。", "answer": "$$\\boxed{1.222}$$", "id": "3637422"}, {"introduction": "当一个调用点有多个常见的目标类型，而非仅一个“热”类型时，编译器该如何选择？此练习将探讨两种常见的优化策略：序列化的决策树和“守卫+回退”机制 [@problem_id:3637428]。通过为每种策略推导预期成本，你将学到如何根据目标类型的概率分布选择最优的检查序列，这是配置文件引导优化中的一项关键技能。", "problem": "一个实现去虚拟化的编译器面临一个对方法 $f$ 的多态调用点，其动态接收者可能是 $A$、$B$ 或 $C$ 类。假设接收者属于各类别的概率分别为 $p_{A}$、$p_{B}$ 和 $p_{C}$，且 $p_{A} + p_{B} + p_{C} = 1$。编译器可以在两种去虚拟化策略之间进行选择，这些策略根据预期成本进行评估，其基础是期望值的定义 $E = \\sum_{i} p_{i} c_{i}$。\n\n假设采用以下成本模型：\n- 每次类型检查（例如，评估诸如“接收者是 $X$ 类”之类的类测试）的成本为 $t > 0$。\n- 一次直接的、静态绑定的调用成本为 $d > 0$。\n- 一次回退的虚分派在直接调用成本之外还有额外的成本 $v > 0$，因此其总成本为 $v + d$。\n- 一个守卫（用于确认最可能目标的单一类型检查）的成本为 $g > 0$。\n\n策略 1（决策树去虚拟化）：生成一个由类型检查组成的决策树，以直接调用 $A::f$、$B::f$ 或 $C::f$。该决策树使用短路求值：对于一个顺序 $(X, Y, Z)$，编译器首先测试“是 $X$ 吗？”；如果为假，则测试“是 $Y$ 吗？”；如果两者都为假，则无需进行第三次测试，直接调用 $Z::f$。\n\n策略 2（带守卫的直接调用）：为最可能的目标（概率最大的类）生成一个守卫，如果守卫通过则进行直接调用；否则，回退到虚分派。\n\n任务：\n1. 使用全期望定律和给定的成本模型，确定在策略 1 中能够最小化预期成本的 $(A, B, C)$ 的顺序。令 $p_{(1)} = \\max\\{p_{A}, p_{B}, p_{C}\\}$ 表示这三个类中最大的概率。\n2. 推导策略 1 的最小预期成本，用 $p_{(1)}$、$t$ 和 $d$ 表示。\n3. 推导策略 2 的预期成本，用 $p_{(1)}$、$g$、$v$ 和 $d$ 表示。\n4. 计算策略 2 与策略 1 最小预期成本之间的差值 $D = E_{\\text{guard}} - E_{\\text{tree,min}}$，给出一个单一的、简化的闭式表达式。\n\n将 $D$ 的简化解析表达式作为最终答案。无需进行数值计算。如果引入任何额外的记号，请明确定义。最终表达式中不要使用任何单位。", "solution": "问题陈述已经过验证，被认为在编译器设计与优化领域内是合理的、自洽的且有科学依据的。这是一个适定问题，可以使用概率论和成本分析的原理来解决。\n\n解答过程将按顺序处理这四个任务。所有数学实体均按要求使用 LaTeX 渲染。\n\n**任务 1 和 2：策略 1（决策树去虚拟化）分析**\n\n策略 $1$ 涉及一系列类型检查。假设选择的检查顺序为 $(C_1, C_2, C_3)$，其中 $\\{C_1, C_2, C_3\\}$ 是 $\\{A, B, C\\}$ 的一个排列。编译器生成的代码等价于：“如果接收者是 $C_1$ 类，则调用 $C_1::f$；否则如果接收者是 $C_2$ 类，则调用 $C_2::f$；否则调用 $C_3::f$。”\n\n我们计算接收者每种可能的动态类型的成本：\n- 如果接收者是 $C_1$ 类（发生概率为 $p_{C_1}$），则执行一次类型检查（成本 $t$）并成功。然后进行一次直接调用（成本 $d$）。总成本为 $t + d$。\n- 如果接收者是 $C_2$ 类（概率为 $p_{C_2}$），则第一次对 $C_1$ 的类型检查执行并失败（成本 $t$）。第二次对 $C_2$ 的类型检查执行并成功（成本 $t$）。进行一次直接调用（成本 $d$）。总成本为 $t + t + d = 2t + d$。\n- 如果接收者是 $C_3$ 类（概率为 $p_{C_3}$），则第一次对 $C_1$ 的检查失败（成本 $t$），第二次对 $C_2$ 的检查也失败（成本 $t$）。`else` 分支被执行，直接调用 $C_3::f$（成本 $d$），无需进行第三次类型检查。总成本为 $t + t + d = 2t + d$。\n\n对于顺序 $(C_1, C_2, C_3)$，其预期成本 $E_{\\text{tree}}$ 是根据全期望定律计算的按概率加权的成本之和：\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = p_{C_1}(t + d) + p_{C_2}(2t + d) + p_{C_3}(2t + d)\n$$\n我们可以分解这个表达式：\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = p_{C_1}t + p_{C_1}d + 2p_{C_2}t + p_{C_2}d + 2p_{C_3}t + p_{C_3}d\n$$\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (p_{C_1} + 2p_{C_2} + 2p_{C_3})t + (p_{C_1} + p_{C_2} + p_{C_3})d\n$$\n鉴于约束条件 $p_{A} + p_{B} + p_{C} = 1$，第二项简化为 $d$。我们也可以将 $p_{C_2} + p_{C_3}$ 重写为 $1 - p_{C_1}$：\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (p_{C_1} + 2(p_{C_2} + p_{C_3}))t + d\n$$\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (p_{C_1} + 2(1 - p_{C_1}))t + d\n$$\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (p_{C_1} + 2 - 2p_{C_1})t + d\n$$\n$$\nE_{\\text{tree}}(C_1, C_2, C_3) = (2 - p_{C_1})t + d\n$$\n为了最小化此预期成本，由于 $t > 0$，我们必须最大化 $p_{C_1}$ 的值。这意味着第一个被检查的类 $C_1$ 必须是概率最高的那个。\n令 $p_{(1)} = \\max\\{p_{A}, p_{B}, p_{C}\\}$。最优顺序要求将 $C_1$ 设置为对应于 $p_{(1)}$ 的类。剩下两个类的相对顺序不影响最小预期成本，因为它们的成本是相同的（$2t+d$）。\n\n这就完成了任务 1。对于任务 2，策略 1 的最小预期成本 $E_{\\text{tree,min}}$，可通过将 $p_{(1)}$ 代替 $p_{C_1}$ 到推导出的成本公式中获得：\n$$\nE_{\\text{tree,min}} = (2 - p_{(1)})t + d\n$$\n\n**任务 3：策略 2（带守卫的直接调用）分析**\n\n策略 $2$ 使用单个守卫来检查最可能的目标，即概率为 $p_{(1)}$ 的类。如果守卫通过，则进行直接调用。如果失败，则执行一次完整的虚分派。\n\n我们分析两种结果的成本：\n- 接收者是最可能的类（概率为 $p_{(1)}$）：守卫被执行（成本 $g$）并成功通过。进行一次直接调用（成本 $d$）。总成本为 $g + d$。\n- 接收者不是最可能的类（概率为 $1 - p_{(1)}$）：守卫被执行（成本 $g$）并失败。发生一次到虚分派的回退（成本 $v+d$）。总成本为 $g + v + d$。\n\n策略 2 的预期成本 $E_{\\text{guard}}$ 为：\n$$\nE_{\\text{guard}} = p_{(1)}(g + d) + (1 - p_{(1)})(g + v + d)\n$$\n让我们简化这个表达式：\n$$\nE_{\\text{guard}} = p_{(1)}g + p_{(1)}d + g + v + d - p_{(1)}g - p_{(1)}v - p_{(1)}d\n$$\n$$\nE_{\\text{guard}} = (p_{(1)}g - p_{(1)}g) + (p_{(1)}d - p_{(1)}d) + g + v + d - p_{(1)}v\n$$\n$$\nE_{\\text{guard}} = g + d + v - p_{(1)}v\n$$\n$$\nE_{\\text{guard}} = g + d + v(1 - p_{(1)})\n$$\n\n**任务 4：计算预期成本的差值**\n\n最后的任务是计算差值 $D = E_{\\text{guard}} - E_{\\text{tree,min}}$。使用上面推导出的表达式：\n$$\nE_{\\text{guard}} = g + d + v(1 - p_{(1)})\n$$\n$$\nE_{\\text{tree,min}} = (2 - p_{(1)})t + d = 2t - p_{(1)}t + d\n$$\n差值 $D$ 为：\n$$\nD = \\left( g + d + v(1 - p_{(1)}) \\right) - \\left( (2 - p_{(1)})t + d \\right)\n$$\n$$\nD = g + d + v - p_{(1)}v - (2t - p_{(1)}t + d)\n$$\n$$\nD = g + d + v - p_{(1)}v - 2t + p_{(1)}t - d\n$$\n直接调用成本 $d$ 被消掉了：\n$$\nD = g + v - 2t - p_{(1)}v + p_{(1)}t\n$$\n合并包含 $p_{(1)}$ 的项，得出最终的简化表达式：\n$$\nD = g + v - 2t + p_{(1)}(t - v)\n$$", "answer": "$$\n\\boxed{g + v - 2t + p_{(1)}(t - v)}\n$$", "id": "3637428"}, {"introduction": "最优的性能提升来自于完全消除运行时开销。本练习将揭示编译器如何通过组合多种静态分析技术，在编译期证明对象的确切类型 [@problem_id:3637449]。你将看到，通过利用类层次结构分析（CHA）、常量传播以及语言特性（如 `final` 字段），编译器可以实现逻辑推理，从而将虚调用安全地转换为无需任何运行时检查的直接调用。", "problem": "Java编程语言的一种优化编译器会应用去虚拟化技术，当它能在调用点证明接收者的动态类型时，它会特化虚调用。考虑以下这个小型的Java程序，它使用了一个区分了子类的 final 字段和一个枚举，而不是使用数字标签：\n\n```java\nenum Tag { CONST, ADD }\nabstract class Node {\n  final Tag tag;\n  Node(Tag t) { this.tag = t; }\n  abstract int eval();\n}\nfinal class Const extends Node {\n  final int value;\n  Const(int v) { super(Tag.CONST); this.value = v; }\n  int eval() { return value; }\n}\nfinal class Add extends Node {\n  final Node l, r;\n  Add(Node l, Node r) { super(Tag.ADD); this.l = l; this.r = r; }\n  int eval() { return l.eval() + r.eval(); }\n}\nclass Factory {\n  static Node mk(boolean b, int v) {\n    if (b) return new Const(v);\n    else return new Add(new Const(v), new Const(v));\n  }\n}\nclass Use {\n  static int run(boolean b, int v) {\n    Node n = Factory.mk(b, v);\n    if (n.tag == Tag.CONST) {\n      return ((Const) n).eval();\n    } else {\n      return n.eval();\n    }\n  }\n}\n```\n\n假设编译器采用：\n- 稀疏条件常量传播（SCCP；一种在控制流图中传播常量值的数据流分析），\n- 类层次结构分析（CHA；一种界定可能的动态接收者类集合的静态分析），\n- 指向分析（一种别名分析，它跟踪在程序控制流下引用变量 `n` 可能指向哪些分配点），以及\n- Java语言规范中关于 `final` 字段的语义（`final` 字段在构造期间被赋值，并且在安全发布的明确定义条件下不会被后续修改）。\n\n从动态分派（一种基于运行时接收者对象的动态类型来解析方法调用的机制）、数据流常量传播（对常量值的流敏感推断）和别名分析（对引用及其突变的推理）的基本定义出发，且不假设任何特殊情况的公式，请确定以下哪组假设足以让编译器（i）将 `final` 字段值 `tag` 从对象的分配点传播到分支处，（ii）确定分支条件 `n.tag == Tag.CONST` 在 `then` 分支中意味着接收者的确切动态类型是 `Const`，在 `else` 分支中意味着其类型是 `Add`，并因此（iii）在没有运行时守卫的情况下编译对 `Const.eval()` 和 `Add.eval()` 的直接调用。\n\n选择唯一的最佳选项。\n\nA. 字段 `tag` 被声明为 `final`，并且仅在每个子类的构造函数中被赋值为一个唯一的枚举常量（`Const` 为 `Tag.CONST`，`Add` 为 `Tag.ADD`）；类 `Const` 和 `Add` 被声明为 `final`；没有对 `tag` 进行反射或低级别的写操作（例如，通过 `java.lang.reflect` 或 `sun.misc.Unsafe`）；指向分析证明调用点的接收者 `n` 来自 `Const` 或 `Add` 的构造函数；类层次结构分析（CHA）采用封闭世界假设，因此不可能有 `Node` 的其他子类。在这些条件下，SCCP可以传播 `tag` 的值，在可达的分配点中从 `tag` 到子类的映射是单射的，并且在没有运行时守卫的情况下，去虚拟化为直接调用是可靠的。\n\nB. 仅将 `tag` 声明为 `final` 就足够了；既不需要别名分析也不需要类层次结构分析，并且反射更新或动态类加载不影响去虚拟化的可靠性。\n\nC. 逃逸分析证明 `n` 不会逃逸出方法 `Use.run`；因此，编译器可以无条件地用直接调用目标替换虚调用，而不管 `tag` 的值如何。\n\nD. 编译器将检查 `n.tag == Tag.CONST` 视为等同于 `instanceof Const` 测试，并基于该假定进行去虚拟化，即使没有证明每个子类构造函数都分配了唯一的 `tag` 值或排除了反射写操作；允许开放世界的动态类加载。", "solution": "要安全地将虚调用 `n.eval()` 去虚拟化为直接调用，编译器必须在编译时无可辩驳地证明变量 `n` 的确切动态类型。这需要一个严密的逻辑推理链，将多个静态分析的结果结合起来。\n\n1.  **确定可能的类型范围：** 编译器首先需要知道 `n` 可能指向哪些类型的对象。\n    *   **类层次结构分析（CHA）** 结合 **封闭世界假设** 是关键的第一步。CHA会扫描代码库，发现 `Node` 有 `Const` 和 `Add` 两个子类。封闭世界假设则让编译器可以断定，在运行时不会有其他 `Node` 的子类（例如通过动态类加载）出现。因此，编译器可以确定 `n` 的动态类型必须是 `Const` 或 `Add` 之一。\n    *   **指向分析** 则将引用 `n` 与其可能的创建点（`Factory.mk` 中的 `new Const(...)` 和 `new Add(...)`）联系起来，确认 `n` 确实指向这两个已知来源的对象。\n\n2.  **建立类型与标签值的唯一映射：** 接下来，编译器需要利用 `n.tag` 的值来区分这两个类型。\n    *   通过分析 `Const` 和 `Add` 的构造函数，编译器发现 `Const` 对象总是将 `tag` 字段设置为 `Tag.CONST`，而 `Add` 对象总是将其设置为 `Tag.ADD`。由于这两个枚举值是不同的，就建立了一个从类型到标签值的单射（一对一）映射。\n\n3.  **保证标签值的不可变性：** 这个映射只有在 `tag` 的值在对象构造后不再改变时才可靠。\n    *   `tag` 字段被声明为 **`final`**，这向编译器提供了强有力的保证，即其值在初始化后不会被修改。\n    *   然而，Java中的反射（`java.lang.reflect`）或 `sun.misc.Unsafe` 等机制可以绕过 `final` 的限制。因此，一个完全可靠的优化必须**排除这些后门写操作**的可能性。\n\n综合以上各点，编译器可以在 `if (n.tag == Tag.CONST)` 这个分支上进行如下推理：\n-   **`then` 分支：** 条件为真，意味着 `n.tag` 的值是 `Tag.CONST`。由于类型与标签值的映射是唯一的，且 `n` 的类型只能是 `Const` 或 `Add`，编译器可以确信 `n` 的类型一定是 `Const`。因此，`((Const) n).eval()` 的调用是安全的。\n-   **`else` 分支：** 条件为假，意味着 `n.tag` 的值不是 `Tag.CONST`。由于 `n` 的唯一另一种可能类型是 `Add`（其标签为 `Tag.ADD`），编译器可以断定 `n` 的类型一定是 `Add`。因此，虚调用 `n.eval()`可以被安全地替换为对 `Add.eval()` 的直接调用，无需任何运行时检查。\n\n现在我们来评估各个选项：\n*   **A.** 此选项准确且完整地列出了上述所有必要的条件：`final` 字段、唯一的标签赋值、`final` 类（进一步加强封闭世界假设）、排除反射写操作、指向分析以及带有封闭世界假设的CHA。这是执行此优化所需的充分条件集。\n*   **B.** 此选项不充分。仅有 `final` 关键字是不够的；没有CHA和封闭世界假设，编译器无法对 `else` 分支进行推理。此外，它错误地忽略了反射和动态类加载的威胁。\n*   **C.** 此选项不相关。逃逸分析用于确定对象的生命周期和分配位置（栈或堆），它不能用来推断依赖于程序输入的对象的具体类型。\n*   **D.** 此选项描述了一种不健全、会产生错误代码的编译器。在没有证明的情况下将标签检查等同于 `instanceof` 是一个危险的假设，尤其是在允许开放世界和反射写操作的情况下。\n\n因此，选项A是唯一一个描述了能够让编译器进行可靠和安全优化的充分假设集合。", "answer": "$$\\boxed{A}$$", "id": "3637449"}]}