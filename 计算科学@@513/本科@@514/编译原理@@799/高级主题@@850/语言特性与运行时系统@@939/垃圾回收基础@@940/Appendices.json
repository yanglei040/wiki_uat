{"hands_on_practices": [{"introduction": "标记-清除（Mark-Sweep）是所有自动内存管理算法的基石。这个实践练习将理论付诸实践，要求你从零开始，为一个由双向链表节点构成的堆实现一个完整的标记-清除垃圾收集器 [@problem_id:3229801]。通过将可达性的图论定义转化为具体代码，你将深入理解垃圾收集器如何区分和回收不再使用的对象，从而为掌握更复杂的GC算法打下坚实的基础。", "problem": "给定一个有限的对象堆，每个对象代表一个双向链表的节点，具有两个字段：“next”指针和“prev”指针。形式上，设堆为一个由唯一整数标识符索引的有限节点集合，我们将其建模为一个有限的三元组集合 $H = \\{(i, n_i, p_i)\\}$，其中对于每个节点标识符 $i$，有两个指针值 $n_i$（“next”指针）和 $p_i$（“prev”指针）。每个指针值要么是堆中一个已存在的节点标识符，要么是空哨兵值，表示为整数 $-1$。设由 $H$ 导出的有向图 $G = (V, E)$ 的顶点集为 $V = \\{ i \\mid (i, n_i, p_i) \\in H \\}$，有向边集为 $E = \\{ (i, n_i) \\mid n_i \\in V \\} \\cup \\{ (i, p_i) \\mid p_i \\in V \\}$。此外，给定一个根集 $R$，它是一个指针（节点标识符）的集合，可能包含重复项、空哨兵值或不存在于 $V$ 中的标识符。如果存在一条在 $G$ 中的有限路径，从某个 $r \\in R \\cap V$ 开始并以 $v$ 结束，则称节点 $v \\in V$ 是从 $R$ 可达的。定义标记集 $M \\subseteq V$ 为从 $R$ 可达的所有节点的集合。一个标记-清除垃圾回收器的具体规定如下：\n- 标记阶段：计算包含 $R \\cap V$ 并且在沿 $E$ 中的边跟随“next”和“prev”指针的操作下是闭合的最小不动点 $M$。\n- 清除阶段：从堆中移除 $V \\setminus M$ 中的所有节点。移除后，对于每个幸存节点 $(i, n_i, p_i)$（其中 $i \\in M$），将任何不指向 $M$ 中某个元素的指针重写为空哨兵值（表示为 $-1$）。\n\n你必须从第一性原理出发，实现这个标记-清除垃圾回收器，其精确行为如下：\n- 在标记阶段，只有等于现有标识符的指针才会被遍历；空哨兵值 $-1$ 和任何不存在的标识符（不在 $V$ 中的整数）都将被忽略。\n- 根集 $R$ 可能包含空哨兵值 $-1$ 或不存在于 $V$ 中的标识符；这些在标记阶段都会被忽略。\n- 标记阶段必须将“next”和“prev”指针都视作出边，并进行跟踪。\n- 清除阶段移除所有未标记的节点，并将幸存节点中任何不指向幸存节点的指针重写为空哨兵值 $-1$。\n\n对于每个测试用例，你的程序必须输出垃圾回收后幸存节点的标识符排序列表。标识符必须按严格升序排列。\n\n你可以使用的基本原理：\n- 图论中的可达性定义：给定一个有向图 $G = (V, E)$ 和一个集合 $R \\subseteq V$，可达集 $M$ 是满足 $R \\subseteq M$ 的最小集合，并且只要 $(u, v) \\in E$ 且 $u \\in M$，那么 $v \\in M$。\n- 集合的差集、并集和交集的基本性质。\n- 空哨兵值的语义，表示“无指针”，在图遍历期间不被跟踪。\n\n测试套件。每个堆以一个三元组 $(\\text{id}, \\text{next}, \\text{prev})$ 的列表形式给出，每个根集是一个整数列表。整数 $-1$ 表示空哨兵值。\n\n- 测试用例 1（简单有限链条）：\n  - 堆 $H_1 = \\{ (1, 2, -1), (2, 3, 1), (3, -1, 2) \\}$。\n  - 根集 $R_1 = [2]$。\n- 测试用例 2（两个连通分量，其中一个被隔离）：\n  - 堆 $H_2 = \\{ (10, 11, -1), (11, -1, 10), (20, -1, -1) \\}$。\n  - 根集 $R_2 = [10]$。\n- 测试用例 3（带有重复根节点的循环双向链表）：\n  - 堆 $H_3 = \\{ (30, 31, 32), (31, 32, 30), (32, 30, 31) \\}$。\n  - 根集 $R_3 = [31, 31]$。\n- 测试用例 4（指向不存在节点的损坏指针）：\n  - 堆 $H_4 = \\{ (40, 999, -1), (41, 40, -1) \\}$，其中 $999 \\notin V$。\n  - 根集 $R_4 = [41]$。\n- 测试用例 5（空根集）：\n  - 堆 $H_5 = \\{ (50, 51, -1), (51, -1, 50) \\}$。\n  - 根集 $R_5 = []$。\n- 测试用例 6（自循环节点和空根条目）：\n  - 堆 $H_6 = \\{ (60, 60, 60) \\}$。\n  - 根集 $R_6 = [60, -1]$。\n\n要求的最终输出格式：\n- 你的程序必须生成单行，包含一个不含空格的 Python 风格列表。该列表有 $6$ 个元素，按给定顺序对应每个测试用例。每个元素本身是一个列表（同样不含空格），包含该测试用例中幸存节点的标识符，按严格升序排列。例如，如果某个测试用例的幸存者是标识符 $1$、 $2$ 和 $3$，那么其元素必须写为 \"[1,2,3]\"，不含空格。整行将这六个测试用例的列表连接在一个外部方括号内，用逗号分隔，不含空格。", "solution": "该问题要求实现一个标记-清除垃圾回收器，用于一个由双向链表结构中的节点组成的内存堆。堆的状态和垃圾回收过程都有形式化定义，任务是确定几个测试用例中幸存节点的集合。\n\n### 问题验证\n\n**步骤 1：提取已知信息**\n-   堆是一个有限的三元组集合 $H = \\{(i, n_i, p_i)\\}$，其中 $i$ 是唯一的整数节点标识符，$n_i$ 是 `next` 指针，$p_i$ 是 `prev` 指针。\n-   指针值可以是已存在的节点标识符或由整数 $-1$ 表示的空哨兵值。\n-   堆导出一个有向图 $G = (V, E)$，其中 $V = \\{ i \\mid (i, n_i, p_i) \\in H \\}$ 且 $E = \\{ (i, n_i) \\mid n_i \\in V \\} \\cup \\{ (i, p_i) \\mid p_i \\in V \\}$。\n-   提供一个根集 $R$，其中可能包含节点标识符、重复项、空哨兵值（$-1$）或不在 $V$ 中的标识符。\n-   标记集 $M \\subseteq V$ 包含所有从有效根 $R \\cap V$ 出发，通过遍历任意数量的 `next` 或 `prev` 指针可达的节点。\n-   标记-清除过程定义为两个阶段：\n    1.  **标记**：计算可达集 $M$。\n    2.  **清除**：移除 $V \\setminus M$ 中的节点。幸存节点中指向被移除节点的指针将被重写为 $-1$。\n-   要求的输出是幸存节点的标识符排序列表，也就是集合 $M$。\n\n**步骤 2：使用提取的已知信息进行验证**\n根据指定标准评估问题陈述：\n-   **科学基础扎实**：该问题基于计算机科学中成熟的垃圾回收、图论和数据结构原理。标记-清除算法和可达性概念是基础且数学上合理的。\n-   **定义明确**：该问题是定义明确的（良构的）。标记集 $M$ 被定义为一个闭包操作的最小不动点，这保证了其存在性和唯一性。找到这个集合的算法（图遍历）是标准且确定性的。\n-   **客观性**：语言是形式化且精确的，使用了无歧义的数学定义，避免了主观性陈述。\n-   问题是**独立的**，提供了所有必要的定义、约束和测试数据。它是**内部一致的**；处理指针（包括空指针和不存在的指针）的规则被清晰地指定，且彼此不矛盾。虽然清除阶段对指针重写的描述对于所要求的输出（幸存者集合）来说并非严格必要，但它正确地描述了完整的垃圾回收过程，并且没有产生任何矛盾。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。它是在算法和数据结构领域内一个定义明确且形式上合理的问题。将提供一个完整的解决方案。\n\n### 基于原理的解决方案\n\n**1. 形式化问题表示**\n\n问题的核心是识别图中节点的特定子集。堆 $H$ 是有向图 $G=(V, E)$ 的一种表示。顶点集 $V$ 是堆中存在的所有节点标识符的集合。边集 $E$ 由 `next` 和 `prev` 指针定义。具体来说，对于每个节点 $i \\in V$ 及其指针 $(n_i, p_i)$，如果 $n_i \\in V$ 和 $p_i \\in V$，则分别存在潜在的有向边 $(i, n_i)$ 和 $(i, p_i)$。\n\n任务是计算“存活”或“可达”节点的集合，我们表示为 $M$。这个集合由从给定根集 $R$ 的图可达性定义。一个节点 $v \\in V$ 在 $M$ 中，当且仅当在图 $G$ 中存在一条从某个起始节点 $r \\in R \\cap V$ 到 $v$ 的路径。遍历的起始节点集是 $R \\cap V$，仅包含那些在堆中是有效节点标识符的根。\n\n**2. 算法原理：图的可达性**\n\n计算标记集 $M$ 是一个经典的图可达性问题。给定一个有向图 $G=(V,E)$ 和一个起始顶点集 $S \\subseteq V$，目标是找到从 $S$ 中任意顶点可达的所有顶点。由于问题规定 `next` 和 `prev` 指针都应被跟随，我们实际上是在寻找底层无向图中包含至少一个根节点的连通分量中的所有节点。\n\n一个标准且高效的算法是广度优先搜索 (BFS)。BFS 从给定的根节点开始，系统地逐层探索图。它保证能找到所有可达的节点。\n\n**3. 算法设计**\n\n垃圾回收过程可以通过精确遵循形式化定义来实现。\n\n**数据结构：**\n-   **堆表示**：堆 $H$ 最好存储在一个哈希映射中（在 Python 中是字典），将每个节点标识符 $i$ 映射到其指针的元组 $(n_i, p_i)$。这为访问节点的指针提供了平均 $O(1)$ 的时间复杂度。有效节点标识符的集合 $V$ 可以通过该字典的键高效地获得。\n-   **标记集**：使用一个哈希集合（在 Python 中是 `set`）来存储标记集 $M$。这使得插入和检查一个节点是否已被标记的平均时间复杂度为 $O(1)。\n-   **遍历队列**：BFS 算法需要一个队列数据结构。Python 的 `collections.deque` 对此非常高效，提供了 $O(1)$ 时间复杂度的追加和从左侧弹出的操作。\n\n**标记阶段实现 (BFS)：**\n1.  **初始化**：\n    -   从输入的三元组列表创建堆字典。设 $V$ 为其键的集合。\n    -   为 $M$ 初始化一个空集合 `marked`。\n    -   初始化一个空队列 `to_visit`。\n    -   遍历给定的根集 $R$。对于每个根 $r \\in R$，如果 $r \\in V$ 且 $r$ 尚未被标记（此检查用于处理重复根的情况），则将 $r$ 同时添加到 `marked` 集合和 `to_visit` 队列中。\n\n2.  **遍历循环**：\n    -   当 `to_visit` 队列不为空时，执行以下步骤：\n        -   从队列中取出一个节点标识符，称之为 $u$。\n        -   从堆字典中检索其指针 $(n_u, p_u)$。\n        -   对于每个指针值 $v \\in \\{n_u, p_u\\}$：\n            -   检查指针是否有效：$v \\in V$。条件 $v \\neq -1$ 和 $v$ 是堆字典的键确保了这一点。\n            -   如果 $v$ 有效且 $v \\notin \\text{marked}$，则它是一个新发现的存活节点。将 $v$ 添加到 `marked` 集合，并将其入队到 `to_visit` 队列。\n    -   当队列为空时，此过程终止，此时 `marked` 集合包含所有从初始根可达的节点。\n\n**清除阶段与输出生成：**\n-   问题陈述，“清除”阶段会移除未标记的节点。因此，幸存节点的集合正是 `marked` 集合 $M$。\n-   要求的输出是 $M$ 中标识符的排序列表。最后一步是将 `marked` 集合转换为列表并按升序排序。\n\n**复杂度分析**：\n-   设 $|V|$ 为图中节点的数量，$|E|$ 为边的数量。在我们的情况下，$|E| \\le 2|V|$。\n-   **时间复杂度**：堆字典的初始化需要 $O(|V|)$ 时间。根集 $R$ 的预处理需要 $O(|R|)$ 时间。BFS 遍历最多访问每个可达节点及其每条边一次。因此，标记阶段的时间复杂度与可达子图中的节点和边的数量成正比，最坏情况下为 $O(|V|+|E|)$（如果所有节点都可达）。\n-   **空间复杂度**：所需空间主要由堆字典、标记集和 BFS 队列主导。在最坏情况下，所有节点都可达，因此存储这些结构的空间复杂度为 $O(|V|)$。", "answer": "```python\nimport collections\nimport numpy as np\n\ndef run_gc(heap_data, roots):\n    \"\"\"\n    Performs mark-and-sweep garbage collection and returns the sorted list of survivor IDs.\n\n    Args:\n        heap_data (list): A list of tuples (id, next, prev) representing the heap.\n        roots (list): A list of integer root pointers.\n\n    Returns:\n        list: A sorted list of integer IDs of the surviving nodes.\n    \"\"\"\n    # Step 1: Represent the heap as a dictionary for efficient access.\n    # The set of valid node IDs is the set of keys of this dictionary.\n    heap = {node[0]: (node[1], node[2]) for node in heap_data}\n    valid_node_ids = set(heap.keys())\n\n    # Step 2: Initialize data structures for the Mark phase (BFS traversal).\n    # 'marked' will store the set of reachable nodes (M).\n    # 'queue' is the frontier for the BFS.\n    marked = set()\n    queue = collections.deque()\n\n    # Step 3: Populate the initial queue with valid and unique roots.\n    # A root is valid if it exists in the heap (is in valid_node_ids).\n    # The null sentinel (-1) and non-existent IDs are ignored.\n    for root_id in roots:\n        if root_id in valid_node_ids and root_id not in marked:\n            marked.add(root_id)\n            queue.append(root_id)\n\n    # Step 4: Perform the Mark phase using Breadth-First Search (BFS).\n    # Explore the graph starting from the roots, following both 'next' and 'prev' pointers.\n    while queue:\n        current_id = queue.popleft()\n\n        # Retrieve pointers for the current node.\n        next_id, prev_id = heap[current_id]\n\n        # Process neighbors (nodes pointed to by 'next' and 'prev').\n        for neighbor_id in [next_id, prev_id]:\n            # A neighbor is processed only if it's a valid node and has not been marked yet.\n            if neighbor_id in valid_node_ids and neighbor_id not in marked:\n                marked.add(neighbor_id)\n                queue.append(neighbor_id)\n\n    # Step 5: The 'marked' set now contains all survivor IDs.\n    # The 'sweep' phase conceptually removes all other nodes.\n    # The required output is the sorted list of these survivor IDs.\n    survivors = sorted(list(marked))\n    return survivors\n\ndef solve():\n    \"\"\"\n    Runs the garbage collection simulation for all test cases and prints the result\n    in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (simple finite chain)\n        (\n            [(1, 2, -1), (2, 3, 1), (3, -1, 2)],\n            [2]\n        ),\n        # Test case 2 (two components, one isolated)\n        (\n            [(10, 11, -1), (11, -1, 10), (20, -1, -1)],\n            [10]\n        ),\n        # Test case 3 (circular doubly linked list with duplicate roots)\n        (\n            [(30, 31, 32), (31, 32, 30), (32, 30, 31)],\n            [31, 31]\n        ),\n        # Test case 4 (broken pointer to non-existent node)\n        (\n            [(40, 999, -1), (41, 40, -1)],\n            [41]\n        ),\n        # Test case 5 (empty roots)\n        (\n            [(50, 51, -1), (51, -1, 50)],\n            []\n        ),\n        # Test case 6 (self-looping node and a null root entry)\n        (\n            [(60, 60, 60)],\n            [60, -1]\n        ),\n    ]\n\n    formatted_results = []\n    for heap_data, roots in test_cases:\n        survivor_ids = run_gc(heap_data, roots)\n        # Format each list of results as a string \"[id1,id2,...]\" with no spaces.\n        formatted_results.append(f\"[{','.join(map(str, survivor_ids))}]\")\n\n    # Join all formatted strings into the final output format.\n    # e.g., \"[[1,2,3],[10,11]]\"\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3229801"}, {"introduction": "在了解了垃圾收集器如何工作之后，下一个关键问题是如何让它高效工作。分代式垃圾收集是一种广泛应用的优化策略，但它引入了关于新生代（nursery）大小的关键权衡：较小的新生代意味着更短但更频繁的GC暂停，而较大的新生代则相反。此练习 [@problem_id:3643388] 引导你使用一个简化的数学模型，通过最小化一个综合了暂停时间和吞吐量损失的目标函数 $J(N)$，来推导出最优的新生代大小 $N^{\\star}$。这是一个关于系统性能分析与调优的绝佳实践。", "problem": "考虑一个使用分代垃圾回收（GC）的管理型运行时，该运行时具有两代：一个新生代和一个老年代。新生代用于存放新分配的对象，并在其空间占满时触发一次次要回收。假设以下经过充分检验的事实和核心定义成立：\n\n- 对象分配遵循速率为 $\\lambda$（对象/秒）的泊松过程。对于泊松过程，累积 $N$ 次分配的期望时间为 $N / \\lambda$。\n- 每个新分配的对象在下一次次要回收中独立存活的概率为 $s \\in [0,1]$。这意味着跨回收的存活模式呈几何分布，特别地，在下一次次要回收时，一批 $N$ 个新分配的对象中的期望存活数量为 $sN$。\n- 次要回收的暂停时间由两个部分构成：\n  1. 一个固定的根和元数据处理开销 $t_{r} > 0$，该开销不依赖于 $N$。\n  2. 与新生代大小 $N$ 和存活对象数量 $sN$ 成线性关系的成本。设 $c_{n} > 0$ 为扫描新生代中每个对象的成本， $c_{p} > 0$ 为处理每个存活对象并将其提升到老年代的成本。\n\n在这些假设下，将次要回收暂停时间定义为新生代大小 $N$ 的函数：$T(N) = t_{r} + c_{n}N + c_{p}sN$。由于新生代在 $N$ 次分配后被填满，因此期望的次要回收频率为 $\\lambda / N$，所以每单位时钟时间内，花费在次要 GC 上的时间的期望比例为 $(\\lambda / N) \\cdot T(N)$。\n\n一位系统工程师希望通过一个权衡吞吐量和暂停时间延迟的标量目标来平衡这两者。设 $\\alpha > 0$ 为瞬时暂停时间的权重，$\\beta > 0$ 为每单位时间内因次要回收所损失的时间的权重。该工程师的目标是选择新生代大小 $N$ 来最小化\n$$\nJ(N) = \\alpha \\, T(N) + \\beta \\left(\\frac{\\lambda}{N}\\right) T(N).\n$$\n\n假设 $N$ 是一个正实数变量，代表以期望对象数量衡量的有效新生代容量。请推导使 $J(N)$ 最小化的 $N$ 值，并将其表示为由 $\\lambda$、$s$、$t_{r}$、$c_{n}$、$c_{p}$、$\\alpha$ 和 $\\beta$ 构成的单一闭式解析表达式。最终表达式无需近似或取整。使用符号 $N^{\\star}$ 表示最优解。", "solution": "问题陈述经确认为有效，因其具有科学依据、良定、客观且自洽。所提出的模型是用于分析垃圾回收性能的一个标准且适当的简化模型。我们的任务是找到使目标函数 $J(N)$ 最小化的新生代大小 $N$。\n\n目标函数 $J(N)$ 由下式给出：\n$$J(N) = \\alpha \\, T(N) + \\beta \\left(\\frac{\\lambda}{N}\\right) T(N)$$\n次要回收暂停时间 $T(N)$ 定义为：\n$$T(N) = t_{r} + c_{n}N + c_{p}sN$$\n参数 $\\alpha$、$\\beta$、$\\lambda$、$t_{r}$、$c_{n}$ 和 $c_{p}$ 均被指定为正实数，存活概率 $s$ 在 $[0,1]$ 范围内，新生代大小 $N$ 被视为一个正实数变量。\n\n为便于求最小值，我们可以先从 $J(N)$ 的表达式中提取出 $T(N)$：\n$$J(N) = \\left(\\alpha + \\frac{\\beta\\lambda}{N}\\right) T(N)$$\n现在，代入 $T(N)$ 的表达式：\n$$J(N) = \\left(\\alpha + \\frac{\\beta\\lambda}{N}\\right) (t_{r} + (c_{n} + c_{p}s)N)$$\n展开此表达式得到：\n$$J(N) = \\alpha t_{r} + \\alpha(c_{n} + c_{p}s)N + \\frac{\\beta \\lambda t_{r}}{N} + \\beta \\lambda (c_{n} + c_{p}s)$$\n为了找到使 $J(N)$ 最小化的 $N$ 值，我们使用微分学。最小化过程需要通过对 $J(N)$ 关于 $N$ 求导并令其等于零来找到 $J(N)$ 的临界点。\n$$\\frac{dJ}{dN} = \\frac{d}{dN} \\left[ \\alpha t_{r} + \\alpha(c_{n} + c_{p}s)N + \\beta \\lambda t_{r} N^{-1} + \\beta \\lambda(c_{n} + c_{p}s) \\right]$$\n项 $\\alpha t_{r}$ 和 $\\beta \\lambda(c_{n} + c_{p}s)$ 相对于 $N$ 是常数，因此它们的导数为 0。对包含 $N$ 的项应用幂函数求导法则：\n$$\\frac{dJ}{dN} = \\alpha(c_{n} + c_{p}s) - \\beta \\lambda t_{r} N^{-2}$$\n将此导数设为 0，以求得最优新生代大小，记为 $N^{\\star}$：\n$$\\alpha(c_{n} + c_{p}s) - \\frac{\\beta \\lambda t_{r}}{(N^{\\star})^2} = 0$$\n现在我们求解该方程以得到 $N^{\\star}$：\n$$\\alpha(c_{n} + c_{p}s) = \\frac{\\beta \\lambda t_{r}}{(N^{\\star})^2}$$\n$$(N^{\\star})^2 = \\frac{\\beta \\lambda t_{r}}{\\alpha(c_{n} + c_{p}s)}$$\n由于 $N$ 代表物理容量，它必须是一个正值。因此，我们取正平方根来求得 $N^{\\star}$：\n$$N^{\\star} = \\sqrt{\\frac{\\beta \\lambda t_{r}}{\\alpha(c_{n} + c_{p}s)}}$$\n为确认该临界点对应一个最小值，我们必须分析 $J(N)$ 的二阶导数：\n$$\\frac{d^2J}{dN^2} = \\frac{d}{dN} \\left( \\alpha(c_{n} + c_{p}s) - \\beta \\lambda t_{r} N^{-2} \\right)$$\n$$\\frac{d^2J}{dN^2} = -(-2) \\beta \\lambda t_{r} N^{-3} = \\frac{2 \\beta \\lambda t_{r}}{N^3}$$\n根据问题陈述，参数 $\\beta$、$\\lambda$ 和 $t_{r}$ 均为严格正数。新生代大小 $N$ 也必须为正。因此，对于所有 $N > 0$，二阶导数均为正：\n$$\\frac{d^2J}{dN^2} > 0$$\n正的二阶导数表明函数 $J(N)$ 在 $N > 0$ 上是严格凸的。因此，我们找到的临界点 $N^{\\star}$ 对应于一个唯一的全局最小值。", "answer": "$$\n\\boxed{\\sqrt{\\frac{\\beta \\lambda t_{r}}{\\alpha (c_{n} + c_{p}s)}}}\n$$", "id": "3643388"}, {"introduction": "为了避免“世界暂停”（stop-the-world）带来的性能瓶颈，现代垃圾收集器通常与应用程序并发执行。然而，并发带来了新的挑战：如果应用程序（mutator）在收集器遍历对象图时修改了指针，会发生什么？这个思想实验 [@problem_id:3643335] 揭示了一个经典的并发“丢失对象”问题，即一个可达对象可能被错误地回收。通过分析这个场景，你将理解为何需要“写入屏障”（write barrier）这一关键技术来保证并发GC的正确性，这是理解所有现代高性能GC设计的核心。", "problem": "考虑一个堆，它被建模为一个有向图 $G=(V,E)$，并有一个指定的根集 $R\\subseteq V$。一个对象 $x\\in V$ 是可达的，当且仅当存在一条从某个根 $r\\in R$ 到 $x$ 的路径，该路径由 $E$ 中的边组成。标记-清除垃圾回收（MSGC）的标记阶段会从 $R$ 开始执行图遍历以发现可达对象，而修改器（应用程序线程）在标记期间可能会继续执行指针更新。假设一个增量标记遍历，它在 $V$ 上维护三个颜色集合：白色（未标记）、灰色（已标记但尚未扫描）和黑色（已标记且已扫描）。在标记开始时，除了根对象被置为灰色外，所有对象都是白色的。扫描过程通过重复地取出一个灰色对象，访问其出边，并将其涂成黑色来进行。\n\n设初始堆如下。顶点集为 $V=\\{r,a,b,w\\}$，根集为 $R=\\{r\\}$。边集为 $E=\\{(r,a),(r,b),(a,w)\\}$。回收器从 $r$ 开始，将 $r$ 涂成黑色，并将 $a$ 和 $b$ 作为灰色对象入队。然后它接下来扫描 $b$，将 $b$ 涂成黑色。此时，$a$ 仍然是灰色的，$w$ 是白色的。\n\n下面的哪个选项既 (i) 给出了一个具体的修改器更新序列，该序列导致朴素的 MSGC（没有写屏障）错误地回收一个可达对象，又 (ii) 正确地指出了在这种并发标记下为保持可达性正确性所需的最小写屏障？\n\nA. 在 $b$ 变为黑色之后且在 $a$ 被扫描之前，修改器首先执行一次存储操作创建边 $(b,w)$，然后清除边 $(a,w)$。最小屏障是增量更新屏障，它在创建一个从黑色对象 $x$ 到白色对象 $y$ 的边 $(x,y)$ 的存储操作时，将 $y$ 涂成灰色。\n\nB. 在 $a$ 被扫描之前，修改器清除了边 $(a,w)$ 但不执行其他更新。最小屏障是起始快照删除屏障，它在覆盖任何指向白色目标 $y$ 的指针时，将 $y$ 涂成灰色。\n\nC. 在 $b$ 变为黑色之后且在 $a$ 被扫描之前，修改器执行一次存储操作创建边 $(b,w)$，但保持 $(a,w)$ 边完整，直到 $a$ 被扫描完成。最小屏障是读屏障，它在每次读取指针时将加载的目标涂成灰色。\n\nD. 在 $b$ 为灰色且在 $b$ 被扫描之前，修改器执行一次存储操作创建 $(b,w)$；随后，在 $b$ 变为黑色之后但在 $a$ 被扫描之前，修改器清除 $(a,w)$。最小屏障是选项 A 中描述的增量更新屏障。\n\nE. 在 $b$ 变为黑色之后且在 $a$ 被扫描之前，修改器首先执行一次存储操作创建边 $(b,w)$，然后清除边 $(a,w)$。最小屏障是起始快照删除屏障，它在覆盖白色目标的指针时，无论新值是什么，都将该白色目标涂成灰色。", "solution": "我们从基本原理出发进行分析。在具有根集 $R$ 的图 $G=(V,E)$ 中，可达性被定义为：存在一条从某个根 $r\\in R$ 到一个节点的、由 $E$ 中的边构成的有向路径。一个正确的 MSGC 必须确保在清除阶段之前，每个可达节点都已被标记，即使修改器在标记期间改变了 $E$。三色标记为每个节点分配三种颜色之一：白色（未见过）、灰色（已发现但尚未扫描）和黑色（已扫描）。遍历过程会扩展灰色节点，将其目标标记为灰色，并在其所有出边都被处理后将源节点涂成黑色。\n\n在存在修改器的情况下，如果没有进行任何协调，如果修改器对 $E$ 的更改导致遍历错过了某个可达的白色节点，那么回收器的遍历就可能失效。有两种成熟的屏障可以强制保证正确性：\n\n- 增量更新屏障（通常归功于 Edsger W. Dijkstra）：在创建一个从黑色对象 $x$ 指向白色对象 $y$ 的边 $(x,y)$ 的指针存储操作时，将 $y$ 涂成灰色。这强制执行了“没有黑色对象指向白色对象”的不变式，从而确保所有从黑色节点出发的边要么指向已标记的对象，要么立即强制进行标记。\n\n- 起始快照删除屏障（通常归功于 Atsushi Yuasa）：在覆盖一个指向白色目标 $y$ 的指针时，无论新值是什么，都将 $y$ 涂成灰色。这通过确保任何最初可达的白色对象不会在被发现之前因删除操作而被隐藏，从而保留了标记开始时堆的一个逻辑快照。\n\n我们分析给定的初始配置。最初，$R=\\{r\\}$，且 $E$ 包含 $(r,a)$、$(r,b)$ 和 $(a,w)$。回收器扫描 $r$ 后，将 $r$ 标记为黑色，并将 $a$ 和 $b$ 作为灰色对象入队。假设它接下来扫描 $b$ 并将 $b$ 标记为黑色。此时，$a$ 是灰色的，$w$ 是白色的。路径 $(r,b)$ 存在，路径 $(a,w)$ 也存在；在当前堆中，$w$ 通过路径 $(r,a),(a,w)$ 是可达的。\n\n我们现在逐一分析每个选项。\n\n选项 A：序列与屏障\n- 序列：在 $b$ 变为黑色之后且在 $a$ 被扫描之前，修改器首先创建边 $(b,w)$，然后清除边 $(a,w)$。\n- 无屏障时的效果：在创建 $(b,w)$ 的存储操作发生时，$b$ 是黑色的而 $w$ 是白色的。这引入了一条从黑到白的边，违反了“没有黑色对象指向白色对象”的属性。因为回收器不会重新扫描 $b$（它已经是黑色的），所以它不会通过 $(b,w)$ 发现 $w$。然后，在 $a$ 被扫描之前，修改器移除了 $(a,w)$。当 $a$ 最终被扫描时，它不再指向 $w$，因此 $w$ 保持白色。然而，$w$ 仍然通过 $(r,b)$ 紧跟着 $(b,w)$ 的路径是可达的，所以遍历错过了一个可达的白色节点。在清除阶段，$w$ 尽管可达，却会被错误地回收，这违反了正确性。\n- 屏障的正确性和最小性：增量更新屏障会在创建边 $(b,w)$（其中 $b$ 是黑色，$w$ 是白色）的存储操作上触发，并立即将 $w$ 涂成灰色。一旦 $w$ 变为灰色，无论之后 $(a,w)$ 是否被删除，它都将被发现并标记。对于这个序列来说，这个屏障是最小的，因为确切的风险在于创建了一条从黑到白的边；屏障恰好在该事件上起作用，而不在其他任何地方。删除屏障在 $(a,w)$ 被清除时（通过将 $w$ 涂灰）也能防止这种违规，但它会在每次覆盖指向白色目标的指针时触发，包括许多与此无关的情况。因此，对于这个序列，增量更新屏障是保持可达性正确性的最小屏障。结论 — 正确。\n\n选项 B：序列与屏障\n- 序列：在 $a$ 被扫描之前，修改器清除了边 $(a,w)$ 且不执行其他更新。\n- 无屏障时的效果：如果 $(a,w)$ 被移除且没有引入边 $(b,w)$，那么 $w$ 就失去了它从 $R$ 出发的唯一路径。在被修改后的堆中，$w$ 变得不可达。回收器在扫描 $a$ 时，找不到指向 $w$ 的边，所以 $w$ 保持白色，并在清除阶段被回收，这对于修改后的堆是正确的。没有正确性违规。\n- 屏障声明：该选项声称所需的最小屏障是删除屏障。然而，由于首先就没有发生违规，因此不需要任何屏障来保持正确性。结论 — 不正确。\n\n选项 C：序列与屏障\n- 序列：在 $b$ 变为黑色之后且在 $a$ 被扫描之前，修改器创建了边 $(b,w)$，但保持 $(a,w)$ 边完整直到 $a$ 被扫描完成。\n- 无屏障时的效果：因为 $(a,w)$ 一直保留到 $a$ 被扫描之后，回收器在扫描 $a$ 时将会标记 $w$，将其变为灰色，并最终变为黑色。额外的边 $(b,w)$ 不会危及正确性，因为 $w$ 将会通过 $a$ 被发现。\n- 屏障声明：该选项提出了一个读屏障，它在指针加载时触发，将加载的目标涂成灰色。在这个序列中，读屏障对于可达性正确性而言不是必需的；遍历已经可以通过扫描 $a$ 找到 $w$。结论 — 不正确。\n\n选项 D：序列与屏障\n- 序列：在 $b$ 为灰色且在 $b$ 被扫描之前，修改器创建了 $(b,w)$；随后，在 $b$ 变为黑色之后但在 $a$ 被扫描之前，修改器清除了 $(a,w)$。\n- 无屏障时的效果：在 $b$ 还是灰色时创建 $(b,w)$ 是安全的，因为 $b$ 将会被扫描，回收器会通过 $(b,w)$ 发现 $w$，并将其标记为灰色。之后，清除 $(a,w)$ 并不会隐藏 $w$，因为它已经因为扫描 $b$ 而被标记了。遍历仍然是正确的。\n- 屏障声明：尽管该选项指明了增量更新屏障，但该序列并不需要它来保证正确性，因为关键的存储操作发生在 $b$ 是灰色而不是黑色的时候。结论 — 不正确。\n\n选项 E：序列与屏障\n- 序列：这个序列与选项 A 相同：在 $b$ 变为黑色之后且在 $a$ 被扫描之前，修改器创建了 $(b,w)$，然后清除了 $(a,w)$。\n- 无屏障时的效果：与选项 A 一样，这个序列通过向遍历过程隐藏一个可达的白色节点而导致了正确性违规。\n- 屏障声明：该选项提出了一个起始快照删除屏障。这个屏障确实可以通过在 $(a,w)$ 被清除时将 $w$ 涂成灰色来保持正确性，从而确保即使 $(b,w)$ 较早被创建，$w$ 最终也会被标记。然而，相对于特定的风险（创建一条从黑到白的边），这个屏障并非最小的；它广泛地处理删除操作，而不是针对导致三色违规的精确插入操作。选项 A 中的增量更新屏障对于这个序列来说是一个目标更明确、更小的干预。结论 — 不正确。\n\n总结：只有选项 A 同时提出了一个破坏朴素并发 MSGC 的修改器更新序列，并指出了为该序列保持可达性正确性所需的最小写屏障。违规源于创建了一条从黑到白的边 $(b,w)$；通过增量更新屏障在该存储操作上将 $w$ 涂成灰色是恢复遍历正确性保证的最小修复方案。", "answer": "$$\\boxed{A}$$", "id": "3643335"}]}