{"hands_on_practices": [{"introduction": "类型推导系统的核心价值之一在于它能在编译阶段自动发现代码中的错误。本练习将通过一个包含不兼容分支的模式匹配表达式，向你展示类型推导如何将看似合理的代码转化为一组相互矛盾的类型约束。通过识别导致矛盾的最小约束集合，我们可以精确地定位错误的根源，这对于使用强类型语言的程序员来说是一项宝贵的问题排查技能。", "problem": "考虑一个带有不交和（disjoint sums）与模式匹配的、简单类型、传值调用（call-by-value）的函数式核心语言。基本类型为 $\\mathsf{int}$ 和 $\\mathsf{bool}$。不交和类型写作 $t_1 + t_2$，其规范构造子为 $\\text{Left}: t_1 \\to t_1 + t_2$ 和 $\\text{Right}: t_2 \\to t_1 + t_2$。模式匹配的形式为 $\\text{match}\\ e\\ \\text{with}\\ \\text{Left}\\ x \\to e_1\\ \\mid\\ \\text{Right}\\ y \\to e_2$。假设使用标准的和类型定型规则：如果 $e: t_1 + t_2$，则在左分支中 $x: t_1$，在右分支中 $y: t_2$，并且 $e_1$ 和 $e_2$ 必须具有相同的类型 $\\tau$，该类型也是整个匹配表达式的类型。整数加法运算符的类型为 $\\mathsf{int} \\times \\mathsf{int} \\to \\mathsf{int}$，一元布尔否定运算符的类型为 $\\mathsf{bool} \\to \\mathsf{bool}$。在应用任何合一（unification）或替换（substitution）之前，使用标准的 Hindley–Milner (HM) 类型推导的 W 算法，以类型表达式的等式形式生成约束。\n\n在上述假设下，分析项 $\\lambda v.\\ \\text{match}\\ v\\ \\text{with}\\ \\text{Left}\\ x \\to x + 1\\ \\mid\\ \\text{Right}\\ y \\to \\text{not}\\ y$。在不执行合一的情况下，通过应用语法导向的定型规则和运算符类型，生成原始类型等式约束集。然后，确定这些原始约束中最小不可满足子集（minimal unsatisfiable core）的基数。\n\n你的最终答案必须是这样一个最小不可满足子集大小的单个数字。无需四舍五入，不涉及单位。", "solution": "该问题要求在一个带有不交和与模式匹配的简单类型函数式语言中，分析一个给定的 $\\lambda$-项。任务是应用 Hindley-Milner 类型推导的原理，特别是 W 算法，来生成一组原始类型等式约束。随后，我们必须确定这些约束的最小不可满足子集（也称为最小不可满足核）的基数。\n\n要分析的项是 $E = \\lambda v.\\ \\text{match}\\ v\\ \\text{with}\\ \\text{Left}\\ x \\to x + 1\\ \\mid\\ \\text{Right}\\ y \\to \\text{not}\\ y$。\n\n我们通过对该项进行语法导向的遍历，为未知类型分配新的类型变量，并根据给定的定型规则生成约束。\n\n设 $\\tau_E$ 为整个表达式 $E$ 的类型。\n该表达式是一个 $\\lambda$-抽象。根据函数抽象的定型规则，其类型将是一个函数类型。设 $\\alpha_v$ 是为绑定变量 $v$ 分配的一个新类型变量，并设 $\\alpha_{body}$ 是为抽象体分配的一个新类型变量。$E$ 的类型则为 $\\tau_E = \\alpha_v \\to \\alpha_{body}$。这定义了最终的类型结构，但本身并不生成合一约束。\n\n抽象体是 `match` 表达式， $M = \\text{match}\\ v\\ \\text{with}\\ \\text{Left}\\ x \\to x + 1\\ \\mid\\ \\text{Right}\\ y \\to e_2$。该表达式的类型是 $\\alpha_{body}$。\n对不交和进行模式匹配的定型规则施加了几个约束：\n1.  被匹配的表达式（审查对象，scrutinee）$v$ 的类型，即 $\\alpha_v$，必须是一个和类型。我们引入两个新的类型变量 $\\alpha_L$ 和 $\\alpha_R$ 来表示和的左、右分量的类型。这给出了我们的第一个约束，它涉及一个类型构造子：\n    $$C_1: \\alpha_v = \\alpha_L + \\alpha_R$$\n2.  `match` 表达式的两个分支的求值结果必须是相同类型。设 $\\alpha_{e1}$ 是第一个分支表达式 $x + 1$ 的类型，$\\alpha_{e2}$ 是第二个分支表达式 $\\text{not}\\ y$ 的类型。这产生一个关键的等式约束：\n    $$C_2: \\alpha_{e1} = \\alpha_{e2}$$\n3.  整个 `match` 表达式的类型 $\\alpha_{body}$ 是其分支的共同类型。\n    $$C_3: \\alpha_{body} = \\alpha_{e1}$$\n\n接下来，我们分析分支表达式的类型以生成更多约束。\n在左分支 $\\text{Left}\\ x \\to x + 1$ 中，模式变量 $x$ 绑定到来自 `Left` 构造子的值。因此其类型为 $\\alpha_L$。表达式是 $x + 1$。整数加法运算符 ‘$+$’ 的声明类型为 $\\mathsf{int} \\times \\mathsf{int} \\to \\mathsf{int}$，这对应于柯里化（curried）的函数类型 $\\mathsf{int} \\to (\\mathsf{int} \\to \\mathsf{int})$。\n为了使应用 $(+) x$ 是类型正确的， $x$ 的类型，即 $\\alpha_L$，必须等于 ‘$+$’ 的参数类型，即 $\\mathsf{int}$。\n$$C_4: \\alpha_L = \\mathsf{int}$$\n$(+) x$ 的结果是一个类型为 $\\mathsf{int} \\to \\mathsf{int}$ 的函数。这个函数接着被应用于整数常量 $1$，其类型为 $\\mathsf{int}$。该应用是类型正确的，表达式 $x+1$ 的最终类型，即 $\\alpha_{e1}$，是返回类型 $\\mathsf{int}$。\n$$C_5: \\alpha_{e1} = \\mathsf{int}$$\n\n在右分支 $\\text{Right}\\ y \\to \\text{not}\\ y$ 中，模式变量 $y$ 的类型为 $\\alpha_R$。表达式是 $\\text{not}\\ y$。一元布尔否定运算符 'not' 的声明类型为 $\\mathsf{bool} \\to \\mathsf{bool}$。\n为了使应用 `not y` 是类型正确的， $y$ 的类型，即 $\\alpha_R$，必须等于 'not' 的参数类型，即 $\\mathsf{bool}$。\n$$C_6: \\alpha_R = \\mathsf{bool}$$\n此应用的结果类型为 $\\mathsf{bool}$。这就是表达式 $\\text{not}\\ y$ 的类型，即 $\\alpha_{e2}$。\n$$C_7: \\alpha_{e2} = \\mathsf{bool}$$\n\n我们现在已经生成了需要进行合一的完整原始等式约束集：\n$\\{ \\alpha_{e1} = \\alpha_{e2}, \\alpha_{body} = \\alpha_{e1}, \\alpha_L = \\mathsf{int}, \\alpha_{e1} = \\mathsf{int}, \\alpha_R = \\mathsf{bool}, \\alpha_{e2} = \\mathsf{bool} \\}$。\n类型系统现在会尝试找到一个替换（一个合一子），以同时满足所有这些等式。\n然而，这个集合是不可满足的。矛盾来自以下约束子集：\n- $C_2: \\alpha_{e1} = \\alpha_{e2}$ (两个分支的类型必须相同。)\n- $C_5: \\alpha_{e1} = \\mathsf{int}$ (第一个分支的类型被推断为 $\\mathsf{int}$。)\n- $C_7: \\alpha_{e2} = \\mathsf{bool}$ (第二个分支的类型被推断为 $\\mathsf{bool}$。)\n\n结合这三个约束导致等式 $\\mathsf{int} = \\mathsf{bool}$。由于 $\\mathsf{int}$ 和 $\\mathsf{bool}$ 是不同的、不可合一的基本类型，这构成了一个矛盾。该项是类型错误的（ill-typed）。\n\n问题要求的是这些原始约束中最小不可满足子集的基数。让我们考虑子集 $S_{core} = \\{ C_2, C_5, C_7 \\} = \\{ \\alpha_{e1} = \\alpha_{e2}, \\alpha_{e1} = \\mathsf{int}, \\alpha_{e2} = \\mathsf{bool} \\}$。我们已经确定 $S_{core}$ 是不可满足的。为了确认它是一个最小不可满足核 (minimal unsatisfiable core, MUC)，我们必须证明从中移除任何一个约束都会得到一个可满足的集合。\n\n1.  移除 $C_2$：集合 $\\{\\alpha_{e1} = \\mathsf{int}, \\alpha_{e2} = \\mathsf{bool}\\}$ 可由替换 $\\{\\alpha_{e1} \\mapsto \\mathsf{int}, \\alpha_{e2} \\mapsto \\mathsf{bool}\\}$ 满足。\n2.  移除 $C_5$：集合 $\\{\\alpha_{e1} = \\alpha_{e2}, \\alpha_{e2} = \\mathsf{bool}\\}$ 可由替换 $\\{\\alpha_{e1} \\mapsto \\mathsf{bool}, \\alpha_{e2} \\mapsto \\mathsf{bool}\\}$ 满足。\n3.  移除 $C_7$：集合 $\\{\\alpha_{e1} = \\alpha_{e2}, \\alpha_{e1} = \\mathsf{int}\\}$ 可由替换 $\\{\\alpha_{e1} \\mapsto \\mathsf{int}, \\alpha_{e2} \\mapsto \\mathsf{int}\\}$ 满足。\n\n由于每个大小为 2 的子集都是可满足的，所以 $S_{core}$ 是一个最小不可满足核。大小为 1 的不可满足核是不可能的，因为没有原始约束的形式是 $T_1 = T_2$（其中 $T_1, T_2$ 是不同的常量）。大小为 2 的不可满足核需要两个像 $\\{\\alpha = T_1, \\alpha = T_2\\}$ 这样的约束，而这在我们的生成集中没有直接出现。因此，一个 MUC 的大小不能小于 3。既然我们找到了一个大小为 3 的 MUC，这就是最小不可满足子集的大小。\n\n这个最小不可满足子集的基数是 $3$。", "answer": "$$\\boxed{3}$$", "id": "3624432"}, {"introduction": "理论学习的最终目的是应用于实践。为了真正内化类型推导的原理，最好的方法莫过于亲手实现它。这个练习将挑战你构建一个微型但功能完备的约束求解器。通过将类型域表示为集合，并将合一（unification）操作实现为集合的交集运算，你将对驱动现代类型推导系统的核心机制获得具体而深入的理解。", "problem": "设计并实现一个完整的、可运行的程序，通过求解简单类型lambda演算表达式 $\\lambda x.\\,\\lambda y.\\,(x == y)$ 的类型约束来执行基本类型推断，其中 $==$ 表示仅限于特定类型集合的内置相等运算符。程序必须使用编译器原理和程序设计语言理论中的以下基本概念：简单类型lambda演算、类型变量、类型环境以及通过对类型进行约束满足的合一。\n\n从以下核心定义和事实出发：\n- 类型环境将项变量与类型变量或具体类型关联起来。对于表达式 $\\lambda x.\\,\\lambda y.\\,(x == y)$，绑定符为 $x$ 和 $y$ 引入新的类型变量，记作 $\\alpha$ 和 $\\beta$。\n- 在简单类型lambda演算中，$==$ 的类型规则要求两个操作数具有相同的类型，并且该运算符返回一个布尔结果。运算符 $==$ 仅在一组指定的可接受类型上定义，我们将其表示为 $S$。\n- 类型约束的合一是通过求解类型之间的方程（例如，$\\alpha = \\beta$）以及域限制（例如，$\\alpha \\in S$, $\\beta \\in S$）来执行的，这需要使用集合论中对允许域的交集运算。\n\n在此任务中，$S$ 固定为 $S = \\{\\text{Int}, \\text{Bool}\\}$，并且只有当两个操作数都是来自 $S$ 的相同类型时，$==$ 的类型才是正确的。因此，表达式主体 $(x == y)$ 为 $x$ 和 $y$ 的操作数类型生成约束 $\\alpha = \\beta$、$\\alpha \\in S$ 和 $\\beta \\in S$。从第一性原理出发，求解这些约束可归结为计算 $\\alpha$ 和 $\\beta$ 的可接受域与 $S$ 的交集。如果交集为空，则在给定假设下，$(x == y)$ 没有有效的类型。如果交集非空，则交集中的每个元素都为 $x$ 和 $y$ 提供了有效的实例化，并且整个表达式的类型是正确的，其中 $==$ 产生一个布尔结果。\n\n你的程序必须为此场景实现一个小型约束求解器，其精确行为如下：\n- 使用整数代码表示类型：$0 \\mapsto \\text{Int}$，$1 \\mapsto \\text{Bool}$，$2 \\mapsto \\text{Float}$，以及 $3 \\mapsto \\text{Var}$，其中 $\\text{Var}$ 表示应用约束之前未约束的类型变量。只有 $\\text{Int}$ 和 $\\text{Bool}$ 对于 $==$ 是可接受的；包含 $\\text{Float}$ 仅用于测试失败场景。\n- 给定 $x$ 和 $y$ 的初始注解（每个注解为 $0$、$1$、$2$ 或 $3$ 中的一个），求解器必须：\n    1. 将 $3$（即 $\\text{Var}$）解释为具有域 $S$。\n    2. 将具体注解 $0$、$1$ 和 $2$ 分别解释为单例域 $\\{\\text{Int}\\}$、$\\{\\text{Bool}\\}$ 和 $\\{\\text{Float}\\}$。\n    3. 通过将 $x$ 和 $y$ 的域与 $S$ 求交集，然后再将所得结果域彼此求交集，来强制执行相等约束 $\\alpha = \\beta$ 和可接受性约束 $\\alpha \\in S$、$\\beta \\in S$。\n    4. 返回交集中可能的操作数类型代码列表，该列表仅限于 $S$。如果没有解，则返回空列表 $[]$。\n\n定义并运行以下参数值的测试套件。每个测试用例是一对 $(x\\_\\text{init}, y\\_\\text{init})$，其代码如上所述，旨在覆盖一般情况和边界条件：\n- 测试用例 1：$(3, 3)$，$x$ 和 $y$ 都是未约束的类型变量。\n- 测试用例 2：$(0, 3)$，$x$ 注解为 $\\text{Int}$，$y$ 未约束。\n- 测试用例 3：$(1, 1)$，$x$ 和 $y$ 都注解为 $\\text{Bool}$。\n- 测试用例 4：$(0, 1)$，$x$ 注解为 $\\text{Int}$，$y$ 注解为 $\\text{Bool}$。\n- 测试用例 5：$(2, 3)$，$x$ 注解为 $\\text{Float}$（不可接受），$y$ 未约束。\n\n你的程序应该生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个测试用例的结果本身也是一个用方括号括起来的、以逗号分隔的列表，包含与操作数类型解对应的可接受代码。例如，如果上述测试套件的计算解是这些，则一个有效的输出格式为 $[[0,1],[0],[1],[],[]]$。不涉及单位或角度。所有输出都是整数代码，空列表表示没有有效的解。\n\n程序必须是自包含的，不需要任何输入，并精确地为指定的测试套件打印聚合结果列表。求解器必须使用基于原则的类型域合一方法，在约束 $\\alpha = \\beta$、$\\alpha \\in S$ 和 $\\beta \\in S$ 下实现，并且除了测试用例参数和可接受集 $S$ 之外，不得依赖于硬编码的逐案结果。", "solution": "该问题要求设计并实现一个程序，为简单类型lambda演算表达式 $\\lambda x.\\,\\lambda y.\\,(x == y)$ 执行基本类型推断。这个任务属于编译器理论和程序设计语言语义学的范畴，具体聚焦于类型系统和基于约束的合一。问题的核心是求解一个从表达式结构及其运算符的类型规则派生出的类型约束系统。\n\n表达式是 $\\lambda x.\\,\\lambda y.\\,(x == y)$。在简单类型lambda演算中，此表达式定义了一个函数，它接受两个参数 $x$ 和 $y$，并比较它们是否相等。类型推断过程首先为lambda抽象引入的项变量分配新的类型变量。设 $x$ 的类型为 $\\alpha$，$y$ 的类型为 $\\beta$。类型环境 $\\Gamma$ 最初填充为 $\\Gamma = \\{x : \\alpha, y : \\beta\\}$。\n\n函数的主体是表达式 $(x == y)$。相等运算符 $==$ 的类型规则对其操作数的类型施加了约束。根据规定，该运算符要求两个操作数具有相同的类型，并且此类型必须属于一个预定义的可接受类型集合，记为 $S$。运算符本身被定义为返回一个 $\\text{Bool}$ 类型的结果。这些语义生成了以下约束集：\n1. 操作数类型相等：$\\alpha = \\beta$。\n2. 第一个操作数类型的可接受性：$\\alpha \\in S$。\n3. 第二个操作数类型的可接受性：$\\beta \\in S$。\n\n$==$ 运算符的可接受类型集合给定为 $S = \\{\\text{Int}, \\text{Bool}\\}$。问题要求我们使用整数代码来表示这些类型以及其他类型：$0 \\mapsto \\text{Int}$，$1 \\mapsto \\text{Bool}$，以及 $2 \\mapsto \\text{Float}$。代码 $3$ 表示一个未约束的类型变量，记为 $\\text{Var}$。使用这种编码，可接受集合 $S$ 对应于代码集合 $S_{code} = \\{0, 1\\}$。\n\n问题简化为针对 $\\alpha$ 和 $\\beta$ 的不同初始注解来求解这些约束。我们可以使用集合论来建模类型和约束。每个类型变量都与一个域相关联，该域是其可以实例化的可能具体类型的集合。然后通过集合交集来执行约束求解。\n\n设 $D_x$ 为 $x$ (类型为 $\\alpha$) 的可能类型的初始域， $D_y$ 为 $y$ (类型为 $\\beta$) 的初始域。这些初始域由提供的注解决定：\n- 对于具体类型注解（代码 $0, 1, 2$），域是一个单例集。例如，如果 $x$ 被注解为 $\\text{Int}$ (代码 $0$)，则 $D_x = \\{\\text{Int}\\} = \\{0\\}$。\n- 对于类型变量注解（代码 $3$），问题规定其域被解释为可接受集合 $S$。因此，如果 $x$ 被注解为 $\\text{Var}$，则 $D_x = S = \\{\\text{Int}, \\text{Bool}\\} = \\{0, 1\\}$。\n\n$x$ 和 $y$ 的可允许类型的整体解是同时满足所有三个约束的类型集合。约束 $\\alpha \\in S$ 和 $\\beta \\in S$ 将域 $D_x$ 和 $D_y$ 分别限制为 $D_x \\cap S_{code}$ 和 $D_y \\cap S_{code}$。相等约束 $\\alpha = \\beta$ 要求最终类型必须对两者都通用，这通过对它们受限的域求交集来实现。因此，有效解的最终域 $D_{sol}$ 为：\n$$ D_{sol} = (D_x \\cap S_{code}) \\cap (D_y \\cap S_{code}) $$\n根据集合交集的结合律和交换律，这等价于：\n$$ D_{sol} = D_x \\cap D_y \\cap S_{code} $$\n空集 $D_{sol} = \\emptyset$ 表示约束是不可满足的，对于给定的初始注解，表达式是类型错误的。\n\n我们现在将此过程应用于每个测试用例。\n\n**测试用例 1：** $(x_\\text{init}, y_\\text{init}) = (3, 3)$。$x$ 和 $y$ 都是未约束的变量 ($\\text{Var}$)。\n- $x$ 的初始域：$D_x = D(3) = \\{0, 1\\}$。\n- $y$ 的初始域：$D_y = D(3) = \\{0, 1\\}$。\n- 可接受集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{0, 1\\} \\cap \\{0, 1\\} \\cap \\{0, 1\\} = \\{0, 1\\}$。\n- 结果代码：$[0, 1]$。\n\n**测试用例 2：** $(x_\\text{init}, y_\\text{init}) = (0, 3)$。$x$ 是 $\\text{Int}$，$y$ 是 $\\text{Var}$。\n- $x$ 的初始域：$D_x = D(0) = \\{0\\}$。\n- $y$ 的初始域：$D_y = D(3) = \\{0, 1\\}$。\n- 可接受集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{0\\} \\cap \\{0, 1\\} \\cap \\{0, 1\\} = \\{0\\}$。\n- 结果代码：$[0]$。\n\n**测试用例 3：** $(x_\\text{init}, y_\\text{init}) = (1, 1)$。$x$ 和 $y$ 都是 $\\text{Bool}$。\n- $x$ 的初始域：$D_x = D(1) = \\{1\\}$。\n- $y$ 的初始域：$D_y = D(1) = \\{1\\}$。\n- 可接受集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{1\\} \\cap \\{1\\} \\cap \\{0, 1\\} = \\{1\\}$。\n- 结果代码：$[1]$。\n\n**测试用例 4：** $(x_\\text{init}, y_\\text{init}) = (0, 1)$。$x$ 是 $\\text{Int}$，$y$ 是 $\\text{Bool}$。\n- $x$ 的初始域：$D_x = D(0) = \\{0\\}$。\n- $y$ 的初始域：$D_y = D(1) = \\{1\\}$。\n- 可接受集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{0\\} \\cap \\{1\\} \\cap \\{0, 1\\} = \\emptyset$。\n- 结果代码：$[]$。\n\n**测试用例 5：** $(x_\\text{init}, y_\\text{init}) = (2, 3)$。$x$ 是 $\\text{Float}$，$y$ 是 $\\text{Var}$。\n- $x$ 的初始域：$D_x = D(2) = \\{2\\}$。\n- $y$ 的初始域：$D_y = D(3) = \\{0, 1\\}$。\n- 可接受集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{2\\} \\cap \\{0, 1\\} \\cap \\{0, 1\\} = \\emptyset$。$\\{2\\}$ 与 $\\{0, 1\\}$ 中任意一个的交集都是空集。\n- 结果代码：$[]$。\n\n程序将实现这种基于集合的逻辑。域将表示为布尔标志数组，交集将通过对这些数组进行逻辑与操作来实现。最终输出将所有测试用例的结果聚合成指定的格式。", "answer": "[[0,1],[0],[1],[],[]]", "id": "3624368"}]}