{"hands_on_practices": [{"introduction": "要真正掌握 Cheney 算法，最好的方法莫过于亲手模拟其执行过程。本练习 ([@problem_id:3634280]) 将引导你扮演垃圾收集器的角色，在一个小规模的对象图上，通过追踪 `scan` 和 `alloc` 指针的移动，来精确地确定每个存活对象的最终内存地址。通过这个实践，你将牢固掌握 Cheney 算法标志性的广度优先遍历机制，并理解对象是如何在“to-space”中被紧凑排列的。", "problem": "一个使用 Cheney 算法的复制式垃圾回收器在两个半空间（semispace）中操作，将所有存活对象从 from-space 移动到 to-space，并以广度优先搜索 (BFS) 的顺序扫描新复制的对象。假设以下基本事实和定义：Cheney 算法维护一个 to-space 分配指针，该指针在复制对象时线性增加；它还维护一个扫描指针，该指针按对象顺序遍历 to-space，每个对象的指针字段仅访问一次。所有对象在内存中是连续的。每个对象都有一个大小为 $8$ 字节的头部，其中包括一个类型标签和一个在复制期间用作转发槽的字。每个指针字段和每个整数字段都占用 $8$ 字节。所有对象地址必须按 $8$ 字节对齐。如果对象大小不是 $8$ 字节的倍数，则向上取整到下一个 $8$ 的倍数。除了对齐要求外，对象之间不插入任何填充。\n\nTo-space 从基地址 $0$ 字节开始。根集合按从左到右的顺序包含两个引用：首先是对象 $X$，然后是对象 $W$。根的复制按此顺序执行。复制根之后，扫描指针从 to-space 的起始位置开始，并按对象顺序进行。对象及其布局如下，指针字段按其被扫描的精确顺序列出；非指针字段包含在有效载荷中，但在扫描期间不被遍历：\n\n- 对象 $X$ 有两个指针字段 $p_1, p_2$，后跟一个整数字段。对齐前总大小：头部 $8$ 字节，指针 $2 \\times 8$ 字节，整数 $1 \\times 8$ 字节。\n- 对象 $W$ 有一个指针字段 $q_1$，没有整数字段。对齐前总大小：头部 $8$ 字节，指针 $1 \\times 8$ 字节。\n- 对象 $Y$ 有一个指针字段 $r_1$，后跟两个整数字段。对齐前总大小：头部 $8$ 字节，指针 $1 \\times 8$ 字节，整数 $2 \\times 8$ 字节。\n- 对象 $Z$ 没有指针字段，有三个整数字段。对齐前总大小：头部 $8$ 字节，整数 $3 \\times 8$ 字节。\n- 对象 $V$ 有两个指针字段 $s_1, s_2$，没有整数字段。对齐前总大小：头部 $8$ 字节，指针 $2 \\times 8$ 字节。\n\n这些对象在 from-space 中的指针关系如下：\n- $X.p_1 \\rightarrow Y$, $X.p_2 \\rightarrow Z$.\n- $W.q_1 \\rightarrow V$.\n- $Y.r_1 \\rightarrow V$.\n- $Z$ 没有指针。\n- $V.s_1 \\rightarrow X$, $V.s_2 \\rightarrow Z$.\n\n假设所有对象都能放入 to-space 而不会耗尽空间。Cheney 算法在第一次遇到被引用的对象时复制它；后续遇到时，通过其转发信息将指针更新为该对象在 to-space 中的地址。在根 $X$ 和 $W$ 按根顺序复制后，扫描指针按 to-space 中的对象顺序访问对象。\n\n在这些假设下，计算对象 $X, W, Y, Z, V$ 的最终 to-space 字节偏移量（地址），表示为相对于 to-space 基地址 $0$ 的值。请以行矩阵 $\\big(\\mathrm{addr}(X), \\mathrm{addr}(W), \\mathrm{addr}(Y), \\mathrm{addr}(Z), \\mathrm{addr}(V)\\big)$ 的形式提供答案。无需取整。", "solution": "问题陈述已经过验证，被认为是合理、自洽且定义明确的。它描述了 Cheney 垃圾回收算法的确定性模拟，这是计算机科学中的一个标准课题，并提供了所有必要的参数。因此，我们可以着手解决。\n\n解决方案涉及逐步模拟 Cheney 算法的执行过程。回收器的状态由两个指向 to-space 的指针定义：一个 `scan` 指针和一个 `alloc` 指针。To-space 从字节偏移量 $0$ 开始。初始时，`scan` 和 `alloc` 指针都设置为 $0$。\n\n首先，我们确定每个对象在内存中的大小。所有对象都必须按 $8$ 字节边界对齐，如果需要，其大小将向上取整到下一个 $8$ 的倍数。每个字段（头部、指针、整数）的大小都给定为 $8$ 字节。\n\n大小计算如下：\n- 对象 $X$：$1$ 个头部，$2$ 个指针字段，$1$ 个整数字段。大小 = $(1+2+1) \\times 8 = 32$ 字节。\n- 对象 $W$：$1$ 个头部，$1$ 个指针字段。大小 = $(1+1) \\times 8 = 16$ 字节。\n- 对象 $Y$：$1$ 个头部，$1$ 个指针字段，$2$ 个整数字段。大小 = $(1+1+2) \\times 8 = 32$ 字节。\n- 对象 $Z$：$1$ 个头部，$3$ 个整数字段。大小 = $(1+3) \\times 8 = 32$ 字节。\n- 对象 $V$：$1$ 个头部，$2$ 个指针字段。大小 = $(1+2) \\times 8 = 24$ 字节。\n\n所有计算出的大小都已经是 $8$ 的倍数，因此不需要额外的填充来对齐。\n\n该算法分两个主要阶段进行：复制根集合，然后扫描 to-space 中的对象。\n\n**阶段 1：复制根集合**\n根集合按指定顺序处理：首先是对象 $X$ 的引用，然后是对象 $W$ 的引用。\n\n1.  **处理根 $X$**：\n    - `alloc` 指针位于 $0$。对象 $X$ 被复制到 to-space 的地址 $0$。因此其新地址为 $\\mathrm{addr}(X) = 0$。\n    - 一个指向地址 $0$ 的转发指针被存储在 from-space 中原始对象 $X$ 的头部。\n    - `alloc` 指针按 $X$ 的大小向前移动：$\\mathrm{alloc} = 0 + 32 = 32$。\n    - 当前状态：$\\mathrm{scan}=0$, $\\mathrm{alloc}=32$。\n\n2.  **处理根 $W$**：\n    - `alloc` 指针位于 $32$。对象 $W$ 被复制到地址 $32$。其新地址为 $\\mathrm{addr}(W) = 32$。\n    - 一个指向地址 $32$ 的转发指针被存储在原始对象 $W$ 的头部。\n    - `alloc` 指针按 $W$ 的大小向前移动：$\\mathrm{alloc} = 32 + 16 = 48$。\n    - 当前状态：$\\mathrm{scan}=0$, $\\mathrm{alloc}=48$。\n\n**阶段 2：扫描 to-space 中的对象**\n算法现在进入一个循环，从 `scan` 指针开始扫描对象，直到 `alloc` 指针。只要 $\\mathrm{scan}  \\mathrm{alloc}$，循环就会继续。\n\n1.  **扫描地址 $0$ 处的对象（对象 $X$）**：\n    - `scan` 指针位于 $0$。此地址处的对象是 $X$ 的新副本。\n    - 其指针字段按顺序扫描：$p_1, p_2$。根据问题描述，$X.p_1 \\rightarrow Y$ 且 $X.p_2 \\rightarrow Z$。\n    - **扫描 $p_1$ (指向 $Y$)**：对象 $Y$ 尚未被复制。\n        - $Y$ 被复制到 `alloc` 指针给出的地址，即 $48$。所以，$\\mathrm{addr}(Y) = 48$。\n        - `alloc` 指针按 $Y$ 的大小向前移动：$\\mathrm{alloc} = 48 + 32 = 80$。\n        - 新对象 $X$ 中的字段 $p_1$ 被更新为指向 $48$。\n    - **扫描 $p_2$ (指向 $Z$)**：对象 $Z$ 尚未被复制。\n        - $Z$ 被复制到当前的 `alloc` 地址 $80$。所以，$\\mathrm{addr}(Z) = 80$。\n        - `alloc` 指针按 $Z$ 的大小向前移动：$\\mathrm{alloc} = 80 + 32 = 112$。\n        - 新对象 $X$ 中的字段 $p_2$ 被更新为指向 $80$。\n    - 对象 $X$ 的扫描完成。`scan` 指针按 $X$ 的大小向前移动：$\\mathrm{scan} = 0 + 32 = 32$。\n    - 当前状态：$\\mathrm{scan}=32$, $\\mathrm{alloc}=112$。条件 $\\mathrm{scan}  \\mathrm{alloc}$ ($32  112$) 为真。\n\n2.  **扫描地址 $32$ 处的对象（对象 $W$）**：\n    - `scan` 指针位于 $32$。该对象是 $W$ 的新副本。\n    - 其指针字段 $q_1$ 被扫描。$W.q_1 \\rightarrow V$。\n    - **扫描 $q_1$ (指向 $V$)**：对象 $V$ 尚未被复制。\n        - $V$ 被复制到当前的 `alloc` 地址 $112$。所以，$\\mathrm{addr}(V) = 112$。\n        - `alloc` 指针按 $V$ 的大小向前移动：$\\mathrm{alloc} = 112 + 24 = 136$。\n        - 新对象 $W$ 中的字段 $q_1$ 被更新为指向 $112$。\n    - 对象 $W$ 的扫描完成。`scan` 指针按 $W$ 的大小向前移动：$\\mathrm{scan} = 32 + 16 = 48$。\n    - 当前状态：$\\mathrm{scan}=48$, $\\mathrm{alloc}=136$。条件 $\\mathrm{scan}  \\mathrm{alloc}$ ($48  136$) 为真。\n\n3.  **扫描地址 $48$ 处的对象（对象 $Y$）**：\n    - `scan` 指针位于 $48$。该对象是 $Y$ 的新副本。\n    - 其指针字段 $r_1$ 被扫描。$Y.r_1 \\rightarrow V$。\n    - **扫描 $r_1$ (指向 $V$)**：对象 $V$ 已经被复制。其转发指针指示其新地址为 $112$。\n        - 新对象 $Y$ 中的字段 $r_1$ 被更新为指向 $112$。没有新对象被复制，`alloc` 保持不变。\n    - 对象 $Y$ 的扫描完成。`scan` 指针按 $Y$ 的大小向前移动：$\\mathrm{scan} = 48 + 32 = 80$。\n    - 当前状态：$\\mathrm{scan}=80$, $\\mathrm{alloc}=136$。条件 $\\mathrm{scan}  \\mathrm{alloc}$ ($80  136$) 为真。\n\n4.  **扫描地址 $80$ 处的对象（对象 $Z$）**：\n    - `scan` 指针位于 $80$。该对象是 $Z$ 的新副本。\n    - 对象 $Z$ 没有指针字段需要扫描。\n    - 对象 $Z$ 的扫描完成。`scan` 指针按 $Z$ 的大小向前移动：$\\mathrm{scan} = 80 + 32 = 112$。\n    - 当前状态：$\\mathrm{scan}=112$, $\\mathrm{alloc}=136$。条件 $\\mathrm{scan}  \\mathrm{alloc}$ ($112  136$) 为真。\n\n5.  **扫描地址 $112$ 处的对象（对象 $V$）**：\n    - `scan` 指针位于 $112$。该对象是 $V$ 的新副本。\n    - 其指针字段按顺序扫描：$s_1, s_2$。$V.s_1 \\rightarrow X$ 且 $V.s_2 \\rightarrow Z$。\n    - **扫描 $s_1$ (指向 $X$)**：对象 $X$ 已被复制。其转发地址是 $0$。字段 $s_1$ 被更新为 $0$。\n    - **扫描 $s_2$ (指向 $Z$)**：对象 $Z$ 已被复制。其转发地址是 $80$。字段 $s_2$ 被更新为 $80$。\n    - 对象 $V$ 的扫描完成。`scan` 指针按 $V$ 的大小向前移动：$\\mathrm{scan} = 112 + 24 = 136$。\n    - 当前状态：$\\mathrm{scan}=136$, $\\mathrm{alloc}=136$。\n\n循环条件 $\\mathrm{scan}  \\mathrm{alloc}$ ($136  136$) 现在为假。回收过程终止。\n\n最终的 to-space 字节偏移量是每个对象被复制时分配的地址：\n- $\\mathrm{addr}(X) = 0$\n- $\\mathrm{addr}(W) = 32$\n- $\\mathrm{addr}(Y) = 48$\n- $\\mathrm{addr}(Z) = 80$\n- $\\mathrm{addr}(V) = 112$\n\n要求的答案是这些地址按 $(X, W, Y, Z, V)$ 顺序排列的行矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  32  48  80  112\n\\end{pmatrix}\n}\n$$", "id": "3634280"}, {"introduction": "掌握了基本遍历过程后，一个关键问题是：Cheney 算法如何优雅地处理循环引用等复杂情况，而不会陷入无限循环？本练习 ([@problem_id:3634295]) 聚焦于一个包含自引用的对象，要求你分析并确定算法能够确保每个对象只被复制一次的核心机制。这个练习将加深你对“转发指针”（forwarding pointer）这一关键设计的理解，它既是对象已被移动的标记，也指明了其新地址。", "problem": "在一个实现 Cheney 算法的复制式垃圾回收器中，堆被划分为两个大小相等的半空间，称为 $from$ 和 $to$。在回收期间，所有可达对象都从 $from$ 空间复制（疏散）到 $to$ 空间，回收器在 $to$ 空间中使用两个指针：一个 $scan$ 指针，用于遍历对象以传递性地处理它们的字段；以及一个 $free$ 指针，用于标记 $to$ 空间中的下一个空闲位置。在此设置下，广度优先复制的一个基本不变量是：在任何时候，根集合中以及已复制对象中的每个指针，要么指向 $to$ 空间中的一个对象，要么指向一个已被赋予确定转发地址的 $from$ 空间对象。\n\n考虑 $from$ 空间中的一个对象 $x$，它有一个指针字段 $f$，满足 $x.f = x$（即 $x$ 是自引用的），并且有一个指向 $x$ 的单一根 $\\rho$。回收器开始时，$scan = free =$ $to$ 空间的起始位置。假设对象复制由一个过程执行，该过程给定一个指向 $from$ 空间的指针 $p$，必须确保在 $to$ 空间中只创建目标对象的一个副本，并且根和 $to$ 空间中的所有字段都被更新以指向这个唯一的副本。\n\n哪个选项根据 Cheney 算法的基本原理和不变量，正确解释了该算法如何处理这种自引用，从而确保只创建一个 $x$ 的副本，并且不会发生无限复制或无界递归？\n\nA. 当通过 $\\rho$ 首次遇到 $x$ 时，回收器在 $free$ 位置分配一个新副本 $x'$，立即在 $x$ 的头部写入一个转发指针，将 $x \\mapsto x'$，将 $\\rho$ 更新为 $x'$，并前移 $free$。之后，当扫描 $x'$ 并看到字段值等于 $x$ 在 $from$ 空间中的旧地址时，回收器检查 $x$ 的头部，找到转发指针，并将该字段更新为 $x'$，而无需分配第二个副本。这种先检查后安装的策略维持了不变量，即每个被疏散的 $from$ 空间对象在它的任何引用被遍历之前，都有一个确定的转发地址。\n\nB. 当通过 $\\rho$ 首次遇到 $x$ 时，回收器在 $x$ 仍位于 $from$ 空间时扫描其所有字段，递归地复制任何引用的对象，并且只有在处理完所有字段后，才分配 $x'$ 并在 $x$ 的头部写入转发指针。对于自引用，这意味着递归返回相同的 $x'$，但延迟安装仍然保证 $to$ 空间中最多只有一个副本。\n\nC. Cheney 算法要求在每个 $from$ 空间对象中有一个单独的已访问标记位以避免多次复制。有了标记位，算法可以将安装转发指针延迟到扫描字段之后，因为标记可以防止自引用触发另一次复制。\n\nD. 当回收器将 $x$ 复制到 $x'$ 时，它将 $x'.f$ 初始化为直接指向 $x'$，而不是复制旧的指针值。结果是，当扫描 $x'$ 时，它的字段已经指向 $to$ 空间，不需要检查，也不会发生额外的复制，即使没有在 $x$ 中安装转发指针。", "solution": "问题陈述描述了一个涉及实现 Cheney 算法的复制式垃圾回收器的场景，这是一种经典的广度优先回收技术。问题在于解释该算法如何正确处理自引用对象，而不会进入无限循环或创建重复的副本。\n\n### 第一步：提取已知条件\n- **堆结构**：堆被划分为两个半空间，`$from$` 和 `$to$`。\n- **回收器指针**：两个指针管理 `$to$` 空间：`$scan$` 和 `$free$`。\n- **初始状态**：`$scan = free = to$ 空间的起始位置。\n- **对象状态**：一个对象 `$x$` 存在于 `$from$` 空间中。\n- **对象结构**：`$x$` 有一个指针字段 `$f$`，满足 `$x.f = x$`。\n- **根集合**：一个单一的根 `$\\rho$` 指向 `$x$`。\n- **算法目标**：将所有可达对象从 `$from$` 复制到 `$to$`，确保每个可达对象只创建一个副本。\n- **核心不变量**：“在任何时候，根集合中以及已复制对象中的每个指针，要么指向 `$to$` 空间中的一个对象，要么指向一个已被赋予确定转发地址的 `$from$` 空间对象。”\n\n### 第二步：使用提取的已知条件进行验证\n问题陈述是科学合理的、定义明确的且客观的。它准确地描述了 Cheney 算法的基本组成部分（半空间、$scan$/$free$ 指针、转发指针），并提出了一个标准的、非平凡的测试用例（自引用对象）。问题要求在此背景下解释算法的核心机制。所提供的不变量是该算法的一个关键属性。没有矛盾、信息缺失或伪科学的主张。该问题是有效的。\n\n### 第三步：从第一性原理推导\nCheney 算法是对对象图的广度优先遍历。$to$ 空间中位于 $scan$ 和 $free$ 指针之间的区域，充当一个队列，用于存放已复制但其内部指针尚未被处理（或“扫描”）的对象。\n\n让我们针对给定场景追踪执行过程：\n1.  **初始化**：回收器从一个空的 `$to$` 空间开始。`$scan$` 和 `$free$` 指针都位于 `$to$` 的起始位置。根集合包含 `$\\rho$`，它指向 `$from$` 空间中某个地址 `$addr(x)$` 处的对象 `$x$`。\n\n2.  **根处理**：回收器检查根 `$\\rho$`。它看到一个指向 `$from$` 空间中 `$x$` 的指针。它必须复制 `$x$`。为此，它调用一个辅助过程，我们称之为 `copy_and_forward(p)`。\n\n3.  **`copy_and_forward(addr(x))` 的首次调用**：\n    a. 该过程首先检查位于 `$addr(x)$` 的对象是否已经被复制。这是通过检查 `$x$` 的头部来完成的。在标准的 Cheney 实现中，没有单独的标记位；用于存储转发指针的空间被利用起来。如果这个空间包含一个指向 `$to$` 空间的指针，则表示该对象已被移动。初始时，情况并非如此。\n    b. 由于 `$x$` 尚未被复制，算法在 `$free$` 指针所指向的 `$to$` 空间地址处分配一个新对象 `$x'$`。\n    c. `$x$` 的内容被逐位复制到 `$x'$` 中。此时，字段 `$x'.f` 包含旧地址 `$addr(x)$`，该地址指向 `$from$` 空间。\n    d. `$free$` 指针按 `$x$` 的大小前移：`free = free + size_of(x)`。\n    e. **至关重要的是**，一个**转发指针**会立即被安装在原始对象 `$x$` 的头部。这个指针是 `$x'$` 的新地址，即 `$addr(x')$`。这一步在某种意义上是原子的，因为它发生在与 `$x$` 相关的任何其他处理之前。旧对象 `$x$` 现在被视为已疏散。\n    f. 该过程返回新地址 `$addr(x')$`。\n\n4.  **根更新**：回收器用返回的地址更新根指针 `$\\rho$`：`$\\rho = addr(x')$`。现在根指向 `$to$` 空间。\n\n5.  **主回收循环**：回收器进入其主循环：`while (scan  free)`。\n    a. 初始时，`$scan$` 位于 `$to$` 的起始处，而 `$free$` 位于 `$scan + size_of(x)$`，因此条件为真。位于 `$scan$` 处的对象是 `$x'$`。\n    b. 回收器现在“扫描”`$x'$`，处理其指针字段。它找到字段 `$f$`，该字段当前持有 `$addr(x)$`（指向 `$from$` 空间中原始对象的指针）。\n    c. 为了更新这个字段，回收器再次调用 `copy_and_forward(addr(x))`。\n\n6.  **`copy_and_forward(addr(x))` 的第二次调用**：\n    a. 该过程检查 `$from$` 空间中地址 `$addr(x)$` 处对象的头部。\n    b. 这一次，它找到了在步骤 3e 中安装的**转发指针**。这个指针是 `$addr(x')$`。\n    c. 识别出这是一个转发地址（因为它指向 `$to$` 空间），该过程**不会**创建新的副本。它只是简单地返回在转发指针中找到的地址：`$addr(x')$`。\n\n7.  **字段更新**：主循环接收到 `$addr(x')$` 并更新正在扫描的对象中的字段：`$x'.f = addr(x')$`。自引用现在已在 `$to$` 空间中正确建立。\n\n8.  **循环推进**：扫描完 `$x'$` 的所有字段后，`$scan$` 指针前移越过 `$x'$`：`$scan = scan + size_of(x')$`。现在，`$scan = free$`。\n\n9.  **终止**：循环条件 `scan  free` 现在为假。回收完成。`$x$` 只创建了一个副本，并且由于立即安装并随后检查转发指针，自引用被正确处理，没有发生无限递归。\n\n### 逐项分析选项\n\n**A. 当通过 $\\rho$ 首次遇到 $x$ 时，回收器在 $free$ 位置分配一个新副本 $x'$，立即在 $x$ 的头部写入一个转发指针，将 $x \\mapsto x'$，将 $\\rho$ 更新为 $x'$，并前移 $free$。之后，当扫描 $x'$ 并看到字段值等于 $x$ 在 $from$ 空间中的旧地址时，回收器检查 $x$ 的头部，找到转发指针，并将该字段更新为 $x'$，而无需分配第二个副本。这种先检查后安装的策略维持了不变量，即每个被疏散的 $from$ 空间对象在它的任何引用被遍历之前，都有一个确定的转发地址。**\n\n该选项与从第一性原理进行的逐步推导完全匹配。它正确地指出了关键的顺序：（1）分配副本，（2）**立即**在原始对象中安装转发指针，（3）更新引用（在此例中是 `$\\rho$`），（4）之后，在扫描副本时，使用转发指针来解析内部字段。这正是 Cheney 算法处理共享和循环结构的精髓。措辞“先检查后安装”可以解释为“检查是否已转发，如果未转发，则安装”，这是正确的。最后一句正确地指出，转发地址是在对象*内部*的引用被遍历（扫描）*之前*安装的。\n\n结论：**正确**。\n\n**B. 当通过 $\\rho$ 首次遇到 $x$ 时，回收器在 $x$ 仍位于 $from$ 空间时扫描其所有字段，递归地复制任何引用的对象，并且只有在处理完所有字段后，才分配 $x'$ 并在 $x$ 的头部写入转发指针。对于自引用，这意味着递归返回相同的 $x'$，但延迟安装仍然保证 $to$ 空间中最多只有一个副本。**\n\n这描述的是深度优先遍历，这是 Cheney 算法之外的其他回收器的特征。Cheney 算法明确是广度优先的，使用 `$scan$` 和 `$free$` 指针来管理一个队列。此外，对于自引用对象 `$x.f = x$`，在将对象标记为已访问（例如，通过安装转发指针）*之前*尝试递归处理字段，将导致无限递归调用：`copy(x)` 会调用 `copy(x.f)`，也就是再次调用 `copy(x)`。该选项为此案例描述了一个无法工作的算法，并错误地陈述了 Cheney 的广度优先方法。\n\n结论：**不正确**。\n\n**C. Cheney 算法要求在每个 $from$ 空间对象中有一个单独的已访问标记位以避免多次复制。有了标记位，算法可以将安装转发指针延迟到扫描字段之后，因为标记可以防止自引用触发另一次复制。**\n\n这在事实上是不正确的。Cheney 算法的一个主要优点和定义性特征是，它**不**需要在每个对象上设置一个额外的标记位。转发指针本身起到了标记对象为已访问和提供其新位置的双重作用。检查很简单：如果指定的头部字包含一个指向 `$to$` 空间的指针，则对象已被移动；否则，未被移动。该选项的前提是错误的。\n\n结论：**不正确**。\n\n**D. 当回收器将 $x$ 复制到 $x'$ 时，它将 $x'.f$ 初始化为直接指向 $x'$，而不是复制旧的指针值。结果是，当扫描 $x'$ 时，它的字段已经指向 $to$ 空间，不需要检查，也不会发生额外的复制，即使没有在 $x$ 中安装转发指针。**\n\n这不正确，主要有两个原因。首先，为了效率，初始复制操作通常是盲目的块内存复制。该算法没有也不需要特殊情况逻辑来在初始复制期间检测自引用。稍后扫描字段的通用机制统一处理所有指针的修正。其次，更关键的是，它声称这“即使没有在 `$x$` 中安装转发指针”也能工作。转发指针对于正确性是绝对必要的。如果另一个对象 `$y$` 也指向 `$x$`，在 `$x$` 中没有转发指针的情况下，处理来自 `$y$` 的引用将导致 `$x$` 的第二个冗余副本，这违反了复制式回收器的核心要求。\n\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "3634295"}, {"introduction": "垃圾收集器的职责不仅在于正确回收内存，其性能表现也至关重要。它所产生的内存布局会直接影响应用程序后续执行的效率，尤其是数据访问的局部性。这个高级练习 ([@problem_id:3634309]) 让你超越简单的算法追踪，通过对比 Cheney 算法（广度优先）和另一种深度优先复制策略所产生的内存布局，来量化分析不同布局对后续图遍历性能的影响。这项实践将算法的内部机制与其对系统性能的实际影响联系起来，揭示了算法设计选择的深远意义。", "problem": "考虑一个有向无环图 (DAG)，其堆分配的对象命名为 $A$、$B$、$C$、$D$、$E$、$F$、$G$ 和 $H$。根集合由两个按固定顺序 $[r_1, r_2]$ 排列的根组成，其中 $r_1$ 引用 $A$，$r_2$ 引用 $B$。每个对象包含按固定的从左到右顺序扫描的指针字段。指针结构如下：\n- $A$ 指向 $C$ 和 $D$。\n- $B$ 指向 $D$ 和 $E$。\n- $C$ 指向 $F$。\n- $D$ 指向 $F$ 和 $G$。\n- $E$ 指向 $H$。\n- $F$ 指向 $H$。\n- $G$ 和 $H$ 没有出指针。\n\n假设一个使用 Cheney 算法的双空间复制式垃圾收集器 (GC)。双空间复制使用一个连续的分配指针在“to-space”（目标空间）中进行分配；Cheney 算法通过一个扫描指针驱动，执行广度优先搜索 (BFS) 扫描，无需递归或显式栈，并在首次复制时建立转发指针。假设“to-space”的基地址为 $A_0 = 0$ 字，按字对齐，各对象的大小（单位：字）如下：\n- $|A| = 3$, $|B| = 4$, $|C| = 2$, $|D| = 5$, $|E| = 2$, $|F| = 3$, $|G| = 1$, $|H| = 2$。\n\n任务第 1 部分：精确模拟 Cheney 算法，以确定确切的 BFS 放置顺序以及每个对象在“to-space”中的地址。根集合按顺序 $[r_1, r_2]$ 扫描，在每个对象内部，字段按从左到右的顺序扫描。\n\n任务第 2 部分：考虑一个后续的图处理算法，该算法对每条有向边迭代一次，按源对象字段的顺序访问邻接表。将每条边的遍历成本建模为由复制布局引起的内存局部性的函数。设分配给对象 $X$ 的地址为 $\\operatorname{addr}(X)$，定义每条有向边 $(X \\to Y)$ 的成本为\n$$\nc_{\\text{edge}}(X \\to Y) = \\begin{cases}\nc_{\\text{near}},  |\\operatorname{addr}(Y) - \\operatorname{addr}(X)| \\leq d, \\\\\nc_{\\text{far}},  |\\operatorname{addr}(Y) - \\operatorname{addr}(X)|  d,\n\\end{cases}\n$$\n其中 $d = 8$，$c_{\\text{near}} = 1$，$c_{\\text{far}} = 3$。\n\n计算由第 1 部分中的 Cheney (BFS) 布局产生的总遍历成本 $T_{\\text{BFS}}$。\n\n任务第 3 部分：作为对比，定义一个由标准递归深度优先搜索 (DFS) 产生的替代性深度优先复制布局，从相同的根顺序 $[r_1, r_2]$ 开始，并按从左到右的顺序扫描字段。在这种 DFS 布局中，每个新发现的对象都会被立即复制，并且其字段在返回前被递归处理。计算此 DFS 布局下所有对象的地址，然后使用相同的成本模型计算总遍历成本 $T_{\\text{DFS}}$。\n\n答案：以最简分数形式提供比率 $T_{\\text{BFS}} / T_{\\text{DFS}}$。无需四舍五入。解释在该成本模型下，相对于 DFS 布局，由 Cheney 算法产生的 BFS 布局如何影响后续边迭代算法的遍历性能。最终的方框答案必须只包含最简分数，不带单位。", "solution": "该问题要求对两种垃圾收集复制策略进行比较分析：一种是基于 Cheney 算法实现的广度优先搜索 (BFS)，另一种是基于深度优先搜索 (DFS)。该分析将通过模拟每种算法产生的内存布局，然后基于内存局部性成本模型计算遍历图中所有边的总成本来执行。\n\n给定的对象图有节点 $\\{A, B, C, D, E, F, G, H\\}$ 和一个根集合 $[r_1, r_2]$，其中 $r_1 \\to A$ 和 $r_2 \\to B$。有向边为：$A \\to C$，$A \\to D$；$B \\to D$，$B \\to E$；$C \\to F$；$D \\to F$，$D \\to G$；$E \\to H$；$F \\to H$。对象的大小（单位：字）为：$|A| = 3$，$|B| = 4$，$|C| = 2$，$|D| = 5$，$|E| = 2$，$|F| = 3$，$|G| = 1$，$|H| = 2$。“to-space”从地址 $A_0 = 0$ 开始。\n\n首先，我们模拟 Cheney 算法以确定 BFS 内存布局和对象地址。Cheney 算法使用两个指针 `scan` 和 `alloc` 来管理“to-space”。该算法首先复制由根直接引用的对象，然后迭代地扫描已复制的对象并复制它们的子对象。\n\n**第 1 部分：Cheney 算法 (BFS) 模拟**\n\n1.  **初始化**：`scan` 和 `alloc` 指针被初始化为“to-space”的基地址 $A_0 = 0$。\n2.  **根处理**：根按给定顺序 $[r_1, r_2]$ 被扫描。\n    -   $r_1$ 指向 $A$。由于 $A$ 尚未被复制，它被复制到 `alloc` 指针所指向的地址。\n        -   $\\operatorname{addr_{BFS}}(A) = 0$。\n        -   `alloc` 指针前进 $|A|=3$，因此 `alloc` 变为 $3$。\n    -   $r_2$ 指向 $B$。由于 $B$ 尚未被复制，它被复制到当前的 `alloc` 地址。\n        -   $\\operatorname{addr_{BFS}}(B) = 3$。\n        -   `alloc` 指针前进 $|B|=4$，因此 `alloc` 变为 $3+4=7$。\n3.  **主循环**：算法现在进入其主循环 `while (scan  alloc)`。\n    -   位于 `scan` 指针 ($0$，对象 $A$) 处的对象被扫描。其字段指向 $C$ 和 $D$。\n        -   $C$ 尚未被复制。它被复制到 `alloc=7`。$\\operatorname{addr_{BFS}}(C) = 7$。`alloc` 变为 $7+|C|=9$。\n        -   $D$ 尚未被复制。它被复制到 `alloc=9`。$\\operatorname{addr_{BFS}}(D) = 9$。`alloc` 变为 $9+|D|=14$。\n        -   `scan` 指针越过对象 $A$ 前进：`scan` 变为 $0+|A|=3$。\n    -   位于 `scan=3` ($B$) 处的对象被扫描。其字段指向 $D$ 和 $E$。\n        -   $D$ 已经被复制到地址 $9$。$B$ 中的指针被更新。\n        -   $E$ 尚未被复制。它被复制到 `alloc=14`。$\\operatorname{addr_{BFS}}(E) = 14$。`alloc` 变为 $14+|E|=16$。\n        -   `scan` 越过 $B$ 前进：`scan` 变为 $3+|B|=7$。\n    -   位于 `scan=7` ($C$) 处的对象被扫描。其字段指向 $F$。\n        -   $F$ 尚未被复制。它被复制到 `alloc=16`。$\\operatorname{addr_{BFS}}(F) = 16$。`alloc` 变为 $16+|F|=19$。\n        -   `scan` 越过 $C$ 前进：`scan` 变为 $7+|C|=9$。\n    -   位于 `scan=9` ($D$) 处的对象被扫描。其字段指向 $F$ 和 $G$。\n        -   $F$ 已经被复制到地址 $16$。$D$ 中的指针被更新。\n        -   $G$ 尚未被复制。它被复制到 `alloc=19`。$\\operatorname{addr_{BFS}}(G) = 19$。`alloc` 变为 $19+|G|=20$。\n        -   `scan` 越过 $D$ 前进：`scan` 变为 $9+|D|=14$。\n    -   位于 `scan=14` ($E$) 处的对象被扫描。其字段指向 $H$。\n        -   $H$ 尚未被复制。它被复制到 `alloc=20`。$\\operatorname{addr_{BFS}}(H) = 20$。`alloc` 变为 $20+|H|=22$。\n        -   `scan` 越过 $E$ 前进：`scan` 变为 $14+|E|=16$。\n    -   位于 `scan=16` ($F$) 处的对象被扫描。其字段指向 $H$。\n        -   $H$ 已经被复制到地址 $20$。\n        -   `scan` 越过 $F$ 前进：`scan` 变为 $16+|F|=19$。\n    -   位于 `scan=19` ($G$) 处的对象被扫描。它没有指针。`scan` 变为 $19+|G|=20$。\n    -   位于 `scan=20` ($H$) 处的对象被扫描。它没有指针。`scan` 变为 $20+|H|=22$。\n4.  **终止**：现在 `scan = 22` 且 `alloc = 22`。条件 `scan  alloc` 为假，算法终止。\n\n最终的 BFS 放置顺序是 $A, B, C, D, E, F, G, H$。地址如下：\n-   $\\operatorname{addr_{BFS}}(A) = 0$\n-   $\\operatorname{addr_{BFS}}(B) = 3$\n-   $\\operatorname{addr_{BFS}}(C) = 7$\n-   $\\operatorname{addr_{BFS}}(D) = 9$\n-   $\\operatorname{addr_{BFS}}(E) = 14$\n-   $\\operatorname{addr_{BFS}}(F) = 16$\n-   $\\operatorname{addr_{BFS}}(G) = 19$\n-   $\\operatorname{addr_{BFS}}(H) = 20$\n\n**第 2 部分：BFS 布局的总遍历成本 ($T_{\\text{BFS}}$)**\n\n每条边的成本是，如果距离 $|\\operatorname{addr}(Y) - \\operatorname{addr}(X)| \\leq d=8$，成本为 $c_{\\text{near}}=1$；否则为 $c_{\\text{far}}=3$。\n-   边 $(A \\to C)$: $|\\operatorname{addr_{BFS}}(C) - \\operatorname{addr_{BFS}}(A)| = |7 - 0| = 7 \\leq 8$。成本 = $1$。\n-   边 $(A \\to D)$: $|\\operatorname{addr_{BFS}}(D) - \\operatorname{addr_{BFS}}(A)| = |9 - 0| = 9  8$。成本 = $3$。\n-   边 $(B \\to D)$: $|\\operatorname{addr_{BFS}}(D) - \\operatorname{addr_{BFS}}(B)| = |9 - 3| = 6 \\leq 8$。成本 = $1$。\n-   边 $(B \\to E)$: $|\\operatorname{addr_{BFS}}(E) - \\operatorname{addr_{BFS}}(B)| = |14 - 3| = 11  8$。成本 = $3$。\n-   边 $(C \\to F)$: $|\\operatorname{addr_{BFS}}(F) - \\operatorname{addr_{BFS}}(C)| = |16 - 7| = 9  8$。成本 = $3$。\n-   边 $(D \\to F)$: $|\\operatorname{addr_{BFS}}(F) - \\operatorname{addr_{BFS}}(D)| = |16 - 9| = 7 \\leq 8$。成本 = $1$。\n-   边 $(D \\to G)$: $|\\operatorname{addr_{BFS}}(G) - \\operatorname{addr_{BFS}}(D)| = |19 - 9| = 10  8$。成本 = $3$。\n-   边 $(E \\to H)$: $|\\operatorname{addr_{BFS}}(H) - \\operatorname{addr_{BFS}}(E)| = |20 - 14| = 6 \\leq 8$。成本 = $1$。\n-   边 $(F \\to H)$: $|\\operatorname{addr_{BFS}}(H) - \\operatorname{addr_{BFS}}(F)| = |20 - 16| = 4 \\leq 8$。成本 = $1$。\n\nBFS 布局的总成本是 $T_{\\text{BFS}} = 1 + 3 + 1 + 3 + 3 + 1 + 3 + 1 + 1 = 17$。\n\n**第 3 部分：DFS 模拟与成本 ($T_{\\text{DFS}}$)**\n\n接下来，我们模拟一个递归的 DFS 复制算法。遍历从 $r_1$ 开始，尽可能深地探索，然后继续处理 $r_2$。\n\n1.  **DFS 模拟**：我们从 `alloc=0` 和一个空的已复制对象集合开始。\n    -   处理根 $r_1 \\to A$。调用 `copy(A)`。\n        -   `copy(A)`: $A$ 是新的。复制 $A$。$\\operatorname{addr_{DFS}}(A) = 0$。`alloc` 变为 $3$。处理 $A$ 的子节点：$(C, D)$。\n            -   调用 `copy(C)`。$C$ 是新的。复制 $C$。$\\operatorname{addr_{DFS}}(C) = 3$。`alloc` 变为 $3+2=5$。处理 $C$ 的子节点：$(F)$。\n                -   调用 `copy(F)`。$F$ 是新的。复制 $F$。$\\operatorname{addr_{DFS}}(F) = 5$。`alloc` 变为 $5+3=8$。处理 $F$ 的子节点：$(H)$。\n                    -   调用 `copy(H)`。$H$ 是新的。复制 $H$。$\\operatorname{addr_{DFS}}(H) = 8$。`alloc` 变为 $8+2=10$。$H$ 没有子节点。返回。\n                -   从 `copy(F)` 返回。\n            -   从 `copy(C)` 返回。\n            -   调用 `copy(D)`。$D$ 是新的。复制 $D$。$\\operatorname{addr_{DFS}}(D) = 10$。`alloc` 变为 $10+5=15$。处理 $D$ 的子节点：$(F, G)$。\n                -   调用 `copy(F)`。$F$ 已经被复制。返回。\n                -   调用 `copy(G)`。$G$ 是新的。复制 $G$。$\\operatorname{addr_{DFS}}(G) = 15$。`alloc` 变为 $15+1=16$。$G$ 没有子节点。返回。\n            -   从 `copy(D)` 返回。\n        -   从 `copy(A)` 返回。\n    -   处理根 $r_2 \\to B$。调用 `copy(B)`。\n        -   `copy(B)`: $B$ 是新的。复制 $B$。$\\operatorname{addr_{DFS}}(B) = 16$。`alloc` 变为 $16+4=20$。处理 $B$ 的子节点：$(D, E)$。\n            -   调用 `copy(D)`。$D$ 已经被复制。返回。\n            -   调用 `copy(E)`。$E$ 是新的。复制 $E$。$\\operatorname{addr_{DFS}}(E) = 20$。`alloc` 变为 $20+2=22$。处理 $E$ 的子节点：$(H)$。\n                -   调用 `copy(H)`。$H$ 已经被复制。返回。\n            -   从 `copy(E)` 返回。\n        -   从 `copy(B)` 返回。\n    -   所有根都已处理完毕。\n\nDFS 放置顺序是 $A, C, F, H, D, G, B, E$。地址如下：\n-   $\\operatorname{addr_{DFS}}(A) = 0$\n-   $\\operatorname{addr_{DFS}}(C) = 3$\n-   $\\operatorname{addr_{DFS}}(F) = 5$\n-   $\\operatorname{addr_{DFS}}(H) = 8$\n-   $\\operatorname{addr_{DFS}}(D) = 10$\n-   $\\operatorname{addr_{DFS}}(G) = 15$\n-   $\\operatorname{addr_{DFS}}(B) = 16$\n-   $\\operatorname{addr_{DFS}}(E) = 20$\n\n2.  **DFS 布局的总遍历成本 ($T_{\\text{DFS}})$**：\n-   边 $(A \\to C)$: $|\\operatorname{addr_{DFS}}(C) - \\operatorname{addr_{DFS}}(A)| = |3 - 0| = 3 \\leq 8$。成本 = $1$。\n-   边 $(A \\to D)$: $|\\operatorname{addr_{DFS}}(D) - \\operatorname{addr_{DFS}}(A)| = |10 - 0| = 10  8$。成本 = $3$。\n-   边 $(B \\to D)$: $|\\operatorname{addr_{DFS}}(D) - \\operatorname{addr_{DFS}}(B)| = |10 - 16| = 6 \\leq 8$。成本 = $1$。\n-   边 $(B \\to E)$: $|\\operatorname{addr_{DFS}}(E) - \\operatorname{addr_{DFS}}(B)| = |20 - 16| = 4 \\leq 8$。成本 = $1$。\n-   边 $(C \\to F)$: $|\\operatorname{addr_{DFS}}(F) - \\operatorname{addr_{DFS}}(C)| = |5 - 3| = 2 \\leq 8$。成本 = $1$。\n-   边 $(D \\to F)$: $|\\operatorname{addr_{DFS}}(F) - \\operatorname{addr_{DFS}}(D)| = |5 - 10| = 5 \\leq 8$。成本 = $1$。\n-   边 $(D \\to G)$: $|\\operatorname{addr_{DFS}}(G) - \\operatorname{addr_{DFS}}(D)| = |15 - 10| = 5 \\leq 8$。成本 = $1$。\n-   边 $(E \\to H)$: $|\\operatorname{addr_{DFS}}(H) - \\operatorname{addr_{DFS}}(E)| = |8 - 20| = 12  8$。成本 = $3$。\n-   边 $(F \\to H)$: $|\\operatorname{addr_{DFS}}(H) - \\operatorname{addr_{DFS}}(F)| = |8 - 5| = 3 \\leq 8$。成本 = $1$。\n\nDFS 布局的总成本是 $T_{\\text{DFS}} = 1 + 3 + 1 + 1 + 1 + 1 + 1 + 3 + 1 = 13$。\n\n**比较与最终比率**\n\n分析表明 $T_{\\text{BFS}} = 17$ 且 $T_{\\text{DFS}} = 13$。比率是 $T_{\\text{BFS}} / T_{\\text{DFS}} = 17 / 13$。\n\nBFS 布局是 Cheney 算法的特点，它根据对象与根的距离来组织对象。这为图遍历中处于同一层的对象（例如，同为根的 $A$ 和 $B$）带来了良好的空间局部性，但如果许多其他同层对象被复制到父子之间，则父子之间的局部性会变差。例如，边 $(C \\to F)$ 成为一次“远”访问，因为对象 $D$ 和 $E$ 被放置在 $C$ 和其子节点 $F$ 之间。这导致了 4 次远访问。\n\n相比之下，DFS 布局保持了父子链在内存中的连续性（例如，$A, C, F, H$ 被顺序放置，使得它们之间的直接链接成为“近”访问）。这种聚类策略通常会为以深度优先方式遍历图的算法提高局部性。然而，它可能导致 DFS 树不同分支之间的交叉链接产生较大的距离（例如，$(E \\to H)$）。在这个具体实例中，DFS 布局将远访问次数最小化到 2 次，从而在给定模型下获得了更低的总遍历成本。因此，性能高度依赖于数据结构的拓扑结构与 GC 算法所引起的内存布局之间的相互作用。\n\n所要求的比率是 $\\frac{17}{13}$。由于 $17$ 和 $13$ 是质数，该分数已是最简形式。", "answer": "$$\\boxed{\\frac{17}{13}}$$", "id": "3634309"}]}