{"hands_on_practices": [{"introduction": "安全点是实现精确垃圾回收和即时编译优化的关键，但它们并非没有代价。每次执行到安全点轮询时，都会产生微小的性能开销。这个练习将引导你量化和比较两种常见的轮询实现策略的性能影响，从而让你深入理解在编译器设计中如何基于底层硬件特性进行性能权衡 [@problem_id:3669414]。", "problem": "考虑一个受控运行时（managed runtime），它在紧凑循环的每次迭代中插入一个安全点轮询（safepoint poll），以便安全地启动垃圾回收和去优化。安全点是程序中的一个点，在该点上，所有线程栈都处于已知状态，并且所有存活的引用都可以通过栈图（stack maps）被发现。栈图为每个安全点记录了寄存器和内存中存活对象引用的位置，以实现精准垃圾回收。实现安全点轮询通常使用两种编译器策略：(i) 内联轮询（inline polling），在循环体中生成一个条件检查；以及 (ii) 调用运行时存根（callout to a runtime stub），循环体执行一个无条件调用进入一个处理安全点协议并返回的存根。\n\n假设一个即时（JIT）编译器目标为两种架构，标记为 $\\mathcal{A}$ 和 $\\mathcal{B}$。设内联轮询使用的条件分支的分支预测错误率为 $p \\in [0,1]$。使用以下基于标准微架构定义的成本建模假设：\n- 一个条件分支的基本执行成本为 $b$ 个周期（包括比较和分支微操作），当预测错误时，由于流水线刷新和前端重定向，会产生 $m$ 个周期的额外惩罚。\n- 在循环体中执行时，从一个热点轮询内存位置（例如，一个页保护标志或轮询页）加载的成本为 $l$ 个周期。在运行时存根内部执行时，相同的加载成本为 $l_{s}$ 个周期。\n- 当实际上没有触发安全点时，在热路径上，对存根的无条件调用及其返回的组合开销为 $c$ 个周期。该开销包括返回栈操作和前端成本，但不包括任何分支预测错误，因为调用是无条件的，并且存根的快速路径相对于返回是无分支的。\n- 在热路径中不会触发安全点；您只需对轮询开销进行建模。\n\n对于内联轮询，循环体执行一次轮询位置的加载和一次条件分支；预期的每次迭代开销是基本成本加上预期的预测错误惩罚的总和。对于调用方法，循环体执行一次无条件调用和返回；如果没有请求安全点，存根会执行一次加载并立即返回，在快速路径上没有条件分支。\n\n使用以上原理，从第一性原理推导出盈亏平衡的预测错误概率 $p^{\\ast}$，在该概率下，内联轮询的预期每次迭代开销等于调用方法的开销。然后，对以下两种架构进行 $p^{\\ast}$ 的数值计算：\n\n- 架构 $\\mathcal{A}$：$l = 4$ 周期，$b = 1$ 周期，$m = 18$ 周期，$c = 9$ 周期，$l_{s} = 4$ 周期。\n- 架构 $\\mathcal{B}$：$l = 3$ 周期，$b = 2$ 周期，$m = 12$ 周期，$c = 8$ 周期，$l_{s} = 3$ 周期。\n\n将这对值 $\\left(p^{\\ast}_{\\mathcal{A}}, p^{\\ast}_{\\mathcal{B}}\\right)$ 作为无量纲的纯数字报告。将您的数值结果四舍五入到四位有效数字。按要求使用 LaTeX 的 pmatrix 环境将最终答案表示为行向量。", "solution": "该问题要求推导盈亏平衡的预测错误概率，记为 $p^{\\ast}$，在此概率下，实现安全点轮询的两种不同编译器策略表现出相等的性能开销。这两种策略是内联轮询和调用运行时存根。我们将首先根据所提供的微架构参数为每种策略建立成本模型，然后符号化地求解盈亏平衡概率 $p^{\\ast}$，最后计算两种指定架构 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的数值。\n\n令 $C_{\\text{inline}}$ 代表内联轮询策略的预期每次迭代开销。问题陈述该策略由在循环体中执行的一次内存加载和一次条件分支组成。总成本是这些操作成本的总和。\n从热点轮询内存位置加载的成本为 $l$。\n条件分支的成本有两个组成部分：基本执行成本 $b$ 和预测错误的潜在惩罚。分支以概率 $p$ 预测错误，产生 $m$ 个周期的额外成本。因此，分支的期望成本是其基本成本与期望惩罚之和，即 $b + p \\times m$。\n因此，内联轮询的总预期开销为：\n$$C_{\\text{inline}} = l + b + pm$$\n\n接下来，令 $C_{\\text{callout}}$ 代表调用策略的每次迭代开销。该策略涉及对一个运行时存根的无条件调用，该存根随后执行内存加载。我们关心的是实际上没有触发安全点的热路径。\n无条件调用及其相应返回的成本为 $c$。\n在存根内部执行时，内存加载的成本为 $l_s$。\n问题明确指出，调用是无条件的，并且存根的快速路径是无分支的，因此在该策略的热路径上无需考虑分支预测错误成本。\n调用策略的总开销是这两个组成部分的总和：\n$$C_{\\text{callout}} = c + l_s$$\n\n盈亏平衡的预测错误概率 $p^{\\ast}$ 是使两种策略成本相等的特定 $p$ 值：$C_{\\text{inline}} = C_{\\text{callout}}$。我们可以建立以下方程：\n$$l + b + p^{\\ast}m = c + l_s$$\n\n我们现在求解这个关于 $p^{\\ast}$ 的方程，以找到盈亏平衡概率的一般符号表达式：\n$$p^{\\ast}m = c + l_s - l - b$$\n$$p^{\\ast} = \\frac{c + l_s - l - b}{m}$$\n\n这个表达式用架构成本参数表示了盈亏平衡概率。我们现在将使用这个公式来计算给定两种架构的数值。\n\n对于架构 $\\mathcal{A}$，提供的参数为：\n$l = 4$ 周期\n$b = 1$ 周期\n$m = 18$ 周期\n$c = 9$ 周期\n$l_s = 4$ 周期\n\n将这些值代入我们推导出的 $p^{\\ast}$ 表达式中：\n$$p^{\\ast}_{\\mathcal{A}} = \\frac{9 + 4 - 4 - 1}{18} = \\frac{8}{18} = \\frac{4}{9}$$\n将此表示为四舍五入到四位有效数字的小数：\n$$p^{\\ast}_{\\mathcal{A}} \\approx 0.4444$$\n\n对于架构 $\\mathcal{B}$，提供的参数为：\n$l = 3$ 周期\n$b = 2$ 周期\n$m = 12$ 周期\n$c = 8$ 周期\n$l_s = 3$ 周期\n\n将这些值代入 $p^{\\ast}$ 的表达式中：\n$$p^{\\ast}_{\\mathcal{B}} = \\frac{8 + 3 - 3 - 2}{12} = \\frac{6}{12} = \\frac{1}{2}$$\n作为小数，它恰好是 $0.5$。为了遵守四舍五入到四位有效数字的要求，我们将其表示为：\n$$p^{\\ast}_{\\mathcal{B}} = 0.5000$$\n\n最终结果是这两个概率对 $(p^{\\ast}_{\\mathcal{A}}, p^{\\ast}_{\\mathcal{B}})$。对于任何给定的架构，如果实际的分支预测错误率 $p$ 大于 $p^{\\ast}$，则调用策略更高效。如果 $p$ 小于 $p^{\\ast}$，则内联轮询是首选的、开销更低的策略。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4444 & 0.5000\n\\end{pmatrix}\n}\n$$", "id": "3669414"}, {"introduction": "在与垃圾回收器交互时，正确性是首要原则，尤其是在处理像内联汇编这样的底层代码时。当一个托管引用被“隐藏”在编译器无法追踪的寄存器中时，如果发生垃圾回收，可能会导致灾难性的内存损坏。这个练习模拟了一个经典的内存安全陷阱，并要求你评估多种修复方案，以确保在精确垃圾回收器面前，程序的行为始终是正确和安全的 [@problem_id:3669445]。", "problem": "一个托管运行时实现了一个精确、重定位的垃圾回收器，并使用协作式安全点，这些安全点作为显式轮询插入在明确定义的程序位置。根据定义，在安全点，垃圾回收器必须能够通过栈图（stack map）发现每一个指向托管对象的存活引用。栈图会精确地枚举所有存活引用及其位置（栈槽和寄存器）。考虑以下一个简化的、针对 x86-64 应用程序二进制接口的类C函数，其中使用了内联汇编。该内联汇编将一个托管引用存放到一个被调用者保存的寄存器中，并在稍后使用它。运行时在这两次使用之间插入了一个安全点轮询。\n\n代码示意（仅为说明，不能直接编译）：\n\n```c\ntypedef struct Obj { int f; } Obj;\n\nvoid g(Obj* p) {\n  // Stash the managed pointer into rbx using inline assembly.\n  asm volatile(\n    \"mov %0, %%rbx\\n\\t\"\n    :\n    : \"r\"(p)\n    : \"rbx\", \"memory\"\n  );\n\n  // A cooperative safe point poll that may trigger garbage collection.\n  safepoint_poll();\n\n  // Later, still use the hidden copy in rbx via inline assembly.\n  asm volatile(\n    \"mov (%%rbx), %%eax\\n\\t\"  // read field f\n    :\n    :\n    : \"rbx\", \"rax\", \"memory\"\n  );\n}\n```\n\n假设以下基本事实：\n- 垃圾回收器是精确且重定位的：它可能在回收过程中移动对象，并假定在安全点处的所有存活引用都可以从栈图中发现。它不会保守地扫描未在栈图中枚举的栈字或寄存器。\n- 编译器仅根据其内部对托管引用的存活性分析和显式注解来构建栈图；它不检查内联汇编的语义。\n- 安全点轮询可能导致一次垃圾回收。如果在该轮询点的栈图中没有枚举某个存活引用，回收器可能会在移动对象后不更新这个隐藏的副本，从而在稍后解引用该副本时导致内存损坏。\n\n在上面的代码中，第一个内联汇编将托管引用复制到寄存器 rbx 中，但外围的编译器无法“看到”rbx 包含一个在轮询后仍然存活的托管引用。因此，在轮询点，栈图可能会忽略这个引用。你必须选择如何在这种精确、重定位的回收器下使该程序变得健全（sound）。\n\n以下哪些改动是修复该程序的健全方法，以确保即使在轮询点发生垃圾回收，程序仍然能正确运行？选择所有适用项。\n\nA. 使用安全点栅栏（safepoint fence）包围从第一个内联汇编到第二个内联汇编的区域（即，防止在该区域内插入或执行轮询或调用），并将任何安全点轮询移到该栅栏区域之外。确保栅栏区域不会调用可能阻塞或轮询的代码。这保证了当引用隐藏在 rbx 中时，不会发生垃圾回收。\n\nB. 保留 `safepoint_poll` 的位置，但向编译器的栈图机制显式地公布该托管引用，使其在轮询期间保持存活。例如，将引用物化（materialize）到一个声明为垃圾回收器根（garbage collector root）的专用溢出槽（spill slot）中，或者使用一个编译器可识别的 keepalive，以便轮询点的栈图能够枚举该引用的位置（无论是在溢出槽中还是在指定的寄存器中）。\n\nC. 依赖平台调用约定和 \"memory\" 破坏描述符：由于 rbx 是被调用者保存的寄存器，并且汇编代码在破坏列表（clobbers）中列出了 \"memory\"，因此即使 rbx 未在栈图中列出，运行时也会在轮询点隐式扫描 rbx，所以不需要额外的工作。\n\nD. 强制进行保守枚举，让运行时在每个安全点都保守地扫描所有通用寄存器和所有栈字，而无需更改汇编代码。这样就避免了专门为该引用添加注解的需要。\n\nE. 用堆句柄（heap handle）替换原始引用：在第一个内联汇编之前，在运行时的句柄表中为 p 注册一个句柄；当内联汇编需要该对象时，必须通过此句柄加载和存储；在第二个内联汇编之后，注销该句柄。由于句柄是一个已知的根，垃圾回收器会在重定位时更新它，即使在轮询点发生垃圾回收，内联汇编也能观察到更新后的地址。", "solution": "### 基于原则的推导\n\n核心问题是违反了垃圾回收器的不变量。GC 的工作原则是：由编译器生成的栈图提供了在安全点时栈上和寄存器中所有存活托管引用的完整枚举。在给定的代码中，引用 `p` 被复制到 `rbx` 寄存器中。由于编译器不分析内联汇编的语义，其存活性分析可能会得出结论，认为变量 `p` 在第一个汇编块之后就不再需要了。因此，在为 `safepoint_poll()` 调用生成栈图时，编译器没有任何信息表明 `rbx` 包含一个必须保留的存活引用。\n\n如果在轮询点发生垃圾回收，GC 将使用不完整的栈图来扫描根。它可能会找到并重定位最初由 `p` 指向的对象（如果通过其他路径可达），或者回收其内存（如果不可达）。无论哪种情况，存储在 `rbx` 中的指针值都不会被更新，因为 GC 不知道它的存在。这个指针现在是过时的（stale）。随后的解引用 `mov (%%rbx), %%eax` 将会从一个无效的内存地址读取，导致内存损坏、段错误或其他未定义行为。\n\n一个健全的解决方案必须恢复这个不变量。这可以通过两种主要策略来实现：\n1.  **防止回收：** 确保在引用对编译器隐藏的期间，不会发生垃圾回收。\n2.  **通知回收器：** 将隐藏的存活引用的存在和位置明确地传达给编译器和运行时，以便它被包含在栈图中并由 GC 正确更新。\n\n### 逐项分析\n\n**A. 使用安全点栅栏（safepoint fence）包围从第一个内联汇编到第二个内联汇编的区域（即，防止在该区域内插入或执行轮询或调用），并将任何安全点轮询移到该栅栏区域之外。确保栅栏区域不会调用可能阻塞或轮询的代码。这保证了当引用隐藏在 rbx 中时，不会发生垃圾回收。**\n\n此方法实现了第一种策略：防止回收。“安全点栅栏”（safepoint fence）或“GC不安全区域”是托管运行时中的一种标准机制。它建立一个代码块，在该代码块中线程不处于GC安全状态。运行时保证此区域内的轮询被禁用，或者如果请求回收，线程不会为GC而挂起。通过将 `rbx` 持有隐藏指针的整个区域用栅栏围起来，我们确保 `safepoint_poll()` 不会触发回收。由于对象不能被移动或回收，`rbx` 中的指针保持有效。该区域不得阻塞或向外调用的约束至关重要，因为此类操作可能隐式地让出控制权给运行时并触发回收。这是一个健全且实用的解决方案。\n\n**结论：正确。**\n\n**B. 保留 safepoint_poll 的位置，但向编译器的栈图机制显式地公布该托管引用，使其在轮询期间保持存活。例如，将引用物化（materialize）到一个声明为垃圾回收器根（garbage collector root）的专用溢出槽（spill slot）中，或者使用一个编译器可识别的 keepalive，以便轮询点的栈图能够枚举该引用的位置（无论是在溢出槽中还是在指定的寄存器中）。**\n\n此方法实现了第二种策略：通知回收器。该解决方案不是隐藏引用，而是让编译器意识到该引用必须在 `safepoint_poll()` 之后仍然被认为是存活的。像 `GC.KeepAlive()` 内在函数或局部变量上的特殊注解之类的机制会告诉编译器延长该引用的生命周期。然后，编译器确保该引用被记录在安全点的栈图中。GC 在读取栈图时，会找到该引用（无论它是在像 `rbx` 这样的寄存器中还是在栈槽中），并在对象被重定位时更新它。这直接解决了汇编代码与编译器/GC之间的信息鸿沟。在许多托管环境中，这是一种健壮且惯用的解决问题的方法。\n\n**结论：正确。**\n\n**C. 依赖平台调用约定和 \"memory\" 破坏描述符：由于 rbx 是被调用者保存的寄存器，并且汇编代码在破坏列表（clobbers）中列出了 \"memory\"，因此即使 rbx 未在栈图中列出，运行时也会在轮询点隐式扫描 rbx，所以不需要额外的工作。**\n\n这个建议是基于对所涉及组件的误解。\n- **被调用者保存的寄存器：** 在 x86-64 System V ABI 下，`rbx` 作为“被调用者保存”的状态是函数调用的一个契约，确保被调用者保留调用者的值。这个约定与 GC 在安全点的根查找机制无关。GC 遵循自己的规则，如前所述，这些规则完全基于栈图。\n- **\"memory\" 破坏描述符：** `memory` 破坏描述符是给*编译器*的指令。它强制编译器假定该汇编块可能读取或写入任何内存位置。这可以防止编译器跨汇编块重排读/写操作，并使其从内存中缓存到寄存器的任何值失效。它不提供关于寄存器*内容*的任何信息。编译器无法从这个破坏描述符推断出 `rbx` 持有一个托管引用。\n问题明确指出 GC 是**精确的**，并且不扫描未枚举的位置。因此，运行时*不会*“隐式扫描 `rbx`”。\n\n**结论：不正确。**\n\n**D. 强制进行保守枚举，让运行时在每个安全点都保守地扫描所有通用寄存器和所有栈字，而无需更改汇编代码。这样就避免了专门为该引用添加注解的需要。**\n\n这建议改变垃圾回收器的基本设计，从精确变为部分保守。虽然保守的 GC 可能会在 `rbx` 中找到类似指针的值并将其视为一个根，但这并不是对*程序*的修复。这是对整个*运行时系统*的修改。问题要求的是在*给定现有运行时约束*（其中之一是精确 GC）的情况下，找到一种修复程序的健全方法。将 GC 的算法从精确更改为保守违反了问题的前提。解决方案必须在指定的系统内工作，而不是通过改变其核心原则。\n\n**结论：不正确。**\n\n**E. 用堆句柄（heap handle）替换原始引用：在第一个内联汇编之前，在运行时的句柄表中为 p 注册一个句柄；当内联汇编需要该对象时，必须通过此句柄加载和存储；在第二个内联汇编之后，注销该句柄。由于句柄是一个已知的根，垃圾回收器会在重定位时更新它，即使在轮询点发生垃圾回收，内联汇编也能观察到更新后的地址。**\n\n这是一个基于间接寻址（indirection）的经典且健壮的解决方案。“句柄”（handle）是对托管对象的稳定引用，通常是指向运行时管理的表中某个位置的指针。GC 知道要将整个表作为根集进行扫描。程序的逻辑将是：\n1. 创建一个句柄 `h`，它指向一个包含对象 `p` 地址的内存位置。\n2. 内联汇编接收句柄的地址 ``。要获取对象的地址，它必须首先解引用 `h`。\n3. 如果 GC 在轮询点运行，它会重定位对象 `p` 并更新存储在 `h` 处的地址。\n4. 第二个内联汇编块再次解引用 `h`，并获得对象的新、正确的地址。\n指向对象的原始指针绝不会跨越安全点持久存在；每次需要时，它都会从稳定的句柄中重新加载。这将代码与对象的物理位置解耦，使其不受重定位的影响。\n\n**结论：正确。**", "answer": "$$\\boxed{ABE}$$", "id": "3669445"}]}