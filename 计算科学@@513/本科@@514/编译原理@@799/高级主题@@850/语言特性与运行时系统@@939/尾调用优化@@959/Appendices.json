{"hands_on_practices": [{"introduction": "掌握尾调用优化的第一步是学会精确识别哪些函数调用处于“尾部位置”。这个练习不仅仅是寻找代码的最后一行；它关乎理解程序的控制流如何决定一个调用是否是最终动作 [@problem_id:3673993]。通过分析一个复杂的嵌套函数并应用一组形式化规则，你将培养出一种精确的直觉，从而识别出优化的机会。", "problem": "我们考虑一种严格的、传值调用的语言，其函数参数和二元运算符的求值顺序为从左到右。该语言具有以下构造和经过充分检验的语义事实，这些是推理尾部位置和尾调用优化（TCO）的基础：\n- 在该语言中，一个表达式被称为处于尾部位置，如果当它求值时，当前函数在当前的活动帧中不执行任何进一步的计算，并立即返回该表达式的值。\n- 条件表达式 $\\mathrm{if}\\ \\phi\\ \\mathrm{then}\\ e_1\\ \\mathrm{else}\\ e_2$ 的值是 $e_1$ 或 $e_2$ 的值。如果整个条件表达式处于尾部位置，那么其被选择的分支也处于尾部位置，但条件 $\\phi$ 不处于尾部位置。\n- let-绑定 $\\mathrm{let}\\ v = e_1\\ \\mathrm{in}\\ e_2$ 的值是 $e_2$ 的值。如果整个let-绑定处于尾部位置，那么 $e_2$ 处于尾部位置，而 $e_1$ 不处于（因为对 $e_1$ 的求值之后必须接着对 $e_2$ 的求值）。\n- 对于一个二元运算符表达式 $e_1 \\oplus e_2$，例如使用 $+$ 的加法或使用 $\\land$ 的短路合取，如果整个运算符表达式处于尾部位置，那么操作数 $e_1$ 和 $e_2$ 都不处于尾部位置，因为在求值一个操作数后，运行时仍然需要执行运算符组合或可能需要求值另一个操作数。\n- 对于一个序列 $e_1;\\ e_2$，其值是 $e_2$ 的值，如果整个序列处于尾部位置，那么 $e_2$ 处于尾部位置，但 $e_1$ 不处于。\n- 在传值调用和从左到右参数求值的情况下，对于一个函数调用 $f(e_1,\\ldots,e_n)$，参数 $e_i$ 不处于尾部位置（因为调用尚未发生），而调用本身如果其值被直接返回，则可能处于尾部位置。\n\n考虑函数 $F(x,y)$，其中标记的调用点 $c_i$ 被明确指出：\n\n$F(x,y) =$\n$\\quad \\mathrm{if}\\ x > 0\\ \\mathrm{then}$\n$\\quad\\quad c_1(\\mathrm{abs}(x))$\n$\\quad \\mathrm{else}$\n$\\quad\\quad \\mathrm{let}\\ t = c_2(x)\\ \\mathrm{in}$\n$\\quad\\quad\\quad \\mathrm{if}\\ t == 0\\ \\mathrm{then}$\n$\\quad\\quad\\quad\\quad c_3(y)\\ \\land\\ c_4(x)$\n$\\quad\\quad\\quad \\mathrm{else}$\n$\\quad\\quad\\quad\\quad \\mathrm{let}\\ u = c_9(t)\\ \\mathrm{in}$\n$\\quad\\quad\\quad\\quad\\quad \\mathrm{if}\\ y > t\\ \\mathrm{then}$\n$\\quad\\quad\\quad\\quad\\quad\\quad 10 + c_5(t - y)$\n$\\quad\\quad\\quad\\quad\\quad \\mathrm{else}$\n$\\quad\\quad\\quad\\quad\\quad\\quad c_6(c_7(x),\\ c_8(y));\\ c_{10}(u)$\n\n假设 $\\land$（逻辑合取）具有通常的短路语义：$e_1 \\land e_2$ 仅在 $e_1$ 的值为 $\\mathrm{true}$ 时才对 $e_2$ 求值，并且如果 $e_1$ 的值为 $\\mathrm{false}$，其值为 $\\mathrm{false}$，否则其值为 $e_2$ 的值。\n\n在 $F$ 中，哪些标记的调用点 $c_i$ 处于尾部位置？\n\nA. $\\{c_1,\\ c_6,\\ c_{10}\\}$\n\nB. $\\{c_1,\\ c_{10}\\}$\n\nC. $\\{c_1,\\ c_3,\\ c_4,\\ c_{10}\\}$\n\nD. $\\{c_1,\\ c_5,\\ c_6,\\ c_{10}\\}$", "solution": "推导始于严格传值调用的基本定义和尾部位置的定义：一个表达式处于尾部位置，如果一旦它计算出其值，当前函数就不再执行任何进一步的计算，并直接返回该值。这是一个结构化属性：如果整个函数体处于尾部位置，那么在顶层的 $\\mathrm{if}$ 表达式中，其分支处于尾部位置；在 $\\mathrm{let}$ 表达式中，只有其主体处于尾部位置；在序列中，只有第二个表达式处于尾部位置；而在二元运算符表达式中，两个操作数都不处于尾部位置，因为运算符仍然需要组合操作数。\n\n我们对 $F(x,y)$ 进行结构化分析。\n\n1. $F(x,y)$ 的整个右侧都处于尾部位置，因为它产生函数的返回值。\n\n2. 顶层条件表达式：\n- 表达式 $\\mathrm{if}\\ x > 0\\ \\mathrm{then}\\ \\cdots\\ \\mathrm{else}\\ \\cdots$ 处于尾部位置，因此无论哪个分支被选中，都处于尾部位置。条件 $x > 0$ 不处于尾部位置，但它不包含任何标记的调用。\n\n3. 第一个分支 ($x > 0$)：\n- 表达式：$c_1(\\mathrm{abs}(x))$。\n- 调用 $c_1(\\cdot)$ 处于一个其值被直接返回的位置，所以 $c_1$ 处于尾部位置。\n- 参数 $\\mathrm{abs}(x)$ 不处于尾部位置（且未被标记），但这不影响我们对标记的尾调用的集合的判断。\n\n4. 第二个分支 ($x \\ge 0$)：\n- 表达式：$\\mathrm{let}\\ t = c_2(x)\\ \\mathrm{in}\\ \\cdots$。\n- 整个 $\\mathrm{let}$ 表达式处于尾部位置，因此其主体也处于尾部位置；然而，$c_2(x)$ 不处于尾部位置，因为在对 $c_2(x)$ 求值后，计算会继续执行其主体部分。\n\n5. 关于 $t$ 的嵌套条件表达式：\n- 如果 $t == 0$ 则为 $c_3(y)\\ \\land\\ c_4(x)$。\n- 整个运算符表达式 $c_3(y)\\ \\land\\ c_4(x)$ 处于尾部位置，但根据严格传值调用和短路求值下二元运算符的经过充分检验的语义， $c_3(y)$ 和 $c_4(x)$ 都不处于尾部位置。在对 $c_3(y)$ 求值后，运行时必须应用合取逻辑（并可能求值 $c_4(x)$），而在对 $c_4(x)$ 求值后，它仍必须得出运算符的结果。因此，$c_3$ 和 $c_4$ 不是尾调用。\n\n- Else (即 $t \\ne 0$)： $\\mathrm{let}\\ u = c_9(t)\\ \\mathrm{in}\\ \\cdots$。\n- 这个 $\\mathrm{let}$ 的主体处于尾部位置，但 $c_9(t)$ 本身不处于，原因同上：其后还有主体部分的求值。\n\n6. 在 $\\mathrm{let}\\ u$ 主体内部关于 $y$ 的条件表达式：\n- Then 分支：$10 + c_5(t - y)$。\n- 这是一个处于尾部位置的二元运算符表达式，但 $c_5(\\cdot)$ 不处于尾部位置，因为在 $c_5$ 返回后，还必须执行加 10 的操作。因此，$c_5$ 不是尾调用。\n\n- Else 分支：$c_6(c_7(x),\\ c_8(y));\\ c_{10}(u)$。\n- 这是一个序列，其值是第二个表达式 $c_{10}(u)$ 的值。因为整个序列处于尾部位置，所以第二个表达式 $c_{10}(u)$ 处于尾部位置，而第一个表达式 $c_6(\\cdot)$ 不处于（因为有后续计算：即对 $c_{10}(u)$ 的求值）。\n- 此外，在调用 $c_6(c_7(x),\\ c_8(y))$ 中，参数在传值调用下从左到右求值，并且参数 $c_7(x)$ 和 $c_8(y)$ 不处于尾部位置，因为它们是一个调用（即$c_6$）的参数，而该调用本身并不是最终返回的表达式。因此，$c_6$、$c_7$ 和 $c_8$ 都不是尾调用。\n- 在 $c_{10}(u)$ 中，该调用本身是序列的第二个表达式，其值被直接返回；因此 $c_{10}$ 处于尾部位置。\n\n收集标记点中的尾调用：\n- 尾调用：$c_1$, $c_{10}$。\n- 非尾调用：$c_2$, $c_3$, $c_4$, $c_5$, $c_6$, $c_7$, $c_8$, $c_9$。\n\n逐项分析选项：\n- A. $\\{c_1,\\ c_6,\\ c_{10}\\}$: 包含了 $c_6$，但由于序列中其后有 $c_{10}(u)$，所以 $c_6$ 不处于尾部位置。不正确。\n- B. $\\{c_1,\\ c_{10}\\}$: 与上面推导出的集合完全一致。正确。\n- C. $\\{c_1,\\ c_3,\\ c_4,\\ c_{10}\\}$: 包含了 $c_3$ 和 $c_4$，但它们在 $\\land$ 运算符表达式内部，不处于尾部位置。不正确。\n- D. $\\{c_1,\\ c_5,\\ c_6,\\ c_{10}\\}$: 包含了 $c_5$（因后续的加法而不处于尾部位置）和 $c_6$（因其后有 $c_{10}(u)$ 而不处于尾部位置）。不正确。", "answer": "$$\\boxed{B}$$", "id": "3673993"}, {"introduction": "尾调用优化不仅限于函数调用自身，它同样适用于更复杂的模式，如相互递归，即两个或多个函数循环调用对方。此实践将超越简单的语法检查，让你从编译器的视角全面思考其必须验证的优化条件，包括调用结构和确保调用后无任何后续计算 [@problem_id:3278452]。通过分析相互递归函数的不同实现方式，你将学会如何评估TCO的可行性，这对于编写高效的递归代码至关重要。", "problem": "考虑一个使用传统调用栈、严格按值调用、具有词法作用域和一等函数的语言。根据定义，如果调用者的最后一个动作是精确地返回被调用者产生的值，之后没有任何进一步的计算，那么这个调用就处于尾部位置（tail position）。尾调用优化（Tail Call Optimization, TCO）是一种实现策略，对于处于适当尾部位置的调用，编译器在进行调用时会复用调用者的栈帧（或者不增长栈），从而保证在无限的尾递归序列中栈的使用量为常数。\n\n假设一个假想的编译器，当且仅当在调用点满足以下所有条件时，它才会跨函数执行尾调用优化（TCO）：\n- 调用处于适当的尾部位置：调用者精确地返回被调用者的结果，在调用之后没有计算、控制转移或封装。\n- 没有必须在被调用者返回后运行的动态构造，因而需要保留调用者的帧，例如挂起的 $finally$ 块或将在调用后执行代码的异常处理程序。\n- 参数表达式在调用前求值（按值调用的要求），并且调用者的变量在调用后没有一个是活跃的。\n- 编译器和运行时在当前的调用约定下支持过程间尾调用消除（例如，两个函数都不是可变参数函数，并且都是在兼容的约定下编译的）。\n\n考虑三个判断奇偶性的相互递归实现。在每个实现中，$n$ 是一个非负整数，$\\text{true}$ 和 $\\text{false}$ 是布尔值。\n\n变体 $\\alpha$：\n$$\n\\text{is\\_even}(n) =\n\\begin{cases}\n\\text{true}  & \\text{if } n = 0 \\\\\n\\text{is\\_odd}(n - 1)  & \\text{otherwise}\n\\end{cases},\\quad\n\\text{is\\_odd}(n) =\n\\begin{cases}\n\\text{false}  & \\text{if } n = 0 \\\\\n\\text{is\\_even}(n - 1)  & \\text{otherwise}\n\\end{cases}.\n$$\n\n变体 $\\beta$：\n$$\n\\text{is\\_even}(n) =\n\\begin{cases}\n\\text{true}  & \\text{if } n = 0 \\\\\n\\text{do\\_log}(n);\\ \\text{is\\_odd}(n - 1)  & \\text{otherwise}\n\\end{cases},\\quad\n\\text{is\\_odd}(n) =\n\\begin{cases}\n\\text{false}  & \\text{if } n = 0 \\\\\n1 - \\text{is\\_even}(n - 1)  & \\text{otherwise}\n\\end{cases}.\n$$\n这里，$\\text{do\\_log}(n)$ 表示在调用前执行的副作用。\n\n变体 $\\gamma$（累加器传递）：\n$$\n\\text{is\\_even}(n, a) =\n\\begin{cases}\na  & \\text{if } n = 0 \\\\\n\\text{is\\_odd}(n - 1,\\, 1 - a)  & \\text{otherwise}\n\\end{cases},\\quad\n\\text{is\\_odd}(n, a) =\n\\begin{cases}\n1 - a  & \\text{if } n = 0 \\\\\n\\text{is\\_even}(n - 1,\\, 1 - a)  & \\text{otherwise}\n\\end{cases}.\n$$\n\n定义一个决策过程 $\\text{TailMutualOK}(\\text{is\\_even}, \\text{is\\_odd})$，给定一对函数定义，如果假想的编译器能对所有输入消除无限的栈增长（通过TCO），则该过程返回 $\\text{true}$，否则返回 $\\text{false}$。根据上述编译器的策略，该过程必须是充分且必要的，并且特别地，它应该接受变体 $\\alpha$ 和 $\\gamma$，并拒绝变体 $\\beta$。\n\n在这些约束下，下列关于 $\\text{TailMutualOK}$ 的哪个规范是正确的？\n\nA. 当且仅当 $\\text{is\\_even}$ 和 $\\text{is\\_odd}$ 之间的每个调用在语法上都是 return 的直接操作数时，返回 $\\text{true}$，忽略任何 $try$/$finally$ 块、异常处理程序或运行时的调用约定能力的存在。\n\nB. 当且仅当在 $\\text{is\\_even}$ 和 $\\text{is\\_odd}$ 之间的每个相互调用点，调用都处于适当的尾部位置，没有 $finally$ 或动态处理程序可以在调用后运行，调用后没有调用者的局部变量是活跃的（参数在调用前已完全求值），并且编译器在当前的调用约定下支持过程间 TCO 时，返回 $\\text{true}$。\n\nC. 对任何相互递归对都返回 $\\text{false}$，因为尾调用优化仅在被调用者等于调用者时才适用；相互递归从本质上阻止了常数栈使用。\n\nD. 如果 $\\text{is\\_even}$ 和 $\\text{is\\_odd}$ 都包含至少一个自身尾调用（即被调用者等于调用者的调用），则返回 $\\text{true}$，即使它们之间的调用不处于尾部位置，因为编译器会自动将相互递归转换为循环。", "solution": "首先验证问题陈述，以确保其科学上合理、问题定义良好且客观。\n\n### 步骤 1：提取已知条件\n- **语言环境**：一个使用传统调用栈、严格按值调用、具有词法作用域和一等函数的语言。\n- **尾部位置的定义**：如果调用者的最后一个动作是精确地返回被调用者产生的值，之后没有任何进一步的计算，那么这个调用就处于尾部位置。\n- **尾调用优化（TCO）的定义**：一种编译器策略，对于处于适当尾部位置的调用，它会复用调用者的栈帧，从而保证在无限的尾递归序列中栈的使用量为常数。\n- **假想编译器的 TCO 策略**：当且仅当在调用点满足以下所有四个条件时，才会执行 TCO：\n    1. 调用处于适当的尾部位置。\n    2. 没有动态构造（例如，挂起的 `finally` 块、异常处理程序）需要保留调用者的帧。\n    3. 调用者的变量在调用后没有一个是活跃的（参数在调用前求值）。\n    4. 编译器和运行时在兼容的调用约定下支持过程间尾调用消除。\n- **函数变体**：三个用于判断非负整数 $n$ 的奇偶性的相互递归实现。\n    - **变体 $\\alpha$**：\n      $$ \\text{is\\_even}(n) = \\begin{cases} \\text{true}  & \\text{if } n = 0 \\\\ \\text{is\\_odd}(n - 1)  & \\text{otherwise} \\end{cases},\\quad \\text{is\\_odd}(n) = \\begin{cases} \\text{false}  & \\text{if } n = 0 \\\\ \\text{is\\_even}(n - 1)  & \\text{otherwise} \\end{cases} $$\n    - **变体 $\\beta$**：\n      $$ \\text{is\\_even}(n) = \\begin{cases} \\text{true}  & \\text{if } n = 0 \\\\ \\text{do\\_log}(n);\\ \\text{is\\_odd}(n - 1)  & \\text{otherwise} \\end{cases},\\quad \\text{is\\_odd}(n) = \\begin{cases} \\text{false}  & \\text{if } n = 0 \\\\ 1 - \\text{is\\_even}(n - 1)  & \\text{otherwise} \\end{cases} $$\n      （$\\text{do\\_log}(n)$ 是在调用前执行的副作用。）\n    - **变体 $\\gamma$**：\n      $$ \\text{is\\_even}(n, a) = \\begin{cases} a  & \\text{if } n = 0 \\\\ \\text{is\\_odd}(n - 1,\\, 1 - a)  & \\text{otherwise} \\end{cases},\\quad \\text{is\\_odd}(n, a) = \\begin{cases} 1 - a  & \\text{if } n = 0 \\\\ \\text{is\\_even}(n - 1,\\, 1 - a)  & \\text{otherwise} \\end{cases} $$\n- **任务**：定义一个决策过程 $\\text{TailMutualOK}$，如果编译器能对所有输入消除无限的栈增长，则返回 $\\text{true}$，否则返回 $\\text{false}$。\n- **对过程的约束**：该过程必须是充分且必要的，接受变体 $\\alpha$ 和 $\\gamma$，并拒绝变体 $\\beta$。\n- **问题**：从给定选项中为 $\\text{TailMutualOK}$ 选择正确的规范。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述定义良好，并基于计算机科学的既定原则，特别是编译器设计和编程语言理论。尾调用、TCO、相互递归、按值调用语义和栈帧等概念都是标准的，并且描述准确。假想编译器的规则是一组用于执行 TCO 的具体但合理且内部一致的条件。问题是客观的，提供了具体的代码示例和一套清晰的逻辑规则。它没有歧义、矛盾，也不是基于不健全的科学前提。\n\n### 步骤 3：结论与行动\n问题是有效的。将通过分析编译器的要求并根据这些要求评估所提供的选项来推导解决方案。\n\n### 解答推导\n\n问题要求为决策过程 $\\text{TailMutualOK}$ 提供一个正确的规范。该过程必须确定一对相互递归的函数是否会被假想的编译器优化以实现常数栈使用。为了在无限次的递归调用中保持栈使用量为常数，相互递归循环中的*每一个*调用都必须是编译器能够并且将会优化的尾调用。\n\n问题明确地给出了编译器执行 TCO 的条件。让我们将它们表示为 $C_1, C_2, C_3, C_4$：\n- $C_1$：调用处于适当的尾部位置。\n- $C_2$：没有调用后清理（例如 `finally` 块）。\n- $C_3$：调用后没有活跃变量。\n- $C_4$：兼容的调用约定和运行时支持。\n\n编译器当且仅当对于一个给定的调用，$C_1 \\land C_2 \\land C_3 \\land C_4$ 为真时才应用 TCO。因此，$\\text{TailMutualOK}$ 必须当且仅当这个合取条件对函数对内的所有相互递归调用都成立时才返回 $\\text{true}$。\n\n让我们基于这些条件分析给定的变体，主要关注 $C_1$，因为它是代码所测试的主要结构属性。我们假设所示代码不涉及隐藏的 `finally` 块或不兼容的调用约定，从而使我们能够专注于调用结构。\n\n- **变体 $\\alpha$**：\n  - 在 $\\text{is\\_even}$ 中，调用 $\\text{is\\_odd}(n - 1)$ 是最终动作。$\\text{is\\_even}$ 的返回值正是 $\\text{is\\_odd}$ 的返回值。这满足 $C_1$。\n  - 在 $\\text{is\\_odd}$ 中，调用 $\\text{is\\_even}(n - 1)$ 同样是最终动作。这也满足 $C_1$。\n  - 由于循环中的两个调用都是适当的尾调用，编译器可以在每一步应用 TCO，从而实现常数栈使用。$\\text{TailMutualOK}$ 应该返回 $\\text{true}$。这与问题的约束一致。\n\n- **变体 $\\beta$**：\n  - 在 $\\text{is\\_even}$ 中，语句是 $\\text{do\\_log}(n);\\ \\text{is\\_odd}(n - 1)$。函数 $\\text{do\\_log}(n)$ 在调用 $\\text{is\\_odd}$ *之前*执行并完成。对 $\\text{is\\_odd}(n - 1)$ 的调用是最终动作，其结果被返回。这个调用处于尾部位置并满足 $C_1$。\n  - 在 $\\text{is\\_odd}$ 中，表达式是 $1 - \\text{is\\_even}(n - 1)$。必须调用函数 $\\text{is\\_even}(n-1)$，并且一旦其结果返回，就会执行减法运算 ($1 - \\dots$)。因为在调用返回后有计算，所以该调用**不**处于尾部位置。它违反了 $C_1$。\n  - 由于相互递归循环中的一个调用不是尾调用，每次调用 $\\text{is\\_odd}$ 都会导致栈增长。将会发生无限的栈增长。$\\text{TailMutualOK}$ 必须返回 $\\text{false}$。这与问题的约束一致。\n\n- **变体 $\\gamma$**：\n  - 在 $\\text{is\\_even}$ 中，调用是 $\\text{is\\_odd}(n - 1, 1 - a)$。参数，包括表达式 $1 - a$，在调用前被求值（由于按值调用）。调用本身是最终动作，其结果被直接返回。这满足 $C_1$。\n  - 在 $\\text{is\\_odd}$ 中，调用是 $\\text{is\\_even}(n - 1, 1 - a)$。这在结构上是相同的，也满足 $C_1$。\n  - 两个调用都是适当的尾调用。这是一种标准的累加器传递风格的转换。编译器可以应用 TCO。$\\text{TailMutualOK}$ 应该返回 $\\text{true}$。这与问题的约束一致。\n\n我们的目标是找到精确描述 $\\text{TailMutualOK}$ 逻辑的选项，该逻辑必须与编译器的完整 TCO 策略完全相同。\n\n### 逐项分析选项\n\n**A. 当且仅当 $\\text{is\\_even}$ 和 $\\text{is\\_odd}$ 之间的每个调用在语法上都是 return 的直接操作数时，返回 $\\text{true}$，忽略任何 $try$/$finally$ 块、异常处理程序或运行时的调用约定能力的存在。**\n此选项正确地指出了尾调用的语法属性（条件 $C_1$）。但是，它明确指出应忽略问题陈述中与 $C_2$ 和 $C_4$ 对应的其他条件。编译器的策略是“当且仅当所列**所有**条件都成立时”才执行 TCO。一个忽略某些必要条件的程序是不充分的，因此是错误的。\n结论：**错误**。\n\n**B. 当且仅当在 $\\text{is\\_even}$ 和 $\\text{is\\_odd}$ 之间的每个相互调用点，调用都处于适当的尾部位置，没有 $finally$ 或动态处理程序可以在调用后运行，调用后没有调用者的局部变量是活跃的（参数在调用前已完全求值），并且编译器在当前的调用约定下支持过程间 TCO 时，返回 $\\text{true}$。**\n此选项全面而准确地重述了问题陈述中为假想编译器的 TCO 策略指定的四个条件。它正确地要求这些条件“在每个相互调用点”都成立，以保证消除无限的栈增长。$\\text{TailMutualOK}$ 的规范必须是充分且必要的，这意味着它必须封装编译器的整个决策逻辑。此选项完美地做到了这一点。\n结论：**正确**。\n\n**C. 对任何相互递归对都返回 $\\text{false}$，因为尾调用优化仅在被调用者等于调用者时才适用；相互递归从本质上阻止了常数栈使用。**\n这个陈述在事实上是错误的。TCO 是对尾部位置调用的一般优化，不仅仅是针对自递归（即被调用者与调用者相同）。许多语言实现，以及问题中描述的假想实现，都明确支持过程间 TCO，其中包括相互递归。问题的预设，包括要求接受变体 $\\alpha$ 和 $\\gamma$，直接反驳了这一说法。\n结论：**错误**。\n\n**D. 如果 $\\text{is\\_even}$ 和 $\\text{is\\_odd}$ 都包含至少一个自身尾调用（即被调用者等于调用者的调用），则返回 $\\text{true}$，即使它们之间的调用不处于尾部位置，因为编译器会自动将相互递归转换为循环。**\n这个选项包含几个错误。首先，它引入了一个关于“自身尾调用”的条件，这在编译器的策略中没有提到，也未在示例中出现。其次，它错误地暗示 TCO 可以“即使它们之间的调用不处于尾部位置”也适用，这从根本上误解了 TCO。非尾调用正是导致栈增长的原因。第三，它假定了一种特定的、高级的优化（“自动将相互递归转换为循环”），这与基于栈帧复用的已定义 TCO 机制是不同的。正确的程序必须遵守问题中给出的规则，而不是发明新的规则。\n结论：**错误**。", "answer": "$$\\boxed{B}$$", "id": "3278452"}, {"introduction": "每项优化都有其权衡，尾调用优化也不例外。它防止栈增长的主要好处，代价是抹去了调用历史，这使得调试变得复杂。这个思想实验挑战你像一个运行时系统设计者一样思考，直面一个强大优化所带来的实际后果 [@problem_id:3278473]。通过设计和评估重建“逻辑”调用栈的机制，你将更深刻地体会到编译器优化、运行时系统和开发者工具之间的相互作用。", "problem": "考虑一个单线程运行时，其执行模型是一个后进先出（LIFO）的调用栈。设调用栈是一个激活记录（帧）的序列 $S = \\langle s_1, s_2, \\dots, s_k \\rangle$，其中，从函数 $f$ 到函数 $g$ 的标准调用会推入一个新帧，因此 $S \\leftarrow \\langle s_1, \\dots, s_k, s_{g} \\rangle$，而从栈顶帧返回会将其弹出，因此 $S \\leftarrow \\langle s_1, \\dots, s_{k-1} \\rangle$。栈追踪是一个从 $S$ 中收集的有限帧描述符序列 $T = \\langle \\tau_1, \\tau_2, \\dots, \\tau_m \\rangle$，通常 $\\tau_m$ 对应于栈顶帧。\n\n尾调用优化（Tail Call Optimization, TCO）定义如下：如果 $f$ 对 $g$ 执行尾调用（即，调用 $g$ 是 $f$ 的最后一个动作，且 $f$ 在 $g$ 返回后无需恢复），那么运行时不会为 $g$ 推入新帧，而是用 $g$ 的帧替换 $f$ 的栈顶帧，即 $S \\leftarrow \\langle s_1, \\dots, s_{k-1}, s_{g} \\rangle$。一个经过充分检验的事实是，TCO 限制了尾递归程序的物理栈使用，防止了 $S$ 的无限增长，同时保留了程序的可观察语义。\n\n我们希望在存在 TCO 的情况下支持调试。具体来说，假设一个执行在进行非尾调用或返回之前，遵循了一个尾调用链 $f_0 \\to f_1 \\to \\dots \\to f_n$。如果在这些尾调用之后生成栈追踪 $T$，物理栈 $S$ 将只包含最新的帧 $s_{f_n}$，而对于 $0 \\leq i  n$ 的中间帧 $s_{f_i}$ 将不存在。调试需求是重建一个逻辑栈追踪 $L = \\langle \\lambda_0, \\lambda_1, \\dots, \\lambda_n \\rangle$，该追踪列出逻辑上嵌套调用的确切序列（包括通过尾调用执行的调用），同时保留 TCO 带来的物理栈渐进空间界限。\n\n设计约束：\n- 正确性：当请求栈追踪时，逻辑追踪 $L$ 必须按顺序枚举当前控制路径上进入的所有函数序列，包括尾调用，不能有缺失或虚假的帧。\n- 开销：在尾调用边界的更新必须以每次事件 $O(1)$ 的时间运行，并为每个逻辑帧描述符分配 $O(1)$ 的额外空间；物理栈必须保持 TCO 所保证的有界性。\n- 兼容性：该机制必须与异常和返回共存，生成与语言标准调用/返回语义一致的逻辑追踪。\n\n以下哪种机制满足上述所有约束？\n\nA. 维护一个线程本地、堆分配的单向链表（一个“逻辑栈”）来存放帧描述符。在从 $f$ 到 $g$ 的非尾调用时，为 $g$ 分配一个新节点并将其链接为新的头部。在从 $f$ 到 $g$ 的尾调用时，为 $g$ 分配一个新节点并将其链接为新的头部，同时将 $f$ 标记为不可恢复（密封）。返回时，弹出节点，如果栈顶节点是通过尾调用链到达的，则继续弹出被密封的前驱节点，直到找到一个可恢复的前驱节点。物理栈继续使用 TCO。打印栈追踪时，从头到根遍历该链表。\n\nB. 在调试构建中禁用尾调用优化（TCO），允许物理栈 $S$ 增长到深度 $n$，并使用标准的栈展开来打印完整的追踪。这保留了栈追踪的准确性，但牺牲了有界的栈使用。\n\nC. 将程序转换为连续传递风格（Continuation-Passing Style, CPS），定义一个显式的连续体数据结构 $K$ 来表示当前的控制路径，并通过堆上的蹦床机制执行。每次调用都变成在 $O(1)$ 时间内构造一个新的连续体节点，而尾调用则变成直接更新 $K$，而无需增长物理栈。逻辑栈追踪通过遍历 $K$ 来重建。\n\nD. 仅依赖静态调试符号和当前的栈顶帧来在追踪时推断先前的尾调用，不使用任何运行时元数据或插桩。使用当前帧中的函数名和源位置来“猜测”之前的尾调用者。\n\n选择所有适用的选项。", "solution": "首先验证问题陈述，以确保其科学上合理、定义明确且客观。\n\n### 第1步：提取已知信息\n- **运行时模型：** 单线程，后进先出调用栈。\n- **调用栈：** 一个激活记录（帧）序列 $S = \\langle s_1, s_2, \\dots, s_k \\rangle$。\n- **标准调用：** 从函数 $f$ 到函数 $g$ 的调用将栈更新为 $S \\leftarrow \\langle s_1, \\dots, s_k, s_{g} \\rangle$。\n- **标准返回：** 从栈顶帧返回将栈更新为 $S \\leftarrow \\langle s_1, \\dots, s_{k-1} \\rangle$。\n- **尾调用优化 (TCO)：** 从 $f$ 到 $g$ 的尾调用将栈更新为 $S \\leftarrow \\langle s_1, \\dots, s_{k-1}, s_{g} \\rangle$，用 $s_g$ 替换帧 $s_f$。\n- **TCO 的效果：** 它限制了物理栈的使用，例如对于简单的尾递归，空间复杂度为 $O(1)$。\n- **问题场景：** 发生了一个尾调用链 $f_0 \\to f_1 \\to \\dots \\to f_n$。链结束后，物理栈 $S$ 只包含 $f_n$ 的帧。对于 $0 \\leq i  n$ 的 $f_i$ 的帧从 $S$ 中丢失。\n- **目标：** 重建一个逻辑栈追踪 $L = \\langle \\lambda_0, \\lambda_1, \\dots, \\lambda_n \\rangle$，以准确表示整个调用序列。\n- **设计约束：**\n    1.  **正确性：** 逻辑追踪 $L$ 必须是按正确顺序列出的所有进入函数的精确枚举，没有缺失或虚假的帧。\n    2.  **开销：** 调用边界的更新必须在 $O(1)$ 时间内完成。每个逻辑帧可以分配 $O(1)$ 的额外空间。物理栈必须像在 TCO 下一样保持有界。\n    3.  **兼容性：** 该机制必须与标准的异常和返回语义兼容。\n\n### 第2步：使用提取的已知信息进行验证\n- **科学基础：** 对调用栈、TCO 和帧语义的描述是计算机科学中用于解释编程语言实现的一种标准且准确的模型。该问题牢固地建立在编译器和运行时系统的既定原则之内。\n- **定义明确：** 该问题提供了一个清晰的目标（重建逻辑栈追踪）和一组精确、不矛盾的约束（正确性、时间/空间开销、兼容性）。问题要求根据这些约束评估具体机制，这使得一个确定的分析解成为可能。\n- **客观性：** 该问题以计算机科学领域通用的、无歧义的技术语言表述。诸如“激活记录”、“尾调用”、“渐进空间界限”和“堆分配”等术语具有精确的含义。约束是定量的且可验证的。\n\n### 第3步：结论与行动\n该问题陈述是**有效的**。这是一个定义明确的计算机科学问题，涉及在存在常见编译器优化的情况下设计调试工具。我现在将继续提供解决方案。\n\n### 基于原则的推导\n根本的挑战在于，尾调用优化（TCO）是通过丢弃信息——特别是在尾调用链中调用函数的身份——来实现其对尾递归循环的 $O(1)$ 栈空间复杂度的。物理栈 $S$ 只维护当前状态，而非历史记录。问题要求为了调试目的恢复这些丢失的历史信息，同时不牺牲 $O(1)$ 物理栈的好处。\n\n约束条件决定了解决方案的形态。“正确性”约束排除了任何形式的启发式方法或猜测。“开销”约束是最关键的：物理栈必须保持有界（例如，对于简单的尾递归循环为 $O(1)$），但我们被允许为每个逻辑帧使用 $O(1)$ 的*额外*空间。这意味着对于长度为 $n$ 的尾调用链，我们可以总共使用 $O(n)$ 的空间，但这些空间不能在物理栈上。这种动态增长数据的自然位置是堆。该机制还必须是高效的，每次调用事件只需要 $O(1)$ 的时间。\n\n因此，一个有效的解决方案必须通过一种机制来增强运行时，在每次调用（尾调用或非尾调用）时，将调用目标的描述符存储在堆分配的数据结构中。这个数据结构将构成“逻辑栈”。该结构必须能够以每次调用 $O(1)$ 的时间更新来维护。单向链表，其中新节点被添加到头部，是满足这些要求的数据结构的典型例子。\n\n### 逐项分析\n\n**A. 维护一个线程本地、堆分配的单向链表（一个“逻辑栈”）来存放帧描述符...**\n\n该机制提议在堆上创建一个“影子栈”。\n-   **在任何调用（尾调用或非尾调用）时：** 在堆上分配一个代表被调用函数帧的新节点，并将其推到单向链表的头部。这是一个 $O(1)$ 时间和 $O(1)$ 空间的操作。\n-   **物理栈：** TCO 照常进行，因此对于尾调用链 $f_0 \\to \\dots \\to f_n$，物理栈大小保持为 $O(1)$，而堆上的逻辑栈增长到大小 $n+1$。\n-   **追踪生成：** 从头到尾遍历链表可以逆序重建逻辑调用历史。这是精确的。\n-   **返回/异常：** 提议的弹出“密封”帧的逻辑正确地模拟了从尾调用链返回的语义——它将逻辑栈展开到最后一个非尾调用的点。这与程序的控制流正确集成。\n\n让我们检查约束：\n1.  **正确性：** 是。链表是每个函数进入的精确、有序的日志。\n2.  **开销：** 是。推入链表头部是 $O(1)$ 时间。每个逻辑帧分配一个节点是 $O(1)$ 空间。物理栈通过 TCO 保持有界。\n3.  **兼容性：** 是。该机制可以在返回和异常展开期间与物理栈协同管理。\n\n**结论：** **正确**。这是一个标准且有效的解决方案。\n\n**B. 在调试构建中禁用尾调用优化（TCO）...**\n\n该机制提议通过消除其原因来解决问题。\n-   **机制：** 关闭 TCO 意味着每次调用，无论是尾调用还是非尾调用，都会在物理栈上推入一个新帧。物理栈 $S$ 将包含完整的调用历史 $s_{f_0}, \\dots, s_{f_n}$。\n-   **追踪生成：** 从物理栈生成的标准栈追踪将是完整和正确的。\n\n让我们检查约束：\n1.  **正确性：** 是。追踪是完全准确的。\n2.  **开销：** 否。约束声明，“...物理栈必须保持 TCO 所保证的有界性。” 禁用 TCO 直接违反了这一点。一个需要深度递归（例如处理一个长列表）的尾递归程序现在会导致栈溢出，而启用 TCO 时不会发生这种情况。这未能满足一个关键要求。\n3.  **兼容性：** 是，因为这是许多没有 TCO 的运行时的默认行为。\n\n**结论：** **不正确**。它未能满足关于物理栈使用的指定性能约束。\n\n**C. 将程序转换为连续传递风格（CPS），定义一个显式的连续体数据结构 K...**\n\n这是一种全程序转换方法。\n-   **机制：** 在 CPS 中，函数不返回。相反，它们调用另一个函数（“连续体”）并传递其结果。所有调用实际上都变成了尾调用。为防止物理栈增长，这通常通过“蹦床”机制执行，即一个反复调用连续体函数的循环。存储在堆上的嵌套连续体链明确地表示了逻辑调用栈。\n-   **追踪生成：** 通过遍历存储在堆上的连续体对象链，可以完美地重建逻辑栈追踪。\n\n让我们检查约束：\n1.  **正确性：** 是。连续体链 $K$ 是程序控制流历史的精确、具体化的表示。\n2.  **开销：** 是。蹦床机制使物理栈的深度保持在 $O(1)$。每个逻辑调用涉及在堆上分配一个新的连续体对象，这是一个 $O(1)$ 时间和 $O(1)$ 空间的操作。这符合开销预算。\n3.  **兼容性：** 是。虽然 CPS 是一个深刻的改变，但它是一种保留语义的转换。异常和返回行为可以在 CPS 框架内建模（例如，使用失败连续体）。生成的追踪与原始程序的逻辑语义一致。\n\n**结论：** **正确**。这是一个有效但更复杂的实现策略，满足所有约束。\n\n**D. 仅依赖静态调试符号和当前的栈顶帧来推断先前的尾调用...**\n\n该机制提议在追踪时使用静态分析，从而提供一个没有运行时开销的解决方案。\n-   **机制：** 当请求追踪时，调试器检查当前帧（$s_{f_n}$）及其相关的调试符号（例如，源代码位置）。然后它尝试通过分析程序的源代码或控制流图来猜测调用者。\n-   **示例：** 如果代码显示函数 $g$ 可以被 $f_A$ 和 $f_B$ 尾调用，而当前帧是 $g$ 的，那么这种方法无法在没有运行时信息的情况下确定在此次执行实例中究竟是 $f_A$ 还是 $f_B$ 是实际的调用者。\n\n让我们检查约束：\n1.  **正确性：** 否。约束要求一个“没有缺失或虚假帧”的*精确*枚举。基于静态信息的猜测从根本上是不可靠的，不能保证准确性。一个函数可能从多个不同的位置被尾调用，仅凭静态分析无法区分实际的动态调用路径。\n2.  **开销：** 是。在调用本身期间没有运行时开销。\n3.  **兼容性：** 该机制不干扰运行时语义，但其输出不可靠。\n\n**结论：** **不正确**。它严重违反了正确性约束，而这对于调试工具来说是不可协商的。", "answer": "$$\\boxed{AC}$$", "id": "3278473"}]}