{"hands_on_practices": [{"introduction": "并发垃圾收集的正确性依赖于维持诸如“初始快照”（Snapshot-At-The-Beginning, SATB）等关键不变性。然而，在实际系统中，为了性能而进行的优化（例如，数组的批量复制操作）可能会无意中绕过写屏障，从而引入微妙的并发竞态条件。本练习 [@problem_id:3630280] 旨在通过一个思想实验，让你识别一个经典的正确性漏洞及其修复方案，从而深化你对写屏障在维护并发正确性中关键作用的理解。", "problem": "考虑一个实现了“初始快照”（Snapshot-At-The-Beginning, SATB）不变性的并发标记回收器。初始快照（SATB）要求，在垃圾回收（GC）周期开始时刻 $t_0$ 可达的每个对象都必须保持标记状态，即使所有指向它的路径后来在并发阶段被修改器（mutator）移除了。确保这一点的标准方法是使用一个预写屏障（pre-write barrier），在任何指针存储操作时，将旧的引用（如果非空）入队，以便回收器最终能标记其引用的对象。\n\n假设堆是一个有向图 $G=(V,E)$，其根集合为 $\\mathcal{R}$，并让 $R(t)$ 表示在时间 $t$ 从 $\\mathcal{R}$ 可达的对象集合。假设在 $V$ 中有两个数组 $S$ 和 $D$，两者都直接从 $\\mathcal{R}$ 引用，以及一个独立的对象 $x \\in V$。在时间 $t_0$（GC 启动并发标记的时刻），假设：\n- $x \\in R(t_0)$,\n- $D[k] = x$ 对于某个索引 $k$,\n- $D[i] \\neq x$ 对于所有 $i \\neq k$，以及\n- $S[j] = y$ 对于某个索引 $j$，其中 $y \\neq x$,\n- 在 $t_0$ 时刻，除了 $D[k]$ 之外，没有其他对象引用 $x$。\n\n假设修改器在 $t_0$ 之后执行一个批量数组复制操作，将 $S$ 中的一个连续引用范围复制到 $D$ 中，包括赋值操作 $D[k] \\leftarrow S[j]$。该批量复制的实现没有在目标数组上应用逐元素的预写屏障（即，优化后的代码在写入多个元素时，不会在每个被覆盖的目标槽位上调用预屏障）。你可以假设，在修改器执行这些写入操作时，回收器的并发标记器尚未发现 $x$。\n\n基于第一性原理（$R(t)$ 的定义以及 SATB 的要求，即对于所有 $o \\in R(t_0)$，无论后续修改器如何删除引用，GC 都必须标记 $o$），请识别出在数组批量复制缺少屏障时违反 SATB 的最小修改器更新集，并选择能恢复正确性的正确屏障放置方式。“最小”是指修改器在 $t_0$ 之后进行的最少数量的指针更新，足以导致一个 $x \\in R(t_0)$ 的对象在标记结束时未被标记，从而被错误地回收。\n\n哪个选项最准确地指明了：\n- 在此场景下 $t_0$ 之后导致失败的最小修改器更新序列，以及\n- 修复该问题的最小正确屏障方案，假设分代回收器可能还需要维护一个跨代记忆集（intergenerational remembered set）？\n\nA. 一次批量复制中的目标槽位覆盖操作移除了指向 $x$ 的最后一条边：该复制执行了 $D[k] \\leftarrow S[j]$，而 $D[k]$ 是指向 $x$ 的唯一引用。如果在目标上没有逐元素的预写屏障，$x$ 就不会被入队，并可能丢失。修复方法是在每个目标槽位被覆盖之前添加一个逐元素的预写屏障，并且在目标存储之后添加一个后写屏障，以便在 $D$ 是老年代而 $S[j]$ 是新生代时维护记忆集。\n\nB. 一次批量复制只写入先前为空（null）的目标槽位（$D$ 中没有元素指向 $x$）：该复制在没有后写屏障的情况下仍然违反 SATB。修复方法是仅在目标存储后使用后写屏障。\n\nC. 批量复制之后将相应的源槽位置为 null（即，在复制后执行 $S[j] \\leftarrow \\mathrm{null}$）：如果在目标存储上放置后写屏障，可以防止 SATB 违规；不需要预屏障。\n\nD. 违反 SATB 需要两次修改器更新：首先创建一条新边 $S[j] \\leftarrow x$，然后通过批量复制覆盖 $D[k]$ 来移除 $D[k] \\leftarrow x$；只有这样 $x$ 才会丢失。修复方法是在读取侧（从 $S[j]$ 加载时）添加一个预写屏障，以便 $x$ 被入队，不需要后屏障。\n\n选择正确的选项。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **系统：** 并发标记垃圾回收器。\n- **不变性：** 初始快照（Snapshot-At-The-Beginning, SATB），要求在垃圾回收（GC）周期开始时刻 $t_0$ 可达的每个对象都必须保持标记状态。\n- **SATB 实现：** 指针存储上的预写屏障会将旧的引用（如果非空）入队。\n- **堆模型：** 一个有向图 $G=(V,E)$，其根集合为 $\\mathcal{R}$。\n- **可达集：** $R(t)$ 表示在时间 $t$ 从 $\\mathcal{R}$ 可达的对象集合。\n- **时间 $t_0$ 时的堆对象和状态：**\n    - 在 $V$ 中有两个数组 $S$ 和 $D$，两者都直接从 $\\mathcal{R}$ 引用。\n    - 一个独立的对象 $x \\in V$。\n    - $x \\in R(t_0)$。\n    - $D[k] = x$ 对于某个索引 $k$。\n    - $D[i] \\neq x$ 对于所有 $i \\neq k$。\n    - $S[j] = y$ 对于某个索引 $j$，其中 $y \\neq x$。\n    - 在 $t_0$ 时刻，除了 $D[k]$ 之外，没有其他对象引用 $x$。\n- **修改器操作（$t_0$ 之后）：**\n    - 从 $S$ 到 $D$ 的批量数组复制，包括赋值操作 $D[k] \\leftarrow S[j]$。\n    - 此批量复制在目标数组 $D$ 上执行时没有逐元素的预写屏障。\n- **回收器状态：** 当修改器执行复制时，并发标记器尚未发现或处理 $x$。\n- **任务：** 识别违反 SATB 的最小修改器更新集，并确定恢复正确性的正确屏障放置方式，同时考虑分代回收器的上下文。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述描述了并发垃圾回收上下文中的一个场景，这是编译器和运行时系统工程中一个成熟的子领域。\n\n- **科学依据：** 并发 GC、初始快照（SATB）、写屏障（预写和后写）、堆即图、可达性、分代回收和记忆集等概念在该领域都是标准和基础的。该场景描述了修改器（应用程序线程）和回收器之间的经典竞争条件，这是并发 GC 算法必须解决的核心问题。由优化的 `arraycopy` 操作省略屏障所引发的特定问题是一个已知的、现实世界中的实现挑战。\n- **良构性：** 这是一个良构问题。在时间 $t_0$ 时堆的相关部分的初始状态有精确定义。修改器的操作是具体的。失败的条件（违反 SATB 不变性）有明确说明。问题要求找出导致此失败的最小操作集及其相应的修复方法，这是对并发算法进行分析的标准形式。从前提可以推导出一个唯一的、合乎逻辑的解决方案。\n- **客观性：** 语言是技术性的、精确的，并且没有主观性。\n\n该问题不违反任何无效标准。它是一个健全且可形式化的计算机科学问题。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将推导解决方案。\n\n### 推导过程\n\n该问题要求分析一个使用初始快照（SATB）不变性的并发垃圾回收器中潜在的正确性失败。让我们从第一性原理来分析这种情况。\n\n1.  **初始状态与 SATB 要求：** 在时间 $t_0$，GC 周期开始。根据定义，所有存活对象的集合就是可达对象集 $R(t_0)$。问题陈述，在 $t_0$ 时刻，存在一个对象 $x$，从根集 $\\mathcal{R}$ 到 $x$ 的唯一路径是通过数组 $D$。具体来说，$\\mathcal{R}$ 引用 $D$，且 $D[k]=x$。因此，$x \\in R(t_0)$。SATB 不变性规定，无论修改器在 $t_0$ 之后做什么，回收器*必须*在标记阶段结束前标记 $x$。\n\n2.  **修改器操作及其后果：** 在 $t_0$ 之后，修改器执行一次批量数组复制。该操作包括存储 $D[k] \\leftarrow S[j]$。我们已知 $S[j]=y$ 且 $y \\neq x$。这个存储操作用一个指向 $y$ 的引用覆盖了 $D[k]$ 中指向 $x$ 的引用。由于 $D[k]$ 是从任何可达对象指向 $x$ 的唯一引用，这次存储之后，$x$ 变得不可达。在此次存储之后的任何时间 $t$，可达对象集 $R(t)$ 将不再包含 $x$。\n\n3.  **回收器与屏障的交互：** 一个标准的 SATB 实现使用预写屏障。这个屏障会在对 $D[k]$ 进行存储之前执行。它会检查被覆盖的值，即指向 $x$ 的指针。由于该指针非空，屏障会记录这个指针，例如，将其推入 GC 标记队列。这确保了即使该引用从堆中被移除，回收器仍然有 $x$ 的记录，并最终会标记它。\n\n4.  **失败场景：** 问题明确指出，批量复制操作是经过优化的，并且*没有*为每个元素执行这个预写屏障。当存储操作 $D[k] \\leftarrow y$ 发生时，旧值（指向 $x$ 的指针）在没有被记录的情况下被丢弃。我们还被告知，回收器的并发标记器尚未扫描 $D$ 以找到对 $x$ 的引用。当标记器最终扫描 $D$ 时，它将看到*新的*状态：$D[k]=y$。标记器随后会去标记 $y$（如果尚未标记）。标记器将永远不会发现存在于 $t_0$ 时刻的、对 $x$ 的原始引用。因为没有其他路径指向 $x$，$x$ 将永远不会被标记。在标记阶段结束时，回收器执行清除阶段，回收所有未标记的对象。由于 $x$ 未被标记，它将被错误地回收。这直接违反了 SATB 不变性，因为 $x \\in R(t_0)$ 但未被标记。\n\n5.  **最小失败序列：** 导致失败的事件序列是：a. GC 在 $t_0$ 开始。$x$ 是存活的，仅能通过 $D[k]$ 访问。b. 修改器执行单个指针存储 $D[k] \\leftarrow y$，没有预写屏障。c. 回收器尚未处理引用 $D[k] \\rightarrow x$。这单个指针更新就足以导致失败。因此，最小的修改器更新集只包含一个更新。\n\n6.  **正确的修复方法：**\n    - **对于 SATB：** 为防止违规，必须让回收器知道对象 $x$ 的存在。这需要在 $D[k]$ 的值被覆盖*之前*捕获它。实现此目的的机制是**预写屏障**。对于批量复制，这个屏障必须应用于每个被覆盖的目标槽位。\n    - **对于分代 GC：** 问题引入了分代回收器的复杂性。在此类系统中，使用**记忆集**来跟踪从老年代指向新生代的指针。这是为了在不扫描整个老年代的情况下回收新生代。如果一个老年代对象（例如 $D$）被修改为指向一个新生代对象（例如 $y$），这个新的从老到新的指针必须被记录在记忆集中。这个检查和记录必须在知道新值*之后*发生。这是**后写屏障**的功能。因此，在一个既是并发的（使用 SATB）又是分代的系统中，一个完整的指针存储屏障方案通常需要两者：用于并发正确性（SATB）的预写屏障和用于分代记账（记忆集）的后写屏障。\n\n### 逐项分析选项\n\n**A. 一次批量复制中的目标槽位覆盖操作移除了指向 $x$ 的最后一条边：该复制执行了 $D[k] \\leftarrow S[j]$，而 $D[k]$ 是指向 $x$ 的唯一引用。如果在目标上没有逐元素的预写屏障，$x$ 就不会被入队，并可能丢失。修复方法是在每个目标槽位被覆盖之前添加一个逐元素的预写屏障，并且在目标存储之后添加一个后写屏障，以便在 $D$ 是老年代而 $S[j]$ 是新生代时维护记忆集。**\n- **失败序列：** 这正确地指出了单个更新是最小序列。\n- **失败原因：** 关于缺失的预写屏障导致旧引用（$x$）未能入队的解释是完全正确的。\n- **修复方法：** 提议的修复方法是全面且正确的。它指明了 SATB 所需的预写屏障和分代记忆集所需的后写屏障，如上文推导所得。\n- **结论：正确**\n\n**B. 一次批量复制只写入先前为空（null）的目标槽位（$D$ 中没有元素指向 $x$）：该复制在没有后写屏障的情况下仍然违反 SATB。修复方法是仅在目标存储后使用后写屏障。**\n- 这个选项改变了前提。如果一个目标槽位是 `null`，覆盖它并不会从 $R(t_0)$ 中移除对一个对象的引用。因此，初始快照中的对象不会变得不可达，SATB 不变性首先就不会被违反。声称此操作违反 SATB 是错误的。此外，它错误地暗示后写屏障可以修复 SATB 问题。\n- **结论：错误**\n\n**C. 批量复制之后将相应的源槽位置为 null（即，在复制后执行 $S[j] \\leftarrow \\mathrm{null}$）：如果在目标存储上放置后写屏障，可以防止 SATB 违规；不需要预屏障。**\n- SATB 违规是由覆盖 $D[k]$ 引起的，而不是由之后对 $S$ 的任何操作引起的。将源槽位置为 null 与核心问题无关。声称后写屏障可以防止违规并且不需要预写屏障是根本错误的。后写屏障作用于新值，无法恢复 SATB 所需的已丢失的旧值。\n- **结论：错误**\n\n**D. 违反 SATB 需要两次修改器更新：首先创建一条新边 $S[j] \\leftarrow x$，然后通过批量复制覆盖 $D[k]$ 来移除 $D[k] \\leftarrow x$；只有这样 $x$ 才会丢失。修复方法是在读取侧（从 $S[j]$ 加载时）添加一个预写屏障，以便 $x$ 被入队，不需要后屏障。**\n- 这个选项错误地声称需要两次更新。如前所述，一次更新就足够了。提议的序列 $S[j] \\leftarrow x$ 后跟 $D[k] \\leftarrow S[j]$ 将导致 $D[k]$ 仍然指向 $x$，这不会导致问题。这个选项错误地描述了最小失败序列。提议的修复方法，“读取侧的预写屏障”，在概念上是混乱的；它似乎指的是读屏障，而这不是解决此 SATB 问题的标准方案。问题在于写入，所以需要写屏障。\n- **结论：错误**", "answer": "$$\\boxed{A}$$", "id": "3630280"}, {"introduction": "在理解了写屏障对于维护SATB不变性的重要性之后，下一个自然的步骤是将其付诸实践。这个练习 [@problem_id:3630316] 提供了一个具体的对象图和一个并发修改序列，你的任务是确定哪些对象最终会被标记为存活。通过这个练习，你将亲身体会到SATB的核心思想：最终的标记集合仅取决于标记周期开始时的“快照”，而与并发执行期间的变化无关。", "problem": "一个支持自动内存管理的语言的运行时实现了一个并发跟踪垃圾回收器，该回收器使用了初始快照（Snapshot-At-The-Beginning, SATB）写屏障。SATB 写屏障定义如下：对于任何指针存储操作，当一个字段 $X.f$ 的值从旧值 $Y_{\\text{old}}$ 被覆盖为新值 $Y_{\\text{new}}$（其中 $Y_{\\text{new}}$ 可能为 $\\varnothing$）时，写屏障会将 $Y_{\\text{old}}$ 入队到一个缓冲区中，并发标记器会排空该缓冲区。这确保了在回收开始时任何可达的对象最终都会被标记，即使修改器（mutator）在标记阶段移除了指向该对象的唯一边。假设在标记阶段的开始和结束之间没有对象分配发生。\n\n考虑在标记开始时间 $t_0$ 的对象图。对象集合为 $V = \\{ O_1, O_2, O_3, O_4, O_5, O_6, O_7, O_8 \\}$，根集合为 $\\mathcal{R} = \\{ O_1 \\}$。在 $t_0$ 时的邻接表为：\n- $O_1 : \\{ O_2, O_3 \\}$，\n- $O_2 : \\{ O_5 \\}$，\n- $O_3 : \\{ O_5, O_6 \\}$，\n- $O_4 : \\{ O_7 \\}$，\n- $O_5 : \\varnothing$，\n- $O_6 : \\{ O_8 \\}$，\n- $O_7 : \\varnothing$，\n- $O_8 : \\varnothing$。\n\n在并发标记期间，修改器执行了以下指针更新，每次更新都会触发 SATB 写屏障，将旧目标入队到 SATB 缓冲区：\n1. 在 $O_1$ 中，一个指向 $O_3$ 的字段被覆盖为指向 $O_7$；旧目标入队：$O_3$。\n2. 在 $O_3$ 中，一个指向 $O_6$ 的字段被覆盖为 $\\varnothing$；旧目标入队：$O_6$。\n3. 在 $O_2$ 中，一个指向 $O_5$ 的字段被覆盖为指向 $O_6$；旧目标入队：$O_5$。\n4. 在 $O_6$ 中，一个指向 $O_8$ 的字段被覆盖为 $\\varnothing$；旧目标入队：$O_8$。\n5. 在 $O_1$ 中，一个指向 $O_2$ 的字段被覆盖为 $\\varnothing$；旧目标入队：$O_2$。\n\n从有向图中可达性的基本定义以及上述 SATB 屏障的保证出发，重构在 $t_0$ 时的概念性 SATB 快照，并推导出最终的标记集，该标记集为快照中从根集合 $\\mathcal{R}$ 可达的所有对象的集合，而无需考虑后续修改器的更新。将最终标记集编码为一个无符号8位整型位掩码，其中第 $i$ 位（从 $i=1$ 作为最低有效位开始计数）为 $1$ 当且仅当 $O_i$ 在最终标记集中，否则为 $0$。提供该位掩码的十进制整数值。无需四舍五入。", "solution": "本题要求确定一个采用初始快照（SATB）写屏障的并发垃圾回收器的最终标记集。\n\nSATB 回收器的基本原理是保证在标记阶段开始时（时间 $t_0$）从根集合可达的每个对象都将被视为存活对象并且不会被回收。这是通过在 $t_0$ 时刻创建对象图的一个概念性“快照”来实现的。在修改器进行并发修改的情况下，写屏障有助于维持这一保证。具体来说，当一个指针被覆盖时，SATB 屏障会记录*旧*值（即即将通过该特定路径变得不可达的对象）。然后，回收器进程会确保这个被记录的对象也被追踪，从而有效地保留了在 $t_0$ 时刻存在的可达性图。\n\n因此，在 SATB 保证下寻找最终标记集的问题，等价于在时间 $t_0$ 的初始对象图中，寻找从根集合 $\\mathcal{R}$ 可达的所有对象的集合。题目描述中的并发修改器行为是回收器实现其保证的机制，但它们不会改变最终结果，最终结果仅由初始快照决定。\n\n给定的已知条件如下：\n- 所有对象的集合 $V = \\{ O_1, O_2, O_3, O_4, O_5, O_6, O_7, O_8 \\}$。\n- 根集合 $\\mathcal{R} = \\{ O_1 \\}$。\n- 时间 $t_0$ 的对象图，由邻接表定义：\n  - $O_1 \\to \\{ O_2, O_3 \\}$\n  - $O_2 \\to \\{ O_5 \\}$\n  - $O_3 \\to \\{ O_5, O_6 \\}$\n  - $O_4 \\to \\{ O_7 \\}$\n  - $O_5 \\to \\varnothing$\n  - $O_6 \\to \\{ O_8 \\}$\n  - $O_7 \\to \\varnothing$\n  - $O_8 \\to \\varnothing$\n\n我们必须在此图上找到从根集合 $\\mathcal{R}$ 开始的可达性关系的传递闭包。这可以通过图遍历算法（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）来完成。设 $M$ 为已标记（可达）对象的集合， $Q$ 为待访问对象的工作列表（队列）。\n\n1.  使用根集合进行初始化：\n    - $M = \\{ O_1 \\}$\n    - $Q = [O_1]$\n\n2.  从队列中取出 $O_1$。其邻居为 $O_2$ 和 $O_3$。由于它们不在 $M$ 中，将它们加入。\n    - $M = \\{ O_1, O_2, O_3 \\}$\n    - $Q = [O_2, O_3]$\n\n3.  从队列中取出 $O_2$。其邻居为 $O_5$。由于 $O_5$ 不在 $M$ 中，将其加入。\n    - $M = \\{ O_1, O_2, O_3, O_5 \\}$\n    - $Q = [O_3, O_5]$\n\n4.  从队列中取出 $O_3$。其邻居为 $O_5$ 和 $O_6$。$O_5$ 已经在 $M$ 中。$O_6$ 不在 $M$ 中，因此将其加入。\n    - $M = \\{ O_1, O_2, O_3, O_5, O_6 \\}$\n    - $Q = [O_5, O_6]$\n\n5.  从队列中取出 $O_5$。它没有邻居。\n    - $M = \\{ O_1, O_2, O_3, O_5, O_6 \\}$\n    - $Q = [O_6]$\n\n6.  从队列中取出 $O_6$。其邻居为 $O_8$。由于 $O_8$ 不在 $M$ 中，将其加入。\n    - $M = \\{ O_1, O_2, O_3, O_5, O_6, O_8 \\}$\n    - $Q = [O_8]$\n\n7.  从队列中取出 $O_8$。它没有邻居。\n    - $M = \\{ O_1, O_2, O_3, O_5, O_6, O_8 \\}$\n    - $Q = []$\n\n队列现已为空，遍历完成。在时间 $t_0$ 时从根 $O_1$ 可达的所有对象的集合为 $M = \\{ O_1, O_2, O_3, O_5, O_6, O_8 \\}$。对象 $O_4$ 和 $O_7$ 从 $\\mathcal{R}$ 不可达，不会被标记。\n\n题目要求将此最终标记集编码为一个无符号8位整型位掩码，其中第 $i$ 位（以第1位为最低有效位 LSB）为1，当且仅当 $O_i$ 被标记，否则为0。该位掩码表示为 $(b_8 b_7 b_6 b_5 b_4 b_3 b_2 b_1)_2$。\n\n- $O_1 \\in M \\implies b_1 = 1$\n- $O_2 \\in M \\implies b_2 = 1$\n- $O_3 \\in M \\implies b_3 = 1$\n- $O_4 \\notin M \\implies b_4 = 0$\n- $O_5 \\in M \\implies b_5 = 1$\n- $O_6 \\in M \\implies b_6 = 1$\n- $O_7 \\notin M \\implies b_7 = 0$\n- $O_8 \\in M \\implies b_8 = 1$\n\n得到的二进制位掩码为 $10110111_2$。为求其十进制值，我们将值为1的位所对应的2的幂相加：\n$$\n\\text{值} = 1 \\cdot 2^{8-1} + 0 \\cdot 2^{7-1} + 1 \\cdot 2^{6-1} + 1 \\cdot 2^{5-1} + 0 \\cdot 2^{4-1} + 1 \\cdot 2^{3-1} + 1 \\cdot 2^{2-1} + 1 \\cdot 2^{1-1}\n$$\n$$\n\\text{值} = 1 \\cdot 2^7 + 0 \\cdot 2^6 + 1 \\cdot 2^5 + 1 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0\n$$\n$$\n\\text{值} = 1 \\cdot 128 + 0 \\cdot 64 + 1 \\cdot 32 + 1 \\cdot 16 + 0 \\cdot 8 + 1 \\cdot 4 + 1 \\cdot 2 + 1 \\cdot 1\n$$\n$$\n\\text{值} = 128 + 32 + 16 + 4 + 2 + 1 = 183\n$$\n该位掩码的十进制整数值为 $183$。", "answer": "$$\n\\boxed{183}\n$$", "id": "3630316"}, {"introduction": "尽管读写屏障和安全点对于保证并发GC的正确性至关重要，但它们并非没有代价。每一次屏障或安全点的执行都会消耗CPU周期，从而对应用程序的整体吞吐量产生影响。本练习 [@problem_id:3630279] 引导你建立一个性能开销的一阶模型，量化这些机制所带来的吞吐量损失，帮助你理解在设计和调优并发GC时所面临的性能权衡。", "problem": "一个单线程的 mutator（执行程序）在一个并发垃圾回收 (GC) 算法下运行，该算法使用初始快照 (Snapshot-At-The-Beginning, SATB) 预写屏障和 Brooks 风格的间接读屏障来维护三色不变性。系统通过周期的全局暂停 (stop-the-world, STW) 安全点与回收器进行协调。考虑一个一阶模型，其中屏障的开销足够小，不会干扰 mutator 的基准事件率。\n\n基本原理：\n- 吞吐量损失是指在测量窗口内，用于 GC 相关开销而不是基准 mutator 执行的时间所占的比例。根据独立开销源的可加性，总开销时间是每个事件的成本乘以事件计数的总和。\n- 在一个时间窗口内的预期事件计数，是通过将期望的线性性应用于基准率和独立事件概率得出的。\n\n假设在一个持续时间为 $T$ 秒的窗口内，具有以下可测量的基准属性：\n- mutator 每秒完成 $\\nu$ 条指令。取 $\\nu = 2.5 \\times 10^{9}$ 且 $T = 10$。\n- 指令中有 $f_{m}$ 的比例是内存操作，其中 $f_{m} = 0.32$。在内存操作中，有 $\\ell = 0.68$ 的比例是加载操作，有 $\\sigma = 0.32$ 的比例是存储操作。\n- 在加载操作中，加载的值是指针的概率是 $\\theta_{r} = 0.55$。在存储操作中，存储的值是指针的概率是 $\\theta_{w} = 0.35$。\n- 读屏障在每次读取指针时执行，SATB 预写屏障在每次写入指针时执行。\n- STW 安全点每隔 $\\Delta$ 秒被周期性请求，其中 $\\Delta = 0.25$。\n\n设每个事件的归一化成本定义如下：$\\alpha$、$\\beta$ 和 $\\gamma$ 是无量纲系数，分别等于写屏障、读屏障和安全点的单次事件时间成本除以 $T$。取 $\\alpha = 3.2 \\times 10^{-11}$，$\\beta = 1.8 \\times 10^{-11}$，以及 $\\gamma = 1.1 \\times 10^{-6}$。\n\n任务：\n1. 从第一性原理出发，推导在持续时间为 $T$ 的窗口内，写屏障命中次数 $W$、读屏障执行次数 $R$ 和安全点次数 $S$ 的预期计数表达式，用 $\\nu$、 $f_{m}$、 $\\ell$、 $\\sigma$、 $\\theta_{r}$、 $\\theta_{w}$、 $T$ 和 $\\Delta$ 表示。\n2. 根据吞吐量损失 $O$ 是窗口中用于开销的时间比例的定义，以及每个事件成本的可加性，推导出仿射形式 $O = \\alpha W + \\beta R + \\gamma S$，并使用给定的归一化系数。然后，使用上述参数值对 $O$ 进行数值计算。将最终数值结果四舍五入至四位有效数字，并以纯数字（无单位）形式报告。", "solution": "该问题定义明确，具有科学依据，且内部一致。进行垃圾回收开销一阶分析所需的所有参数均已提供。该模型基于独立事件源成本的线性可加性，是性能评估的标准有效方法。因此，我们可以着手求解。\n\n根据题目要求，解题过程分为两部分。首先，我们推导预期事件计数的表达式。其次，我们推导吞吐量损失的形式并计算其数值。\n\n**1. 预期事件计数（$W$、$R$ 和 $S$）的推导**\n\n分析基于一个持续时间为 $T$ 的测量窗口。基本原理是，一个事件的预期计数是其平均速率乘以观测窗口的持续时间。与内存相关的事件的速率由 mutator 的指令完成率 $\\nu$ 导出。\n\nmutator 在时长为 $T$ 秒的窗口内完成的总指令数是：\n$$N_{inst} = \\nu T$$\n\n-   这些指令中有 $f_{m}$ 的比例是内存操作。内存操作的总数是：\n    $$N_{mem} = f_{m} N_{inst} = \\nu T f_{m}$$\n\n-   内存操作由加载和存储组成。其中 $\\ell$ 的比例是加载，$\\sigma$ 的比例是存储。加载操作的总数是：\n    $$N_{load} = \\ell N_{mem} = \\nu T f_{m} \\ell$$\n-   存储操作的总数是：\n    $$N_{store} = \\sigma N_{mem} = \\nu T f_{m} \\sigma$$\n    注意，这些比例是一致的，因为 $\\ell + \\sigma = 0.68 + 0.32 = 1$。\n\n**写屏障命中次数的预期计数 ($W$)**\n初始快照 (Snapshot-At-The-Beginning, SATB) 预写屏障在每次写入指针时执行。指针写入是指存储的值是指针的存储操作。问题陈述，在存储操作中，存储的值是指针的概率是 $\\theta_{w}$。因此，写屏障命中的预期次数 $W$ 是总存储操作数乘以这个概率：\n$$W = N_{store} \\times \\theta_{w} = (\\nu T f_{m} \\sigma) \\theta_{w}$$\n$$W = \\nu T f_{m} \\sigma \\theta_{w}$$\n\n**读屏障执行次数的预期计数 ($R$)**\n读屏障在每次读取指针时执行。指针读取是指加载的值是指针的加载操作。问题给出的加载值是指针的概率是 $\\theta_{r}$。因此，读屏障执行的预期次数 $R$ 是总加载操作数乘以这个概率：\n$$R = N_{load} \\times \\theta_{r} = (\\nu T f_{m} \\ell) \\theta_{r}$$\n$$R = \\nu T f_{m} \\ell \\theta_{r}$$\n\n**安全点次数的预期计数 ($S$)**\n安全点每隔 $\\Delta$ 秒周期性触发。在总持续时间为 $T$ 的时间窗口内，这样的周期数是 $T / \\Delta$。每个周期结束时会发生一次安全点。对于给定的值 $T = 10$ 和 $\\Delta = 0.25$，比率 $T/\\Delta = 40$ 是一个整数，所以安全点的数量恰好是这个值。一般情况下，这个数字应为 $\\lfloor T/\\Delta \\rfloor$，但根据上下文，确定性计数为：\n$$S = \\frac{T}{\\Delta}$$\n\n以上就是 $W$、$R$ 和 $S$ 所需的表达式。\n\n**2. 吞吐量损失 ($O$) 的推导与评估**\n\n吞吐量损失 $O$ 被定义为测量窗口中用于 GC 相关开销的时间所占的比例。总开销时间是花在每种类型开销事件上的时间之和。设 $C_W$、$C_R$ 和 $C_S$ 分别为单个写屏障、读屏障和安全点的绝对时间成本。\n\n总开销时间是事件计数与其单次事件成本乘积的总和：\n$$T_{overhead} = W C_W + R C_R + S C_S$$\n\n吞吐量损失 $O$ 是这个总开销时间除以总窗口持续时间 $T$：\n$$O = \\frac{T_{overhead}}{T} = \\frac{W C_W + R C_R + S C_S}{T}$$\n\n问题提供了无量纲的归一化成本 $\\alpha$、$\\beta$ 和 $\\gamma$，定义为单次事件的时间成本除以 $T$。即：\n$$\\alpha = \\frac{C_W}{T}, \\quad \\beta = \\frac{C_R}{T}, \\quad \\gamma = \\frac{C_S}{T}$$\n将这些定义代入 $O$ 的表达式中：\n$$O = W \\left(\\frac{C_W}{T}\\right) + R \\left(\\frac{C_R}{T}\\right) + S \\left(\\frac{C_S}{T}\\right)$$\n$$O = \\alpha W + \\beta R + \\gamma S$$\n这证实了问题陈述中提供的仿射形式。\n\n现在，我们将推导出的 $W$、$R$ 和 $S$ 的表达式代入此公式：\n$$O = \\alpha (\\nu T f_{m} \\sigma \\theta_{w}) + \\beta (\\nu T f_{m} \\ell \\theta_{r}) + \\gamma \\left(\\frac{T}{\\Delta}\\right)$$\n\n我们使用给定的参数值进行数值评估：\n-   $\\nu = 2.5 \\times 10^{9}$ s$^{-1}$\n-   $T = 10$ s\n-   $f_{m} = 0.32$\n-   $\\ell = 0.68$\n-   $\\sigma = 0.32$\n-   $\\theta_{r} = 0.55$\n-   $\\theta_{w} = 0.35$\n-   $\\Delta = 0.25$ s\n-   $\\alpha = 3.2 \\times 10^{-11}$\n-   $\\beta = 1.8 \\times 10^{-11}$\n-   $\\gamma = 1.1 \\times 10^{-6}$\n\n首先，我们计算预期计数 $W$、$R$ 和 $S$ 的数值：\n$$W = (2.5 \\times 10^{9}) \\times 10 \\times 0.32 \\times 0.32 \\times 0.35 = 8.96 \\times 10^{8}$$\n$$R = (2.5 \\times 10^{9}) \\times 10 \\times 0.32 \\times 0.68 \\times 0.55 = 2.992 \\times 10^{9}$$\n$$S = \\frac{10}{0.25} = 40$$\n\n接下来，我们计算总吞吐量损失 $O$ 的三个组成部分：\n-   写屏障损失：$O_W = \\alpha W = (3.2 \\times 10^{-11}) \\times (8.96 \\times 10^{8}) = 0.028672$\n-   读屏障损失：$O_R = \\beta R = (1.8 \\times 10^{-11}) \\times (2.992 \\times 10^{9}) = 0.053856$\n-   安全点损失：$O_S = \\gamma S = (1.1 \\times 10^{-6}) \\times 40 = 0.000044$\n\n总吞吐量损失是这些组成部分的总和：\n$$O = O_W + O_R + O_S = 0.028672 + 0.053856 + 0.000044 = 0.082572$$\n\n问题要求将最终结果四舍五入到四位有效数字。\n$$O \\approx 0.08257$$\n这表示总吞吐量损失约为 $8.257\\%$。", "answer": "$$\\boxed{0.08257}$$", "id": "3630279"}]}