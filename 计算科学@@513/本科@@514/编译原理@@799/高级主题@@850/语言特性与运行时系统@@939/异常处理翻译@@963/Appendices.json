{"hands_on_practices": [{"introduction": "在着手翻译异常处理之前，我们必须先理解它在运行时的处理过程。这项练习将指导你实现一个简化的栈回溯模拟器[@problem_id:3641466]，通过模拟系统如何利用调用点表 (call-site tables) 逐帧搜索处理器，你将对编译器输出必须支持的底层机制有一个具体而深入的认识。", "problem": "要求您从编译器设计的基本原理出发，实现一个使用调用点表的异常处理栈展开的确定性模拟。该模拟必须以一个完整、可运行的程序来表达。程序将遍历一个模拟的调用栈，并使用调用点表条目来决定一个帧是提供匹配的处理程序、仅提供清理，还是不执行任何操作。此任务的重点是将异常处理语义逻辑地转换为一个表驱动的遍历器，而不是关注任何特定编程语言的运行时。\n\n推导的基本基础是以下一组来自编译器原理的概念：\n- 异常代表某种类型的值，用符号 $\\tau$ 表示。\n- 调用栈由通过整数索引的帧组成，其中更深的帧具有更大的索引。设总帧数（深度）为 $d$，帧的索引为 $i \\in \\{0,1,\\dots,d-1\\}$，其中 $i=0$ 表示基帧，$i=d-1$ 表示最深的帧。\n- 每个帧 $i$ 都有一个调用点表 $T_i$，该表由将指令地址区间映射到操作的条目组成。每个条目是一个四元组 $(a, \\ell, k, S)$，表示：起始地址 $a$、长度 $\\ell$、操作类型 $k$（属于 $\\{0,1,2\\}$）以及一组处理程序类型 $S$。操作类型 $k$ 的解释如下：$k=0$ 表示无操作，$k=1$ 表示仅清理操作，$k=2$ 表示捕获操作，其允许的处理程序类型为 $S$。\n- 展开语义：给定一个起始帧索引为 $p$ 的抛出点和每个帧 $i$ 的指令指针值 $x_i$，遍历器从 $i=p$ 向下进行到 $i=0$。在每个帧 $i$ 中，它找到 $T_i$ 中唯一的条目 $(a,\\ell,k,S)$，其区间 $[a,a+\\ell)$ 包含 $x_i$。如果 $k=2$ 且 $\\tau \\in S$，则搜索停止，控制权转移到帧 $i$ 中的处理程序。否则，如果 $k=1$ 或 $k=0$，遍历器继续到下一个帧 $i-1$。展开的帧数定义为停止前弹出的帧的数量；如果在帧 $i$ 中找到处理程序，弹出的帧为 $p, p-1, \\dots, i+1$，其数量为 $p-i$。如果没有找到处理程序，当遍历完从 $p$ 到 $0$ 的所有帧后，展开的帧数等于 $p+1$。\n\n您必须为一个特定的、确定性的调用点表族实现这个遍历器。对于每个帧 $i \\in \\{0,1,\\dots,d-1\\}$，调用点表 $T_i$ 恰好有三个条目，划分了地址空间 $[0,100)$:\n- 条目 $j=0$ 具有 $(a=0,\\ell=30)$，如果 $i \\bmod 3=0$，则 $k=2$ 且 $S=\\{i \\bmod 5,(i+1) \\bmod 5\\}$，否则 $k=0$ 且 $S=\\varnothing$。\n- 条目 $j=1$ 具有 $(a=30,\\ell=40)$，如果 $i$ 是偶数，则 $k=1$（仅清理），否则 $k=0$；所有清理条目的 $S=\\varnothing$。\n- 条目 $j=2$ 具有 $(a=70,\\ell=30)$，则 $k=2$ 且 $S=\\{(i+2) \\bmod 5\\}$。\n\n给定一个抛出的类型 $\\tau$、一个起始索引 $p$ 以及每个帧的指令指针 $x_i$，遍历器必须应用上述语义来计算展开的帧的整数数量。\n\n您的程序必须完全按照上述表构造规则实现此遍历器，并为以下测试套件生成结果。所有参数和数字都是固定的，必须嵌入程序中；程序不得读取任何输入。\n\n测试套件：\n- 测试用例 1（通用成功路径）：$d=10$, $p=9$, $\\tau=3$，且对于所有 $i \\in \\{0,1,\\dots,9\\}$，$x_i=75$。\n- 测试用例 2（不存在处理程序）：$d=10$, $p=9$, $\\tau=0$，且对于所有 $i \\in \\{0,1,\\dots,9\\}$，$x_i=35$。\n- 测试用例 3（从基帧开始的边界情况）：$d=10$, $p=0$, $\\tau=2$，且对于所有 $i \\in \\{0,1,\\dots,9\\}$，$x_i=75$。\n- 测试用例 4（混合清理后接处理程序）：$d=10$, $p=9$, $\\tau=1$，其中 $x_9=35$, $x_8=35$, $x_7=35$, $x_6=15$，且对于所有 $i \\in \\{0,1,\\dots,5\\}$，$x_i=15$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述测试用例顺序排列的、用方括号括起来的逗号分隔列表的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是测试用例 $k$ 的整数结果。\n\n此问题不涉及物理单位或角度单位。所有输出都必须是整数。程序必须是自包含的，并且无需任何输入即可运行。", "solution": "该问题要求我们模拟一个由表驱动的栈展开过程，并计算四个特定测试用例中展开（弹出）的帧数。我们将逐个分析每个用例。\n\n**测试用例 1：** $d=10, p=9, \\tau=3$，所有 $x_i=75$。\n搜索从帧 $i=9$ 开始向下进行。对于 $x_i=75$，我们使用地址区间 $[70, 100)$ 的规则，即操作类型 $k=2$（捕获）且处理程序类型集 $S=\\{(i+2) \\bmod 5\\}$。我们需要找到一个使 $\\tau=3$ 在 $S$ 中的帧 $i$，即需要满足 $(i+2) \\bmod 5 = 3$。\n- $i=9: (9+2) \\bmod 5 = 1$。不匹配。\n- $i=8: (8+2) \\bmod 5 = 0$。不匹配。\n- $i=7: (7+2) \\bmod 5 = 4$。不匹配。\n- $i=6: (6+2) \\bmod 5 = 3$。**匹配**。\n处理程序在帧 $i=6$ 中找到。根据定义，展开的帧是 $9, 8, 7$。展开的帧数为 $p-i = 9-6 = 3$。\n\n**测试用例 2：** $d=10, p=9, \\tau=0$，所有 $x_i=35$。\n搜索从帧 $i=9$ 开始向下进行。对于 $x_i=35$，我们使用地址区间 $[30, 70)$ 的规则。此规则仅产生 $k=1$（仅清理，如果 $i$ 是偶数）或 $k=0$（无操作，如果 $i$ 是奇数），从不产生 $k=2$（捕获）。因此，搜索将遍历所有帧直到 $i=0$ 而找不到处理程序。\n根据规则，如果没有找到处理程序，展开的帧数等于 $p+1$。\n数量为 $9+1 = 10$。\n\n**测试用例 3：** $d=10, p=0, \\tau=2$，所有 $x_i=75$。\n搜索从帧 $p=0$ 开始，只检查帧 $i=0$。\n对于 $x_0=75$，我们使用地址区间 $[70, 100)$ 的规则：$k=2$ 且 $S=\\{(0+2) \\bmod 5\\} = \\{2\\}$。\n由于抛出的异常类型 $\\tau=2$，我们有 $\\tau \\in S$。**匹配**。\n处理程序在起始帧 $i=0$ 中找到。没有帧被展开。展开的帧数为 $p-i = 0-0 = 0$。\n\n**测试用例 4：** $d=10, p=9, \\tau=1$，其中 $x_9=35, x_8=35, x_7=35, x_6=15$，其余 $x_i=15$。\n搜索从帧 $i=9$ 开始向下进行。\n- $i=9$: $x_9=35$ (在 $[30, 70)$ 区间)。因为 $i=9$ 是奇数，所以 $k=0$（无操作）。继续。\n- $i=8$: $x_8=35$ (在 $[30, 70)$ 区间)。因为 $i=8$ 是偶数，所以 $k=1$（仅清理）。继续。\n- $i=7$: $x_7=35$ (在 $[30, 70)$ 区间)。因为 $i=7$ 是奇数，所以 $k=0$（无操作）。继续。\n- $i=6$: $x_6=15$ (在 $[0, 30)$ 区间)。因为 $i=6$，所以 $i \\bmod 3 = 0$。我们使用此区间的规则：$k=2$ 且 $S = \\{i \\bmod 5, (i+1) \\bmod 5\\} = \\{6 \\bmod 5, 7 \\bmod 5\\} = \\{1, 2\\}$。\n由于抛出的异常类型 $\\tau=1$，我们有 $\\tau \\in S$。**匹配**。\n处理程序在帧 $i=6$ 中找到。展开的帧是 $9, 8, 7$。展开的帧数为 $p-i = 9-6 = 3$。", "answer": "$$\\boxed{[3, 10, 0, 3]}$$", "id": "3641466"}, {"introduction": "`finally` 子句保证了无论 `try` 块如何退出，其代码都将被执行，这为编译器带来了有趣的控制流难题，尤其是在遇到提前 `return` 语句时。这项练习要求你辨别出正确的底层中间表示[@problem_id:3641508]，迫使你思考如何跨越一个共享的清理代码块来管理状态（例如预期的返回值和目标地址）。", "problem": "一种用于支持结构化异常处理的高级语言的编译器，必须翻译一种将在 `try` 块内的提前 `return` 与 `finally` 子句相结合的构造。`try-finally` 的语义定义是以下基本原则：在从受保护区域的任何退出（正常执行到底、`return`、`break`、`continue` 或异常）时，`finally` 块都必须且仅执行一次，之后控制流会像原退出发生时那样继续，除非 `finally` 块自身抛出异常，此时该异常将取代先前的退出。\n\n考虑以下源过程，其中 `cleanup` 可能会抛出异常：\n\n```c\nint g(int x) {\n  try {\n    if (x  0) return -1;\n    x = x + 1;\n  } finally {\n    cleanup(x);\n  }\n  return x;\n}\n```\n\n编译器会将其降级为一种低级中间表示（IR），该中间表示包含显式标签 $L_{\\cdot}$、无条件分支 `goto`、条件分支 `if(·) goto` 和 `return` 语句。该 IR 还具有简单的三地址赋值 `:=`, 一个布尔标志 $f \\in \\{0,1\\}$（除非另有说明，否则初始化为 $0$），以及一个用于保存待定返回值的整型临时变量 $r$。调用（例如 `cleanup(x)`）可能会抛出异常；如果调用抛出异常，控制流不会执行该块中后续的 IR 指令。IR 中没有隐式的异常处理：在 `cleanup` 期间抛出的异常会立即传播并中止本地控制流；它们不会在此函数中被捕获。\n\n您的任务是确定以下哪个候选翻译正确地执行了上述语义。具体来说，一个正确的翻译必须确保：\n- 如果 `try` 块内的路径执行了提前 `return`，`finally` 块会且仅执行一次，然后函数返回指定的值，除非 `cleanup` 抛出异常，在这种情况下，异常会逃逸而不是返回。\n- 如果 `try` 块内的路径正常执行到底，`finally` 块会且仅执行一次，然后控制流返回最终的 `x` 值，除非 `cleanup` 抛出异常，在这种情况下，异常会逃逸。\n- 没有任何路径会执行 `cleanup` 超过一次，也没有任何路径会跳过 `cleanup`。\n\n假设 $f$ 和 $r$ 是未在别处使用的新临时变量。选择正确的翻译。\n\n选项 A:\nL0:\n  f := 0;\n  if (x  0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  if (f == 1) goto Lret; else goto Lnorm;\nLret:\n  return r;\nLnorm:\n  return x;\n\n选项 B:\nL0:\n  f := 0;\n  if (x  0) goto Lret; else goto Linc;\nLret:\n  r := -1;\n  return r;\nLinc:\n  x := x + 1;\n  cleanup(x);\n  return x;\n\n选项 C:\nL0:\n  f := 0;\n  if (x  0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  return x;\n\n选项 D:\nL0:\n  f := 0;\n  if (x  0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  return r;\n\n哪个选项在所有执行路径上（包括当 `cleanup(x)` 抛出异常时）都保留了指定的语义？\n\nA. 选项 A\nB. 选项 B\nC. 选项 C\nD. 选项 D", "solution": "问题要求为包含 `try-finally` 块和一个潜在的提前 `return` 语句的高级语言函数，确定其正确的低级中间表示（IR）。核心语义规则是，在从 `try` 块的任何出口处，`finally` 块必须且仅执行一次，之后恢复原始的退出操作，除非 `finally` 块本身抛出异常。\n\n我们首先根据指定的语义分析源过程 `g(x)` 的行为。\n\n```c\nint g(int x) {\n  try {\n    if (x  0) return -1;\n    x = x + 1;\n  } finally {\n    cleanup(x);\n  }\n  return x;\n}\n```\n\n通过 `try` 块主要有两条控制流路径：\n\n1.  **提前返回路径 ($x  0$)：**\n    - 条件 $x  0$ 为真。\n    - 遇到语句 `return -1;`。这构成了从 `try` 块的提前退出。\n    - 在函数可以返回之前，必须执行 `finally` 块。因此，调用 `cleanup(x)`。传递给 `cleanup` 的 `x` 值是其原始的负值，因为它没有被修改过。\n    - 如果 `cleanup(x)` 成功执行（不抛出异常），则完成待定的退出操作 `return -1;`。函数返回值 `-1`。\n    - 如果 `cleanup(x)` 抛出异常，待定的 `return -1;` 将被取代。异常会从函数 `g(x)` 中传播出去。\n\n2.  **正常执行到底路径 ($x \\ge 0$)：**\n    - 条件 $x  0$ 为假。\n    - 语句 `x = x + 1;` 被执行，递增 `x`。\n    - `try` 块执行完毕。这是一个正常的“执行到底”退出。\n    - `finally` 块被执行。`cleanup(x)` 以新的、已递增的 `x` 值被调用。\n    - 如果 `cleanup(x)` 成功执行，控制流将继续到 `try-finally` 结构后面的语句，即 `return x;`。函数返回递增后的 `x` 值。\n    - 如果 `cleanup(x)` 抛出异常，语句 `return x;` 将永远不会被执行到，异常会从 `g(x)` 中传播出去。\n\n一个正确的到给定 IR 的翻译必须复制这种行为。关键的挑战在于，来自 `try` 块内两条不同路径的控制流必须合并到 `finally` 块的单一代码段中，然后再次分叉以执行正确的接续操作（提前返回或正常执行到底）。这需要一种机制来“记住”哪个接续是合适的。为此提供了一个布尔标志 `f`。还提供了一个临时变量 `r` 来保存待定的返回值。\n\n现在，我们将根据这些要求评估每个选项。\n\n**选项 A：**\n\n```\nL0:\n  f := 0;\n  if (x  0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  if (f == 1) goto Lret; else goto Lnorm;\nLret:\n  return r;\nLnorm:\n  return x;\n```\n\n-   **路径 $x  0$： ** 控制流经过 `L0 → Lretprep → Lcleanup`。在 `Lretprep`，待定的返回值 `-1` 存储在 `r` 中，标志 `f` 被设为 `1` 以表示有待定的返回。然后用 `x` 的原始值调用 `cleanup(x)`。如果 `cleanup` 成功，测试 `if (f == 1)` 为真，跳转到 `Lret`，执行 `return r`。函数返回 `-1`。这是正确的。如果 `cleanup(x)` 抛出异常，执行在 `if` 语句之前中止，异常传播出去，这也是正确的。\n-   **路径 $x \\ge 0$： ** 控制流经过 `L0 → Linc → Lcleanup`。在 `Linc`，`x` 被递增。标志 `f` 保持其初始值 `0`。然后用新的、已递增的 `x` 值调用 `cleanup(x)`。如果 `cleanup` 成功，测试 `if (f == 1)` 为假，跳转到 `Lnorm`，执行 `return x`。函数返回递增后的 `x` 值。这是正确的。如果 `cleanup(x)` 抛出异常，执行中止，这也是正确的。\n-   **`cleanup` 的执行：** 在所有通过 `try` 块的非异常路径中，控制流都被无条件转移到 `Lcleanup`，确保 `cleanup(x)` 且仅被执行一次。\n\n此翻译正确地实现了指定语义的所有方面。\n**结论：正确**\n\n**选项 B：**\n\n```\nL0:\n  f := 0;\n  if (x  0) goto Lret; else goto Linc;\nLret:\n  r := -1;\n  return r;\nLinc:\n  x := x + 1;\n  cleanup(x);\n  return x;\n```\n\n-   **路径 $x  0$： ** 控制流跳转到 `Lret`。函数立即执行 `return r`（返回 `-1`）。`finally` 块的代码 `cleanup(x)` 被完全跳过。这直接违反了基本的 `try-finally` 语义规则。\n**结论：不正确**\n\n**选项 C：**\n\n```\nL0:\n  f := 0;\n  if (x  0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  return x;\n```\n\n-   **路径 $x  0$： ** 控制流经过 `Lretprep` 到达 `Lcleanup`。临时变量 `r` 被正确设置为 `-1`，`f` 被设置为 `1`。然而，在 `cleanup(x)` 执行后，代码无条件地执行 `return x;`。这将返回 `x` 的原始负值，而不是预期的提前返回的值 `-1`。存储在 `r` 和 `f` 中的信息被忽略了。\n-   **路径 $x \\ge 0$： ** 此路径行为正确，执行 `x := x + 1;`，然后是 `cleanup(x);`，再然后是 `return x;`。\n-   由于提前返回路径处理不当，整个翻译是有缺陷的。\n**结论：不正确**\n\n**选项 D：**\n\n```\nL0:\n  f := 0;\n  if (x  0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  return r;\n```\n\n-   **路径 $x \\ge 0$： ** 控制流经过 `Linc` 到达 `Lcleanup`。`x` 被递增。在 `cleanup(x)` 执行后，代码无条件地执行 `return r;`。然而，在这条路径上，临时变量 `r` 从未被初始化。函数将返回一个未定义或垃圾值，而不是所要求的递增后的 `x` 值。\n-   **路径 $x  0$： ** 此路径行为正确。在 `cleanup(x)` 之后，执行 `return r;`，由于 `r` 已被设置为 `-1`，因此返回了正确的值。\n-   由于正常执行到底的路径处理不当，该翻译是有缺陷的。\n**结论：不正确**\n\n根据分析，只有选项 A 正确地实现了所有执行路径的指定语义。它恰当地使用了一个标志来区分接续操作，并使用一个临时变量来存储待定的返回值，从而确保 `finally` 块总是被执行，并且采取了正确的后续操作。", "answer": "$$\\boxed{A}$$", "id": "3641508"}, {"introduction": "编译器在设计时常常面临选择。对于像 `finally` 这样的结构，一个关键决策是为每个退出路径复制清理代码，还是创建一个共享的代码块。这项练习将你从具体的实现细节提升到策略分析的层面[@problem_id:3641500]，要求你为两种方法的代码大小和结构复杂度建立数学模型。这揭示了编译器设计者如何基于定量的原则性决策来优化性能和代码体积。", "problem": "编译器必须将带有保证最终执行的高级构造（例如 Java 的关键字 `finally`）转换为底层控制流。考虑一个由受保护的计算和其后的 `finally` 代码块组成的单个结构化区域 $R$。受保护的计算可以沿 $m$ 个不同的出口终止，其中 $m = m_{n} + m_{x}$，$m_{n}$ 是继续到不同续体点的正常出口，$m_{x}$ 是将控制权转移到不同异常处理程序的异常出口。编译器在两种翻译策略之间进行选择：\n\n- 策略 $\\mathcal{D}$（复制）：沿受保护计算的每个出口内联克隆 `finally` 代码块。运行内联的最终执行代码后，控制权通过单个无条件分支直接转移到出口的目标。\n\n- 策略 $\\mathcal{S}$（共享清理）：生成一个实现 `finally` 代码的独立清理代码块。受保护区域的每个出口首先执行一个小的标签写入以记录预定目标，然后分支到共享清理代码块。在清理结束时，一个多路分派会跳转到记录的目标。\n\n假设一个代码大小的成本模型，其中机器级指令的数量在基本块之间是可加的。设 `finally` 代码块主体的大小为 $F$。设每个无条件分支的大小为 $j$。在共享清理策略中，设每个出口的标签写入大小为 $t$，清理结束时的多路分派实现为一个跳转表，其总大小为 $d + u m$，其中 $d$ 是固定的表头成本，$u$ 是每个目标的条目成本乘以 $m$。忽略所有其他开销，并假设无论在何处出现无条件分支，都使用相同的分支大小 $j$。\n\n为从第一性原理分析对路径结构的影响，请使用 McCabe 关于控制流图（CFG）圈复杂度的标准定义。对于一个连通的 CFG 组件，McCabe 的圈复杂度 $V$ 定义为 $V = E - N + 2$，其中 $E$ 是边的数量，$N$ 是节点的数量。对于结构化程序，$V$ 等于一加上独立决策点的数量。假设 `finally` 代码块的主体包含 $s$ 个二元决策点。将具有 $m$ 个备选项的多路分派视为贡献了 $m - 1$ 个独立决策点。\n\n在这些假设下：\n\n1. 推导代码大小增量 $\\Delta S$ 的闭式表达式，$\\Delta S$ 定义为共享清理策略的代码大小减去复制策略的代码大小，用 $F$、$m$、$t$、$d$ 和 $u$ 表示。\n\n2. 推导路径计数增量 $\\Delta P$ 的闭式表达式，$\\Delta P$ 定义为共享清理策略的圈复杂度减去复制策略的圈复杂度，用 $m$ 和 $s$ 表示。\n\n以闭式形式提供最终结果，形式为一个二元行向量 $\\left(\\Delta S, \\Delta P\\right)$。不需要进行数值舍入，也不涉及物理单位。请将最终答案表示为精确的符号表达式。", "solution": "在尝试求解之前，将首先根据指定标准对问题进行验证。\n\n**问题验证**\n\n**第一步：提取已知条件**\n- 一个由受保护的计算和其后的 `finally` 代码块组成的单个结构化区域 $R$。\n- 受保护的计算有 $m$ 个不同的出口。\n- $m = m_{n} + m_{x}$，其中 $m_{n}$ 是正常出口，$m_{x}$ 是异常出口。\n- 策略 $\\mathcal{D}$（复制）：为 $m$ 个出口中的每一个内联克隆 `finally` 代码块。然后通过单个无条件分支转移控制权。\n- 策略 $\\mathcal{S}$（共享清理）：使用一个独立的清理代码块。$m$ 个出口中的每一个都执行一次标签写入，并分支到清理代码块。清理以多路分派结束。\n- `finally` 代码块主体的大小：$F$。\n- 无条件分支的大小：$j$。\n- 每个出口的标签写入大小（策略 $\\mathcal{S}$）：$t$。\n- 多路分派的大小（策略 $\\mathcal{S}$）：$d + u m$，其中 $d$ 是固定成本，$u$ 是每个目标的条目成本。\n- McCabe 的圈复杂度：$V = E - N + 2$。\n- 对于结构化程序，$V = 1 + (\\text{独立决策点的数量})$。\n- `finally` 代码块主体中的二元决策点数量：$s$。\n- 具有 $m$ 个备选项的多路分派贡献 $m - 1$ 个独立决策点。\n- 任务是求解代码大小增量 $\\Delta S = S_{\\mathcal{S}} - S_{\\mathcal{D}}$ 和路径计数（圈复杂度）增量 $\\Delta P = V_{\\mathcal{S}} - V_{\\mathcal{D}}$。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学依据：**这个问题牢固地植根于计算机科学的一个子领域——编译器设计。复制和共享清理这两种策略是用于实现异常处理和最终化构造（如 Java 的 `finally`）的标准、有据可查的技术。代码大小和圈复杂度的成本模型是简化的，但也是用于编译器优化分析的标准抽象。\n- **良构的：**所有参数（$F$, $m$, $t$, $d$, $u$, $s$, $j$）都有明确定义。目标（推导 $\\Delta S$ 和 $\\Delta P$）是明确的。可以从给定的模型中推导出唯一、稳定且有意义的符号解。\n- **客观性：**问题以精确、形式化的语言陈述，没有主观或基于观点的断言。\n\n该问题不违反任何无效标准。它是在指定领域内一个定义明确、可形式化的问题。前提条件是一致且充分的，足以推导出所需的表达式。\n\n**第三步：结论与行动**\n问题被判定为**有效**。将提供完整解答。\n\n**解答推导**\n\n解答需要推导两个量：从复制策略（$\\mathcal{D}$）转变为共享清理策略（$\\mathcal{S}$）时，代码大小的变化量 $\\Delta S$ 和圈复杂度的变化量 $\\Delta P$。\n\n**第一部分：代码大小增量（$\\Delta S$）的推导**\n\n设 $S_{\\mathcal{D}}$ 为使用策略 $\\mathcal{D}$ 实现 `finally` 的总代码大小，$S_{\\mathcal{S}}$ 为使用策略 $\\mathcal{S}$ 的代码大小。我们定义 $\\Delta S = S_{\\mathcal{S}} - S_{\\mathcal{D}}$。受保护计算本身的大小对两种策略是共同的，因此对增量没有贡献。\n\n**策略 $\\mathcal{D}$（复制）的代码大小：**\n在此策略中，大小为 $F$ 的 `finally` 代码块主体被复制到 $m$ 个出口中的每一个。在每个复制的块之后，使用一个大小为 $j$ 的无条件分支将控制权转移到相应的出口目标。\n总大小是 $m$ 个复制块和 $m$ 个无条件分支的大小之和。\n$$S_{\\mathcal{D}} = m \\cdot F + m \\cdot j$$\n\n**策略 $\\mathcal{S}$（共享清理）的代码大小：**\n在此策略中，生成 `finally` 代码块主体的单个副本，其大小为 $F$。受保护区域的 $m$ 个出口中的每一个都需要一次标签写入（大小为 $t$）来记录其目的地，然后是一个无条件分支（大小为 $j$）到共享清理代码块。最后，清理代码块以一个大小为 $d + um$ 的多路分派结束。\n总大小是这些组件之和。\n$$S_{\\mathcal{S}} = \\left( \\sum_{i=1}^{m} (t + j) \\right) + F + (d + u m)$$\n$$S_{\\mathcal{S}} = m(t + j) + F + d + u m$$\n$$S_{\\mathcal{S}} = F + mt + mj + d + um$$\n\n**计算增量 $\\Delta S$：**\n现在，我们计算差值 $\\Delta S = S_{\\mathcal{S}} - S_{\\mathcal{D}}$。\n$$\\Delta S = (F + mt + mj + d + um) - (mF + mj)$$\n项 $mj$ 被消去。\n$$\\Delta S = F - mF + mt + d + um$$\n对各项进行因式分解，我们得到 $\\Delta S$ 的最终表达式：\n$$\\Delta S = (1 - m)F + m(t + u) + d$$\n\n**第二部分：圈复杂度增量（$\\Delta P$）的推导**\n\n设 $V_{\\mathcal{D}}$ 为策略 $\\mathcal{D}$ 的圈复杂度，$V_{\\mathcal{S}}$ 为策略 $\\mathcal{S}$ 的圈复杂度。我们定义 $\\Delta P = V_{\\mathcal{S}} - V_{\\mathcal{D}}$。题目指出，对于结构化代码，圈复杂度 $V$ 可以计算为 $1$ 加上独立决策点的数量。设 $d_{p}$ 是受保护计算内部的决策点数量，这对两种策略是共同的。\n\n**策略 $\\mathcal{D}$（复制）的圈复杂度：**\n`finally` 代码块主体包含 $s$ 个二元决策点。在策略 $\\mathcal{D}$ 中，此代码块被复制 $m$ 次。由于每个副本位于独立的路径上，由 `finally` 逻辑贡献的总决策点数是每个副本中决策点数的总和，即 $m \\cdot s$。图中总的决策点数是受保护块中的决策点数和 `finally` 机制中的决策点数之和。\n$\\mathcal{D}$ 的总决策点数 = $d_{p} + m s$。\n因此，圈复杂度为：\n$$V_{\\mathcal{D}} = 1 + (d_{p} + ms)$$\n\n**策略 $\\mathcal{S}$（共享清理）的圈复杂度：**\n在策略 $\\mathcal{S}$ 中，只有一个 `finally` 代码块主体的副本，贡献 $s$ 个决策点。此外，共享块末尾具有 $m$ 个备选项的多路分派被定义为贡献 $m-1$ 个独立决策点。从受保护区域到共享块的无条件分支不增加决策点。\n$\\mathcal{S}$ 的总决策点数 = $d_{p} + s + (m-1)$。\n因此，圈复杂度为：\n$$V_{\\mathcal{S}} = 1 + (d_{p} + s + m - 1)$$\n\n**计算增量 $\\Delta P$：**\n现在，我们计算差值 $\\Delta P = V_{\\mathcal{S}} - V_{\\mathcal{D}}$。\n公共项 $1 + d_{p}$ 被消去。\n$$\\Delta P = (s + m - 1) - ms$$\n对各项进行因式分解，我们得到 $\\Delta P$ 的最终表达式：\n$$\\Delta P = s - ms + m - 1$$\n$$\\Delta P = (1 - m)s + m - 1$$\n\n所需的二元行向量是 $(\\Delta S, \\Delta P)$。", "answer": "$$ \\boxed{ \\begin{pmatrix} (1 - m)F + m(t + u) + d  (1 - m)s + m - 1 \\end{pmatrix} } $$", "id": "3641500"}]}