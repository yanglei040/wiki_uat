{"hands_on_practices": [{"introduction": "要真正理解惰性求值的核心优势，最好的方法莫过于亲手追踪其执行过程，并与其它策略进行比较。本练习将通过一个简单的算术表达式，让你量化比较“按名调用”和“按需调用”两种策略的求值成本[@problem_id:3649720]。通过计算参数表达式被求值的次数，你将清晰地看到“按需调用”中“记忆化”（memoization）的共享机制是如何避免重复计算，从而提升效率的。", "problem": "考虑一个扩展了整数字面量和二元加法的无类型 lambda 演算。表达式由以下文法生成：$e ::= n \\mid x \\mid \\lambda x.\\,e \\mid e\\ e \\mid e + e$，其中 $n$ 代表整数字面量，$x$ 代表变量。值 (value) 是 $v ::= n \\mid \\lambda x.\\,e$。加法对其两个操作数都是严格的，并且从左到右求值。算术的小步语义 (small-step semantics) 由以下规则给出：\n- 如果 $e_{1} \\to e_{1}'$，那么 $e_{1} + e_{2} \\to e_{1}' + e_{2}$。\n- 如果 $e_{2} \\to e_{2}'$ 且 $e_{1}$ 是一个数值 $n_{1}$，那么 $n_{1} + e_{2} \\to n_{1} + e_{2}'$。\n- 如果两个操作数都是数值，那么 $n_{1} + n_{2} \\to n$，其中 $n$ 是 $n_{1}$ 和 $n_{2}$ 的整数和。\n\n考虑两种调用策略：\n- 传名调用 (Call-by-name) (基于替换)：$(\\lambda x.\\,M)\\ N \\to M[x := N]$，不对 $N$ 进行预先求值。\n- 传需调用 (Call-by-need) (通过 let-绑定实现共享)：$(\\lambda x.\\,M)\\ E \\to \\mathbf{let}\\ x = E\\ \\mathbf{in}\\ M$，并且对 $x$ 的需求驱动的强制求值 (forcing) 最多对 $E$ 求值一次，并将绑定更新为结果值，此后所有出现的 $x$ 都使用该记忆化的值。\n\n固定闭合参数表达式 $E \\equiv (1+1) + (1+1)$，它不是一个值，并且在上述算术规则下确定性地归约为数值 $4$。考虑程序 $(\\lambda x.\\, x + x + x)\\ E$，其中加法的语法结合性是左结合的，因此 $x + x + x$ 表示 $(x + x) + x$。\n\n将“一次 $x$ 的求值”定义为：为了在函数体中某处出现的 $x$ 提供所需的数值操作数，而将绑定的参数表达式 $E$ 完全归约为一个数值的过程；也就是说，每当根据小步规则，一次出现的 $x$ 被强制求值为一个数值时，就算作一次 $x$ 的求值。\n\n在上述传名调用和传需调用策略下，将 $(\\lambda x.\\, x + x + x)\\ E$ 求值为一个数值。计算在每种策略下，整个运行过程中 $x$ 的求值次数。以行矩阵 $\\begin{pmatrix} c_{\\text{name}}  c_{\\text{need}} \\end{pmatrix}$ 的形式报告你的答案，其中 $c_{\\text{name}}$ 是传名调用下的次数，$c_{\\text{need}}$ 是传需调用下的次数。无需四舍五入。在你的推导中解释传需调用下共享是如何产生的，以及为什么它会改变求值次数。", "solution": "问题要求我们确定，在一个 lambda 抽象应用于特定参数表达式 $E$ 时，在传名调用和传需调用这两种不同的求值策略下，$E$ 被求值的次数。\n\n程序由 $P \\equiv (\\lambda x.\\, x + x + x)\\ E$ 给出。\n参数表达式为 $E \\equiv (1+1) + (1+1)$。\nlambda 抽象的函数体是 $M \\equiv x + x + x$，由于左结合性，它等价于 $(x+x)+x$。\n`+` 运算符是严格的，意味着它在执行加法之前会先对其操作数求值。求值顺序是从左到右。\n“一次 $x$ 的求值”被定义为将绑定的参数表达式 $E$ 完全归约为一个数值，这发生于当 $x$ 的一次出现必须为一个运算提供数值时。表达式 $E$ 本身归约为值 $4$：\n$E \\equiv (1+1) + (1+1) \\to 2 + (1+1) \\to 2 + 2 \\to 4$。\n\n让我们分析每种策略下的求值过程。\n\n### 传名调用求值\n\n在传名调用下，函数应用的归约规则是 $(\\lambda x.\\,M)\\ N \\to M[x := N]$。未求值的参数表达式 $N$ 被替换到函数体 $M$ 中形式参数 $x$ 的每一次出现。\n\n$1$. 初始的 $\\beta$-归约是：\n$$(\\lambda x.\\, (x+x)+x) ( (1+1) + (1+1) ) \\to ( (x+x)+x )[x := (1+1)+(1+1) ]$$\n这得到了表达式：\n$$(( (1+1)+(1+1) ) + ( (1+1)+(1+1) )) + ( (1+1)+(1+1) )$$\n为清晰起见，我们将未求值的表达式 $(1+1)+(1+1)$ 表示为 $E$。需要求值的表达式是 $(E + E) + E$。\n\n$2$. $(E+E)+E$ 的求值遵循加法严格的、从左到右的语义进行。\n首先，我们必须对最外层 `+` 的左操作数求值，即子表达式 $(E+E)$。为了对 $(E+E)$ 求值，我们必须先对其左操作数，即第一个 $E$ 求值。这是第一次需要数值操作数。\n**第一次 $x$ 的求值**：$E$ 的第一次出现被归约为一个值。\n$E \\equiv (1+1)+(1+1) \\to 2+(1+1) \\to 2+2 \\to 4$。\n表达式变为 $(4 + E) + E$。\n\n$3$. 接下来，为了对子表达式 $(4+E)$ 求值，我们必须对其右操作数，即第二个 $E$ 求值。\n**第二次 $x$ 的求值**：$E$ 的第二次出现被归约为一个值。这是来自替换的一个新的表达式副本。\n$E \\equiv (1+1)+(1+1) \\to 2+(1+1) \\to 2+2 \\to 4$。\n表达式变为 $(4 + 4) + E$。\n\n$4$. 现在可以执行内部的加法：\n$(4+4)+E \\to 8+E$。\n\n$5$. 最后，为了对 $8+E$ 求值，我们必须对其右操作数，即第三个 $E$ 求值。\n**第三次 $x$ 的求值**：$E$ 的第三次出现被归约为一个值。\n$E \\equiv (1+1)+(1+1) \\to 2+(1+1) \\to 2+2 \\to 4$。\n表达式变为 $8+4$。\n\n$6$. 进行最后的加法：\n$8+4 \\to 12$。\n\n在整个过程中，参数表达式 $E$ 被完全求值了三次，函数体中 $x$ 每出现一次就求值一次。因此，传名调用的求值次数是 $c_{\\text{name}} = 3$。\n\n### 传需调用求值\n\n在传需调用下，参数在函数应用时不被求值。取而代之的是，会创建一个“thunk”（计算的占位符）。参数表达式的求值仅在其值第一次被需要时触发。其结果随后被记忆化（缓存），之后所有对该变量的使用都将使用这个缓存的值，从而避免重复计算。\n\n$1$. 初始的归约步骤将函数应用转换为一个 `let` 绑定：\n$$(\\lambda x.\\, (x+x)+x)\\ E \\to \\mathbf{let}\\ x = E\\ \\mathbf{in}\\ (x+x)+x$$\n在这里，$x$ 被绑定到一个代表未求值表达式 $E \\equiv (1+1)+(1+1)$ 的 thunk。\n\n$2$. 函数体 $(x+x)+x$ 的求值开始。与传名调用一样，最外层 `+` 的求值需要其左操作数 $(x+x)$ 的值。\n为了对 $(x+x)$ 求值，我们必须先对其左操作数，即第一个 $x$ 求值。这是第一次需要（或“强制求出”） $x$ 的值。\n**第一次也是唯一一次 $x$ 的求值**：与 $x$ 关联的 thunk 被求值。\n$E \\equiv (1+1)+(1+1) \\to 2+(1+1) \\to 2+2 \\to 4$。\n结果 $4$ 被缓存。$x$ 的绑定现在被更新为值 $4$。这算作一次求值。\n我们正在求值的表达式 $(x+x)$ 变为 $(4+x)$，并且我们知道 $x$ 现在是 $4$。\n\n$3$. 为了对子表达式 $(4+x)$ 求值，我们需要其右操作数，即第二个 $x$ 的值。\n当访问到 $x$ 的第二次出现时，传需调用机制发现其 thunk 已经被求值。它只是简单地检索记忆化的值 $4$，而不会重新计算 $E$。\n表达式变为 $(4+4)$。\n\n$4$. 执行内部的加法：\n$4+4 \\to 8$。\n整个表达式变为 $8+x$。\n\n$5$. 为了对 $8+x$ 求值，我们需要第三个 $x$ 的值。\n同样，直接检索到记忆化的值 $4$。没有对 $E$ 的新求值发生。\n表达式变为 $8+4$。\n\n$6$. 执行最后的加法：\n$8+4 \\to 12$。\n\n在这种策略下，$E$ 的昂贵计算只在第一次需要 $x$ 的值时执行了一次。所有后续的需求都由缓存的结果满足。这种共享是与传名调用的核心区别。传需调用的求值次数是 $c_{\\text{need}} = 1$。\n\n最终答案是计数对 $(c_{\\text{name}}, c_{\\text{need}})$。\n$c_{\\text{name}} = 3$\n$c_{\\text{need}} = 1$\n这表示为行矩阵 $\\begin{pmatrix} 3  1 \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix} 3  1 \\end{pmatrix}}$$", "id": "3649720"}, {"introduction": "惰性求值的一个深刻推论是：如果一个参数的值从未在函数体中被需要，那么该参数的计算过程将永远不会被触发。这个练习通过一个涉及异常处理的巧妙场景，来检验你对这一核心原则的理解[@problem_id:3649715]。通过分析一个其参数会抛出异常但函数体却未使用该参数的程序，你将认识到惰性求值如何充当一张“安全网”，避免了不必要的副作用。", "problem": "考虑一个扩展了异常处理的核心按需调用（call-by-need）lambda 演算。表达式由变量 $x$、数值字面量（如 $1$）、lambda 抽象 $\\lambda x.\\, t$、应用 $t\\_1\\, t\\_2$ 以及一个异常构造器 $\\text{throw}\\ e$ 组成。当 $\\text{throw}\\ e$ 被求值时，它表示抛出一个携带载荷 $e$ 的异常。假设按需调用策略（也称为惰性求值）将参数实现为 thunk，这些 thunk 直到其绑定的变量在函数体中被需要时才会被求值；并且异常仅在表达式 $\\text{throw}\\ e$ 本身被求值时才被抛出。作为基础的关键操作事实如下：\n- 在按名调用（CBN）和按需调用（CBNeed）中，一个应用 $(\\lambda x.\\, t)\\, u$ 的执行过程是：进入 $t$，并将 $x$ 绑定到 $u$（CBN）或 $u$ 的一个 thunk（CBNeed）。在这两种情况下，$u$ 在应用点都不会被求值。\n- 在按需调用下，一个 thunk 仅当其绑定的变量在继续求值函数体时确实被需要时才会被强制执行（forced）。如果一个绑定变量未被使用，其 thunk 永远不会被强制执行。\n- 表达式 $\\text{throw}\\ e$ 仅在 $\\text{throw}\\ e$ 被求值时才会抛出载荷为 $e$ 的异常；仅仅因为 $\\text{throw}\\ e$ 作为一个子项存在并不会导致异常抛出，除非该子项被实际求值。\n\n在按需调用和上述异常语义下，求值程序 $(\\lambda x.\\, 1)\\,(\\text{throw}\\ e)$。哪个陈述最能描述其可观察行为？\n\nA. 程序求值为 $1$，并且异常载荷 $e$ 不会被抛出，因为参数未被需要，因此也未被求值。\n\nB. 程序在函数应用完成前抛出 $e$，因为在惰性语言中，参数在替换前会被求值。\n\nC. 在按需调用下，由于共享机制，程序会抛出 $e$，该机制为避免重复而强制提前对参数求值。\n\nD. 行为是实现相关的；一个典型的惰性编译器可能会将参数求值到弱头范式（weak-head normal form）从而抛出 $e$，或者根据启发式策略跳过求值并返回 $1$。", "solution": "在尝试解答之前，必须先确定问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n问题指定了以下内容：\n- **系统：** 一个核心按需调用 lambda 演算。\n- **语法：** 表达式由变量 $x$、数值字面量（例如 $1$）、lambda 抽象 $\\lambda x.\\, t$、应用 $t\\_1\\, t\\_2$ 以及一个异常构造器 $\\text{throw}\\ e$ 组成。\n- **求值策略：** 按需调用（惰性求值）。\n- **应用语义：** 对于一个应用 $(\\lambda x.\\, t)\\, u$，参数 $u$ 在应用点不被求值。相反，在函数体 $t$ 中，变量 $x$ 被绑定到 $u$ 的一个 *thunk*。\n- **参数求值语义：** 一个 thunk 仅在其对应的绑定变量为继续求值函数体所需要时才被强制执行（求值）。如果一个绑定变量未被使用，其 thunk 永远不会被强制执行。\n- **异常语义：** 表达式 $\\text{throw}\\ e$ 仅在 $\\text{throw}\\ e$ 本身被求值时，才会抛出载荷为 $e$ 的异常。\n- **待求值程序：** $(\\lambda x.\\, 1)\\,(\\text{throw}\\ e)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题陈述进行评估。\n- **科学性：** 该问题牢固地植根于程序设计语言理论和编译器设计的原则。lambda 演算、按需调用求值、thunk 和异常处理等概念在该领域是标准且明确定义的。所指定的语义与此类语言的形式化操作语义一致。\n- **良构性（Well-Posed）：** 该问题提供了一个特定的程序和一套清晰、无歧义的求值规则。应用这些规则将导致一个唯一的、确定性的结果。\n- **客观性：** 语言是形式化和技术性的，没有主观或模糊的术语。\n- **完整性和一致性：** 问题提供了求值该程序所需的所有必要定义。对按需调用的描述是内部一致的，并与计算机科学中的标准定义相符。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。这是理论计算机科学领域内一个良构的问题。现在可以推导解决方案。\n\n### 正确答案的推导\n\n待求值的程序是 $(\\lambda x.\\, 1)\\,(\\text{throw}\\ e)$。该表达式是一个形式为 $(\\lambda x.\\, t)\\, u$ 的函数应用，其中：\n- 函数是 $\\lambda x.\\, 1$。\n- 函数体是 $t = 1$。\n- 参数是 $u = \\text{throw}\\ e$。\n\n求值过程根据指定的按需调用策略进行。\n\n1.  **函数应用：** 根据规则，参数 $\\text{throw}\\ e$ 在应用点**不**被求值。相反，系统为参数 $\\text{throw}\\ e$ 创建一个 thunk（一个暂停的计算），并将变量 $x$ 绑定到这个 thunk。然后，求值过程进入函数体 $1$。\n\n2.  **函数体求值：** 函数体是表达式 $1$。这是一个数值字面量，它是一个值。对一个值的求值结果就是该值本身。\n\n3.  **参数使用情况：** 为了确定是否必须强制执行 $x$ 的 thunk，我们检查函数体 $1$。变量 $x$ 没有出现在函数体的任何地方。因此，完成函数体的求值不需要 $x$ 的值。\n\n4.  **Thunk 强制执行：** 问题陈述中提到：“在按需调用下，一个 thunk 仅当其绑定的变量在继续求值函数体时确实被需要时才会被强制执行……如果一个绑定变量未被使用，其 thunk 永远不会被强制执行。” 由于 $x$ 未被使用，包含表达式 $\\text{throw}\\ e$ 的 thunk 永远不会被强制执行（即，永远不会被求值）。\n\n5.  **异常处理：** 问题指定：“表达式 $\\text{throw}\\ e$ 仅在 $\\text{throw}\\ e$ 被求值时才会抛出载荷为 $e$ 的异常”。由于 $\\text{throw}\\ e$ 的 thunk 从未被求值，表达式 $\\text{throw}\\ e$ 也从未被求值。因此，异常不会被抛出。\n\n6.  **最终结果：** 函数体 $1$ 的求值成功完成，产生值 $1$。参数的 thunk 被直接丢弃。该程序的可观察行为是它返回值 $1$。\n\n### 逐项分析选项\n\n**A. 程序求值为 $1$，并且异常载荷 $e$ 不会被抛出，因为参数未被需要，因此也未被求值。**\n这个陈述是对上述推导的求值过程的精确描述。函数体是常量 $1$，它不依赖于参数 $x$。在按需调用系统中，这意味着参数永远不会被求值。由于参数是表达式 $\\text{throw}\\ e$，而对它的求值是触发异常的原因，所以异常永远不会被抛出。程序正确地返回 $1$。\n**结论：正确。**\n\n**B. 程序在函数应用完成前抛出 $e$，因为在惰性语言中，参数在替换前会被求值。**\n这个陈述在事实上是错误的。其前提“在惰性语言中，参数在替换前会被求值”描述的是一种及早求值策略（如按值调用），而不是像按需调用这样的惰性策略。问题明确定义了一种惰性求值策略，其中参数作为未求值的 thunk 传递。\n**结论：错误。**\n\n**C. 在按需调用下，由于共享机制，程序会抛出 $e$，该机制为避免重复而强制提前对参数求值。**\n这个陈述误解了按需调用中的共享概念。共享（按需调用中“需”的部分，也是其与按名调用的区别）确保如果一个 thunk 化的参数被*多次*使用，它最多被求值一次，且结果被共享。它不会强制对一个根本未被使用的参数进行求值。求值的触发器是对变量值的*需要*，而不是共享机制本身。由于变量 $x$ 从未被需要，共享机制是无关紧要的，求值也不会发生。\n**结论：错误。**\n\n**D. 行为是实现相关的；一个典型的惰性编译器可能会将参数求值到弱头范式（weak-head normal form）从而抛出 $e$，或者根据启发式策略跳过求值并返回 $1$。**\n这个陈述与问题的前提相矛盾。问题要求基于一个具有精确定义规则的*核心按需调用 lambda 演算*进行求值，而不是基于某个特定现实世界编译器可能存在的、由启发式驱动的复杂优化。根据指定的形式化语义，其行为是确定性的，而非与实现相关。对一个未使用的参数进行求值将违反所定义的按需调用策略。\n**结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "3649715"}, {"introduction": "虽然惰性求值的共享机制在纯函数世界中能显著提升效率，但当与副作用结合时，它可能会引入微妙且危险的行为，甚至破坏程序的引用透明性。本练习构建了一个经典的反例，展示了对一个带有副作用的表达式进行共享（例如，通过公共子表达式消除）如何改变程序的最终结果[@problem_id:3649688]。通过这个实践，你不仅能认识到在混合了副作用的环境中应用惰性求值的挑战，还能了解到如何通过类型系统（如纯度检查或线性类型）来恢复代码的健壮性和可预测性。", "problem": "考虑一个具有整数、加法和单一绑定结构的一阶表达式语言的按需调用（惰性）实现。表达式由以下文法给出：$e ::= n \\mid e_1 + e_2 \\mid \\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e' \\mid \\mathsf{tick}()$，其中 $n \\in \\mathbb{Z}$ 是一个整数字面量，$\\mathsf{tick}()$ 是一个带副作用的原始操作。其操作意图是：\n- 在 $\\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e'$ 中，实现为 $e$ 分配一个 thunk；当需要 $x$ 时，该 thunk 被求值，其结果被记忆化，所有后续对 $x$ 的需求都会读取记忆化的结果（这就是按需调用共享）。\n- 原始操作 $\\mathsf{tick}()$ 将一个特殊的事件 $\\star$ 附加到全局日志 $L$ 中，并返回整数 $1$。一个表达式的可观察行为是其最终的整数值以及最终的日志序列 $L$；如果两个表达式对于所有初始日志都能产生相同的值和相同的日志序列，那么它们是可观察等价的。\n\n如果将相等的部分相互替换在所有上下文中都能保持可观察行为不变，那么该语言是引用透明的。在引用透明的环境中，引入共享的编译器优化（例如，将重复的子表达式重写为单个 $\\mathbf{let}$ 绑定的 thunk 的公共子表达式消除）是保留语义的，但在存在副作用的情况下可能是不健全的。\n\n仅以上述定义为出发点，对以下候选反例和补救措施进行推理。设 $E_1 \\triangleq \\mathsf{tick}() + \\mathsf{tick}()$ 且 $E_2 \\triangleq \\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$。\n\n选择所有正确的陈述：\n\nA. 在没有 $\\mathsf{tick}()$ 的纯子语言中，$E_1$ 和 $E_2$ 将是上下文等价的。当 $\\mathsf{tick}()$ 的日志是可观察的时，按需调用共享导致 $E_2$ 恰好产生 1 个 tick，而 $E_1$ 恰好产生 2 个。因此，除非排除了副作用，否则一个天真地将 $E_1$ 重写为 $E_2$（或执行等价的公共子表达式消除）的编译器是不健全的。\n\nB. 在带共享的按需调用下，对 $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ 求值会在每次使用时独立地对 $x$ 的 thunk 求值，导致两次 tick；在这种情况下，共享不会改变副作用的数量。\n\nC. 一个使共享保持语义的充分约束是强制共享的 thunk 是纯的：在 $\\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e'$ 中的绑定表达式 $e$ 必须是无副作用的。一个副作用系统可以通过将 $\\mathsf{tick}$ 类型化为有副作用的（例如，类型为 $\\mathsf{IO}\\ \\mathbb{Z}$），并且只允许对纯类型的表达式（例如，类型为 $\\mathbb{Z}$）进行共享，或者通过要求显式的副作用封装来强制执行这一点。\n\nD. 因为按名调用（无共享）不进行记忆化，$E_1$ 和 $E_2$ 之间的差异消失了，这意味着在任何非严格策略下，无论是否存在副作用，公共子表达式消除都是安全的。\n\nE. 除了禁止副作用，还可以使用线性或唯一性类型规程来防止有副作用的 thunk 的重复。在这种约束下，$\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ 会被拒绝，因为 $x$ 被使用了两次，从而阻止了反例的出现，并在不要求全局纯净性的情况下使共享变得安全。", "solution": "### 问题验证\n\n**步骤 1：提取已知条件**\n-   **语言文法**：表达式由 $e ::= n \\mid e_1 + e_2 \\mid \\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e' \\mid \\mathsf{tick}()$ 定义，其中 $n \\in \\mathbb{Z}$ 是一个整数字面量。\n-   **求值策略**：按需调用（惰性）实现。\n-   **`let` 的语义**：在 $\\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e'$ 中，为 $e$ 分配一个 thunk。当第一次需要 $x$ 时，该 thunk 被求值，其结果被记忆化，所有后续对 $x$ 的需求都检索记忆化的结果。这被明确定义为按需调用共享。\n-   **`tick()` 的语义**：原始操作 $\\mathsf{tick}()$ 将一个特殊的事件 $\\star$ 附加到全局日志 $L$ 中，并返回整数值 $1$。\n-   **可观察行为**：表达式求值的结果是其最终整数值和日志序列 $L$ 的最终状态组成的对。\n-   **可观察等价性**：如果两个表达式对于所有可能的初始日志状态都能产生相同的整数值和相同的最终日志序列，则认为它们是可观察等价的。\n-   **引用透明性 (RT)**：如果用一个表达式替换一个可观察等价的表达式能够保持外围程序的可观察行为，则 RT 成立。\n-   **优化上下文**：该问题考虑了公共子表达式消除 (CSE)，它可能将一个带有重复子表达式的表达式重写为一个使用单个 `let` 绑定 thunk 来表示公共部分的形式。\n-   **候选表达式**：\n    -   $E_1 \\triangleq \\mathsf{tick}() + \\mathsf{tick}()$\n    -   $E_2 \\triangleq \\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题陈述是编程语言语义学和编译器理论领域的一个标准理论练习。它精确地定义了一个带副作用的简单函数式语言、一种求值策略（按需调用）以及一个可观察行为的概念。这些定义内部一致，并基于已有的计算机科学原理。问题要求基于这些定义对系统的属性进行逻辑推导。该问题是适定 (well-posed) 的，因为所提供的语义足以唯一确定所讨论表达式的行为。它是客观的，不包含任何科学或事实上的不健全之处、不可形式化的概念或歧义。\n\n**步骤 3：结论与行动**\n问题陈述是 **有效的**。可以从所提供的定义中推导出解决方案。\n\n### 推导与分析\n\n我们首先根据指定的按需调用语义来确定表达式 $E_1$ 和 $E_2$ 的可观察行为。设初始日志为 $L_0$。\n\n**$E_1 \\triangleq \\mathsf{tick}() + \\mathsf{tick}()$ 的分析**\n为了计算这个和，必须对其操作数进行求值。假设 `$+$` 运算符的参数采用标准的从左到右的求值顺序：\n1.  左操作数 $\\mathsf{tick}()$ 被求值。这将 $\\star$ 附加到日志中，因此日志变为 $L_0 \\cdot \\langle\\star\\rangle$。该操作返回值 $1$。\n2.  右操作数 $\\mathsf{tick}()$ 被求值。这将另一个 $\\star$ 附加到日志中，使其变为 $L_0 \\cdot \\langle\\star, \\star\\rangle$。该操作返回值 $1$。\n3.  执行加法 $1 + 1$，得到最终值 $2$。\n\n$E_1$ 的可观察行为是（值：$2$，最终日志：$L_0 \\cdot \\langle\\star, \\star\\rangle$）。它恰好向日志中添加两个事件。\n\n**$E_2 \\triangleq \\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ 的分析**\n求值过程按照按需调用的规则进行：\n1.  为表达式 $\\mathsf{tick}()$ 创建一个 thunk（一个暂停的计算）并绑定到变量 $x$。在此阶段不发生求值，日志保持为 $L_0$。\n2.  `let` 表达式的主体 $x + x$ 被求值。这需要对 `$+$` 的操作数进行求值。\n3.  左操作数 $x$ 第一次被需要。绑定到 $x$ 的 thunk 被强制求值（evaluated）。\n4.  对 thunk 的表达式 $\\mathsf{tick}()$ 求值，会将 $\\star$ 附加到日志中（日志变为 $L_0 \\cdot \\langle\\star\\rangle$）并返回值 $1$。\n5.  关键的是，根据按需调用的规范，这个结果（$1$）被 **记忆化**。\n6.  右操作数 $x$ 被需要。由于这是后续的需求，实现会检索记忆化的结果 $1$，而不会重新对 thunk 求值。没有新的事件被添加到日志中。\n7.  执行加法 $1 + 1$，得到最终值 $2$。\n\n$E_2$ 的可观察行为是（值：$2$，最终日志：$L_0 \\cdot \\langle\\star\\rangle$）。它恰好向日志中添加一个事件。\n\n**关于等价性的结论**\n$E_1$ 和 $E_2$ 的求值结果都是整数 $2$，但它们产生不同的最终日志。因此，它们不是可观察等价的。\n\n### 逐项分析\n\n**A. 在没有 $\\mathsf{tick}()$ 的纯子语言中，$E_1$ 和 $E_2$ 将是上下文等价的。当 $\\mathsf{tick}()$ 的日志是可观察的时，按需调用共享导致 $E_2$ 恰好产生 1 个 tick，而 $E_1$ 恰好产生 2 个。因此，除非排除了副作用，否则一个天真地将 $E_1$ 重写为 $E_2$（或执行等价的公共子表达式消除）的编译器是不健全的。**\n\n-   在一个纯子语言中（没有 $\\mathsf{tick}()$），让我们考虑一个任意的纯表达式 $e_{pure}$ 来代替 $\\mathsf{tick}()$。表达式将是 $e_{pure} + e_{pure}$ 和 $\\mathbf{let}\\ x = e_{pure}\\ \\mathbf{in}\\ x + x$。在纯环境中，唯一的可观察量是最终值。两个表达式都会计算出相同的值。求值的次数不会改变可观察行为。因此，它们将是上下文等价的。\n-   第二句话指出 $E_2$ 产生一个 tick 而 $E_1$ 产生两个。我们上面的推导证实了这是正确的。\n-   结论是直接的：由于从一个类似 $E_1$ 的表达式到类似 $E_2$ 的表达式的转换改变了程序的可观察行为，所以这个转换是不健全的（即不保留语义）。这正是将共享与副作用相结合的经典问题。\n-   **结论：正确。**\n\n**B. 在带共享的按需调用下，对 $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ 求值会在每次使用时独立地对 $x$ 的 thunk 求值，导致两次 tick；在这种情况下，共享不会改变副作用的数量。**\n\n-   这个陈述直接与问题中按需调用的定义相矛盾，该定义明确指出，强制求值一个 thunk 的结果会被“记忆化，并且所有后续对 $x$ 的需求都会读取记忆化的结果”。\n-   所描述的行为（每次使用时都强制求值 thunk）是 **按名调用** 的特征，这是一种没有记忆化的非严格策略。按需调用则通过使用记忆化（共享）来避免重复计算来定义。\n-   我们对 $E_2$ 的分析表明，共享正是只产生一个 tick 的根本原因。\n-   **结论：不正确。**\n\n**C. 一个使共享保持语义的充分约束是强制共享的 thunk 是纯的：在 $\\mathbf{let}\\ x = e\\ \\mathbf{in}\\ e'$ 中的绑定表达式 $e$ 必须是无副作用的。一个副作用系统可以通过将 $\\mathsf{tick}$ 类型化为有副作用的（例如，类型为 $\\mathsf{IO}\\ \\mathbb{Z}$），并且只允许对纯类型的表达式（例如，类型为 $\\mathbb{Z}$）进行共享，或者通过要求显式的副作用封装来强制执行这一点。**\n\n-   不健全性之所以产生，是因为共享的表达式 $\\mathsf{tick}()$ 具有可观察的副作用。如果一个表达式 $e$ 是纯的（无副作用的），那么多次对其求值与对其求值一次并重用结果在可观察行为上是无法区分的。\n-   因此，如果公共子表达式消除转换仅限于纯表达式，它就不会改变程序的可观察行为。\n-   使用类型和副作用系统是强制执行这种纯度区分的标准且稳健的方法。像 $\\mathsf{tick}()$ 这样的有副作用的计算将被赋予一个标记其为非纯的类型（例如 $\\mathsf{IO}\\ \\mathbb{Z}$），而像整数算术这样的纯计算将具有纯类型（例如 $\\mathbb{Z}$）。然后编译器将只允许对纯类型的表达式进行共享优化。这是恢复健全性的充分条件。\n-   **结论：正确。**\n\n**D. 因为按名调用（无共享）不进行记忆化，$E_1$ 和 $E_2$ 之间的差异消失了，这意味着在任何非严格策略下，无论是否存在副作用，公共子表达式消除都是安全的。**\n\n-   让我们在按名调用（无记忆化的惰性求值）下分析这个前提。\n    -   $E_1 \\triangleq \\mathsf{tick}() + \\mathsf{tick}()$：求值仍然需要对两个操作数进行求值，导致两次 tick 和值 $2$。\n    -   $E_2 \\triangleq \\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$：这等同于在每个使用点替换 $x$ 的定义，导致对 $\\mathsf{tick}() + \\mathsf{tick}()$ 的求值。这也导致两次 tick 和值 $2$。\n-   前提是正确的：在按名调用下，$E_1$ 和 $E_2$ 是可观察等价的。\n-   然而，其推论是错误的。它声称在 *任何* 非严格策略下，CSE 都是安全的。按需调用也是一种非严格策略，而我们已经证明在按需调用下，该转换是 *不安全的*。在一种非严格策略（按名调用）下的安全性并不意味着在所有非严格策略下都是安全的。\n-   **结论：不正确。**\n\n**E. 除了禁止副作用，还可以使用线性或唯一性类型规程来防止有副作用的 thunk 的重复。在这种约束下，$\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ 会被拒绝，因为 $x$ 被使用了两次，从而阻止了反例的出现，并在不要求全局纯净性的情况下使共享变得安全。**\n\n-   这个陈述提出了一个基于线性类型的替代解决方案，其中变量必须被精确使用一次。\n-   在表达式 $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x + x$ 中，变量 $x$ 在主体中被使用了两次。如果 $x$ 被赋予一个线性类型（这对于一个有副作用、不可复制的资源是合适的），线性类型检查器会因类型错误而拒绝这个程序。\n-   CSE 优化将 $E_1$ 重写为 $E_2$。如果目标语言包含一个线性类型系统，这个转换可以由类型检查器来保护。编译器只有在生成的 `let` 表达式是类型正确的情况下才被允许执行 CSE。在这种情况下，从 $\\mathsf{tick}() + \\mathsf{tick}()$ 到 $\\mathbf{let}\\ x = \\mathsf{tick}()\\ \\mathbf{in}\\ x+x$ 的转换将被禁止，因为后者违反了线性规则。\n-   这正确地阻止了不健全的优化，而无需所有共享表达式都必须是纯的。它控制的是有副作用的绑定如何被 *使用*，而不是禁止它们被共享。这是一种用于安全管理副作用的有效且成熟的技术。\n-   **结论：正确。**", "answer": "$$\\boxed{ACE}$$", "id": "3649688"}]}