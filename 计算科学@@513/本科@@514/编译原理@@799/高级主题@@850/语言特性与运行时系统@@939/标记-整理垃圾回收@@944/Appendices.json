{"hands_on_practices": [{"introduction": "“标记-整理”算法的效率并非一成不变，它与堆上对象的分布和结构密切相关。这个练习将让你通过量化分析来深入理解这一点。你将比较两种常见的对象图模式——由许多小节点组成的长链表，以及由少数大数组构成的引用集合——来计算它们的整理效率，从而锻炼你精确计算回收空间和指针修复成本的核心技能。[@problem_id:3657487]", "problem": "一个托管运行时使用一种基于标记-整理 (Mark-Compact, MC) 算法的精确垃圾回收 (GC) 方案。在 MC 算法中，回收器首先标记所有从根可达的对象，然后通过重定位存活对象来整理以消除碎片，最后修复存活对象和根中的所有引用，使其指向新的位置。对于一个指针字段，只有当该字段位于一个存活对象（或根）中，并且其值指向一个被移动的存活对象时，才会执行修复操作。\n\n考虑两种堆模式，它们仅在可达对象图的形状和 MC 回收周期开始时死亡对象的分布上有所不同。假设使用 $64$ 位机器，因此每个指针字段占用 $8$ 字节。以下所有大小均为精确的字节数。\n\n模式 A（许多小节点，cons 风格的列表）：\n- 有 $100$ 个独立的单向链表，每个链表最初的长度为 $100$ 个节点，但在回收时，每个链表只能通过一个根指针从其第一个存活节点开始访问。在每个链表中，恰好后缀的 $50$ 个节点是存活的，而前缀的 $50$ 个节点是死亡的。\n- 每个链表节点有一个标记为 $next$ 的指针字段和 $16$ 字节的有效载荷；因此节点大小为 $24$ 字节。\n- 存活节点的 $next$ 字段指向列表中的下一个存活节点，但最后一个节点的 $next$ 为 $\\text{null}$。所有死亡节点都是不可达的，并且不包含任何会被扫描的指针（它们在整理过程中不会被访问或修复）。\n- 每个链表都通过一个指向该链表中第一个存活节点的根指针来访问。\n\n模式 B（少量大型引用数组）：\n- 有 $10$ 个数组，每个数组都是存活的，并且通过一个根指针直接可达。每个数组有 $1{,}000$ 个槽位，数组对象本身由一个 $16$ 字节的头部和紧随其后的 $1{,}000$ 个每个 $8$ 字节的指针槽位组成。\n- 在程序的生命周期内，每个数组分配了恰好 $1{,}000$ 个大小统一的记录对象；在回收时，每个数组中只有 $200$ 个对象仍然可达。\n- 每个数组的 $200$ 个可达记录都由不同的非 $\\text{null}$ 数组槽位指向；每个数组剩下的 $800$ 个记录对象是死亡的（不可达），且没有被任何存活的数组槽位引用。\n- 每个记录对象没有指针字段，占用 $32$ 字节。\n- 每个存活的数组槽位恰好指向一个存活的记录对象；没有存活的记录对象被多于一个槽位引用；所有死亡的记录对象都是不可达且不会被扫描的。\n\n将给定模式下一次 MC 循环的整理效率 $\\mathcal{E}$ 定义为比率\n$$\n\\mathcal{E} = \\frac{\\text{回收的死亡对象总字节数}}{\\text{执行的指针修复总次数}},\n$$\n其中分母计算的是存活对象和根中所有因其引用的对象在整理过程中被移动而更新了值的指针字段的总数。\n\n在这些假设下，计算比率\n$$\nR \\;=\\; \\frac{\\mathcal{E}_{\\text{B}}}{\\mathcal{E}_{\\text{A}}}.\n$$\n请以无单位、不四舍五入的精确最简分数形式给出最终答案。", "solution": "我们的目标是计算比率 $R = \\frac{\\mathcal{E}_{\\text{B}}}{\\mathcal{E}_{\\text{A}}}$，其中整理效率 $\\mathcal{E}$ 的定义如下：\n$$\n\\mathcal{E} = \\frac{\\text{回收的死亡对象总字节数}}{\\text{执行的指针修复总次数}}\n$$\n根据问题描述，如果一个指针字段位于一个存活对象或根中，并且它指向一个在整理过程中被移动的存活对象，那么这个指针就需要被修复。在标准的标记-整理算法中，所有存活对象都会被移动。因此，任何从存活对象或根指向另一个存活对象的非空指针都必须被修复。\n\n**第一步：分析模式 A**\n\n在模式 A 中，有 $100$ 个独立的链表，每个链表包含 $50$ 个死亡节点和 $50$ 个存活节点，每个节点大小为 $24$ 字节。\n\n1.  **计算回收的字节数**：\n    回收的字节数来自于所有死亡的节点。\n    $$\n    \\text{回收字节数}_{\\text{A}} = (\\text{列表数量}) \\times (\\text{每个列表的死亡节点数}) \\times (\\text{节点大小})\n    $$\n    $$\n    \\text{回收字节数}_{\\text{A}} = 100 \\times 50 \\times 24 = 120,000 \\text{ 字节}\n    $$\n\n2.  **计算指针修复次数**：\n    指针修复发生在根指针和存活对象内部的指针。\n    -   **根指针**：有 $100$ 个列表，每个列表都由一个根指针引用其第一个存活节点。由于所有存活节点都会被移动，这 $100$ 个根指针都需要被修复。\n    -   **对象内部指针**：每个列表有 $50$ 个存活节点。在这 $50$ 个节点中，前 $49$ 个节点的 `next` 指针指向下一个存活节点（也即将被移动），因此需要修复。最后一个节点的 `next` 指针为 $\\text{null}$，无需修复。所以每个列表内部有 $49$ 次修复。\n    $$\n    \\text{内部修复次数}_{\\text{A}} = 100 \\times 49 = 4,900\n    $$\n    总修复次数为根指针修复和内部指针修复之和。\n    $$\n    \\text{总修复次数}_{\\text{A}} = 100 + 4,900 = 5,000\n    $$\n\n3.  **计算效率 $\\mathcal{E}_{\\text{A}}$**：\n    $$\n    \\mathcal{E}_{\\text{A}} = \\frac{\\text{回收字节数}_{\\text{A}}}{\\text{总修复次数}_{\\text{A}}} = \\frac{120,000}{5,000} = 24\n    $$\n\n**第二步：分析模式 B**\n\n在模式 B 中，有 $10$ 个存活的数组。每个数组有 $1,000$ 个槽位，最初指向 $1,000$ 个记录对象。在回收时，每个数组有 $200$ 个记录对象存活，$800$ 个死亡。每个记录对象大小为 $32$ 字节。\n\n1.  **计算回收的字节数**：\n    回收的字节数来自于所有死亡的记录对象。\n    $$\n    \\text{回收字节数}_{\\text{B}} = (\\text{数组数量}) \\times (\\text{每个数组的死亡记录数}) \\times (\\text{记录大小})\n    $$\n    $$\n    \\text{回收字节数}_{\\text{B}} = 10 \\times 800 \\times 32 = 256,000 \\text{ 字节}\n    $$\n\n2.  **计算指针修复次数**：\n    -   **根指针**：有 $10$ 个根指针，分别指向 $10$ 个存活的数组。由于这些数组对象本身也是存活对象，将被移动，因此这 $10$ 个根指针都需要被修复。\n    -   **对象内部指针**：存活的对象包括 $10$ 个数组和 $10 \\times 200 = 2,000$ 个记录对象。记录对象没有指针字段。数组对象包含指针字段。每个数组有 $200$ 个槽位指向存活的记录对象。由于这些记录对象将被移动，这 $200$ 个指针都需要被修复。\n    $$\n    \\text{内部修复次数}_{\\text{B}} = 10 \\times 200 = 2,000\n    $$\n    总修复次数为：\n    $$\n    \\text{总修复次数}_{\\text{B}} = 10 + 2,000 = 2,010\n    $$\n\n3.  **计算效率 $\\mathcal{E}_{\\text{B}}$**：\n    $$\n    \\mathcal{E}_{\\text{B}} = \\frac{\\text{回收字节数}_{\\text{B}}}{\\text{总修复次数}_{\\text{B}}} = \\frac{256,000}{2,010} = \\frac{25,600}{201}\n    $$\n\n**第三步：计算比率 R**\n\n最后，我们计算所求的比率 $R$。\n$$\nR = \\frac{\\mathcal{E}_{\\text{B}}}{\\mathcal{E}_{\\text{A}}} = \\frac{\\frac{25,600}{201}}{24} = \\frac{25,600}{201 \\times 24}\n$$\n为了化简分数，我们可以对分子和分母进行约分。注意到 $25,600$ 和 $24$ 都可以被 $8$ 整除：\n$25,600 \\div 8 = 3,200$\n$24 \\div 8 = 3$\n代入表达式：\n$$\nR = \\frac{3,200}{201 \\times 3} = \\frac{3,200}{603}\n$$\n为了确认分数是否最简，我们对分子和分母进行质因数分解：\n-   分子: $3,200 = 32 \\times 100 = 2^5 \\times 10^2 = 2^5 \\times (2 \\times 5)^2 = 2^7 \\times 5^2$\n-   分母: $603 = 3 \\times 201 = 3 \\times (3 \\times 67) = 3^2 \\times 67$\n分子和分母没有共同的质因数，因此该分数是最简形式。", "answer": "$$\\boxed{\\frac{3200}{603}}$$", "id": "3657487"}, {"introduction": "在真实的内存管理中，为了性能，对象通常需要按特定边界（例如 $16$ 字节）对齐。这个看似简单的工程需求会引入额外的空间开销，即所谓的“内部碎片”。本练习提供了一个概率模型，让你能够计算在给定的对象大小分布下，因对齐而产生的预期填充开销，从而将垃圾回收的实现细节与统计分析方法联系起来。[@problem_id:3657450]", "problem": "一个托管运行时采用标记-整理垃圾回收（MCGC），这是一种垃圾回收（GC）形式。在该回收方式中，标记完存活对象后，所有存活对象会被移动，从一个$16$字节对齐的基地址开始，使其在内存中连续排列。整理阶段强制执行一个约束，即每个对象的起始地址都必须是$16$的倍数。这是通过在连续对象之间根据需要插入内部填充来实现的。在最后一个对象之后不会插入填充，因为没有后续对象需要对齐。\n\n假设每个存活对象的总大小$s$（包括一个$16$字节的固定头部及其载荷）是一个独立同分布的离散随机变量，由以下以字节为单位的载荷大小分布决定：\n- 载荷大小 $x \\in \\{0, 6, 11, 17, 24, 33, 46\\}$ 出现的概率分别为 $\\{0.10, 0.20, 0.15, 0.25, 0.10, 0.10, 0.10\\}$。\n因此，$s = 16 + x \\in \\{16, 22, 27, 33, 40, 49, 62\\}$。\n\n使用所述的对齐基本原理和整理策略，推导出每个对象插入的期望内部填充量。最终答案以字节为单位表示。如果在中间步骤需要进行任何数值近似，请以符号形式保留，直到最终计算；最终答案无需四舍五入。", "solution": "我们的目标是计算在垃圾回收的整理阶段，为保证下一个对象地址对齐而插入的内部填充的期望量。对齐约束要求每个对象的起始地址都必须是 $16$ 字节的倍数。\n\n首先，我们形式化地表示单个对象之后所需的填充量。考虑一个总大小为 $s$ 的对象。根据问题，它的起始地址 $A_{start}$ 是 $16$ 的倍数。它占用的内存空间结束于 $A_{start} + s$。下一个对象的起始地址 $A'_{start}$ 必须是大于或等于 $A_{start} + s$ 的最小的 $16$ 的倍数。\n\n在对象之后插入的填充量 $p(s)$ 是下一个对象的对齐起始地址与当前对象所占空间末端之间的差值。这个填充量只取决于对象大小 $s$ 本身，与它的具体起始地址无关。计算公式为：\n$$\np(s) = (16 - (s \\pmod{16})) \\pmod{16}\n$$\n这个公式的含义是：如果 $s$ 正好是 $16$ 的倍数，那么 $s \\pmod{16} = 0$，填充量为 $(16 - 0) \\pmod{16} = 0$。如果 $s$ 不是 $16$ 的倍数，比如 $s \\pmod{16} = r$（其中 $1 \\le r  16$），那么需要填充 $16 - r$ 字节才能使下一个地址对齐。\n\n问题要求计算“每个对象插入的期望内部填充量”。虽然在最后一个对象之后不添加填充，但在大量对象的情况下，每个对象的平均填充量接近于单个对象所需填充量的期望值 $E[p(s)]$。\n\n对象总大小 $s$ 是一个随机变量，其值由载荷大小 $x$ 决定 ($s = 16 + x$)。我们首先列出所有可能的对象大小 $s_i$ 及其对应的概率 $P_i$：\n- 载荷 $x_1=0$, $P_1=0.10 \\implies s_1 = 16 + 0 = 16$\n- 载荷 $x_2=6$, $P_2=0.20 \\implies s_2 = 16 + 6 = 22$\n- 载荷 $x_3=11$, $P_3=0.15 \\implies s_3 = 16 + 11 = 27$\n- 载荷 $x_4=17$, $P_4=0.25 \\implies s_4 = 16 + 17 = 33$\n- 载荷 $x_5=24$, $P_5=0.10 \\implies s_5 = 16 + 24 = 40$\n- 载荷 $x_6=33$, $P_6=0.10 \\implies s_6 = 16 + 33 = 49$\n- 载荷 $x_7=46$, $P_7=0.10 \\implies s_7 = 16 + 46 = 62$\n\n接下来，我们计算每个可能对象大小 $s_i$ 所需的填充量 $p(s_i)$：\n- $p(s_1) = p(16) = (16 - (16 \\pmod{16})) \\pmod{16} = (16 - 0) \\pmod{16} = 0$\n- $p(s_2) = p(22) = (16 - (22 \\pmod{16})) \\pmod{16} = (16 - 6) \\pmod{16} = 10$\n- $p(s_3) = p(27) = (16 - (27 \\pmod{16})) \\pmod{16} = (16 - 11) \\pmod{16} = 5$\n- $p(s_4) = p(33) = (16 - (33 \\pmod{16})) \\pmod{16} = (16 - 1) \\pmod{16} = 15$\n- $p(s_5) = p(40) = (16 - (40 \\pmod{16})) \\pmod{16} = (16 - 8) \\pmod{16} = 8$\n- $p(s_6) = p(49) = (16 - (49 \\pmod{16})) \\pmod{16} = (16 - 1) \\pmod{16} = 15$\n- $p(s_7) = p(62) = (16 - (62 \\pmod{16})) \\pmod{16} = (16 - 14) \\pmod{16} = 2$\n\n期望填充量 $E[p(s)]$ 是每种填充量与其对应概率的乘积之和：\n$$\nE[p(s)] = \\sum_{i=1}^{7} p(s_i) P_i\n$$\n代入数值进行计算：\n$$\nE[p(s)] = (0 \\times 0.10) + (10 \\times 0.20) + (5 \\times 0.15) + (15 \\times 0.25) + (8 \\times 0.10) + (15 \\times 0.10) + (2 \\times 0.10)\n$$\n计算每一项：\n$$\nE[p(s)] = 0.0 + 2.0 + 0.75 + 3.75 + 0.8 + 1.5 + 0.2\n$$\n将各项相加得到最终的期望值：\n$$\nE[p(s)] = 9.0\n$$\n因此，每个对象插入的期望内部填充为 $9.0$ 字节。", "answer": "$$\n\\boxed{9.0}\n$$", "id": "3657450"}, {"introduction": "检验是否真正理解一个算法的最终标准是亲手实现它。这个练习将引导你从零开始，构建一个完整的“标记-整理”垃圾回收器模拟程序。通过亲手编写标记、整理以及触发GC的决策逻辑，你将把所有理论知识融会贯通，牢固掌握整个算法流程的每个环节。[@problem_id:3657427]", "problem": "您需要设计并实现一个基于原则的标记-整理（mark-compact）垃圾回收器模拟，该回收器应用于一种小型的、显式管理的语言。该模拟必须以一个完整的、可运行的程序形式表达，并且必须产生一个确定性的、单行的输出，该输出聚合了一个小型测试套件的结果。目标是从核心定义出发，构建决定何时根据存活内存阈值进行整理的逻辑，同时检测每个调用点的分配统计数据。\n\n该问题的基本基础如下：\n\n- 堆（heap）是对象的有限集合，每个对象都有一个以字节为单位的固定大小和有限数量的引用字段。对象可以通过索引引用其他对象。\n- 根集（root set）是变量的有限集合，其中任何一个变量都可能持有对堆对象的引用。设根变量为一个固定大小的向量。\n- 可达性（Reachability）是归纳定义的：如果一个对象在根集中，或者被一个可达对象所引用，那么它就是可达的。不可达对象被视为垃圾（garbage）。\n- 标记-整理（Mark-compact）垃圾回收包括两个概念阶段：\n  1. 标记阶段（Mark phase）：从根集开始，递归标记所有可达对象。\n  2. 整理阶段（Compact phase）：将标记的对象重定位到内存中连续的位置，更新对象和根中的引用以指向它们的新位置，并丢弃所有未标记的对象。\n- 触发整理的决策基于存活字节数（live bytes）：计算可达（已标记）对象的总字节数，当且仅当这个总和严格超过阈值 $L$ 时触发整理。\n\n您将实现一种小型语言，其执行通过以下操作修改堆和根：\n\n- 分配操作，参数包括：调用点标识符 $c \\in \\mathbb{N}$，大小 $s \\in \\mathbb{N}$ 字节，根集中的变量索引 $v \\in \\mathbb{N}$，以及字段数 $f \\in \\mathbb{N}$。此操作创建一个具有 $f$ 个引用字段（初始化为空）的对象，记录该分配发生在调用点 $c$，并将对新对象的引用存储在根变量 $v$ 中。\n- 链接操作，参数包括：源变量索引 $v_s \\in \\mathbb{N}$，字段索引 $i \\in \\mathbb{N}$，以及目标变量索引 $v_t \\in \\mathbb{N}$。此操作将根变量 $v_s$ 引用的对象的字段 $i$ 设置为引用根变量 $v_t$ 引用的对象。\n- 丢弃操作，参数为：变量索引 $v \\in \\mathbb{N}$。此操作将根变量 $v$ 设置为空。\n- 整理决策策略：每次分配后，通过从当前根集进行标记并对已标记对象的字节数求和来计算存活字节数；如果总和严格大于 $L$，则立即按上述方式执行整理。如果未执行整理，则必须清除用于决策的标记，以确保未来的决策是从干净的状态计算的。\n\n您必须检测每个调用点的分配统计数据。对于每个调用点标识符 $c$，记录在测试程序整个执行期间在该点分配的累计总字节数，无论这些字节后来是否被回收。\n\n您的解释器必须支持固定大小的堆和固定数量的根变量。所有内存使用量的计算都必须以字节为单位，并且您最终报告的内存值也必须以字节为单位。\n\n定义三个测试程序（测试套件），每个程序由一系列操作和一个阈值 $L$ 组成，如下所示。在每条指令中，任何整数都以字节或索引的形式给出，调用点标识符是整数。所有分配中的堆对象都应只有一个字段（即，以下所有分配的 $f = 1$）。\n\n- 测试案例 1（正常路径，发生两次整理）：\n  - 阈值 $L = 50$。\n  - 操作（按顺序）：\n    - 在调用点 $c = 1$ 分配大小为 $s = 20$ 的对象到变量 $v = 0$，字段数为 $f = 1$。\n    - 在调用点 $c = 2$ 分配大小为 $s = 20$ 的对象到变量 $v = 1$，字段数为 $f = 1$。\n    - 链接：将变量 $v_s = 0$ 的字段 $i = 0$ 设置为变量 $v_t = 1$ 中的对象。\n    - 在调用点 $c = 1$ 分配大小为 $s = 30$ 的对象到变量 $v = 2$，字段数为 $f = 1$。\n    - 链接：将变量 $v_s = 1$ 的字段 $i = 0$ 设置为变量 $v_t = 2$ 中的对象。\n    - 丢弃变量 $v = 0$。\n    - 丢弃变量 $v = 1$。\n    - 在调用点 $c = 3$ 分配大小为 $s = 15$ 的对象到变量 $v = 3$，字段数为 $f = 1$。\n    - 丢弃变量 $v = 2$。\n    - 在调用点 $c = 1$ 分配大小为 $s = 40$ 的对象到变量 $v = 4$，字段数为 $f = 1$。\n- 测试案例 2（边界条件，恰好在阈值上，不进行整理）：\n  - 阈值 $L = 60$。\n  - 操作：\n    - 在调用点 $c = 1$ 分配大小为 $s = 30$ 的对象到变量 $v = 0$，字段数为 $f = 1$。\n    - 在调用点 $c = 2$ 分配大小为 $s = 30$ 的对象到变量 $v = 1$，字段数为 $f = 1$。\n- 测试案例 3（不可达循环，发生一次整理）：\n  - 阈值 $L = 25$。\n  - 操作：\n    - 在调用点 $c = 5$ 分配大小为 $s = 10$ 的对象到变量 $v = 0$，字段数为 $f = 1$。\n    - 在调用点 $c = 5$ 分配大小为 $s = 10$ 的对象到变量 $v = 1$，字段数为 $f = 1$。\n    - 链接：将变量 $v_s = 0$ 的字段 $i = 0$ 设置为变量 $v_t = 1$ 中的对象。\n    - 链接：将变量 $v_s = 1$ 的字段 $i = 0$ 设置为变量 $v_t = 0$ 中的对象。\n    - 丢弃变量 $v = 0$。\n    - 丢弃变量 $v = 1$。\n    - 在调用点 $c = 6$ 分配大小为 $s = 30$ 的对象到变量 $v = 2$，字段数为 $f = 1$。\n\n您的程序必须独立执行每个测试案例（在案例之间重置堆和根变量），并为每个测试案例 $t$ 计算以下内容：\n\n- $C_t$：执行的整理次数（一个整数）。\n- $L_t^{\\mathrm{final}}$：程序结束后最终的存活字节数（一个整数，单位为字节）。\n- $\\mathbf{A}_t$：每个调用点的总分配量列表（单位为字节），按该测试案例中观察到的调用点标识符升序排列。\n\n最终输出格式要求：\n\n- 您的程序应产生单行输出，其中包含所有三个测试案例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个测试案例表示为 $[C_t, L_t^{\\mathrm{final}}, \\mathbf{A}_t]$ 列表。例如，格式为 $[[C_1,L_1^{\\mathrm{final}},[a_{1,1},a_{1,2},\\dots]],[C_2,L_2^{\\mathrm{final}},[a_{2,1},a_{2,2},\\dots]],[C_3,L_3^{\\mathrm{final}},[a_{3,1},a_{3,2},\\dots]]]$。所有数字必须是整数，所有内存量均以字节为单位。\n\n解释器、垃圾回收器和检测工具必须在一个单独的 C 程序中实现，该程序无需输入即可运行，并精确打印所需的单行输出。", "solution": "要完成此任务，需要模拟一个标记-整理垃圾回收器，并根据给定的三个测试用例执行它，最终生成一个包含所有结果的确定性输出。以下是实现该模拟的核心逻辑和数据结构的概述。\n\n### 模拟设计\n\n1.  **数据结构**\n    -   **对象 (Object)**: 使用一个结构体来表示堆中的对象，包含其大小 `size`、一个标记位 `marked`、一个用于整理的转发地址 `forward_addr`，以及一个引用字段数组 `fields`。\n    -   **堆 (Heap)**: 可以用一个对象结构体的数组来模拟，通过索引来表示对象的“地址”。一个计数器 `heap_ptr` 跟踪下一个可用的堆位置（即“碰撞指针”）。\n    -   **根集 (Root Set)**: 一个固定大小的索引数组，每个元素存储一个指向堆中对象的索引。一个特殊值（如-1）可以表示空引用。\n    -   **分配统计 (Allocation Stats)**: 一个映射或数组，用于按调用点ID累计分配的总字节数。\n\n2.  **核心算法**\n    -   **标记阶段 (Mark Phase)**:\n        -   该阶段从根集开始，对所有可达对象进行图遍历（如深度优先搜索）。\n        -   创建一个工作栈，将所有根引用的对象索引压入栈中。\n        -   循环处理栈，直到为空：弹出一个对象索引，如果该对象未被标记，则将其标记为 `marked`，并将其引用的所有对象的索引压入栈中。\n        -   在标记的同时，计算所有已标记对象的总大小（存活字节数）。\n\n    -   **整理阶段 (Compact Phase)**:\n        -   **计算新地址**: 遍历堆，为每个已标记（存活）的对象计算一个新的、连续的地址（索引）。这个新地址存储在对象的 `forward_addr` 字段中。\n        -   **更新引用**: 再次遍历所有根和所有已标记的对象。对于其中的每一个引用，将其更新为所引用对象的 `forward_addr`。\n        -   **移动对象**: 遍历堆，将每个已标记的对象从其旧位置复制到其 `forward_addr` 指定的新位置。\n        -   更新 `heap_ptr` 为存活对象的数量，并清除所有存活对象的标记位，为下一次GC做准备。\n\n    -   **GC 触发逻辑**:\n        -   在每次 `Allocate` 操作之后，立即执行一次完整的标记阶段来计算存活字节数。\n        -   将计算出的存活字节数与阈值 $L$ 进行比较。如果存活字节数严格大于 $L$，则触发整理阶段。\n        -   如果未触发整理，则必须遍历堆，清除所有对象的标记位，以确保下一次GC决策的正确性。\n\n### 测试用例执行逻辑\n\n对每个测试用例，程序需要：\n1.  初始化堆、根集和统计数据。\n2.  按顺序执行操作指令。\n3.  在每次分配后，运行GC检查和触发逻辑。\n4.  在所有指令执行完毕后，再执行一次标记阶段来计算最终的存活字节数 $L_t^{\\mathrm{final}}$。\n5.  记录整理次数 $C_t$、最终存活字节数 $L_t^{\\mathrm{final}}$ 和分配统计 $\\mathbf{A}_t$。\n6.  将所有三个测试用例的结果格式化为指定的单行字符串。\n\n通过对三个测试用例进行精确的逻辑推演，可以得出以下结果：\n\n-   **测试用例 1 (L=50)**: 第一次GC在分配第三个对象（大小30）后触发，此时存活字节为 20+20+30=70 > 50。第二次GC在分配第五个对象（大小40）后触发，此时存活字节为 15+40=55 > 50。最终，有两个对象（大小15和40）存活。\n-   **测试用例 2 (L=60)**: 分配两个大小为30的对象后，存活字节为 30+30=60。由于不满足“严格大于”的条件，GC不会触发。\n-   **测试用例 3 (L=25)**: 在创建并丢弃一个循环引用后，分配一个大小为30的对象。此时，只有这个新对象是可达的，存活字节为30 > 25，触发GC。循环引用的两个对象被回收。\n\n综合以上分析，程序应计算并输出确定的结果。", "answer": "[[2, 55, [90, 20, 15]], [0, 60, [30, 30]], [1, 30, [20, 30]]]", "id": "3657427"}]}