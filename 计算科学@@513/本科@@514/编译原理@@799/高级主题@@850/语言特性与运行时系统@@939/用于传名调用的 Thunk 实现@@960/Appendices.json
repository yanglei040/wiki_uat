{"hands_on_practices": [{"introduction": "要真正理解传名调用，最好的方法是亲手追踪其执行过程。这个练习将引导你模拟一个编译器的求值过程，在一个嵌套的函数调用中，精确地计算一个由thunk表示的参数被“强制求值”的次数 [@problem_id:3675795]。通过这个过程，你将直观地感受到惰性求值中“按需驱动”的本质，并理解重复求值是如何发生的。", "problem": "在编译器原理的背景下，考虑一种通过 thunk 实现的一阶、传名调用求值策略。thunk 是一种延迟计算，表示为一个捕获了表达式及其环境的闭包，并且只有在其值被需要（强制执行）时才执行。在传名调用中，没有记忆化：每次使用形式参数都会从头重新求值 thunk。假设基本操作遵循确定性的从左到右的求值顺序：对于加法运算符，先求值左操作数，再求值右操作数；对于条件表达式，先求值条件，再求值所选分支；对于词法绑定，一个 $\\text{let}$ 按名称绑定（非严格），绑定的表达式直到绑定的名称被使用时才求值。\n\n设实际参数为表达式 $x_{n} = \\sum_{i=1}^{n} i$，其中 $n$ 是一个满足 $n \\geq 1$ 的整数，形式参数为 $a$。该参数以 thunk $\\theta_{a}$ 的形式传递给函数 $f$，每次引用 $a$ 时，$\\theta_{a}$ 都会重新求值 $x_{n}$。对运行时进行插桩，使得每次 $\\theta_{a}$ 被强制执行时，全局计数器 $F$ 增加 $1$。我们忽略任何其他成本，仅计算 $\\theta_{a}$ 被强制执行的次数。\n\n定义函数 $f$ 如下，其中 $k$ 是一个非负整数参数：\n1. 辅助复制函数定义为\n$$\\operatorname{rep}_{k}(a) = \\begin{cases}\n0,  \\text{if } k = 0, \\\\\na + \\operatorname{rep}_{k-1}(a),  \\text{if } k > 0,\n\\end{cases}$$\n其中加法从左到右求值。\n2. 函数 $f$ 定义为\n$$\nf(a, k) = \\text{if } a > 0 \\text{ then } \n\\Big(\n\\text{let } b = a + a \\text{ in }\n\\text{let } c = a + b \\text{ in }\n\\text{let } d = b + b \\text{ in }\nc + d + \\operatorname{rep}_{k}(a)\n\\Big)\n\\text{ else } 0.\n$$\n\n在上述使用非记忆化 thunk 的传名调用语义下，且 $n \\geq 1$ 时，当实际参数是 $x_{n}$ 的 thunk $\\theta_{a}$ 时，确定在求值 $f(a, k)$ 期间 $\\theta_{a}$ 被强制执行的总次数。请用关于 $k$ 的封闭形式表达式表示。將你的最終答案表示為單個解析表達式。無需四捨五入。", "solution": "此推导的基本依据是传名调用与 thunk 的定义：形式参数 $a$ 表示一个 thunk $\\theta_{a}$，当被强制执行时，它会在捕获的环境中重新求值其关联的表达式。在没有记忆化的传名调用下，已执行代码中每次 $a$ 的语法出现都会导致一次对 $\\theta_{a}$ 的独立强制执行。我们还使用指定的基本操作从左到右的求值顺序以及延迟求值直到使用时的非严格 $\\text{let}$ 绑定。\n\n我们通过分析在求值 $f(a, k)$ 过程中 $\\theta_{a}$ 的需求驱动的强制执行行为，来计算 $a$ 被引用的次数，从而得出 $\\theta_{a}$ 被强制执行的次数。我们假设 $n \\geq 1$，因此 $x_{n} = \\sum_{i=1}^{n} i$ 是正数，所以 $a > 0$ 成立。因此，将执行 $\\text{then}$ 分支，而 $\\text{else}$ 分支不会被求值。\n\n步骤 1：求值条件守卫 $a > 0$。\n- 条件引用了 $a$ 一次。\n- 这会强制执行 $\\theta_{a}$ 恰好一次。\n- 对 $F$ 的贡献：$1$。\n\n步骤 2：进入 $\\text{then}$ 分支并处理嵌套的 $\\text{let}$ 绑定。因为 $\\text{let}$ 是按名称绑定的，所以右侧表达式在绑定时不会被求值，而只在它们绑定的名称被使用时才求值。\n\n$\\text{then}$ 分支的主体是：\n$$\n\\text{let } b = a + a \\text{ in }\n\\text{let } c = a + b \\text{ in }\n\\text{let } d = b + b \\text{ in }\nc + d + \\operatorname{rep}_{k}(a).\n$$\n\n我们从左到右求值最终表达式 $c + d + \\operatorname{rep}_{k}(a)$。\n\n步骤 2a：强制执行 $c$。\n- $c$ 定义为 $a + b$，从左到右求值。\n- 首先，求值 $a + b$ 中的 $a$：这会强制执行 $\\theta_{a}$ 一次。\n- 接下来，求值 $a + b$ 中的 $b$：这会强制执行 $b$。\n- 强制执行 $b$ 会从左到右求值 $a + a$：\n  - 求值左边的 $a$：强制执行 $\\theta_{a}$ 一次。\n  - 求值右边的 $a$：强制执行 $\\theta_{a}$ 一次。\n- 由 $c$ 引起的 $\\theta_{a}$ 总强制执行次数：$1$ (对于 $a+b$ 中的 $a$) $+ 2$ (对于 $b$ 中的两个 $a$) $= 3$。\n- 对 $F$ 的贡献：$3$。\n\n步骤 2b：强制执行 $d$。\n- $d$ 定义为 $b + b$，从左到右求值。\n- 求值左边的 $b$：强制执行 $b$ 会求值 $a + a$，这会强制执行 $\\theta_{a}$ 两次（左边的 $a$ 和右边的 $a$）。\n- 求值右边的 $b$：强制执行 $b$ 会再次求值 $a + a$，这会再次强制执行 $\\theta_{a}$ 两次。\n- 由 $d$ 引起的 $\\theta_{a}$ 总强制执行次数：$2 + 2 = 4$。\n- 对 $F$ 的贡献：$4$。\n\n步骤 2c：强制执行 $\\operatorname{rep}_{k}(a)$。\n- 定义为 $\\operatorname{rep}_{k}(a) = 0$ (如果 $k=0$)，否则为 $a + \\operatorname{rep}_{k-1}(a)$。\n- 对于 $k > 0$，每个递归步骤首先求值 $a$（从左到右的加法），然后对 $\\operatorname{rep}_{k-1}(a)$ 进行递归。\n- 因此，对于 $k$ 个步骤中的每一个， $a$ 都被精确引用一次，所以 $\\theta_{a}$ 在每一步都被强制执行一次。\n- 由 $\\operatorname{rep}_{k}(a)$ 引起的 $\\theta_{a}$ 总强制执行次数：$k$。\n- 对 $F$ 的贡献：$k$。\n\n步骤 3：所有贡献的总和。\n- 来自条件守卫：$1$。\n- 来自强制执行 $c$：$3$。\n- 来自强制执行 $d$：$4$。\n- 来自强制执行 $\\operatorname{rep}_{k}(a)$：$k$。\n\n因此，在求值 $f(a, k)$ 期间，$\\theta_{a}$ 被强制执行的总次数是\n$$k + 1 + 3 + 4 = k + 8.$$\n\n这个计数仅取决于语法出现和指定的求值顺序；$n \\geq 1$ 时 $x_{n}$ 的值为正数确保了 $\\text{then}$ 分支被执行，但没有进一步的分支依赖于 $a$。因此，总强制执行次数的封闭形式表达式是 $k + 8$。", "answer": "$$\\boxed{k+8}$$", "id": "3675795"}, {"introduction": "在上一个练习中，我们看到了重复求值现象的存在，现在我们将量化其性能影响。本练习引入了一个明确的成本模型，让你能够像编译器设计者一样，分析纯粹的传名调用与引入共享（或称“记忆化”）优化后的成本差异 [@problem_id:3675854]。通过这种量化分析，你将深入理解为何需要像传需调用（call-by-need）这样的优化策略，并学会评估其效益。", "problem": "一个严格一阶算术语言的编译器通过 thunk 实现传名调用。thunk 是一个存储了未求值的参数表达式及其环境的闭包。强制执行一个 thunk 会在捕获的环境中触发该表达式的求值。在纯粹的传名调用下，每次强制执行都会重新求值该表达式。考虑函数体 $f(x,y) = x + y + x$，并假设加法是对两个操作数都严格的基本运算符。\n\n假设使用以下成本模型，其中所有成本都是可相加的：\n- 每次强制执行任意 thunk 会产生一个固定的开销成本 $h$。\n- 求值 x 的表达式（不包括 thunk 开销）的成本为 $c_{x}$。\n- 求值 y 的表达式（不包括 thunk 开销）的成本为 $c_{y}$。\n- 每次基本加法 $+$ 的成本为 $a$。\n- 作为一种可选的转换，编译器可以引入一个局部绑定，在 $x$ 的多次使用中共享其值（仅对 $x$ 模拟传需调用）：以成本 $m$ 分配一个单元一次，以成本 $s$ 存储首次求值的结果一次，并以成本 $r$ 从该单元中满足 $x$ 的后续每次使用，而无需重新求值 $x$ 的表达式。$x$ 的首次使用仍然会强制执行和求值 thunk，产生 $h + c_{x}$ 的成本。\n\n从传名调用 thunk 和 $+$ 的严格求值的基本定义出发，进行以下推理：\n- 确定函数体 $f(x,y) = x + y + x$ 中每个参数 $x$ 和 $y$ 的动态强制执行乘数。\n- 根据成本模型的第一性原理和已确定的乘数，推导出在纯粹的传名调用（无共享）下求值 $f(x,y)$ 的总执行成本。\n- 如果编译器仅对 $x$ 应用共享转换（不共享 $y$），推导出总执行成本。\n- 讨论使用结合律和交换律重排加数（例如，$(x + x) + y$ 或 $y + x + x$）是否会改变任一机制下的总成本，并选择能使总成本最小化的方案（纯粹的传名调用 vs. 共享 $x$）和顺序。\n- 使用参数值 $h = 3$, $c_{x} = 40$, $c_{y} = 10$, $a = 1$, $m = 2$, $s = 1$ 和 $r = 1$，计算在最优方案和顺序下求值 $f(x,y)$ 的最小总成本。\n\n将最终答案表示为一个无单位的实数值。无需四舍五入。", "solution": "我们分两种情况计算总成本：纯粹的传名调用和对 $x$ 进行共享优化的调用。加法从左到右求值。\n\n1.  **纯粹的传名调用（无共享）**\n    函数体是 $x + y + x$。参数 $x$ 被使用了两次，参数 $y$ 被使用了一次。\n    -   求值第一个 $x$：强制执行 thunk，成本为 $h + c_{x}$。\n    -   求值 $y$：强制执行 thunk，成本为 $h + c_{y}$。\n    -   求值第二个 $x$：再次强制执行 thunk，成本为 $h + c_{x}$。\n    -   两次加法运算：成本为 $2a$。\n    总成本 = $(h + c_{x}) + (h + c_{y}) + (h + c_{x}) + 2a = 2(h + c_{x}) + (h + c_{y}) + 2a$。\n    代入数值：$2(3 + 40) + (3 + 10) + 2(1) = 2(43) + 13 + 2 = 86 + 13 + 2 = 101$。\n\n2.  **对 $x$ 应用共享（模拟传需调用）**\n    -   首次使用 $x$：需要分配内存 ($m$)，强制执行 thunk ($h + c_{x}$)，并存储结果 ($s$)。成本为 $m + h + c_{x} + s$。\n    -   使用 $y$：强制执行 thunk，成本为 $h + c_{y}$。\n    -   第二次使用 $x$：从内存中读取已存结果，成本为 $r$。\n    -   两次加法运算：成本为 $2a$。\n    总成本 = $(m + h + c_{x} + s) + (h + c_{y}) + r + 2a$。\n    代入数值：$(2 + 3 + 40 + 1) + (3 + 10) + 1 + 2(1) = 46 + 13 + 1 + 2 = 62$。\n\n3.  **顺序和最优选择**\n    由于加法从左到右求值，表达式 $x + y + x$ 的求值顺序是固定的。使用结合律和交换律重排为 $(x+x)+y$ 或 $y+(x+x)$ 也不会改变强制执行的次数和基本运算的次数，因此成本不变。\n    比较两种策略的成本：纯粹传名调用成本为 101，对 $x$ 共享的成本为 62。\n    因此，最优方案是应用共享转换，最小总成本为 62。", "answer": "$$\\boxed{62}$$", "id": "3675854"}, {"introduction": "优化性能时，我们常常会考虑对计算结果进行记忆化（memoization），但这是否会改变原始的语义呢？这个练习通过别名（aliasing）和副作用（side effects）等精巧的场景，探讨了纯粹的传名调用（每次都重新求值）与带有记忆化的传需调用（call-by-need）之间的根本区别 [@problem_id:3675807]。完成这个练习有助于你精确地区分这两种求值策略，避免在实际应用中混淆它们。", "problem": "在一个具有词法作用域和一等公民过程的语言的标准解释器中，传名调用（CBN）是通过为每个实参传递一个 thunk 来实现的。一个 thunk 是一个序对 $\\langle e,\\rho\\rangle$，其中 $e$ 是未求值的表达式，$\\rho$ 是将 $e$ 的自由变量映射到位置或值的环境。强制求值一个 thunk，记作 $\\operatorname{force}(\\langle e,\\rho\\rangle)$，是在环境 $\\rho$ 下对 $e$ 进行求值。根据传名调用的定义，每次在被调用者函数体中使用其对应的形参时，都会对实参表达式进行求值；也就是说，在多次使用之间不会重用先前的求值结果。\n\n考虑一个函数应用，其中被调用者有两个形参，而调用者为这两个形参提供了相同的实参表达式，因此被调用者接收到两个别名到同一个 thunk $\\langle e,\\rho\\rangle$ 的绑定。你正在评估 $\\operatorname{force}$ 的实现应该是每次调用时都重新计算 $e$，还是在第一次求值后重用存储在 thunk 中的记忆化结果。正在考虑两种实现策略：\n- 策略 $1$：从不记忆化；每次调用 $\\operatorname{force}(\\langle e,\\rho\\rangle)$ 都会在环境 $\\rho$ 中重新对 $e$ 求值。\n- 策略 $2$：在 thunk 内部进行记忆化；第一次调用 $\\operatorname{force}(\\langle e,\\rho\\rangle)$ 会在环境 $\\rho$ 中对 $e$ 求值并将结果存储在 thunk 中；后续的调用则返回存储的结果，而不再重新对 $e$ 求值。\n\n假设语言可能包含副作用（例如修改或打印），并且可能有不会终止的计算。被调用者可能会多次使用每个参数。当调用者两次传递相同的表达式时，例如在语法上类似于 $f(x,x)$ 的调用中，两个形参可能会别名到同一个 thunk 对象。\n\n以下哪个陈述是正确的？\n\nA. 在传名调用下，策略 $1$ 是必需的；即使两个形参别名到同一个 thunk $\\langle e,\\rho\\rangle$，每次对参数进行强制求值也必须独立地重新计算 $e$。当 $e$ 具有副作用或可能发散时，使用策略 $2$ 通常会改变语义。\n\nB. 对所有程序而言，策略 $2$ 在可观察行为上等价于传名调用；记忆化只能提高性能，而不能改变可观察行为。\n\nC. 由于别名，被调用者必须复制 thunk 对象，以使每个形参都有一个不同的 thunk；否则，即使使用策略 $1$，通过一个参数进行强制求值也会错误地影响通过另一个参数进行的强制求值。\n\nD. 在一个纯粹的环境中，当 $e$ 是引用透明且会终止时，对于形式为 $f(e,e)$ 的调用，策略 $1$ 和 $2$ 在可观察行为上是等价的；在这种情况下，共享一个记忆化的 thunk 会产生与传名调用相同的结果。", "solution": "此问题探讨了纯粹的传名调用（策略1）与传需调用（策略2，即带记忆化的传名调用）在语义上的关键区别。\n\n- **陈述 A 是正确的。** 传名调用的严格定义要求每次使用参数时都重新求值其对应的表达式。策略1正是此定义的直接实现。如果表达式 `e` 带有副作用（如修改一个全局计数器）或可能不会终止（发散），策略2（记忆化）会显著改变程序的行为。例如，对于 `f(e,e)`，如果 `e` 是 `(counter++)`，策略1会使计数器增加两次，而策略2只会使其增加一次。因此，记忆化在这种情况下不是一个纯粹的优化，而是一个语义上的改变。\n\n- **陈述 B 是错误的。** 如上所述，当存在副作用或非终止计算时，记忆化会改变程序的可观察行为（例如，I/O操作的次数、最终的全局状态等），因此两种策略不等价。\n\n- **陈述 C 是错误的。** 当调用者传递 `f(e,e)` 时，两个形式参数别名到同一个thunk是传名调用语义的自然结果。解释器不需要也不应该复制thunk。策略1在这种别名情况下正确地工作：每次通过任一形式参数强制求值，都会重新计算共享的表达式 `e`，这完全符合传名调用的定义。\n\n- **陈述 D 是正确的。** 在一个纯粹的环境中，表达式 `e` 是引用透明的，这意味着它的值仅取决于其输入，且没有可观察的副作用。如果 `e` 还会终止，那么每次对它求值都会得到完全相同的结果。在这种受限的情况下，重新计算（策略1）和计算一次并重用结果（策略2）在最终结果上是等价的，因此可观察行为相同。策略2此时可以被视为一种安全的性能优化。\n\n综上所述，陈述 A 和 D 是正确的。", "answer": "$$\\boxed{AD}$$", "id": "3675807"}]}