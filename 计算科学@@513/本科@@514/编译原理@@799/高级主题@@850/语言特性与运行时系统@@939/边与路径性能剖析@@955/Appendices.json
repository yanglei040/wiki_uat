{"hands_on_practices": [{"introduction": "为了从根本上理解路径剖析，我们首先要掌握一种为程序中每条路径分配唯一标识符的方法。Ball-Larus算法正是实现这一目标的核心技术。通过本练习，你将亲手计算边权重并生成路径ID，从而深入理解该算法的内部工作机制，并探索当控制流图发生变化时，该编号方案为何需要重新调整。[@problem_id:3640199]", "problem": "考虑用于无环控制流图 (CFG) 的 Ball–Larus 路径剖析方案，其中唯一的路径标识符被计算为任何从入口到出口路径上所有边权值之和。该方案通过在每个分支节点为出边设置固定顺序，并根据从每个节点到出口的不同路径数量来分配边权值，从而确保唯一性。假设遵循标准的 Ball–Larus 约定，即节点的第一个出边权值为 $0$，而后续出边的权值反映了在固定的出边顺序下，因选择前面的出边而跳过的路径的累积数量。\n\n给定以下人工构造的 CFG，其入口节点为 $S$，出口节点为 $X$：\n- 节点：$S, A, B, C, D, E, F, X$。\n- 有向边：$(S,A)$, $(A,B)$, $(A,C)$, $(B,D)$, $(B,E)$, $(C,F)$, $(D,X)$, $(E,X)$, $(F,X)$。\n- 出边的固定顺序：\n  - 在节点 $A$：先是 $(A,B)$，然后是 $(A,C)$。\n  - 在节点 $B$：先是 $(B,D)$，然后是 $(B,E)$。\n  - 所有其他节点都只有一条出边。\n\n任务：\n1. 使用 Ball–Larus 路径剖析原理和给定的出边顺序，计算 CFG 中所有边的原始权值 $w(e)$ 以及所有从入口到出口路径的最终路径标识符。\n2. 现在引入一个拓扑变化，添加一条新的快捷边 $e_{s} = (B,X)$，使得节点 $B$ 有三条出边。在一个简单的修补方案下，该方案保留所有原始边上先前计算的权值，并设置 $w(e_{s}) = 0$，判断是否会发生路径标识符冲突。如果发生冲突，请给出两条在该简单赋值下计算出的标识符相等的、不同的从入口到出口的路径。\n3. 使用 Ball–Larus 路径剖析原理，为修改后的 CFG（包括 $e_{s}$）重新计算边权值 $w'(e)$，其中节点 $B$ 处的固定顺序如下：先是 $(B,D)$，然后是 $(B,E)$，最后是 $(B,X)$。保持节点 $A$ 处的顺序如上所述不变。确认重新计算的权值恢复了所有从入口到出口路径的路径标识符的唯一性。\n4. 将重赋权代价定义为\n$$\nC \\;=\\; \\sum_{e \\in E_{\\text{orig}}} \\left| w'(e) - w(e) \\right|,\n$$\n其中 $E_{\\text{orig}}$ 是在添加 $e_{s}$ 之前原始 CFG 中的边集。计算 $C$ 的值，结果为一个实数值。无需四舍五入。你的最终答案应该是一个没有单位的纯数字。\n\n你的最终答案应该只包含 $C$ 的值。", "solution": "本问题要求对给定的无环控制流图 (CFG) 逐步应用和分析 Ball–Larus 路径剖析算法。解答分为四个部分，与题目中的四个任务相对应。\n\nBall–Larus 算法包括两个主要阶段：\n1.  从出口节点到入口节点的自底向上遍历，为每个节点 $n$ 计算 $\\text{NumPaths}(n)$，即从 $n$ 到出口节点 $X$ 的不同路径数量。对于一个有后继节点 $s_1, s_2, \\ldots, s_k$ 的节点 $n$，$\\text{NumPaths}(n)$ 由 $\\sum_{i=1}^{k} \\text{NumPaths}(s_i)$ 给出。根据定义，$\\text{NumPaths}(X) = 1$。\n2.  从入口节点到出口节点的自顶向下遍历，为每条边 $e = (u,v)$ 分配权值 $w(e)$。在每个节点 $u$，若其出边按固定顺序为 $(u, v_1), (u, v_2), \\ldots, (u, v_k)$，则权值分配如下：$w(u, v_1) = 0$ 且对于 $i > 1$，$w(u, v_i) = \\sum_{j=1}^{i-1} \\text{NumPaths}(v_j)$。\n\n任何从入口到出口路径的路径标识符是构成该路径的所有边的权值之和。\n\n### 任务 1：原始边权值和路径标识符\n\n首先，我们为原始 CFG 中的所有节点 $n$ 计算 $\\text{NumPaths}(n)$。\n-   节点：$S, A, B, C, D, E, F, X$。\n-   出口节点：$X$。\n-   根据定义，$\\text{NumPaths}(X) = 1$。\n-   从 $X$ 开始反向计算：\n    -   $\\text{NumPaths}(D) = \\text{NumPaths}(X) = 1$。\n    -   $\\text{NumPaths}(E) = \\text{NumPaths}(X) = 1$。\n    -   $\\text{NumPaths}(F) = \\text{NumPaths}(X) = 1$。\n    -   $\\text{NumPaths}(C) = \\text{NumPaths}(F) = 1$。\n    -   $\\text{NumPaths}(B) = \\text{NumPaths}(D) + \\text{NumPaths}(E) = 1 + 1 = 2$。\n    -   $\\text{NumPaths}(A) = \\text{NumPaths}(B) + \\text{NumPaths}(C) = 2 + 1 = 3$。\n    -   $\\text{NumPaths}(S) = \\text{NumPaths}(A) = 3$。\n这表明从入口 $S$ 到出口 $X$ 有 $3$ 条唯一路径。\n\n接下来，我们计算边权值 $w(e)$。\n-   节点 $S$：只有一条出边 $(S,A)$。因此，$w(S,A)=0$。\n-   节点 $A$：出边顺序为 $(A,B), (A,C)$。\n    -   $w(A,B) = 0$ (第一条边)。\n    -   $w(A,C) = \\text{NumPaths}(B) = 2$。\n-   节点 $B$：出边顺序为 $(B,D), (B,E)$。\n    -   $w(B,D) = 0$ (第一条边)。\n    -   $w(B,E) = \\text{NumPaths}(D) = 1$。\n-   节点 $C, D, E, F$ 各只有一条出边，因此它们的权值为 $0$。\n    -   $w(C,F) = 0$, $w(D,X) = 0$, $w(E,X) = 0$, $w(F,X) = 0$。\n\n原始边权值 $w(e)$ 如下：\n$w(S,A)=0$, $w(A,B)=0$, $w(A,C)=2$, $w(B,D)=0$, $w(B,E)=1$, $w(C,F)=0$, $w(D,X)=0$, $w(E,X)=0$, $w(F,X)=0$。\n\n这 $3$ 条路径的标识符是：\n1.  路径 $P_1: S \\to A \\to B \\to D \\to X$。路径 ID = $w(S,A) + w(A,B) + w(B,D) + w(D,X) = 0 + 0 + 0 + 0 = 0$。\n2.  路径 $P_2: S \\to A \\to B \\to E \\to X$。路径 ID = $w(S,A) + w(A,B) + w(B,E) + w(E,X) = 0 + 0 + 1 + 0 = 1$。\n3.  路径 $P_3: S \\to A \\to C \\to F \\to X$。路径 ID = $w(S,A) + w(A,C) + w(C,F) + w(F,X) = 0 + 2 + 0 + 0 = 2$。\n路径标识符为 $0, 1, 2$，是唯一的。\n\n### 任务 2：添加边 $e_s = (B,X)$ 后对简单修补方案的分析\n\n添加了一条新边 $e_s=(B,X)$。一个简单的修补方案是保留所有原始权值 $w(e)$ 并设置 $w(e_s) = 0$。这引入了一条新路径 $P_4: S \\to A \\to B \\to X$。我们来用这个简单的权值计算修改后图中的路径标识符。\n-   ID($P_1: S \\to A \\to B \\to D \\to X$) = $w(S,A) + w(A,B) + w(B,D) + w(D,X) = 0 + 0 + 0 + 0 = 0$。\n-   ID($P_2: S \\to A \\to B \\to E \\to X$) = $w(S,A) + w(A,B) + w(B,E) + w(E,X) = 0 + 0 + 1 + 0 = 1$。\n-   ID($P_3: S \\to A \\to C \\to F \\to X$) = $w(S,A) + w(A,C) + w(C,F) + w(F,X) = 0 + 2 + 0 + 0 = 2$。\n-   ID($P_4: S \\to A \\to B \\to X$) = $w(S,A) + w(A,B) + w(B,X) = 0 + 0 + 0 = 0$。\n\n发生了冲突。两条不同的路径具有相同的标识符 $0$：\n-   冲突路径 1：$S \\to A \\to B \\to D \\to X$。\n-   冲突路径 2：$S \\to A \\to B \\to X$。\n\n### 任务 3：为修改后的 CFG 重新计算权值\n\n我们在包含边 $(B,X)$ 的修改后的 CFG 上重新运行 Ball–Larus 算法。\n节点 $B$ 的出边新顺序为 $(B,D), (B,E), (B,X)$。\n\n首先，我们为修改后的图重新计算 $\\text{NumPaths}'(n)$。\n-   $\\text{NumPaths}'(X) = 1$。\n-   $\\text{NumPaths}'(D) = 1$, $\\text{NumPaths}'(E) = 1$, $\\text{NumPaths}'(F) = 1$。\n-   $\\text{NumPaths}'(C) = \\text{NumPaths}'(F) = 1$。\n-   节点 $B$ 现在有后继节点 $D, E, X$。\n    $\\text{NumPaths}'(B) = \\text{NumPaths}'(D) + \\text{NumPaths}'(E) + \\text{NumPaths}'(X) = 1 + 1 + 1 = 3$。\n-   节点 $A$ 有后继节点 $B, C$。\n    $\\text{NumPaths}'(A) = \\text{NumPaths}'(B) + \\text{NumPaths}'(C) = 3 + 1 = 4$。\n-   $\\text{NumPaths}'(S) = \\text{NumPaths}'(A) = 4$。\n现在从 $S$ 到 $X$ 有 $4$ 条唯一路径。\n\n接下来，我们重新计算边权值 $w'(e)$。\n-   节点 $S$：单条边 $(S,A) \\implies w'(S,A)=0$。\n-   节点 $A$：边 $(A,B), (A,C)$。\n    -   $w'(A,B) = 0$。\n    -   $w'(A,C) = \\text{NumPaths}'(B) = 3$。\n-   节点 $B$：边 $(B,D), (B,E), (B,X)$。\n    -   $w'(B,D) = 0$。\n    -   $w'(B,E) = \\text{NumPaths}'(D) = 1$。\n    -   $w'(B,X) = \\text{NumPaths}'(D) + \\text{NumPaths}'(E) = 1 + 1 = 2$。\n-   节点 $C, D, E, F$：各有一条边 $\\implies$ 权值为 $0$。\n    -   $w'(C,F) = 0$, $w'(D,X) = 0$, $w'(E,X) = 0$, $w'(F,X) = 0$。\n\n这 $4$ 条路径的新标识符是：\n1.  路径 $P'_1: S \\to A \\to B \\to D \\to X$。ID = $w'(S,A) + w'(A,B) + w'(B,D) + w'(D,X) = 0+0+0+0 = 0$。\n2.  路径 $P'_2: S \\to A \\to B \\to E \\to X$。ID = $w'(S,A) + w'(A,B) + w'(B,E) + w'(E,X) = 0+0+1+0 = 1$。\n3.  路径 $P'_3: S \\to A \\to B \\to X$。ID = $w'(S,A) + w'(A,B) + w'(B,X) = 0+0+2 = 2$。\n4.  路径 $P'_4: S \\to A \\to C \\to F \\to X$。ID = $w'(S,A) + w'(A,C) + w'(C,F) + w'(F,X) = 0+3+0+0 = 3$。\n路径标识符 $0, 1, 2, 3$ 是唯一的，这证实了重新运行该算法能够恢复其正确性。\n\n### 任务 4：计算重赋权代价 $C$\n\n重赋权代价定义为 $C = \\sum_{e \\in E_{\\text{orig}}} | w'(e) - w(e) |$，其中 $E_{\\text{orig}}$ 是原始 CFG 中的边集。我们对 $9$ 条原始边中的每一条，比较其新权值 $w'(e)$ 和原始权值 $w(e)$。\n\n-   $e = (S,A)$: $|w'(S,A) - w(S,A)| = |0 - 0| = 0$。\n-   $e = (A,B)$: $|w'(A,B) - w(A,B)| = |0 - 0| = 0$。\n-   $e = (A,C)$: $|w'(A,C) - w(A,C)| = |3 - 2| = 1$。这是因为这条边的权值取决于 $\\text{NumPaths}(B)$，该值从 $2$ 变为 $3$。\n-   $e = (B,D)$: $|w'(B,D) - w(B,D)| = |0 - 0| = 0$。\n-   $e = (B,E)$: $|w'(B,E) - w(B,E)| = |1 - 1| = 0$。该权值取决于 $\\text{NumPaths}(D)$，该值没有改变。\n-   $e = (C,F)$: $|w'(C,F) - w(C,F)| = |0 - 0| = 0$。\n-   $e = (D,X)$: $|w'(D,X) - w(D,X)| = |0 - 0| = 0$。\n-   $e = (E,X)$: $|w'(E,X) - w(E,X)| = |0 - 0| = 0$。\n-   $e = (F,X)$: $|w'(F,X) - w(F,X)| = |0 - 0| = 0$。\n\n总重赋权代价 $C$ 是这些绝对差值之和：\n$C = 0 + 0 + 1 + 0 + 0 + 0 + 0 + 0 + 0 = 1$\n\n代价为 $1$，这完全是由于边 $(A,C)$ 的权值变化所致，该边位于节点 $B$ 结构修改的上游。", "answer": "$$\\boxed{1}$$", "id": "3640199"}, {"introduction": "为路径分配唯一ID的意义何在？本练习将揭示路径剖析相较于传统边剖析的根本优势。通过分析一个具体的场景，你将看到路径信息如何揭示出边计数无法捕捉的分支相关性，并学习如何利用这些信息来指导编译器进行安全且高效的代码优化。[@problem_id:3640289]", "problem": "考虑以下某个过程的控制流图（CFG），其中节点是基本块（BB），有向边表示可能的控制转移。入口是 $S$，出口是 $W$。\n\n- $S \\rightarrow B_1$。\n- $B_1$ 根据谓词 $P$ 进行分支：true边指向 $B_2$，false边指向 $B_3$。\n- $B_2$ 和 $B_3$ 是直线代码（例如，调用具有副作用的函数），并且都流入 $B_5$。\n- $B_5$ 根据谓词 $Q$ 进行分支：true边指向 $U$，false边指向 $V$。\n- $U \\rightarrow W$ 和 $V \\rightarrow W$。\n\n假设给定以下信息。\n\n1) 定义（基本基础）：\n- 控制流图（CFG）是一个有向图 $G=(V,E)$，其中顶点 $V$ 是基本块，边 $E$ 是可能的控制流转移；一次执行对应于 $G$ 中的一条路径。\n- 边分析（EP）记录每条边 $e \\in E$ 被遍历的次数。它捕获了单条边的边际频率。\n- 路径分析（PP）记录在 $G$ 的指定区域中，每条无环路径 $\\pi$ 被执行的次数。它捕获了边序列的联合频率，并能揭示仅靠EP无法发现的分支结果之间的相关性。\n- 一个转换是健全的（sound），如果对于所有程序输入，它都保持可观察的语义；在使用分析数据时，可以通过守护式版本化（guarded versioning）来保持健全性：仅在一个运行时守卫确保语义等价的条件下，才沿着预测的热路径执行特化版本，否则回退到原始版本。\n\n2) 在代表性工作负载上测得的分析数据：\n- $B_1$ 处的边分析计数：true边被执行 $600$ 次，false边被执行 $400$ 次。\n- $B_5$ 处的边分析计数：true边被执行 $400$ 次，false边被执行 $600$ 次。\n- 路径分析识别出两条频繁执行的无环路径及其计数：\n  - $p^* = \\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{false}}, V, W \\rangle$ 执行了 $600$ 次。\n  - $p' = \\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{true}}, U, W \\rangle$ 执行了 $400$ 次。\n  - 另外两个互补的组合 $\\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{true}}, U, W \\rangle$ 和 $\\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{false}}, V, W \\rangle$ 被观察到 $0$ 次。\n\n直观上，路径分析揭示了在观察到的执行中，$B_1$ 和 $B_5$ 处的结果之间存在强烈的互斥相关性：沿着热路径 $p^*$，每当上游的 $P$ 为true时，下游 $B_5$ 处的 $Q$ 随后就为false。仅靠边计数无法揭示这种相关性，因为它们只独立地提供了 $B_1$ 和 $B_5$ 的边际频率。\n\n你的目标是利用这些信息，在热路径 $p^*$ 上移除 $B_5$ 处的动态检查，同时为所有输入保持正确性。\n\n以下哪种编译器转换是健全的，并且利用了路径分析信息来移除 $p^*$ 路径上 $B_5$ 处的冗余检查？\n\nA. 仅使用边分析来推断 $B_1^{\\text{true}}$ 意味着 $B_5^{\\text{false}}$，并在任何时候当直接前驱是 $B_2$ 时，将 $B_5$ 处的分支替换为到 $V$ 的无条件跳转。\n\nB. 将构成 $p^*$ 的区域克隆成一个从 $B_1^{\\text{true}}$ 进入的特化跟踪版本 $T^*$。在 $T^*$ 的开头插入一个运行时守卫，它评估 $Q$ 并检查 $Q=\\text{false}$；如果守卫通过，则绕过 $B_5$ 直接跳转到 $V$（在 $T^*$ 中删除对 $Q$ 的测试），否则分支到原始代码。保留原始CFG作为回退。\n\nC. 根据路径分析，推断出不变量 $Q \\equiv \\lnot P$，并通过相应地对后继者进行常量折叠来全局性地消除 $B_1$ 和 $B_5$ 处的分支。\n\nD. 重排基本块，将 $B_2 \\rightarrow B_5 \\rightarrow V$ 连续地放置在内存中（布局优化），但保持所有分支不变。\n\n选择正确的选项。", "solution": "用户希望我验证并解决一个关于编译器优化的问题，特别是对比边分析和路径分析如何实现一个健全的转换。\n\n### 第一步：提取已知条件\n\n- **控制流图（CFG）结构：**\n  - 一个有向图，入口为 $S$，出口为 $W$。\n  - $S \\rightarrow B_1$。\n  - $B_1$ 是一个基于谓词 $P$ 的条件分支。true边为 $B_1 \\rightarrow B_2$，false边为 $B_1 \\rightarrow B_3$。\n  - $B_2 \\rightarrow B_5$ 且 $B_3 \\rightarrow B_5$。\n  - $B_5$ 是一个基于谓词 $Q$ 的条件分支。true边为 $B_5 \\rightarrow U$，false边为 $B_5 \\rightarrow V$。\n  - $U \\rightarrow W$ 且 $V \\rightarrow W$。\n\n- **定义：**\n  - **边分析（EP）：** 记录每条边 $e$ 的遍历次数。\n  - **路径分析（PP）：** 记录每条无环路径 $\\pi$ 的执行次数。它可以揭示EP无法发现的相关性。\n  - **健全的转换：** 一种对所有程序输入都保持可观察语义的转换。对于分析数据，健全性可以通过“守护式版本化”来实现，即使用运行时守卫来检查条件，然后才执行特化的优化代码版本，并提供到原始未优化代码的回退路径。\n\n- **分析数据：**\n  - 在 $B_1$ 处的EP：$B_1 \\xrightarrow{\\text{true}} B_2$ 执行了 $600$ 次。$B_1 \\xrightarrow{\\text{false}} B_3$ 执行了 $400$ 次。\n  - 在 $B_5$ 处的EP：$B_5 \\xrightarrow{\\text{true}} U$ 执行了 $400$ 次。$B_5 \\xrightarrow{\\text{false}} V$ 执行了 $600$ 次。\n  - PP 数据：\n    - 路径 $p^* = \\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{false}}, V, W \\rangle$ 执行了 $600$ 次。\n    - 路径 $p' = \\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{true}}, U, W \\rangle$ 执行了 $400$ 次。\n    - 路径 $\\langle S, B_1^{\\text{true}}, B_2, B_5^{\\text{true}}, U, W \\rangle$ 执行了 $0$ 次。\n    - 路径 $\\langle S, B_1^{\\text{false}}, B_3, B_5^{\\text{false}}, V, W \\rangle$ 执行了 $0$ 次。\n\n- **目标：**\n  - 利用路径分析数据，在热路径 $p^*$ 上移除 $B_5$ 处的谓词 $Q$ 的动态检查，同时确保转换是健全的。\n\n### 第二步：使用提取的已知条件进行验证\n\n- **科学基础：** 该问题牢固地基于编译器设计的既定原则，特别是基于分析的优化、控制流分析和代码转换技术（如跟踪特化）。边分析、路径分析和健全性的概念是该领域的核心。该问题在科学上是合理的。\n- **良构性：** CFG的定义明确。分析数据明确且内部一致。例如，通过 $B_1$ 的总流量是 $600+400=1000$。通过 $B_5$ 的总流量也是 $600+400=1000$。路径计数之和等于总执行次数（$600+400+0+0=1000$），并且与边计数一致（例如，边 $B_1 \\rightarrow B_2$ 的计数为 $600$，与以 $B_1^{\\text{true}}$ 开头的路径总和 $600+0=600$ 相符）。目标清晰具体。\n- **客观性：** 该问题使用计算机科学领域的精确技术术语陈述。没有主观或模糊的陈述。\n- **缺陷检查清单：**\n  1. **科学/事实不健全：** 无。\n  2. **不可形式化/不相关：** 无。该问题是一个经典的、可形式化的编译器优化问题。\n  3. **不完整/矛盾的设置：** 无。数据完整且一致。\n  4. **不现实/不可行：** 无。相关的分支在程序中很常见，所描述的优化技术是现实的。\n  5. **不良构/结构差：** 无。问题结构良好。\n  6. **伪深刻/琐碎：** 无。该问题需要理解边分析和路径分析之间的关键区别以及优化中健全性的概念。\n  7. **超出科学可验证性：** 无。\n\n### 第三步：判断与行动\n\n问题陈述是 **有效的**。这是一个在编译器原理领域中形式良好、一致且有科学依据的问题。我现在将进行求解推导和选项分析。\n\n### 求解推导\n\n问题的核心在于边分析与路径分析所能推断出的信息之间的区别，以及如何利用这些信息来执行一个*健全的*优化。\n\n1.  **从分析中获得的信息：**\n    - 边分析显示，$B_1$ 处的分支以概率 $(\\text{true}: 0.6, \\text{false}: 0.4)$ 被选择，$B_5$ 处的分支以概率 $(\\text{true}: 0.4, \\text{false}: 0.6)$ 被选择。如果分支是独立的，我们预期路径 $B_1^{\\text{true}} \\to \\dots \\to B_5^{\\text{false}}$ 被执行的次数是 $1000 \\times 0.6 \\times 0.6 = 360$ 次。\n    - 路径分析揭示了强相关性。路径 $p^* = \\langle S, B_1^{\\text{true}}, \\dots, B_5^{\\text{false}}, \\dots \\rangle$ 被执行了 $600$ 次，而路径 $\\langle S, B_1^{\\text{true}}, \\dots, B_5^{\\text{true}}, \\dots \\rangle$ 被执行了 $0$ 次。这表明对于观察到的工作负载，每当 $P$ 为true时，$Q$ 就为false。\n\n2.  **健全性约束：** 一个关键约束是任何转换都必须是*健全的*，意味着它必须对*所有可能的输入*都正确，而不仅仅是分析运行中的那些。一个分析结果，无论多么强，都只是一个统计观察，而不是程序不变量的形式证明。我们不能断定 $Q \\equiv \\lnot P$ 对所有执行都为真。可能存在在分析期间未遇到的执行路径，其中 $P$ 为true且 $Q$ 也为true。健全的优化必须正确处理这种情况。\n\n3.  **目标：** 目标是消除在热路径 $p^*$ 上 $B_5$ 处的 $Q$ 检查。这条路径是在 $P$ 评估为true后采取的。\n\n4.  **机制（守护式版本化）：** 问题陈述本身定义了正确的机制：“守护式版本化”。这涉及为预测的（热）路径创建一个特化的、更快的代码版本，并使用一个运行时检查（一个守卫）来确保进入这个特化路径的条件得到满足。如果守卫失败，控制权将转移到原始的、未优化的代码（一个回退）。\n\n    将此应用于我们的问题：\n    - 当 $P$ 为true时，进入热路径。\n    - 在这条路径上，我们预测 $Q$ 将为false。\n    - 因此，我们可以创建一个特化的代码序列，它执行 $B_2$ 的主体，然后无条件跳转到 $V$，完全绕过在 $B_5$ 处的 $Q$ 测试。\n    - 为了保持健全性，我们必须引入一个守卫。在承诺走这条特化路径之前，我们必须验证我们的预测是否成立。守卫必须检查 $Q$ 是否确实为false。\n    - $B_1$ 之后的新控制流将如下所示：如果 $P$ 为true，则跳转到一个新的块，即守卫。\n    - 守卫块检查 $Q$ 是否为false。\n        - 如果为`true`（即 $Q$ 为false），则执行特化路径（$B_2$ 的代码，然后跳转到 $V$）。\n        - 如果为`false`（即 $Q$ 为true），这是未预测到的情况。我们通过跳转到 $B_2$ 来回退到原始代码路径，然后它将继续到 $B_5$，正确地将 $Q$ 评估为true，并跳转到 $U$。\n\n这种结构实现了目标：在频繁执行的路径上（$P$ 为true且 $Q$ 为false），$B_5$ 处的检查被消除了。对于罕见的（或未观察到的）情况（$P$ 为true且 $Q$ 也为true），正确性得以保持。\n\n### 逐项分析选项\n\n**A. 仅使用边分析来推断 $B_1^{\\text{true}}$ 意味着 $B_5^{\\text{false}}$，并在任何时候当直接前驱是 $B_2$ 时，将 $B_5$ 处的分支替换为到 $V$ 的无条件跳转。**\n\n- 前提“仅使用边分析”是错误的。如前所述，仅靠边分析不足以检测 $B_1$ 和 $B_5$ 处分支之间的相关性。此信息来自路径分析。\n- “将 $B_5$ 处的分支替换为无条件跳转”这一转换是**不健全的**。它基于从统计样本（“分析数据”）得出的推断，但却将其当作已证明的不变量来应用。如果存在任何输入，使得控制流通过 $B_2$ 到达 $B_5$ 并且谓词 $Q$ 评估为true，那么这个转换将导致程序错误地跳转到 $V$ 而不是 $U$。\n- **结论：** 错误。\n\n**B. 将构成 $p^*$ 的区域克隆成一个从 $B_1^{\\text{true}}$ 进入的特化跟踪版本 $T^*$。在 $T^*$ 的开头插入一个运行时守卫，它评估 $Q$ 并检查 $Q=\\text{false}$；如果守卫通过，则绕过 $B_5$ 直接跳转到 $V$（在 $T^*$ 中删除对 $Q$ 的测试），否则分支到原始代码。保留原始CFG作为回退。**\n\n- 该选项正确地（隐式地）指出了路径分析是信息来源，因为它提到了路径 $p^*$。\n- 它描述了标准的“守护式版本化”技术。\n  - “将区域克隆...成一个特化跟踪版本 $T^*$”：这是创建优化路径。\n  - “插入...一个运行时守卫，它评估 $Q$ 并检查 $Q=\\text{false}$”：这是确保优化条件在运行时成立的关键检查。\n  - “如果守卫通过，则绕过 $B_5$ 直接跳转到 $V$（在 $T^*$ 中删除对 $Q$ 的测试）”：这是移除了冗余检查的优化执行路径。\n  - “否则分支到原始代码”：这是保证对未预测情况健全性的回退机制。\n- 这种转换是**健全的**，并且直接实现了在热路径上移除 $B_5$ 处检查的目标。虽然在实践中将 $Q$ 的评估提升到 $B_2$ 之前可能存在复杂性，但所描述的逻辑结构是解决此类基于分析的优化的正确和标准方法。\n- **结论：** 正确。\n\n**C. 根据路径分析，推断出不变量 $Q \\equiv \\lnot P$，并通过相应地对后继者进行常量折叠来全局性地消除 $B_1$ 和 $B_5$ 处的分支。**\n\n- 在编译器正确性的背景下，关键短语“推断出不变量 $Q \\equiv \\lnot P$”是一个逻辑谬误。分析数据表明了相关性；它并未证明一个普遍为真的不变量。做出这个假设是不健全性的主要来源。\n- 提议的转换“全局性地消除两个分支”将改变任何违反该假设不变量的输入的程序行为。例如，如果存在一个输入使得 $P$ 和 $Q$ 都为true，原始程序将遵循到 $U$ 的路径。转换后的程序，由于假设了 $P \\implies \\lnot Q$，将错误地强制走向到 $V$ 的路径。这是一个**不健全的**转换。\n- **结论：** 错误。\n\n**D. 重排基本块，将 $B_2 \\rightarrow B_5 \\rightarrow V$ 连续地放置在内存中（布局优化），但保持所有分支不变。**\n\n- 这描述了一种代码布局优化。这种优化利用分析来识别热路径（$B_2 \\rightarrow B_5 \\rightarrow V$ 是热路径 $p^*$ 的一部分），并将它们按顺序排列在内存中，以改善指令缓存局部性，并可能减少分支惩罚。\n- 然而，该选项明确说明“保持所有分支不变”。\n- 问题的目标是“**移除 $B_5$ 处的动态检查**”。这种转换不移除任何检查或分支。虽然它是一种利用分析信息的有效优化，但它没有解决问题的具体目标。\n- **结论：** 错误。", "answer": "$$\\boxed{B}$$", "id": "3640289"}, {"introduction": "在实际应用中，性能开销是剖析系统必须面对的关键挑战。本练习将引导你从成本效益的角度思考插桩策略，即如何用最小的开销来区分一组关键路径。你将学习如何将此问题形式化为一个整数线性规划（ILP）模型，这是一种在资源受限的情况下寻找最优解的强大数学工具。[@problem_id:3640258]", "problem": "考虑一个控制流图 $G=(V,E)$，其入口节点为 $s$，出口节点为 $t$。给定一组无环的、从入口到出口的路径 $\\mathcal{P}$。每条边 $e \\in E$ 都有一个非负的插桩开销成本 $w_{e}$，你可以在边 $e$ 上放置一个硬件计数器（由二元决策变量 $y_{e} \\in \\{0,1\\}$ 建模），每当 $e$ 被遍历时，该计数器加 $1$。对于任何路径 $p \\in \\mathcal{P}$，其计数器签名是沿插桩边的计数器值向量，通过按固定的边顺序连接每条边的计数获得。假设 $\\mathcal{P}$ 中的每条路径最多遍历任何边一次。\n\n从控制流图和路径剖析的基本定义出发，形式化一个整数线性规划（ILP）模型。该模型选择一个边的子集进行插桩，以使 $\\mathcal{P}$ 中所有不同路径的计数器签名都是唯一的，同时最小化总开销 $\\sum_{e \\in E} w_{e} y_{e}$。然后，针对下面的具体实例，求解该ILP模型，并以单个实数的形式报告最小总开销。\n\n实例说明：\n- 边与成本：$E=\\{e_{1},e_{2},e_{3},e_{4},e_{5}\\}$，其中 $w_{e_{1}}=2$，$w_{e_{2}}=4$，$w_{e_{3}}=3$，$w_{e_{4}}=1$，$w_{e_{5}}=5$。\n- 路径：$\\mathcal{P}=\\{p_{1},p_{2},p_{3},p_{4}\\}$，其中 $p_{1}=(e_{1},e_{2},e_{5})$，$p_{2}=(e_{1},e_{3},e_{5})$，$p_{3}=(e_{4},e_{2},e_{5})$，以及 $p_{4}=(e_{4},e_{3},e_{5})$。\n\n你的答案必须是最佳插桩的最小总开销值，表示为单个实数。不要包含单位。如果你选择近似计算，请说明为何需要近似，并四舍五入到指定数量的有效数字。否则，请提供精确值。", "solution": "### ILP 公式化\n首先，我们形式化通用的整数线性规划（ILP）模型。\n设 $y_e \\in \\{0, 1\\}$ 为每条边 $e \\in E$ 的二元决策变量，其中如果边 $e$ 用计数器进行插桩，则 $y_e=1$，否则 $y_e=0$。总插桩开销是被插桩边的成本之和。目标函数是最小化此总成本：\n$$\n\\text{最小化} \\quad Z = \\sum_{e \\in E} w_e y_e\n$$\n主要约束是任意两条不同路径的计数器签名必须是唯一的。设 $p_i$ 和 $p_j$ 是 $\\mathcal{P}$ 中两条不同的路径（$i \\neq j$）。路径的计数器签名是来自插桩边的计数器读数向量。鉴于路径是简单的（最多遍历一条边一次）这一假设，如果 $e \\in p_i$，则被插桩边 $e$ 上的计数器将读为 $1$，如果 $e \\notin p_i$，则读为 $0$。\n\n为了使 $p_i$ 和 $p_j$ 的签名不同，必须至少有一条被插桩的边 $e$（即 $y_e = 1$）在一条路径中而不在另一条路径中。能够区分 $p_i$ 和 $p_j$ 的边集是它们的对称差，记为 $p_i \\Delta p_j = (p_i \\cup p_j) \\setminus (p_i \\cap p_j)$。\n为确保对 $(p_i, p_j)$ 这对路径的可区分性，我们必须对它们对称差中的至少一条边进行插桩。这可以表示为线性不等式：\n$$\n\\sum_{e \\in p_i \\Delta p_j} y_e \\ge 1\n$$\n此约束必须对 $\\mathcal{P}$ 中每一对不同的路径都成立。\n\n完整的ILP模型如下：\n- **决策变量**：对于所有 $e \\in E$，$y_e \\in \\{0, 1\\}$。\n- **目标函数**：最小化 $Z = \\sum_{e \\in E} w_e y_e$。\n- **约束条件**：对于每一对不同的路径 $(p_i, p_j) \\in \\mathcal{P} \\times \\mathcal{P}$ 且 $i \\neq j$，\n$$\n\\sum_{e \\in p_i \\Delta p_j} y_e \\ge 1\n$$\n\n### 求解具体实例\n现在我们将此模型应用于给定的实例。\n边集为 $E=\\{e_{1},e_{2},e_{3},e_{4},e_{5}\\}$，成本为 $w_{e_{1}}=2$, $w_{e_{2}}=4$, $w_{e_{3}}=3$, $w_{e_{4}}=1$, $w_{e_{5}}=5$。\n路径集为 $\\mathcal{P}=\\{p_{1},p_{2},p_{3},p_{4}\\}$：\n- $p_{1} = \\{e_{1},e_{2},e_{5}\\}$\n- $p_{2} = \\{e_{1},e_{3},e_{5}\\}$\n- $p_{3} = \\{e_{4},e_{2},e_{5}\\}$\n- $p_{4} = \\{e_{4},e_{3},e_{5}\\}$\n\n需要最小化的目标函数是：\n$$\nZ = 2y_{e_{1}} + 4y_{e_{2}} + 3y_{e_{3}} + y_{e_{4}} + 5y_{e_{5}}\n$$\n我们必须为 $\\mathcal{P}$ 中每一对唯一的路径生成一个约束。共有 $\\binom{4}{2}=6$ 对这样的路径。\n\n1.  **路径对 $(p_1, p_2)$**：\n    $p_1 \\Delta p_2 = (\\{e_1,e_2,e_5\\} \\cup \\{e_1,e_3,e_5\\}) \\setminus (\\{e_1,e_2,e_5\\} \\cap \\{e_1,e_3,e_5\\}) = \\{e_1,e_2,e_3,e_5\\} \\setminus \\{e_1,e_5\\} = \\{e_2,e_3\\}$。\n    约束 (C1)：$y_{e_2} + y_{e_3} \\ge 1$。\n\n2.  **路径对 $(p_1, p_3)$**：\n    $p_1 \\Delta p_3 = (\\{e_1,e_2,e_5\\} \\cup \\{e_4,e_2,e_5\\}) \\setminus (\\{e_1,e_2,e_5\\} \\cap \\{e_4,e_2,e_5\\}) = \\{e_1,e_2,e_4,e_5\\} \\setminus \\{e_2,e_5\\} = \\{e_1,e_4\\}$。\n    约束 (C2)：$y_{e_1} + y_{e_4} \\ge 1$。\n\n3.  **路径对 $(p_1, p_4)$**：\n    $p_1 \\Delta p_4 = (\\{e_1,e_2,e_5\\} \\cup \\{e_4,e_3,e_5\\}) \\setminus (\\{e_1,e_2,e_5\\} \\cap \\{e_4,e_3,e_5\\}) = \\{e_1,e_2,e_3,e_4,e_5\\} \\setminus \\{e_5\\} = \\{e_1,e_2,e_3,e_4\\}$。\n    约束 (C3)：$y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$。\n\n4.  **路径对 $(p_2, p_3)$**：\n    $p_2 \\Delta p_3 = (\\{e_1,e_3,e_5\\} \\cup \\{e_4,e_2,e_5\\}) \\setminus (\\{e_1,e_3,e_5\\} \\cap \\{e_4,e_2,e_5\\}) = \\{e_1,e_2,e_3,e_4,e_5\\} \\setminus \\{e_5\\} = \\{e_1,e_2,e_3,e_4\\}$。\n    约束 (C4)：$y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$。（与C3相同）。\n\n5.  **路径对 $(p_2, p_4)$**：\n    $p_2 \\Delta p_4 = (\\{e_1,e_3,e_5\\} \\cup \\{e_4,e_3,e_5\\}) \\setminus (\\{e_1,e_3,e_5\\} \\cap \\{e_4,e_3,e_5\\}) = \\{e_1,e_3,e_4,e_5\\} \\setminus \\{e_3,e_5\\} = \\{e_1,e_4\\}$。\n    约束 (C5)：$y_{e_1} + y_{e_4} \\ge 1$。（与C2相同）。\n\n6.  **路径对 $(p_3, p_4)$**：\n    $p_3 \\Delta p_4 = (\\{e_4,e_2,e_5\\} \\cup \\{e_4,e_3,e_5\\}) \\setminus (\\{e_4,e_2,e_5\\} \\cap \\{e_4,e_3,e_5\\}) = \\{e_2,e_3,e_4,e_5\\} \\setminus \\{e_4,e_5\\} = \\{e_2,e_3\\}$。\n    约束 (C6)：$y_{e_2} + y_{e_3} \\ge 1$。（与C1相同）。\n\n唯一的约束集是：\n- (C1): $y_{e_2} + y_{e_3} \\ge 1$\n- (C2): $y_{e_1} + y_{e_4} \\ge 1$\n- (C3): $y_{e_1} + y_{e_2} + y_{e_3} + y_{e_4} \\ge 1$\n\n我们观察到，如果(C1)和(C2)被满足，那么它们各自至少有一个项为 $1$。例如，设对于 $e_i \\in \\{e_2, e_3\\}$ 有 $y_{e_i} \\ge 1$，且对于 $e_j \\in \\{e_1, e_4\\}$ 有 $y_{e_j} \\ge 1$。那么(C3)中的和必然至少为 $1+1=2$（因为变量是非负的），这大于 $1$。因此，约束(C3)是多余的，可以移除。问题简化为：\n$$\n\\text{最小化} \\quad Z = 2y_{e_{1}} + 4y_{e_{2}} + 3y_{e_{3}} + y_{e_{4}} + 5y_{e_{5}}\n$$\n约束条件：\n$$\ny_{e_2} + y_{e_3} \\ge 1 \\\\\ny_{e_1} + y_{e_4} \\ge 1 \\\\\ny_e \\in \\{0,1\\} \\text{ for } e \\in E\n$$\n目标函数是正数项的和。为了最小化 $Z$，我们应将尽可能多的 $y_e$ 变量设为 $0$。\n变量 $y_{e_5}$ 未出现在任何约束中。由于其成本 $w_{e_{5}}=5$ 是正数，我们必须在任何最优解中将 $y_{e_5}$ 设为 $0$。\n\n剩下的问题可以分解为两个独立的子问题，因为约束作用于不相交的变量集：\n子问题1：最小化 $4y_{e_{2}} + 3y_{e_{3}}$，约束条件为 $y_{e_2} + y_{e_3} \\ge 1$。\n- 选项(a)：$y_{e_2}=1, y_{e_3}=0$。成本贡献：$4(1) + 3(0) = 4$。\n- 选项(b)：$y_{e_2}=0, y_{e_3}=1$。成本贡献：$4(0) + 3(1) = 3$。\n- 选项(c)：$y_{e_2}=1, y_{e_3}=1$。成本贡献：$4(1) + 3(1) = 7$。\n该子问题的最小成本是 $3$，通过设置 $y_{e_2}=0$ 和 $y_{e_3}=1$ 实现。\n\n子问题2：最小化 $2y_{e_{1}} + y_{e_{4}}$，约束条件为 $y_{e_1} + y_{e_4} \\ge 1$。\n- 选项(a)：$y_{e_1}=1, y_{e_4}=0$。成本贡献：$2(1) + 1(0) = 2$。\n- 选项(b)：$y_{e_1}=0, y_{e_4}=1$。成本贡献：$2(0) + 1(1) = 1$。\n- 选项(c)：$y_{e_1}=1, y_{e_4}=1$。成本贡献：$2(1) + 1(1) = 3$。\n该子问题的最小成本是 $1$，通过设置 $y_{e_1}=0$ 和 $y_{e_4}=1$ 实现。\n\n结合子问题的最优解并包含 $y_{e_5}=0$，总体的最优解是：\n$y_{e_1}=0$, $y_{e_2}=0$, $y_{e_3}=1$, $y_{e_4}=1$, $y_{e_5}=0$。\n这意味着我们应该对边 $e_3$ 和 $e_4$ 进行插桩。\n\n最小总开销是各子问题最优解的成本之和：\n$$\nZ_{min} = (4y_{e_{2}} + 3y_{e_{3}}) + (2y_{e_{1}} + y_{e_{4}}) + (5y_{e_{5}})\n$$\n$$\nZ_{min} = (3) + (1) + (0) = 4\n$$\n最小总开销是 $4$。这对应于对边 $e_3$（成本 $3$）和 $e_4$（成本 $1$）进行插桩。\n对边 $e_3$ 和 $e_4$ 进行插桩后，得到的签名如下：\n- $p_1$：不包含 $e_3$ 或 $e_4$。签名：$(0,0)$。\n- $p_2$：包含 $e_3$ 但不含 $e_4$。签名：$(1,0)$。\n- $p_3$：包含 $e_4$ 但不含 $e_3$。签名：$(0,1)$。\n- $p_4$：包含 $e_3$ 和 $e_4$。签名：$(1,1)$。\n所有四个签名都是唯一的，这证实了解决方案的正确性。", "answer": "$$\\boxed{4}$$", "id": "3640258"}]}