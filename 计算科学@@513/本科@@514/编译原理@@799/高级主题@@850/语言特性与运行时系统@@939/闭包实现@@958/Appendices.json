{"hands_on_practices": [{"introduction": "当一个函数返回一个闭包，而该闭包又引用了该函数作用域内的局部变量时，我们面临一个根本性的挑战：栈上的变量会随着函数的返回而被销毁。这个练习探讨了如何解决所谓的“向上 funarg 问题” ([@problem_id:3680362])，即通过将捕获的变量从栈迁移到堆来保证闭包的正确执行。通过分析不同的实现策略，你将学会识别出正确且高效的编译器转换方法。", "problem": "考虑一台带有特定帧指针（FP）和栈指针（SP）的机器上的传统调用栈。一个活动记录按地址从高到低的顺序包含：一个保存的返回地址（RA）、一个保存的旧帧指针（old FP）、被调用者保存的寄存器、编译器生成的溢出槽和临时变量、用于局部变量和被视为局部变量的参数的空间，以及一个用于被调用者进行调用时的出参区域。根据标准定义，一个栈分配对象的生命周期在其活动记录被弹出时结束，而一个生命周期超过其创建调用的闭包必须在其创建活动记录的生命周期之外保留其词法环境的存储。\n\n一个函数 $f$ 有局部变量 $x$ 和 $y$，并返回一个闭包 $k$，该闭包在 $f$ 返回后引用 $x$ 和 $y$。你必须转换 $f$，以便 $k$ 在稍后被调用时是有效的。假设采用词法作用域、值传递参数，并且 $f$ 不会将其局部变量的引用传递给其他线程。该实现支持一个闭包对象，它由一个代码指针和一个指向堆分配块的环境指针（EP）组成。\n\n以下哪种编译器策略能正确地确定必须从 $f$ 的活动记录中移动到堆上的内容，以及如何调整生命周期和指针以在最小开销下保持语义？\n\nA. 将 $f$ 的整个活动记录（包括保存的RA、保存的旧FP、被调用者保存的寄存器、溢出槽、局部变量和出参区域）移动到堆中。之后对 $k$ 的调用直接重用这个驻留在堆中的帧，不需要重写访问代码。\n\nB. 分配一个堆环境，其中只包含 $f$ 的被捕获局部变量（这里是 $x$ 和 $y$，以及闭包实际引用的任何其他局部变量）。重写闭包代码中的所有访问，使其通过环境指针（EP）进行加载和存储，而不是通过相对于 $FP$ 的地址。不要移动保存的RA、保存的旧$FP$、被调用者保存的寄存器、未被捕获的溢出槽或出参区域。如果在 $f$ 内部获取了被捕获局部变量的地址，则重写该地址，使其指向堆环境内相应的单元，以保证别名仍然有效。\n\nC. 在返回时不弹出 $f$ 的原始栈帧，使其保持活动状态；将原始的 $FP$ 作为闭包的环境指针传递。这可以保持所有相对于 $FP$ 的地址的有效性，并避免任何代码重写。\n\nD. 将被捕获的局部变量和被调用者保存的寄存器区域移动到堆中，以便保留创建闭包时的寄存器状态。同时也将保存的RA保留在堆中，以便在需要时进行栈回溯。重写所有静态链接，使其指向旧的 $FP$。\n\nE. 只将被捕获局部变量的值复制到堆环境中，但将之前获取的这些局部变量的地址保留，使其仍然指向它们原始的栈槽。在每次调用 $k$ 时，通过在堆环境和原始栈槽之间复制值来同步，以保持别名的引用传递语义。\n\n选择唯一的最佳策略。", "solution": "问题描述了编译器设计和运行时系统中的一个经典场景，称为“向上函数参数问题”（upward funarg problem）。一个函数 $f$ 创建了一个闭包 $k$，它捕获了 $f$ 的局部变量，或者说与这些变量形成了词法绑定。这个闭包 $k$ 随后从 $f$ 返回，意味着它的生命周期可能会超过 $f$ 的活动记录的生命周期。由于被捕获的变量 $x$ 和 $y$ 通常在 $f$ 的活动记录内在栈上分配，它们将在 $f$ 返回时被释放。之后任何对 $k$ 的调用都将访问无效内存，导致未定义行为。任务是确定正确的编译器策略来解决这个问题，同时保持程序语义并维持效率（“最小开销”）。\n\n一个有效的策略必须确保任何被捕获变量（一个“逃逸”变量）的存储在闭包本身可以被调用的整个期间都持续存在。实现这一点的标准且最有效的方法是将这些变量分配在堆上而不是栈上。问题指出，该实现提供了一个闭包对象，由一个代码指针和一个指向堆分配块的环境指针（$EP$）组成，这是用于此目的的标准机制。\n\n一个正确解决方案的核心原则是：\n$1$. **识别**：编译器必须识别哪些变量的生命周期需要被延长。这些是 $f$ 的局部变量中被闭包 $k$ 引用（“捕获”）的变量。在本例中，我们被告知是 $x$ 和 $y$。这个过程被称为逃逸分析。\n$2$. **存储迁移**：这些被识别出的变量的存储必须从栈移动到一个生命周期将超过该栈帧的位置，也就是堆。\n$3$. **访问重写**：访问这些已迁移变量的代码，无论是在原始函数 $f$ 内部还是在闭包 $k$ 内部，都必须被重写。原始访问是相对于帧指针（$FP$）的。新的访问必须相对于指向堆分配环境的指针，也就是存储在闭包对象中的环境指针（$EP$）。\n$4. **语义保持**：转换必须在语义上是透明的。如果被捕获变量的地址被获取，这一点尤其重要。所有指向该变量的指针都必须引用一个单一的、规范的内存位置。如果变量被移动到堆上，任何获取其地址的操作都必须产生其堆上位置的地址，而不是其原始（且现已不存在）的栈上位置的地址。\n$5$. **效率**：该策略应具有最小的开销。这意味着只移动必要的数据，并避免复杂、低效的运行时机制。\n\n基于这些原则，我们来评估给出的选项。\n\n**A. 将 $f$ 的整个活动记录（包括保存的RA、保存的旧FP、被调用者保存的寄存器、溢出槽、局部变量和出参区域）移动到堆中。之后对 $k$ 的调用直接重用这个驻留在堆中的帧，不需要重写访问代码。**\n\n这个策略效率极低。活动记录包含许多与闭包 $k$ 无关的数据。保存的返回地址（$RA$）和保存的旧帧指针（old $FP$）是调用 $f$ 的动态链接链的一部分，对 $k$ 没有意义。被调用者保存的寄存器由 $f$ 为其调用者保存，并在 $f$ 返回时恢复。出参区域是为 $f$ 进行的调用准备的，而不是为 $k$ 进行的调用。将所有这些数据移动到堆上会产生巨大的、不必要的复制开销和内存使用。它违反了“最小开销”的要求。虽然它可能通过避免一些代码重写来简化访问，但这是一个重量级且概念上不纯粹的解决方案。\n**结论：不正确。**\n\n**B. 分配一个堆环境，其中只包含 $f$ 的被捕获局部变量（这里是 $x$ 和 $y$，以及闭包实际引用的任何其他局部变量）。重写闭包代码中的所有访问，使其通过环境指针（EP）进行加载和存储，而不是通过相对于 $FP$ 的地址。不要移动保存的RA、保存的旧$FP$、被调用者保存的寄存器、未被捕获的溢出槽或出参区域。如果在 $f$ 内部获取了被捕获局部变量的地址，则重写该地址，使其指向堆环境内相应的单元，以保证别名仍然有效。**\n\n这个策略与上述原则完美契合。\n- 它是高效的（“最小开销”），因为它只为实际逃逸的变量（$x$ 和 $y$）在堆上分配空间。\n- 它正确地指出了需要重写访问，使其相对于环境指针（$EP$）。\n- 至关重要的是，它正确地解决了别名问题。通过确保任何生成被捕获变量地址的操作（例如 ``）现在都产生堆分配实例的地址，它为该变量维护了一个单一的规范位置，从而即使在存在指针的情况下也能保持程序的语义。这是像 ML、Lisp 和 Scala 这样的语言的现代编译器中使用的标准、正确且高效的技术。\n**结论：正确。**\n\n**C. 在返回时不弹出 $f$ 的原始栈帧，使其保持活动状态；将原始的 $FP$ 作为闭包的环境指针传递。这可以保持所有相对于 $FP$ 的地址的有效性，并避免任何代码重写。**\n\n这个策略被称为“意大利面条式栈”（spaghetti stack），因为它打破了传统调用栈严格的后进先出（LIFO）原则。如果 $f$ 的栈帧不被弹出，它会在栈中造成一个“洞”，而正常的栈管理机制（$SP$ 操作）无法处理。这极大地复杂化了内存管理，基本上需要一个用于栈的垃圾回收器。问题指定了一个“传统调用栈”，而此方法违反了这一规定。由于其复杂性和低效率，它不切实际，并未在主流架构或编译器中使用。\n**结论：不正确。**\n\n**D. 将被捕获的局部变量和被调用者保存的寄存器区域移动到堆中，以便保留创建闭包时的寄存器状态。同时也将保存的RA保留在堆中，以便在需要时进行栈回溯。**\n\n这是移动不必要信息的另一个例子。被调用者保存的寄存器在 $f$ 返回前会被恢复，因此在 $f$ 执行完毕后，它们被保存的状态是短暂且无关紧要的。闭包 $k$ 在被调用时将有自己的执行上下文，并将根据调用约定管理寄存器。同样，$f$ 的保存的 $RA$ 是用于从 $f$ 返回到其调用者的；它与 $k$ 的执行无关。将这些组件移动到堆上违反了最小开销原则，并且没有任何正确的语义目的。\n**结论：不正确。**\n\n**E. 只将被捕获局部变量的值复制到堆环境中，但将之前获取的这些局部变量的地址保留，使其仍然指向它们原始的栈槽。在每次调用 $k$ 时，通过在堆环境和原始栈槽之间复制值来同步，以保持别名的引用传递语义。**\n\n这个策略存在根本性缺陷，因为它破坏了指针语义。如果一个指向局部变量 $x$ 的指针被创建，例如 `p = `，这个指针 `p` 将引用栈上的一个位置。在 $f$ 返回后，这个栈位置被释放，`p` 变成了一个悬空指针。提议的“同步”并不能解决这个问题；它只是试图修补一个已经损坏的模型。它创建了数据的两个独立副本（一个在栈上，一个在堆上），这违反了一个变量应有单一规范存储位置的原则。任何通过悬空指针 `p` 的更新都将作用于无效内存，而对堆副本的更新也不会反映在 `p` 所指向的内容上。这个策略未能保持程序语义。\n**结论：不正确。**\n\n因此，策略B是唯一一个通过仅将必要数据迁移到堆上并重写访问以保持语义正确性（包括别名）来正确且高效地解决问题的方法。", "answer": "$$\\boxed{B}$$", "id": "3680362"}, {"introduction": "既然我们知道需要为闭包在堆上分配一个环境来存储捕获的变量，一个自然而然的优化目标就是使这个环境尽可能小。这个练习将指导你运用编译器中的一项关键技术——活性变量分析（live-variable analysis）([@problem_id:3627881])，来精确确定在闭包创建点哪些变量是“活”的，并且确实被闭包使用。通过这种方式，你可以构建出最小化的闭包环境，从而提升内存效率。", "problem": "考虑一个编译器中的程序中间表示，该编译器以引用捕获语义实现词法闭包。词法闭包在特定的程序点创建，并可能在后续的控制流中被调用。闭包环境存储了闭包所引用的自由变量的绑定。为了消除无效捕获（dead captures），我们希望只包含那些活跃范围与闭包创建点相交的变量。在一个控制流图（CFG）上使用标准的反向活跃变量数据流分析（DFA），其基本定义如下：\n- 一个变量 $v$ 在程序点 $p$ 是活跃的，当且仅当存在一条从 $p$ 到 $v$ 的某个使用点的路径，且该路径不经过对 $v$ 的重新定义。\n- 对于每个基本块 $n$，活跃变量方程为\n$$\\mathrm{IN}[n] = \\mathrm{USE}[n] \\cup \\left(\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n]\\right), \\qquad \\mathrm{OUT}[n] = \\bigcup_{s \\in \\mathrm{Succ}(n)} \\mathrm{IN}[s],$$\n其中 $\\mathrm{USE}[n]$ 是在 $n$ 中任何定义之前就被使用的变量集合，$\\mathrm{DEF}[n]$ 是在 $n$ 中被定义的变量集合，而 $\\mathrm{Succ}(n)$ 是 $n$ 在CFG中的后继节点。\n\n程序具有外层作用域的局部变量 $a$、 $b$、 $c$、 $d$，其字节大小分别为 $s_a = 8$、 $s_b = 8$、 $s_c = 4$、 $s_d = 16$。闭包在基本块 $B_3$ 的末尾创建。为了对跨越闭包边界的活跃性进行建模，在CFG中添加一条从 $B_3$ 到闭包体入口 $G_1$ 的边。外层程序和闭包体由以下基本块以三地址码的形式给出：\n\n- 外层程序：\n  - $B_1$: $a := 1;$ $b := 2;$ $c := b + a;$ goto $B_2$.\n  - $B_2$ 分支到 $B_2^\\mathrm{T}$ 或 $B_2^\\mathrm{F}$：\n    - $B_2^\\mathrm{T}$: if cond then $a := a + 1;$ goto $B_3$.\n    - $B_2^\\mathrm{F}$: else $c := b + 3;$ goto $B_3$.\n  - $B_3$: $t := \\mathrm{closure}(\\lambda u.\\ \\text{body } G);$ if cond2 then $d := a + c$ else $b := b + 5;$ goto $B_4$.\n  - $B_4$: call $h(t);$ return.\n\n- 闭包体：\n  - $G_1$: $x := a + c;$ goto $G_2$.\n  - $G_2$: if $\\phi$ then $y := b$ else $y := a;$ goto $G_3$.\n  - $G_3$: return $x + y$.\n\n假设变量 $x$ 和 $y$ 是闭包的局部变量，不属于外层变量集合。使用上述活跃变量DFA定义，计算最小闭包环境，即其活跃范围与基本块 $B_3$ 末尾的闭包创建点相交的外层变量集合。然后，计算总环境大小（以字节为单位），即该最小集合中所有变量 $v$ 的大小 $s_v$ 之和。请用一个精确的整数字节数表示您的最终答案。无需四舍五入。请以字节为单位给出您的最终数值答案。", "solution": "该问题要求计算词法闭包环境的最小大小。这通过识别闭包中其活跃范围与闭包创建点相交的自由变量集合来实现。问题指定在程序的控制流图（CFG）上使用反向活跃变量数据流分析（DFA）。\n\n首先，我们建立CFG并确定每个基本块的 `USE` 和 `DEF` 集合。该程序由一个包含基本块 $B_1, B_2, B_2^\\mathrm{T}, B_2^\\mathrm{F}, B_3, B_4$ 的外层函数和一个包含基本块 $G_1, G_2, G_3$ 的闭包体组成。外层作用域变量是 $\\{a, b, c, d\\}$，闭包的局部变量是 $\\{x, y\\}$。\n\nCFG的后继关系 $\\mathrm{Succ}(n)$ 如下：\n- $\\mathrm{Succ}(B_1) = \\{B_2\\}$\n- 为简化分析，我们可以将空的分支块 $B_2$ 与其后继块合并。但我们遵循给定的结构：$\\mathrm{Succ}(B_2) = \\{B_2^\\mathrm{T}, B_2^\\mathrm{F}\\}$。\n- $\\mathrm{Succ}(B_2^\\mathrm{T}) = \\{B_3\\}$\n- $\\mathrm{Succ}(B_2^\\mathrm{F}) = \\{B_3\\}$\n- $\\mathrm{Succ}(B_3) = \\{B_4, G_1\\}$。从 $B_3$到 $G_1$ 的边是为对闭包调用的活跃性进行建模而明确添加的。\n- $\\mathrm{Succ}(B_4) = \\emptyset$ （因为 `return` 语句）。\n- $\\mathrm{Succ}(G_1) = \\{G_2\\}$\n- $\\mathrm{Succ}(G_2) = \\{G_3\\}$\n- $\\mathrm{Succ}(G_3) = \\emptyset$ （因为 `return` 语句）。\n\n接下来，我们确定每个基本块 $n$ 的 $\\mathrm{USE}[n]$ 和 $\\mathrm{DEF}[n]$ 集合。$\\mathrm{USE}[n]$ 包含在 $n$ 中任何定义之前被使用的变量，而 $\\mathrm{DEF}[n]$ 包含在 $n$ 中被定义的变量。\n- $B_1: a := 1; b := 2; c := b + a;$\n  - $\\mathrm{USE}[B_1] = \\emptyset$\n  - $\\mathrm{DEF}[B_1] = \\{a, b, c\\}$\n- $B_2$: 分支\n  - $\\mathrm{USE}[B_2] = \\emptyset$\n  - $\\mathrm{DEF}[B_2] = \\emptyset$\n- $B_2^\\mathrm{T}: a := a + 1;$\n  - $\\mathrm{USE}[B_2^\\mathrm{T}] = \\{a\\}$\n  - $\\mathrm{DEF}[B_2^\\mathrm{T}] = \\{a\\}$\n- $B_2^\\mathrm{F}: c := b + 3;$\n  - $\\mathrm{USE}[B_2^\\mathrm{F}] = \\{b\\}$\n  - $\\mathrm{DEF}[B_2^\\mathrm{F}] = \\{c\\}$\n- $B_3: t := \\mathrm{closure}(...); \\text{if cond2 then } d := a + c \\text{ else } b := b + 5;$\n  - $\\mathrm{USE}[B_3] = \\{a, b, c\\}$\n  - $\\mathrm{DEF}[B_3] = \\{b, d\\}$ （可能被定义的变量）\n- $B_4: \\text{call } h(t); \\text{return};$\n  - $\\mathrm{USE}[B_4] = \\emptyset$ （相对于 $\\{a, b, c, d, x, y\\}$）\n  - $\\mathrm{DEF}[B_4] = \\emptyset$\n- $G_1: x := a + c;$\n  - $\\mathrm{USE}[G_1] = \\{a, c\\}$\n  - $\\mathrm{DEF}[G_1] = \\{x\\}$\n- $G_2: \\text{if } \\phi \\text{ then } y := b \\text{ else } y := a;$\n  - $\\mathrm{USE}[G_2] = \\{a, b\\}$\n  - $\\mathrm{DEF}[G_2] = \\{y\\}$\n- $G_3: \\text{return } x + y;$\n  - $\\mathrm{USE}[G_3] = \\{x, y\\}$\n  - $\\mathrm{DEF}[G_3] = \\emptyset$\n\n我们迭代应用活跃变量方程，直到 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集合收敛。我们将所有集合初始化为 $\\emptyset$。\n$$ \\mathrm{IN}[n] = \\mathrm{USE}[n] \\cup (\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n]) $$\n$$ \\mathrm{OUT}[n] = \\bigcup_{s \\in \\mathrm{Succ}(n)} \\mathrm{IN}[s] $$\n\n**第1次迭代：**\n- $\\mathrm{OUT}[B_4] = \\emptyset$\n- $\\mathrm{IN}[B_4] = \\mathrm{USE}[B_4] \\cup (\\mathrm{OUT}[B_4] \\setminus \\mathrm{DEF}[B_4]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$\n- $\\mathrm{OUT}[G_3] = \\emptyset$\n- $\\mathrm{IN}[G_3] = \\mathrm{USE}[G_3] \\cup (\\mathrm{OUT}[G_3] \\setminus \\mathrm{DEF}[G_3]) = \\{x, y\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x, y\\}$\n- $\\mathrm{OUT}[G_2] = \\mathrm{IN}[G_3] = \\{x, y\\}$\n- $\\mathrm{IN}[G_2] = \\mathrm{USE}[G_2] \\cup (\\mathrm{OUT}[G_2] \\setminus \\mathrm{DEF}[G_2]) = \\{a, b\\} \\cup (\\{x, y\\} \\setminus \\{y\\}) = \\{a, b, x\\}$\n- $\\mathrm{OUT}[G_1] = \\mathrm{IN}[G_2] = \\{a, b, x\\}$\n- $\\mathrm{IN}[G_1] = \\mathrm{USE}[G_1] \\cup (\\mathrm{OUT}[G_1] \\setminus \\mathrm{DEF}[G_1]) = \\{a, c\\} \\cup (\\{a, b, x\\} \\setminus \\{x\\}) = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_3] = \\mathrm{IN}[B_4] \\cup \\mathrm{IN}[G_1] = \\emptyset \\cup \\{a, b, c\\} = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_3] = \\mathrm{USE}[B_3] \\cup (\\mathrm{OUT}[B_3] \\setminus \\mathrm{DEF}[B_3]) = \\{a, b, c\\} \\cup (\\{a, b, c\\} \\setminus \\{b, d\\}) = \\{a, b, c\\} \\cup \\{a, c\\} = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_2^\\mathrm{T}] = \\mathrm{IN}[B_3] = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_2^\\mathrm{T}] = \\mathrm{USE}[B_2^\\mathrm{T}] \\cup (\\mathrm{OUT}[B_2^\\mathrm{T}] \\setminus \\mathrm{DEF}[B_2^\\mathrm{T}]) = \\{a\\} \\cup (\\{a, b, c\\} \\setminus \\{a\\}) = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_2^\\mathrm{F}] = \\mathrm{IN}[B_3] = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_2^\\mathrm{F}] = \\mathrm{USE}[B_2^\\mathrm{F}] \\cup (\\mathrm{OUT}[B_2^\\mathrm{F}] \\setminus \\mathrm{DEF}[B_2^\\mathrm{F}]) = \\{b\\} \\cup (\\{a, b, c\\} \\setminus \\{c\\}) = \\{b\\} \\cup \\{a, b\\} = \\{a, b\\}$\n- $\\mathrm{OUT}[B_2] = \\mathrm{IN}[B_2^\\mathrm{T}] \\cup \\mathrm{IN}[B_2^\\mathrm{F}] = \\{a, b, c\\} \\cup \\{a, b\\} = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_2] = \\mathrm{USE}[B_2] \\cup (\\mathrm{OUT}[B_2] \\setminus \\mathrm{DEF}[B_2]) = \\emptyset \\cup (\\{a, b, c\\} \\setminus \\emptyset) = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_1] = \\mathrm{IN}[B_2] = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_1] = \\mathrm{USE}[B_1] \\cup (\\mathrm{OUT}[B_1] \\setminus \\mathrm{DEF}[B_1]) = \\emptyset \\cup (\\{a, b, c\\} \\setminus \\{a, b, c\\}) = \\emptyset$\n\n第二次迭代显示所有 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集合均未改变，因此分析已收敛到一个不动点。\n\n问题陈述，“最小闭包环境是其活跃范围与基本块 $B_3$ 末尾的闭包创建点相交的外层变量集合”。在基本块上的DFA背景下，在一个块 $n$ 末尾的活跃变量集合是 $\\mathrm{OUT}[n]$。\n\n根据我们的分析，在块 $B_3$ 末尾的活跃变量集合是：\n$$ \\mathrm{OUT}[B_3] = \\{a, b, c\\} $$\n这些变量因其后续使用而活跃，无论是在闭包体中（到 $G_1$ 的路径），还是在主程序流中（到 $B_4$ 的路径，尽管在此情况下 $\\mathrm{IN}[B_4]=\\emptyset$）。$\\{a, b, c\\}$ 的活跃性完全由它们在闭包体内部的使用决定，反向传播成为 $\\mathrm{IN}[G_1]$，这又决定了 $\\mathrm{OUT}[B_3]$。\n\n外层作用域的变量集合是 $\\{a, b, c, d\\}$。最小闭包环境由该集合中同时也在 $\\mathrm{OUT}[B_3]$ 中的变量组成。\n$$ \\text{被捕获的变量} = \\mathrm{OUT}[B_3] \\cap \\{a, b, c, d\\} = \\{a, b, c\\} $$\n变量 $d$ 没有被捕获，因为它在块 $B_3$ 之后不是活跃的；不存在从 $B_3$ 末尾到 $d$ 的某个使用点的路径。\n\n最后，我们使用给定的被捕获变量的大小来计算此环境的总大小：$s_a = 8$ 字节，$s_b = 8$ 字节，以及 $s_c = 4$ 字节。\n$$ \\text{总大小} = s_a + s_b + s_c = 8 + 8 + 4 = 20 \\text{ 字节} $$\n总环境大小为 $20$ 字节。", "answer": "$$\\boxed{20}$$", "id": "3627881"}, {"introduction": "在最小化闭包环境之后，我们可以进一步寻找常见的特殊模式，以完全避免环境的分配。这个练习聚焦于一种重要的特殊情况优化 ([@problem_id:3627920])：在面向对象的语言中，当一个闭包只捕获了 $this$ 指针时，它可以被转换为一个更高效的方法指针。通过应用这个优化规则并量化其带来的成本节约，你将学会如何识别并利用特定模式来提升代码性能。", "problem": "给定一个闭包表示的数学模型，以及一条基于标准编译器关于词法作用域和环境捕获原理的优化规则。一个闭包表示为一个序对 $(f, E)$，其中 $f$ 是一个指向函数的代码指针，$E$ 是一个环境对象，包含了该闭包捕获的所有自由变量。在典型的具有隐式接收者语义的面向对象环境中，接收者被称为 $this$。我们使用一个多重集来建模捕获，其元素类型为 $\\{\\mathrm{THIS}, \\mathrm{INT}, \\mathrm{PTR}\\}$，其中 $\\mathrm{THIS}$ 表示接收者指针，$\\mathrm{INT}$ 表示一个被提升到环境中的捕获整数值，而 $\\mathrm{PTR}$ 表示任何其他被捕获的指针。\n\n基本基础：\n- 在词法作用域中，闭包必须为其自由变量携带绑定，以便函数 $f$ 之后能以正确的语义被调用。环境 $E$ 存储了这些绑定。\n- 在标准表示中，闭包的形成会分配一个环境 $E$，其中为每个捕获的变量包含一个单元，并且闭包存储一个指向 $E$ 的指针。所有捕获的变量在调用期间从 $E$ 中加载。\n- 在面向对象的方法调用中，接收者 $this$ 是 $f$ 的一个特殊参数，如果它是闭包携带的唯一值，则可以通过将闭包表示为直接与接收者配对的方法指针来消除环境分配。\n\n需要实现的优化规则：\n- 当且仅当环境 $E$ 只捕获了 $this$（即 $E=\\{\\mathrm{THIS}\\}$ 且基数 $|E|=1$）时，将闭包表示 $(f, E)$ 替换为方法指针表示 $(f, this)$，该表示在调用时将 $this$ 作为显式参数传递给 $f$。这消除了为 $E$ 进行的堆分配，并将环境成本降至零。\n- 否则，保持闭包不变。\n\n定义优化前的环境成本 $C_{\\text{before}}$ 为闭包形成时为 $E$ 分配的单元数，等于捕获变量的总数：如果 $n_{\\mathrm{THIS}}$ 是 $\\mathrm{THIS}$ 捕获的数量，$n_{\\mathrm{INT}}$ 是 $\\mathrm{INT}$ 捕获的数量，$n_{\\mathrm{PTR}}$ 是 $\\mathrm{PTR}$ 捕获的数量，则\n$$\nC_{\\text{before}} = n_{\\mathrm{THIS}} + n_{\\mathrm{INT}} + n_{\\mathrm{PTR}}.\n$$\n优化后，定义环境成本 $C_{\\text{after}}$ 为：如果优化适用，则为 $0$（因为 $E$ 被消除）；否则为 $C_{\\text{before}}$。适用性标志 $T$ 定义为：当优化适用时为 $1$，否则为 $0$。同时报告分配节省 $S = C_{\\text{before}} - C_{\\text{after}}$。\n\n你的任务是实现一个程序，对测试套件中的每个闭包，确定优化是否适用，并计算 $(T, C_{\\text{before}}, C_{\\text{after}}, S)$。\n\n测试套件：\n每个测试用例由元组 $(n_{\\mathrm{THIS}}, n_{\\mathrm{INT}}, n_{\\mathrm{PTR}})$ 指定，所有值均为非负整数。使用以下测试用例：\n- 用例 1：$(1, 0, 0)$。\n- 用例 2：$(1, 1, 0)$。\n- 用例 3：$(0, 0, 0)$。\n- 用例 4：$(0, 1, 0)$。\n- 用例 5：$(1, 0, 1)$。\n- 用例 6：$(0, 0, 1)$。\n- 用例 7：$(1, 1, 1)$。\n\n输出规范：\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个形式为 $[T, C_{\\text{before}}, C_{\\text{after}}, S]$ 的内部列表。\n- 对于上述七个用例，要求的输出格式为单行：$[[T_1, C_{\\text{before},1}, C_{\\text{after},1}, S_1],[T_2, C_{\\text{before},2}, C_{\\text{after},2}, S_2],\\dots,[T_7, C_{\\text{before},7}, C_{\\text{after},7}, S_7]]$。\n- 所有报告的值必须是整数。不涉及物理单位或角度单位。\n\n科学真实性：\n- 环境单元模型假设每个捕获的变量对环境表示贡献恰好一个单元，这在成本以统一的指针大小单元度量的抽象机模型中是标准的。\n- 该优化是可靠的，因为当 $E=\\{\\mathrm{THIS}\\}$ 时，用显式传递 $this$ 替换隐式环境解引用，在采用词法作用域的值调用（call-by-value）下保持了可观察等价性，并消除了不必要的堆分配。\n\n你的程序必须是自包含的，不需要任何输入。它必须计算并打印出上述固定测试套件所要求的确切格式。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于已建立的编译器设计原则，问题阐述清晰，具有明确的确定性算法，并以客观、形式化的语言表达。闭包表示、环境捕获和指定优化的模型是编程语言实现研究中的标准概念。所有必要的定义和数据都已提供，没有矛盾或歧义。\n\n解决方案的步骤是实现指定的优化规则，并为每个测试用例计算相应的成本度量。\n\n设每种捕获变量的数量由 $n_{\\mathrm{THIS}}$、$n_{\\mathrm{INT}}$ 和 $n_{\\mathrm{PTR}}$ 表示。这些是为每个测试用例提供的非负整数。\n\n优化前的环境成本 $C_{\\text{before}}$ 是捕获变量的总数。这是捕获多重集的基数，计算方式如下：\n$$\nC_{\\text{before}} = n_{\\mathrm{THIS}} + n_{\\mathrm{INT}} + n_{\\mathrm{PTR}}\n$$\n\n问题的核心在于优化规则。该优化仅在环境 $E$ 只捕获接收者指针 `this` 时适用。在给定的模型中，这对应于捕获的多重集恰好是 $\\{\\mathrm{THIS}\\}$ 且基数为 $1$。这转化为精确的逻辑条件：\n$$\n(n_{\\mathrm{THIS}} = 1) \\land (n_{\\mathrm{INT}} = 0) \\land (n_{\\mathrm{PTR}} = 0)\n$$\n\n适用性标志 $T$ 是该条件的二进制指示器：\n$$\nT = \\begin{cases} 1  \\text{如果 } (n_{\\mathrm{THIS}} = 1) \\land (n_{\\mathrm{INT}} = 0) \\land (n_{\\mathrm{PTR}} = 0) \\\\ 0  \\text{否则} \\end{cases}\n$$\n\n优化后的环境成本 $C_{\\text{after}}$ 取决于优化是否被应用。如果应用了优化（$T=1$），环境分配被消除，其成本变为 $0$。否则（$T=0$），环境保持不变，其成本也不变。这可以表示为：\n$$\nC_{\\text{after}} = (1 - T) \\cdot C_{\\text{before}}\n$$\n\n最后，分配节省 $S$ 是成本的减少量：\n$$\nS = C_{\\text{before}} - C_{\\text{after}}\n$$\n代入 $C_{\\text{after}}$ 的表达式，我们得到：\n$$\nS = C_{\\text{before}} - (1 - T) \\cdot C_{\\text{before}} = C_{\\text{before}} \\cdot (1 - (1 - T)) = T \\cdot C_{\\text{before}}\n$$\n这证实了只有当优化被应用时（$T=1$）才会产生节省，并且节省的量是环境的全部原始成本。\n\n我们将此算法应用于每个测试用例。\n\n**示例用例 1: $(n_{\\mathrm{THIS}}, n_{\\mathrm{INT}}, n_{\\mathrm{PTR}}) = (1, 0, 0)$**\n1.  计算 $C_{\\text{before}}$: $C_{\\text{before}} = 1 + 0 + 0 = 1$。\n2.  检查条件: $(n_{\\mathrm{THIS}} = 1) \\land (n_{\\mathrm{INT}} = 0) \\land (n_{\\mathrm{PTR}} = 0)$ 为真。\n3.  设置 $T$: $T=1$。\n4.  计算 $C_{\\text{after}}$: $C_{\\text{after}} = (1 - 1) \\cdot 1 = 0$。\n5.  计算 $S$: $S = C_{\\text{before}} - C_{\\text{after}} = 1 - 0 = 1$。\n6.  结果是 $(T, C_{\\text{before}}, C_{\\text{after}}, S) = (1, 1, 0, 1)$。\n\n**示例用例 2: $(n_{\\mathrm{THIS}}, n_{\\mathrm{INT}}, n_{\\mathrm{PTR}}) = (1, 1, 0)$**\n1.  计算 $C_{\\text{before}}$: $C_{\\text{before}} = 1 + 1 + 0 = 2$。\n2.  检查条件: $(n_{\\mathrm{INT}} = 0)$ 为假。整个合取式为假。\n3.  设置 $T$: $T=0$。\n4.  计算 $C_{\\text{after}}$: $C_{\\text{after}} = (1 - 0) \\cdot 2 = 2$。\n5.  计算 $S$: $S = C_{\\text{before}} - C_{\\text{after}} = 2 - 2 = 0$。\n6.  结果是 $(T, C_{\\text{before}}, C_{\\text{after}}, S) = (0, 2, 2, 0)$。\n\n程序将系统地将此过程应用于测试套件中提供的所有测试用例，并将集体结果格式化为指定的单行输出。", "answer": "[[1, 1, 0, 1], [0, 2, 2, 0], [0, 0, 0, 0], [0, 1, 1, 0], [0, 2, 2, 0], [0, 1, 1, 0], [0, 3, 3, 0]]", "id": "3627920"}]}