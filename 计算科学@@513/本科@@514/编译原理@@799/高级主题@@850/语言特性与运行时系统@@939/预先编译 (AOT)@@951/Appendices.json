{"hands_on_practices": [{"introduction": "AOT 编译器的核心挑战之一是必须保证其优化对于所有可能的运行时输入都是正确的。本练习 [@problem_id:3620671] 引入了一个使用“毒化”值 ($\\mathsf{poison}$) 的形式化模型，用于推理在存在未定义行为（如除以零）时常量折叠的安全性。你需要依据严格的“AOT 健全性”准则，判断哪些优化规则是安全的，从而培养严谨思考编译器正确性的基本技能。", "problem": "一个预先（Ahead-of-Time, AOT）编译器在程序输入未知之前，对一个中间表示（Intermediate Representation, IR）应用常量折叠。考虑该 IR 的一个直线型子集，其中表达式由整型变量和常量通过整数加法 $+$、乘法 $\\times$、按位与 $\\wedge$ 和整数除法 $\\div$ 构成。我们使用一种毒化感知（poison-aware）的指称语义来建模潜在的未定义行为（Undefined Behavior, UB），以在优化过程中保持健全性约束。\n\n基础设定：设值域为 $V = \\mathbb{Z} \\cup \\{\\mathsf{poison}\\}$。求值函数 $\\llbracket e \\rrbracket : \\mathbb{Z}^{k} \\to V$ 将一个具有 $k$ 个自由整型变量的表达式 $e$ 映射为一个整数或 $\\mathsf{poison}$。该语义由以下经过充分测试的规则定义：\n- $\\mathsf{poison}$ 的纯粹传播：对于任何二元运算符 $\\circ \\in \\{+, \\times, \\wedge, \\div\\}$ 和操作数 $v_1, v_2 \\in V$，如果 $v_1 = \\mathsf{poison}$ 或 $v_2 = \\mathsf{poison}$，则 $v_1 \\circ v_2 = \\mathsf{poison}$。\n- 整数除法：对于 $a, b \\in \\mathbb{Z}$，如果 $b = 0$，则 $a \\div b = \\mathsf{poison}$，否则 $a \\div b$ 是数学上的整数商；当两个操作数都在 $\\mathbb{Z}$ 中时，按位与和其它运算符的行为与标准定义一致。\n- 可观察性：返回 $\\mathsf{poison}$（或在控制流中使用它）在运行时构成 UB；$\\mathbb{Z}$ 中的整数结果是已定义行为。\n\n一个局部重写 $e \\Rightarrow e'$ 在保持毒化值的语义下被称为是 AOT-健全的，如果对于所有将整数值赋给 $e$ 的自由变量的环境 $\\rho \\in \\mathbb{Z}^{k}$，\n- 如果 $\\llbracket e \\rrbracket(\\rho) \\in \\mathbb{Z}$，则 $\\llbracket e' \\rrbracket(\\rho) = \\llbracket e \\rrbracket(\\rho)$（不改变已定义行为），并且\n- 如果 $\\llbracket e \\rrbracket(\\rho) = \\mathsf{poison}$，则 $\\llbracket e' \\rrbracket(\\rho) = \\mathsf{poison}$（保持毒化值而不是静默地消除它）。\n\n该语义捕捉了 AOT 编译器不能折叠掉依赖于输入的 UB 的要求。\n\n考虑以下候选常量折叠规则，每个规则都旨在局部应用，不求值子表达式，也不窥视运行时输入：\n- A. 对于所有表达式 $e$，重写 $0 \\times e \\Rightarrow 0$。\n- B. 对于所有变量 $x$，重写 $x \\div x \\Rightarrow 1$。\n- C. 对于所有变量 $x$，重写 $x + 0 \\Rightarrow x$。\n- D. 对于所有表达式 $e$，重写 $e \\wedge 0 \\Rightarrow 0$。\n- E. 对于所有变量 $x$，在程序点处有一个已证明的静态前置条件 $x \\neq 0$ 的情况下，重写 $x \\div x \\Rightarrow 1$。\n\n在上述定义的保持毒化值的语义下，哪些规则是 AOT-健全的？选择所有适用项。", "solution": "首先验证问题陈述，以确保其科学上合理、良构的、客观的和自足的。\n\n### 第 1 步：提取已知条件\n- **值域**：$V = \\mathbb{Z} \\cup \\{\\mathsf{poison}\\}$。\n- **求值函数**：对于一个具有 $k$ 个自由整型变量的表达式 $e$，$\\llbracket e \\rrbracket : \\mathbb{Z}^{k} \\to V$。环境 $\\rho \\in \\mathbb{Z}^{k}$ 为这些变量赋予整数值。\n- **二元运算符的语义**：\n    1.  **毒化值传播**：对于任何二元运算符 $\\circ \\in \\{+, \\times, \\wedge, \\div\\}$ 和操作数 $v_1, v_2 \\in V$，如果 $v_1 = \\mathsf{poison}$ 或 $v_2 = \\mathsf{poison}$，则 $v_1 \\circ v_2 = \\mathsf{poison}$。这意味着所有运算符都是严格的。\n    2.  **整数除法**：对于 $a, b \\in \\mathbb{Z}$，如果 $b = 0$，则 $a \\div b = \\mathsf{poison}$。否则，$a \\div b$ 是标准的整数商。\n    3.  **其他运算符**：对于 $a, b \\in \\mathbb{Z}$，运算符 $+, \\times, \\wedge$ 分别按标准的整数加法、乘法和按位与进行运算。\n- **AOT-健全性的定义**：一个重写 $e \\Rightarrow e'$ 是 AOT-健全的，如果对于所有环境 $\\rho \\in \\mathbb{Z}^{k}$：\n    1.  如果 $\\llbracket e \\rrbracket(\\rho) \\in \\mathbb{Z}$，则 $\\llbracket e' \\rrbracket(\\rho) = \\llbracket e \\rrbracket(\\rho)$。（保持已定义行为的值。）\n    2.  如果 $\\llbracket e \\rrbracket(\\rho) = \\mathsf{poison}$，则 $\\llbracket e' \\rrbracket(\\rho) = \\mathsf{poison}$。（保持未定义行为。）\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题陈述是指称语义在编译器优化中的一个形式化练习，这是计算机科学中的一个标准课题。\n- **科学上合理**：该模型使用成熟的形式化方法（指称语义）来推理程序转换。使用 `poison` 值来表示潜在的未定义行为是现代编译器中一种众所周知的技术（例如 LLVM 的 `poison` 和 `undef` 值）。该设置在逻辑上是一致的，并以编译器理论为基础。\n- **良构的**：值域、运算符语义和健全性的定义是精确且无歧义的。任务是根据这些定义检查一个有限的候选规则列表，这使得每个规则都有一个唯一且稳定的答案。\n- **客观的**：问题以形式化的数学和逻辑语言表述，没有主观性或歧义。\n- **完整性和一致性**：问题提供了进行所需分析的所有必要定义。没有内部矛盾。\n\n### 第 3 步：结论与行动\n问题是有效的。现在，解题过程将通过分析每个候选规则是否符合所提供的 AOT-健全性定义来继续。\n\n令 $e_{LHS}$ 表示重写规则的左侧表达式，$e_{RHS}$ 表示右侧表达式。一个规则要成为 AOT-健全的，必须对所有环境 $\\rho$ 满足两个条件：\n1. 如果 $\\llbracket e_{LHS} \\rrbracket(\\rho) \\in \\mathbb{Z}$，则 $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket e_{LHS} \\rrbracket(\\rho)$。\n2. 如果 $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$，则 $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\mathsf{poison}$。\n\n我们将针对这两个条件评估每个候选规则。\n\n### 逐项分析\n\n**A. 对于所有表达式 $e$，重写 $0 \\times e \\Rightarrow 0$。**\n\n令 $e_{LHS} = 0 \\times e$ 和 $e_{RHS} = 0$。我们测试第二个 AOT-健全性条件。我们必须检查是否 $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$ 蕴含 $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\mathsf{poison}$。\n让我们选择一个表达式 $e$ 和一个环境 $\\rho$，使得 $\\llbracket e \\rrbracket(\\rho) = \\mathsf{poison}$。例如，令 $e$ 为表达式 $x \\div 0$，其中 $x$ 是某个变量。对于任何环境 $\\rho$，$\\llbracket x \\div 0 \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) \\div \\llbracket 0 \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) \\div 0 = \\mathsf{poison}$。\n现在，让我们用这个 $e$ 来求值 $e_{LHS}$。\n$\\llbracket e_{LHS} \\rrbracket(\\rho) = \\llbracket 0 \\times (x \\div 0) \\rrbracket(\\rho) = \\llbracket 0 \\rrbracket(\\rho) \\times \\llbracket x \\div 0 \\rrbracket(\\rho) = 0 \\times \\mathsf{poison}$。\n根据“毒化值的纯粹传播”规则，$0 \\times \\mathsf{poison} = \\mathsf{poison}$。所以，$\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$。\n现在，让我们求值 $e_{RHS}$：\n$\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket 0 \\rrbracket(\\rho) = 0$。\n这里，我们有一个情况，其中 $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$ 但 $\\llbracket e_{RHS} \\rrbracket(\\rho) = 0$。该重写将一个 `poison` 值更改为一个整数 `0`，因此违反了第二个条件。这种转换非法地移除了潜在的未定义行为。\n\n结论：**错误**。\n\n**B. 对于所有变量 $x$，重写 $x \\div x \\Rightarrow 1$。**\n\n令 $e_{LHS} = x \\div x$ 和 $e_{RHS} = 1$。我们测试第二个条件。\n考虑一个环境 $\\rho$，其中 $\\rho(x) = 0$。\n$\\llbracket e_{LHS} \\rrbracket(\\rho) = \\llbracket x \\div x \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) \\div \\llbracket x \\rrbracket(\\rho) = 0 \\div 0$。\n根据整数除法规则，除以零导致 `poison`。所以，$\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$。\n现在，我们求值 $e_{RHS}$：\n$\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket 1 \\rrbracket(\\rho) = 1$。\n这是一个情况，其中 $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$ 但 $\\llbracket e_{RHS} \\rrbracket(\\rho) = 1$。该转换移除了与 $0 \\div 0$ 相关的 UB，并将其替换为已定义的值 $1$。这违反了第二个健全性条件。\n\n结论：**错误**。\n\n**C. 对于所有变量 $x$，重写 $x + 0 \\Rightarrow x$。**\n\n令 $e_{LHS} = x + 0$ 和 $e_{RHS} = x$。\n环境 $\\rho$ 将变量 $x$ 映射到一个整数值，比如 $\\rho(x) = v_x \\in \\mathbb{Z}$。根据定义，$\\llbracket x \\rrbracket(\\rho) = v_x$。\n\n1.  **条件 1**：假设 $\\llbracket e_{LHS} \\rrbracket(\\rho) \\in \\mathbb{Z}$。\n    $\\llbracket x + 0 \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) + \\llbracket 0 \\rrbracket(\\rho) = v_x + 0 = v_x$。这个值总是在 $\\mathbb{Z}$ 中。\n    我们必须检查是否 $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket e_{LHS} \\rrbracket(\\rho)$。\n    $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) = v_x$。\n    因为 $v_x = v_x$，该条件成立。\n\n2.  **条件 2**：假设 $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$。\n    如上所示，$\\llbracket x + 0 \\rrbracket(\\rho) = v_x + 0 = v_x$，其中 $v_x$ 是一个整数。结果永远不会是 $\\mathsf{poison}$。该条件的前提，即 $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$，对于所有环境 $\\rho$ 都是假的。因此，该蕴含关系空泛为真。\n\n两个 AOT-健全性条件对所有环境 $\\rho$ 都满足。\n\n结论：**正确**。\n\n**D. 对于所有表达式 $e$，重写 $e \\wedge 0 \\Rightarrow 0$。**\n\n令 $e_{LHS} = e \\wedge 0$ 和 $e_{RHS} = 0$。这个情况与规则 A 类似。\n我们测试第二个条件。让我们找一个 $e$ 和 $\\rho$ 使得 $\\llbracket e \\rrbracket(\\rho) = \\mathsf{poison}$。和之前一样，令 $e$ 为 $x \\div 0$。\n$\\llbracket e_{LHS} \\rrbracket(\\rho) = \\llbracket (x \\div 0) \\wedge 0 \\rrbracket(\\rho) = \\llbracket x \\div 0 \\rrbracket(\\rho) \\wedge \\llbracket 0 \\rrbracket(\\rho) = \\mathsf{poison} \\wedge 0$。\n根据毒化值传播规则，$\\mathsf{poison} \\wedge 0 = \\mathsf{poison}$。所以，$\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$。\n现在，我们求值 $e_{RHS}$：\n$\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket 0 \\rrbracket(\\rho) = 0$。\n我们有一个情况，其中 $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$ 但 $\\llbracket e_{RHS} \\rrbracket(\\rho) = 0$。这违反了第二个健全性条件。按位与 $0$ 在数学上结果恒为 $0$ 这一事实是无关紧要的；必须遵守严格的毒化语义。\n\n结论：**错误**。\n\n**E. 对于所有变量 $x$，在程序点处有一个已证明的静态前置条件 $x \\neq 0$ 的情况下，重写 $x \\div x \\Rightarrow 1$。**\n\n令 $e_{LHS} = x \\div x$ 和 $e_{RHS} = 1$。此分析仅限于满足前置条件的环境 $\\rho$，即 $\\rho(x) = v_x$ 且 $v_x \\neq 0$。\n\n1.  **条件 1**：对于一个环境 $\\rho$ 其中 $\\rho(x) = v_x \\neq 0$，假设 $\\llbracket e_{LHS} \\rrbracket(\\rho) \\in \\mathbb{Z}$。\n    $\\llbracket x \\div x \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) \\div \\llbracket x \\rrbracket(\\rho) = v_x \\div v_x$。\n    因为 $v_x$ 是一个非零整数，所以除法是良定义的，结果为 $1$。所以，$\\llbracket e_{LHS} \\rrbracket(\\rho) = 1 \\in \\mathbb{Z}$。\n    我们必须检查是否 $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket e_{LHS} \\rrbracket(\\rho)$。\n    $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket 1 \\rrbracket(\\rho) = 1$。\n    因为 $1 = 1$，该条件成立。\n\n2.  **条件 2**：对于一个环境 $\\rho$ 其中 $\\rho(x) = v_x \\neq 0$，假设 $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$。\n    如上所示，对于任何这样的环境，$\\llbracket x \\div x \\rrbracket(\\rho) = 1$。结果永远不会是 $\\mathsf{poison}$。该条件的前提对于适用的环境集合总是假的。因此，该蕴含关系空泛为真。\n\n两个 AOT-健全性条件对所有满足前置条件的环境都满足。该前置条件是此规则与不健全的规则 B 的区别所在，因为它明确排除了 $x=0$ 这个有问题的情况。\n\n结论：**正确**。", "answer": "$$\\boxed{CE}$$", "id": "3620671"}, {"introduction": "在确认一项优化是安全的之后，下一个问题是它是否真的值得。本练习 [@problem_id:3620675] 提出了一个真实场景：一个 AOT 编译遍尝试对 `printf` 函数调用进行常量折叠，这能带来显著的性能提升，但也会引入额外开销并需处理（如区域设置变化等）特殊情况。你将使用成本模型和概率论来计算预期的性能增益，这是设计高效编译器启发式策略的一项关键技术。", "problem": "我们考虑一个预先（Ahead-of-Time, AOT）编译过程，该过程将 C 标准输入/输出函数 `printf` 在其格式化字符串和参数均为编译时常量的情况下的调用，转换为直接输出一个预计算的常量字符串。例如，调用 `printf(\"x=%d\", 3)` 可以在运行时被替换为输出常量字符串 `\"x=3\"`。该转换的基本依据是：(i) 编译器中常量折叠的定义，该定义允许在编译时对纯计算进行求值，同时保持程序行为的观测等价性；以及 (ii) 任何此类转换都必须在所有与其规范一致的运行时环境下，保持程序的可观测输出这一要求。此外，本文使用概率论中的期望值模型来量化不确定部署条件下的性能。\n\n假设 AOT 过程插入一个运行时守卫，用于检查进程是否在 “C” 区域设置下执行。如果区域设置是 “C” 区域设置，该过程会输出预计算的常量字符串；否则，它会回退到调用 `printf` 以保留区域设置敏感的行为（例如，数字格式化或消息国际化选择）。设每次转换发生时，区域设置守卫的成本为常量时间 $ \\gamma $，且与分支结果无关。假设运行时的成本模型如下：\n- 带有单个整数转换的调用 `printf(\"x=%d\", k)` 的运行时间为 $ t_{\\mathrm{printf}} $。\n- 通过轻量级函数（如 `puts`）输出常量字符串的运行时间为 $ t_{\\mathrm{const}} $。\n- 每次转换发生时，区域设置守卫的成本为 $ \\gamma $ 时间。\n- 在比例为 $ p $ 的运行中，区域设置不是 “C” 区域设置，每次转换发生时都将回退到 `printf`；在比例为 $ 1 - p $ 的运行中，使用 “C” 区域设置，每次转换发生时都将采用输出常量字符串的路径。\n\n考虑一个程序，其中有 $ n $ 个此模式的静态转换实例，并且在每次运行时，每个此类实例都精确执行 $ k $ 次。仅使用这些假设和期望值原理，从第一性原理出发，推导该 AOT 过程每次运行所节省的预期总运行时间的闭式表达式，该表达式用 $ n $、$ k $、$ t_{\\mathrm{printf}} $、$ t_{\\mathrm{const}} $、$ \\gamma $ 和 $ p $ 表示。然后，对于具体的参数值\n$$\nn = 800, \\quad k = 25{,}000, \\quad t_{\\mathrm{printf}} = 800 \\text{ ns}, \\quad t_{\\mathrm{const}} = 120 \\text{ ns}, \\quad \\gamma = 20 \\text{ ns}, \\quad p = 0.15,\n$$\n对表达式进行数值计算，并以秒为单位表示每次运行节省的最终预期总时间。将您的答案四舍五入到四位有效数字，并以秒为单位表示最终时间。", "solution": "该问题经验证具有科学依据、提法恰当、客观且完整。它基于编译器设计和性能分析的标准原则。我现在开始解答。\n\n目标是推导通过一个转换特定 `printf` 调用的预先（AOT）编译过程，每次运行所节省的预期总运行时间的表达式。首先，我们为有转换和无转换两种情况下的程序行为建立成本模型。\n\n设 $n$ 为被转换模式的静态实例数量， $k$ 为每个实例在每次运行中的执行次数。因此，被转换代码块的动态执行总次数 $N$ 为：\n$$ N = n \\times k $$\n\n没有 AOT 转换时的运行时成本很简单。$N$ 次动态执行中的每一次都涉及一次对 `printf` 的调用。总运行时间 $T_{\\mathrm{original}}$ 为：\n$$ T_{\\mathrm{original}} = N \\times t_{\\mathrm{printf}} = n \\times k \\times t_{\\mathrm{printf}} $$\n\n采用 AOT 转换后，会引入一个运行时守卫。执行路径取决于程序的区域设置。让我们分析程序单次运行的两种可能情况。\n\n情况1：区域设置不是 “C” 区域设置。\n此事件发生的概率为 $p$。在这种情况下，程序必须回退到原始的 `printf` 调用以确保正确性（例如，区域设置特定的数字格式化）。对于 $N$ 次动态执行中的每一次，成本包括区域设置守卫检查的成本 $\\gamma$，以及随后的 `printf` 调用本身的成本 $t_{\\mathrm{printf}}$。在此情况下，一次运行的总运行时间 $T_{\\mathrm{fallback}}$ 为：\n$$ T_{\\mathrm{fallback}} = N \\times (\\gamma + t_{\\mathrm{printf}}) = n \\times k \\times (\\gamma + t_{\\mathrm{printf}}) $$\n\n情况2：区域设置是 “C” 区域设置。\n此事件发生的概率为 $1 - p$。在这种情况下，将采用优化路径。对于 $N$ 次动态执行中的每一次，成本包括区域设置守卫检查的成本 $\\gamma$，以及随后的输出预计算常量字符串的成本 $t_{\\mathrm{const}}$。在此情况下，一次运行的总运行时间 $T_{\\mathrm{fast}}$ 为：\n$$ T_{\\mathrm{fast}} = N \\times (\\gamma + t_{\\mathrm{const}}) = n \\times k \\times (\\gamma + t_{\\mathrm{const}}) $$\n\n根据期望值原理，经过转换后的预期总运行时间 $E[T_{\\mathrm{transformed}}]$，是每种情况的运行时间按其各自概率加权后的总和：\n$$ E[T_{\\mathrm{transformed}}] = T_{\\mathrm{fallback}} \\times p + T_{\\mathrm{fast}} \\times (1 - p) $$\n代入 $T_{\\mathrm{fallback}}$ 和 $T_{\\mathrm{fast}}$ 的表达式：\n$$ E[T_{\\mathrm{transformed}}] = [n \\times k \\times (\\gamma + t_{\\mathrm{printf}})] \\times p + [n \\times k \\times (\\gamma + t_{\\mathrm{const}})] \\times (1 - p) $$\n我们可以提出公因式 $n \\times k$：\n$$ E[T_{\\mathrm{transformed}}] = n \\times k \\times [p(\\gamma + t_{\\mathrm{printf}}) + (1 - p)(\\gamma + t_{\\mathrm{const}})] $$\n展开括号内的项：\n$$ E[T_{\\mathrm{transformed}}] = n \\times k \\times [p\\gamma + p \\cdot t_{\\mathrm{printf}} + \\gamma - p\\gamma + t_{\\mathrm{const}} - p \\cdot t_{\\mathrm{const}}] $$\n$$ E[T_{\\mathrm{transformed}}] = n \\times k \\times [\\gamma + p \\cdot t_{\\mathrm{printf}} + (1 - p)t_{\\mathrm{const}}] $$\n\n预期节省的总运行时间 $E[T_{\\mathrm{saved}}]$ 是原始运行时间与预期转换后运行时间之差：\n$$ E[T_{\\mathrm{saved}}] = T_{\\mathrm{original}} - E[T_{\\mathrm{transformed}}] $$\n$$ E[T_{\\mathrm{saved}}] = (n \\times k \\times t_{\\mathrm{printf}}) - (n \\times k \\times [\\gamma + p \\cdot t_{\\mathrm{printf}} + (1 - p)t_{\\mathrm{const}}]) $$\n再次提出公因式 $n \\times k$：\n$$ E[T_{\\mathrm{saved}}] = n \\times k \\times [t_{\\mathrm{printf}} - (\\gamma + p \\cdot t_{\\mathrm{printf}} + (1 - p)t_{\\mathrm{const}})] $$\n$$ E[T_{\\mathrm{saved}}] = n \\times k \\times [t_{\\mathrm{printf}} - \\gamma - p \\cdot t_{\\mathrm{printf}} - (1 - p)t_{\\mathrm{const}}] $$\n合并 $t_{\\mathrm{printf}}$ 相关项：\n$$ E[T_{\\mathrm{saved}}] = n \\times k \\times [(1 - p)t_{\\mathrm{printf}} - (1 - p)t_{\\mathrm{const}} - \\gamma] $$\n最后，提出公因式 $(1 - p)$，得到预期节省总时间的闭式表达式：\n$$ E[T_{\\mathrm{saved}}] = n \\times k \\times [(1 - p)(t_{\\mathrm{printf}} - t_{\\mathrm{const}}) - \\gamma] $$\n\n现在，我们使用给定的数值参数来计算该表达式的值：\n$n = 800$, $k = 25{,}000$, $t_{\\mathrm{printf}} = 800 \\text{ ns}$, $t_{\\mathrm{const}} = 120 \\text{ ns}$, $\\gamma = 20 \\text{ ns}$, $p = 0.15$。\n\n首先，计算动态执行的总次数 $N$：\n$$ N = n \\times k = 800 \\times 25{,}000 = 20{,}000{,}000 = 2 \\times 10^7 $$\n接下来，计算每次执行的预期节省表达式中的各个组成部分：\n$$ 1 - p = 1 - 0.15 = 0.85 $$\n$$ t_{\\mathrm{printf}} - t_{\\mathrm{const}} = 800 \\text{ ns} - 120 \\text{ ns} = 680 \\text{ ns} $$\n每次执行的预期节省为：\n$$ (1 - p)(t_{\\mathrm{printf}} - t_{\\mathrm{const}}) - \\gamma = (0.85)(680 \\text{ ns}) - 20 \\text{ ns} $$\n$$ = 578 \\text{ ns} - 20 \\text{ ns} = 558 \\text{ ns} $$\n预期的总节省时间是动态执行的总次数与每次执行的预期节省时间的乘积：\n$$ E[T_{\\mathrm{saved}}] = (2 \\times 10^7) \\times (558 \\text{ ns}) = 1{,}116 \\times 10^7 \\text{ ns} = 1.116 \\times 10^{10} \\text{ ns} $$\n为了将该值以秒为单位表示，我们使用换算关系 $1 \\text{ s} = 10^9 \\text{ ns}$：\n$$ E[T_{\\mathrm{saved}}] = \\frac{1.116 \\times 10^{10} \\text{ ns}}{10^9 \\text{ ns/s}} = 1.116 \\times 10^1 \\text{ s} = 11.16 \\text{ s} $$\n结果 $11.16$ 具有四位有效数字，符合题目要求。", "answer": "$$\\boxed{11.16}$$", "id": "3620675"}, {"introduction": "AOT 编译并非没有成本，它本身会消耗时间和资源。最后一个练习 [@problem_id:3620650] 将经典的函数内联问题构建为一个资源分配任务，具体来说就是一个 0-1 背包问题。通过应用合适的贪心启发式算法，你将学习编译器如何在固定的编译时间预算内做出战略决策以最大化运行时性能，这是在生产级系统中至关重要的一种权衡。", "problem": "一个预先（ahead-of-time, AOT）编译器必须在执行前，在严格的编译时间预算下，决定内联哪些候选调用点。对于每个候选函数 $f_i$，假设一个静态成本模型估算出其增量编译时间权重 $w_i$ 和执行时间收益 $b_i$，两者均为非负值，并以一致的单位衡量。设总编译时间预算为 $T_{\\max}$。编译器寻求一个要内联的候选子集 $\\mathcal{S}$，该子集在满足预算约束的同时能够提升性能。\n\n使用以下基础进行建模和设计。$0$-$1$ 背包问题定义为：给定一组具有权重 $w_i$ 和价值 $v_i$ 的物品，选择一个子集以最大化 $\\sum_{i \\in \\mathcal{S}} v_i$，其约束条件为 $\\sum_{i \\in \\mathcal{S}} w_i \\le W$。这是一个著名且被广泛研究的组合优化问题，通常是 $\\mathsf{NP}$-难的，存在精确的伪多项式动态规划算法和多种近似启发式算法。在 AOT 编译器中，可预测性和有界的编译开销至关重要，因此任何内联控制器都应简单且快速，并且仅依赖静态估算。假设在此场景中，不允许对递归和相互递归循环进行内联。\n\n考虑 5 个候选函数，其估算值和预算如下：\n- $f_1$: $w_1 = 4$, $b_1 = 9$,\n- $f_2$: $w_2 = 5$, $b_2 = 10$,\n- $f_3$: $w_3 = 3$, $b_3 = 6$,\n- $f_4$: $w_4 = 2$, $b_4 = 4$,\n- $f_5$: $w_5 = 4$, $b_5 = 7$,\n预算 $T_{\\max} = 10$。\n\n哪个选项正确地将该决策问题建模为 $0$-$1$ 背包问题，提出了一种源于该模型、适用于 AOT 且具有可预测低开销的静态启发式算法，并给出了该启发式算法为上述实例所选择的子集，包括其总收益和总权重？\n\nA. 将选择问题建模为 $0$-$1$ 背包问题，目标为在 $\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$ 的约束下最大化 $\\sum_{i \\in \\mathcal{S}} b_i$。使用精确的动态规划 (DP) 算法计算最优子集。对于该实例，DP 返回 $\\{f_2, f_3, f_4\\}$，总收益为 $20$，总权重为 $10$。\n\nB. 将选择问题建模为 $0$-$1$ 背包问题，目标为在 $\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$ 的约束下最大化 $\\sum_{i \\in \\mathcal{S}} b_i$。使用静态贪心启发式算法，按比率 $r_i = b_i / w_i$ 对候选函数进行降序排序，当比率相同时，选择 $b_i$ 较大的，然后在满足预算的条件下依次添加项目。对于该实例，排序为 $f_1$ ($2.25$)，然后是 $f_2$ ($2.0$)、$f_3$ ($2.0$)、$f_4$ ($2.0$)，最后是 $f_5$ ($1.75$)。该启发式算法选择 $\\{f_1, f_2\\}$，总收益为 $19$，总权重为 $9$。\n\nC. 将选择问题建模为 $0$-$1$ 背包问题，但使用仅考虑收益的贪心启发式算法，按 $b_i$ 降序排序并选择项目直至达到预算上限，在排序时忽略 $w_i$。对于该实例，排序为 $f_2, f_1, f_5, f_3, f_4$。该启发式算法选择 $\\{f_2, f_1\\}$，总收益为 $19$，总权重为 $9$。\n\nD. 将选择问题建模为 $0$-$1$ 背包问题，并应用阈值规则：选择所有满足 $b_i \\ge w_i$ 的项目，如果超出预算，则首先丢弃权重最小的项目。对于该实例，所有项目都满足 $b_i \\ge w_i$，所以该规则选择了 $\\{f_2, f_1, f_4\\}$，然后因预算溢出而丢弃 $f_4$，并声称 $\\{f_2, f_1\\}$ 是最终选择，其总收益为 $19$，总权重为 $9$。", "solution": "首先将对问题陈述的科学性和逻辑完整性进行验证。\n\n### 步骤 1：提取已知条件\n- **问题背景**：AOT (ahead-of-time) 编译器必须选择一个候选函数子集 $\\mathcal{S}$ 进行内联。\n- **约束条件**：存在一个严格的总编译时间预算 $T_{\\max}$。内联控制器必须简单、快速，并且仅依赖静态估算。不允许对递归和相互递归进行内联。\n- **函数模型**：对于每个候选函数 $f_i$，我们有：\n  - $w_i$：增量编译时间权重（非负）。\n  - $b_i$：执行时间收益（非负）。\n- **优化目标**：找到一个子集 $\\mathcal{S}$，在满足预算（$\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$）的同时提升性能（解释为最大化 $\\sum_{i \\in \\mathcal{S}} b_i$）。\n- **类比模型**：该问题将仿照 $0$-$1$ 背包问题进行建模，即在 $\\sum_{i \\in \\mathcal{S}} w_i \\le W$ 的约束下最大化 $\\sum_{i \\in \\mathcal{S}} v_i$。\n- **问题实例数据**：\n  - $f_1$: $w_1 = 4$, $b_1 = 9$\n  - $f_2$: $w_2 = 5$, $b_2 = 10$\n  - $f_3$: $w_3 = 3$, $b_3 = 6$\n  - $f_4$: $w_4 = 2$, $b_4 = 4$\n  - $f_5$: $w_5 = 4$, $b_5 = 7$\n  - 预算：$T_{\\max} = 10$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在编译器理论中有充分的依据。函数内联是一种标准的优化方法，编译时成本和运行时收益之间的权衡是一个核心问题。将这种权衡建模为背包问题是编译器启发式算法文献中的一种经典且有效的方法。\n- **问题适定性**：问题陈述清晰。它提供了一个明确定义的优化问题的具体实例，并要求评估与 AOT 编译的实际约束相符的不同启发式方法。\n- **客观性**：语言精确且技术性强。所有术语都有定义，数据是定量的。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。它在科学上是合理的、自洽的、客观的。我现在将开始解决问题。\n\n### 问题分析\n任务是选择一个函数子集进行内联。这可以正式地建模为一个 $0$-$1$ 背包问题。\n- 放入背包的物品是候选函数 $\\{f_1, f_2, f_3, f_4, f_5\\}$。\n- 每个物品 $f_i$ 的“重量”是其编译时间成本 $w_i$。\n- 每个物品 $f_i$ 的“价值”是其执行时间收益 $b_i$。\n- 背包的容量是总编译时间预算 $W = T_{\\max} = 10$。\n- 目标是选择一个函数子集 $\\mathcal{S}$，以最大化总收益 $\\sum_{i \\in \\mathcal{S}} b_i$，约束条件是总权重不超过预算：$\\sum_{i \\in \\mathcal{S}} w_i \\le 10$。\n\n问题明确指出，对于 AOT 编译器，决策过程必须“简单且快速”，并具有“可预测的低开销”。这是选择算法的一个关键约束。\n\n让我们评估所提供的选项。\n\n### 逐项分析选项\n\n**A. 将选择问题建模为 $0$-$1$ 背包问题，目标为在 $\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$ 的约束下最大化 $\\sum_{i \\in \\mathcal{S}} b_i$。使用精确的动态规划 (DP) 算法计算最优子集。对于该实例，DP 返回 $\\{f_2, f_3, f_4\\}$，总收益为 $20$，总权重为 $10$。**\n\n建模是正确的。我们来验证计算。像动态规划这样的精确算法会找到真正的最优解。让我们通过检查组合来找到这个最优解。\n- 集合 $\\{f_2, f_3, f_4\\}$ 的总权重为 $w_2 + w_3 + w_4 = 5 + 3 + 2 = 10$，满足预算 $T_{\\max}=10$。\n- 总收益为 $b_2 + b_3 + b_4 = 10 + 6 + 4 = 20$。\n- 让我们检查是否有其他组合能产生更高的收益。另一个高收益组合是 $\\{f_1, f_2\\}$，权重为 $4+5=9$，收益为 $9+10=19$。另一个是 $\\{f_1, f_3, f_4\\}$，权重为 $4+3+2=9$，收益为 $9+6+4=19$。\n- 穷举搜索证实，收益为 $20$ 的 $\\{f_2, f_3, f_4\\}$ 确实是最优解。\n然而，问题要求一种“适用于 AOT 的静态启发式算法”，该算法要“简单且快速”。背包问题的动态规划时间复杂度为 $\\mathcal{O}(N \\cdot W)$，其中 $N$ 是物品数量，$W$ 是容量。在此背景下，$\\mathcal{O}(5 \\cdot 10)$ 是微不足道的。但对于一个真实的 AOT 编译器场景，可能有数千个候选函数（$N$）和巨大的预算（$T_{\\max}$），这种伪多项式复杂度可能会高得令人望而却步。更重要的是，DP 是一种*精确算法*，而不是*启发式算法*，并且通常被认为比简单的贪心排序更复杂、运行成本更高。问题对简单性和速度的约束使得选择 DP 在指定的 AOT 上下文中是值得怀疑的。\n\n结论：**不正确**。所提出的方法（精确 DP）不是一种“启发式算法”，并且对于所描述的 AOT 编译上下文来说，通常不被认为足够“简单和快速”，尽管它对这个特定的小实例的计算是正确的。\n\n**B. 将选择问题建模为 $0$-$1$ 背包问题，目标为在 $\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$ 的约束下最大化 $\\sum_{i \\in \\mathcal{S}} b_i$。使用静态贪心启发式算法，按比率 $r_i = b_i / w_i$ 对候选函数进行降序排序，当比率相同时，选择 $b_i$ 较大的，然后在满足预算的条件下依次添加项目。对于该实例，排序为 $f_1$ ($2.25$)，然后是 $f_2$ ($2.0$)、$f_3$ ($2.0$)、$f_4$ ($2.0$)，最后是 $f_5$ ($1.75$)。该启发式算法选择 $\\{f_1, f_2\\}$，总收益为 $19$，总权重为 $9$。**\n\n建模是正确的。所提出的基于收益-权重比（价值密度）的贪心启发式算法是背包问题的经典标准启发式算法。它易于实现且速度快，其复杂度主要由排序决定，为 $\\mathcal{O}(N \\log N)$。这完全符合“适用于 AOT”的标准。\n\n让我们验证计算：\n1.  计算比率 $r_i = b_i / w_i$:\n    - $f_1$: $r_1 = 9/4 = 2.25$\n    - $f_2$: $r_2 = 10/5 = 2.0$\n    - $f_3$: $r_3 = 6/3 = 2.0$\n    - $f_4$: $r_4 = 4/2 = 2.0$\n    - $f_5$: $r_5 = 7/4 = 1.75$\n2.  按 $r_i$ 降序排序。平局打破规则是优先选择 $b_i$ 较大的。\n    - 最高比率是 $f_1$ 的 $r_1 = 2.25$。\n    - 其次是 $f_2, f_3, f_4$ 的比率 $r=2.0$ 相同。我们按 $b_i$ 降序对它们进行排序：$b_2=10 > b_3=6 > b_4=4$。所以顺序是 $f_2, f_3, f_4$。\n    - 最低比率是 $f_5$ 的 $r_5 = 1.75$。\n    - 最终排序顺序为：$f_1, f_2, f_3, f_4, f_5$。\n3.  按此顺序选择项目，直到预算 $T_{\\max} = 10$ 用完：\n    - 选择 $f_1$：当前权重 = $4$。剩余预算 = $6$。已选集合：$\\{f_1\\}$。\n    - 选择 $f_2$：权重 $5 \\le 6$。新权重 = $4+5=9$。剩余预算 = $1$。已选集合：$\\{f_1, f_2\\}$。\n    - 考虑 $f_3$：权重 $3 > 1$。无法选择。\n    - 考虑 $f_4$：权重 $2 > 1$。无法选择。\n    - 考虑 $f_5$：权重 $4 > 1$。无法选择。\n4.  最终选择的集合是 $\\mathcal{S} = \\{f_1, f_2\\}$。\n    - 总权重：$w_1 + w_2 = 4+5=9$。\n    - 总收益：$b_1 + b_2 = 9+10=19$。\n\n所提出的启发式算法非常适用，并且计算是正确的。\n\n结论：**正确**。该选项正确地识别了问题，为该上下文提出了最标准、最合适的启发式算法，并将其正确地应用于给定的数据。\n\n**C. 将选择问题建模为 $0$-$1$ 背包问题，但使用仅考虑收益的贪心启发式算法，按 $b_i$ 降序排序并选择项目直至达到预算上限，在排序时忽略 $w_i$。对于该实例，排序为 $f_2, f_1, f_5, f_3, f_4$。该启发式算法选择 $\\{f_2, f_1\\}$，总收益为 $19$，总权重为 $9$。**\n\n建模是正确的。所提出的启发式算法（按收益贪心）也简单快速（$\\mathcal{O}(N \\log N)$），使其适用于 AOT。然而，在排序时忽略物品权重（$w_i$）对于背包问题来说是一种不太成熟的策略，因为它可能偏爱那些收益高但权重（成本）也很“昂贵”的物品，可能导致对预算的次优使用。\n\n让我们验证计算：\n1.  按 $b_i$ 降序排序：\n    - $f_2$ ($b_2=10$), $f_1$ ($b_1=9$), $f_5$ ($b_5=7$), $f_3$ ($b_3=6$), $f_4$ ($b_4=4$)。顺序是正确的。\n2.  使用预算 $T_{\\max}=10$ 选择项目：\n    - 选择 $f_2$：当前权重 = $5$。剩余预算 = $5$。已选集合：$\\{f_2\\}$。\n    - 选择 $f_1$：权重 $4 \\le 5$。新权重 = $5+4=9$。剩余预算 = $1$。已选集合：$\\{f_2, f_1\\}$。\n    - 考虑 $f_5$：权重 $4 > 1$。无法选择。\n3.  最终选择的集合是 $\\mathcal{S} = \\{f_1, f_2\\}$。\n    - 总权重：$9$。总收益：$19$。\n\n计算是正确的。然而，与选项 B 相比，这种启发式算法的原理性较差。背包问题的核心是收益和权重之间的张力。基于收益-权重比的启发式算法直接解决了这种张力，而仅考虑收益的启发式算法在其主要决策步骤（排序）中忽略了权衡的一方面。虽然两种启发式算法都适用于 AOT，并且在这个特定实例中碰巧得出了相同的结果，但对于一般问题而言，基于比率的启发式算法是更优越、更标准的选择。\n\n结论：**不正确**。尽管对于所提出的（且看似合理的）启发式算法，计算是正确的，但该启发式算法本身对于背包问题的理论基础不如选项 B 中的算法扎实。选项 B 提供了一种更经典、更稳健的方法。\n\n**D. 将选择问题建模为 $0$-$1$ 背包问题，并应用阈值规则：选择所有满足 $b_i \\ge w_i$ 的项目，如果超出预算，则首先丢弃权重最小的项目。对于该实例，所有项目都满足 $b_i \\ge w_i$，所以该规则选择了 $\\{f_2, f_1, f_4\\}$，然后因预算溢出而丢弃 $f_4$，并声称 $\\{f_2, f_1\\}$ 是最终选择，其总收益为 $19$，总权重为 $9$。**\n\n建模是正确的，但所提出的启发式算法复杂且描述不一致。让我们分析所述规则：“选择所有满足 $b_i \\ge w_i$ 的项目，如果超出预算，则首先丢弃权重最小的项目。”\n1.  基于 $b_i \\ge w_i$ 的初始选择：\n    - $f_1: 9 \\ge 4$ (是), $f_2: 10 \\ge 5$ (是), $f_3: 6 \\ge 3$ (是), $f_4: 4 \\ge 2$ (是), $f_5: 7 \\ge 4$ (是)。\n    - 所有 5 个函数都被选中。初始集合为 $\\{f_1, f_2, f_3, f_4, f_5\\}$。\n2.  检查预算：总权重为 $4+5+3+2+4=18$。这超过了预算 $T_{\\max}=10$。\n3.  丢弃项目：规则说“首先丢弃权重最小的项目”。\n    - 权重为 $w_4=2$, $w_3=3$, $w_1=4$, $w_5=4$, $w_2=5$。\n    - 丢弃 $f_4$ (权重 2)。新权重为 $18-2=16$。仍然 $>10$。\n    - 丢弃 $f_3$ (权重 3)。新权重为 $16-3=13$。仍然 $>10$。\n    - 丢弃 $f_1$ (权重 4，假设通过索引打破与 $f_5$ 的平局)。新权重为 $13-4=9$。这 $\\le 10$。\n    - 最终集合将是 $\\{f_2, f_5\\}$，权重为 $5+4=9$，收益为 $10+7=17$。\n该选项对其自身过程的描述是“该规则选择 $\\{f_2, f_1, f_4\\}$”。这与所陈述的规则所暗示的不符。所陈述的规则暗示首先选择所有符合条件的物品，然后再丢弃。此外，它声称“从这个集合中丢弃 $f_4$……声称 $\\{f_2, f_1\\}$ 是最终选择”。这是一个临时的过程描述，而不是一个一致规则的应用。其逻辑自相矛盾且定义不明确。\n\n结论：**不正确**。该提议在逻辑上存在缺陷，因为对启发式算法应用的描述与启发式算法本身的定义不匹配。该规则的设计也很糟糕（丢弃权重最小的物品来减轻总权重是一种奇怪的策略）。\n\n### 结论\n选项 B 提出了最合适的解决方案。它正确地构建了问题模型，提出了标准且最有效的贪心启发式算法（价值密度），该算法非常适合 AOT 编译器上下文，并正确地将此启发式算法应用于给定的实例。", "answer": "$$\\boxed{B}$$", "id": "3620650"}]}