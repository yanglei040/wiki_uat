{"hands_on_practices": [{"introduction": "SIMD指令的性能很大程度上取决于高效的数据加载和存储，而内存对齐是其中的关键。本练习将引导你解决一个核心的性能瓶颈：由基地址未对齐导致的向量访存惩罚。你将通过量化分析，亲手设计一种循环剥离（loop peeling）策略来动态地对齐主循环体，从而深刻理解编译器在生成高性能SIMD代码时所做的权衡。", "problem": "一个编译器按如下方式对更新单精度值连续数组的循环进行向量化：对于从 $0$ 到 $N-1$ 的索引 $i$，它执行 $x[i] \\leftarrow x[i] + c$，其中 $x$ 是一个元素大小为 $E$ 字节的数组，$c$ 是一个标量常量。该机器支持宽度为 $W$ 个元素的单指令多数据 (SIMD) 向量，自然对齐为 $A$ 字节。$x$ 的基地址 $p$ 满足 $p \\bmod A = 8$ 字节。假设 $E = 4$ 字节（单精度），$W = 8$，$A = 32$ 字节，因此 $W \\cdot E = A$。元素总数为 $N = 1022$。\n\n使用以下成本模型，该模型受吞吐量限制，且迭代之间成本相加，没有重叠：\n- 处理一个元素的标量迭代成本为 $c_s = 3$ 个周期。\n- 处理 $W$ 个元素的对齐 SIMD 向量迭代成本为 $c_a = 2$ 个周期。\n- 一个未对齐的 SIMD 向量迭代（由于整个循环中持续的基地址未对齐）每次向量迭代会产生 $d = 5$ 个周期的额外开销，因此其成本为 $c_a + d$。\n\n从内存对齐和同余的定义出发，确定所需的最小非负标量剥离迭代次数 $k$，使得在剥离 $k$ 次标量迭代后，SIMD 主体在与 $A$ 对齐的地址上操作。然后，提出由 $k$ 次迭代的标量序言、一个对齐的 SIMD 主体和一个处理剩余部分的标量结尾组成的循环结构。与不进行剥离并因此所有向量迭代都未对齐执行的朴素 SIMD 向量化相比，量化通过执行此循环剥离所节省的总周期数。将最终结果表示为节省的周期数的单个整数。在最终的方框答案中不要包含任何单位。", "solution": "用户希望我解决一个关于 SIMD 向量化和内存对齐的编译器优化问题。我将首先验证问题陈述。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 循环操作是对于从 $0$到 $N-1$ 的索引 $i$，执行 $x[i] \\leftarrow x[i] + c$。\n- 元素总数：$N = 1022$。\n- 每个元素的大小：$E = 4$ 字节。\n- SIMD 向量宽度：$W = 8$ 个元素。\n- 自然对齐要求：$A = 32$ 字节。\n- 数组 $x$ 的基地址 $p$ 具有属性 $p \\bmod A = 8$ 字节。\n- 题目说明 $W \\cdot E = A$，即 $8 \\cdot 4 = 32$，与给定值一致。\n- 单次标量迭代的成本：$c_s = 3$ 个周期。\n- 单次对齐 SIMD 向量迭代的成本：$c_a = 2$ 个周期。\n- 单次未对齐 SIMD 向量迭代的成本惩罚：$d = 5$ 个周期。\n- 单次未对齐 SIMD 向量迭代的成本是 $c_a + d$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学性：** 该问题描述了计算机体系结构和编译器优化中的一个经典场景，特别是考虑了内存对齐的循环向量化。成本模型虽然简化，但反映了标量处理和向量处理之间的实际性能权衡，以及未对齐内存访问的惩罚。其原理是合理的。\n- **适定性：** 所有必要的常量（$N$、$E$、$W$、$A$、$c_s$、$c_a$、$d$）和初始条件（$p \\bmod A = 8$）都已提供。所提出的问题——找出剥离迭代的次数、描述最终的循环结构并量化性能增益——是具体的，并能导出一个唯一的、有意义的解。\n- **客观性：** 问题以精确、量化的术语陈述。成本模型被明确定义，没有主观解释的余地。\n\n**步骤 3：结论和行动**\n问题是有效的。它具有科学性、适定性和客观性。我将继续进行求解。\n\n### 解题过程\n\n解决方案主要包括三个部分：\n1.  确定为对齐主向量循环的起始地址所需的标量剥离迭代次数 $k$。\n2.  计算朴素的、未对齐的向量化策略的总执行时间。\n3.  计算使用循环剥离的优化策略的总执行时间，然后通过求差来量化节省的周期数。\n\n**1. 确定剥离迭代的次数 ($k$)**\n\n数组 $x$ 的第 $i$ 个元素的地址由 $p + i \\cdot E$ 给出，其中 $p$ 是基地址。为了让 SIMD 向量循环在对齐的数据上操作，其起始地址必须是对齐大小 $A$ 的倍数。如果我们剥离 $k$ 次标量迭代，向量循环将从索引 $k$ 开始处理。该元素的地址是 $p + k \\cdot E$。因此，对齐条件为：\n$$(p + k \\cdot E) \\bmod A = 0$$\n我们已知以下值：$p \\bmod A = 8$，$E = 4$，$A = 32$。将这些值代入同余关系：\n$$((p \\bmod A) + (k \\cdot E) \\bmod A) \\bmod A = 0$$\n$$ (8 + 4k) \\bmod 32 = 0 $$\n这个方程意味着 $8 + 4k$ 必须是 $32$ 的倍数。我们可以将其写成一个整数方程：\n$$8 + 4k = 32j$$\n其中 $j$ 是一个正整数。我们寻求满足此条件的最小非负整数 $k$。\n$$4k = 32j - 8$$\n$$k = 8j - 2$$\n为了找到最小的非负 $k$，我们从 $j=1$ 开始测试整数值：\n- 当 $j=1$ 时：$k = 8(1) - 2 = 6$。\n这是 $k$ 的最小非负整数值。\n因此，必须从循环的开头剥离 $k=6$ 次标量迭代。\n\n建议的循环结构如下：\n- **标量序言：** 一个从 $i=0$ 到 $k-1=5$ 迭代的循环，执行操作 $x[i] \\leftarrow x[i] + c$。\n- **对齐的 SIMD 主体：** 一个从索引 $i=k=6$ 开始的向量化循环。每次迭代处理 $W=8$ 个元素。此循环及后续结尾部分要处理的元素数量为 $N - k = 1022 - 6 = 1016$。向量迭代的次数为 $\\lfloor \\frac{1016}{8} \\rfloor = 127$。此循环覆盖的索引范围是从 $6$ 到 $6 + (127 \\cdot 8) - 1 = 1021$。\n- **标量结尾：** 一个处理剩余元素的循环。剩余元素的数量为 $(N - k) \\bmod W = 1016 \\bmod 8 = 0$。因此，不需要标量结尾。\n\n**2. 计算朴素（未对齐）向量化的成本**\n\n在朴素向量化策略中，编译器会生成一个从索引 $0$ 开始的 SIMD 循环，而不进行剥离。由于基地址 $p$ 是未对齐的（$p \\bmod 32 = 8$），所有的向量内存访问都将是未对齐的，因为任何后续向量块（在索引 $j \\cdot W$ 处）的起始地址是 $p + (j \\cdot W) \\cdot E = p + j \\cdot A$，并且 $(p + j \\cdot A) \\bmod A = p \\bmod A = 8 \\neq 0$。\n\n一次未对齐向量迭代的成本为 $c_m = c_a + d = 2 + 5 = 7$ 个周期。\n完整向量迭代的次数为 $N_{\\text{vec, naive}} = \\lfloor \\frac{N}{W} \\rfloor = \\lfloor \\frac{1022}{8} \\rfloor = 127$。\n向量部分的成本为 $T_{\\text{vec, naive}} = N_{\\text{vec, naive}} \\cdot c_m = 127 \\cdot 7 = 889$ 个周期。\n\n必须由标量结尾处理的剩余元素数量为 $N_{\\text{epilogue, naive}} = N \\bmod W = 1022 \\bmod 8 = 6$。\n标量结尾的成本为 $T_{\\text{epilogue, naive}} = N_{\\text{epilogue, naive}} \\cdot c_s = 6 \\cdot 3 = 18$ 个周期。\n\n朴素策略的总成本为 $T_{\\text{naive}} = T_{\\text{vec, naive}} + T_{\\text{epilogue, naive}} = 889 + 18 = 907$ 个周期。\n\n**3. 计算优化（剥离）向量化的成本和节省量**\n\n在优化策略中，我们首先执行一个 $k=6$ 次迭代的标量序言。\n序言的成本为 $T_{\\text{prologue}} = k \\cdot c_s = 6 \\cdot 3 = 18$ 个周期。\n\n序言之后，还剩下 $N' = N - k = 1022 - 6 = 1016$ 个元素。SIMD 循环从索引 $6$ 开始，该处的地址是对齐的。此循环中的所有向量迭代都是对齐的。\n对齐向量迭代的次数为 $N_{\\text{vec, opt}} = \\lfloor \\frac{N'}{W} \\rfloor = \\lfloor \\frac{1016}{8} \\rfloor = 127$。\n向量部分的成本为 $T_{\\text{vec, opt}} = N_{\\text{vec, opt}} \\cdot c_a = 127 \\cdot 2 = 254$ 个周期。\n\n最终标量结尾的元素数量为 $N_{\\text{epilogue, opt}} = N' \\bmod W = 1016 \\bmod 8 = 0$。\n结尾的成本为 $T_{\\text{epilogue, opt}} = 0$ 个周期。\n\n优化策略的总成本为 $T_{\\text{opt}} = T_{\\text{prologue}} + T_{\\text{vec, opt}} + T_{\\text{epilogue, opt}} = 18 + 254 + 0 = 272$ 个周期。\n\n最后，节省的总周期数是朴素成本和优化成本之差：\n$$\\text{Savings} = T_{\\text{naive}} - T_{\\text{opt}} = 907 - 272 = 635$$\n\n与朴素的未对齐向量化相比，循环剥离策略节省了 $635$ 个周期。", "answer": "$$\\boxed{635}$$", "id": "3670086"}, {"introduction": "向量化的威力远不止于简单的逐元素算术运算，它同样能加速复杂的非线性算法。本练习将带领你将一种经典信号处理算法——中值滤波，通过排序网络（sorting networks）的方法进行SIMD改造。你将学习如何将算法分解为固定的比较与交换序列，并将其应用于多个并行数据通道，从而掌握将复杂算法重构为数据并行模式的核心思想。", "problem": "您需要实现一个数据并行的滑动窗口中值滤波器，该滤波器使用单指令多数据（SIMD）向量化技术，并纯粹表示为由等长向量上的比较-交换原语构建的排序网络。目标是计算整数数组上大小为 $3$ 和 $9$ 的窗口的中值，并通过并行通道处理多个窗口。所有算法步骤必须基于公认的编译器向量化设计原则和排序网络理论。\n\n使用的基本原理：\n- 单指令多数据（SIMD）执行模型将单个操作同时应用于多个数据元素。在我们的抽象表述中，这由固定通道宽度 $L$ 的向量和在这些通道上的逐元素操作表示。\n- 两个等长向量上的比较-交换原语被定义为产生其逐元素最小值和最大值的一对逐元素函数。具体而言，对于两个输入向量 $x$ 和 $y$，定义 $x_{\\min} = \\min(x,y)$ 和 $x_{\\max} = \\max(x,y)$，其中 $\\min$ 和 $\\max$ 是按通道方式应用的。比较-交换操作将 $x \\leftarrow x_{\\min}$ 和 $y \\leftarrow x_{\\max}$。这模拟了排序网络中使用的排序比较器，但同时在 $L$ 个通道上执行。\n- 排序网络是比较-交换操作的固定序列，无论输入值如何，它都能对固定数量的输入进行排序。它们可用于获取顺序统计量，例如中值元素。一个直接且经过充分测试的选择是奇偶置换排序网络，它通过 $n$ 轮传递对 $n$ 个元素进行排序：在偶数轮传递中，它比较索引 $(0,1),(2,3),\\dots$，在奇数轮传递中，它比较索引 $(1,2),(3,4),\\dots$。对于 $n=9$，经过 $9$ 轮传递后，输入被排序；中值是索引为 $4$ 的元素（从零开始）。对于 $n=3$，存在一个最小网络，它通过 $3$ 个比较-交换步骤进行排序；排序后，中值是索引为 $1$ 的元素。\n\n实现要求：\n- 表示通道宽度为 $L$（一个固定的正整数）的向量，并实现按通道的 $\\min$ 和 $\\max$ 操作。使用这些来实现一个向量比较-交换操作，该操作将两个输入向量映射到它们的逐元素顺序，其中第一个向量接收最小值，第二个向量接收最大值。\n- 通过在 $3$ 个向量寄存器上组合比较-交换操作，实现一个3元中值排序网络。然后将此网络按通道方式同时应用于 $L$ 个窗口。\n- 使用奇偶置换法在 $9$ 个向量寄存器上实现一个9元中值排序网络。然后将此网络按通道方式同时应用于 $L$ 个窗口。\n- 实现一个步长为 $1$ 且具有有效窗口语义的滑动中值滤波器：对于长度为 $N$ 且窗口大小为 $K$ 的数组，如果 $N \\ge K$，则生成 $N-K+1$ 个输出，否则生成零个输出。所有输入均为整数。本问题不涉及物理单位。\n- 向量化策略：对于从窗口索引 $i$ 开始且通道宽度为 $L$ 的批处理，构建 $K$ 个向量寄存器，使得通道 $\\ell$ 包含窗口 $(i+\\ell)$ 在其第 $t$ 个位置的元素，其中 $t \\in \\{0,1,\\dots,K-1\\}$。在这 $K$ 个向量寄存器上执行排序网络的比较-交换步骤。提取中值向量寄存器并写出前 $m$ 个通道，其中 $m = \\min(L, \\text{剩余窗口数})$。重复此过程，直到处理完所有窗口。当剩余窗口少于 $L$ 个时，通过减少 $m$ 来隐式使用标量回退；不需要单独的标量路径。\n\n测试套件：\n- 案例 1：对数组 [1, 5, 2, 4, 3, 8, 7, 6] 进行3元中值滤波。\n- 案例 2：对数组 [9, 9, 9] 进行3元中值滤波。\n- 案例 3：对数组 [10, 1, 9, 2, 8, 3, 7, 4, 6, 5, 0, 11, 12] 进行9元中值滤波。\n- 案例 4：对数组 [5, 1, 5, 1, 5, 1, 5, 1, 5] 进行9元中值滤波。\n- 案例 5：对数组 [1, 2, 3, 4, 5, 6, 7, 8] （长度小于 $9$）进行9元中值滤波，应产生一个空列表。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的列表形式的结果，结果按测试案例的顺序排列。例如，格式必须严格为 `[ [...], [...], [...], [...], [...] ]` 的形式，不含空格。具体来说，您的输出必须是包含五个子列表的单行，按顺序对应案例 $1$ 到 $5$。\n\n交付成果：\n- 提供一个单一、完整、可运行的程序，实现上述要求，其中固定的通道宽度 $L$ 由您选择并在代码注释中明确记录。程序不得读取任何输入，并且必须以所需格式精确打印一行。", "solution": "该问题要求实现一个数据并行的滑动窗口中值滤波器。解决方案必须基于指定的单指令多数据（SIMD）向量化和排序网络的原则。问题的核心是通过将算法步骤映射到向量操作上，来并发处理整数数组的多个滑动窗口。\n\n基本原理是数据并行，即一个操作同时应用于多个数据元素（或称“通道”）。我们将一个SIMD向量建模为一个固定大小的整数数组。设通道宽度为 $L$。在本实现中，我们选择固定的通道宽度 $L=4$，这代表了SIMD架构的典型宽度（例如，一个持有四个 $32$-bit 整数的 $128$-bit 寄存器）。因此，一个向量 $v$ 是一个元组 $(v_0, v_1, \\dots, v_{L-1})$。\n\n我们排序网络的基本构建块是比较-交换原语。对于两个长度为 $L$ 的输入向量 $v_a$ 和 $v_b$，比较-交换操作会修改它们，使得操作后，$v_a$ 包含逐元素的最小值，而 $v_b$ 包含逐元素的最大值。也就是说，对于每个通道 $i \\in \\{0, 1, \\dots, L-1\\}$，新的值 $v'_{a,i}$ 和 $v'_{b,i}$ 计算如下：\n$$ v'_{a,i} = \\min(v_{a,i}, v_{b,i}) $$\n$$ v'_{b,i} = \\max(v_{a,i}, v_{b,i}) $$\n此操作对所有 $L$ 个通道并行执行，构成一个向量化的比较-交换步骤。\n\n利用这个原语，我们构建排序网络来找到一组数的中值。排序网络是一种“不知情”的排序算法，意味着比较序列是固定的，不依赖于输入数据。这个特性使其非常适合硬件实现，或者在我们的案例中，适合SIMD向量化。\n\n对于大小为 $K=3$ 的窗口，我们使用一个最小排序网络，它通过三次比较-交换操作对三个元素进行排序。给定三个向量寄存器 $r_0, r_1, r_2$，它们分别持有 $L$ 个窗口在位置 $0$、$1$ 和 $2$ 的元素，排序过程如下：\n1. 比较-交换($r_0, r_1$)\n2. 比较-交换($r_1, r_2$)\n3. 比较-交换($r_0, r_1$)\n经过这三个步骤后，向量寄存器 $r_1$ 将在每个通道中包含三个相应输入值的中值。\n\n对于大小为 $K=9$ 的窗口，需要一个更复杂的网络。问题指定使用奇偶置换排序网络。该网络在 $n$ 轮传递中对 $n$ 个元素进行排序。在我们的案例中，$n=9$。我们使用 $9$ 个向量寄存器 $r_0, r_1, \\dots, r_8$。算法从 $p=0$ 迭代到 $n-1 = 8$：\n- **偶数轮传递（$p$ 为偶数）：** 对所有偶数索引 $i \\in \\{0, 2, 4, 6\\}$ 的寄存器对 $(r_i, r_{i+1})$ 执行比较-交换。\n- **奇数轮传递（$p$ 为奇数）：** 对所有奇数索引 $i \\in \\{1, 3, 5, 7\\}$ 的寄存器对 $(r_i, r_{i+1})$ 执行比较-交换。\n经过 $9$ 轮这样的传递后，这 $9$ 个寄存器按通道方式排序。$9$ 个元素的中值是第5个元素（索引为 $4$），因此向量寄存器 $r_4$ 将包含 $L$ 个窗口各自的中值。\n\n滑动窗口滤波器是通过分批处理输入数组来实现的。对于长度为 $N$ 的输入数组 `data` 和窗口大小 $K$，总共有 $N-K+1$ 个中值需要计算。我们遍历这些窗口，每次处理最多 $L$ 个窗口。\n在每个批次中，从窗口索引 $i$ 开始，我们首先将数据加载到 $K$ 个向量寄存器中。这是一个“收集”（gather）操作。对于每个寄存器 $t \\in \\{0, \\dots, K-1\\}$ 和每个活动通道 $\\ell \\in \\{0, \\dots, L-1\\}$，我们加载值：\n$$ r_{t, \\ell} = \\text{data}[i + \\ell + t] $$\n这将数据组织成数组结构（Structure-of-Arrays, SoA）布局，其中每个寄存器都持有来自 $L$ 个不同窗口的相同索引位置的元素。\n加载后，将排序网络（`median-of-3` 或 `median-of-9`）应用于这 $K$ 个寄存器。最后，从中值寄存器（例如，$K=3$ 时的 $r_1$，$K=9$ 时的 $r_4$）中提取中值，并将其写入输出数组。这是一个“散布”（scatter）操作。\n为了处理剩余窗口数小于 $L$ 的情况，活动通道数 $m$ 计算为 $m = \\min(L, \\text{remaining\\_windows})$。这确保算法不会访问数组边界之外的数据，并正确处理最后几个窗口。当 $m=1$ 时，这种方法会平滑地退化为类似标量的处理，而无需单独的代码路径。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3670096"}, {"introduction": "编译器优化必须严格遵守“as-if”规则，即任何变换都不能改变程序的可观察行为，但SIMD的并行与推测执行特性有时会挑战这一原则。本练习聚焦于一个包含潜在除零异常的循环，让你亲手构建一个检测器来揭示天真的向量化如何破坏程序的原始语义。通过实现并评估两种不同的安全保护措施，你将深刻理解在追求极致性能的同时，保证程序正确性的重要性与具体方法。", "problem": "你需要设计并实现一个完整且可运行的程序，用于检测称为单指令多数据（SIMD）向量化的编译器转换，在何种情况下会改变一个可能因除零而引发异常的循环的可观察行为。核心场景是一个循环，为从 $0$ 到 $n-1$ 的索引 $i$ 计算 $c[i] = a[i] / b[i]$，其中 $b[i]$ 可能为 $0$，因此当循环被向量化时，可能会改变异常发生的方式以及 $c[i]$ 元素被写入的方式。\n\n基本前提：在顺序执行模型中，程序按程序顺序（从左到右遍历循环索引）执行操作。可观察行为包括哪些迭代执行了内存写入，以及是否出现了异常情况（如除零）。编译器受限于 `as-if` 规则和源语言的顺序语义，其所做的转换必须保持可观察行为不变。然而，SIMD 向量化中的推测性执行和乱序执行可能会导致在顺序短路语义下不会执行的操作被执行，从而写入额外的元素，并改变异常表面上发生的索引。这些事实已被广泛接受，并作为本任务的基础出发点。\n\n使用以下要求设计一个检测器和防护措施：\n\n1. 为循环定义一个顺序标量语义：从 $0$ 到 $n-1$ 迭代 $i$，计算 $a[i]/b[i]$ 并赋值给 $c[i]$，直到遇到第一个满足 $b[s] = 0$ 的索引 $s$ 为止。此时循环停止，不写入 $c[s]$ 或任何 $j \\ge s$ 的 $c[j]$。为实现该检测器，将任何满足 $b[i] = 0$ 的值（包括 $-0$）都视作零。\n\n2. 定义一个具有固定向量宽度 $w$ 的朴素 SIMD 向量化语义模型：以宽度为 $w$ 的块处理索引，为块通道 $j$（其中 $i+j  n$）执行所有除法 $a[i+j]/b[i+j]$，并将所有结果写入 $c[i+j]$，即使某些 $b[i+j] = 0$。这模拟了跨通道的推测性执行，并且它不会在遇到第一个零时短路。\n\n3. 定义两种防护措施以保持与标量语义完全相同的可观察行为：\n   - 防护 $G_1$ （预扫描与回退）：预扫描整个 $b[i]$ 数组以检查是否有任何 $b[i] = 0$。如果发现任何零，则完全跳过向量化并执行标量循环；否则，使用朴素 SIMD 向量化语义。这是一个保守的选择，确保在存在零时行为完全一致，并且仅在安全时才进行完全向量化。\n   - 防护 $G_2$ （掩码前缀）：通过预扫描计算第一个零的索引 $s$。仅对索引 $i  s$ 执行向量化计算；不为任何 $i \\ge s$ 写入 $c[i]$。这模拟了一种向量化掩码执行，它遵循短路行为，并避免在第一个异常索引及其之后进行推测性写入。\n\n4. 实现一个检测器，该检测器比较朴素 SIMD 向量化语义产生的结果与标量语义产生的结果，并报告行为是否发生改变。为使比较明确，将所有 $c[i]$ 初始化为非数值（not-a-number），并将任何保持为非数值的 $c[i]$ 视为“未写入”。如果在向量化语义和标量语义之间，任何索引 $k$ 的写入状态或值存在差异，则检测到行为改变。所有计算均使用双精度浮点算术。如果在向量化语义下任何除法生成了 $\\infty$ 或非数值，出于检测目的，将其视为一次有效的写入。\n\n5. 对于每种防护措施（$G_1$ 和 $G_2$），实现其相应的语义，并报告该防护措施是否保持了与标量语义完全一致的行为。\n\n6. 你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是一个针对测试用例的三整数列表 $[x_1, x_2, x_3]$，其中 $x_1$ 表示朴素 SIMD 向量化语义是否改变了相对于标量语义的行为，$x_2$ 表示防护 $G_1$ 是否保持了行为，$x_3$ 表示防护 $G_2$ 是否保持了行为。使用 $0$ 表示“无改变”或“已保持”，使用 $1$ 表示“已改变”或“未保持”。\n\n不涉及物理单位。不适用角度。不适用百分比。\n\n测试套件与覆盖范围：\n\n所有测试用例均使用固定的向量宽度 $w = 4$。每个测试的循环长度 $n$ 以及数组 $a$ 和 $b$ 规定如下。所有值均为双精度字面量。\n\n- 测试用例 1（正常路径，无零值）：\n  - $n = 6$\n  - $a = [1, 2, 3, 4, 5, 6]$\n  - $b = [1, 1, 1, 1, 1, 1]$\n\n- 测试用例 2（多个零，零值在前）：\n  - $n = 6$\n  - $a = [10, 20, 30, 40, 50, 60]$\n  - $b = [2, 0, 5, 10, 0, 3]$\n\n- 测试用例 3（零在首个索引）：\n  - $n = 4$\n  - $a = [7, 8, 9, 10]$\n  - $b = [0, 2, 3, 4]$\n\n- 测试用例 4（零在末尾索引）：\n  - $n = 4$\n  - $a = [8, 16, 24, 32]$\n  - $b = [2, 2, 2, 0]$\n\n- 测试用例 5（带符号的零）：\n  - $n = 4$\n  - $a = [1.0, -2.0, 3.5, -4.5]$\n  - $b = [1.0, -0.0, 2.0, 2.0]$\n\n- 测试用例 6（零值跨越向量块边界）：\n  - $n = 9$\n  - $a = [1, 2, 3, 4, 5, 6, 7, 8, 9]$\n  - $b = [1, 1, 1, 1, 1, 0, 1, 1, 1]$\n\n最终输出格式规范：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个包含三个整数的方括号列表 $[x_1,x_2,x_3]$。例如，一个包含两个测试用例的有效输出应如 $[[0,0,0],[1,0,0]]$。你的程序必须以这种格式精确地生成一行输出，并且不得读取任何输入。", "solution": "该问题要求设计并实现一个程序，用以分析编译器的 SIMD（单指令多数据）向量化会如何改变一个循环的可观察行为，特别是在存在除零异常的情况下。该分析通过将一个明确定义的顺序（标量）循环的输出与一个朴素向量化循环以及两个带防护措施的向量化循环的输出进行比较来完成。\n\n问题的核心原则是编译器对 `as-if` 规则的遵守。该规则允许任何不改变由语言抽象机所定义的程序可观察行为的转换。在像 C 这样的顺序语言中，程序的执行及其副作用（内存写入、异常）是由程序顺序定义的。像 `for (i=0; i", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3670137"}]}