{"hands_on_practices": [{"introduction": "寄存器分配的核心在于将变量的生命周期冲突转化为图论问题。这个练习将带你从最基本的层面入手，通过分析一小段直线型三地址码，亲手计算变量的活跃范围，并构建出它们之间的冲突图。通过这个过程，你将掌握将代码抽象为图模型的关键第一步，并确定解决该问题所需的最小寄存器数量 [@problem_id:3675472]。", "problem": "考虑以下直线型三地址码（TAC），其中三地址码（TAC）是一种表示形式，每条指令最多有三个操作数，并赋值给一个目标：\n\n指令 $\\;1$: $x := a + b$; 指令 $\\;2$: $y := x + c$; 指令 $\\;3$: $z := y + d$\n\n假设存在以下上下文和约定：\n- 变量 $a$、$b$、$c$ 和 $d$ 在基本块的入口处是活跃的（live-in），并且在块内使用之前未被定义。\n- 在指令 $\\;3$ 之后，紧随该块有一个单次使用点，$z$ 作为该块的结果被消耗，使得 $z$ 在块末尾是活跃于出口的（live-out）。\n- 变量的活跃性是根据标准的数据流意义定义的：如果一个变量的当前值可能在从某程序点开始的某条路径上被读取，则该变量在该程序点是活跃的。\n- 变量的活跃范围是程序点的集合，该集合从变量成为入口活跃（live-in）或被定义开始，一直持续到其最后一次可能影响可观察结果的使用。\n- 如果两个变量的活跃范围在任何程序点上重叠，则它们相互冲突；冲突图在相互冲突的变量之间有一条边。\n- 通过图着色进行寄存器分配，为变量分配颜色（寄存器），使得相邻顶点不共享同一颜色。最少寄存器数量是允许对冲突图进行有效着色的最小颜色数。\n\n任务：\n- 使用上述 TAC 和假设，计算所有变量 $a$、$b$、$c$、$d$、$x$、$y$ 和 $z$ 的活跃范围，以指令之间的边界为索引：指令 $\\;1$ 之前，指令 $\\;1$ 和指令 $\\;2$ 之间，指令 $\\;2$ 和指令 $\\;3$ 之间，以及指令 $\\;3$ 之后但在 $z$ 的最终使用之前。\n- 沿此线性顺序绘制相应的活跃区间，并通过连接活跃区间重叠的变量对来构建冲突图。\n- 为冲突图选择一个有效的着色方案，并确定所需的最少颜色数。\n\n请提供所需的最少寄存器数量作为最终答案。答案必须是一个没有单位的整数。不需要四舍五入。", "solution": "问题陈述经评估为**有效**。它内容完整，科学上基于编译器理论的原理，且提法明确。三地址码（TAC）、变量活跃性、活跃范围、冲突图和图着色的定义都是标准且无歧义的。所提供的代码和假设是一致的，足以推导出一个唯一的解。\n\n求解过程分为四个步骤：\n1.  执行活跃性分析，以确定每个程序点的活跃变量集合。\n2.  定义每个变量的活跃范围（或活跃区间）。\n3.  基于重叠的活跃范围构建冲突图。\n4.  确定冲突图的色数，该色数对应于所需的最少寄存器数量。\n\n设程序点定义在指令的边界处：\n-   $P_0$：指令 $1$ 之前的点。\n-   $P_1$：指令 $1$ 和指令 $2$ 之间的点。\n-   $P_2$：指令 $2$ 和指令 $3$ 之间的点。\n-   $P_3$：指令 $3$ 之后，但在 $z$ 的最终使用之前的点。\n\n活跃性分析从基本块的末尾向后进行。指令 $i$ 的入口活跃集合（live-in set）$\\text{Live}_{\\text{in}}(i)$ 是根据其出口活跃集合（live-out set）$\\text{Live}_{\\text{out}}(i)$，使用标准数据流方程计算得出的：\n$$ \\text{Live}_{\\text{in}}(i) = (\\text{Live}_{\\text{out}}(i) \\setminus \\text{def}(i)) \\cup \\text{use}(i) $$\n其中 $\\text{def}(i)$ 是由指令 $i$ 定义的变量集合，$\\text{use}(i)$ 是由指令 $i$ 使用的变量集合。一条指令的出口活跃集合是其后继指令的入口活跃集合。\n\n**步骤 1：活跃性分析**\n\n-   **在点 $P_3$（指令 $3$ 之后）：**\n    问题陈述指出 $z$ 在块的出口是活跃的。因此，此点的活跃变量集合是 $\\{z\\}$。这也是指令 $3$ 的出口活跃集合。\n    $$ \\text{Live}_{\\text{out}}(\\text{Inst } 3) = \\{z\\} $$\n\n-   **对于指令 $3: z := y + d$**：\n    -   $\\text{def}(\\text{Inst } 3) = \\{z\\}$\n    -   $\\text{use}(\\text{Inst } 3) = \\{y, d\\}$\n    -   $\\text{Live}_{\\text{in}}(\\text{Inst } 3) = (\\text{Live}_{\\text{out}}(\\text{Inst } 3) \\setminus \\{z\\}) \\cup \\{y, d\\} = (\\{z\\} \\setminus \\{z\\}) \\cup \\{y, d\\} = \\{y, d\\}$。\n    -   点 $P_2$ 的活跃变量集合是 $\\{y, d\\}$。这也是 $\\text{Live}_{\\text{out}}(\\text{Inst } 2)$。\n\n-   **对于指令 $2: y := x + c$**：\n    -   $\\text{Live}_{\\text{out}}(\\text{Inst } 2) = \\text{Live}_{\\text{in}}(\\text{Inst } 3) = \\{y, d\\}$\n    -   $\\text{def}(\\text{Inst } 2) = \\{y\\}$\n    -   $\\text{use}(\\text{Inst } 2) = \\{x, c\\}$\n    -   $\\text{Live}_{\\text{in}}(\\text{Inst } 2) = (\\text{Live}_{\\text{out}}(\\text{Inst } 2) \\setminus \\{y\\}) \\cup \\{x, c\\} = (\\{y, d\\} \\setminus \\{y\\}) \\cup \\{x, c\\} = \\{d, x, c\\}$。\n    -   点 $P_1$ 的活跃变量集合是 $\\{c, d, x\\}$。这也是 $\\text{Live}_{\\text{out}}(\\text{Inst } 1)$。\n\n-   **对于指令 $1: x := a + b$**：\n    -   $\\text{Live}_{\\text{out}}(\\text{Inst } 1) = \\text{Live}_{\\text{in}}(\\text{Inst } 2) = \\{c, d, x\\}$\n    -   $\\text{def}(\\text{Inst } 1) = \\{x\\}$\n    -   $\\text{use}(\\text{Inst } 1) = \\{a, b\\}$\n    -   $\\text{Live}_{\\text{in}}(\\text{Inst } 1) = (\\text{Live}_{\\text{out}}(\\text{Inst } 1) \\setminus \\{x\\}) \\cup \\{a, b\\} = (\\{c, d, x\\} \\setminus \\{x\\}) \\cup \\{a, b\\} = \\{a, b, c, d\\}$。\n    -   点 $P_0$ 的活跃变量集合是 $\\{a, b, c, d\\}$。这证实了问题陈述中 $a$、$b$、$c$ 和 $d$ 在块的入口处是活跃的。\n\n每个程序点的活跃变量总结：\n-   在 $P_0$：$\\{a, b, c, d\\}$\n-   在 $P_1$：$\\{c, d, x\\}$\n-   在 $P_2$：$\\{d, y\\}$\n-   在 $P_3$：$\\{z\\}$\n\n**步骤 2：活跃范围**\n\n一个变量的活跃范围是其保持活跃状态的程序点集合。\n-   $a$：从 $P_0$ 开始活跃，直到在指令 $1$ 中被使用。范围：$[P_0, P_1)$。\n-   $b$：从 $P_0$ 开始活跃，直到在指令 $1$ 中被使用。范围：$[P_0, P_1)$。\n-   $x$：由指令 $1$ 定义，从 $P_1$ 开始活跃，直到在指令 $2$ 中被使用。范围：$[P_1, P_2)$。\n-   $c$：从 $P_0$ 开始活跃，直到在指令 $2$ 中被使用。范围：$[P_0, P_2)$。\n-   $y$：由指令 $2$ 定义，从 $P_2$ 开始活跃，直到在指令 $3$ 中被使用。范围：$[P_2, P_3)$。\n-   $d$：从 $P_0$ 开始活跃，直到在指令 $3$ 中被使用。范围：$[P_0, P_3)$。\n-   $z$：由指令 $3$ 定义，从 $P_3$ 开始活跃，直到在块之后被使用。范围：$[P_3, \\text{end})$。\n\n**步骤 3：构建冲突图**\n\n如果两个变量的活跃范围重叠，它们就相互冲突。我们列出在任何程序点同时活跃的所有变量对。\n-   在点 $P_0$，活跃变量集合是 $\\{a, b, c, d\\}$。这些变量中的所有对都相互冲突。这构成了一个大小为 $4$ 的团（记为 $K_4$）。边包括：$(a,b), (a,c), (a,d), (b,c), (b,d), (c,d)$。\n-   在点 $P_1$，活跃变量集合是 $\\{c, d, x\\}$。这些变量中的所有对都相互冲突。边包括：$(c,d), (c,x), (d,x)$。\n-   在点 $P_2$，活跃变量集合是 $\\{d, y\\}$。这两个变量相互冲突。边为：$(d,y)$。\n-   在点 $P_3$，活跃变量集合是 $\\{z\\}$。没有涉及 $z$ 的冲突。\n\n冲突图 $G$ 中的完整边集是在所有点上发现的冲突的并集。该图的邻接表如下：\n-   $a$：$\\{b, c, d\\}$\n-   $b$：$\\{a, c, d\\}$\n-   $c$：$\\{a, b, d, x\\}$\n-   $d$：$\\{a, b, c, x, y\\}$\n-   $x$：$\\{c, d\\}$\n-   $y$：$\\{d\\}$\n-   $z$：$\\emptyset$\n\n**步骤 4：最少寄存器数量（色数）**\n\n所需的最少寄存器数量是冲突图 $G$ 的色数 $\\chi(G)$。\n色数必须至少与图中最大团的大小 $\\omega(G)$ 相等。通过对点 $P_0$ 的分析，我们识别出一个由顶点 $\\{a, b, c, d\\}$ 组成的大小为 $4$ 的团。因此，$\\omega(G) \\ge 4$，这意味着 $\\chi(G) \\ge 4$。所以，至少需要 $4$ 个寄存器。\n\n我们现在通过尝试对图进行 4-着色来检查 $4$ 个寄存器是否足够。设颜色为 $C_1, C_2, C_3, C_4$。\n1.  用不同的颜色为 $K_4$ 团 $\\{a, b, c, d\\}$ 的顶点着色：\n    -   color($a$) := $C_1$\n    -   color($b$) := $C_2$\n    -   color($c$) := $C_3$\n    -   color($d$) := $C_4$\n2.  为其余顶点（$x$, $y$, $z$）着色。\n    -   顶点 $x$ 与 $c$（颜色 $C_3$）和 $d$（颜色 $C_4$）相邻。我们可以为其分配除 $C_3$ 或 $C_4$ 之外的任何颜色。我们选择 $C_1$。color($x$) := $C_1$。这是有效的，因为 $x$ 不与 $a$ 相邻。\n    -   顶点 $y$ 仅与 $d$（颜色 $C_4$）相邻。我们可以为其分配除 $C_4$ 之外的任何颜色。我们选择 $C_1$。color($y$) := $C_1$。这是有效的。\n    -   顶点 $z$ 没有邻居。我们可以为其分配任何颜色。我们选择 $C_1$。color($z$) := $C_1$。\n\n一个有效的 4-着色方案是：\n-   $a$：$C_1$\n-   $b$：$C_2$\n-   $c$：$C_3$\n-   $d$：$C_4$\n-   $x$：$C_1$\n-   $y$：$C_1$\n-   $z$：$C_1$\n\n由于存在 4-着色方案，所以 $4$ 个寄存器是足够的，即 $\\chi(G) \\le 4$。\n结合两个边界条件 $\\chi(G) \\ge 4$ 和 $\\chi(G) \\le 4$，我们得出结论，色数恰好为 $4$。\n\n因此，所需的最少寄存器数量为 $4$。", "answer": "$$\\boxed{4}$$", "id": "3675472"}, {"introduction": "一个初始的冲突图可能无法用可用的寄存器进行着色，但这并不意味着必须立即进行溢出。通过巧妙地重写代码，我们可以改变变量的活跃范围，从而优化冲突图。这个练习探讨了一种强大的技术——活跃范围分裂，特别是在循环的上下文中，它能如何减少冲突，从而使得原本无法完成的寄存器分配成为可能 [@problem_id:3666880]。", "problem": "考虑对以下具有单条循环回边的直线型三地址循环体，通过图着色进行寄存器分配。冲突图是根据活性构建的：如果两个变量的活跃范围重叠，则它们之间存在一条冲突边。设循环体由标号为 $\\ell_{1}$ 到 $\\ell_{5}$ 的语句给出，随后是在 $\\ell_{6}$ 处到 $\\ell_{1}$ 的循环回边分支或退出到 $\\ell_{7}$，最后在 $\\ell_{7}$ 处返回。变量 $p$、$s$ 和 $r$ 是循环不变量，$t$ 是一个循环携带累加器。代码如下：\n\n- 在 $\\ell_{1}$ 处：$a := p + s$。\n- 在 $\\ell_{2}$ 处：$b := a + r$。\n- 在 $\\ell_{3}$ 处：$u := t + b$。\n- 在 $\\ell_{4}$ 处：$t := u + s$。\n- 在 $\\ell_{5}$ 处：$\\text{if } \\psi \\text{ then goto } \\ell_{1} \\text{ else goto } \\ell_{7}$。\n- 在 $\\ell_{7}$ 处：$\\text{return } t$。\n\n假设使用标准的后向活性数据流方程和冲突图构建规则：对于每个语句 $n$，对于每个定义的变量 $d \\in \\text{def}(n)$，在冲突图中添加 $d$ 与 $L_{\\text{out}}(n)$ 中每个变量之间的边，其中活性满足 $L_{\\text{in}}(n) = \\text{use}(n) \\cup \\big(L_{\\text{out}}(n) \\setminus \\text{def}(n)\\big)$ 且 $L_{\\text{out}}(n) = \\bigcup_{s \\in \\text{succ}(n)} L_{\\text{in}}(s)$。\n\n你在循环回边处分裂 $t$ 的活跃范围，方法是在边 $\\ell_{5} \\to \\ell_{1}$ 上插入一个拷贝操作并重命名传入的使用：引入 $t_{\\text{in}}$，在 $\\ell_{5}$ 和 $\\ell_{1}$ 之间插入带有 $t_{\\text{in}} := t$ 的语句 $\\ell_{B}$，并将 $\\ell_{3}$ 重写为 $u := t_{\\text{in}} + b$。所有其他语句保持不变。\n\n仅使用上述基本定义，确定这次活跃范围分裂从节点 $t$ 上移除了多少条冲突边。将你的最终答案表示为单个整数。你可以假设有 $k=5$ 个可用寄存器；减少的边数应足以在分裂后允许进行 $k$-着色。不需要四舍五入，也不涉及物理单位。报告移除的边数。", "solution": "为了确定从变量 $t$ 对应的节点上移除的冲突边数量，我们必须首先构建活跃范围分裂前后冲突图的相关部分。这需要对两个版本的代码都进行活性分析。\n\n如果两个变量的活跃范围重叠，则它们之间存在冲突边。题目给出了一个特定的图构建规则：对于每个定义了变量 $d$ 的语句 $n$（即 $d \\in \\text{def}(n)$），在 $d$ 和 $L_{\\text{out}}(n)$ 中的每个变量 $v$ 之间添加一条冲突边，其中 $L_{\\text{out}}(n)$ 是在语句 $n$ 处出口活跃的变量集合。\n\n变量的活性由后向数据流方程确定：\n$L_{\\text{in}}(n) = \\text{use}(n) \\cup \\big(L_{\\text{out}}(n) \\setminus \\text{def}(n)\\big)$\n$L_{\\text{out}}(n) = \\bigcup_{s \\in \\text{succ}(n)} L_{\\text{in}}(s)$\n\n变量集为 $\\{p, s, r, a, b, u, t\\}$。变量 $p, s, r$ 是循环不变量，意味着它们在循环外部定义，在循环内部使用。变量 $t$ 是一个循环携带累加器。这意味着 $p, s, r, t$ 必须在进入循环头 $\\ell_1$ 时是活跃的。\n\n### 第 1 部分：分裂前的活性和冲突\n\n首先，我们分析原始代码。控制流图有节点 $\\ell_1, \\ell_2, \\ell_3, \\ell_4, \\ell_5, \\ell_7$，其后继为 $\\text{succ}(\\ell_1)=\\{\\ell_2\\}$, $\\text{succ}(\\ell_2)=\\{\\ell_3\\}$, $\\text{succ}(\\ell_3)=\\{\\ell_4\\}$, $\\text{succ}(\\ell_4)=\\{\\ell_5\\}$ 和 $\\text{succ}(\\ell_5)=\\{\\ell_1, \\ell_7\\}$。\n\n每个语句的 `def` 和 `use` 集合如下：\n- $\\ell_1: a := p + s \\implies \\text{def}(\\ell_1)=\\{a\\}, \\text{use}(\\ell_1)=\\{p, s\\}$\n- $\\ell_2: b := a + r \\implies \\text{def}(\\ell_2)=\\{b\\}, \\text{use}(\\ell_2)=\\{a, r\\}$\n- $\\ell_3: u := t + b \\implies \\text{def}(\\ell_3)=\\{u\\}, \\text{use}(\\ell_3)=\\{t, b\\}$\n- $\\ell_4: t := u + s \\implies \\text{def}(\\ell_4)=\\{t\\}, \\text{use}(\\ell_4)=\\{u, s\\}$\n- $\\ell_5: \\text{if...} \\implies \\text{def}(\\ell_5)=\\emptyset, \\text{use}(\\ell_5)=\\emptyset$\n- $\\ell_7: \\text{return } t \\implies \\text{def}(\\ell_7)=\\emptyset, \\text{use}(\\ell_7)=\\{t\\}$\n\n我们对活性集进行不动点迭代，初始条件是 $L_{\\text{in}}(\\ell_7) = \\{t\\}$。由于循环结构，分析必须迭代进行，直到集合稳定。入口活跃集和出口活跃集的最小不动点解为：\n- $L_{\\text{in}}(\\ell_1) = \\{p, s, r, t\\}$\n- $L_{\\text{out}}(\\ell_1) = L_{\\text{in}}(\\ell_2) = \\{p, s, r, t, a\\}$\n- $L_{\\text{out}}(\\ell_2) = L_{\\text{in}}(\\ell_3) = \\{p, s, r, t, b\\}$\n- $L_{\\text{out}}(\\ell_3) = L_{\\text{in}}(\\ell_4) = \\{p, s, r, u\\}$\n- $L_{\\text{out}(\\ell_4)} = L_{\\text{in}}(\\ell_5) = \\{p, s, r, t\\}$\n- $L_{\\text{out}}(\\ell_5) = L_{\\text{in}}(\\ell_1) \\cup L_{\\text{in}}(\\ell_7) = \\{p,s,r,t\\} \\cup \\{t\\} = \\{p,s,r,t\\}$\n\n现在，我们确定与 $t$ 相关的冲突边：\n1.  在 $\\ell_1$ 处，$a$ 被定义。出口活跃集为 $L_{\\text{out}}(\\ell_1)=\\{p, s, r, t, a\\}$。由于 $t \\in L_{\\text{out}}(\\ell_1)$，创建了冲突边 $(t, a)$。\n2.  在 $\\ell_2$ 处，$b$ 被定义。出口活跃集为 $L_{\\text{out}}(\\ell_2)=\\{p, s, r, t, b\\}$。由于 $t \\in L_{\\text{out}}(\\ell_2)$，创建了冲突边 $(t, b)$。\n3.  在 $\\ell_3$ 处，$u$ 被定义。出口活跃集为 $L_{\\text{out}}(\\ell_3)=\\{p, s, r, u\\}$。由于 $t \\notin L_{\\text{out}}(\\ell_3)$，没有在 $t$ 和 $u$ 之间创建边。在 $\\ell_3$ 处使用的 `t` 的活跃范围在此结束。\n4.  在 $\\ell_4$ 处，$t$ 被定义。出口活跃集为 $L_{\\text{out}}(\\ell_4)=\\{p, s, r, t\\}$。被定义的变量 $t$ 与此集合中的所有其他变量冲突。这会创建边 $(t, p)$, $(t, r)$ 和 $(t, s)$。\n\n总计，在分裂前，有 5 条与 $t$ 相关的冲突边：$(t,a), (t,b), (t,p), (t,r), (t,s)$。\n\n### 第 2 部分：分裂后的活性和冲突\n\n$t$ 的活跃范围被分裂。引入了一个新变量 $t_{\\text{in}}$。代码修改如下：\n- 在回边上插入一个新的基本块 $\\ell_B$，包含语句 $t_{\\text{in}} := t$。控制流图变为 $\\ell_5 \\to \\ell_B \\to \\ell_1$。\n- 语句 $\\ell_3$ 被重写为 $u := t_{\\text{in}} + b$。\n\n现在的变量集为 $\\{p, s, r, a, b, u, t, t_{\\text{in}}\\}$。新的 `def`/`use` 集合如下：\n- $\\text{def}(\\ell_3)=\\{u\\}, \\text{use}(\\ell_3)=\\{t_{\\text{in}}, b\\}$\n- $\\text{def}(\\ell_B)=\\{t_{\\text{in}}\\}, \\text{use}(\\ell_B)=\\{t\\}$\n\n我们对修改后的代码再次进行活性分析。\n- $L_{\\text{in}}(\\ell_1) = \\{t_{\\text{in}}, p, s, r\\}$\n- $L_{\\text{out}}(\\ell_1) = L_{\\text{in}}(\\ell_2) = \\{t_{\\text{in}}, p, s, r, a\\}$\n- $L_{\\text{out}}(\\ell_2) = L_{\\text{in}}(\\ell_3) = \\{t_{\\text{in}}, p, s, r, b\\}$\n- $L_{\\text{out}}(\\ell_3) = L_{\\text{in}}(\\ell_4) = \\{p, s, r, u\\}$\n- $L_{\\text{out}(\\ell_4)} = L_{\\text{in}}(\\ell_5) = \\{t, p, s, r\\}$\n- $L_{\\text{out}}(\\ell_B) = L_{\\text{in}}(\\ell_1) = \\{t_{\\text{in}}, p, s, r\\}$\n- $L_{\\text{in}}(\\ell_B) = \\text{use}(\\ell_B) \\cup (L_{\\text{out}}(\\ell_B) \\setminus \\text{def}(\\ell_B)) = \\{t\\} \\cup (\\{t_{\\text{in}}, p, s, r\\} \\setminus \\{t_{\\text{in}}\\}) = \\{t, p, s, r\\}$\n- $L_{\\text{out}}(\\ell_5) = L_{\\text{in}}(\\ell_B) \\cup L_{\\text{in}}(\\ell_7) = \\{t, p, s, r\\} \\cup \\{t\\} = \\{t, p, s, r\\}$\n\n现在，我们重新检查与原始变量 $t$ 相关的冲突边：\n1.  在 $\\ell_1$ 处，$a$ 被定义。$L_{\\text{out}}(\\ell_1) = \\{t_{\\text{in}}, p, s, r, a\\}$。由于 $t \\notin L_{\\text{out}}(\\ell_1)$，不再创建边 $(t, a)$。（取而代之的是创建了边 $(t_{\\text{in}}, a)$）。\n2.  在 $\\ell_2$ 处，$b$ 被定义。$L_{\\text{out}}(\\ell_2) = \\{t_{\\text{in}}, p, s, r, b\\}$。由于 $t \\notin L_{\\text{out}}(\\ell_2)$，不再创建边 $(t, b)$。（取而代之的是创建了边 $(t_{\\text{in}}, b)$）。\n3.  在 $\\ell_4$ 处，$t$ 被定义。$L_{\\text{out}}(\\ell_4)=\\{t, p, s, r\\}$。这仍然会创建边 $(t, p), (t, r)$ 和 $(t, s)$。\n\n分裂后，与 $t$ 相关的冲突边数量为 3 条：$(t, p), (t, r), (t, s)$。\n\n### 结论\n\n与 $t$ 相关的原始冲突边数量为 5 条。分裂 $t$ 的活跃范围后，冲突边数量为 3 条。边 $(t, a)$ 和 $(t, b)$ 被移除了。\n移除的边数是差值：$5 - 3 = 2$。", "answer": "$$\\boxed{2}$$", "id": "3666880"}, {"introduction": "在实际的编译器中，寄存器分配并非一个孤立的优化，它与消除冗余指令和最小化内存访问成本紧密相关。这个练习将你置于一个真实的权衡场景中：有时，主动“溢出”一个变量到内存，反而能为更重要的优化（如合并多个传送指令）创造条件，最终获得性能上的净收益。通过量化溢出成本 $C_{\\text{spill}}$ 与传送指令成本 $C_{\\text{move}}$，你将学会如何做出基于成本效益的、更高级的分配决策 [@problem_id:3666838]。", "problem": "考虑一个在具有 $k=5$ 个物理寄存器的目标机器上执行 $N$ 次的循环体。其中间表示包含四个临时变量之间的一系列拷贝操作，写成移动指令的形式：\n- $t_{2} \\leftarrow t_{1}$,\n- $t_{3} \\leftarrow t_{2}$,\n- $t_{4} \\leftarrow t_{3}$.\n\n此外，还有五个活跃范围 $p, q, r, s$ 和 $u$，它们在循环内被使用和重定义，因此 $p, q, r, s$ 和 $u$ 中的每一个都在循环体的某一部分是活跃的。活跃性的安排使得，在发生移动指令的三个程序点上，同时活跃的集合是：\n- 在 $t_{2} \\leftarrow t_{1}$ 处：$\\{t_{1},p,q,r,u\\}$，\n- 在 $t_{3} \\leftarrow t_{2}$ 处：$\\{t_{2},p,q,s,u\\}$，\n- 在 $t_{4} \\leftarrow t_{3}$ 处：$\\{t_{3},p,r,s,u\\}$。\n\n循环中没有其他活跃范围。假设循环体内是顺序代码（无分支），并且所有五个活跃范围 $p, q, r, s, u$ 在每次迭代中被使用然后重定义一次，使得它们如前所述在整个循环体中都是活跃的。\n\n使用标准的基于图着色的寄存器分配冲突图模型：如果两个节点（活跃范围）在某个程序点上同时活跃，则它们相互冲突。如果保守合并规则（例如，George 或 Briggs 准则）认为合并对于 $k$-可着色性是安全的，则可以合并与移动指令相关的节点。设执行成本模型为：\n- 每条移动指令的每次动态执行成本为 $C_{\\text{move}}$。\n- 因溢出一个活跃范围而产生的每次内存访问成本为 $C_{\\text{spill}}$。\n\n假设我们考虑两种分配策略：\n- 策略A（不溢出，不合并）：使用 $k=5$ 进行分配，不合并任何 $t_{1}, t_{2}, t_{3}, t_{4}$。这是可能的，因为最大同时活跃数为 $5$。循环每次迭代执行 3 次移动指令，不产生溢出访问。\n- 策略B（将 $u$ 溢出到内存，然后完全合并 $t_{1}, t_{2}, t_{3}, t_{4}$ 为一个节点）：溢出 $u$ 使得对于 $k=5$ 整个链的合并变得保守安全，因此所有三个移动指令都被消除了。因为 $u$ 在每次迭代中被使用和重定义一次，所以溢出操作在每次迭代中正好引入 2 次内存访问（在其使用前一次加载，在其重定义后一次存储）。\n\n仅从活跃性、冲突图和 $k$-着色的保守合并的核心定义出发，解释为什么策略 A 允许用 $k=5$ 进行着色，但不能保守地合并整个链，而策略 B 允许用 $k=5$ 进行着色，并允许合并整个链。然后，使用给定的成本模型，推导在一次循环迭代中 $C_{\\text{spill}}$ 与 $C_{\\text{move}}$ 的盈亏平衡比率 $r^{\\ast}$，使得当 $\\frac{C_{\\text{spill}}}{C_{\\text{move}}}  r^{\\ast}$ 时，策略 B 的执行成本严格低于策略 A。给出 $r^{\\ast}$ 的简化解析表达式。不要对你的答案进行四舍五入。", "solution": "该问题要求基于冲突图模型，对给定循环体的两种寄存器分配策略进行分析，并推导一个成本盈亏平衡点。我们首先验证问题的陈述。\n\n### 问题验证\n**步骤1：提取已知条件**\n- 物理寄存器数量：$k=5$。\n- 循环执行次数：$N$ 次。\n- 移动指令：$t_{2} \\leftarrow t_{1}$, $t_{3} \\leftarrow t_{2}$, $t_{4} \\leftarrow t_{3}$。\n- 活跃范围：$p, q, r, s, u$ 及临时变量 $t_1, t_2, t_3, t_4$。\n- 在特定程序点的同时活跃集：\n  - 在 $t_{2} \\leftarrow t_{1}$ 处：$L_1 = \\{t_{1}, p, q, r, u\\}$。\n  - 在 $t_{3} \\leftarrow t_{2}$ 处：$L_2 = \\{t_{2}, p, q, s, u\\}$。\n  - 在 $t_{4} \\leftarrow t_{3}$ 处：$L_3 = \\{t_{3}, p, r, s, u\\}$。\n- 所有其他活跃范围都已考虑在内，冲突仅由这些集合决定。\n- 成本模型：每次移动成本为 $C_{\\text{move}}$，每次因溢出活跃范围而产生的内存访问成本为 $C_{\\text{spill}}$。\n- 策略 A：不溢出，不合并。成本是每次迭代 3 次移动。陈述中说明 $k=5$ 着色是可能的。\n- 策略 B：溢出活跃范围 u。合并链 $t_1, t_2, t_3, t_4$。成本是每次迭代 2 次与溢出相关的内存访问。陈述中说明这是可能的。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在编译器设计的标准理论框架内定义良好，特别是通过图着色进行寄存器分配。活跃性、冲突图、图着色、保守合并（Briggs/George 准则）和溢出的概念都是标准的。已知条件是自洽的，足以构建和分析两种策略的冲突图。问题的前提——策略 A 中着色是可能的，策略 B 中合并是可能的——是需要解释的断言，这是一种有效的教学结构。该问题有科学依据，是客观且良定的。\n\n**步骤3：结论与行动**\n问题是有效的。继续进行解答。\n\n### 分析与解答\n基于图着色的寄存器分配的核心是冲突图 $G=(V, E)$，其中 $V$ 是活跃范围（临时变量）的集合，如果活跃范围 $a$ 和 $b$ 在程序中的任何点上同时活跃，则存在一条边 $(a, b) \\in E$。通过移动指令（如 $t_2 \\leftarrow t_1$ 中的 $t_1$ 和 $t_2$）相关联的两个活跃范围，根据定义不发生冲突，假设 $t_1$ 的活跃性在此指令处结束，而 $t_2$ 的活跃性开始。\n\n如果图中的每个节点都可以被赋予 $k$ 种颜色中的一种，使得没有两个相邻节点具有相同的颜色，则该图是 $k$-可着色的。一个关于 $k$-可着色性的关键启发式方法是：如果一个图可以通过迭代地移除任何度数小于 $k$ 的节点来简化，那么这个图是 $k$-可着色的。\n\n合并两个与移动相关的节点 $u$ 和 $v$（它们不冲突）意味着将它们融合成一个单一节点。保守合并启发式方法确保这种合并不会使一个 $k$-可着色的图变得不可着色。Briggs 准则指出，如果合并后产生的节点 $uv$ 将拥有少于 $k$ 个度数大于或等于 $k$ 的邻居，则可以合并两个节点 $u$ 和 $v$。\n\n**策略A：不溢出，不合并**\n\n首先，我们根据给定的活跃集构建冲突图 $G$。节点集合是 $V = \\{t_1, t_2, t_3, t_4, p, q, r, s, u\\}$。边由任何共存于活跃集 $L_1, L_2, L_3$ 中任意一个的变量对构成。移动链中的临时变量 $t_1, t_2, t_3, t_4$ 具有不相交的活跃范围，因此彼此不冲突。\n\n每个节点的邻居和度数计算如下：\n- $t_1$ 的邻居来自 $L_1$：$\\text{Neigh}(t_1) = \\{p, q, r, u\\}$。$\\text{deg}(t_1) = 4$。\n- $t_2$ 的邻居来自 $L_2$：$\\text{Neigh}(t_2) = \\{p, q, s, u\\}$。$\\text{deg}(t_2) = 4$。\n- $t_3$ 的邻居来自 $L_3$：$\\text{Neigh}(t_3) = \\{p, r, s, u\\}$。$\\text{deg}(t_3) = 4$。\n- 临时变量 $t_4$ 由 $t_4 \\leftarrow t_3$ 定义。由于没有给出包含 $t_4$ 的活跃集，并且冲突仅由给定的集合决定，所以 $t_4$ 没有冲突。$\\text{deg}(t_4) = 0$。\n- $p$ 的邻居是任何包含 $p$ 的集合中其他变量的并集：$\\text{Neigh}(p) = \\{t_1, q, r, u\\} \\cup \\{t_2, q, s, u\\} \\cup \\{t_3, r, s, u\\} = \\{t_1, t_2, t_3, q, r, s, u\\}$。$\\text{deg}(p) = 7$。\n- 类似地，我们找到其他节点的度数：\n  - $\\text{Neigh}(q) = \\{t_1, t_2, p, r, s, u\\}$。$\\text{deg}(q) = 6$。\n  - $\\text{Neigh}(r) = \\{t_1, t_3, p, q, s, u\\}$。$\\text{deg}(r) = 6$。\n  - $\\text{Neigh}(s) = \\{t_2, t_3, p, q, r, u\\}$。$\\text{deg}(s) = 6$。\n  - $\\text{Neigh}(u) = \\{t_1, t_2, t_3, p, q, r, s\\}$。$\\text{deg}(u) = 7$。\n\n该图包含几个 5-团（例如，$L_1$, $L_2$, $L_3$），因此其色数至少为 5。问题正确地指出 5-着色是可能的。这依赖于结构化代码的冲突图的性质，这些图通常是完美图或接近完美图，意味着它们的色数约等于它们的团数。由于最大团的大小为 5，该图是 5-可着色的。\n\n现在，我们解释为什么链 $t_1, t_2, t_3, t_4$ 不能被完全合并。让我们尝试合并由移动指令 $t_2 \\leftarrow t_1$ 相关的 $t_1$ 和 $t_2$。新的合并节点 $T_{12}$ 的邻居将是 $t_1$ 和 $t_2$ 邻居的并集：$\\text{Neigh}(T_{12}) = \\text{Neigh}(t_1) \\cup \\text{Neigh}(t_2) = \\{p, q, r, u\\} \\cup \\{p, q, s, u\\} = \\{p, q, r, s, u\\}$。\n这些邻居在原始图中的度数是 $\\text{deg}(p)=7$, $\\text{deg}(q)=6$, $\\text{deg}(r)=6$, $\\text{deg}(s)=6$, and $\\text{deg}(u)=7$。所有这些度数都 $\\ge k=5$。\n根据 Briggs 准则，$T_{12}$ 的度数 $\\ge k$ 的邻居数量必须小于 $k$。这里，有 5 个这样的邻居。由于 5 并不小于 $k=5$，保守合并条件失败。因此，即使是链中的第一次合并也是不被允许的。所以，整个链不能被合并。\n\n**策略B：溢出 `u`，然后合并**\n\n在这个策略中，活跃范围 $u$ 被溢出到内存。这等同于在着色前从冲突图中移除节点 $u$ 及其所有关联边。设新图为 $G'$。\n\n$G'$ 中的节点和度数（$k=5$）是：\n- $\\text{deg}'(t_1) = |\\{p, q, r\\}| = 3$。\n- $\\text{deg}'(t_2) = |\\{p, q, s\\}| = 3$。\n- $\\text{deg}'(t_3) = |\\{p, r, s\\}| = 3$。\n- $\\text{deg}'(t_4) = 0$。\n- $\\text{deg}'(p) = |\\{t_1, t_2, t_3, q, r, s\\}| = 6$。\n- $\\text{deg}'(q) = |\\{t_1, t_2, p, r, s\\}| = 5$。\n- $\\text{deg}'(r) = |\\{t_1, t_3, p, q, s\\}| = 5$。\n- $\\text{deg}'(s) = |\\{t_2, t_3, p, q, r\\}| = 5$。\n\n现在，我们尝试合并链 $t_1, t_2, t_3, t_4$。让我们从 $t_4$ 到 $t_1$ 的顺序进行。\n1.  **合并 $t_3 \\leftarrow t_4$**：合并后的节点 $T_{34}$ 有邻居 $\\text{Neigh}'(t_3) \\cup \\text{Neigh}'(t_4) = \\{p, r, s\\}$。这些邻居在 $G'$ 中的度数是 $\\text{deg}'(p)=6$, $\\text{deg}'(r)=5$, $\\text{deg}'(s)=5$。这三个都是“高度数”（度数 $\\ge k=5$）。高度数邻居的数量是 3。由于 $3  5$，满足 Briggs 准则。合并是安全的。设新图为 $G''$。\n\n2.  **合并 $t_2 \\leftarrow T_{34}$**：此步骤对应于原始的移动指令 $t_3 \\leftarrow t_2$。合并后的新节点 $T_{234}$ 的邻居是 $\\text{Neigh}''(t_2) \\cup \\text{Neigh}''(T_{34}) = \\{p, q, s\\} \\cup \\{p, r, s\\} = \\{p, q, r, s\\}$。这些邻居在 $G'$ 中的度数分别为 $\\text{deg}'(p)=6$, $\\text{deg}'(q)=5$, $\\text{deg}'(r)=5$ 和 $\\text{deg}'(s)=5$。所有 4 个邻居的度数都 $\\ge 5$。因此，高度数邻居的数量是 4。由于 $4  5$，根据 Briggs 准则，这个合并也是安全的。设新图为 $G'''$。\n\n3.  **合并 $t_1 \\leftarrow T_{234}$**：这对应于原始的移动指令 $t_2 \\leftarrow t_1$。最终合并的节点 $T = T_{1234}$ 的邻居是 $\\text{Neigh}'''(t_1) \\cup \\text{Neigh}'''(T_{234}) = \\{p, q, r\\} \\cup \\{p, q, r, s\\} = \\{p, q, r, s\\}$。邻居的数量是 4。即使它们都是高度数节点，由于 $4  5$，合并也是安全的。\n\n由于所有合并都是保守安全的，整个链可以被合并。最终的图由节点 $\\{T, p, q, r, s\\}$ 组成。节点 $T$ 连接到 $p, q, r, s$。在移除 $u$ 之后，节点 $\\{p, q, r, s\\}$ 自身构成一个 4-团 ($K_4$)。因此，最终的图是一个 5-团（$p, q, r, s, T$ 并不一定构成 $K_5$，但图是 5-可着色的）。\n\n**成本分析**\n\n我们被要求计算盈亏平衡比率 $r^{\\ast} = \\frac{C_{\\text{spill}}}{C_{\\text{move}}}$，使得策略 B 的成本严格低于策略 A。\n\n- **策略 A 的成本, $C_A$**：在此策略中，不发生溢出。三个移动指令（$t_2 \\leftarrow t_1, t_3 \\leftarrow t_2, t_4 \\leftarrow t_3$）在 $N$ 次循环迭代的每一次中都被执行。\n  $$ C_A = 3 \\times C_{\\text{move}} \\quad (\\text{每次迭代}) $$\n\n- **策略 B 的成本, $C_B$**：在此策略中，活跃范围 $u$ 被溢出。问题陈述 $u$ 在每次迭代中被使用一次并重定义一次。这需要在每次迭代中进行一次使用前的内存加载和一次重定义后的内存存储，总共两次内存访问。所有三个移动指令都通过合并被消除了。\n  $$ C_B = 2 \\times C_{\\text{spill}} \\quad (\\text{每次迭代}) $$\n\n当 $C_B  C_A$ 时，策略 B 的成本严格低于策略 A。\n$$ 2 \\times C_{\\text{spill}}  3 \\times C_{\\text{move}} $$\n为了找到关于比率 $r = \\frac{C_{\\text{spill}}}{C_{\\text{move}}}$ 的条件，我们将不等式两边除以 $C_{\\text{move}}$（一个正成本）。\n$$ 2 \\left( \\frac{C_{\\text{spill}}}{C_{\\text{move}}} \\right)  3 $$\n$$ 2r  3 $$\n$$ r  \\frac{3}{2} $$\n问题要求的是盈亏平衡比率 $r^{\\ast}$，使得策略 B 更便宜的条件是 $r  r^{\\ast}$。从我们推导出的不等式，这个值是 $r^{\\ast} = \\frac{3}{2}$。", "answer": "$$\\boxed{\\frac{3}{2}}$$", "id": "3666838"}]}