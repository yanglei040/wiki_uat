{"hands_on_practices": [{"introduction": "任何安全的程序变换都必须以精确的数据依赖分析为基础。本练习将带你应用多面体模型中的核心定义，通过分析一个简单的循环来亲手实践读后写（RAW）、写后读（WAR）和写后写（WAW）依赖的识别过程。通过这个练习，你将深入理解为何某些代码重排是非法的，并掌握保障变换正确性的基本原则 [@problem_id:3663286]。", "problem": "考虑一个单层嵌套循环，迭代变量为 $i$，数组 $A$、$B$ 和 $C$ 的长度为 $N$，其中 $N \\geq 5$。循环以 $i$ 严格递增的方式执行，并且数组 $A$、$B$ 和 $C$ 之间没有混叠（aliasing）。循环内的语句是：\n$$S_1: A[i] = A[i-2] + B[i],$$\n$$S_2: A[i-2] = A[i-3] + C[i],$$\n对于所有满足 $3 \\leq i \\leq N-1$ 的整数 $i$。假设在每次迭代中，循环体内部的原始程序顺序是 $S_1$ 在前，$S_2$ 在后。\n\n使用多面体循环优化模型，从迭代域、仿射访问函数、程序顺序调度以及依赖方向向量和距离的核心定义出发进行推理。判断在顺序语义下，将 $S_1$ 重排到 $S_2$ 之后执行（即交换它们，使得每个 $i$ 的循环体变为 $S_2$ 在前，$S_1$ 在后）是否合法，需要考虑写后读（RAW）、读后写（WAR）和写后写（WAW）依赖关系。\n\n你的最终答案必须是一个数字：如果重排是合法的，则返回 $1$；如果重排是非法的，则返回 $0$。无需四舍五入。你的答案不带单位。", "solution": "问题要求我们判断在循环内重排两个语句 $S_1$ 和 $S_2$ 是否是符合顺序语义的合法转换。此分析将使用多面体模型进行，该模型为循环优化推理提供了一个形式化框架。一个转换是合法的，当且仅当它保留了原始程序的所有数据依赖关系。\n\n首先，我们通过定义迭代域、内存访问函数和程序调度来形式化该问题。\n\n循环的迭代变量 $i$ 从 $3$ 到 $N-1$。语句 $S_1$ 和 $S_2$ 都在这个循环中执行。两个语句的迭代域是与循环迭代器值相对应的整数点集。由于这是一个单层嵌套循环，迭代向量就是标量 $i$。\n$S_1$ 和 $S_2$ 的迭代域 $\\mathcal{D}$ 是：\n$$ \\mathcal{D} = \\{i \\in \\mathbb{Z} \\mid 3 \\leq i \\leq N-1 \\} $$\n\n语句如下：\n$S_1: A[i] = A[i-2] + B[i]$\n$S_2: A[i-2] = A[i-3] + C[i]$\n\n每个语句的内存访问可以表示为迭代变量 $i$ 的仿射函数。由于数组 $A$、$B$ 和 $C$ 之间没有混叠，我们只需要分析对数组 $A$ 的依赖关系。\n数组 $A$ 的访问函数是：\n- 对于 $S_1$：\n  - 写访问：$f_{W,A,1}(i) = i$\n  - 读访问：$f_{R,A,1}(i) = i-2$\n- 对于 $S_2$：\n  - 写访问：$f_{W,A,2}(i) = i-2$\n  - 读访问：$f_{R,A,2}(i) = i-3$\n\n原始的程序顺序（或称调度）定义了所有语句实例的执行序列。在原始程序中，每次迭代中 $S_1$ 在 $S_2$ 之前执行。我们可以用向量 $(k, i)$ 来表示语句 $S_k$ 在迭代 $i$ 中的实例的调度。执行顺序是这些向量的字典序。\n- $S_1(i)$ 的调度：$(1, i)$\n- $S_2(i)$ 的调度：$(2, i)$\n对于任何给定的迭代 $i$，$(1, i)$ 在字典序上小于 $(2, i)$，这意味着 $S_1(i)$ 在 $S_2(i)$ 之前执行。对于任何两个迭代 $i$ 和 $j$（其中 $i  j$），迭代 $i$ 中的任何语句实例都在迭代 $j$ 中的任何实例之前执行。\n\n如果语句实例 $S_a(i)$ 在实例 $S_b(j)$ 之前执行，它们都访问相同的内存位置，并且其中至少一个访问是写操作，则存在从 $S_a(i)$ 到 $S_b(j)$ 的数据依赖。重排语句 $S_1$ 和 $S_2$ 只有在不违反任何依赖关系的情况下才是合法的。一个从 $S_1(i)$ 到 $S_2(i)$ 的依赖（循环无关依赖）会被交换操作所违反，因为新的顺序会将依赖的汇点（sink）($S_2(i)$) 置于依赖的源点（source）($S_1(i)$) 之前。因此，当且仅当存在一个从 $S_1$ 到 $S_2$ 的循环无关依赖时，交换才是非法的。\n\n我们现在寻找这种循环无关依赖，它发生在同一次迭代内的语句实例之间。我们测试从 $S_1(i)$ 到 $S_2(i)$ 的写后读（RAW）、读后写（WAR）和写后写（WAW）依赖，其中 $i \\in \\mathcal{D}$。\n\n1.  **RAW 依赖 ($S_1(i) \\to_{\\text{RAW}} S_2(i)$)**：在同一次迭代中，$S_1$ 写入一个位置，而 $S_2$ 读取该位置。\n    这要求 $S_1$ 的写访问函数等于 $S_2$ 的读访问函数。\n    $$ f_{W,A,1}(i) = f_{R,A,2}(i) $$\n    $$ i = i - 3 $$\n    $$ 0 = -3 $$\n    这是一个矛盾，因此不存在从 $S_1$ 到 $S_2$ 的循环无关 RAW 依赖。\n\n2.  **WAW 依赖 ($S_1(i) \\to_{\\text{WAW}} S_2(i)$)**：在同一次迭代中，$S_1$ 和 $S_2$ 写入相同的位置。\n    这要求写访问函数相等。\n    $$ f_{W,A,1}(i) = f_{W,A,2}(i) $$\n    $$ i = i - 2 $$\n    $$ 0 = -2 $$\n    这是一个矛盾，因此不存在从 $S_1$ 到 $S_2$ 的循环无关 WAW 依赖。\n\n3.  **WAR 依赖 ($S_1(i) \\to_{\\text{WAR}} S_2(i)$)**：在同一次迭代中，$S_1$ 读取一个位置，而 $S_2$ 写入该位置。\n    这要求 $S_1$ 的读访问函数等于 $S_2$ 的写访问函数。\n    $$ f_{R,A,1}(i) = f_{W,A,2}(i) $$\n    $$ i - 2 = i - 2 $$\n    这个方程对所有 $i$ 的值都成立。因此，对于每个迭代 $i \\in \\mathcal{D}$，都存在一个从 $S_1(i)$ 到 $S_2(i)$ 的关于内存位置 $A[i-2]$ 的 WAR（反）依赖。\n\n这个循环无关的 WAR 依赖 $S_1(i) \\to_{\\text{WAR}} S_2(i)$ 的存在意味着，为了保持程序语义，在同一次迭代 $i$ 中，语句 $S_1$ 对 $A[i-2]$ 的读取必须在语句 $S_2$ 对 $A[i-2]$ 的写入之前发生。原始的程序顺序遵守了这一依赖关系。\n\n如果我们交换这两个语句，循环体内部的新顺序将变为 $S_2$ 在前，$S_1$ 在后。对于任何迭代 $i$，语句 $S_2(i)$ 将在 $S_1(i)$ 之前执行。这将导致对 $A[i-2]$ 的写操作发生在对 $A[i-2]$ 的读操作之前。因此，$S_1(i)$ 将会读取由 $S_2(i)$ 计算出的 $A[i-2]$ 的新值，而不是它本应读取的来自前一次迭代的值。这违反了依赖关系，并改变了程序的计算结果。\n\n为了完整性，我们可以检查其他的（循环携带的）依赖，尽管它们不影响此特定转换的合法性。对于 $i  j$：\n-   $S_1(i) \\to S_2(j)$：\n    -   RAW: $f_{W,A,1}(i) = f_{R,A,2}(j) \\implies i = j-3 \\implies j-i=3$。存在一个距离为 $3$ 的循环携带 RAW 依赖。\n    -   WAW: $f_{W,A,1}(i) = f_{W,A,2}(j) \\implies i = j-2 \\implies j-i=2$。存在一个距离为 $2$ 的循环携带 WAW 依赖。\n    -   WAR: $f_{R,A,1}(i) = f_{W,A,2}(j) \\implies i-2 = j-2 \\implies i=j$。对于 $i  j$ 这是不可能的，所以没有这种循环携带的 WAR 依赖。\n\n这些循环携带的依赖不受循环内语句交换的影响，但关键是循环无关的 WAR 依赖，它明确禁止了这种转换。\n\n因此，重排是非法的。", "answer": "$$\\boxed{0}$$", "id": "3663286"}, {"introduction": "在识别出所有数据依赖后，编译器的下一步是设计一个执行顺序，即调度（schedule），它不仅要尊重这些依赖，还应尽可能地挖掘并行性。本练习探讨了一个多维仿射调度如何作用于一个二维循环，并揭示了并行执行的可能性。通过计算变换后的依赖向量并识别并行维度（parallel bands），你将具体地看到多面体模型是如何将一个看似串行的循环重塑为并行任务的 [@problem_id:3663326]。", "problem": "考虑整数参数 $N$ 和 $M$ 的迭代域 $D=\\{(i,j)\\in\\mathbb{Z}^{2}\\mid 0\\le i  N,\\ 0 \\le j  M\\}$。在该域中执行一个循环嵌套，该循环嵌套具有一个单一的、一致的流依赖，其距离向量为 $d=(\\Delta i, \\Delta j)=(0,1)$。这意味着每次迭代 $(i,j)$ 都依赖于其前一次的迭代 $(i,j-1)$。对该循环应用以下仿射调度变换：\n$$ \\theta(i,j) = (i,\\ j-i) $$\n你的任务是确定此调度的两个属性：\n1.  **合法性 ($L$)**：该调度是否合法？即，对于所有依赖关系，它是否都保留了因果关系？如果调度是合法的，则 $L=1$；否则，$L=0$。如果变换后的依赖向量在字典序上为正，则调度是合法的。\n2.  **并行性 ($P$)**：该调度揭示了多少个外层并行循环维度？这等于最外层并行带中的维度数，即变换后依赖向量中前导零的数量。\n\n你的最终答案必须是包含这两个整数的行矩阵 $\\begin{pmatrix}L  P\\end{pmatrix}$。无需四舍五入。你的答案不带单位。", "solution": "该问题要求我们为一个给定的多面体循环优化场景确定两个值：合法性指示符 $L$ 和并行调度维度的数量 $P$。\n\n首先，我们确定调度 $\\theta$ 的合法性。如果对于从迭代点 $p$到迭代点 $p'$ 的每个依赖，调度都保留了执行顺序，那么该调度就被定义为合法的。这意味着 $p$ 的调度时间必须在字典序上小于 $p'$ 的调度时间。问题将此条件表述为 $\\theta(p) \\prec_{\\text{lex}} \\theta(p')$。设 $p=(i,j)$ 为源迭代， $d=(\\Delta i, \\Delta j)=(0,1)$ 为一致流依赖向量。则目标迭代为 $p' = p+d = (i, j+1)$。\n\n合法性条件可以使用依赖距离向量 $\\delta$ 重新表述，它被定义为目标迭代和源迭代的调度时间之差：\n$$ \\delta = \\theta(p') - \\theta(p) $$\n当且仅当对于所有依赖，该距离向量是字典序为正的，即 $\\delta \\succ_{\\text{lex}} 0$，调度才是合法的。如果一个向量 $v=(v_1, v_2, \\dots, v_n)$ 的第一个非零分量为正，则该向量是字典序为正的。\n\n给定的调度是 $\\theta:\\mathbb{Z}^{2}\\to\\mathbb{Z}^{2}$，定义为 $\\theta(i,j)=(i,\\ j-i)$。让我们计算源迭代和目标迭代的调度时间。\n源迭代是 $p=(i,j)$。其调度时间为：\n$$ \\theta(p) = \\theta(i,j) = (i,\\ j-i) $$\n目标迭代是 $p'=(i, j+1)$。其调度时间为：\n$$ \\theta(p') = \\theta(i, j+1) = (i, (j+1)-i) = (i, j-i+1) $$\n\n现在，我们计算依赖距离向量 $\\delta$：\n$$ \\delta = \\theta(p') - \\theta(p) = (i, j-i+1) - (i, j-i) $$\n$$ \\delta = (i-i, (j-i+1)-(j-i)) $$\n$$ \\delta = (0, 1) $$\n对于这种一致依赖和仿射调度，依赖距离向量是恒定的。我们必须检查 $\\delta = (0,1)$ 是否是字典序为正的。$\\delta$ 的第一个分量是 $0$。然后我们检查第二个分量，它是 $1$。由于 $1 > 0$，向量 $\\delta=(0,1)$ 是字典序为正的。\n$$ (0,1) \\succ_{\\text{lex}} (0,0) $$\n该调度尊重依赖因果关系。因此，该调度是合法的。合法性指示符 $L$ 为 $1$。\n$$ L=1 $$\n\n接下来，我们确定并行调度维度的数量 $P$。问题将调度维度 $k$ 定义为并行的，如果依赖距离向量的第 $k$ 个分量为 $0$。数量 $P$ 是构成最外层并行带的此类维度的计数。这对应于依赖距离向量中前导零的数量。\n\n我们计算出的依赖距离向量是 $\\delta = (\\delta_1, \\delta_2) = (0,1)$。让我们检查它的分量：\n1.  第一个分量是 $\\delta_1 = 0$。根据定义，第一个调度维度是并行的。这意味着对于给定的依赖，所有相关的操作都被映射到变换后迭代空间的第一个维度中的相同坐标。\n2.  第二个分量是 $\\delta_2 = 1$。由于这是非零的，第二个调度维度不是并行的；它是顺序的。这个维度携带依赖，确保正确性。\n\n向量 $\\delta=(0,1)$ 中前导零的数量是一个。这个单一的并行维度构成了一个外层的并行带。因此，并行调度维度的数量为 $1$。\n$$ P=1 $$\n\n问题要求以行矩阵 $\\begin{pmatrix}L  P\\end{pmatrix}$ 的形式给出最终答案。代入我们求得的值：\n$$ \\begin{pmatrix} 1  1 \\end{pmatrix} $$\n这表明该调度是合法的，并且它揭示了一个维度的循环级并行性。", "answer": "$$ \\boxed{\\begin{pmatrix} 1  1 \\end{pmatrix}} $$", "id": "3663326"}, {"introduction": "将理论应用于实践是掌握任何技术的关键，在多面体模型中，一个主要应用就是实现循环分块（tiling）以提升并行度和数据局部性。然而，某些依赖模式（如高斯-赛德尔迭代）会形成依赖环，阻碍简单的分块。本练习模拟了一个真实的优化场景，要求你识别出正确的程序变换——数组展开（array expansion），以打破依赖环，从而为并行分块执行铺平道路 [@problem_id:3663289]。", "problem": "考虑以下在多面体模型中编写的二维 Gauss–Seidel 风格的更新。迭代域为整数多面体 $$D = \\{(i,j)\\in \\mathbb{Z}^2 \\mid 1 \\le i \\le N,\\ 1 \\le j \\le N\\},$$ 其中 $N \\in \\mathbb{Z}_{0}$。单个语句 $S(i,j)$ 对每个 $(i,j)\\in D$ 执行，并使用四点邻居和当前元素对数组 $A$ 进行原地更新：\n$$\n\\text{写入: } W_A(i,j) = (i,j),\\quad\n\\text{读取: } R_A(i,j) = \\{(i-1,j),\\ (i,j-1),\\ (i+1,j),\\ (i,j+1),\\ (i,j)\\},\n$$\n边界外的读取会以标准方式钳位到有效索引。在 $(i,j)$ 的字典序执行顺序（例如，行主序）下，$S(i,j)$ 与同一扫描趟中的 $S(i-1,j)$ 和 $S(i,j-1)$ 存在流依赖关系，当沿 $i$ 和 $j$ 同时应用矩形分块时，这会引发一个环。\n\n设矩形分块由一个分块映射定义\n$$\n\\tau(i,j) = \\big(b_i, b_j, x_i, x_j\\big),\\quad\nb_i = \\left\\lfloor \\frac{i-1}{p} \\right\\rfloor,\\quad b_j = \\left\\lfloor \\frac{j-1}{q} \\right\\rfloor,\\quad\nx_i = i - b_i p,\\quad x_j = j - b_j q,\n$$\n其中 $p,q \\in \\mathbb{Z}_{0}$ 为给定的分块大小。分块坐标为 $(b_i,b_j)$，块内坐标为 $(x_i,x_j)$。在原始的原地更新下，沿 $+i$ 和 $+j$ 方向的依赖关系在分块级依赖图中产生一个环，从而强制串行化（例如，通过波前调度）并阻止所有分块并行运行。\n\n在多面体模型中，打破这种依赖环的常用策略是引入一个新的临时数组并修改访问函数，使得计算阶段只读取更新前的值并只写入临时数组，然后是一个单独的复制/更新阶段，将临时数组的内容提交到原始数组。这有时被描述为通过数组展开将 Gauss–Seidel 更新转换为 Jacobi 风格的两阶段更新。\n\n你需要选择一种变换，该变换能正确修改访问函数以打破依赖环，并解锁在一个仅按 $(b_i,b_j)$ 排序的分块调度下的并行分块，即\n$$\n\\Theta_{\\text{tile}}(i,j) = (b_i, b_j),\n$$\n其中当不存在分块间依赖时，所有位于不同 $(b_i,b_j)$ 的分块都允许在计算阶段并发执行。\n\n哪个选项精确地指定了访问函数修改和阶段排序，从而为计算阶段产生一个无环的分块级依赖图，使得所有分块在 $\\Theta_{\\text{tile}}$ 下可以并行，同时在科学上保持合理性？\n\nA. 将所有对 $A$ 的写入 $W_A(i,j)$ 替换为对新临时数组 $B$ 的写入 $W_B(i,j) = (i,j)$，并保持所有对 $A$ 的读取不变：$R_A(i,j)$ 如所给。在整个域 $D$ 上完成计算阶段后，执行一个单独的复制阶段 $C(i,j)$，其写入为 $W_A^{\\text{copy}}(i,j) = (i,j)$，读取为 $R_B^{\\text{copy}}(i,j) = (i,j)$，即 $A(i,j) \\gets B(i,j)$。使用 $\\Theta_{\\text{tile}}$ 并行执行所有分块的计算阶段，然后在不引入分块间读取的情况下按元素（或按分块）执行复制阶段。\n\nB. 将对 $A$ 的写入替换为对 $B$ 的写入 $W_B(i,j) = (i,j)$，但从 $B$ 读取“较早”的邻居，即 $R_B(i,j) \\supset \\{(i-1,j),(i,j-1)\\}$，并从 $A$ 读取“较晚”的邻居，即 $R_A(i,j) \\supset \\{(i+1,j),(i,j+1),(i,j)\\}$。在每个分块完成后立即执行按分块的复制 $A \\gets B$。\n\nC. 保持对 $A$ 的写入不变，$W_A(i,j) = (i,j)$，但将所有邻居的读取重定向到临时数组 $B$，即 $R_B(i,j) = \\{(i-1,j), (i,j-1), (i+1,j), (i,j+1), (i,j)\\}$，并且没有从 $A$ 到 $B$ 的显式初始化。允许分块在 $\\Theta_{\\text{tile}}$ 下并行运行，因为读取来自 $B$。\n\nD. 写入 $B$，$W_B(i,j) = (i,j)$，然后在同一次 $(i,j)$ 迭代内立即通过 $A(i,j) \\gets B(i,j)$ 进行复制（即，在元素粒度上交错计算和复制）。保持从 $A$ 读取原始邻居，并允许在 $\\Theta_{\\text{tile}}$ 下并行分块，因为每个元素在邻居读取它之前就已提交。\n\n选择正确的选项。", "solution": "用户希望我识别出正确的变换，以对 Gauss-Seidel 风格的更新启用分块的并行执行。\n\n### 步骤1：提取已知信息\n- **迭代域**：$D = \\{(i,j)\\in \\mathbb{Z}^2 \\mid 1 \\le i \\le N,\\ 1 \\le j \\le N\\}$，对于某个常数 $N \\in \\mathbb{Z}_{0}$。\n- **语句**：$S(i,j)$ 对域 $D$ 中的每个点 $(i,j)$ 执行。\n- **访问函数**：\n    - 写入数组 $A$：$W_A(i,j) = (i,j)$。\n    - 读取数组 $A$：$R_A(i,j) = \\{(i-1,j), (i,j-1), (i+1,j), (i,j+1), (i,j)\\}$。\n- **执行顺序和依赖关系**：在 $(i,j)$ 的字典序执行顺序下，语句 $S(i,j)$ 与 $S(i-1,j)$ 和 $S(i,j-1)$ 存在流依赖关系。\n- **分块**：矩形分块由映射 $\\tau(i,j) = (b_i, b_j, x_i, x_j)$ 定义，其中：\n    - 分块坐标：$b_i = \\lfloor \\frac{i-1}{p} \\rfloor$, $b_j = \\lfloor \\frac{j-1}{q} \\rfloor$，对于分块大小 $p, q \\in \\mathbb{Z}_{0}$。\n    - 块内坐标：$x_i = i - b_i p$, $x_j = j - b_j q$。\n- **问题**：流依赖关系产生分块间依赖，这阻止了在分块调度 $\\Theta_{\\text{tile}}(i,j) = (b_i, b_j)$ 下所有分块的并行执行。\n- **目标**：找到一个修改访问函数的变换，为计算阶段创建一个无环的分块级依赖图，从而允许所有分块并发执行。\n\n### 步骤2：使用提取的已知信息进行验证\n问题陈述在编译器优化领域，特别是在多面体模型方面，具有科学依据。它描述了一个标准场景：一个带有模板式依赖（一种 Gauss-Seidel 松弛）的规则循环嵌套，在分块时限制了并行性。目标是应用一种已知技术——数组展开，将更新转换为 Jacobi 风格的更新，以实现更多的并行性。所使用的术语（迭代域、访问函数、依赖、分块、分块调度）是标准的并且使用正确。该问题定义明确、客观，并包含足够的信息来确定正确的变换。不存在科学或逻辑上的缺陷。\n\n### 步骤3：结论与行动\n问题是有效的。将对各选项进行严格的推导和评估。\n\n### 基于原理的推导\n\n核心问题是在单次计算扫描趟中存在流依赖关系。具体来说，对于字典序调度 $(i,j)$， $A(i,j)$ 的计算依赖于在同一扫描趟中已更新的值 $A(i-1,j)$ 和 $A(i,j-1)$。设更新函数为 $f$。更新操作为 $A(i,j) \\gets f(A(i-1,j), A(i,j-1), \\dots)$。\n\n如果语句 $S_1$ 写入一个内存位置，而语句 $S_2$ 随后读取该位置，并且 $S_1$ 在 $S_2$ 之前执行，那么从 $S_1$到 $S_2$ 存在流依赖。\n1.  **从 $S(i-1,j)$ 到 $S(i,j)$ 的依赖**：$S(i-1,j)$ 写入 $A(i-1,j)$。随后，$S(i,j)$ 读取 $A(i-1,j)$。这是一个流依赖，依赖向量为 $\\mathbf{d}_1 = (i,j) - (i-1,j) = (1,0)$。\n2.  **从 $S(i,j-1)$ 到 $S(i,j)$ 的依赖**：$S(i,j-1)$ 写入 $A(i,j-1)$。随后，$S(i,j)$ 读取 $A(i,j-1)$。这是一个流依赖，依赖向量为 $\\mathbf{d}_2 = (i,j) - (i,j-1) = (0,1)$。\n\n对 $A(i+1,j)$ 和 $A(i,j+1)$ 的读取是从将在本次扫描趟后期更新的位置进行的。因此，这些读取访问的是扫描开始前的值，不会引入额外的流依赖。\n\n当应用分块时，这些依赖关系可能会跨越分块边界。\n- 对于 $\\mathbf{d}_1 = (1,0)$：一次迭代 $(i,j)$ 可能依赖于 $(i-1,j)$。如果 $i-1$ 是分块宽度 $p$ 的倍数，那么 $(i,j)$ 和 $(i-1,j)$ 位于不同的分块中。具体来说，包含 $(i,j)$ 的分块依赖于其左侧的分块。\n- 对于 $\\mathbf{d}_2 = (0,1)$：一次迭代 $(i,j)$ 可能依赖于 $(i,j-1)$。如果 $j-1$ 是分块高度 $q$ 的倍数，那么 $(i,j)$ 和 $(i,j-1)$ 位于不同的分块中。包含 $(i,j)$ 的分块依赖于其“上方”的分块。\n\n这些分块间依赖意味着分块 $(b_i, b_j)$ 必须等到其相邻分块 $(b_i-1, b_j)$ 和 $(b_i, b_j-1)$ 产生了必要的边界值后才能开始执行。这阻止了所有分块的同时并行执行。\n\n为了在计算阶段打破这些依赖关系，我们必须确保没有计算会读取在同一阶段写入的值。这可以通过使用一个临时数组（比如 $B$）将 Gauss-Seidel 更新转换为 Jacobi 风格的更新来实现。这种技术被称为数组展开或私有化。\n\n该变换涉及两个不同的阶段：\n1.  **计算阶段**：所有计算都从原始数组 $A$（它持有扫描开始前的状态）中读取，并将其结果写入临时数组 $B$。\n    - 更新变为：$B(i,j) \\gets f(A(i-1,j), A(i,j-1), A(i+1,j), A(i,j+1), A(i,j))$。\n    - 对于此阶段中的任意两次迭代 $S'(i_1, j_1)$ 和 $S'(i_2, j_2)$：\n        - 所有读取都来自数组 $A$。\n        - 所有写入都指向数组 $B$。\n        - 由于 $(i_1, j_1) \\neq (i_2, j_2)$，它们写入不同的位置 $B(i_1, j_1)$ 和 $B(i_2, j_2)$。\n        - 不存在一次迭代写入一个位置而另一次迭代读取该位置的情况。因此，计算阶段中任意两次迭代之间不存在流依赖、反依赖或输出依赖。\n    - 由于没有依赖关系，所有迭代 $(i,j) \\in D$ 可以按任何顺序执行，包括完全并行。这意味着所有分块都可以并发执行，没有任何分块间依赖。\n\n2.  **复制阶段**：在整个域 $D$ 的计算阶段完成后，将临时数组 $B$ 的结果复制回原始数组 $A$。\n    - 复制操作为：$A(i,j) \\gets B(i,j)$，对所有 $(i,j) \\in D$。\n    - 每个复制操作 $C(i,j)$ 从一个唯一的 $B(i,j)$ 位置读取，并写入一个唯一的 $A(i,j)$ 位置。这些操作之间没有依赖关系。\n    - 因此，复制阶段也可以完全并行化。\n\n必须在计算阶段和复制阶段之间放置一个全局同步屏障以确保正确性。这种变换正确地消除了计算阶段的分块间依赖，实现了既定目标。\n\n### 逐项分析\n\n**A. 将所有对 $A$ 的写入 $W_A(i,j)$ 替换为对新临时数组 $B$ 的写入 $W_B(i,j) = (i,j)$，并保持所有对 $A$ 的读取不变：$R_A(i,j)$ 如所给。在整个域 $D$ 上完成计算阶段后，执行一个单独的复制阶段 $C(i,j)$，其写入为 $W_A^{\\text{copy}}(i,j) = (i,j)$，读取为 $R_B^{\\text{copy}}(i,j) = (i,j)$，即 $A(i,j) \\gets B(i,j)$。使用 $\\Theta_{\\text{tile}}$ 并行执行所有分块的计算阶段，然后在不引入分块间读取的情况下按元素（或按分块）执行复制阶段。**\n该选项准确地描述了上面推导出的 Jacobi 风格的变换。计算阶段只从 $A$ 读取并写入 $B$，这消除了计算循环嵌套中所有迭代间的依赖关系。这正确地导致了一个无环的（实际上是空的）分块级依赖图，从而允许所有分块并行运行。随后的复制阶段正确地提交了结果。这是标准的、正确的方法。\n**结论：正确**\n\n**B. 将对 $A$ 的写入替换为对 $B$ 的写入 $W_B(i,j) = (i,j)$，但从 $B$ 读取“较早”的邻居，即 $R_B(i,j) \\supset \\{(i-1,j),(i,j-1)\\}$，并从 $A$ 读取“较晚”的邻居，即 $R_A(i,j) \\supset \\{(i+1,j),(i,j+1),(i,j)\\}$。在每个分块完成后立即执行按分块的复制 $A \\gets B$。**\n这个变换是有缺陷的。通过从临时数组 $B$ 读取“较早”的邻居，它重新引入了我们试图消除的流依赖。$B(i,j)$ 的计算现在依赖于在同一阶段计算的 $B(i-1,j)$ 和 $B(i,j-1)$。这导致了依赖向量 $(1,0)$ 和 $(0,1)$，产生了分块间依赖，并阻止了所有分块的并行执行。按分块复制也会引入复杂的竞争条件和不正确的语义。\n**结论：不正确**\n\n**C. 保持对 $A$ 的写入不变，$W_A(i,j) = (i,j)$，但将所有邻居的读取重定向到临时数组 $B$，即 $R_B(i,j) = \\{(i-1,j), (i,j-1), (i+1,j), (i,j+1), (i,j)\\}$，并且没有从 $A$ 到 $B$ 的显式初始化。允许分块在 $\\Theta_{\\text{tile}}$ 下并行运行，因为读取来自 $B$。**\n这个选项在科学上是不合理的。它建议从未初始化的数组 $B$ 中读取数据。基于未定义数据的计算将产生无意义的结果。在任何有效的实现中，$B$ 都需要首先用 $A$ 的内容进行初始化。如果我们假设有这样一个初始化步骤（$B \\gets A$），那么计算阶段将是 $A(i,j) \\gets f(B(\\dots))$。虽然这允许并行执行（从 $B$ 读取，写入 $A$），但原选项由于使用了未初始化的数据而存在根本性缺陷。\n**结论：不正确**\n\n**D. 写入 $B$，$W_B(i,j) = (i,j)$，然后在同一次 $(i,j)$ 迭代内立即通过 $A(i,j) \\gets B(i,j)$ 进行复制（即，在元素粒度上交错计算和复制）。保持从 $A$ 读取原始邻居，并允许在 $\\Theta_{\\text{tile}}$ 下并行分块，因为每个元素在邻居读取它之前就已提交。**\n这个变换在功能上等同于原始的原地更新。序列 `temp = calculation_from_A; B(i,j) = temp; A(i,j) = B(i,j);` 简化为 `A(i,j) = calculation_from_A;`。临时数组 $B$ 是完全多余的。因此，所有原始的流依赖，例如从 $S(i-1,j)$ 到 $S(i,j)$ 的依赖，都被保留了下来。声称这允许并行分块是错误的；分块间的依赖依然存在，该变换没有实现任何目的。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3663289"}]}