{"hands_on_practices": [{"introduction": "寄存器合并最直接的动机是消除冗余的移动指令，并减少寄存器压力。本练习将通过一个涉及静态单赋值（SSA）形式中 $\\phi$ 函数的经典场景，来具体展示这一优势。通过分析合并前后冲突图的变化，你将亲手计算并验证寄存器合并如何能够降低图的色数，从而在寄存器数量有限的情况下避免溢出，这是理解寄存器合并核心价值的第一步。[@problem_id:3667498]", "problem": "给定一个由整数 $k \\geq 3$ 参数化的控制流图族，该族模拟了静态单赋值（Static Single Assignment, SSA）形式中 $\\phi$ 函数和副本插入的效果。考虑以下程序结构：两个前驱基本块 $P$ 和 $Q$ 流入一个合并块 $M$。有 $k-1$ 个变量 $u_{1},u_{2},\\dots,u_{k-1}$，它们都跨越合并点活跃并在 $M$ 中被使用。在块 $P$ 中定义了一个临时变量 $a$；在块 $Q$ 中定义了一个临时变量 $b$。在块 $M$ 中有一个 $\\phi$ 函数 $x \\leftarrow \\phi(a,b)$，其结果 $x$ 与所有 $u_{i}$ 一起在后续计算中使用，之后它们都变为死亡。根据标准的 SSA $\\phi$ 插入语义，一个实现 $x \\leftarrow a$ 的并行副本被放置在 $P$ 的末尾，一个实现 $x \\leftarrow b$ 的并行副本被放置在 $Q$ 的末尾。假设不存在其他定义或使用，并且 $u_{1},\\dots,u_{k-1}$ 对 $P$ 和 $Q$ 都是入口活跃的，并且仅通过在 $M$ 中的单次使用而成为 $M$ 的出口活跃变量。\n\n寄存器分配器使用一个冲突图，其顶点是程序变量的活跃范围，并且当且仅当两个顶点对应的活跃范围在某个程序点重叠时，它们之间存在一条无向边。所需的物理寄存器数量等于该冲突图的色数。假设合并仅允许用于不冲突的、与移动指令相关的变量，并且合并操作会融合它们的顶点，统一所有关联的冲突边。\n\n任务：\n- 仅使用上述关于活跃性、冲突以及在前驱边上放置 $\\phi$ 副本的核心定义，推导在副本未被合并的情况下，$P$ 和 $Q$ 的最后一个程序点上同时活跃的变量集合。利用此结果论证冲突图中存在一个团（clique），该团意味着所需寄存器数量的下界。\n- 论证如果 $\\{x,a\\}$ 和 $\\{x,b\\}$ 都被合并（这是合法的，因为 $a$ 和 $b$ 在不同的前驱块中定义且从不同时活跃，所以它们不冲突），那么在任何程序点上同时活跃的变量的最大数量会减少，并构造一个使用 $k$ 种颜色的有效着色方案。\n- 总结出当副本不被合并时，所需物理寄存器的最小数量，作为 $k$ 的函数。\n\n你的最终答案必须是一个关于 $k$ 的单一闭式解析表达式，给出不进行合并时所需物理寄存器的最小数量。无需四舍五入，也不涉及物理单位。[@problem_id:125]", "solution": "在尝试解答之前，需对问题进行验证。\n\n### 步骤 1：提取已知条件\n-   一个由整数 $k \\geq 3$ 参数化的控制流图。\n-   两个前驱基本块 $P$ 和 $Q$ 合并入一个块 $M$。\n-   有 $k-1$ 个变量 $u_{1}, u_{2}, \\dots, u_{k-1}$ 跨越合并点活跃。\n-   一个临时变量 $a$ 在块 $P$ 中定义。\n-   一个临时变量 $b$ 在块 $Q$ 中定义。\n-   一个 $\\phi$ 函数 $x \\leftarrow \\phi(a,b)$ 在块 $M$ 中。\n-   结果 $x$ 和所有 $u_{i}$ 在 $M$ 的一个计算中使用，之后它们都变为死亡。\n-   变量 $u_{1},\\dots,u_{k-1}$ 对 $P$ 和 $Q$ 都是入口活跃的。\n-   SSA 语义：一个并行副本 $x \\leftarrow a$ 被放置在 $P$ 的末尾，而 $x \\leftarrow b$ 被放置在 $Q$ 的末尾。\n-   寄存器分配基于对冲突图的着色。顶点是活跃范围。如果活跃范围在某个程序点重叠，则存在一条边。寄存器数量是色数。\n-   合并允许用于不冲突的、与移动指令相关的变量。它会融合它们的顶点。\n-   假设不存在其他定义或使用。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在编译器理论和寄存器分配领域内是明确定义的。所有使用的术语（$\\phi$ 函数、活跃性、冲突图、合并）都是标准术语。该设置描述了一个经典的“菱形”控制流模式。\n\n一个关键的解释点是在一个程序点上，特别是在一个副本指令处，“冲突”的精确定义。只有当采纳一个关于副本指令处冲突的特定、强解释时，问题陈述的后续子句（例如，合并后“同时活跃变量的最大数量……减少”）才能保持一致。这种解释是：在一个类似 $t \\leftarrow s$ 的副本指令处，源变量 $s$、目标变量 $t$ 以及所有在该指令上活跃的变量都被认为是同时活跃的。这会创建一个冲突变量的团。这种解释虽然不是文献中唯一的解释，但它是一个有效的模型，并使问题内部一致且可解。基于这种解释，该问题具有科学依据，是适定且客观的。\n\n### 步骤 3：结论与行动\n在上述关于副本指令处冲突的解释下，该问题被判定为**有效**。将提供详细的解决方案。\n\n### 解题推导\n\n问题要求在不执行寄存器合并的情况下，给定程序结构所需的最小物理寄存器数量。这个数量等于程序冲突图 $G$ 的色数 $\\chi(G)$。\n\n#### 不进行合并时的活跃性与冲突\n\n我们首先分析关键程序点上的活跃变量，这些点是插入在前驱块 $P$ 和 $Q$ 末尾的副本指令。\n\n-   **变量**：我们关心的变量是 $a, b, x,$ 和 $u_1, \\dots, u_{k-1}$。\n-   **$u_i$ 的活跃性**：每个变量 $u_i$ (对于 $i=1, \\dots, k-1$) 对 $P$ 和 $Q$ 都是入口活跃的，并在 $M$ 中被使用。因此，每个 $u_i$ 的活跃范围横跨整个块 $P$ 和 $Q$，并延伸到块 $M$ 中直到其使用点。\n-   **$a$ 和 $b$ 的活跃性**：变量 $a$ 在 $P$ 中定义，其唯一使用是在 $P$ 末尾的副本指令 $x \\leftarrow a$ 中。因此，其活跃范围从其定义点延伸到此副本指令。类似地，$b$ 的活跃范围从其在 $Q$ 中的定义点延伸到 $Q$ 末尾的副本指令 $x \\leftarrow b$。\n-   **$x$ 的活跃性**：变量 $x$ 由 $P$ 和 $Q$ 末尾的副本指令定义，并在 $M$ 中使用。其活跃范围在这些副本指令之后立即开始，并在其于 $M$ 中的使用点结束。\n\n为了确定冲突图的结构，我们必须识别出同时活跃的变量集合。\n\n如验证阶段所确立的，我们采用这样的模型：在副本指令处，源变量、目标变量以及所有活跃通过该指令的变量都被认为是同时活跃的，因此相互冲突。\n\n考虑块 $P$ 的最后一个程序点，即副本指令 $x \\leftarrow a$。\n-   源变量是 $a$。\n-   目标变量是 $x$。\n-   活跃通过此指令的变量是 $u_1, u_2, \\dots, u_{k-1}$，因为它们是 $P$ 的出口活跃变量，并且它们的值在 $M$ 中需要。\n\n根据我们的冲突模型，变量集合 $S_P = \\{a, x, u_1, u_2, \\dots, u_{k-1}\\}$ 在此程序点上都是同时活跃的。该集合的大小为 $1 + 1 + (k-1) = k+1$。由于这些变量都是同时活跃的，它们必须相互冲突。因此，在冲突图 $G$ 中，与 $S_P$ 中变量对应的顶点集构成一个大小为 $k+1$ 的团。\n\n类似地，在块 $Q$ 的最后一个程序点，副本指令是 $x \\leftarrow b$。同时活跃的变量集合是 $S_Q = \\{b, x, u_1, u_2, \\dots, u_{k-1}\\}$。这个集合的大小也是 $k+1$，并在 $G$ 中构成另一个大小为 $k+1$ 的团。\n\n冲突图 $G$ 中存在一个大小为 $k+1$ 的团，这为其色数建立了一个下界：$\\chi(G) \\geq k+1$。因此，至少需要 $k+1$ 个寄存器。\n\n为了确定这个界是否紧确，我们必须检查该图是否是 $(k+1)$-可着色的。图的顶点是 $V = \\{a, b, x, u_1, \\dots, u_{k-1}\\}$。冲突边由找到的团推导得出。\n-   集合 $\\{a, x, u_1, \\dots, u_{k-1}\\}$ 是一个团。\n-   集合 $\\{b, x, u_1, \\dots, u_{k-1}\\}$ 是一个团。\n-   变量 $a$ 和 $b$ 不冲突，因为它们的活跃范围被限制在不相交的基本块（$P$ 和 $Q$）中。\n\n让我们尝试用 $k+1$ 种颜色进行着色，记为 $\\{c_1, c_2, \\dots, c_{k+1}\\}$。\n1.  对于团 $\\{a, x, u_1, \\dots, u_{k-1}\\}$，我们需要 $k+1$ 种不同的颜色。我们进行如下分配：\n    -   $\\text{color}(u_i) = c_i$ (对于 $i = 1, \\dots, k-1$)\n    -   $\\text{color}(a) = c_k$\n    -   $\\text{color}(x) = c_{k+1}$\n2.  现在我们必须为唯一剩下的变量 $b$ 分配颜色。变量 $b$ 与 $x$ 和所有 $u_i$ 冲突。\n    -   $\\text{color}(b) \\neq \\text{color}(x) = c_{k+1}$\n    -   $\\text{color}(b) \\neq \\text{color}(u_i) = c_i$ (对于 $i = 1, \\dots, k-1$)\n3.  在我们的 $k+1$ 种颜色集合中，唯一可用于 $b$ 的颜色是 $c_k$。如果 $b$ 不与任何其他使用 $c_k$ 着色的变量冲突，我们就可以分配 $\\text{color}(b) = c_k$。唯一被分配了 $c_k$ 的其他变量是 $a$。如前所述，$a$ 和 $b$ 不冲突。\n4.  因此，分配 $\\text{color}(b) = c_k$ 是有效的。\n\n我们成功地用 $k+1$ 种颜色构造了一个有效的着色方案：\n-   $\\text{color}(u_i) = c_i$ (对于 $i \\in \\{1, \\dots, k-1\\}$)\n-   $\\text{color}(a) = c_k$\n-   $\\text{color}(b) = c_k$\n-   $\\text{color}(x) = c_{k+1}$\n\n由于该图包含一个大小为 $k+1$ 的团并且是 $(k+1)$-可着色的，其色数恰好是 $k+1$。\n\n#### 与合并情况的一致性检查\n\n问题要求论证合并可以减少寄存器压力。如果移动指令 $\\{x,a\\}$ 和 $\\{x,b\\}$ 被合并，副本指令就会被消除。变量 $a, b, x$ 被合并成一个单一的活跃范围，我们称之为 $y$。代码实际上变成：\n-   $P$: `y = ...`\n-   $Q$: `y = ...`\n-   $M$: `... use y, u1, ..., u_{k-1}`\n在这个转换后的程序中，同时活跃变量的最大集合出现在 $P$ 或 $Q$ 中 $y$ 的定义之后，以及在 $M$ 中使用之前。这个集合是 $\\{y, u_1, \\dots, u_{k-1}\\}$，其大小为 $k$。这意味着存在一个 $k$-团，并且合并后图的色数为 $k$。\n同时活跃变量的最大数量从 $k+1$（在未合并情况下的副本指令处）减少到 $k$。寄存器需求从 $k+1$ 减少到 $k$。这证实了在我们选择的冲突模型下，问题前提的一致性。\n\n#### 结论\n\n在不进行合并的情况下，冲突图包含一个大小为 $k+1$ 的团。使用 $k+1$ 个寄存器进行着色是可能的。因此，所需的最小物理寄存器数量为 $k+1$。", "answer": "$$\\boxed{k+1}$$", "id": "3667498"}, {"introduction": "并非所有的合并都是有益的；激进的合并策略有时会“弄巧成拙”，因扩大变量的活动范围而增加冲突，反而导致需要更多的寄存器。这个练习模拟了这样一种情况，即一次看似合理的合并导致了寄存器溢出。你的任务是运用更精细的技术——存活范围分裂（live-range splitting），来重构变量的生命周期，从而为一次“安全”且有效的合并创造条件，最终在有限的寄存器数量下成功着色。[@problem_id:3667484]", "problem": "考虑通过图着色进行寄存器分配，其中每个虚拟寄存器对应于一个干涉图中的节点，如果两个节点的生存范围在任何程序点上重叠，则它们之间存在一条边。由一条拷贝指令连接的一组移动相关的虚拟寄存器，通过一条移动边而不是干涉边连接。干涉图的团数是所需物理寄存器数量的下界。合并操作将移动相关的节点融合成一个单一节点，其邻居集合是被合并节点邻居集合的并集。生存范围分裂将一个虚拟寄存器替换为两个具有不相交生存范围的独立临时变量。\n\n假设有虚拟寄存器 $a$、$b$、$c$、$x$、$y$ 和唯一的一条拷贝指令 $x \\leftarrow y$。基准干涉图（在任何合并之前）具有以下干涉边：\n- $a$ 与 $b$ 和 $c$ 干涉。\n- $b$ 与 $a$ 和 $c$ 干涉。\n- $c$ 与 $a$ 和 $b$ 干涉。\n- $x$ 与 $a$ 和 $b$ 干涉，但不与 $c$ 干涉。\n- $y$ 与 $b$ 和 $c$ 干涉，但不与 $a$ 干涉。\n- $x$ 和 $y$ 不干涉（它们仅由移动指令 $x \\leftarrow y$ 连接）。\n\n假设有一个激进合并器，它会合并任何移动相关的对。在此策略下，合并 $x$ 和 $y$ 会创建一个新节点 $z$，其邻居集合是 $x$ 和 $y$ 邻居集合的并集。\n\n然后，你可以通过在 $y$ 的路径上插入一个拷贝指令来应用一次生存范围分裂，从而将 $y$ 分割成具有不相交生存范围的 $y_{1}$ 和 $y_{2}$。这个分裂的选择方式是：$y_{1}$ 仅在 $b$ 存活且 $c$ 与 $x$ 不同时存活的区域内存活，而 $y_{2}$ 仅在 $c$ 存活且 $b$ 与 $x$ 不同时存活的区域内存活。你可以将 $x$ 与 $y_{1}$ 或 $y_{2}$ 中的一个进行合并，前提是该合并不会使最大团的大小增加到超出不可避免的程度。\n\n设目标机器有 $k$ 个物理寄存器，其中 $k = 3$。首先，由于存在一个大小为 $k+1$ 的团，激进的合并 $x \\leftrightarrow y$ 会失败。请按所述设计一次分裂和一次合并，通过消除过度激进的合并所引入的膨胀干涉，将最大团的大小减小到至多为 $k$。在你的合并和分裂变换之后，对最终的干涉图进行着色而无需溢出，所需的最少物理寄存器数量是多少？以一个没有单位的整数形式报告你的答案。无需四舍五入。", "solution": "用户提供了一个编译器构造领域的问题，具体涉及通过图着色进行寄存器分配。该问题具有科学依据，提法明确且客观。它提供了一个清晰的设置，并要求基于一系列明确定义的变换得出一个具体的数值结果。因此，该问题是有效的，可以推导出解决方案。\n\n问题要求在不发生溢出的情况下，为修改后的干涉图着色所需的最少物理寄存器数量。这等价于求最终图的色数 $\\chi(G)$。\n\n首先，让我们将干涉图的初始状态形式化，称之为 $G_0$。虚拟寄存器（节点）的集合是 $V_0 = \\{a, b, c, x, y\\}$。干涉边（无向）如下：\n- $a$ 与 $b$ 和 $c$ 干涉：边 $(a, b), (a, c)$。\n- $b$ 与 $a$ 和 $c$ 干涉：边 $(b, c)$（加上已列出的 $(b,a)$）。\n- $c$ 与 $a$ 和 $b$ 干涉：边已列出。\n- $x$ 与 $a$ 和 $b$ 干涉：边 $(x, a), (x, b)$。\n- $y$ 与 $b$ 和 $c$ 干涉：边 $(y, b), (y, c)$。\n\n干涉边的集合是 $E_0 = \\{(a,b), (a,c), (b,c), (x,a), (x,b), (y,b), (y,c)\\}$。有一条移动指令 $x \\leftarrow y$，因此在 $x$ 和 $y$ 之间存在移动关系。注意，节点 $a, b, c$ 形成一个大小为 3 的团，通常表示为 $K_3$。\n\n所描述的第一步是一种激进的合并策略，即合并任何与移动相关的对。这里，$x$ 和 $y$ 被合并成一个新节点，我们称之为 $z$。$z$ 的邻居，记作 $N(z)$，是 $x$ 和 $y$ 邻居的并集。\n- $x$ 的邻居是 $N(x) = \\{a, b\\}$。\n- $y$ 的邻居是 $N(y) = \\{b, c\\}$。\n- 新节点 $z$ 的邻居是 $N(z) = N(x) \\cup N(y) = \\{a, b\\} \\cup \\{b, c\\} = \\{a, b, c\\}$。\n\n结果图 $G_1$ 的节点为 $V_1 = \\{a,b,c,z\\}$。节点 $z$ 与 $a, b, c$ 干涉。由于 $a, b, c$ 本身已经形成一个 3-团，节点集合 $\\{a, b, c, z\\}$ 形成一个 4-团。该图的团数 $\\omega(G_1)$ 为 4。色数必须至少等于团数，因此 $\\chi(G_1) \\ge 4$。只有 $k=3$ 个物理寄存器，该图无法在不溢出的情况下着色，这证实了问题的假设。\n\n任务是设计一个特定的生存范围分裂，将 $y$ 分成 $y_1$ 和 $y_2$，然后进行一次合并，以使图是 3-可着色的。此变换的目标是打破 4-团的形成。\n\n生存范围分裂将变量 $y$ 的生存范围划分为新变量 $y_1$ 和 $y_2$ 的不相交的生存范围。$y$ 的原始干涉被分配给 $y_1$ 和 $y_2$。让我们分析所需的分裂。我们被允许将 $x$ 与 $y_1$ 或 $y_2$ 合并。假设我们将 $x$ 与 $y_1$ 合并，创建一个新节点 $w = (x, y_1)$。$w$ 的邻居将是 $N(w) = N(x) \\cup N(y_1)$。\n\n在激进合并场景下的 4-团是 $\\{a, b, c, z\\}$。为避免这种情况，新的合并节点 $w$ 必须不能同时与 $a, b, c$ 三者都干涉。我们知道 $N(x) = \\{a, b\\}$，所以 $w$ 肯定会与 $a$ 和 $b$ 干涉。为了防止形成 4-团 $\\{a,b,c,w\\}$，我们必须确保 $w$ 不与 $c$ 干涉。\n条件 `interferes(w, c)` 为假当且仅当 `interferes(x, c)` 为假且 `interferes(y1, c)` 为假。已知 $x$ 不与 $c$ 干涉。因此，对 $y$ 的分裂必须设计成 $y_1$ 不与 $c$ 干涉。\n\n原始变量 $y$ 与 $\\{b, c\\}$ 干涉。由于 $y_1$ 不会与 $c$ 干涉，与 $c$ 的干涉必须被归到 $y_2$ 上。因此，$y_2$ 必须与 $c$ 干涉。\n问题对 $y_1$ 分裂的描述是：“$y_1$ 仅在 $b$ 存活但 $c$ 不与 $x$ 同时存活的区域内存活”。由于 $x$ 和 $c$ 不干涉，它们的生存范围是不相交的，因此对于 $c$ 生存范围内的任何点，“不与 $x$ 同时存活”的条件总是满足的。这部分描述简化为“$y_1$ 仅在 $b$ 存活的区域内存活”，这意味着 $y_1$ 与 $b$ 干涉。\n对 $y_2$ 的描述支持了它与 $c$ 干涉的结论。\n一个能实现此目标的干净分裂会将 $y$ 的干涉进行划分，使得 $N(y_1) = \\{b\\}$ 且 $N(y_2) = \\{c\\}$。这是一个精心设计的生存范围分裂的有效结果。\n\n那么，让我们继续进行这个设计的变换：\n1.  **分裂**：将 $y$ 分裂成 $y_1$ 和 $y_2$，使得 $N(y_1)=\\{b\\}$ 和 $N(y_2)=\\{c\\}$。生存范围 $L(y_1)$ 和 $L(y_2)$ 是不相交的，因此没有边 $(y_1, y_2)$。原始的移动指令 $x \\leftarrow y$ 被更新，比如说更新为 $x \\leftarrow y_1$，在 $x$ 和 $y_1$ 之间创建了移动关系。\n2.  **合并**：将移动相关的对 $(x, y_1)$ 合并成一个新节点 $w$。\n    - $N(x) = \\{a, b\\}$。\n    - $N(y_1) = \\{b\\}$。\n    - $N(w) = N(x) \\cup N(y_1) = \\{a, b\\} \\cup \\{b\\} = \\{a,b\\}$。\n\n最终的干涉图，我们称之为 $G_2$，其节点集为 $V_2 = \\{a, b, c, w, y_2\\}$。边集是原始边中不涉及 $x$ 或 $y$ 的边，加上涉及 $w$ 和 $y_2$ 的新边：\n- $\\{a,b,c\\}$ 上的原始 3-团保持不变：边 $(a,b), (a,c), (b,c)$。\n- 新节点 $w$ 的边：$(w,a)$ 和 $(w,b)$。\n- 新节点 $y_2$ 的边：$(y_2,c)$。\n\n$G_2$ 中的完整边集是 $E_2 = \\{(a,b), (a,c), (b,c), (w,a), (w,b), (y_2,c)\\}$。\n\n为了找到最少的寄存器数量，我们需要求出色数 $\\chi(G_2)$。色数的一个下界是最大团的大小 $\\omega(G_2)$。\n- 节点 $\\{a, b, c\\}$ 形成一个 3-团。\n- 节点 $\\{a, b, w\\}$ 形成一个 3-团，因为 $w$ 与 $a$ 和 $b$ 都干涉。\n不存在其他大小为 3 或更大的团。例如，$y_2$ 只与 $c$ 连接。因此，最大团的大小是 $\\omega(G_2) = 3$。这意味着 $\\chi(G_2) \\ge 3$。\n\n现在我们检查 $G_2$ 是否是 3-可着色的。让我们为节点分配颜色（例如，$C_1, C_2, C_3$）：\n1.  从需要 3 种不同颜色的 3-团 $\\{a,b,c\\}$ 开始。\n    - 令 $\\text{color}(a) = C_1$。\n    - 令 $\\text{color}(b) = C_2$。\n    - 令 $\\text{color}(c) = C_3$。\n2.  为节点 $w$ 着色。它与 $a$（颜色 $C_1$）和 $b$（颜色 $C_2$）相邻。因此，$w$ 可以被赋予剩下的颜色。\n    - 令 $\\text{color}(w) = C_3$。\n3.  为节点 $y_2$ 着色。它只与 $c$（颜色 $C_3$）相邻。因此，$y_2$ 可以被赋予除 $C_3$ 之外的任何颜色。\n    - 令 $\\text{color}(y_2) = C_1$。\n\n我们为图 $G_2$ 找到了一个有效的 3-着色方案：$\\{a:C_1, b:C_2, c:C_3, w:C_3, y_2:C_1\\}$。没有两个相邻节点共享相同的颜色。\n- $(a,b) \\rightarrow (C_1, C_2)$\n- $(a,c) \\rightarrow (C_1, C_3)$\n- $(b,c) \\rightarrow (C_2, C_3)$\n- $(w,a) \\rightarrow (C_3, C_1)$\n- $(w,b) \\rightarrow (C_3, C_2)$\n- $(y_2,c) \\rightarrow (C_1, C_3)$\n所有约束都得到满足。\n\n由于该图是 3-可着色的，其色数为 $\\chi(G_2)=3$。在不发生溢出的情况下为该图着色所需的最少物理寄存器数量是 3。", "answer": "$$\\boxed{3}$$", "id": "3667484"}, {"introduction": "在真实的编译器中，是否执行某项优化往往取决于复杂的权衡。本练习将寄存器合并的决策过程形式化为一个优化问题。你需要最小化一个综合考虑了移动指令开销和寄存器溢出代价的成本函数 $C=\\alpha\\cdot \\text{moves}+\\beta\\cdot \\text{spills}$。通过评估不同合并策略的成本，你将学会像编译器一样，在消除指令和增加寄存器压力之间做出量化的、有原则的决策。[@problem_id:3667547]", "problem": "一个编译器后端通过图着色来执行寄存器分配，并将寄存器合并建模为一种优化，它在消除复制指令与增加寄存器压力的风险之间进行权衡。考虑一个干涉图 $G=(V,E)$，其中顶点集 $V=\\{u,v,w,x,y\\}$，干涉边集为\n$$\nE=\\{(u,w),(u,x),(v,w),(v,y),(w,x),(x,y)\\}.\n$$\n有 $k=2$ 个可用的机器寄存器。程序在以下非干涉对（称为移动相关对）之间包含复制（移动）指令：\n$$\nM=\\{(u,v),(v,x),(w,y)\\}.\n$$\n您可以选择 $M$ 的任何子集进行合并。合并一对 $(a,b)\\in M$ 会将节点 $a$ 和 $b$ 合并为一个新节点，其邻接关系等于 $a$ 和 $b$ 邻接关系的并集，从而精确地消除一条移动指令。合并仅对 $M$ 中的对是允许的，并且仅当其端点在当前图中不干涉时才允许。在执行您选择的合并之后，您必须通过溢出（即，分配到内存而不是寄存器）最少数量的节点，使结果图变为 $k$-可着色；溢出一个节点会将其本身及其所有关联边从图中移除。假设有以下建模选择：\n- 剩余的移动指令数量，记为 $\\text{moves}$，等于您未合并的 $M$ 中的对的数量；溢出不改变此数量。\n- 溢出数量，记为 $\\text{spills}$，等于您为实现 $k$-可着色性而选择从合并后图中溢出的不同节点的数量。\n\n目标是最小化线性成本\n$$\nC=\\alpha\\cdot \\text{moves}+\\beta\\cdot \\text{spills},\n$$\n其中权重为 $\\alpha=4$ 和 $\\beta=9$。\n\n在这些规则下，确定 $C$ 可达到的最小值。请以单个数字形式提供您的最终答案。无需四舍五入。[@problem_id:101]", "solution": "用户想让我解决一个编译器优化问题。\n\n### 步骤 1：提取已知条件\n-   **干涉图**：$G=(V,E)$\n    -   顶点：$V=\\{u,v,w,x,y\\}$\n    -   干涉边：$E=\\{(u,w),(u,x),(v,w),(v,y),(w,x),(x,y)\\}$\n-   **可用寄存器**：$k=2$\n-   **移动相关对**：$M=\\{(u,v),(v,x),(w,y)\\}$\n-   **合并规则**：合并一对 $(a,b) \\in M$ 会将节点 $a$ 和 $b$ 合并为一个新节点。新节点的邻居是 $a$ 和 $b$ 邻居的并集。只有当端点在当前图中不干涉时才允许合并。\n-   **溢出规则**：为了使图 $k$-可着色，必须溢出最少数量的节点。溢出一个节点会将其自身及其所有关联边移除。\n-   **成本函数**：$C=\\alpha\\cdot \\text{moves}+\\beta\\cdot \\text{spills}$\n-   **成本权重**：$\\alpha=4$, $\\beta=9$\n-   **定义**：\n    -   `moves`：$M$ 中未合并的对的数量。\n    -   `spills`：为实现 $k$-可着色性而从合并后图中溢出的节点数量。\n-   **目标**：找到 $C$ 的可达到的最小值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在编译器理论领域，特别是在通过图着色进行寄存器分配方面，具有科学依据。干涉图、移动相关对、合并、溢出以及用于平衡这些权衡的成本函数等概念是该领域的标准模型。这是一个适定的问题：它提供了一套清晰的规则、约束以及一个要在有限的选择集（要合并的 $M$ 的子集）上最小化的目标函数。数据是自洽且一致的。例如，$M$ 中的移动相关对被正确地描述为在初始图 $G$ 中不干涉。语言客观而精确。因此，该问题是有效的。\n\n### 步骤 3：结论与行动\n问题有效。我将继续进行解答。\n\n### 解答\n目标是最小化成本函数 $C = 4 \\cdot \\text{moves} + 9 \\cdot \\text{spills}$。移动指令的数量是 $|M| - (\\text{成功合并的数量})$，其中 $|M|=3$。为了最小化 $C$，我们必须分析不同合并策略的结果。一种策略包括从 $M$ 中选择一个移动指令的子集进行合并，但需遵守合并只对当前图中非干涉对可行的规则。对于任何结果图，我们必须找到使其变为 $2$-可着色所需的最少溢出次数，因为有 $k=2$ 个寄存器。一个图是 $2$-可着色的，当且仅当它是二分图，即不包含奇数长度的环。\n\n让我们按执行的合并次数分组，分析可能的合并策略。\n\n**情况 0：不进行合并**\n如果没有移动指令被合并，我们从初始图 $G$ 开始。\n-   未合并的移动指令数量：$\\text{moves} = 3$。\n-   顶点 $\\{u, w, x\\}$ 形成一个三角形 ($K_3$)，这是一个奇数长度的环。因此，$G$ 不是 $2$-可着色的，其色数 $\\chi(G) \\ge 3$。需要进行溢出。\n-   为了使 $G$ 成为二分图，我们必须打破所有奇数环。该图包含一个 3-环 $(u,w,x)$ 和一个 5-环 $(u,w,v,y,x,u)$。溢出单个节点（例如 $w$）会移除所有与其关联的边。剩余的顶点是 $\\{u,v,x,y\\}$，边集为 $E'=\\{(u,x), (v,y), (x,y)\\}$。这个图是二分图（一个有效的 2-着色是 $C(u)=1, C(x)=2, C(y)=1, C(v)=2$）。因此，一次溢出就足够了。\n-   $\\text{spills} = 1$。\n-   成本为 $C_0 = 4 \\cdot 3 + 9 \\cdot 1 = 12 + 9 = 21$。\n\n**情况 1：进行一次合并**\n我们可以选择合并 $M$ 中三对中的任意一对。初始时它们都是有效的，因为它们不干涉。让我们分析合并 $(u,v)$ 的情况。\n-   将 $(u,v)$ 合并为一个新节点 $uv$。消除了一条移动指令。$\\text{moves} = 2$。\n-   新的顶点集为 $V' = \\{uv, w, x, y\\}$。\n-   新节点 $uv$ 的邻居是 $u$ 和 $v$ 邻居的并集：$\\text{Adj}(uv) = \\text{Adj}(u) \\cup \\text{Adj}(v) = \\{w,x\\} \\cup \\{w,y\\} = \\{w,x,y\\}$。\n-   新的边集为 $E' = \\{(uv,w), (uv,x), (uv,y), (w,x), (x,y)\\}$。\n-   这个新图包含两个三角形：$(uv,w,x)$ 和 $(uv,x,y)$。它不是 $2$-可着色的。\n-   为了使其成为二分图，我们可以溢出节点 $x$。剩余的顶点 $\\{uv, w, y\\}$ 的边集为 $\\{(uv,w), (uv,y)\\}$，这是一个二分图。因此，一次溢出就足够了。\n-   $\\text{spills} = 1$。\n-   成本为 $C_1 = 4 \\cdot 2 + 9 \\cdot 1 = 8 + 9 = 17$。\n-   根据对称性，只合并 $(v,x)$ 或只合并 $(w,y)$ 也会得到一个需要一次溢出的图，产生的成本同样为 $17$。\n\n**情况 2：进行两次合并**\n我们可以尝试从 $M = \\{(u,v), (v,x), (w,y)\\}$ 中合并两对。\n-   **子情况 2.1：合并 $(u,v)$ 和 $(v,x)$**。\n    这两对共享顶点 $v$。这意味着将 $u,v,x$ 合并为一个节点。然而，初始图中包含干涉边 $(u,x) \\in E$。这违反了合并的原则，因为一组节点只有在它们之间不相互干涉时才能合并。顺序分析证实了这一点：如果我们先将 $(u,v)$ 合并为 $uv$，新节点 $uv$ 会与 $x$ 干涉（因为 $u$ 与 $x$ 干涉）。因此，后续对移动对（现在是 $uv$ 和 $x$ 之间）的合并被阻止。对称地，先合并 $(v,x)$ 会阻止后续对 $(u,v)$ 的合并。因此，不可能同时执行这两个合并。此策略最终只会导致一次合并，成本为 $17$，与情况 1 相同。\n-   **子情况 2.2：合并 $(u,v)$ 和 $(w,y)$**。\n    这两对是不相交且非干涉的。我们可以执行这两个合并。\n    -   消除了两条移动指令。$\\text{moves} = 1$。\n    -   我们将 $u,v$ 合并为 $uv$，将 $w,y$ 合并为 $wy$。新的顶点集是 $V'' = \\{uv, wy, x\\}$。\n    -   让我们找出边：\n        -   $\\text{Adj}(uv)$ 的邻居是 $\\text{Adj}(u) \\cup \\text{Adj}(v) = \\{w,x,y\\}$。在新的节点集中，这变为 $\\{wy, x\\}$。\n        -   $\\text{Adj}(wy)$ 的邻居是 $\\text{Adj}(w) \\cup \\text{Adj}(y) = \\{u,v,x\\} \\cup \\{v,x\\} = \\{u,v,x\\}$。在新的节点集中，这变为 $\\{uv, x\\}$。\n        -   $\\text{Adj}(x)$ 的邻居是 $\\{u,w,y\\}$。在新的节点集中，这变为 $\\{uv, wy\\}$。\n    -   在 $\\{uv, wy, x\\}$ 上的结果图是一个三角形 ($K_3$)，因为每个节点都与其他每个节点相连。\n    -   这个图不是 $2$-可着色的。溢出三个节点中的任何一个都会留下一条边 ($K_2$)，这是二分图。\n    -   $\\text{spills} = 1$。\n    -   成本为 $C_2 = 4 \\cdot 1 + 9 \\cdot 1 = 4 + 9 = 13$。\n-   **子情况 2.3：合并 $(v,x)$ 和 $(w,y)$**。\n    这类似于子情况 2.2。这两对是不相交的，并且都可以被合并。\n    -   $\\text{moves} = 1$。\n    -   新的顶点集是 $\\{u, vx, wy\\}$，其中 $vx$ 是 $v,x$ 的合并，$wy$ 是 $w,y$ 的合并。\n    -   结果图又是一个 $K_3$，需要一次溢出。\n    -   $\\text{spills} = 1$。\n    -   成本为 $C_3 = 4 \\cdot 1 + 9 \\cdot 1 = 13$。\n\n**情况 3：进行三次合并**\n要执行来自 $M=\\{(u,v), (v,x), (w,y)\\}$ 的所有三次合并，我们需要合并节点集 $\\{u,v,x\\}$ 和 $\\{w,y\\}$。如子情况 2.1 中所确立的，由于干涉 $(u,x)$ 的存在，集合 $\\{u,v,x\\}$ 不能被合并。因此，不可能执行所有三次合并。成功合并的最大数量是两次。\n\n**结论**\n我们评估了所有可能的有效合并策略的成本：\n-   0 次合并：$C = 21$。\n-   1 次合并：$C = 17$。\n-   2 次合并：$C = 13$。\n\n可达到的最小成本是 $13$。这是通过合并两个不冲突的移动对，例如 $(u,v)$ 和 $(w,y)$ 来实现的。", "answer": "$$\n\\boxed{13}\n$$", "id": "3667547"}]}