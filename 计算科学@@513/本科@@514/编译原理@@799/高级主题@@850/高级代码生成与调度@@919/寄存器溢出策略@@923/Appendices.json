{"hands_on_practices": [{"introduction": "寄存器压力不仅源于程序中同时活跃的变量过多，还可能因硬件或ABI（应用程序二进制接口）的限制而加剧，这些限制会将某些变量“预着色”到特定寄存器中。这种约束常常导致寄存器分配器别无选择，只能进行寄存器溢出。本练习 [@problem_id:3667850] 构建了一个这样的场景，要求你评估并选择最有效的溢出策略。通过比较“全局溢出”这一暴力方法与更为精准的“活跃范围分裂”技术，你将深入理解如何通过最小化内存操作来降低溢出带来的性能开销。", "problem": "考虑一个假设的精简指令集计算机 (RISC) 架构，它有 $4$ 个整数寄存器 $\\{r0, r1, r2, r3\\}$。应用程序二进制接口 (ABI) 为 $r0$ 保留了一些固定角色：它在函数调用时会被破坏，并且关键的是，某些指令要求操作数和结果必须在 $r0$ 中。特别是，无符号高位乘法指令 $\\mathrm{mulhi}(x, y)$ 要求其第一个操作数在 $r0$ 中，并将其结果写入 $r0$。\n\n一个编译器正在对循环内的以下线性基本块执行全局寄存器分配。该块包含指令 $I_1$ 到 $I_{10}$，并使用临时变量 $\\{p, q, r, w, s, m, t, u, d, g, v\\}$，其数据依赖和使用情况如下：\n- $I_1$: $p \\leftarrow \\mathrm{load}(P)$\n- $I_2$: $q \\leftarrow \\mathrm{load}(Q)$\n- $I_3$: $r \\leftarrow p + q$\n- $I_4$: $w \\leftarrow r + q$\n- $I_5$: $s \\leftarrow w + p$\n- $I_6$: $t \\leftarrow \\mathrm{mulhi}(s, m)$，存在硬件约束，即在 $I_6$ 处，操作数 $s$ 必须在 $r0$ 中，并且结果 $t$ 也产生在 $r0$ 中；第二个操作数 $m$ 必须在某个寄存器中（$\\mathrm{mulhi}$ 不支持内存操作数）。\n- $I_7$: $u \\leftarrow t + s$\n- $I_8$: $v \\leftarrow u + r$\n- $I_9$: $v \\leftarrow v + d$\n- $I_{10}$: $v \\leftarrow v + g$\n\n假设 $m$ 在之前已加载，且仅在 $I_6$ 处使用；$d$ 和 $g$ 都在 $I_6$ 之前定义，并分别在 $I_6$ 之后如图所示的位置使用。该块中没有函数调用，也没有其他特殊指令。假设分配器执行 Chaitin 风格的图着色算法：它根据活性分析构建冲突图，并尝试使用可用寄存器进行着色；如果由于寄存器压力而着色失败，它会通过插入存储和加载指令来进行溢出。\n\n在 $I_6$ 处，同时存活的值的集合是 $\\{s, r, d, g, m\\}$，因为 $s$ 在 $I_6$ 和 $I_7$ 处使用，$r$ 在之后的 $I_8$ 处使用，$d$ 在 $I_9$ 处使用，$g$ 在 $I_{10}$ 处使用，而 $m$ 在 $I_6$ 处使用。由于在 $I_6$ 处的预着色要求，$s$ 必须位于 $r0$ 中，这使得 $r0$ 无法用于任何其他存活值。这使得剩下的 $4$ 个存活值 $\\{r, d, g, m\\}$ 只能使用 $\\{r1, r2, r3\\}$，从而保证在 $I_6$ 处至少有 $1$ 次溢出。\n\n编译器必须选择一种策略，既满足预着色约束，又最小化额外的溢出开销。考虑以下候选策略：\n\nA. 在块中对 $r$ 的整个存活范围内进行全局溢出，即在其定义 $I_3$ 之后插入一条到内存的存储指令，并在其每个使用点（$I_4$ 和 $I_8$）插入加载指令，使得 $r$ 主要保留在内存中而不是寄存器中。\n\nB. 在 $I_6$ 周围对 $r$ 的存活范围进行分裂：在 $I_6$ 之前一直将 $r$ 保留在寄存器中，在 $I_6$ 紧邻之前插入一条存储 $r$ 的指令以缓解压力峰值，并在 $I_8$ 紧邻之前插入一条重新加载 $r$ 的指令；在其他地方 $r$ 仍然在寄存器中。\n\nC. 将 $m$ 分配给 $r2$，并在 $\\mathrm{mulhi}$ 中为 $m$ 使用内存操作数，以避免在 $I_6$ 处占用寄存器。\n\nD. 在 $I_6$ 周围分裂 $s$：在 $I_6$ 之前将 $s$ 保留在 $r2$ 中，在 $I_6$ 紧邻之前将 $s$ 移动到 $r0$ 中，并在 $I_6$ 之后将其移出，而不溢出其他值。\n\n哪种策略能在保持语义不变的情况下，得出一个既遵守预着色约束又最小化额外溢出开销（以每次循环迭代中插入的加载和存储指令数量衡量）的有效分配方案？\n\n选择一个选项。\n\nA. 在整个块内对 $r$ 进行全局溢出。\n\nB. 仅在 $I_6$ 周围对 $r$ 进行存活范围分裂。\n\nC. 在 $\\mathrm{mulhi}$ 中为 $m$ 使用内存操作数。\n\nD. 仅在 $I_6$ 处将 $s$ 复制到 $r0$ 中，而不溢出其他变量。", "solution": "用户希望我扮演一位严谨的STEM教授，验证所提供的问题陈述，然后推导出正确的解决方案。\n\n### 步骤 1：提取已知条件\n\n-   **架构**：假设的RISC架构，拥有 $4$ 个整数寄存器 $\\{r0, r1, r2, r3\\}$。\n-   **ABI/指令约束**：$r0$ 用于特殊目的。指令 $t \\leftarrow \\mathrm{mulhi}(s, m)$ 有以下约束：\n    1.  第一个操作数 ($s$) 必须在寄存器 $r0$ 中。\n    2.  结果 ($t$) 被写入寄存器 $r0$。\n    3.  第二个操作数 ($m$) 必须在寄存器中。\n-   **代码块**：一个循环内的线性基本块，包含指令 $I_1$ 到 $I_{10}$。\n    -   $I_1$: $p \\leftarrow \\mathrm{load}(P)$\n    -   $I_2$: $q \\leftarrow \\mathrm{load}(Q)$\n    -   $I_3$: $r \\leftarrow p + q$\n    -   $I_4$: $w \\leftarrow r + q$\n    -   $I_5$: $s \\leftarrow w + p$\n    -   $I_6$: $t \\leftarrow \\mathrm{mulhi}(s, m)$\n    -   $I_7$: $u \\leftarrow t + s$\n    -   $I_8$: $v \\leftarrow u + r$\n    -   $I_9$: $v \\leftarrow v + d$\n    -   $I_{10}$: $v \\leftarrow v + g$\n-   **活性信息**：\n    -   在指令 $I_6$ 处，同时存活的值的集合被给出为 $\\{s, r, d, g, m\\}$。\n    -   活性验证：\n        -   $s$：在 $I_5$ 定义，在 $I_6$ 和 $I_7$ 使用。跨越 $I_6$ 存活。\n        -   $r$：在 $I_3$ 定义，在 $I_4$ 和 $I_8$ 使用。跨越 $I_6$ 存活。\n        -   $d$：在 $I_6$ 之前定义，在 $I_9$ 使用。跨越 $I_6$ 存活。\n        -   $g$：在 $I_6$ 之前定义，在 $I_{10}$ 使用。跨越 $I_6$ 存活。\n        -   $m$：在 $I_6$ 之前定义，在 $I_6$ 使用。在 $I_6$ 处存活。\n    -   关于活性的陈述是正确的。在指令 $I_6$ 的位置有 $5$ 个变量存活。\n-   **寄存器分配上下文**：\n    -   方法：Chaitin风格的图着色。\n    -   总可用寄存器数：$4$。\n    -   $I_6$ 处的寄存器压力：$5$ 个存活变量需要寄存器，但只有 $4$ 个可用。\n    -   预着色：在 $I_6$ 处，变量 $s$ 必须在 $r0$ 中。\n    -   冲突：其他 $4$ 个存活变量 $\\{r, d, g, m\\}$ 必须从剩下的 $3$ 个寄存器 $\\{r1, r2, r3\\}$ 中分配。这是不可能的，因此强制发生一次溢出。\n-   **目标**：选择一个有效且能最小化溢出开销（插入的加载/存储指令数量）的策略。\n\n### 步骤 2：使用已知条件进行验证\n\n-   **科学依据**：该问题在编译器设计原理方面有坚实的基础，特别是寄存器分配、活性分析、冲突图和溢出策略。所描述的约束是对现实世界处理器架构和编译器挑战的现实简化。该问题在科学和技术上是合理的。\n-   **问题适定性**：问题是适定的。它提出了一个寄存器压力超过可用资源的清晰场景，并要求在最小化内存操作这一明确的优化标准下，评估特定的、明确定义的策略。\n-   **客观性**：问题以客观、技术性的语言陈述。目标“最小化额外溢出开销”是一个可量化的指标。\n-   **缺陷检查**：\n    1.  **科学或事实不健全**：无。逻辑与已建立的编译器理论一致。\n    2.  **不可形式化或不相关**：无。问题与寄存器溢出策略直接相关。\n    3.  **不完整或矛盾的设置**：设置是自洽的，并提供了足够的信息。关于存活集和由此产生的冲突的明确说明指导了分析，将问题简化为专注于溢出策略的选择。虽然问题陈述简化了 `mulhi` 指令会破坏 $s$ 值的问题，但这是一种常见的教学简化，目的是将问题集中在一个特定概念上——在这种情况下，是比较*其他*变量的溢出策略。所提供的选项与这种简化视图是一致的。\n    4.  **不切实际或不可行**：该场景是对一个常见编译器问题的现实（尽管简化了）模型。\n    5.  **问题不适定或结构不良**：问题结构良好，能够在选项中导出一个可确定的最佳答案。\n    6.  **伪深刻、琐碎或同义反复**：问题并非琐碎；它需要对不同策略的溢出成本进行正确分析。\n    7.  **超出科学可验证性**：问题可通过标准编译器算法进行验证。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。进入求解过程。\n\n### 推导与选项分析\n\n问题的核心是在指令 $I_6$ 处的寄存器分配冲突。此时，有 $5$ 个存活变量 $\\{s, r, d, g, m\\}$，但只有 $4$ 个可用寄存器 $\\{r0, r1, r2, r3\\}$。这些变量的冲突图将包含一个 $5$-团（$K_5$），无法用 $4$ 种颜色进行着色。因此，至少有一个变量必须被溢出（即，存储在内存中）。\n\n问题规定了指导溢出候选者选择的约束条件：\n1.  **预着色**：变量 $s$ 必须在寄存器 $r0$ 中以执行 `mulhi` 指令。这将 $s$ 的节点预着色为 $r0$。\n2.  **操作数约束**：变量 $m$ 必须在寄存器中以执行 `mulhi`。这意味着 $m$ 不能是溢出的变量。\n\n由于 $s$ 被分配给 $r0$，剩下的 $4$ 个存活变量 $\\{r, d, g, m\\}$ 必须从剩下的 $3$ 个寄存器 $\\{r1, r2, r3\\}$ 中分配。由于 $m$ 必须在寄存器中，它将占用 $\\{r1, r2, r3\\}$ 中的一个。这只剩下 $2$ 个寄存器给 $3$ 个变量 $\\{r, d, g\\}$。因此，集合 $\\{r, d, g\\}$ 中的一个变量必须在指令 $I_6$ 处被溢出。\n\n问题要求找到处理这次溢出的最佳策略，重点是最小化溢出开销（增加的 `load` 和 `store` 指令数量）。我们现在评估每个选项。\n\n**A. 在整个块内对 $r$ 进行全局溢出。**\n该策略建议将变量 $r$ 在其整个存活范围内都保存在内存中。\n-   变量 $r$ 在 $I_3: r \\leftarrow p + q$ 定义。一个 `store` 指令将紧跟在 $I_3$ 之后插入。\n-   变量 $r$ 在 $I_4: w \\leftarrow r + q$ 使用。一个 `load` 指令将在 $I_4$ 之前插入。\n-   变量 $r$ 再次在 $I_8: v \\leftarrow u + r$ 使用。一个 `load` 指令将在 $I_8$ 之前插入。\n-   **溢出开销**：该策略引入 $1$ 个 `store` 和 $2$ 个 `load` 指令，每次循环迭代总共有 $3$ 次内存操作。\n-   **有效性**：该策略通过将 $r$ 从需要寄存器的变量集合中移除，成功解决了 $I_6$ 处的寄存器压力。剩下的变量 $\\{s, d, g, m\\}$ 可以被分配到 $4$ 个可用寄存器中。该策略是有效的。\n-   **结论**：**不正确**。虽然有效，但可能不是最优的。如果变量被多次使用，全局溢出通常比更有针对性的方法开销更大。\n\n**B. 仅在 $I_6$ 周围对 $r$ 进行存活范围分裂。**\n该策略涉及更精确的溢出，除了在 $I_6$ 周围寄存器压力高的特定区域外，都将 $r$ 保留在寄存器中。\n-   $r$ 在 $I_3$ 定义，在 $I_4$ 使用。在此期间可以将其保存在寄存器中。\n-   为了缓解 $I_6$ 处的压力，在 $I_6$ 之前插入一个针对 $r$ 的 `store` 指令。\n-   在 $I_6$ 之后，直到在 $I_8$ 使用之前，$r$ 都不再需要。在 $I_8$ 之前插入一个 `load` 指令，将其值重新加载到寄存器中。\n-   **溢出开销**：该策略引入 $1$ 个 `store` 和 $1$ 个 `load` 指令，每次循环迭代总共有 $2$ 次内存操作。\n-   **有效性**：该策略也是有效的。它在关键点 $I_6$ 将 $r$ 从寄存器分配器的考虑中移除，解决了冲突。\n-   **结论**：**正确**。该策略有效，并且导致的溢出开销（$2$ 次内存操作）比选项 A 中的全局溢出策略（$3$ 次内存操作）要少。这是一个更高效的解决方案。\n\n**C. 在 `mulhi` 中为 $m$ 使用内存操作数。**\n该策略建议修改 `mulhi` 指令，使其直接从内存中获取第二个操作数。\n-   **有效性**：问题陈述明确给出了一个硬件约束：“第二个操作数 $m$ 必须在某个寄存器中（$\\mathrm{mulhi}$ 不支持内存操作数）”。该策略直接违反了这一给定的约束。\n-   **结论**：**不正确**。该策略是无效的，因为它不被指定的架构所支持。\n\n**D. 仅在 $I_6$ 处将 $s$ 复制到 $r0$ 中，而不溢出其他变量。**\n此选项声称可以在不溢出任何其他存活变量 $\\{r, d, g, m\\}$ 的情况下解决问题。\n-   **有效性**：这一说法在逻辑上是不可能的。如前所述，在指令 $I_6$ 处，有 $5$ 个同时存活的变量：$\\{s, r, d, g, m\\}$。寄存器分配的原则是，如果 $k$ 个变量同时存活，则至少需要 $k$ 个寄存器来保存它们而不发生溢出。这里，$k=5$，但可用寄存器数量为 $4$。不可能将所有 $5$ 个值都保存在寄存器中。“而不溢出其他变量”的说法与基本问题约束相矛盾。\n-   **结论**：**不正确**。该策略描述了一个不可能实现的结果。\n\n**总结**\n比较有效的选项，选项 A 导致 $3$ 次内存操作，而选项 B 导致 $2$ 次。选项 B 最小化了溢出开销。选项 C 和 D 是无效的。因此，在这些选择中，最佳策略是对 $r$ 进行存活范围分裂。", "answer": "$$\\boxed{B}$$", "id": "3667850"}, {"introduction": "一旦编译器决定溢出一个变量，就必须为其在内存中预留一个稳定的存储位置，即“溢出槽”。本练习 [@problem_id:3667841] 深入探讨了溢出槽在函数栈帧上的具体实现，尤其是在面对动态栈分配（如C语言中的 `alloca`）等复杂情况时的挑战。通过本练习，你将从第一性原理出发，理解为何使用一个稳定的帧指针（`FP`）而非动态变化的栈指针（`SP`）来寻址溢出槽，是生成正确且高效溢出代码的关键。", "problem": "一个函数被编译到一个目标平台，该平台的运行时栈向低地址方向增长。机器模型提供了一个栈指针 `SP` 和一个帧指针 `FP`。应用程序二进制接口 (ABI) 要求被调用者保存的寄存器 (callee-saved registers) 必须溢出到函数活动记录的内存中。编译器的寄存器分配器可能会使用“基址+立即数”寻址模式插入溢出加载和存储指令，即内存操作数的形式为 `[B + c]`，其中 `B` 是一个基址寄存器，$c$ 是一个编译时常量偏移量。\n\n考虑一个测试函数，该函数使用可变大小的自动存储（变长数组），这是通过一个动态分配的内建函数实现的，该函数在运行时根据输入调整 `SP` 的值。该函数的结构如下：\n\n- 序言：通过将 `SP` 从 `$SP_0$` 更新为 `$SP_1 = SP_0 - F$` 来分配一个大小为 `$F$` 字节的固定大小帧。然后设置 `$FP \\leftarrow SP_1$`，并保持 `$FP$` 直到函数尾声部分都不变。\n- 函数体：在一个包含 $k$ 次迭代的循环中，每次迭代都执行一次可变大小的分配，在第 $i$ 次迭代中将 `SP` 的值改变 `$-d_i$`（其中 `$d_i > 0$` 且在编译时未知），然后执行一些可能触发寄存器溢出和重载的计算，最后通过将 `SP` 恢复到其先前的值来释放动态分配，为下一次迭代做准备。\n- 尾声：将 `SP` 恢复到 `$SP_0$` 并返回。\n\n假设在函数体的不同位置，寄存器分配器必须将一个值溢出到函数帧的一个槽位中，并在之后重新加载它。溢出指令必须引用一个在经历任何动态分配和释放序列后，无论当前 `SP` 值如何都有效的内存位置，并且不得违反 ABI 不变量，例如保持动态分配区域的内容和布局。\n\n从第一性原理出发，思考为帧的固定部分维护一个专用的 `$FP$` 所引入的不变量，以及由于动态分配导致的 `SP` 的可变性。设 `$A_{\\text{spill}}$` 表示溢出指令用于访问其内存槽位的有效地址。设 `$A_{\\text{dyn}}(t)$` 表示在函数内部，时间 `$t$` 时可变大小区域的顶部，并假设 `$SP(t)$` 反映了这种可变性，而 `$FP$` 在整个时间 `$t$` 内保持不变。\n\n在给定上述约束的情况下，以下哪种溢出槽管理策略能确保在动态帧增长时，溢出加载和存储操作仍然正确？\n\nA. 在活动记录的静态大小部分内预留一个固定的溢出区域，并使用相对于 `$FP$` 的操作数 `$A_{\\text{spill}} = FP + c$` 来寻址溢出，其中 $c$ 是在序言中选择的编译时常量；将可变大小的分配严格放置在该固定区域之下，以使 `$FP$` 在序言之后永不调整。\n\nB. 使溢出槽相对于 `SP` ，并在每次溢出和重载时，使用一个随时间变化的偏移量 `$c(t)$` 重新计算 `$A_{\\text{spill}} = SP + c(t)$`，该偏移量取决于当前活动的动态分配；让寄存器分配器将 `$SP(t)$` 作为虚拟寄存器进行跟踪，并在每个程序点发出适当的立即数。\n\nC. 在每次溢出前插入一次栈保存操作，并在溢出后立即进行栈恢复，以便在每次溢出和重载期间将 `SP` 临时重置为其序言值；使用相对于 `SP` 的寻址，其常量偏移量是为序言状态计算的。\n\nD. 依赖 ABI 提供的 `SP` 下方的保证“红色区域”（red zone），并将溢出槽放置在该红色区域中，假设中断或信号不会干扰它，并且动态分配不会与其重叠；使用相对于 `SP` 的寻址进入红色区域。\n\nE. 在按函数标识索引的线程局部存储中分配溢出槽，这样栈增长就不会影响它们的地址；让寄存器分配器将线程局部基址指针视作溢出基址。\n\n选择唯一的最佳选项。", "solution": "问题陈述经证实是科学合理的、定义明确的且客观的。它描述了编译器设计中的一个典型问题，该问题与存在动态栈分配（如 C 语言的 `alloca` 或变长数组）时的栈帧管理相关。所有给定的条件都是一致且充分的，足以从计算机体系结构和编译器构造的第一性原理推导出解决方案。\n\n**基于第一性原理的推导**\n\n核心要求是为寄存器溢出槽找到一种内存寻址方案，使得尽管栈指针 `$SP$` 在波动，但在整个函数执行期间都能提供一个稳定的地址。可用的寻址模式是“基址+立即数”，即 `[B + c]`，其中 `$B$` 是基址寄存器，$c$ 是一个编译时常量。\n\n问题定义了两个用于栈管理的主要指针寄存器：栈指针 `$SP$` 和帧指针 `$FP$`。\n1.  **栈指针, `$SP$`**: 根据定义，`$SP(t)$` 跟踪在时间 `$t$` 的栈顶。问题明确指出，`$SP$` 在运行时会被在编译时未知的量 (`$d_i$`) 修改。因此，从编译器的静态角度来看，`$SP$` 的值是动态且不可预测的。如果我们使用 `$SP$` 作为基址寄存器 `$B$`，操作数 `[SP + c]` 将引用内存地址 `$SP(t) + c$`。由于 `$SP(t)$` 会改变，这个表达式并不表示一个固定的内存位置。如果 `$SP(t_1) \\neq SP(t_2)$`，那么在时间 `$t_1$` 存储在地址 `$SP(t_1) + c$` 的值无法在稍后的时间 `$t_2$` 从 `$SP(t_2) + c$` 可靠地加载。因此，使用 `$SP$` 作为基址并带一个常量偏移量来访问帧中的固定槽位是根本错误的。\n\n2.  **帧指针, `$FP$`**: 问题指明，在函数序言中，`$FP$` 被设置为指向栈帧固定大小部分的基址 (`$FP \\leftarrow SP_1$`)，并且，关键的是，`$FP$` *在函数尾声之前保持不变*。这使得 `$FP$` 在整个函数体执行期间成为一个不变量。它作为活动记录的一个稳定锚点或参考点。\n\n基于这个不变量，我们可以将所有需要稳定地址的数据放置在固定大小的帧部分内，地址范围从 `$SP_1$` 到 `$SP_0 - 1 = SP_1 + F - 1$`。这包括固定大小的局部变量、保存的被调用者保存寄存器，以及对本问题最重要的寄存器溢出槽。任何这样的槽位都可以相对于稳定的 `$FP$` 进行寻址。地址 `$A_{\\text{spill}}$` 可以计算为 `$FP + c$`，其中 `$c$` 是一个指向固定帧内的编译时常量偏移量。由于 `$FP$` 是常量且 `$c$` 也是常量，有效地址 `$FP + c$` 在函数执行期间是恒定的。无论 `$SP$` 如何因在更低地址 (`$SP(t) \\le FP$`) 发生的动态分配而波动，对 `[FP + c]` 的溢出和加载操作都将始终访问同一个内存位置。\n\n这就确立了一个原则：使用一个不变的帧指针是管理同时包含固定大小和可变大小组件的栈帧的标准且正确的方法。\n\n**逐项分析**\n\n**A. 在活动记录的静态大小部分内预留一个固定的溢出区域，并使用相对于 `$FP$` 的操作数 `$A_{\\text{spill}} = FP + c$` 来寻址溢出，其中 $c$ 是在序言中选择的编译时常量；将可变大小的分配严格放置在该固定区域之下，以使 `$FP$` 在序言之后永不调整。**\n这个选项与从第一性原理得出的推论完全一致。它使用不变量 `$FP$` 作为基址寄存器，并使用一个编译时常量 `$c$` 作为偏移量。溢出槽被放置在帧的静态部分，这部分不会被发生在更低地址的动态分配所干扰。这是标准的教科书式解决方案。\n**结论：正确**\n\n**B. 使溢出槽相对于 `$SP$` ，并在每次溢出和重载时，使用一个随时间变化的偏移量 `$c(t)$` 重新计算 `$A_{\\text{spill}} = SP + c(t)$`，该偏移量取决于当前活动的动态分配；让寄存器分配器将 `$SP(t)$` 作为虚拟寄存器进行跟踪，并在每个程序点发出适当的立即数。**\n这个选项在多个方面存在缺陷。首先，它提出了一个随时间变化的偏移量 `$c(t)$`。问题明确地将寻址模式限制为 `[B + c]`，其中 `$c$` 是一个*编译时常量*。一个随时间变化的偏移量不能被编码为指令中的立即数，并且需要运行时计算，这可能需要额外的寄存器和指令，从而违反了指定的寻址模式。其次，即使可能，与使用提供的 `$FP$` 相比，这也是一种极为复杂和低效的方法。\n**结论：错误**\n\n**C. 在每次溢出前插入一次栈保存操作，并在溢出后立即进行栈恢复，以便在每次溢出和重载期间将 `$SP$` 临时重置为其序言值；使用相对于 `$SP$` 的寻址，其常量偏移量是为序言状态计算的。**\n这个策略试图使 `$SP$` 暂时稳定。在函数体中进行任何动态分配之前，`$SP$` 的“序言值”是 `$SP_1$`，它等于 `$FP$`。因此，这个选项通过执行一个类似如下的序列来有效地模拟相对于 `$FP$` 的寻址：保存当前 `$SP$`，设置 `$SP \\leftarrow FP$`，执行溢出/加载 `[SP + c]`，恢复旧的 `$SP$`。虽然这在功能上是可行的（它使得 `[SP + c]` 访问与 `[FP + c]` 相同的位置），但它极其低效，为每一次溢出和加载都增加了几条指令。鉴于选项 A 提供了一个直接的、单指令的解决方案，这不是“最佳”策略。\n**结论：错误**\n\n**D. 依赖 ABI 提供的 `$SP$` 下方的保证“红色区域”（red zone），并将溢出槽放置在该红色区域中，假设中断或信号不会干扰它，并且动态分配不会与其重叠；使用相对于 `$SP$` 的寻址进入红色区域。**\n“红色区域”（red zone）是当前 `$SP$` 下方的一小块区域，叶函数（leaf function）可以在不递减 `$SP$` 的情况下使用它。然而，所描述的函数不是叶函数，并且关键是，它执行了*明确改变 `$SP$`*的动态分配。当 `$SP$` 减少 `$d_i$` 时，旧的红色区域被消耗并成为已分配栈的一部分。相对于旧 `$SP$` 存储在旧红色区域中的任何数据，与新 `$SP$` 的偏移量将不同，并可能被覆盖。任何修改 `$SP$` 的操作都会使红色区域失效，这使得该策略对于本问题来说根本上是不可靠的。\n**结论：错误**\n\n**E. 在按函数标识索引的线程局部存储中分配溢出槽，这样栈增长就不会影响它们的地址；让寄存器分配器将线程局部基址指针视作溢出基址。**\n这种方法会提供一个稳定的内存地址，因为线程局部存储（TLS）不在栈上。然而，问题明确指出“ABI 要求被调用者保存的寄存器必须溢出到函数活动记录的内存中”。活动记录（或栈帧）位于栈上。TLS 是一个不同的内存段。因此，这个策略违反了问题的一个主要约束。与基于栈的溢出相比，它也是一个更重量级的机制，尤其是在考虑可重入性和递归时。\n**结论：错误**\n\n基于以上分析，选项 A 是在给定约束条件下唯一正确、高效且规范地解决该问题的方法。", "answer": "$$\\boxed{A}$$", "id": "3667841"}, {"introduction": "在复杂的程序中，当寄存器压力过大时，编译器往往有多个变量可以作为溢出对象。一个草率的选择可能导致显著的性能下降，特别是在频繁执行的代码路径上。本练习 [@problem_id:3667851] 介绍了一种更为先进的决策方法：利用性能剖析指导优化（Profile-Guided Optimization, PGO）数据来做出明智的选择。你将运用概率论的期望值概念，为不同的溢出候选变量计算其平均性能成本，从而体会数据驱动的启发式策略在现代编译器中的强大作用。", "problem": "一个为具有 $R$ 个体系结构寄存器的目标设计的编译器，在一个控制流图 (CFG) 上使用全局寄存器分配。在某个特定的程序点，活跃集的大小为 $L = R + 1$，因此必须有一个活跃范围被溢出到内存。程序结构是一个动态频繁的单多路分支（例如 switch 语句），它创建了3条不相交的、最终重新汇合的无环路径。对于函数的单次调用，基于性能剖析的路径概率分别为 $p_1 = \\frac{4}{5}$，$p_2 = \\frac{3}{20}$ 和 $p_3 = \\frac{1}{20}$，根据构造，它们满足 $p_1 + p_2 + p_3 = 1$。活性分析确定了三个候选活跃范围，记为 $v_A$、$v_B$ 和 $v_C$，从正确性的角度来看，它们都是同样可以溢出的。然而，由于使用密度的不同，它们的动态内存操作计数（由溢出和沿路径的后续重载引起的加载和存储的总和）因路径而异。设 $c_i(v)$ 表示如果活跃范围 $v \\in \\{v_A, v_B, v_C\\}$ 被溢出，在路径 $i \\in \\{1,2,3\\}$ 上执行的内存操作数。测量到的计数如下：\n$$\nc_1(v_A) = 30,\\quad c_2(v_A) = 2,\\quad c_3(v_A) = 1,\n$$\n$$\nc_1(v_B) = 18,\\quad c_2(v_B) = 6,\\quad c_3(v_B) = 6,\n$$\n$$\nc_1(v_C) = 10,\\quad c_2(v_C) = 12,\\quad c_3(v_C) = 12.\n$$\n假设一次函数调用以概率 $p_i$ 精确选择一条路径 $i$，并且在该路径上，所选择的溢出操作确定性地产生 $c_i(v)$ 次内存操作。一个路径概率加权的溢出启发式算法倾向于溢出那些由溢出引起的内存操作偏向于冷路径（执行频率较低的路径）的活跃范围。使用离散随机变量的期望定义，推导每个候选溢出的期望内存操作数，并选择在路径概率加权启发式算法下使期望最小化的候选者。作为对比，一个朴素的、路径无关的启发式算法会忽略性能剖析数据，并使用 3 条路径的均匀平均值来选择溢出对象。\n\n在每个启发式算法做出选择后，计算朴素启发式算法的期望内存操作数与路径概率加权启发式算法的期望内存操作数之比。将最终比率表示为单个实数。无需四舍五入。", "solution": "该问题已经过验证，被认为是编译器优化领域中一个有效且适定的问题。\n\n**已知条件：**\n- 体系结构寄存器数量: $R$。\n- 活跃集大小: $L = R + 1$。\n- 需要的溢出数量: $1$。\n- 不相交路径数量: $3$。\n- 路径概率: $p_1 = \\frac{4}{5}$, $p_2 = \\frac{3}{20}$, $p_3 = \\frac{1}{20}$。\n- 用于溢出的候选活跃范围: $v_A$, $v_B$, $v_C$。\n- 溢出候选 $v$ 在路径 $i$ 上的动态内存操作计数 $c_i(v)$:\n  - $c_1(v_A) = 30$, $c_2(v_A) = 2$, $c_3(v_A) = 1$。\n  - $c_1(v_B) = 18$, $c_2(v_B) = 6$, $c_3(v_B) = 6$。\n  - $c_1(v_C) = 10$, $c_2(v_C) = 12$, $c_3(v_C) = 12$。\n\n**问题陈述：**\n目标是计算由朴素的、路径无关的启发式算法做出的选择所导致的期望内存操作数，与由最优的、路径概率加权的启发式算法做出的选择所导致的期望内存操作数之比。\n\n**1. 路径概率加权启发式算法分析**\n\n该启发式算法选择使期望内存操作数最小化的溢出候选。溢出一个活跃范围 $v$ 的期望内存操作数，记为 $E[C(v)]$，计算方法是将在每条路径上的代价乘以采用该路径的概率，然后求和。公式为：\n$$E[C(v)] = \\sum_{i=1}^{3} p_i \\cdot c_i(v)$$\n\n我们为每个候选活跃范围（$v_A$、$v_B$、$v_C$）计算期望代价。为方便计算，我们注意到 $p_1 = \\frac{16}{20}$。\n\n对于候选 $v_A$：\n$$E[C(v_A)] = p_1 c_1(v_A) + p_2 c_2(v_A) + p_3 c_3(v_A) = \\left(\\frac{16}{20}\\right)(30) + \\left(\\frac{3}{20}\\right)(2) + \\left(\\frac{1}{20}\\right)(1)$$\n$$E[C(v_A)] = \\frac{480 + 6 + 1}{20} = \\frac{487}{20} = 24.35$$\n\n对于候选 $v_B$：\n$$E[C(v_B)] = p_1 c_1(v_B) + p_2 c_2(v_B) + p_3 c_3(v_B) = \\left(\\frac{16}{20}\\right)(18) + \\left(\\frac{3}{20}\\right)(6) + \\left(\\frac{1}{20}\\right)(6)$$\n$$E[C(v_B)] = \\frac{288 + 18 + 6}{20} = \\frac{312}{20} = 15.6$$\n\n对于候选 $v_C$：\n$$E[C(v_C)] = p_1 c_1(v_C) + p_2 c_2(v_C) + p_3 c_3(v_C) = \\left(\\frac{16}{20}\\right)(10) + \\left(\\frac{3}{20}\\right)(12) + \\left(\\frac{1}{20}\\right)(12)$$\n$$E[C(v_C)] = \\frac{160 + 36 + 12}{20} = \\frac{208}{20} = 10.4$$\n\n比较期望代价：$E[C(v_C)] = 10.4  E[C(v_B)] = 15.6  E[C(v_A)] = 24.35$。\n路径概率加权启发式算法选择具有最小期望代价的候选者，即 $v_C$。此最优选择的期望内存操作数为 $E_{\\text{opt}} = E[C(v_C)] = 10.4$。\n\n**2. 朴素路径无关启发式算法分析**\n\n该启发式算法忽略给定的路径概率，而是使用 3 条路径的均匀平均值。这等同于假设一个均匀概率分布，其中 $p'_1 = p'_2 = p'_3 = \\frac{1}{3}$。该启发式算法为每个候选计算平均代价 $Avg(v)$：\n$$Avg(v) = \\frac{1}{3} \\sum_{i=1}^{3} c_i(v) = \\frac{c_1(v) + c_2(v) + c_3(v)}{3}$$\n\n对于候选 $v_A$：\n$$Avg(v_A) = \\frac{30 + 2 + 1}{3} = \\frac{33}{3} = 11$$\n\n对于候选 $v_B$：\n$$Avg(v_B) = \\frac{18 + 6 + 6}{3} = \\frac{30}{3} = 10$$\n\n对于候选 $v_C$：\n$$Avg(v_C) = \\frac{10 + 12 + 12}{3} = \\frac{34}{3} \\approx 11.33$$\n\n比较平均代价：$Avg(v_B) = 10  Avg(v_A) = 11  Avg(v_C) \\approx 11.33$。\n朴素启发式算法选择具有最小平均代价的候选者，即 $v_B$。\n\n问题要求的是由朴素启发式算法的选择所导致的*实际*期望内存操作数。为了得到这个值，我们必须使用实际的路径概率（$p_1, p_2, p_3$）来评估溢出 $v_B$ 的真实期望代价。这个值在第一部分已经计算过了。\n朴素启发式算法所做选择的期望代价是 $E_{\\text{naive\\_choice}} = E[C(v_B)] = 15.6$。\n\n**3. 计算比率**\n\n最后一步是计算朴素启发式算法的期望代价与路径概率加权启发式算法的期望代价之比。\n$$\\text{Ratio} = \\frac{E_{\\text{naive\\_choice}}}{E_{\\text{opt}}}$$\n$$\\text{Ratio} = \\frac{15.6}{10.4}$$\n\n为了精确计算，我们使用前面推导出的分数形式：\n$$E_{\\text{naive\\_choice}} = E[C(v_B)] = \\frac{312}{20}$$\n$$E_{\\text{opt}} = E[C(v_C)] = \\frac{208}{20}$$\n$$\\text{Ratio} = \\frac{312/20}{208/20} = \\frac{312}{208}$$\n我们可以简化这个分数：\n$$\\frac{312}{208} = \\frac{156}{104} = \\frac{78}{52} = \\frac{39}{26} = \\frac{3}{2}$$\n作为实数，该比率为 $1.5$。这表明，与最优的、基于性能剖析的启发式算法所做的选择相比，朴素启发式算法所做的选择预计会多产生 $50\\%$ 的内存操作。", "answer": "$$\\boxed{1.5}$$", "id": "3667851"}]}