{"hands_on_practices": [{"introduction": "本练习是检验和巩固活跃度分析与干扰图构建核心技能的基础。您需要面对一段包含条件分支和汇合点的代码，通过系统地反向数据流分析，精确计算出在每个程序点上的活跃变量集合。通过这个过程，您将能够构建出正确的干扰图，并与一个给定的、存在缺陷的图进行对比，从而找出其中缺失的干扰边 ([@problem_id:3647421])。这个练习旨在磨练您在复杂控制流下进行精确分析的能力。", "problem": "编译器后端通过在控制流图（CFG; Control Flow Graph）上进行活性分析来为寄存器分配构建冲突图。当且仅当两个程序变量的活跃范围在某个程序点重叠时，它们之间存在冲突，这意味着根据非静态单赋值（non-SSA; Static Single Assignment）形式下的标准活性定义，它们同时处于活跃状态。\n\n考虑以下命令式程序，它包含四个基本块（Basic Block; BB），并带有行号和分支标签的注释。该程序使用赋值语句和一个条件分支。每个赋值语句 $v := \\text{expr}$ 定义了左侧变量 $v$ 并使用了出现在 $\\text{expr}$ 中的所有变量。程序中没有函数调用、没有别名，也没有除赋值语句所隐含的之外的内存副作用。\n\n块 $B_{1}$：\n- 行 $1$: $d := a + 1$\n- 行 $2$: $b := d + c$\n- 行 $3$: $x := b + e$\n- 行 $4$: if (x > m) goto $B_{2}$ else goto $B_{3}$\n\n块 $B_{2}$ （当行 $4$ 的条件为真时进入）：\n- 行 $5$: $y := x + c$\n- 行 $6$: $t := y + n$\n- 行 $7$: $b := t + a$\n- 行 $8$: goto $B_{4}$\n\n块 $B_{3}$ （当行 $4$ 的条件为假时进入）：\n- 行 $9$: $y := m + c$\n- 行 $10$: $x := y + a$\n- 行 $11$: $t := x + p$\n- 行 $12$: goto $B_{4}$\n\n块 $B_{4}$ （汇合块）：\n- 行 $13$: $z := x + y$\n- 行 $14$: $r := z + b$\n- 行 $15$: return $r$\n\n假设在构建图时只考虑临时变量 $\\{b, x, y, t, z\\}$；所有其他标识符（$a, c, d, e, m, n, p, r$）被视为外部值或预着色寄存器，不作为冲突图的节点。编译器声称的、基于节点 $\\{b, x, y, t, z\\}$ 的冲突图 $G$ 当前仅包含以下边\n$$\n\\{(t,x),\\ (t,y),\\ (z,b)\\}.\n$$\n\n根据标准的非 SSA 活性定义，一个变量在某个程序点是活跃的，当且仅当存在一条从该点到该变量的后续使用的路径，并且在该路径上该变量没有被重新定义。当且仅当存在至少一个程序点，使得两个变量同时处于活跃状态，则它们之间存在冲突。\n\n你的任务是：重新计算 $x$ 和 $y$ 同时活跃的程序点的活性，确定因此必须存在的所有涉及 $x$ 和 $y$ 的冲突边，并与图 $G$ 中给出的边进行比较。计算图 $G$ 相对于由 $\\{b, x, y, t, z\\}$ 导出的正确冲突图所缺失的边的数量，结果为一个整数。请以精确整数形式表示最终答案；无需四舍五入。", "solution": "该问题是有效的，因为它科学地基于编译器理论的原理，特别是活性分析和冲突图构建。它定义明确、客观，并提供了推导唯一解所需的所有信息。\n\n任务是确定变量集合 $\\{b, x, y, t, z\\}$ 的正确冲突图，并找出给定图 $G$ 中缺失的边的数量。如果两个变量在任何程序点同时活跃，则它们之间存在冲突。一个变量在某个点是活跃的，如果存在从该点到该变量的一次使用的路径，且该路径不被对该变量的重定义所截断。\n\n分析过程是通过从程序末尾开始向后计算每条指令入口和出口处的活跃变量集合来进行的。控制流图（CFG）以块 $B_1$ 为入口，它分支到 $B_2$ 和 $B_3$。$B_2$ 和 $B_3$ 都分支到汇合块 $B_4$，即出口块。\n\n令 $\\text{LiveAfter}(i)$ 为紧跟在指令 $i$ 之后的活跃变量集合。对于一条指令 $i$，$\\text{def}(i)$ 是它定义的变量集合，$\\text{use}(i)$ 是它使用的变量集合。紧接在指令 $i$ 之前的活跃变量集合由标准数据流方程给出：\n$$\n\\text{LiveBefore}(i) = \\text{use}(i) \\cup (\\text{LiveAfter}(i) - \\text{def}(i))\n$$\n$\\text{def}(i)$ 中的任何变量都与 $\\text{LiveAfter}(i)$ 中的每个变量冲突。此外，同一 $\\text{LiveAfter}(i)$ 集合中的任意两个变量也相互冲突。我们将为每条指令计算这些集合，只考虑我们关心的变量：$\\{b, x, y, t, z\\}$。\n\n分析从程序的末尾开始。在最后一条指令（行 $15$）之后，没有变量是活跃的。\n$\\text{LiveAfter}(15) = \\emptyset$。\n\n**块 $B_4$（行 $13$-$15$）：**\n- **行 $15$: `return r`**：`def(15) = \\emptyset`, `use(15) = \\emptyset`（变量 $r$ 不在我们的集合中）。\n$\\text{LiveBefore}(15) = \\emptyset \\cup (\\emptyset - \\emptyset) = \\emptyset$。\n- **行 $14$: `r := z + b`**：`def(14) = \\emptyset`, `use(14) = \\{z, b\\}$。\n$\\text{LiveAfter}(14) = \\text{LiveBefore}(15) = \\emptyset$。\n$\\text{LiveBefore}(14) = \\{z, b\\} \\cup (\\emptyset - \\emptyset) = \\{z, b\\}$。\n- **行 $13$: `z := x + y`**：`def(13) = \\{z\\}$, `use(13) = \\{x, y\\}$。\n$\\text{LiveAfter}(13) = \\text{LiveBefore}(14) = \\{z, b\\}$。在这个程序点，变量 $z$ 和 $b$ 同时活跃。这意味着存在一条冲突边 $(z, b)$。$z$ 的定义也与行 $13$ 之后活跃的其他变量（这里只有 $b$）冲突。这确认了边 **$(z, b)$**。\n$\\text{LiveBefore}(13) = \\{x, y\\} \\cup (\\{z, b\\} - \\{z\\}) = \\{x, y, b\\}$。这是在块 $B_4$ 入口处活跃的变量集合。\n\n在 $B_4$ 入口处的活跃变量集合 $\\text{Live}_{\\text{in}}(B_4)$ 是 $\\{x, y, b\\}$。由于 $B_4$ 是 $B_2$ 和 $B_3$ 的后继块，我们有 $\\text{Live}_{\\text{out}}(B_2) = \\text{Live}_{\\text{out}}(B_3) = \\text{Live}_{\\text{in}}(B_4) = \\{x, y, b\\}$。\n\n**块 $B_3$（行 $9$-$12$）：**\n我们从块的末尾开始向后分析，此处的活跃集合是 $\\text{Live}_{\\text{out}}(B_3) = \\{x, y, b\\}$。\n- **行 $12$: `goto B4`**：`def(12) = \\emptyset`, `use(12) = \\emptyset$。\n$\\text{LiveAfter}(12) = \\{x, y, b\\}$。\n$\\text{LiveBefore}(12) = \\emptyset \\cup (\\{x, y, b\\} - \\emptyset) = \\{x, y, b\\}$。\n- **行 $11$: `t := x + p`**：`def(11) = \\{t\\}$, `use(11) = \\{x\\}$。\n一个关键的观察是，在行 $11$ 定义的变量 $t$ 之后再也没有被使用过。根据活性定义，这个 $t$ 的实例是一个死变量；它的活跃范围是空的。因此，它不能与任何其他变量冲突。\n$\\text{LiveAfter}(11) = \\text{LiveBefore}(12) = \\{x, y, b\\}$。此时，变量 $x$、$y$ 和 $b$ 同时活跃。这意味着存在冲突边 **$(x, y)$**、**$(x, b)$** 和 **$(y, b)$**。\n$\\text{LiveBefore}(11) = \\{x\\} \\cup (\\{x, y, b\\} - \\{t\\}) = \\{x, y, b\\}$。\n- **行 $10$: `x := y + a`**：`def(10) = \\{x\\}$, `use(10) = \\{y\\}$。\n$\\text{LiveAfter}(10) = \\text{LiveBefore}(11) = \\{x, y, b\\}$。$x$ 的定义与此集合中的其他变量 $\\{y, b\\}$ 冲突。这确认了边 **$(x, y)$** 和 **$(x, b)$**。\n$\\text{LiveBefore}(10) = \\{y\\} \\cup (\\{x, y, b\\} - \\{x\\}) = \\{y, b\\}$。\n- **行 $9$: `y := m + c`**：`def(9) = \\{y\\}$, `use(9) = \\emptyset$。\n$\\text{LiveAfter}(9) = \\text{LiveBefore}(10) = \\{y, b\\}$。此时，$y$ 和 $b$ 是活跃的，意味着存在边 **$(y, b)$**。$y$ 的定义与 $b$ 冲突。\n$\\text{LiveBefore}(9) = \\emptyset \\cup (\\{y, b\\} - \\{y\\}) = \\{b\\}$。这是 $\\text{Live}_{\\text{in}}(B_3)$。\n\n**块 $B_2$（行 $5$-$8$）：**\n我们从块的末尾开始向后分析，此处的活跃集合是 $\\text{Live}_{\\text{out}}(B_2) = \\{x, y, b\\}$。\n- **行 $8$: `goto B4`**：\n$\\text{LiveAfter}(8) = \\{x, y, b\\}$。活跃变量意味着存在边 **$(x, y)$**、**$(x, b)$** 和 **$(y, b)$**。\n$\\text{LiveBefore}(8) = \\{x, y, b\\}$。\n- **行 $7$: `b := t + a`**：`def(7) = \\{b\\}$, `use(7) = \\{t\\}$。\n$\\text{LiveAfter}(7) = \\text{LiveBefore}(8) = \\{x, y, b\\}$。$b$ 的定义与 $\\{x, y\\}$ 冲突。这产生了边 **$(b, x)$** 和 **$(b, y)$**。\n$\\text{LiveBefore}(7) = \\{t\\} \\cup (\\{x, y, b\\} - \\{b\\}) = \\{t, x, y\\}$。\n- **行 $6$: `t := y + n`**：`def(6) = \\{t\\}$, `use(6) = \\{y\\}$。\n$\\text{LiveAfter}(6) = \\text{LiveBefore}(7) = \\{t, x, y\\}$。此时，$t$、$x$ 和 $y$ 同时活跃，意味着存在边 **$(t, x)$**、**$(t, y)$** 和 **$(x, y)$**。\n$\\text{LiveBefore}(6) = \\{y\\} \\cup (\\{t, x, y\\} - \\{t\\}) = \\{x, y\\}$。\n- **行 $5$: `y := x + c`**：`def(5) = \\{y\\}$, `use(5) = \\{x\\}$。\n$\\text{LiveAfter}(5) = \\text{LiveBefore}(6) = \\{x, y\\}$。这意味着存在边 **$(x, y)$**。\n$\\text{LiveBefore}(5) = \\{x\\} \\cup (\\{x, y\\} - \\{y\\}) = \\{x\\}$。这是 $\\text{Live}_{\\text{in}}(B_2)$。\n\n**块 $B_1$（行 $1$-$4$）：**\n在 $B_1$ 出口处的活跃变量集合是 $\\text{Live}_{\\text{out}}(B_1) = \\text{Live}_{\\text{in}}(B_2) \\cup \\text{Live}_{\\text{in}}(B_3) = \\{x\\} \\cup \\{b\\} = \\{x, b\\}$。\n- **行 $4$: `if (x > m) ...`**：`def(4) = \\emptyset`, `use(4) = \\{x\\}$。\n$\\text{LiveAfter}(4) = \\{x, b\\}$。此时，$x$ 和 $b$ 是活跃的，意味着存在一条边 **$(x, b)$**。\n$\\text{LiveBefore}(4) = \\{x\\} \\cup (\\{x, b\\} - \\emptyset) = \\{x, b\\}$。\n- **行 $3$: `x := b + e`**：`def(3) = \\{x\\}$, `use(3) = \\{b\\}$。\n$\\text{LiveAfter}(3) = \\text{LiveBefore}(4) = \\{x, b\\}$。$x$ 的定义与 $b$ 冲突，确认了边 **$(x, b)$**。\n$\\text{LiveBefore}(3) = \\{b\\} \\cup (\\{x, b\\} - \\{x\\}) = \\{b\\}$。\n- **行 $2$: `b := d + c`**：`def(2) = \\{b\\}$, `use(2) = \\emptyset$。\n$\\text{LiveAfter}(2) = \\text{LiveBefore}(3) = \\{b\\}$。没有冲突。\n$\\text{LiveBefore}(2) = \\emptyset \\cup (\\{b\\} - \\{b\\}) = \\emptyset$。\n- **行 $1$: `d := a + 1`**：不涉及我们集合中的任何变量。$\\text{LiveBefore}(1) = \\emptyset$。\n\n**合并边：**\n我们收集所有已识别的唯一冲突边：\n1. $(z, b)$，也可写作 $(b, z)$。\n2. $(x, y)$。\n3. $(x, b)$，也可写作 $(b, x)$。\n4. $(y, b)$，也可写作 $(b, y)$。\n5. $(t, x)$。\n6. $(t, y)$。\n\n正确冲突图中的完整边集合是 $E_{\\text{correct}} = \\{(b, z), (x, y), (x, b), (y, b), (t, x), (t, y)\\}$。\n正确边的数量是 $|E_{\\text{correct}}| = 6$。\n\n**与给定图的比较：**\n问题陈述给定的冲突图 $G$ 包含边 $E_{\\text{given}} = \\{(t,x), (t,y), (z,b)\\}$。\n为了找到缺失的边，我们计算集合差 $E_{\\text{correct}} - E_{\\text{given}}$。\n$$\nE_{\\text{missing}} = \\{(b, z), (x, y), (x, b), (y, b), (t, x), (t, y)\\} - \\{(t, x), (t, y), (z, b)\\}\n$$\n$E_{\\text{correct}}$ 中存在但 $E_{\\text{given}}$ 中不存在的边是：\n- $(x, y)$\n- $(x, b)$\n- $(y, b)$\n\n缺失边的数量是该集合的基数，即 $3$。", "answer": "$$\n\\boxed{3}\n$$", "id": "3647421"}, {"introduction": "循环是程序中常见的结构，它为活跃度分析带来了独特的挑战。本练习将通过一个精心设计的例子，揭示一个关键原则：在循环之后被使用的变量，其活跃范围必须贯穿整个循环体。您将通过分析发现，即使某些变量未在循环体内直接使用，它们仍会与循环内的变量产生干扰，因为它们需要在循环结束后保持活跃 ([@problem_id:3647442])。理解这一点对于处理真实世界代码中的寄存器分配至关重要。", "problem": "编译器后端通过构建一个冲突图来执行寄存器分配，该图的顶点是程序变量，其无向边连接在某个程序点上同时活跃的变量对。在经典的活性数据流框架中，基本定义如下：对于每个语句 $s$，其入口活跃变量集 $\\mathrm{IN}[s]$ 和出口活跃变量集 $\\mathrm{OUT}[s]$ 满足\n$$\n\\mathrm{IN}[s] = \\mathrm{USE}[s] \\cup \\left( \\mathrm{OUT}[s] \\setminus \\mathrm{DEF}[s] \\right), \\quad \\mathrm{OUT}[s] = \\bigcup_{s' \\in \\mathrm{succ}(s)} \\mathrm{IN}[s'],\n$$\n其中 $\\mathrm{USE}[s]$ 和 $\\mathrm{DEF}[s]$ 分别是在语句 $s$ 中读取和写入的变量集合，$\\mathrm{succ}(s)$ 是其在控制流图（CFG）中的后继集合。\n\n考虑以下带有单个循环的线性三地址代码，它由带标签的语句和基本块写成。所有变量都是标量临时变量。唯一的控制流如所示，没有函数调用或别名。该程序被设计成仅由于在循环出口处活跃的变量而出现冲突。\n\n基本块和语句：\n- 循环前置区：\n  - 行 $1$：$u \\leftarrow 0$\n  - 行 $2$：$v \\leftarrow 1$\n  - 行 $3$：$w \\leftarrow \\mathrm{input}()$\n  - 行 $4$：goto $L$\n- 循环头 $L$：\n  - 行 $5$：if ($w \\leq 0$) goto $E$ else goto $B$\n- 循环体 $B$：\n  - 行 $6$：$w \\leftarrow w - 1$\n  - 行 $7$：goto $L$\n- 出口 $E$：\n  - 行 $8$：$x \\leftarrow u + w$\n  - 行 $9$：$y \\leftarrow v + w$\n  - 行 $10$：$z \\leftarrow x + y$\n\n假设CFG的后继如下：$\\mathrm{succ}(1)=\\{2\\}$, $\\mathrm{succ}(2)=\\{3\\}$, $\\mathrm{succ}(3)=\\{4\\}$, $\\mathrm{succ}(4)=\\{5\\}$, $\\mathrm{succ}(5)=\\{8,6\\}$, $\\mathrm{succ}(6)=\\{7\\}$, $\\mathrm{succ}(7)=\\{5\\}$, $\\mathrm{succ}(8)=\\{9\\}$, $\\mathrm{succ}(9)=\\{10\\}$, $\\mathrm{succ}(10)=\\emptyset$。$\\mathrm{USE}$ 和 $\\mathrm{DEF}$ 集合为：$\\mathrm{DEF}[1]=\\{u\\}$, $\\mathrm{DEF}[2]=\\{v\\}$, $\\mathrm{DEF}[3]=\\{w\\}$, $\\mathrm{DEF}[6]=\\{w\\}$, $\\mathrm{DEF}[8]=\\{x\\}$, $\\mathrm{DEF}[9]=\\{y\\}$, $\\mathrm{DEF}[10]=\\{z\\}$。非空的 $\\mathrm{USE}$ 集合为：$\\mathrm{USE}[5]=\\{w\\}$, $\\mathrm{USE}[6]=\\{w\\}$, $\\mathrm{USE}[8]=\\{u,w\\}$, $\\mathrm{USE}[9]=\\{v,w\\}$, $\\mathrm{USE}[10]=\\{x,y\\}$。\n\n使用上述定义，计算活性集合直至达到不动点。然后，根据标准的边生成规则构建冲突图：对于语句 $s$ 处的每个非移动赋值 $a \\leftarrow \\cdots$，添加连接 $a$ 和 $\\mathrm{OUT}[s]$ 中除 $a$ 自身以外的每个变量的无向边。最后，确定冲突图中不同边的总数。将该数字作为你的最终答案。无需四舍五入。答案没有物理单位。", "solution": "用户提供的问题是一个关于活性分析和冲突图构建的明确定义的练习，植根于编译器设计原则。所有必要的组成部分——代码、控制流图（CFG）后继、USE/DEF集合以及形式化定义——都已提供且内部一致。该问题在科学上是合理的、客观的且定义良好的。因此，该问题是有效的，并且可以推导出一个完整的解。\n\n求解过程分为两个主要阶段：\n1. 通过迭代数据流方程直到达到不动点，计算每个语句 $s$ 的入口活跃变量集（$\\mathrm{IN}[s]$）和出口活跃变量集（$\\mathrm{OUT}[s]$）。\n2. 对代码中的每个定义，应用指定的边生成规则，使用计算出的出口活跃变量集来构建冲突图。\n\n活性分析的数据流方程如下：\n$$\n\\mathrm{IN}[s] = \\mathrm{USE}[s] \\cup \\left( \\mathrm{OUT}[s] \\setminus \\mathrm{DEF}[s] \\right)\n$$\n$$\n\\mathrm{OUT}[s] = \\bigcup_{s' \\in \\mathrm{succ}(s)} \\mathrm{IN}[s']\n$$\n程序中的变量为 $u, v, w, x, y, z$。该分析是一种反向数据流分析，意味着我们将活性信息从语句的后继传回该语句本身。我们将所有的 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集合初始化为空集 $\\emptyset$，并进行迭代直到没有集合发生变化。\n\n提供的 USE 和 DEF 集合如下：\n- $\\mathrm{USE}[1]=\\emptyset, \\mathrm{DEF}[1]=\\{u\\}$\n- $\\mathrm{USE}[2]=\\emptyset, \\mathrm{DEF}[2]=\\{v\\}$\n- $\\mathrm{USE}[3]=\\emptyset, \\mathrm{DEF}[3]=\\{w\\}$\n- $\\mathrm{USE}[4]=\\emptyset, \\mathrm{DEF}[4]=\\emptyset$\n- $\\mathrm{USE}[5]=\\{w\\}, \\mathrm{DEF}[5]=\\emptyset$\n- $\\mathrm{USE}[6]=\\{w\\}, \\mathrm{DEF}[6]=\\{w\\}$\n- $\\mathrm{USE}[7]=\\emptyset, \\mathrm{DEF}[7]=\\emptyset$\n- $\\mathrm{USE}[8]=\\{u,w\\}, \\mathrm{DEF}[8]=\\{x\\}$\n- $\\mathrm{USE}[9]=\\{v,w\\}, \\mathrm{DEF}[9]=\\{y\\}$\n- $\\mathrm{USE}[10]=\\{x,y\\}, \\mathrm{DEF}[10]=\\{z\\}$\n\n后继 $\\mathrm{succ}(s)$ 在问题描述中给出。分析过程如下，迭代进行直至达到不动点。\n\n在迭代不动点计算收敛后，最终的活性集合为：\n- 语句 $1$：$\\mathrm{OUT}[1] = \\{u\\}$，$\\mathrm{IN}[1] = \\emptyset$\n- 语句 $2$：$\\mathrm{OUT}[2] = \\{u, v\\}$，$\\mathrm{IN}[2] = \\{u\\}$\n- 语句 $3$：$\\mathrm{OUT}[3] = \\{u, v, w\\}$，$\\mathrm{IN}[3] = \\{u, v\\}$\n- 语句 $4$：$\\mathrm{OUT}[4] = \\{u, v, w\\}$，$\\mathrm{IN}[4] = \\{u, v, w\\}$\n- 语句 $5$：$\\mathrm{OUT}[5] = \\{u, v, w\\}$，$\\mathrm{IN}[5] = \\{u, v, w\\}$\n- 语句 $6$：$\\mathrm{OUT}[6] = \\{u, v, w\\}$，$\\mathrm{IN}[6] = \\{u, v, w\\}$\n- 语句 $7$：$\\mathrm{OUT}[7] = \\{u, v, w\\}$，$\\mathrm{IN}[7] = \\{u, v, w\\}$\n- 语句 $8$：$\\mathrm{OUT}[8] = \\{v, w, x\\}$，$\\mathrm{IN}[8] = \\{u, v, w\\}$\n- 语句 $9$：$\\mathrm{OUT}[9] = \\{x, y\\}$，$\\mathrm{IN}[9] = \\{v, w, x\\}$\n- 语句 $10$：$\\mathrm{OUT}[10] = \\emptyset$，$\\mathrm{IN}[10] = \\{x, y\\}$\n\n确定了最终的活性集合后，我们构建冲突图。规则是：对于语句 $s$ 处的每个非移动赋值 $a \\leftarrow \\dots$，在 $a$ 和 $\\mathrm{OUT}[s] \\setminus \\{a\\}$ 中的每个变量之间添加一条无向边。定义语句是 $1, 2, 3, 6, 8, 9, 10$。\n\n1.  **语句 $1$**：$u \\leftarrow 0$。这里，$a=u$ 且 $s=1$。冲突变量的集合是 $\\mathrm{OUT}[1] \\setminus \\{u\\} = \\{u\\} \\setminus \\{u\\} = \\emptyset$。不添加任何边。\n\n2.  **语句 $2$**：$v \\leftarrow 1$。这里，$a=v$ 且 $s=2$。冲突变量的集合是 $\\mathrm{OUT}[2] \\setminus \\{v\\} = \\{u, v\\} \\setminus \\{v\\} = \\{u\\}$。添加一条边 $\\{u, v\\}$。\n\n3.  **语句 $3$**：$w \\leftarrow \\mathrm{input}()$。这里，$a=w$ 且 $s=3$。冲突变量的集合是 $\\mathrm{OUT}[3] \\setminus \\{w\\} = \\{u, v, w\\} \\setminus \\{w\\} = \\{u, v\\}$。添加边 $\\{u, w\\}$ 和 $\\{v, w\\}$。\n\n4.  **语句 $6$**：$w \\leftarrow w-1$。这里，$a=w$ 且 $s=6$。冲突变量的集合是 $\\mathrm{OUT}[6] \\setminus \\{w\\} = \\{u, v, w\\} \\setminus \\{w\\} = \\{u, v\\}$。添加边 $\\{u, w\\}$ 和 $\\{v, w\\}$。这些与语句 $3$ 生成的边相同。\n\n5.  **语句 $8$**：$x \\leftarrow u+w$。这里，$a=x$ 且 $s=8$。冲突变量的集合是 $\\mathrm{OUT}[8] \\setminus \\{x\\} = \\{v, w, x\\} \\setminus \\{x\\} = \\{v, w\\}$。添加边 $\\{v, x\\}$ 和 $\\{w, x\\}$。\n\n6.  **语句 $9$**：$y \\leftarrow v+w$。这里，$a=y$ 且 $s=9$。冲突变量的集合是 $\\mathrm{OUT}[9] \\setminus \\{y\\} = \\{x, y\\} \\setminus \\{y\\} = \\{x\\}$。添加一条边 $\\{x, y\\}$。\n\n7.  **语句 $10$**：$z \\leftarrow x+y$。这里，$a=z$ 且 $s=10$。冲突变量的集合是 $\\mathrm{OUT}[10] \\setminus \\{z\\} = \\emptyset \\setminus \\{z\\} = \\emptyset$。不添加任何边。\n\n收集所有生成的不同边：\n- 来自语句 $2$：$\\{u, v\\}$\n- 来自语句 $3$：$\\{u, w\\}$, $\\{v, w\\}$\n- 来自语句 $8$：$\\{v, x\\}$, $\\{w, x\\}$\n- 来自语句 $9$：$\\{x, y\\}$\n\n冲突图中的所有不同的无向边集合是：\n1.  $\\{u, v\\}$\n2.  $\\{u, w\\}$\n3.  $\\{v, w\\}$\n4.  $\\{v, x\\}$\n5.  $\\{w, x\\}$\n6.  $\\{x, y\\}$\n\n计算这些不同的边，总数为 $6$。变量 $z$ 不与任何其他变量冲突，因为它在任何其他变量被定义的点都不是活跃的，并且在定义 $z$ 的语句的出口处也没有其他变量是活跃的。", "answer": "$$\n\\boxed{6}\n$$", "id": "3647442"}, {"introduction": "在反向的活跃度分析中，为什么在控制流的汇合点必须使用集合的“并集”而非“交集”？这个练习通过一个假设的错误分析场景，让您深入探究数据流方程背后的理论依据。您将对比错误方法（使用交集）与正确方法（使用并集）所产生的不同干扰图，从而直观地理解数据流方程定义的严谨性及其对寄存器分配结果的决定性影响 ([@problem_id:3647411])。这个实践旨在加深您对活跃度分析理论基础的认识。", "problem": "一个编译器后端通过对一个根据控制流图（CFG）上的活跃度信息构建的干涉图进行图着色来实现寄存器分配。考虑以下带有条件分支和汇合点的线性代码，其以带标签指令的基本块形式写出。赋值用 $:=$ 表示。该 CFG 有从 $B_1$ 的末尾到 $B_2$ 和 $B_3$ 的开头的边，从 $B_2$ 和 $B_3$ 的末尾到 $B_4$ 的开头的边，并且 $B_4$ 顺序执行至一条返回语句。\n\n基本块：\n- $B_1$:\n  - 指令 $1$: $u := x + y$\n  - 指令 $2$: 如果 $u > 0$ 跳转到 $B_2$ 否则 $B_3$\n- $B_2$:\n  - 指令 $3$: $v := u + z$\n  - 指令 $4$: $w := v + 1$\n  - 指令 $5$: 跳转到 $B_4$\n- $B_3$:\n  - 指令 $6$: $v := u + 1$\n  - 指令 $7$: $w := v + y$\n  - 指令 $8$: 跳转到 $B_4$\n- $B_4$:\n  - 指令 $9$: $x := w + 1$\n  - 指令 $10$: 返回 $x$\n\n假设变量 $x$、$y$ 和 $z$ 在进入 $B_1$ 时是活跃的，并且除了明确显示的使用外，没有其他外部使用。干涉图 $G = (V,E)$ 对 $\\{x,y,z,u,v,w\\}$ 中的每个变量都有一个顶点，并且只要变量 $a$ 和 $b$ 因为在某个程序点上同时活跃而不能被分配到同一个寄存器，就存在一条无向边 $\\{a,b\\} \\in E$。这遵循标准的指令级干涉构建规则：对于每个定义变量 $d$ 的指令，在 $d$ 和该指令之后紧邻的出口活跃集中的每个变量之间添加边。\n\n一位队友进行了一次错误的活跃度分析，他在计算指令 $2$ 中条件语句的出口活跃集时，错误地使用了后继的集合交集而不是集合并集。具体来说，在指令 $2$ 产生的汇合点处，他们设置了\n$$\\mathrm{live\\_out}[2] = \\mathrm{live\\_in}[3] \\cap \\mathrm{live\\_in}[6],$$\n然后使用上述规则构建了一个干涉图 $G_f = (V,E_f)$。他们报告说 $E_f$ 只包含边 $\\{v,y\\}$。\n\n使用正确的指令级活跃度反向数据流方程和上面陈述的干涉边构建规则，确定缺失边的确切数量，即计算整数值 $|E \\setminus E_f|$。请以单个整数形式提供您的答案。不要四舍五入。", "solution": "所述问题是有效的。它在编译器构建领域，特别是活跃度分析和干涉图生成方面，呈现了一个定义明确的场景。所有必要的数据，包括代码、控制流图（CFG）结构、初始活跃度条件以及构建图的具体规则，都已提供。任务是比较一个正确构建的图和一个错误的图，并量化它们之间的差异。\n\n问题的核心在于应用反向数据流分析的原则来确定程序中各个点的活跃变量集，然后使用指定的规则来构建干涉图。我们必须首先进行一次正确的活跃度分析，然后重现错误的分析，为这两种情况构建相应的干涉图，最后计算错误图中缺失的边的数量。\n\n涉及的变量为 $V = \\{x, y, z, u, v, w\\}$。CFG 由基本块及其连接定义。\n\n首先，我们建立活跃度分析的数据流方程。对于一条指令 $i$，令 $\\mathrm{use}[i]$ 为 $i$ 使用的变量集合，$\\mathrm{def}[i]$ 为 $i$ 定义的变量集合。入口活跃集和出口活跃集的关系如下：\n$$ \\mathrm{live\\_in}[i] = \\mathrm{use}[i] \\cup (\\mathrm{live\\_out}[i] \\setminus \\mathrm{def}[i]) $$\n$$ \\mathrm{live\\_out}[i] = \\bigcup_{s \\in \\mathrm{succ}(i)} \\mathrm{live\\_in}[s] $$\n其中 $\\mathrm{succ}(i)$ 是指令 $i$ 的后继指令集合。我们从程序的末尾开始分析，由于程序在指令 $10$ 后返回，因此 $\\mathrm{live\\_out}[10] = \\emptyset$。\n\n让我们执行正确的反向活跃度分析。\n\n1.  **指令 $10$**: 返回 $x$\n    *   $\\mathrm{use}[10] = \\{x\\}$, $\\mathrm{def}[10] = \\emptyset$。\n    *   $\\mathrm{live\\_out}[10] = \\emptyset$。\n    *   $\\mathrm{live\\_in}[10] = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}$。\n\n2.  **指令 $9$**: $x := w + 1$\n    *   $\\mathrm{use}[9] = \\{w\\}$, $\\mathrm{def}[9] = \\{x\\}$, $\\mathrm{succ}(9) = \\{10\\}$。\n    *   $\\mathrm{live\\_out}[9] = \\mathrm{live\\_in}[10] = \\{x\\}$。\n    *   $\\mathrm{live\\_in}[9] = \\{w\\} \\cup (\\{x\\} \\setminus \\{x\\}) = \\{w\\}$。\n    *   基本块 $B_4$ 的入口活跃集是 $\\mathrm{live\\_in}[B_4] = \\mathrm{live\\_in}[9] = \\{w\\}$。\n\n由于基本块 $B_2$ 和 $B_3$ 都跳转到 $B_4$，这些块末尾的出口活跃集就是 $B_4$ 的入口活跃集。\n*   $\\mathrm{live\\_out}[B_2] = \\mathrm{live\\_in}[B_4] = \\{w\\}$。这是 $\\mathrm{live\\_out}[5]$。\n*   $\\mathrm{live\\_out}[B_3] = \\mathrm{live\\_in}[B_4] = \\{w\\}$。这是 $\\mathrm{live\\_out}[8]$。\n\n3.  **对基本块 $B_2$ 的分析（指令 $3, 4, 5$）**：\n    *   **指令 $5$**: 跳转到 $B_4$。$\\mathrm{use}[5]=\\emptyset, \\mathrm{def}[5]=\\emptyset, \\mathrm{succ}(5)=\\{9\\}$。$\\mathrm{live\\_out}[5]=\\mathrm{live\\_in}[9]=\\{w\\}$。$\\mathrm{live\\_in}[5]=\\{w\\}$。\n    *   **指令 $4$**: $w := v + 1$。$\\mathrm{use}[4]=\\{v\\}, \\mathrm{def}[4]=\\{w\\}, \\mathrm{succ}(4)=\\{5\\}$。$\\mathrm{live\\_out}[4]=\\mathrm{live\\_in}[5]=\\{w\\}$。$\\mathrm{live\\_in}[4]=\\{v\\} \\cup (\\{w\\} \\setminus \\{w\\}) = \\{v\\}$。\n    *   **指令 $3$**: $v := u + z$。$\\mathrm{use}[3]=\\{u, z\\}, \\mathrm{def}[3]=\\{v\\}, \\mathrm{succ}(3)=\\{4\\}$。$\\mathrm{live\\_out}[3]=\\mathrm{live\\_in}[4]=\\{v\\}$。$\\mathrm{live\\_in}[3]=\\{u, z\\} \\cup (\\{v\\} \\setminus \\{v\\}) = \\{u, z\\}$。\n\n4.  **对基本块 $B_3$ 的分析（指令 $6, 7, 8$）**：\n    *   **指令 $8$**: 跳转到 $B_4$。$\\mathrm{use}[8]=\\emptyset, \\mathrm{def}[8]=\\emptyset, \\mathrm{succ}(8)=\\{9\\}$。$\\mathrm{live\\_out}[8]=\\mathrm{live\\_in}[9]=\\{w\\}$。$\\mathrm{live\\_in}[8]=\\{w\\}$。\n    *   **指令 $7$**: $w := v + y$。$\\mathrm{use}[7]=\\{v, y\\}, \\mathrm{def}[7]=\\{w\\}, \\mathrm{succ}(7)=\\{8\\}$。$\\mathrm{live\\_out}[7]=\\mathrm{live\\_in}[8]=\\{w\\}$。$\\mathrm{live\\_in}[7]=\\{v, y\\} \\cup (\\{w\\} \\setminus \\{w\\}) = \\{v, y\\}$。\n    *   **指令 $6$**: $v := u + 1$。$\\mathrm{use}[6]=\\{u\\}, \\mathrm{def}[6]=\\{v\\}, \\mathrm{succ}(6)=\\{7\\}$。$\\mathrm{live\\_out}[6]=\\mathrm{live\\_in}[7]=\\{v, y\\}$。$\\mathrm{live\\_in}[6]=\\{u\\} \\cup (\\{v, y\\} \\setminus \\{v\\}) = \\{u, y\\}$。\n\n5.  **对基本块 $B_1$ 的分析（指令 $1, 2$）**：\n    *   **指令 $2$**: 如果 $\\dots$。$\\mathrm{use}[2]=\\{u\\}, \\mathrm{def}[2]=\\emptyset, \\mathrm{succ}(2)=\\{3, 6\\}$。\n    *   对于一个汇合点，正确的规则是并集：$\\mathrm{live\\_out}[2] = \\mathrm{live\\_in}[3] \\cup \\mathrm{live\\_in}[6]$。\n    *   $\\mathrm{live\\_out}[2] = \\{u, z\\} \\cup \\{u, y\\} = \\{u, y, z\\}$。\n    *   $\\mathrm{live\\_in}[2] = \\mathrm{use}[2] \\cup (\\mathrm{live\\_out}[2] \\setminus \\mathrm{def}[2]) = \\{u\\} \\cup (\\{u, y, z\\} \\setminus \\emptyset) = \\{u, y, z\\}$。\n    *   **指令 $1$**: $u := x + y$。$\\mathrm{use}[1]=\\{x, y\\}, \\mathrm{def}[1]=\\{u\\}, \\mathrm{succ}(1)=\\{2\\}$。\n    *   $\\mathrm{live\\_out}[1] = \\mathrm{live\\_in}[2] = \\{u, y, z\\}$。\n    *   $\\mathrm{live\\_in}[1] = \\{x, y\\} \\cup (\\{u, y, z\\} \\setminus \\{u\\}) = \\{x, y, z\\}$。这与问题的前提条件——$x, y, z$ 在进入 $B_1$ 时是活跃的——相符。\n\n现在，我们使用问题的规则构建正确的干涉图 $G=(V, E)$：对于每个定义变量 $d$ 的指令，在 $d$ 和该指令的出口活跃集中的每个变量之间添加边（不包括自环）。\n\n*   **指令 $1$** ($u := x+y$)：$\\mathrm{def}[1]=\\{u\\}$, $\\mathrm{live\\_out}[1]=\\{u, y, z\\}$。添加的边：$\\{u, y\\}, \\{u, z\\}$。\n*   **指令 $3$** ($v := u+z$)：$\\mathrm{def}[3]=\\{v\\}$, $\\mathrm{live\\_out}[3]=\\{v\\}$。未添加边。\n*   **指令 $4$** ($w := v+1$)：$\\mathrm{def}[4]=\\{w\\}$, $\\mathrm{live\\_out}[4]=\\{w\\}$。未添加边。\n*   **指令 $6$** ($v := u+1$)：$\\mathrm{def}[6]=\\{v\\}$, $\\mathrm{live\\_out}[6]=\\{v, y\\}$。添加的边：$\\{v, y\\}$。\n*   **指令 $7$** ($w := v+y$)：$\\mathrm{def}[7]=\\{w\\}$, $\\mathrm{live\\_out}[7]=\\{w\\}$。未添加边。\n*   **指令 $9$** ($x := w+1$)：$\\mathrm{def}[9]=\\{x\\}$, $\\mathrm{live\\_out}[9]=\\{x\\}$。未添加边。\n\n正确图中的边集是 $E = \\{\\{u, y\\}, \\{u, z\\}, \\{v, y\\}\\}$。\n\n接下来，我们确定错误的干涉图 $G_f = (V, E_f)$。错误发生在 $\\mathrm{live\\_out}[2]$ 的计算中，这会从该点开始向后影响分析。\n\n*   **指令 2 处的错误分析**：\n    *   $\\mathrm{live\\_out\\_f}[2] = \\mathrm{live\\_in}[3] \\cap \\mathrm{live\\_in}[6] = \\{u, z\\} \\cap \\{u, y\\} = \\{u\\}$。\n    *   $\\mathrm{live\\_in\\_f}[2] = \\mathrm{use}[2] \\cup (\\mathrm{live\\_out\\_f}[2] \\setminus \\mathrm{def}[2]) = \\{u\\} \\cup (\\{u\\} \\setminus \\emptyset) = \\{u\\}$。\n*   **指令 1 处的错误分析**：\n    *   $\\mathrm{live\\_out\\_f}[1] = \\mathrm{live\\_in\\_f}[2] = \\{u\\}$。\n\n指令 $3$ 到 $10$ 的活跃度信息不受影响，因为从程序出口到条件分支入口点（指令 $3$ 和 $6$）的反向遍与分支前发生的事情无关。\n\n现在，我们使用相同的构建规则但使用错误的活跃度数据来构建错误的图 $E_f$。\n\n*   **指令 $1$** ($u := x+y$)：$\\mathrm{def}[1]=\\{u\\}$, $\\mathrm{live\\_out\\_f}[1]=\\{u\\}$。未添加边。\n*   **指令 $6$** ($v := u+1$)：$\\mathrm{def}[6]=\\{v\\}$, $\\mathrm{live\\_out}[6]=\\{v, y\\}$。添加的边：$\\{v, y\\}$。\n*   所有其他定义指令（$3, 4, 7, 9$）仍然没有添加边，因为它们的出口活跃集没有改变，并且只包含被定义的变量本身。\n\n错误图中的边集是 $E_f = \\{\\{v, y\\}\\}$。这与队友的报告相符，证实了我们对该过程的理解。\n\n最后，我们需要计算缺失边的数量，也就是集合差 $E \\setminus E_f$ 的基数。\n$$ E \\setminus E_f = \\{\\{u, y\\}, \\{u, z\\}, \\{v, y\\}\\} \\setminus \\{\\{v, y\\}\\} $$\n$$ E \\setminus E_f = \\{\\{u, y\\}, \\{u, z\\}\\} $$\n缺失边的数量是这个集合的大小。\n$$ |E \\setminus E_f| = 2 $$\n这两条缺失的边是 $\\{u, y\\}$ 和 $\\{u, z\\}$。它们被漏掉了，因为在汇合点的错误交集运算错误地判定 $y$ 和 $z$ 在指令 $2$ 之后不是活跃的，这又进而意味着它们在指令 $1$ 之后也不是活跃的。", "answer": "$$ \\boxed{2} $$", "id": "3647411"}]}