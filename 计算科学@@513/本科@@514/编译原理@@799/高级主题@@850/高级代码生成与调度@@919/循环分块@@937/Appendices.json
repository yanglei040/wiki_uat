{"hands_on_practices": [{"introduction": "循环分块的核心在于选择合适的分块大小。这不仅是一个随意的决定，而是一个需要在缓存容量和冲突未命中之间进行精确权衡的过程。通过这个练习，你将亲手为一个简单的嵌套循环计算最优的分块尺寸，从而深入理解这些底层硬件约束如何直接影响代码性能。[@problem_id:3653910]", "problem": "考虑以下对按行主序存储的二维数组进行操作的双重嵌套循环：\nfor i in 0..N-1:\n    for j in 0..M-1:\n        A[i][j] = A[i][j] + 1\n\n您将对该循环嵌套应用循环分块，使用边长为 $T$ 的方形块，即选择 $T_i = T_j = T$，并按如下方式迭代分块：\nfor i0 in 0..N-1 step T:\n    for j0 in 0..M-1 step T:\n        for ii in 0..T-1:\n            for jj in 0..T-1:\n                A[i0+ii][j0+jj] = A[i0+ii][j0+jj] + 1\n\n假设具有以下具体的机器和数据特性：\n- 数组 $A$ 的维度为 $N \\times M$，$N$ 和 $M$ 都足够大，可以忽略边界块。取 $M = 1024$。\n- 数组 $A$ 的元素大小为 $E = 8$ 字节（双精度浮点数）。\n- 内存布局严格遵循行主序：$A[i][j]$ 的地址为 $A_{\\text{base}} + (i \\cdot M + j) \\cdot E$。\n- 一级（L1）缓存是直接映射的，容量 $C = 32768$ 字节，缓存行大小 $L = 64$ 字节。共有 $S = C / L$ 个缓存行/组。\n- 中央处理器（CPU）按所示顺序执行内层循环；在每个块内，元素以 $j$ 最快变化的方式被访问。假设没有访问其他数组，并且在一级缓存处理每个块开始时是冷的，但在处理单个块期间不受其他活动干扰。\n\n您的目标是选择最大的整数块边长 $T$，使得在处理任何单个块时：\n1) 就必须同时持有的不同缓存行而言，块的总缓存足迹永远不超过一级缓存的容量（以避免块内的容量驱逐），以及\n2) 在块内固定列偏移处跨越 $T$ 行的访问模式不会在直接映射的一级缓存中引起冲突颠簸（以避免块内的冲突驱逐）。\n\n从行主序寻址和直接映射缓存索引的基本原理推导出这两个约束，并计算满足这两个约束的最大整数 $T$。仅报告此 $T$ 作为您的最终答案（无单位）。无需进行舍入，因为根据定义 $T$ 是一个整数。", "solution": "为了找到满足容量和冲突约束的最大块边长 $T$，我们分别推导这两个约束。\n\n**1. 容量约束 (Capacity Constraint)**\n\n容量约束要求一个 $T \\times T$ 块的工作集（working set）必须能完全装入L1缓存。一个块由 $T$ 行组成，每行包含 $T$ 个元素。\n- 每个元素的大小为 $E = 8$ 字节。\n- 缓存行大小为 $L = 64$ 字节。\n- 缓存总容量为 $C = 32768$ 字节，因此总缓存行数为 $S = C/L = 32768 / 64 = 512$ 行。\n\n块中的每一行（包含 $T$ 个元素）在内存中跨越 $T \\times E = 8T$ 字节。由于可能存在未对齐的情况，访问这 $8T$ 字节数据所需的缓存行数最坏情况下可以近似为 $\\lceil 8T/L \\rceil + 1$。一个更简单且常用的保守估计是，每一行段最多会占用 $8T/L + 1$ 个缓存行。对于一个 $T$ 行的块，其总缓存足迹可以估计为：\n$$ \\text{Footprint} \\approx T \\times \\left( \\frac{T \\times E}{L} + 1 \\right) \\text{ 行} $$\n为避免容量未命中，这个足迹不能超过缓存的总行数 $S$：\n$$ T \\left( \\frac{8T}{64} + 1 \\right) \\le 512 $$\n$$ T \\left( \\frac{T}{8} + 1 \\right) \\le 512 $$\n$$ \\frac{T^2}{8} + T \\le 512 $$\n$$ T^2 + 8T - 4096 \\le 0 $$\n为了找到这个不等式的解，我们首先解二次方程 $T^2 + 8T - 4096 = 0$ 的根：\n$$ T = \\frac{-8 \\pm \\sqrt{8^2 - 4(1)(-4096)}}{2} = \\frac{-8 \\pm \\sqrt{64 + 16384}}{2} = \\frac{-8 \\pm \\sqrt{16448}}{2} $$\n由于 $\\sqrt{16448} \\approx 128.25$，正根为 $T \\approx \\frac{-8 + 128.25}{2} \\approx 60.125$。\n因此，容量约束要求 $T \\le 60$。我们称之为 $T_{\\text{cap}} = 60$。\n\n**2. 冲突约束 (Conflict Constraint)**\n\n冲突约束源于直接映射缓存的特性。当多个内存地址映射到同一个缓存行时，就会发生冲突。我们需要分析块内沿列访问的模式，例如访问 $A[i_0][j_0], A[i_0+1][j_0], \\dots, A[i_0+T-1][j_0]$。\n\n- 数组 $A$ 的宽度为 $M=1024$ 个元素。\n- 相邻两行中同一列的元素（如 $A[i][j]$ 和 $A[i+1][j]$）在内存中的地址步长（stride）为 $\\Delta_{\\text{addr}} = M \\times E = 1024 \\times 8 = 8192$ 字节。\n- 缓存索引是通过 `(地址 / 缓存行大小) mod (总缓存行数)` 计算的。\n- 因此，地址步长对应的缓存行索引步长为：\n$$ \\Delta_{\\text{index}} = \\frac{\\Delta_{\\text{addr}}}{L} \\pmod{S} = \\frac{8192}{64} \\pmod{512} = 128 \\pmod{512} = 128 $$\n这意味着，在同一列中，每向下一行，其元素映射到的缓存行索引就会增加 $128$。访问序列 $A[i_0][j_0], A[i_0+1][j_0], A[i_0+2][j_0], \\dots$ 将映射到索引序列 $k, (k+128)\\%512, (k+256)\\%512, (k+384)\\%512, (k+512)\\%512=k, \\dots$。\n\n此索引序列的周期为 $\\frac{S}{\\gcd(\\Delta_{\\text{index}}, S)} = \\frac{512}{\\gcd(128, 512)} = \\frac{512}{128} = 4$。\n这意味着 $A[i_0][j_0]$ 和 $A[i_0+4][j_0]$ 会映射到同一个缓存行，从而产生冲突。为了在一个块的处理过程中避免这种自冲突，块的高度 $T$ 必须小于或等于这个周期。\n因此，冲突约束要求 $T \\le 4$。我们称之为 $T_{\\text{conf}} = 4$。\n\n**结论**\n\n为了同时满足两个约束，块边长 $T$ 必须小于或等于两个约束中的最小值：\n$$ T \\le \\min(T_{\\text{cap}}, T_{\\text{conf}}) = \\min(60, 4) = 4 $$\n因此，满足所有条件的最大整数块边长 $T$ 是 $4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3653910"}, {"introduction": "优化性能不仅仅是减少缓存未命中，更宏大的目标是让程序摆脱内存带宽的束缚，充分利用处理器的计算能力。这个练习将引导你使用“屋顶线模型”(Roofline model) 这一强大的性能分析工具，来量化循环分块如何通过提升算法的计算强度，将一个内存密集型内核转变为计算密集型内核。[@problem_id:3653939]", "problem": "考虑一个应用于 $N \\times N$ 双精度值数组的二维模糊核。每个输出点由一个 $3 \\times 3$ 的邻域（半径 $r=1$）计算得出，每个输出执行 $9$ 次乘法和 $8$ 次加法，总共每个输出点需要 $f=17$ 次浮点运算。假设以下基本事实：\n\n- 算术强度 $AI$ 定义为总浮点运算次数除以与主存之间传输的总字节数。\n- Roofline 性能模型 (RPM) 将峰值点（ridge point）描述为 $R = P_{\\text{peak}} / B$，其中 $P_{\\text{peak}}$ 是峰值浮点吞吐量（单位：浮点运算/秒），$B$ 是可持续的主存带宽（单位：字节/秒）。如果 $AI \\ge R$，则该核是计算密集型（compute-bound）；否则，它是内存密集型（memory-bound）。\n- 双精度值占用 $8$ 字节。\n- 使用流式存储（streaming stores），因此每次输出写入都恰好向内存贡献一次 $8$ 字节的存储，没有任何“为所有权而读”（read-for-ownership）的流量。\n- 在一个 tile（块）内，从内存中取出的所有输入数据都会被完全重用，直到该 tile 的输出计算完成；不同 tile 之间没有数据重用，并且由于 tile 的足迹（footprint）可以放入缓存，因此可以忽略 tile 内部的容量/冲突未命中（capacity/conflict misses）。\n\n您将比较两种分块（tiling）策略：\n\n1.  矩形分块：一个 tile 计算 $t_x \\times t_y$ 个输出，加载半径为 $r=1$ 的光环（halo），因此其唯一的输入足迹是 $(t_x+2)\\times(t_y+2)$，并写入 $t_x t_y$ 个输出。\n2.  条带分块（仅在一个维度上分块）：一个条带计算单行中的 $s \\times 1$ 个输出。为了用 $r=1$ 计算这 $s$ 个输出，该条带加载跨越 $(s+2)$ 列的 $3$ 行输入（中间行及其垂直相邻行），并写入 $s$ 个输出。\n\n假设机器的峰值性能 $P_{\\text{peak}} = 100 \\times 10^{9}$ 次浮点运算/秒，可持续带宽 $B = 200 \\times 10^{9}$ 字节/秒。仅使用上述定义并仔细计算每个 tile 内的重用情况：\n\n- 推导条带的算术强度 $AI_{\\text{strip}}(s)$ 作为 $s$ 的函数。\n- 使用 Roofline 峰值点 $R$ 来确定最小的实数条带宽度 $s$，使得 $AI_{\\text{strip}}(s)$ 恰好等于 $R$。\n\n将最终的 $s$ 阈值作为一个数字提供。不需要四舍五入。", "solution": "主要目标是找到最小的实数条带宽度 $s$，使得给定的模糊核变为计算密集型。根据 Roofline 性能模型，当一个核的算术强度 $AI$ 大于或等于机器的峰值点 $R$ 时，该核是计算密集型的。阈值是算术强度恰好等于峰值点的点。\n$$AI = R$$\n\n首先，我们使用提供的机器参数计算峰值点 $R$。峰值浮点吞吐量为 $P_{\\text{peak}} = 100 \\times 10^{9}$ 次浮点运算/秒 (FLOPS/s)，可持续主存带宽为 $B = 200 \\times 10^{9}$ 字节/秒 (bytes/s)。\n\n峰值点 $R$ 定义为：\n$$R = \\frac{P_{\\text{peak}}}{B}$$\n代入给定值：\n$$R = \\frac{100 \\times 10^{9} \\text{ FLOPS/s}}{200 \\times 10^{9} \\text{ bytes/s}} = \\frac{100}{200} \\frac{\\text{FLOPS}}{\\text{byte}} = 0.5 \\frac{\\text{FLOPS}}{\\text{byte}}$$\n\n接下来，我们推导条带分块策略的算术强度 $AI_{\\text{strip}}(s)$，作为条带宽度 $s$ 的函数。算术强度定义为执行的总浮点运算次数与处理器和主存之间传输的总字节数之比。\n$$AI_{\\text{strip}}(s) = \\frac{\\text{总浮点运算次数}}{\\text{传输的总字节数}}$$\n\n我们来计算一个计算 $s \\times 1$ 个输出的条带 tile 的分子和分母。\n\n总浮点运算次数由输出点的数量和每个点的运算次数决定。该条带计算 $s$ 个输出点。问题陈述每个输出点需要 $f=17$ 次浮点运算。\n$$\\text{总浮点运算次数} = s \\times f = 17s$$\n\n传输的总字节数是从内存读取的字节数（加载）和写入内存的字节数（存储）之和。\n对于输入数据（加载），问题指明，计算一行中的 $s$ 个输出需要加载 $3$ 行输入数据，每行跨越 $(s+2)$ 列。核的半径为 $r=1$。\n$$\\text{输入元素数量} = 3 \\times (s+2)$$\n每个元素是一个双精度值，占用 $8$ 字节。\n$$\\text{加载的字节数} = 8 \\times 3 \\times (s+2) = 24(s+2) = 24s + 48$$\n\n对于输出数据（存储），该 tile 计算 $s$ 个输出点。问题陈述使用了流式存储，因此每个输出都是一次向内存的 $8$ 字节写入。\n$$\\text{存储的字节数} = 8 \\times s = 8s$$\n\n传输的总字节数是加载和存储的字节数之和。\n$$\\text{传输的总字节数} = (24s + 48) + 8s = 32s + 48$$\n\n现在我们可以写出条带 tile 的算术强度表达式：\n$$AI_{\\text{strip}}(s) = \\frac{17s}{32s + 48}$$\n\n为了找到阈值条带宽度 $s$，我们将算术强度设为等于峰值点 $R$。\n$$AI_{\\text{strip}}(s) = R$$\n$$\\frac{17s}{32s + 48} = 0.5$$\n\n我们求解这个方程以得到 $s$。\n$$17s = 0.5 \\times (32s + 48)$$\n$$17s = 16s + 24$$\n从两边减去 $16s$ 得到：\n$$17s - 16s = 24$$\n$$s = 24$$\n\n因此，使得算术强度恰好等于峰值点的最小实数条带宽度 $s$ 是 $24$。对于任何 $s > 24$，该核将是计算密集型的；对于任何 $s  24$，它将是内存密集型的。", "answer": "$$ \\boxed{24} $$", "id": "3653939"}, {"introduction": "并非所有循环都能从标准的分块技术中直接受益，特别是当数据访问模式不规则时。直方图计算就是一个经典的例子，其随机的内存访问模式使得传统分块方法几乎失效。这个练习将挑战你的思维定式，并介绍一种更高级的优化策略——私有化（privatization），来解决这类棘手问题。[@problem_id:3653880]", "problem": "考虑在一个输入数组上计算直方图，过程如下：对于每个索引 $i$ ($0 \\le i  N$)，执行更新 $H[A[i]] \\leftarrow H[A[i]] + 1$，其中 $A[i] \\in \\{0,1,\\dots,B-1\\}$。假设 $A[i]$ 是独立同分布的，并且在 $B$ 个箱子上均匀分布。直方图数组 $H$ 有 $B$ 个箱子，每个箱子宽 $w$ 字节，因此 $H$ 占用 $B \\cdot w$ 字节。假设有一个全相联数据缓存，容量为 $C$ 字节，缓存行大小为 $L$ 字节，采用写分配和写回策略。令 $R = L / w$ 表示每个缓存行中的箱子数量，令 $B_{\\ell} = \\lceil B / R \\rceil$ 表示覆盖该直方图的缓存行数量。考虑将对 $i$ 的循环分块，块大小为 $S$，以便每个块处理 $S$ 个连续的 $i$ 索引。现有两种策略正在考虑中：\n\n- 策略 $(1)$：对 $i$ 进行分块，但不改变数据结构，继续更新单个全局直方图 $H$。\n- 策略 $(2)$：对于每个块，使用一个包含 $B$ 个箱子的私有直方图数组 $L_{t}$，该数组被初始化为零，并假设能装入缓存（即 $B \\cdot w \\le C$）。通过更新 $L_{t}[A[i]]$ 来处理该块，完成该块后，将 $L_{t}$ 合并到 $H$ 中，即对每个箱子 $b$ 执行更新 $H[b] \\leftarrow H[b] + L_{t}[b]$。\n\n在这些假设下，选择所有正确的陈述。通过运用存储器层次结构中时间局部性和空间局部性的核心定义、独立均匀采样的性质以及基本的操作计数来证明你的选择。\n\nA. 当 $B \\cdot w \\gg C$ 且 $A[i]$ 是均匀随机时，与未分块的循环相比，对 $i$ 进行分块但不使用私有直方图（策略 $(1)$）基本上不会减少对 $H$ 的缓存未命中次数。\n\nB. 使用每个块一个缓存驻留的私有直方图（策略 $(2)$）并且 $A[i]$ 是均匀随机的情况下，处理一个大小为 $S$ 的块时，访问到的不同直方图缓存行的期望数量是 $B_{\\ell} \\left(1 - \\left(1 - \\frac{R}{B}\\right)^{S}\\right)$，对于大的 $B$，这可以近似为 $B_{\\ell} \\left(1 - e^{-S R / B}\\right)$。\n\nC. 对于策略 $(2)$，在整个数组上的所有合并过程中，标量加法的总数是 $\\Theta\\!\\left(B \\cdot \\left\\lceil \\frac{N}{S} \\right\\rceil\\right)$，因为每个块的私有直方图都必须被累加到 $H$ 中一次。\n\nD. 对于策略 $(2)$，由合并引起的对全局直方图 $H$ 的访问次数是 $O\\!\\left(B \\cdot \\left\\lceil \\frac{N}{S} \\right\\rceil\\right)$，当 $S$ 的增长速度快于 $B$ 时（即当 $S = \\omega(B)$ 时），这在渐近意义上小于基线情况下的 $O(N)$ 次全局更新。\n\nE. 如果计算在 $P$ 个线程上并行化，每个线程对其数据块使用一个私有直方图，并在末尾通过二叉归约树执行一次性合并，那么总合并成本是 $O(B \\log P)$ 次加法，与 $N$ 和 $S$ 无关。\n\nF. 如果计算在 $P$ 个线程上并行化，每个线程都有一个私有直方图，并在块结束时进行一次性合并，那么内存开销是 $B \\cdot P$ 个箱子，并且合并期间执行的加法总数是 $\\Theta(B \\cdot P)$。\n\n选择所有适用项。", "solution": "此问题分析了两种不同分块策略下直方图计算的缓存性能。关键在于对直方图数组 $H$ 的访问模式。\n\n**策略 (1) 分析：不使用私有化的分块**\n在此策略中，对 $i$ 的循环进行了分块，但更新仍然直接作用于单个全局直方图 $H$。对 $H$ 的内存访问序列是 $H[A[0]], H[A[1]], \\dots, H[A[N-1]]$。由于 $A[i]$ 的值是独立同分布且均匀的，对 $H$ 的箱子的访问是随机的。将对 $i$ 的循环分块，只是将这些访问分组为大小为 $S$ 的块，但并未改变它们的顺序或随机性质。如果直方图的总大小 $B \\cdot w$ 远大于缓存容量 $C$，则缓存只能容纳 $H$ 的一小部分。由于随机访问模式，一次对 $H$ 的缓存行的访问，在它被驱逐之前，不太可能再次被访问。这是一个典型的容量未命中场景。对计算循环进行分块而不改变数据访问模式，对 $H$ 数组的时间局部性没有改善。\n\n**策略 (2) 分析：使用私有化的分块**\n此策略为每个块引入一个私有直方图 $L_t$，并假设其能装入缓存 ($B \\cdot w \\le C$)。\n- **块处理：** 对于一个大小为 $S$ 的索引块，所有 $S$ 次更新都修改 $L_t$。由于 $L_t$ 是缓存驻留的，在最初的强制性未命中将 $L_t$ 的行调入缓存后，后续对相同行的访问将是命中。这极大地改善了时间局部性。对 $L_t$ 的未命中次数仅限于被访问的不同缓存行的数量，而不是总访问次数。\n- **合并步骤：** 每个块处理完毕后，私有的 $L_t$ 被加到全局的 $H$ 中。这涉及到流式地遍历 $L_t$ 的 $B$ 个箱子（只读）和 $H$ 的 $B$ 个箱子（读写）。这是一个规则、可预测的访问模式。此步骤的未命中次数大约是 $L_t$ 的 $B_{\\ell}$ 次读取和 $H$ 的 $B_{\\ell}$ 次读-修改-写。\n\n现在，我们评估每个选项。\n\n**A. 当 $B \\cdot w \\gg C$ 且 $A[i]$ 是均匀随机时，与未分块的循环相比，对 $i$ 进行分块但不使用私有直方图（策略 $(1)$）基本上不会减少对 $H$ 的缓存未命中次数。**\n如上所述，对 $H$ 的访问模式是随机的。条件 $B \\cdot w \\gg C$ 意味着直方图无法装入缓存。由访问 $H[A[i]]$ 调入的任何 $H$ 的缓存行，在下一次访问命中它之前，有很高的概率被驱逐。两次连续访问 $H[A[i]]$ 和 $H[A[i+1]]$ 命中同一缓存行的概率是 $R/B$，对于大的 $B$ 来说这个值很小。对 $i$ 的循环进行分块并不会重新排序对 $H$ 的数据访问，因此不会改善数据局部性。对 $H$ 的缓存未命中率仍然很高，主要由容量未命中主导，就像在未分块的情况下一样。\n**结论：正确。**\n\n**B. 使用每个块一个缓存驻留的私有直方图（策略 $(2)$）并且 $A[i]$ 是均匀随机的情况下，处理一个大小为 $S$ 的块时，访问到的不同直方图缓存行的期望数量是 $B_{\\ell} \\left(1 - \\left(1 - \\frac{R}{B}\\right)^{S}\\right)$，对于大的 $B$，这可以近似为 $B_{\\ell} \\left(1 - e^{-S R / B}\\right)$。**\n这是占用问题的一个应用。我们有 $S$ 个随机样本（访问 $A[i]$），从 $B$ 个箱子中抽取。我们想找出命中不同缓存行的期望数量。为简化起见，假设 $B$ 是 $R$ 的倍数，所以 $B_{\\ell} = B/R$。$B_{\\ell}$ 个缓存行中的每一个都包含 $R$ 个箱子。\n一次随机访问命中特定缓存行的概率是 $p = R/B$。\n一次随机访问*未*命中特定缓存行的概率是 $1-p = 1 - R/B$。\n由于一个块中有 $S$ 次独立访问，所有 $S$ 次访问都未命中特定缓存行的概率是 $(1 - R/B)^S$。\n特定缓存行至少被命中一次的概率是 $1 - (1 - R/B)^S$。\n令 $X_j$ 为一个指示变量，如果缓存行 $j$ 被命中，则为 $1$，否则为 $0$。$E[X_j] = P(X_j=1) = 1 - (1 - R/B)^S$。\n根据期望的线性性，被命中的不同缓存行的总期望数量是 $\\sum_{j=1}^{B_{\\ell}} E[X_j] = B_{\\ell} \\left(1 - \\left(1 - \\frac{R}{B}\\right)^{S}\\right)$。这与公式相符。\n对于小的 $x$，$1-x \\approx e^{-x}$。将此应用于 $x=R/B$（对于大的 $B$ 来说很小），我们有 $(1 - R/B)^S \\approx (e^{-R/B})^S = e^{-SR/B}$。\n命中次数的期望值的近似值变为 $B_{\\ell} (1 - e^{-SR/B})$。该陈述的两个部分在数学上都是合理的。即使 $B$ 不是 $R$ 的倍数，$B_{\\ell} = \\lceil B/R \\rceil$ 的使用也是正确的，因为推导依赖于对 $B_{\\ell}$ 行的求和。最后一个部分行的概率略有不同，这是该标准模型中忽略的二阶效应。\n**结论：正确。**\n\n**C. 对于策略 $(2)$，在整个数组上的所有合并过程中，标量加法的总数是 $\\Theta\\!\\left(B \\cdot \\left\\lceil \\frac{N}{S} \\right\\rceil\\right)$，因为每个块的私有直方图都必须被累加到 $H$ 中一次。**\n大小为 $N$ 的对 $i$ 的循环被划分为 $\\lceil N/S \\rceil$ 个块。对于每个块，执行一次合并操作。一次合并操作包括将私有直方图 $L_t$ 的 $B$ 个箱子加到全局直方图 $H$ 的 $B$ 个箱子上。这需要 $B$ 次标量加法。因此，在所有合并过程中执行的标量加法总数正好是 $B \\cdot \\lceil N/S \\rceil$。根据定义，这是 $\\Theta(B \\cdot \\lceil N/S \\rceil)$。\n**结论：正确。**\n\n**D. 对于策略 $(2)$，由合并引起的对全局直方图 $H$ 的访问次数是 $O\\!\\left(B \\cdot \\left\\lceil \\frac{N}{S} \\right\\rceil\\right)$，当 $S$ 的增长速度快于 $B$ 时（即当 $S = \\omega(B)$ 时），这在渐近意义上小于基线情况下的 $O(N)$ 次全局更新。**\n在策略 (2) 中，全局直方图 $H$ 仅在合并期间被访问。每次合并对 $b \\in \\{0, \\dots, B-1\\}$ 执行更新 $H[b] \\leftarrow H[b] + L_t[b]$。这涉及到对每个箱子 $H[b]$ 的一次读取和一次写入，每次合并总共对 $H$ 进行 $2B$ 次访问。对于 $\\lceil N/S \\rceil$ 个块，对 $H$ 的总访问次数为 $2B \\cdot \\lceil N/S \\rceil$，即 $O(B \\cdot N/S)$。\n基线策略对 $N$ 个元素中的每一个都执行一次对 $H$ 的更新，导致 $N$ 次更新，这意味着 $O(N)$ 次访问。\n我们想比较访问 $H$ 的成本：策略 (2) 的 $O(B N/S)$ 与基线的 $O(N)$。要使策略 (2) 的成本在渐近意义上更小，我们需要 $\\lim_{N,S,B \\to \\infty} \\frac{B N/S}{N} = 0$。这简化为 $\\lim \\frac{B}{S} = 0$，这意味着 $S$ 的增长必须渐近地快于 $B$。这正是 $S = \\omega(B)$ 的定义。该陈述在逻辑上和数学上都是合理的。\n**结论：正确。**\n\n**E. 如果计算在 $P$ 个线程上并行化，每个线程对其数据块使用一个私有直方图，并在末尾通过二叉归约树执行一次性合并，那么总合并成本是 $O(B \\log P)$ 次加法，与 $N$ 和 $S$ 无关。**\n该问题描述了将 $P$ 个大小为 $B$ 的私有直方图合并成一个最终直方图。二叉归约树是组织这种合并的一种方式。\n- 在树的第一层，我们执行 $P/2$ 次合并，将成对的直方图组合起来。每次合并需要 $B$ 次加法。总工作量：$(P/2) \\cdot B$。\n- 在第二层，我们有 $P/4$ 次合并。总工作量：$(P/4) \\cdot B$。\n- 这个过程持续 $\\log_2 P$ 层。\n*加法总数*（总工作量）是所有层级的总和：$B \\cdot (P/2 + P/4 + \\dots + 1) = B \\cdot (P-1)$。\n这个总工作量是 $\\Theta(B \\cdot P)$。\n该陈述声称总成本是 $O(B \\log P)$ 次加法。这是不正确的。如果在每个级别都有足够的处理器， $O(B \\log P)$ 表示归约的并行时间（跨度），但它不代表操作的总数（工作量），而“总...加法”所指的正是后者。\n**结论：不正确。**\n\n**F. 如果计算在 $P$ 个线程上并行化，每个线程都有一个私有直方图，并在块结束时进行一次性合并，那么内存开销是 $B \\cdot P$ 个箱子，并且合并期间执行的加法总数是 $\\Theta(B \\cdot P)$。**\n- **内存开销：** 有 $P$ 个线程，每个线程都需要自己的私有直方图。每个直方图有 $B$ 个箱子。用于这些私有直方图的总内存构成了开销，为 $P \\times B$ 个箱子。这部分是正确的。\n- **加法总数：** 正如对选项 E 的分析，将 $P$ 个大小为 $B$ 的私有直方图合并成一个最终直方图，总共需要 $(P-1) \\cdot B$ 次标量加法，无论具体的合并策略如何（例如，串行累加，归约树）。因此，加法总数是 $\\Theta(B \\cdot P)$。这部分也是正确的。\n该陈述在两方面都是准确的。\n**结论：正确。**", "answer": "$$\\boxed{ABCDF}$$", "id": "3653880"}]}