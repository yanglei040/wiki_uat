{"hands_on_practices": [{"introduction": "要真正掌握列表调度，最好的方法就是亲手实践。这个练习将带你从头到尾地走一遍列表调度的核心流程，包括计算指令的“关键路径”优先级，以及在一个简单的单发射处理器上逐周期地模拟调度过程。通过比较两种不同的调度策略，你将直观地看到，即使是微小的决策差异（例如，当多条指令同时就绪时如何选择），也会对最终的执行时间产生显著影响 ([@problem_id:3650813])。", "problem": "一个编译器后端的目标是一个单指令发射 (Single Instruction Issue, SII) 机器，该机器每个时钟周期最多能发射一条指令。指令具有正整数延迟。如果一条指令 $v$ 在周期 $t$ 发射，其结果在周期 $t + l(v)$ 可用，其中 $l(v)$ 是其延迟。有向无环图 (DAG) 中指令 $v$ 的一个后继指令 $u$ 只有在其所有前驱指令都已产生结果时才能发射。一个列表调度器维护一个就绪列表，其中包含在给定周期数据依赖已满足的指令，并在列表可用时每个周期选择一条指令；如果列表为空，则该周期被计为一个停顿周期。总完工时间是最后一条指令的完成时间（所有已发射指令的发射时间加延迟的最大值）。\n\n考虑一个基本块，其依赖图是一个有向无环图 (DAG) $G=(V,E)$，节点集为\n$$V=\\{C_{1},C_{2},C_{3},C_{4},C_{5}\\}\\cup \\{P_{1},P_{2},P_{3},P_{4},P_{5},P_{6},P_{7},P_{8}\\}$$\n边集为\n$$E=\\{(C_{1},C_{2}),(C_{2},C_{3}),(C_{3},C_{4}),(C_{4},C_{5})\\}。$$\n所有 $P_{j}$ 节点既没有后继节点也没有前驱节点。延迟为\n$$l(C_{i})=4 \\text{ for } i\\in\\{1,2,3,4,5\\},\\quad l(P_{j})=1 \\text{ for } j\\in\\{1,2,3,4,5,6,7,8\\}。$$\n\n使用关键路径优先级的定义，即加权最长路径到出口的度量，\n$$p(v)=l(v)+\\max_{(v\\to u)\\in E}p(u),\\quad \\max \\emptyset = 0,$$\n执行以下操作：\n\n- 计算所有 $v\\in V$ 的 $p(v)$。\n- 构建两个列表调度：\n  - 调度 $\\mathcal{S}_{A}$ 使用的就绪列表决胜规则为：选择就绪指令中 $p(v)$ 最大的指令；若出现平局，则选择 $l(v)$ 较大的指令；若再次出现平局，则按标识符的字典序递增选择（$C$ 在 $P$ 之前，数字索引较小的优先）。\n  - 调度 $\\mathcal{S}_{B}$ 使用的就绪列表决胜规则为：选择就绪指令中 $l(v)$ 最小的指令；若出现平局，则选择 $p(v)$ 较小的指令；若再次出现平局，则按标识符的字典序递增选择。\n\n对于每个调度，报告每条指令的发射时间、停顿周期数以及以周期为单位的总完工时间。然后，作为您的最终数值答案，给出定义为\n$$\\text{makespan}(\\mathcal{S}_{B})-\\text{makespan}(\\mathcal{S}_{A})$$\n的完工时间差值（以周期为单位）。\n请将您的最终答案表示为整数个周期。无需四舍五入。", "solution": "首先，计算所有指令的优先级 $p(v)$。\n- $P_j$ 节点没有后继节点，因此 $p(P_j) = l(P_j) = 1$。\n- $C_i$ 节点形成一条链，我们从后向前计算：\n  - $p(C_5) = l(C_5) = 4$\n  - $p(C_4) = l(C_4) + p(C_5) = 4 + 4 = 8$\n  - $p(C_3) = l(C_3) + p(C_4) = 4 + 8 = 12$\n  - $p(C_2) = l(C_2) + p(C_3) = 4 + 12 = 16$\n  - $p(C_1) = l(C_1) + p(C_2) = 4 + 16 = 20$\n\n**调度 $\\mathcal{S}_{A}$ 表格：**\n| 周期 $t$ | 就绪列表 (节点, $p$, $l$) | 所选指令 | 发射时间 | 备注 |\n|---|---|---|---|---|\n| 1 | {$C_1(20,4)$, $P_1..P_8(1,1)$} | $C_1$ | 1 | $C_1$ 的 $p$ 值最高。在 $1+4=5$ 时完成 |\n| 2 | {$P_1..P_8(1,1)$} | $P_1$ | 2 | 完成: $2+1=3$ |\n| 3 | {$P_2..P_8(1,1)$} | $P_2$ | 3 | 完成: $3+1=4$ |\n| 4 | {$P_3..P_8(1,1)$} | $P_3$ | 4 | 完成: $4+1=5$ |\n| 5 | {$C_2(16,4)$, $P_4..P_8(1,1)$} | $C_2$ | 5 | $C_1$ 完成。$C_2$ 就绪。$C_2$ 的 $p$ 值最高。完成: $5+4=9$ |\n| 6 | {$P_4..P_8(1,1)$} | $P_4$ | 6 | 完成: $6+1=7$ |\n| 7 | {$P_5..P_8(1,1)$} | $P_5$ | 7 | 完成: $7+1=8$ |\n| 8 | {$P_6..P_8(1,1)$} | $P_6$ | 8 | 完成: $8+1=9$ |\n| 9 | {$C_3(12,4)$, $P_7, P_8(1,1)$} | $C_3$ | 9 | $C_2$ 完成。$C_3$ 就绪。$C_3$ 的 $p$ 值最高。完成: $9+4=13$ |\n| 10 | {$P_7, P_8(1,1)$} | $P_7$ | 10 | 完成: $10+1=11$ |\n| 11 | {$P_8(1,1)$} | $P_8$ | 11 | 完成: $11+1=12$ |\n| 12 | {} | STALL | - | 等待 $C_3$ |\n| 13 | {$C_4(8,4)$} | $C_4$ | 13 | $C_3$ 完成。$C_4$ 就绪。完成: $13+4=17$ |\n| 14 | {} | STALL | - | 等待 $C_4$ |\n| 15 | {} | STALL | - | |\n| 16 | {} | STALL | - | |\n| 17 | {$C_5(4,4)$} | $C_5$ | 17 | $C_4$ 完成。$C_5$ 就绪。完成: $17+4=21$ |\n\n调度 $\\mathcal{S}_{A}$ 发射了13条指令，有4个停顿周期。最后一条指令 $C_5$ 在周期21完成，因此完工时间 $\\text{makespan}(\\mathcal{S}_{A}) = 21$。\n\n**调度 $\\mathcal{S}_{B}$ 表格：**\n| 周期 $t$ | 就绪列表 (节点, $l$, $p$) | 所选指令 | 发射时间 | 备注 |\n|---|---|---|---|---|\n| 1 | {$C_1(4,20)$, $P_1..P_8(1,1)$} | $P_1$ | 1 | $P$ 指令的 $l$ 值最小。完成: $1+1=2$ |\n| 2 | {$C_1(4,20)$, $P_2..P_8(1,1)$} | $P_2$ | 2 | 完成: $2+1=3$ |\n| 3 | {$C_1(4,20)$, $P_3..P_8(1,1)$} | $P_3$ | 3 | 完成: $3+1=4$ |\n| 4 | {$C_1(4,20)$, $P_4..P_8(1,1)$} | $P_4$ | 4 | 完成: $4+1=5$ |\n| 5 | {$C_1(4,20)$, $P_5..P_8(1,1)$}| $P_5$ | 5 | 完成: $5+1=6$ |\n| 6 | {$C_1(4,20)$, $P_6..P_8(1,1)$}| $P_6$ | 6 | 完成: $6+1=7$ |\n| 7 | {$C_1(4,20)$, $P_7, P_8(1,1)$}| $P_7$ | 7 | 完成: $7+1=8$ |\n| 8 | {$C_1(4,20)$, $P_8(1,1)$} | $P_8$ | 8 | 完成: $8+1=9$ |\n| 9 | {$C_1(4,20)$} | $C_1$ | 9 | 完成: $9+4=13$ |\n| 10 | {} | STALL | - | 等待 $C_1$ |\n| 11 | {} | STALL | - | |\n| 12 | {} | STALL | - | |\n| 13 | {$C_2(4,16)$} | $C_2$ | 13 | 完成: $13+4=17$ |\n| 14 | {} | STALL | - | 等待 $C_2$ |\n| 15 | {} | STALL | - | |\n| 16 | {} | STALL | - | |\n| 17 | {$C_3(4,12)$} | $C_3$ | 17 | 完成: $17+4=21$ |\n| 18 | {} | STALL | - | 等待 $C_3$ |\n| 19 | {} | STALL | - | |\n| 20 | {} | STALL | - | |\n| 21 | {$C_4(4,8)$} | $C_4$ | 21 | 完成: $21+4=25$ |\n| 22 | {} | STALL | - | 等待 $C_4$ |\n| 23 | {} | STALL | - | |\n| 24 | {} | STALL | - | |\n| 25 | {$C_5(4,4)$} | $C_5$ | 25 | 完成: $25+4=29$ |\n\n调度 $\\mathcal{S}_{B}$ 发射了13条指令，有12个停顿周期。最后一条指令 $C_5$ 在周期29完成，因此完工时间 $\\text{makespan}(\\mathcal{S}_{B}) = 29$。\n\n完工时间差值为：\n$$\\text{makespan}(\\mathcal{S}_{B}) - \\text{makespan}(\\mathcal{S}_{A}) = 29 - 21 = 8$$", "answer": "$$\\boxed{8}$$", "id": "3650813"}, {"introduction": "调度启发式算法的选择并非总是直截了当，有时最符合直觉的选择反而可能导致次优的结果。这个练习通过一个特殊的“星型”依赖图，揭示了一个经典的调度“反常”现象 ([@problem_id:3650829])。它旨在挑战你关于“短任务优先”的朴素想法，并促使你更深入地思考如何在最大化并行度与优先处理最长任务之间取得平衡，这对于优化整体执行时间至关重要。", "problem": "考虑一个有向无环图（DAG），其中一个汇点指令依赖于许多独立的叶子指令。这种星形结构用于研究指令调度中的列表调度。处理器模型是一台超标量机器，具有发射宽度 $m=2$ 的相同功能单元（FU），其中每条指令都是非抢占式的，并在其整个执行时间内占用一个FU（以周期为单位）。所有叶子节点在时间 $t=0$ 时都已就绪。只有在所有叶子节点都完成后，汇点指令才能被发射。\n\n设计具有以下节点和依赖关系的星形DAG：\n- 叶子节点：$L_{1},L_{2},L_{3},L_{4},L_{5}$，每个节点产生一个操作数供给汇点 $S$，执行时间分别为 $p(L_{1})=12$, $p(L_{2})=8$, $p(L_{3})=8$, $p(L_{4})=8$, $p(L_{5})=8$ 个周期。\n- 汇点：$S$，执行时间为 $p(S)=6$ 个周期，且 $S$ 依赖于所有 $L_{i}$，其中 $i\\in\\{1,2,3,4,5\\}$。\n\n当FU可用时，使用列表调度和两种不同的优先级策略来选择要发射的就绪叶子节点：\n1. 策略 $\\mathcal{E}$（早汇点偏置）：按执行时间非递增顺序（即按 $p(L_{i})$ 降序排序）对叶子节点进行优先级排序。\n2. 策略 $\\mathcal{P}$（并行叶子最大化）：按执行时间非递减顺序（即按 $p(L_{i})$ 升序排序）对叶子节点进行优先级排序。\n\n在这两种策略下，同等优先级的叶子节点之间的平局可以任意打破。所有叶子节点完成后，如果FU可用，立即发射 $S$。计算完工时间比\n$$R=\\frac{M_{\\mathcal{P}}}{M_{\\mathcal{E}}},$$\n其中 $M_{\\mathcal{P}}$ 和 $M_{\\mathcal{E}}$ 分别是在策略 $\\mathcal{P}$ 和 $\\mathcal{E}$ 下整个DAG的总完成时间（即 $S$ 的完成时间）。将 $R$ 表示为单个简化分数。无需四舍五入，最终答案不应包含单位。", "solution": "我们将模拟两种策略的列表调度过程，以确定它们各自的完工时间。列表调度算法维护一个就绪指令列表，这些指令的依赖关系已经得到满足。在每个有FU空闲的时间步，算法从就绪列表中选择优先级最高的指令并将其发射。\n\n**1. 策略 $\\mathcal{E}$（早汇点偏置）下的完工时间**\n\n该策略优先考虑执行时间较长的叶子节点。\n执行时间为 $p(L_1)=12, p(L_2)=8, p(L_3)=8, p(L_4)=8, p(L_5)=8$。\n按执行时间非递增顺序排序的优先级列表是 $(L_1, L_2, L_3, L_4, L_5)$。我们使用节点索引来打破四个执行时间为8的叶子节点之间的平局。\n\n设 $S_i$ 和 $F_i$ 分别表示指令 $i$ 的开始和完成时间，其中 $F_i = S_i + p(i)$。模拟过程如下：\n- **时间 $t=0$**：就绪列表为 $\\{L_1, L_2, L_3, L_4, L_5\\}$。有两个FU可用。\n  - 在FU1上发射 $L_1$：$S_{L_1}=0$， $F_{L_1}=0+12=12$。\n  - 在FU2上发射 $L_2$：$S_{L_2}=0$， $F_{L_2}=0+8=8$。\n- **时间 $t=8$**：FU2变为空闲。就绪列表为 $\\{L_3, L_4, L_5\\}$。\n  - 在FU2上发射 $L_3$：$S_{L_3}=8$， $F_{L_3}=8+8=16$。\n- **时间 $t=12$**：FU1变为空闲。就绪列表为 $\\{L_4, L_5\\}$。\n  - 在FU1上发射 $L_4$：$S_{L_4}=12$， $F_{L_4}=12+8=20$。\n- **时间 $t=16$**：FU2变为空闲。就绪列表为 $\\{L_5\\}$。\n  - 在FU2上发射 $L_5$：$S_{L_5}=16$， $F_{L_5}=16+8=24$。\n\n所有叶子节点现已调度完毕。完成时间为 $F_{L_1}=12$, $F_{L_2}=8$, $F_{L_3}=16$, $F_{L_4}=20$, $F_{L_5}=24$。\n汇点指令 $S$ 只有在其所有依赖项（叶子节点）都完成后才能开始。因此，$S$ 的开始时间是叶子节点完成时间的最大值。\n$$S_S = \\max(F_{L_1}, F_{L_2}, F_{L_3}, F_{L_4}, F_{L_5}) = \\max(12, 8, 16, 20, 24) = 24$$\n在时间 $t=24$ 时，FU2变为空闲，而FU1自 $t=20$ 起就一直空闲。因此，有一个可用的FU可以立即开始执行 $S$。\n$S$ 的完成时间为 $F_S = S_S + p(S) = 24 + 6 = 30$。\n策略 $\\mathcal{E}$ 的完工时间是 $M_{\\mathcal{E}} = 30$。\n\n**2. 策略 $\\mathcal{P}$（并行叶子最大化）下的完工时间**\n\n该策略优先考虑执行时间较短的叶子节点。\n按执行时间非递减顺序排序的优先级列表是 $(L_2, L_3, L_4, L_5, L_1)$。我们再次使用节点索引来打破平局。\n\n- **时间 $t=0$**：就绪列表为 $\\{L_1, L_2, L_3, L_4, L_5\\}$。有两个FU可用。\n  - 在FU1上发射 $L_2$：$S_{L_2}=0$， $F_{L_2}=0+8=8$。\n  - 在FU2上发射 $L_3$：$S_{L_3}=0$， $F_{L_3}=0+8=8$。\n- **时间 $t=8$**：FU1和FU2都变为空闲。就绪列表为 $\\{L_4, L_5, L_1\\}$。\n  - 在FU1上发射 $L_4$：$S_{L_4}=8$， $F_{L_4}=8+8=16$。\n  - 在FU2上发射 $L_5$：$S_{L_5}=8$， $F_{L_5}=8+8=16$。\n- **时间 $t=16$**：FU1和FU2都变为空闲。就绪列表为 $\\{L_1\\}$。\n  - 在FU1上发射 $L_1$：$S_{L_1}=16$， $F_{L_1}=16+12=28$。在 $L_1$ 执行期间，FU2保持空闲。\n\n所有叶子节点已调度完毕。完成时间为 $F_{L_1}=28$, $F_{L_2}=8$, $F_{L_3}=8$, $F_{L_4}=16$, $F_{L_5}=16$。\n汇点 $S$ 的开始时间是这些完成时间的最大值。\n$$S_S = \\max(F_{L_1}, F_{L_2}, F_{L_3}, F_{L_4}, F_{L_5}) = \\max(28, 8, 8, 16, 16) = 28$$\n在时间 $t=28$ 时，FU1变为空闲。FU2自 $t=16$ 起就一直空闲。有一个可用的FU可以立即开始执行 $S$。\n$S$ 的完成时间为 $F_S = S_S + p(S) = 28 + 6 = 34$。\n策略 $\\mathcal{P}$ 的完工时间是 $M_{\\mathcal{P}} = 34$。\n\n**3. 计算完工时间比**\n\n比率 $R$ 定义为 $R=\\frac{M_{\\mathcal{P}}}{M_{\\mathcal{E}}}$。代入计算出的完工时间：\n$$R = \\frac{34}{30}$$\n通过将分子和分母除以它们的最大公约数2来简化分数：\n$$R = \\frac{17}{15}$$\n\n这个结果展示了一个经典的调度异常现象，即看似次优的启发式算法（优先调度短作业）导致了更差的总体完工时间，因为它推迟了单个最长的作业，在末尾创建了一个长的关键路径，并降低了整体处理器利用率。", "answer": "$$\\boxed{\\frac{17}{15}}$$", "id": "3650829"}, {"introduction": "在真实的编译器中，指令调度并非孤立存在，它与内存访问等其他优化紧密相连。本练习引入了一个更高级且贴近实际的挑战：内存别名分析（memory aliasing）对调度的影响 ([@problem_id:3650816])。你将探索在“乐观”与“悲观”的别名假设下，调度器如何因依赖关系图的改变而生成截然不同的指令序列，并量化这种不确定性带来的性能代价，例如额外的停顿周期。", "problem": "一个编译器后端的目标是一个静态调度的超长指令字（VLIW）架构，但为了简化分析，它生成一个单发射调度。对于一个基本块，考虑以下指令序列和机器模型。目标是执行两次列表调度，第一次在乐观内存别名假设下，第二次在悲观内存别名假设下，然后量化这些假设如何改变调度。最后，计算这些调度之间差异的标量摘要。\n\n机器模型和调度策略：\n- 处理器每个周期可以发射一条指令。每条发射的指令在其开始周期占据唯一的发射槽；在其结果延迟期间，处理器可以在后续周期中发射其他就绪的指令。\n- 功能单元的延迟是固定的：加载（load）延迟为 $3$，存储（store）延迟为 $2$，乘法（multiply）延迟为 $3$，加法（add）延迟为 $1$。\n- 在所有生产者结果可用之前，消费者指令不能被发射；也就是说，只有当每个所需的操作数都已生成且相应的延迟已经过去，带有操作数的指令才变为就绪状态。\n- 使用列表调度，优先级等于到出口的最长加权路径（关键路径长度），计算方法为节点延迟加上其后继指令优先级的最大值。当多个就绪指令具有相同优先级时，按较早的程序顺序打破平局。\n- 只有一个内存单元；然而，由于机器是单发射的，资源冲突被发射宽度约束所涵盖。\n\n程序和依赖关系：\n- 程序顺序（从先到后）：$L_{A}$、$L_{B}$、$M_{1}$、$S_{P}$、$L_{C}$、$M_{2}$、$A$。\n- 语义：\n  - $L_{A}$：加载 $a \\leftarrow *p$。\n  - $L_{B}$：加载 $b \\leftarrow *q$。\n  - $M_{1}$：乘法 $x \\leftarrow a \\times b$。\n  - $S_{P}$：存储 $*p \\leftarrow x$。\n  - $L_{C}$：加载 $c \\leftarrow *r$。\n  - $M_{2}$：乘法 $y \\leftarrow c \\times x$。\n  - $A$：加法 $z \\leftarrow y + b$。\n- 来自别名分析的已证实和未知的别名事实：\n  - 已证实 $q$ 与 $p$ 或 $r$ 不存在别名。\n  - $p$ 可能与 $r$ 存在别名（未知的别名关系）。\n- 真数据依赖：\n  - $L_{A} \\rightarrow M_{1}$、$L_{B} \\rightarrow M_{1}$、$M_{1} \\rightarrow S_{P}$、$L_{C} \\rightarrow M_{2}$、$M_{1} \\rightarrow M_{2}$、$M_{2} \\rightarrow A$、$L_{B} \\rightarrow A$。\n- 两种别名假设下的内存顺序依赖：\n  - 乐观假设：除了已证实的依赖外，不引入额外的依赖；特别地，不约束 $S_{P}$ 和 $L_{C}$，因为 $p$ 是否与 $r$ 别名是未知的。\n  - 悲观假设：由于 $p$ 和 $r$ 之间可能存在别名，引入一个从存储到加载的依赖 $S_{P} \\rightarrow L_{C}$。将此依赖视为要求存储操作完成后才能发射加载操作。\n\n任务：\n1. 使用给定的延迟和依赖关系，计算在乐观和悲观两种别名假设下每条指令的列表调度优先级（到出口的关键路径长度）。然后，为每种情况构建单发射调度，方法是从周期 $0$ 开始，在每个周期选择优先级最高的就绪指令（按较早的程序顺序打破平局），每发射一条指令时间推进 $1$。一条指令在其延迟结束后产生结果。\n2. 对于每个调度，记录每条指令的开始周期和最后一条指令的完成周期。将停顿周期定义为因没有指令就绪而未发射任何指令的周期。\n3. 定义调度差异 $D$ 为在乐观和悲观调度下，所有指令的开始周期之差的绝对值之和。定义停顿传播差异 $\\Delta S$ 为悲观调度中的停顿周期数与乐观调度中的停顿周期数之差。\n4. 计算标量摘要 $\\Gamma$，定义为 $\\Gamma = \\frac{D}{\\Delta S}$。将您的答案四舍五入到四位有效数字。", "solution": "**指令和延迟数据**\n指令表示为 $L_A, L_B, M_1, S_P, L_C, M_2, A$。它们各自的延迟如下：\n- 加载（$L_A, L_B, L_C$）：$3$ 个周期\n- 存储（$S_P$）：$2$ 个周期\n- 乘法（$M_1, M_2$）：$3$ 个周期\n- 加法（$A$）：$1$ 个周期\n\n**第1部分：乐观调度**\n\n**依赖图和优先级（乐观）**\n在乐观假设下，我们只考虑真数据依赖。我们通过从叶节点向后遍历数据依赖图来计算优先级：\n- $P(A) = \\text{latency}(A) = 1$\n- $P(S_P) = \\text{latency}(S_P) = 2$\n- $P(M_2) = \\text{latency}(M_2) + P(A) = 3 + 1 = 4$\n- $P(M_1) = \\text{latency}(M_1) + \\max(P(S_P), P(M_2)) = 3 + \\max(2, 4) = 7$\n- $P(L_C) = \\text{latency}(L_C) + P(M_2) = 3 + 4 = 7$\n- $P(L_B) = \\text{latency}(L_B) + \\max(P(M_1), P(A)) = 3 + \\max(7, 1) = 10$\n- $P(L_A) = \\text{latency}(L_A) + P(M_1) = 3 + 7 = 10$\n\n**列表调度（乐观）**\n- 周期 $0$：就绪 {$L_A, L_B, L_C$}。$P(L_A)=10, P(L_B)=10$。选 $L_A$ (程序顺序)。发射 $L_A$ (完成于周期3)。\n- 周期 $1$：就绪 {$L_B, L_C$}。选 $L_B$ ($P=10$)。发射 $L_B$ (完成于周期4)。\n- 周期 $2$：就绪 {$L_C$}。选 $L_C$ ($P=7$)。发射 $L_C$ (完成于周期5)。\n- 周期 $3$：停顿 (等待 $L_B$ for $M_1$)。\n- 周期 $4$：就绪 {$M_1$}。发射 $M_1$ (完成于周期7)。\n- 周期 $5$：停顿 (等待 $M_1$ for $M_2/S_P$)。\n- 周期 $6$：停顿 (等待 $M_1$)。\n- 周期 $7$：就绪 {$M_2, S_P$}。$P(M_2)=4, P(S_P)=2$。选 $M_2$。发射 $M_2$ (完成于周期10)。\n- 周期 $8$：就绪 {$S_P$}。选 $S_P$ ($P=2$)。发射 $S_P$ (完成于周期10)。\n- 周期 $9$：停顿 (等待 $M_2$ for $A$)。\n- 周期 $10$：就绪 {$A$}。发射 $A$ (完成于周期11)。\n\n乐观调度开始时间 ($S_{opt}$): $L_A(0), L_B(1), L_C(2), M_1(4), M_2(7), S_P(8), A(10)$。\n完工时间为 $11$。停顿周期数 $stalls_{opt} = 11 - 7 = 4$。\n\n**第2部分：悲观调度**\n\n**依赖图和优先级（悲观）**\n增加依赖 $S_P \\rightarrow L_C$。重新计算优先级：\n- $P(A) = 1$\n- $P(M_2) = 4$\n- $P(L_C) = \\text{latency}(L_C) + P(M_2) = 3 + 4 = 7$\n- $P(S_P) = \\text{latency}(S_P) + P(L_C) = 2 + 7 = 9$\n- $P(M_1) = \\text{latency}(M_1) + \\max(P(S_P), P(M_2)) = 3 + \\max(9, 4) = 12$\n- $P(L_B) = \\text{latency}(L_B) + \\max(P(M_1), P(A)) = 3 + \\max(12, 1) = 15$\n- $P(L_A) = \\text{latency}(L_A) + P(M_1) = 3 + 12 = 15$\n\n**列表调度（悲观）**\n- 周期 $0$：就绪 {$L_A, L_B$}。$P(L_A)=15, P(L_B)=15$。选 $L_A$。发射 $L_A$ (完成于周期3)。\n- 周期 $1$：就绪 {$L_B$}。选 $L_B$ ($P=15$)。发射 $L_B$ (完成于周期4)。\n- 周期 $2$：停顿 (等待 $L_A, L_B$ for $M_1$)。\n- 周期 $3$：停顿 (等待 $L_B$ for $M_1$)。\n- 周期 $4$：就绪 {$M_1$}。发射 $M_1$ (完成于周期7)。\n- 周期 $5$：停顿 (等待 $M_1$)。\n- 周期 $6$：停顿 (等待 $M_1$)。\n- 周期 $7$：就绪 {$S_P$}。发射 $S_P$ (完成于周期9)。\n- 周期 $8$：停顿 (等待 $S_P$ for $L_C$)。\n- 周期 $9$：就绪 {$L_C$}。发射 $L_C$ (完成于周期12)。\n- 周期 $10$：停顿 (等待 $L_C$ for $M_2$)。\n- 周期 $11$：停顿 (等待 $L_C$)。\n- 周期 $12$：就绪 {$M_2$}。发射 $M_2$ (完成于周期15)。\n- 周期 $13$：停顿 (等待 $M_2$ for $A$)。\n- 周期 $14$：停顿 (等待 $M_2$)。\n- 周期 $15$：就绪 {$A$}。发射 $A$ (完成于周期16)。\n\n悲观调度开始时间 ($S_{pess}$): $L_A(0), L_B(1), M_1(4), S_P(7), L_C(9), M_2(12), A(15)$。\n完工时间为 $16$。停顿周期数 $stalls_{pess} = 16 - 7 = 9$。\n\n**第3部分：调度差异和停顿差异**\n\n**调度差异, $D$**\n$D = |S_{opt}(L_A) - S_{pess}(L_A)| + |S_{opt}(L_B) - S_{pess}(L_B)| + \\dots + |S_{opt}(A) - S_{pess}(A)|$\n$D = |0-0| + |1-1| + |4-4| + |8-7| + |2-9| + |7-12| + |10-15|$\n$D = 0 + 0 + 0 + 1 + 7 + 5 + 5 = 18$\n\n**停顿传播差异, $\\Delta S$**\n$\\Delta S = stalls_{pess} - stalls_{opt} = 9 - 4 = 5$。\n\n**第4部分：标量摘要 $\\Gamma$**\n$$\n\\Gamma = \\frac{D}{\\Delta S} = \\frac{18}{5} = 3.6\n$$\n四舍五入到四位有效数字，我们得到 $3.600$。", "answer": "$$\n\\boxed{3.600}\n$$", "id": "3650816"}]}