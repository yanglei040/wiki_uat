{"hands_on_practices": [{"introduction": "指令调度不仅关乎程序的正确性，更在于追求极致的性能。即使在简单的单发射流水线中，独立指令的执行顺序也至关重要。本练习将通过一个具体的计算任务，向你展示如何通过巧妙地重排指令顺序来规避“载入-使用”相关的流水线停顿，从而有效隐藏延迟，直观地量化编译器优化带来的性能提升 [@problem_id:3646541]。", "problem": "考虑一个单发射、顺序执行、五级流水线，其算术逻辑单元（ALU）具有完全旁路功能。该流水线遵循以下规则，这些规则反映了由写后读（RAW）依赖和固定的生产者延迟引起的标准流水线冒险：\n- 每条指令每个周期尝试发射一次；任何周期内最多只能发射一条指令。\n- 如果一条加载指令紧跟着一条使用其目标寄存器的消费者指令，由于一周期加载-使用延迟，将在该消费者指令前插入恰好一个停顿周期（一个气泡）。如果加载指令和其消费者指令之间至少有一条独立的指令，则不会产生停顿。\n- 在完全旁路的情况下，整数加法的结果延迟为零周期，因此消费整数加法结果的指令可以在紧接着的下一个周期调度，而不会产生停顿。\n- 在本问题中，没有其他来源的停顿或结构性冒险。\n\n给定一个基本块，用于计算归约\n$$R_7 \\leftarrow (R_1 + R_4) + (R_2 + R_6),$$\n其中 $+$ 表示可交换的整数加法。以下指令实现了这个计算，并指明了依赖关系：\n1. $\\mathrm{LD}\\ R_1 \\leftarrow M[\\alpha]$\n2. $\\mathrm{LD}\\ R_2 \\leftarrow M[\\beta]$\n3. $\\mathrm{ADD}\\ R_3 \\leftarrow R_1 + R_4$\n4. $\\mathrm{ADD}\\ R_5 \\leftarrow R_2 + R_6$\n5. $\\mathrm{ADD}\\ R_7 \\leftarrow R_3 + R_5$\n\n由于 $+$ 是可交换的，只要遵守各自加载指令的数据依赖关系，$R_3$ 和 $R_5$ 的生成顺序可以自由排列。考虑以下两种合法的发射顺序（两者都遵守数据依赖图）：\n- 顺序 $\\mathcal{O}_1$: $\\mathrm{LD}\\ R_1$, $\\mathrm{ADD}\\ R_3 \\leftarrow R_1 + R_4$, $\\mathrm{LD}\\ R_2$, $\\mathrm{ADD}\\ R_5 \\leftarrow R_2 + R_6$, $\\mathrm{ADD}\\ R_7 \\leftarrow R_3 + R_5$.\n- 顺序 $\\mathcal{O}_2$: $\\mathrm{LD}\\ R_1$, $\\mathrm{LD}\\ R_2$, $\\mathrm{ADD}\\ R_3 \\leftarrow R_1 + R_4$, $\\mathrm{ADD}\\ R_5 \\leftarrow R_2 + R_6$, $\\mathrm{ADD}\\ R_7 \\leftarrow R_3 + R_5$.\n\n仅使用上述数据依赖和生产者-消费者延迟的基本概念，确定在每种顺序下执行所有五条指令所需的总发射周期数（包括任何自动插入的停顿周期），然后计算较优顺序相对于较差顺序的加速比，定义为\n$$S \\equiv \\frac{T_{\\text{worse}}}{T_{\\text{better}}}.$$\n\n将 $S$ 的最终答案表示为单个简化分数。无需四舍五入，也无需提供单位。", "solution": "本题要求我们分析两种不同的指令调度顺序在单发射流水线上的执行时间，并计算它们之间的加速比。关键在于理解“加载-使用”延迟导致的流水线停顿。\n\n**规则回顾：**\n- **加载-使用延迟**：如果一条指令紧跟在产生其所需数据的加载指令之后发射，必须插入一个停顿周期。如果它们之间至少有一条其他指令，则无需停顿。\n- **ALU-使用延迟**：0个周期，ALU运算结果可以立即在下一个周期使用，无停顿。\n\n**1. 分析顺序 $\\mathcal{O}_1$**\n\n指令序列为：$\\mathrm{LD}\\ R_1$, $\\mathrm{ADD}\\ R_3$, $\\mathrm{LD}\\ R_2$, $\\mathrm{ADD}\\ R_5$, $\\mathrm{ADD}\\ R_7$。\n\n- **周期 1**: 发射 $\\mathrm{LD}\\ R_1$。\n- **周期 2**: 尝试发射 $\\mathrm{ADD}\\ R_3$。该指令使用 $\\mathrm{LD}\\ R_1$ 的结果 $R_1$，并且紧随其后。根据规则，这里会产生一次加载-使用冒险。\n- **周期 3**: **停顿**（流水线气泡），以解决冒险。\n- **周期 4**: 现在可以发射 $\\mathrm{ADD}\\ R_3$。\n- **周期 5**: 发射 $\\mathrm{LD}\\ R_2$。\n- **周期 6**: 尝试发射 $\\mathrm{ADD}\\ R_5$。该指令使用 $\\mathrm{LD}\\ R_2$ 的结果 $R_2$，同样紧随其后，产生一次加载-使用冒险。\n- **周期 7**: **停顿**（流水线气泡）。\n- **周期 8**: 现在可以发射 $\\mathrm{ADD}\\ R_5$。\n- **周期 9**: 发射 $\\mathrm{ADD}\\ R_7$。它依赖于 $\\mathrm{ADD}\\ R_3$ 和 $\\mathrm{ADD}\\ R_5$ 的结果，但由于ALU-使用延迟为0，所以没有停顿。\n\n执行顺序 $\\mathcal{O}_1$ 的总时间 $T_1$ 是 5 条指令 + 2 个停顿周期 = 7 个周期。\n*(注：一个更精确的流水线模型视图是：周期2发射ADD，ADD在执行阶段停顿一个周期。周期4发射LD，周期5发射ADD，ADD停顿。周期7发射最终ADD。总发射周期为 1(LD), 2(ADD), 3(stall), 4(LD), 5(ADD), 6(stall), 7(ADD)。总时间仍然是7个周期。为简化，我们将停顿视为占用一个发射周期。)*\n\n**2. 分析顺序 $\\mathcal{O}_2$**\n\n指令序列为：$\\mathrm{LD}\\ R_1$, $\\mathrm{LD}\\ R_2$, $\\mathrm{ADD}\\ R_3$, $\\mathrm{ADD}\\ R_5$, $\\mathrm{ADD}\\ R_7$。\n\n- **周期 1**: 发射 $\\mathrm{LD}\\ R_1$。\n- **周期 2**: 发射 $\\mathrm{LD}\\ R_2$。\n- **周期 3**: 发射 $\\mathrm{ADD}\\ R_3$。它依赖于 $\\mathrm{LD}\\ R_1$ 的结果，但它们之间被指令 $\\mathrm{LD}\\ R_2$ 隔开。因此，没有停顿。\n- **周期 4**: 发射 $\\mathrm{ADD}\\ R_5$。它依赖于 $\\mathrm{LD}\\ R_2$ 的结果，但它们之间被指令 $\\mathrm{ADD}\\ R_3$ 隔开。因此，也没有停顿。\n- **周期 5**: 发射 $\\mathrm{ADD}\\ R_7$。无停顿。\n\n执行顺序 $\\mathcal{O}_2$ 的总时间 $T_2$ 是 5 条指令 + 0 个停顿周期 = 5 个周期。\n\n**3. 计算加速比**\n\n通过重新排序指令，执行时间从7个周期减少到5个周期。顺序 $\\mathcal{O}_2$ 是更优的调度。\n\n- 较差顺序的执行时间：$T_{\\text{worse}} = T_1 = 7$ 个周期。\n- 较优顺序的执行时间：$T_{\\text{better}} = T_2 = 5$ 个周期。\n\n根据定义计算加速比 $S$：\n$$S = \\frac{T_{\\text{worse}}}{T_{\\text{better}}} = \\frac{7}{5}$$", "answer": "$$\n\\boxed{\\frac{7}{5}}\n$$", "id": "3646541"}, {"introduction": "现代处理器普遍采用超标量架构，能在单个周期内执行多条指令，这为指令调度带来了新的挑战：资源竞争。一个调度方案的优劣，取决于数据依赖链（即关键路径）的长度和硬件资源（如发射宽度）的限制。本练习要求你在一个双发射流水线上调度一个向量点积计算，亲身体验如何在满足数据依赖的同时，高效利用有限的硬件资源，并理解为何资源限制有时会导致实际执行时间超过理论上的关键路径长度 [@problem_id:3646497]。", "problem": "一个编译器以一个用于浮点运算的双发射流水线为目标，必须调度一个计算长度为 $4$ 的点积的基本块。机器模型如下：该流水线每个周期最多可向两个对称的槽位发射 $W=2$ 个操作，除了发射宽度之外没有结构性冒险，唯一的数据冒险由指令延迟决定。一个浮点乘法操作的延迟为 $L_{\\text{mul}}=4$ 个周期，一个浮点加法操作的延迟为 $L_{\\text{add}}=1$ 个周期。一条指令的结果在其发射后恰好 $L$ 个周期变为可用，其中 $L$ 是该指令的延迟。所有输入操作数在周期 $0$ 时均可用，寄存器重命名消除了命名依赖，且基本块中没有内存操作。编译器可以在满足上述约束的条件下，在任何周期的任何槽位中调度任何加法或乘法操作。\n\n向量 $\\{a_k\\}$ 和 $\\{b_k\\}$（其中 $k \\in \\{0,1,2,3\\}$）的点积计算为 $s = \\sum_{k=0}^{3} a_k b_k$。要调度的基本块由四个独立的乘法（产生部分积）和通过三个加法进行的平衡规约（产生最终的标量 $s$）组成。设四个乘法表示为 $m_0,m_1,m_2,m_3$，两个第一级加法表示为 $a_{01}$ 和 $a_{23}$，最终的加法表示为 $a_f$。该基本块的有向无环图 (DAG) 包含边 $m_0 \\rightarrow a_{01}$, $m_1 \\rightarrow a_{01}$, $m_2 \\rightarrow a_{23}$, $m_3 \\rightarrow a_{23}$, 以及 $a_{01} \\rightarrow a_f$, $a_{23} \\rightarrow a_f$，边权重等于生产者指令的延迟。\n\n从有资源约束和固定延迟的DAG上的指令调度的基本原理出发，确定一个能最小化完成时间（makespan）的有效调度。识别哪些周期是完全填充的（两个发射槽位都被使用），并识别依赖图中的一条关键路径。最后，报告 $s$ 变为可用的最早周期索引，从周期 $0$ 作为第一个发射机会开始计算。\n\n将最终答案表示为最小完工时间（以周期为单位），形式为一个不带单位的精确整数。", "solution": "问题要求为双发射处理器上的一个基本块找到一个最优指令调度。一个有效的调度必须同时满足由有向无环图 (DAG) 定义的数据依赖约束，以及由机器发射宽度给出的资源约束。目标是最小化完工时间（makespan），即从执行开始到最终结果可用的时间。\n\n设 $S_i$ 为指令 $i$ 的发射周期，$L_i$ 为其延迟。指令 $i$ 的结果在周期 $S_i + L_i$ 的开始时变为可用。依赖于指令 $i$ 结果的指令 $j$ 不能早于此时间发射。指令集包括四个乘法 $\\{m_0, m_1, m_2, m_3\\}$ 和三个加法 $\\{a_{01}, a_{23}, a_f\\}$。延迟分别为 $L_{\\text{mul}}=4$ 和 $L_{\\text{add}}=1$。机器每个周期最多可以发射 $W=2$ 条指令。所有输入在周期 $0$ 时均可用。\n\n首先，我们确定完工时间的一个下界。完工时间受限于计算依赖图中的最长路径（称为关键路径）以及可用的硬件资源。\n\n1.  **数据依赖界限（关键路径）：** 计算的结构为 $s = (a_0 b_0 + a_1 b_1) + (a_2 b_2 + a_3 b_3)$。这对应一个DAG，其中乘法操作的结果送入第一级加法，而第一级加法的结果又送入最终的加法。从一个输入到最终结果的一条路径涉及一个乘法和两个加法。例如，涉及 $m_0$ 的路径是 $m_0 \\rightarrow a_{01} \\rightarrow a_f$。如果在没有资源约束的情况下调度这些指令，它们的执行将因数据依赖而被串行化。如果 $m_0$ 在周期 $C_0=0$ 发射，其结果在 $C_0 + L_{\\text{mul}} = 4$ 时可用。然后 $a_{01}$ 可以在周期 $C_1=4$ 发射，其结果在 $C_1 + L_{\\text{add}} = 5$ 时可用。最后，$a_f$ 可以在周期 $C_2=5$ 发射，最终结果 $s$ 在 $C_2 + L_{\\text{add}} = 6$ 时可用。因此，DAG的关键路径长度为 $L_{\\text{mul}} + L_{\\text{add}} + L_{\\text{add}} = 4 + 1 + 1 = 6$ 个周期。所以完工时间必须至少为 $6$ 个周期。\n\n2.  **资源界限：** 该基本块总共包含 $7$ 条指令（$4$ 个乘法，$3$ 个加法）。对于双发射机器（$W=2$），发射所有指令至少需要 $\\lceil \\frac{7}{2} \\rceil = 4$ 个周期。特别是对于乘法，有 $4$ 条独立指令。发射它们至少需要 $\\lceil \\frac{4}{2} \\rceil = 2$ 个周期。\n\n我们将使用贪心方法（也称为列表调度）来构建一个调度。在每个周期，我们识别出“就绪”指令集——即那些数据依赖已满足的指令——并从中发射最多 $W=2$ 条指令。\n\n**周期 $0$：**\n初始就绪集包含四个乘法：$\\{m_0, m_1, m_2, m_3\\}$，因为它们的输入都可用。我们可以发射其中的两个。我们发射 $m_0$ 和 $m_1$。\n- **调度：** 发射 $m_0$, $m_1$。\n- **状态：** $m_0, m_1$ 正在执行中。它们的结果将在周期 $0 + L_{\\text{mul}} = 4$ 时可用。\n\n**周期 $1$：**\n就绪集现在包含剩余的乘法：$\\{m_2, m_3\\}$。我们发射 $m_2$ 和 $m_3$。\n- **调度：** 发射 $m_2$, $m_3$。\n- **状态：** $m_0, m_1, m_2, m_3$ 正在执行中。$m_2, m_3$ 的结果将在周期 $1 + L_{\\text{mul}} = 5$ 时可用。\n\n**周期 $2$ 和 $3$：**\n没有指令就绪。加法 $a_{01}$ 和 $a_{23}$ 正在等待乘法的结果。这会产生一个停顿。\n- **调度：** 停顿（没有指令发射）。\n\n**周期 $4$：**\n$m_0$ 和 $m_1$ 的结果现在可用。这使得指令 $a_{01}$ 就绪，因为它的两个依赖都已满足。就绪集是 $\\{a_{01}\\}$。\n- **调度：** 发射 $a_{01}$。一个发射槽位未使用。\n- **状态：** $a_{01}$ 的结果将在周期 $4 + L_{\\text{add}} = 5$ 时可用。\n\n**周期 $5$：**\n$m_2$ 和 $m_3$ 的结果变为可用。这使得指令 $a_{23}$ 就绪。同样在周期 $5$，$a_{01}$ 的结果也变为可用。就绪集是 $\\{a_{23}\\}$。最终加法 $a_f$ 的另一个输入尚未就绪。\n- **调度：** 发射 $a_{23}$。一个发射槽位未使用。\n- **状态：** $a_{23}$ 的结果将在周期 $5 + L_{\\text{add}} = 6$ 时可用。\n\n**周期 $6$：**\n$a_{23}$ 的结果现在可用。$a_{01}$ 的结果从周期 $5$ 开始就已可用。最终加法 $a_f$ 的两个输入现在都已就绪。就绪集是 $\\{a_f\\}$。\n- **调度：** 发射 $a_f$。一个发射槽位未使用。\n- **状态：** 最终结果 $s$ 将在周期 $6 + L_{\\text{add}} = 7$ 时可用。\n\n**周期 $7$：**\n计算完成。结果 $s$ 可用。\n\n此调度的完工时间是 $7$ 个周期。这比 $6$ 个周期的关键路径界限要长。原因是资源约束。$W=2$ 的发射宽度迫使四个独立的乘法被调度在两个周期内完成。在周期 $1$ 发射的乘法（$m_2, m_3$）比在周期 $0$ 发射的乘法晚一个周期完成。这个一周期延迟沿着依赖链传播，延迟了 $a_{23}$ 并随后延迟了 $a_f$，与理论上的、无资源约束的下界相比，最终使总执行时间增加了一个周期。没有其他调度可以做得更好，因为调度四个乘法至少需要两个周期，这不可避免地在其结果的可用性上造成了一个周期的交错。这种交错无法克服。\n\n**分析总结：**\n- **最小完工时间：** $s$ 可用的最早周期是周期 $7$。\n- **完全填充周期：** 如果两个发射槽位都被使用，则该周期是完全填充的。在此调度中，周期 $0$（发射了 $m_0, m_1$）和周期 $1$（发射了 $m_2, m_3$）是完全填充的。\n- **关键路径：** 调度的关键路径是决定完工时间的依赖指令序列。完成时间由 $a_f$ 的结果在周期 $7$ 的可用性决定。这是因为 $a_f$ 在周期 $6$ 被发射，而这又是因为其最晚到达的输入（来自 $a_{23}$）在周期 $6$ 才可用。$a_{23}$ 在周期 $5$ 的发射是由于其输入（来自 $m_2$ 和 $m_3$）在周期 $5$ 才变为可用。而 $m_2$ 和 $m_3$ 在周期 $1$ 的发射是由于资源约束，因为 $m_0$ 和 $m_1$ 占据了周期 $0$ 的发射槽位。因此，该调度的一条关键路径是链 $m_2 \\rightarrow a_{23} \\rightarrow a_f$（或 $m_3 \\rightarrow a_{23} \\rightarrow a_f$），其中第一个依赖是资源引起的，而后续的依赖是真正的数据依赖。“依赖图中的关键路径”可以理解为在最终调度中成为关键路径的抽象DAG中的一条路径。\n\n所要求的最终答案是 $s$ 变为可用的最早周期索引。这就是最优调度的完工时间。\n最终完工时间 = $7$ 个周期。", "answer": "$$\\boxed{7}$$", "id": "3646497"}, {"introduction": "真实世界的程序充满了分支，仅仅在单个基本块内进行调度会错失大量优化机会，因此编译器需要采用跨越分支的全局调度技术。本练习将带你探索超块（superblock）调度，这是一种将高频执行路径（hot trace）视为一个整体进行优化的全局策略，它允许将后续基本块的指令“推测性地”提前到分支指令之前执行。通过对比局部调度和全局调度的性能差异，你将学会量化推测执行在“热路径”上带来的加速，以及在“冷路径”上可能引入的开销，从而理解高级优化中的性能权衡 [@problem_id:3646565]。", "problem": "一个编译器后端的目标是一个简单的标量机，必须调度一个包含一条热路径和一个非热路径分支的区域。目标是对比局部基本块调度与在热路径上进行的全局超块调度，并量化热路径上的改进以及由于推测性移动而在非热路径上产生的开销。机器模型和区域如下。\n\n机器模型假设：\n- 单发射：每个周期最多可以发射 $1$ 条指令。\n- 固定延迟：整数加法延迟为 $1$，整数乘法延迟为 $2$，加载延迟为 $3$，存储延迟为 $1$，分支延迟为 $1$。\n- 使用由前一条指令产生的值的指令，其发射周期不能早于生产者的发射周期加上其延迟。没有其他结构性冒险。\n- 已知该区域中的所有加载都是不会出错且无副作用的，因此可以在不改变程序语义的情况下在分支之前进行推测。算术指令没有副作用。存储和分支指令具有其通常的副作用，不能跨越其动态控制依赖进行推测。\n\n控制流区域：\n- 块 $A$ (入口)：\n  - $a_1$：整数加法 (延迟 $1$)\n  - $a_2$：整数乘法 (延迟 $2$)，依赖于 $a_1$ 的结果\n  - $a_3$：条件分支 (延迟 $1$)，依赖于 $a_2$ 的结果；以概率 $p_B$ 跳转到 $B$ (热路径)，以概率 $1 - p_B$ 跳转到 $C$ (非热路径)\n- 块 $B$ (A 的热后继)：\n  - $b_1$：加载 (延迟 $3$)，独立于 $A$\n  - $b_2$：整数乘法 (延迟 $2$)，依赖于 $b_1$ 的结果，并产生值 $g$\n- 块 $C$ (A 的非热路径后继)：\n  - $c_1$：整数加法 (延迟 $1$)\n  - $c_2$：整数乘法 (延迟 $2$)，依赖于 $c_1$ 的结果，并产生值 $g$\n- 块 $D$ (B 和 C 之后的汇合点)：\n  - $d_1$：存储 (延迟 $1$)，使用 $g$\n\n应用的调度规则：\n- 在局部基本块调度下，每个块独立调度；任何指令都不能跨越块边界移动。当沿某条路径执行时，如果后继块中的消费者指令在其生产者值就绪之前到达（由于延迟），执行必须停顿，插入所需数量的无操作指令，直到值就绪可以发射消费者指令。\n- 在全局超块调度下，将热路径 $A \\rightarrow B \\rightarrow D$ 视为一个单一的调度区域。只要遵守依赖关系且上述合法性假设成立，您可以将 $B$ 中的指令向上移动到 $A$ 中 $a_3$ 之前。您不能将 $d_1$ 移动到 $a_3$ 之上。非热路径 $A \\rightarrow C \\rightarrow D$ 会执行放置在 $a_3$ 之前的任何推测性操作，即使分支跳转到 $C$；在那种路径上，这些操作成为浪费的工作。\n\n给定热分支概率 $p_B = 0.8$，请完成以下操作：\n- 在局部基本块调度下，推导出热路径和非热路径上的最小周期调度，计算由块内和块间依赖引起的所有必要停顿。\n- 在全局超块调度下，推导出热路径（超块路径 $A \\rightarrow B \\rightarrow D$）和非热路径（$A \\rightarrow C \\rightarrow D$）上的最小周期调度，在合法的情况下将 $B$ 的指令推测性地移动到分支 $a_3$ 之前，并考虑非热路径上浪费的执行。\n- 根据这些调度，使用给定的 $p_B$ 计算局部基本块调度的每次区域进入的期望周期数 $E_{\\text{local}}$ 和全局超块调度的期望周期数 $E_{\\text{super}}$。\n- 最后，计算定义为 $E_{\\text{local}} / E_{\\text{super}}$ 的加速比。\n\n将您的最终数值答案（加速比）四舍五入到四位有效数字。答案中不要包含任何单位。在计算期望值时，将分支概率表示为小数 $0.8$。", "solution": "我们从局部基本块调度和全局超块调度的基本定义开始。在这两种情况下，机器每个周期最多发射 $1$ 条指令，并且消费者指令的发射周期必须至少是生产者的发射周期加上生产者的延迟。在局部调度下，不允许跨块边界的代码移动，因此在进入后继块时，块间依赖可能导致停顿。在超块调度下，只要保持数据依赖和控制依赖的合法性，代码可以沿着热路径向上移动；我们假设加载和算术指令可以在分支前安全地进行推测，但存储指令 $d_1$ 不能被提升到 $a_3$ 之上。\n\n步骤 $1$：局部基本块调度和路径周期。\n\n- 块 $A$ 有 $a_1$（延迟 $1$），$a_2$（延迟 $2$）依赖于 $a_1$，以及 $a_3$（延迟 $1$）依赖于 $a_2$。在单发射的情况下：\n  - 在周期 $1$ 发射 $a_1$。\n  - 因为 $a_2$ 依赖于 $a_1$ 且 $a_1$ 的延迟为 $1$，我们可以在周期 $2$ 发射 $a_2$。\n  - $a_3$ 依赖于在周期 $2$ 发射的 $a_2$（延迟为 $2$），所以 $a_3$ 最早可以在周期 $2 + 2 = 4$ 发射。因此，周期 $3$ 是一个停顿，我们在周期 $4$ 发射 $a_3$。\n  - 因此，块 $A$ 占用周期 $1$ 到 $4$。\n\n- 块 $B$ 有独立的 $b_1$（延迟 $3$）和依赖于 $b_1$ 的 $b_2$（延迟 $2$）：\n  - 在 $B$ 的相对周期 $1$ 发射 $b_1$。\n  - $b_2$ 可以在相对周期 $1 + 3 = 4$ 发射，因此相对周期 $2$ 和 $3$ 是停顿。\n  - 因此，进入 $B$ 时，它占用 $4$ 个周期。\n\n- 块 $C$ 有 $c_1$（延迟 $1$）和依赖于 $c_1$ 的 $c_2$（延迟 $2$）：\n  - 在相对周期 $1$ 发射 $c_1$。\n  - 由于 $1 + 1 = 2$，在相对周期 $2$ 发射 $c_2$。\n  - 因此，进入 $C$ 时，它占用 $2$ 个周期。\n\n- 块 $D$ 有一个使用 $g$ 的单一存储指令 $d_1$。在局部调度下，$d_1$ 不能被移动到块 $D$ 之前，因此从前驱块进入 $D$ 时，我们可能需要停顿直到 $g$ 就绪。\n\n现在通过序列化这些块并遵守在 $D$ 处对 $g$ 的跨块就绪性来计算每条路径的总周期。\n\n热路径 $A \\rightarrow B \\rightarrow D$：\n- $A$ 使用周期 $1$ 到 $4$；在周期 $5$ 进入 $B$。\n- 在 $B$ 中：在周期 $5$ 发射 $b_1$，在周期 $6$ 和 $7$ 停顿，在周期 $8$ 发射 $b_2$。来自 $b_2$（延迟为 $2$）的结果 $g$ 在周期 $8 + 2 = 10$ 时就绪。\n- 在周期 $9$（紧随 $B$ 完成后）进入 $D$。由于 $g$ 直到周期 $10$ 才就绪，我们必须在周期 $9$ 停顿，并在周期 $10$ 发射 $d_1$。\n- 热路径在周期 $10$ 完成。\n\n冷路径 $A \\rightarrow C \\rightarrow D$：\n- $A$ 使用周期 $1$ 到 $4$；在周期 $5$ 进入 $C$。\n- 在 $C$ 中：在周期 $5$ 发射 $c_1$，在周期 $6$ 发射 $c_2$。来自 $c_2$（延迟为 $2$）的结果 $g$ 在周期 $6 + 2 = 8$ 时就绪。\n- 在周期 $7$ 进入 $D$。由于 $g$ 直到周期 $8$ 才就绪，在周期 $7$ 停顿，并在周期 $8$ 发射 $d_1$。\n- 冷路径在周期 $8$ 完成。\n\n因此，在局部基本块调度下：\n- 热路径周期：$10$。\n- 冷路径周期：$8$。\n\n步骤 $2$：热路径 $A \\rightarrow B \\rightarrow D$ 的全局超块调度和非热路径行为。\n\n在超块调度下，我们将热路径视为一个单一的调度区域。由于 $b_1$ 和 $b_2$ 无副作用且遵守数据依赖，我们可以将 $B$ 的指令向上移动到分支 $a_3$ 之前。我们不能将 $d_1$ 移动到 $a_3$ 之前。\n\n我们选择一个能将 $b_1$ 的 $3$ 周期延迟隐藏在 $A$ 的工作之下的顺序：\n- 在周期 $1$ 发射 $b_1$，以尽早开始长延迟的加载。\n- 在周期 $2$ 发射 $a_1$。\n- 在周期 $3$ 发射 $a_2$（依赖于 $a_1$，延迟为 $1$）。\n- $b_2$ 依赖于 $b_1$，延迟为 $3$，所以它可以在周期 $1 + 3 = 4$ 发射。在周期 $4$ 发射 $b_2$。\n- $a_3$ 依赖于在周期 $3$ 发射的 $a_2$（延迟为 $2$），所以 $a_3$ 可以在周期 $3 + 2 = 5$ 发射。在周期 $5$ 发射 $a_3$。\n- 在热路径上（分支到 $B$），我们继续执行到 $D$。在周期 $4$ 发射的 $b_2$（延迟为 $2$）产生的值 $g$ 在周期 $6$ 就绪，所以在周期 $6$ 发射 $d_1$。\n- 在非热路径上（分支到 $C$），我们仍然执行了分支前推测的 $b_1$ 和 $b_2$，然后在周期 $6$ 进入 $C$ 并局部调度 $C$：在周期 $6$ 发射 $c_1$，在周期 $7$ 发射 $c_2$，然后来自 $c_2$（延迟为 $2$）的 $g$ 在周期 $9$ 就绪，所以在周期 $9$ 发射 $d_1$。\n\n因此，在超块调度下：\n- 热路径周期：在周期 $6$ 完成。\n- 非热路径周期：在周期 $9$ 完成。\n- 相对于局部调度，热路径上的改进是节省了 $10 - 6 = 4$ 个周期。\n- 在非热路径上以浪费的工作形式体现的补偿开销是该路径上额外的 $9 - 8 = 1$ 个周期。\n\n步骤 $3$：使用 $p_B = 0.8$ 计算期望周期和加速比。\n\n设 $p_B = 0.8$ 且 $1 - p_B = 0.2$。\n\n局部调度期望周期：\n$$\nE_{\\text{local}} = p_B \\cdot 10 + (1 - p_B) \\cdot 8 = 0.8 \\cdot 10 + 0.2 \\cdot 8 = 8 + 1.6 = 9.6.\n$$\n\n超块调度期望周期：\n$$\nE_{\\text{super}} = p_B \\cdot 6 + (1 - p_B) \\cdot 9 = 0.8 \\cdot 6 + 0.2 \\cdot 9 = 4.8 + 1.8 = 6.6.\n$$\n\n加速比：\n$$\n\\text{Speedup} = \\frac{E_{\\text{local}}}{E_{\\text{super}}} = \\frac{9.6}{6.6} = 1.454545\\ldots\n$$\n\n四舍五入到四位有效数字，加速比为 $1.455$。", "answer": "$$\\boxed{1.455}$$", "id": "3646565"}]}