{"hands_on_practices": [{"introduction": "模调度（Modulo Scheduling）的核心是确定最优的启动间隔（Initiation Interval, II），该间隔受两个基本因素的制约：机器的资源限制（ResMII）和数据依赖的延迟限制（RecMII）。本练习将引导你亲手计算这两个基本的下界，并理解它们如何共同决定最终的最小启动间隔（MII）。通过解决这个练习 [@problem_id:3658402]，你将学会在平衡资源和依赖约束的条件下，构建一个有效且无冲突的调度方案。", "problem": "一个编译器使用模调度（modulo scheduling）来对一个循环进行流水线化。该循环在一台拥有两个算术逻辑单元（ALU）和一个乘法单元（MUL）的机器上运行。ALU执行加法操作，MUL执行乘法操作。所有功能单元都是完全流水线化的，每个周期的发射率为$1$，一个操作仅在其发射的那个周期占用其单元。加法延迟为$1$个周期，乘法延迟为$2$个周期；也就是说，一个加法在开始后$1$个周期产生其结果，一个乘法在开始后$2$个周期产生其结果。\n\n考虑每次迭代 $i$ 的以下循环体：\n- $N_1$: $x_i \\leftarrow a_i + b_i$ (加法)，\n- $N_2$: $y_i \\leftarrow c_i + d_i$ (加法)，\n- $N_3$: $s_i \\leftarrow s_{i-1} + e_i$ (加法，从迭代 $i-1$ 到 $i$ 的循环携带相关，相关距离为 $1$)，\n- $N_4$: $z_i \\leftarrow x_i \\times k$ (乘法，在同一次迭代中依赖于 $N_1$)。\n\n假设有无限的寄存器，并且内存访问与计算完全重叠（没有来自内存的额外资源或延迟约束），并且只有所述的功能单元和延迟约束调度。\n\n从模调度中关于资源吞吐量和相关性时间安排的基本原理出发，确定该循环在给定机器上的资源受限的最小启动间隔（ResMII），然后以计算出的 $ResMII$ 相等的启动间隔构建一个无冲突的模调度核心。该核心必须：\n- 为每个操作 $N_1$、$N_2$、$N_3$、$N_4$ 分配一个模启动时间 $t(N_j) \\in \\{0, 1, \\ldots, \\mathrm{II}-1\\}$，\n- 在每个模时间点上尊重资源容量（每个模时间点发射的加法操作不超过 $2$ 个，乘法操作不超过 $1$ 个），\n- 满足所有数据相关性时间约束，包括循环携带相关。\n\n将你的最终答案表示为 $ResMII$ 的数值。不需要四舍五入。", "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。这是一个建立在编译器理论和计算机体系结构原理基础上的适定问题，特别是在指令级并行和软件流水线领域。所有参数和约束都已明确定义，没有内部矛盾或事实不准确之处。\n\n该问题要求我们确定给定循环体的资源受限最小启动间隔（$ResMII$），并为该 $II$ 构建一个有效的模调度。启动间隔（$II$）是在软件流水线循环中连续迭代开始之间的时钟周期数。最小可能 $II$，记作 $MII$，受资源可用性和循环携带数据相关的双重约束。\n$$\nMII = \\max(\\text{ResMII}, \\text{RecMII})\n$$\n\n首先，我们计算 $ResMII$。这由循环的资源使用情况决定。对于每种资源类型 $r$，最小间隔是需要该资源的操作数量 $N_r$ 与该类型可用功能单元数量 $R_r$ 之比的向上取整。总的 $ResMII$ 是所有资源类型的最大值。\n$$\nResMII = \\max_{r} \\left\\lceil \\frac{N_r}{R_r} \\right\\rceil\n$$\n循环体包含以下操作：\n- $N_1$: 加法 (ALU)\n- $N_2$: 加法 (ALU)\n- $N_3$: 加法 (ALU)\n- $N_4$: 乘法 (MUL)\n\n每种资源类型的操作数量为：\n- ALU 的加法操作：$N_{ALU} = 3$\n- MUL 的乘法操作：$N_{MUL} = 1$\n\n可用的机器资源为：\n- ALU 单元：$R_{ALU} = 2$\n- MUL 单元：$R_{MUL} = 1$\n\n每种资源类型对 $ResMII$ 的贡献为：\n- 对于 ALU：$\\text{ResMII}_{\\text{ALU}} = \\left\\lceil \\frac{N_{ALU}}{R_{ALU}} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = \\lceil 1.5 \\rceil = 2$\n- 对于 MUL：$\\text{ResMII}_{\\text{MUL}} = \\left\\lceil \\frac{N_{MUL}}{R_{MUL}} \\right\\rceil = \\left\\lceil \\frac{1}{1} \\right\\rceil = 1$\n\n总的 $ResMII$ 是这些值的最大值：\n$$\n\\text{ResMII} = \\max(2, 1) = 2\n$$\n\n接下来，我们计算 $RecMII$。这由循环携带相关（也称为递归）决定。对于涉及一系列操作的递归循环， $RecMII$ 是循环中操作延迟总和与相关距离总和之比的向上取整。\n$$\nRecMII = \\max_{\\text{recurrences } p} \\left\\lceil \\frac{\\sum_{\\text{ops } j \\in p} \\text{latency}(j)}{\\sum_{\\text{deps } e \\in p} \\text{distance}(e)} \\right\\rceil\n$$\n在这个问题中，有一个指定的递归：\n- 操作 $N_3: s_i \\leftarrow s_{i-1} + e_i$ 依赖于其前一次迭代的结果。这形成了一个递归循环 $N_3 \\to N_3$。\n- 操作 $N_3$ (加法) 的延迟是 $L(N_3) = 1$ 个周期。\n- 相关距离给定为 $\\delta = 1$ 次迭代。\n\n这个递归的 $RecMII$ 是：\n$$\n\\text{RecMII} = \\left\\lceil \\frac{L(N_3)}{\\delta} \\right\\rceil = \\left\\lceil \\frac{1}{1} \\right\\rceil = 1\n$$\n\n现在，我们可以找到总的最小启动间隔 ($MII$):\n$$\nMII = \\max(\\text{ResMII}, \\text{RecMII}) = \\max(2, 1) = 2\n$$\n最小可能的启动间隔是 $2$ 个周期。问题要求 $ResMII$ 的值，我们计算出为 $2$。我们现在必须验证是否可以为 $II = ResMII = 2$ 构建一个无冲突的调度。\n\n模调度为循环体中的每个操作 $N_j$ 分配一个启动时间 $t(N_j) \\in \\{0, 1, \\dots, II-1\\}$。对于 $II=2$，可能的时间是 $t=0$ 和 $t=1$。调度必须同时满足资源和相关性约束。\n\n数据相关约束由以下不等式表示，该不等式适用于从操作 $N_u$到操作 $N_v$ 的相关，其中延迟为 $L(N_u)$，距离为 $\\delta$：\n$$\nt(N_u) + L(N_u) \\le t(N_v) + \\delta \\times II\n$$\n让我们分析一下我们问题中 $II=2$ 的相关性：\n1.  迭代内相关 $N_1 \\to N_4$:\n    - $N_u=N_1$, $N_v=N_4$, $L(N_1)=1$ (加法延迟), $\\delta=0$。\n    - $t(N_1) + 1 \\le t(N_4) + 0 \\times 2 \\implies t(N_1) + 1 \\le t(N_4)$。\n2.  循环携带相关 $N_3 \\to N_3$:\n    - $N_u=N_3$, $N_v=N_3$, $L(N_3)=1$ (加法延迟), $\\delta=1$。\n    - $t(N_3) + 1 \\le t(N_3) + 1 \\times 2 \\implies 1 \\le 2$。这是一个平凡的约束，总是被满足，并且证实了我们的 $RecMII$ 计算。\n\n主要的调度约束是 $t(N_1) + 1 \\le t(N_4)$。由于 $t(N_1)$ 和 $t(N_4)$ 必须在 $\\{0, 1\\}$ 中，这个不等式只能在 $t(N_1)=0$ 和 $t(N_4)=1$ 时被满足。\n\n让我们固定这些分配，并调度剩余的操作 $N_2$ (加法) 和 $N_3$ (加法)。\n- 在时间 $t=0$ 调度：我们已经调度了 $N_1$ (加法)。一个 ALU 被使用。我们还剩下一个 ALU 单元和一个 MUL 单元。\n- 在时间 $t=1$ 调度：我们已经调度了 $N_4$ (乘法)。一个 MUL 被使用。我们还剩下两个 ALU 单元和零个 MUL 单元。\n\n我们可以将剩余的两个加法操作 $N_2$ 和 $N_3$ 放置在可用的槽位中。一个可能的有效调度是：\n- 将 $N_2$ (加法) 放置在时间 $t=0$。\n- 将 $N_3$ (加法) 放置在时间 $t=1$。\n\n提议的核心调度是：\n- $t(N_1) = 0$\n- $t(N_2) = 0$\n- $t(N_3) = 1$\n- $t(N_4) = 1$\n\n让我们验证这个调度：\n- **资源约束：**\n  - 在时间 $t=0$：发射 $N_1$ 和 $N_2$。这需要 $2$ 个 ALU。机器有 $2$ 个 ALU。这是有效的。\n  - 在时间 $t=1$：发射 $N_3$ 和 $N_4$。这需要 $1$ 个 ALU 和 $1$ 个 MUL。机器有 $2$ 个 ALU 和 $1$ 个 MUL。这是有效的。\n- **相关性约束：**\n  - $t(N_1) + 1 \\le t(N_4) \\implies 0 + 1 \\le 1$，这是成立的。\n\n该调度是有效的。这证实了该循环可以用等于计算出的 $ResMII$ 的启动间隔 $II=2$ 进行流水线化。\n\n问题要求资源受限的最小启动间隔 ($ResMII$) 的数值。根据我们的推导，这个值是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3658402"}, {"introduction": "一个高效的编译器不仅要调度现有代码，更要主动地对其进行转换以挖掘更高的性能。本练习探索了代码优化（特别是强度削减）与模调度之间强大的协同作用。通过将一个高延迟的乘法操作替换为一个低延迟的移位操作 [@problem_id:3658415]，你将直接观察到它对循环依赖约束（RecMII）和资源约束（ResMII）的影响，从而揭示不同优化阶段如何共同提升指令级并行度。", "problem": "考虑以下循环和目标机器模型，用于模调度中的软件流水线。您需要根据依赖约束和资源约束下限的第一性原理来推断启动间隔（II）。\n\n循环体（单个基本块，稳态）：\n- 设 $x$ 和 $acc$ 是跨迭代传递的标量变量，其初始值 $x_{0}$ 和 $acc_{0}$ 在循环开始前设置。\n- 在每次迭代 $i$ 中：\n  - 通过 $x \\leftarrow 8 \\cdot x + b$ 更新 $x$，其中 $b$ 是一个寄存器中可用的整数常量。\n  - 累加 $acc \\leftarrow acc + x$。\n  - 将当前累加器存入内存 $B[i] \\leftarrow acc$。\n  - 增加循环索引 $i \\leftarrow i + 1$。\n\n机器模型：\n- 寄存器到寄存器指令的操作延迟（以周期为单位）：\n  - 整数加法延迟为 $1$。\n  - 按常量左移延迟为 $1$。\n  - 整数乘法延迟为 $4$。\n- 内存模型：\n  - 存储指令在专用的内存流水线上以 $1$ 个周期的延迟发射（存储完成延迟不计入任何循环携带的递归；不存在跨迭代的内存依赖）。\n- 发射能力（每周期）：\n  - 整数乘法（MUL）流水线：能力为每周期 $1$ 个。\n  - 整数算术逻辑单元（ALU），由加法和移位共享：能力为每周期 $2$ 个。\n  - 用于存储的内存流水线：能力为每周期 $1$ 个。\n\n关于依赖的假设：\n- 唯一的循环携带标量依赖是：\n  - 由更新 $x \\leftarrow 8 \\cdot x + b$ 定义的关于 $x$ 的递归，距离为 $1$。\n  - 由 $acc \\leftarrow acc + x$ 定义的关于 $acc$ 的递归，距离为 $1$。\n- 不存在跨迭代的内存依赖（每个 $B[i]$ 都是唯一的）。\n- 所有值在使用时都在寄存器中；$b$ 是循环不变量；指令延迟是精确的且完全流水化的。\n\n任务：\n- 对 $x$ 的更新应用了强度削减的归纳更新，将乘以 $8$ 替换为左移 $3$ 位。即，更新变为 $x \\leftarrow (x \\ll 3) + b$，其中 $\\ll$ 表示左移并使用 ALU。\n- 仅使用模调度中启动间隔的递归约束下限和资源约束下限的定义，确定此转换后的新启动间隔。您必须考虑这两个下限，并报告转换后的最终 $II$。\n\n请以单个整数形式提供您的最终答案。最终答案中不得报告任何中间结果。没有舍入要求。", "solution": "该问题是有效的。这是编译器理论和计算机体系结构领域内一个适定问题，特别涉及指令调度和循环优化。所有必要的数据，如操作延迟、资源容量和依赖信息都已提供，并且没有内部矛盾或科学上的不准确之处。\n\n任务是确定给定循环在强度削减转换后的最小启动间隔（$II$）。模调度中的启动间隔受两个下限约束：递归约束的启动间隔（$RecMII$）和资源约束的启动间隔（$ResMII$）。最终的 $II$ 必须至少是这两个下限的最大值。\n$$II \\ge \\max(\\text{RecMII}, \\text{ResMII})$$\n我们将为转换后的循环计算这两个下限。\n\n首先，让我们分析强度削减后循环体内的操作。乘法 $x \\leftarrow 8 \\cdot x + b$ 被替换为左移和加法：$x \\leftarrow (x \\ll 3) + b$。$\\ll$ 操作，即左移 $3$ 位，使用算术逻辑单元（ALU）。\n\n转换后循环的一次迭代中的操作是：\n1.  一个左移操作：$t \\leftarrow x \\ll 3$。这使用 ALU，其延迟为 $1$ 个周期。\n2.  一个加法操作：$x \\leftarrow t + b$。这使用 ALU，其延迟为 $1$ 个周期。\n3.  一个加法操作：$acc \\leftarrow acc + x$。这使用 ALU，其延迟为 $1$ 个周期。\n4.  一个存储操作：$B[i] \\leftarrow acc$。这使用内存（MEM）流水线，并在 $1$ 个周期内发射。\n\n现在我们计算启动间隔的两个下限。\n\n**1. 递归约束的启动间隔（$RecMII$）**\n\n$RecMII$ 由最长的循环携带依赖环路决定。一个环路 $c$ 的贡献公式为 $\\lceil \\frac{c \\text{ 中的延迟总和}}{c \\text{ 中的依赖距离总和}} \\rceil$。我们必须在循环依赖图的所有基本递归环路中找到这些值的最大值。问题陈述有两个循环携带的标量依赖，每个距离为 $1$。\n\n-   **关于 $x$ 的递归**：一次迭代中 $x$ 的值依赖于前一次迭代中它的值。更新 $x \\leftarrow (x \\ll 3) + b$ 由两个依赖操作链组成：一个移位后跟一个加法。\n    -   这个递归在处理器内的路径是：来自前一次迭代的 $x$ 值 $\\rightarrow$ SHIFT 操作 $\\rightarrow$ ADD 操作 $\\rightarrow$ 新的 $x$ 值。\n    -   此操作链的总延迟是移位和加法延迟的总和：$1 + 1 = 2$ 个周期。\n    -   依赖距离给定为 $1$。\n    -   此递归所施加的最小启动间隔为 $\\lceil \\frac{2}{1} \\rceil = 2$。\n\n-   **关于 $acc$ 的递归**：一次迭代中 $acc$ 的值依赖于前一次迭代中它的值。更新为 $acc \\leftarrow acc + x$。\n    -   此递归中的核心操作是加法本身。来自前一次迭代的 $acc$ 值是此 ADD 操作的输入。\n    -   ADD 操作的延迟是 $1$ 个周期。\n    -   依赖距离给定为 $1$。\n    -   此递归所施加的最小启动间隔为 $\\lceil \\frac{1}{1} \\rceil = 1$。请注意，虽然 $acc$ 的计算也依赖于 $x$ 的新值，但这个迭代内依赖不会为 $acc$ 创建更长的基本递归环路。$acc$ 的环路只涉及将先前的 $acc$ 与新的 $x$ 相加的 ADD 操作。\n\n$RecMII$ 是每个递归所需的最小间隔的最大值。\n$$\\text{RecMII} = \\max(2, 1) = 2$$\n\n**2. 资源约束的启动间隔（$ResMII$）**\n\n$ResMII$ 由对每种功能单元的需求决定。对于每种资源类型 $R$，其贡献为 $\\lceil \\frac{\\text{使用 } R \\text{ 的操作数}}{\\text{每周期 } R \\text{ 的容量}} \\rceil$。\n\n我们来统计一下转换后循环的一次迭代的资源使用情况：\n-   **整数乘法（MUL）单元：** 乘法已被移位替换，所以有 $0$ 个操作使用 MUL 单元。\n    -   容量：每周期 $1$ 个。\n    -   $ResMII_{MUL} = \\lceil \\frac{0}{1} \\rceil = 0$。\n\n-   **算术逻辑单元（ALU）：** ALU 用于移位和两次加法。\n    -   操作：$1$（移位） $+ 2$（加法） $= 3$ 个操作。\n    -   容量：每周期 $2$ 个。\n    -   $ResMII_{ALU} = \\lceil \\frac{3}{2} \\rceil = \\lceil 1.5 \\rceil = 2$。\n\n-   **内存（MEM）单元：** MEM 单元用于存储操作。\n    -   操作：$1$（存储）。\n    -   容量：每周期 $1$ 个。\n    -   $ResMII_{MEM} = \\lceil \\frac{1}{1} \\rceil = 1$。\n\n$ResMII$ 是对任何单一资源类型施加的最大需求。\n$$\\text{ResMII} = \\max(\\text{ResMII}_{\\text{MUL}}, \\text{ResMII}_{\\text{ALU}}, \\text{ResMII}_{\\text{MEM}}) = \\max(0, 2, 1) = 2$$\n\n**结论：最终启动间隔（$II$）**\n\n循环的最小启动间隔是递归约束和资源约束下限的最大值。\n$$II = \\max(\\text{RecMII}, \\text{ResMII}) = \\max(2, 2) = 2$$\n因此，转换后的新启动间隔为 $2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3658415"}, {"introduction": "一个理论上最优的调度方案在实践中并不总是正确的，因为重叠的循环迭代可能会在使用相同寄存器时产生细微的冲突。本练习聚焦于一个关键的实现细节：使用模变量扩展（Modulo Variable Expansion, MVE）技术来解决“先读后写”（WAR）反依赖问题。通过分析变量在不同迭代间的生命周期 [@problem_id:3658367]，你将学会如何识别并修复这些隐藏的冲突，确保最终生成的流水线代码不仅运行迅速，而且功能正确。", "problem": "考虑以下一个旨在通过模调度进行软件流水线处理的循环，其启动间隔 (II) 定义为 $\\mathrm{II}$。循环体包含四个相关操作，这些操作在单发射、全流水的功能单元上执行，并具有指定的延迟（以周期为单位）：\n- $S_1$: 生成标量 $x$，延迟为 $2$，\n- $S_2$: 使用 $x$ 生成 $y$，延迟为 $1$，\n- $S_4$: 使用 $x$ 生成 $\\mathrm{tmp}$，延迟为 $5$，\n- $S_5$: 使用 $\\mathrm{tmp}$ 更新一个累加器，延迟为 $1$。\n\n假设在一个启动间隔 $\\mathrm{II} = 2$ 的候选模调度中，对于迭代 $i \\in \\mathbb{Z}_{\\ge 0}$，操作被安排在以下绝对时间（以周期为单位）：\n- $S_1$ 在时间 $2i + 0$ 发射，并在时间 $2i + 2$ 写入 $x$，\n- $S_2$ 在时间 $2i + 3$ 发射（在其发射时间读取 $x$ 作为输入），\n- $S_4$ 在时间 $2i + 5$ 发射（在其发射时间读取 $x$ 作为输入），\n- $S_5$ 在时间 $2i + 10$ 发射。\n\n这些安排与真相关和资源使用情况一致。读取操作发生在操作的发射时间，写入操作发生在操作的完成时间。模变量展开 (MVE) 的展开因子为 $K$，它为标量 $x$ 分配 $K$ 个不同的名称，并每 $K$ 次迭代以循环方式重用每个名称；设置 $K = 1$ 意味着每个迭代都重用同一个名称。\n\n仅使用数据相关、生存期和模调度时间语义 $t_{i}(O) = T(O) + i \\cdot \\mathrm{II}$（针对迭代 $i$ 中的操作 $O$）的基本定义，分析当 $K = 1$ 时出现的对 $x$ 的隐藏的写后读反相关，并确定为消除此反相关以使调度变得可行所需的最小整数展开因子 $K$。使用所述的时间模型：对同一名称的后续写入必须严格在最后一次读取完成之后发生（即，写入时间必须严格大于最后一次读取时间）。你的答案应为一个不带单位的整数。", "solution": "首先根据指定标准对问题进行验证。\n\n**步骤 1：提取已知条件**\n- **主题**：软件流水线的模调度。\n- **启动间隔**：$\\mathrm{II} = 2$ 周期。\n- **操作和延迟**：\n  - $S_1$: 生成标量 $x$，延迟 $L(S_1) = 2$ 周期。\n  - $S_2$: 使用 $x$，延迟 $L(S_2) = 1$ 周期。\n  - $S_4$: 使用 $x$，延迟 $L(S_4) = 5$ 周期。\n  - $S_5$: 使用 $\\mathrm{tmp}$，延迟 $L(S_5) = 1$ 周期。\n- **迭代 $i$ 的候选模调度时间**：\n  - $S_1$ 在时间 $t_i(S_1) = 2i + 0$ 发射。\n  - $S_2$ 在时间 $t_i(S_2) = 2i + 3$ 发射。\n  - $S_4$ 在时间 $t_i(S_4) = 2i + 5$ 发射。\n  - $S_5$ 在时间 $t_i(S_5) = 2i + 10$ 发射。\n- **时间模型**：\n  - 读取发生在操作的发射时间。\n  - 写入发生在操作的完成时间，即（发射时间 + 延迟）。\n  - 反相关约束：对一个名称的写入必须在严格晚于从该同一名称的最后一次读取的时间点发生。\n- **模变量展开 (MVE)**：\n  - 展开因子 $K$ 为一个标量提供 $K$ 个不同的名称，每 $K$ 次迭代重用一次。\n- **目标**：确定解决标量变量 $x$ 上的写后读 (WAR) 反相关所需的最小整数展开因子 $K$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在编译器设计的既定理论中有充分的依据，特别是指令调度和优化技术，如软件流水线、模调度和寄存器重命名（通过模变量展开）。\n- **适定性**：该问题提供了一套完整的定义、约束和数据，用以计算出 $K$ 的唯一整数值。\n- **客观性**：语言正式且精确，没有主观或模棱两可的陈述。\n- **缺陷检查**：该问题没有违反任何列出的无效标准。如所述，该调度满足真相关。例如，对于迭代 $i$ 中关于 $x$ 的 $S_1 \\rightarrow S_2$ 相关，来自 $S_1$ 的写入发生在时间 $t_i(S_1) + L(S_1) = (2i+0)+2 = 2i+2$，而 $S_2$ 的读取发生在时间 $t_i(S_2) = 2i+3$。由于 $2i+2 \\le 2i+3$，该相关得到满足。问题关注于跨迭代的名称重用所产生的反相关，这是该领域的标准分析。\n\n**步骤 3：结论与行动**\n问题有效。将推导解决方案。\n\n**求解推导**\n\n问题要求找到最小整数模变量展开因子 $K$，以消除对标量变量 $x$ 的写后读 (WAR) 反相关。这种反相关是由于软件流水线调度中循环迭代的重叠执行而产生的。\n\n首先，我们必须描述 $x$ 的单个值的生存期。在任何给定的迭代 $i$ 中，操作 $S_1$ 产生一个新值 $x$。我们将此值表示为 $x_i$。\n\n值 $x_i$ 在迭代 $i$ 的操作 $S_1$ 完成时被写入其存储位置（即其生命周期开始）。在迭代 $i$ 中，$S_1$ 的发射时间是 $t_i(S_1) = 2i$。延迟为 $L(S_1) = 2$ 周期，因此写入时间为：\n$$t_{write}(x_i) = t_i(S_1) + L(S_1) = 2i + 2$$\n\n这个值 $x_i$ 在同一次迭代 $i$ 中被操作 $S_2$ 和 $S_4$ 消耗（读取）。根据时间模型，读取发生在消耗操作的发射时间。$x_i$ 的读取时间是：\n- 对于 $S_2$：$t_{read,S2}(x_i) = t_i(S_2) = 2i + 3$\n- 对于 $S_4$：$t_{read,S4}(x_i) = t_i(S_4) = 2i + 5$\n\n值 $x_i$ 的生存期延续到其最后一次使用。因此，最后一次读取的时间是：\n$$t_{last\\_read}(x_i) = \\max(t_{read,S2}(x_i), t_{read,S4}(x_i)) = \\max(2i+3, 2i+5) = 2i+5$$\n\n如果 $x_i$ 的存储位置在时间 $t_{last\\_read}(x_i)$ 之前或之时被后续操作覆盖，则会发生 WAR 反相关冲突。问题规定，写入时间必须严格大于最后一次读取时间。\n\n使用因子为 $K$ 的模变量展开，我们为变量 $x$ 使用 $K$ 个不同的名称。在迭代 $i$ 中使用的名称每 $K$ 次迭代重用一次。因此，用于值 $x_i$ 的存储位置将被用于值 $x_{i+K}$，该值由迭代 $i+K$ 中的操作 $S_1$ 产生。\n\n这次后续的、可能产生冲突的写入时间是迭代 $i+K$ 中 $S_1$ 的完成时间：\n$$t_{write}(x_{i+K}) = t_{i+K}(S_1) + L(S_1) = (2(i+K)) + 2 = 2i + 2K + 2$$\n\n为确保调度可行，对重用名称的写入必须严格在从该名称的最后一次读取完成之后发生。这给了我们以下不等式：\n$$t_{write}(x_{i+K}) > t_{last\\_read}(x_i)$$\n\n代入我们推导出的表达式：\n$$2i + 2K + 2 > 2i + 5$$\n\n项 $2i$ 出现在两侧，可以消去，从而得到一个与具体迭代 $i$ 无关的不等式：\n$$2K + 2 > 5$$\n\n求解 $K$：\n$$2K > 3$$\n$$K > \\frac{3}{2}$$\n$$K > 1.5$$\n\n由于展开因子 $K$ 必须是整数，满足此条件的最小整数值 $K$ 是 $2$。\n因此，需要至少 $K=2$ 个不同的名称来为变量 $x$ 命名，才能通过消除写后读反相关使调度变得可行。", "answer": "$$\n\\boxed{2}\n$$", "id": "3658367"}]}