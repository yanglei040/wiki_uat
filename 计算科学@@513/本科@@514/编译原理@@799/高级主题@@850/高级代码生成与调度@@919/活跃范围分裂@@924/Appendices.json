{"hands_on_practices": [{"introduction": "首先，我们必须理解活跃区间分裂的基本经济学。本练习提供了一个简化的成本模型，帮助你量化溢出变量与分裂其活跃区间之间的权衡。通过推导最佳分裂次数，你将建立起对何时进行此项优化有利可图的核心直觉 [@problem_id:3651169]。", "problem": "考虑在编译器的中间表示中，为一个具有长生存区间 $I$ 的单个标量变量进行寄存器分配。生存区间是指一个值必须保持可用的所有程序点集合。当瞬时寄存器压力超过可用寄存器数量时，一个生存区间可能会从寄存器中移除（溢出），并在之后恢复。生存范围分裂通过插入定义或使用边界，将一个生存区间切分成多个子区间，从而允许更精确地将其放置在寄存器或内存中。\n\n假设在一条单一的线性化执行路径上，成本模型如下，该路径是通过对控制流进行频率加权而形成的单一序列：\n\n- 长生存区间 $I$ 与恰好 $K \\in \\mathbb{N}$ 个不相交的高压区域重叠。在每个这样的区域中，如果 $I$ 没有通过分裂在该区域内被置为无效，则分配器必须为 $I$ 插入一次溢出，其总期望动态成本为 $c_p > 0$。\n- 每次分裂操作都是一个单一的程序点，在该点上 $I$ 被切分为两个子区间，这会增加一个期望动态成本 $c_s > 0$（例如，由于额外的移动或复制、簿记或合并减少）。\n- 为了在一个高压区域中消除对 $I$ 的溢出需求，恰好需要 $2$ 次分裂：一次在区域之前，使 $I$ 在该区域内无效；另一次在区域之后，以恢复 $I$。\n- 分裂没有其他影响，也不会改变高压区域的数量或位置。高压区域互不重叠，且 $K$ 是固定的。\n- 总期望动态成本是所有使用的分裂的成本与分裂后仍然必要的所有溢出的成本之和。\n- 你可以自由选择任意非负整数数量的分裂 $S \\in \\mathbb{Z}_{\\ge 0}$，并可以相对于 $K$ 个区域对它们进行最优放置。\n- 假设 $c_s \\ll c_p$，其含义是，如果增加分裂能够以仅消耗这些分裂的成本为代价来消除一次溢出，那么这样做总是更可取的。\n\n从上述核心定义出发，并遵循寄存器分配决策旨在最小化总期望动态成本的原则，推导出一个关于 $S$ 的函数，该函数捕获此模型下的总成本，然后计算最小化此成本的最优分裂次数 $S^{\\star}$。用 $K$、$c_s$ 和 $c_p$ 以闭式解的形式表示 $S^{\\star}$。你的最终答案必须是 $S^{\\star}$ 的单个解析表达式。不需要四舍五入，也没有物理单位适用。", "solution": "问题要求解出最优的分裂次数，记为 $S^{\\star}$，它能最小化与 $K$ 个高压区域重叠的单个生存区间 $I$ 的寄存器分配总期望动态成本。\n\n首先，我们验证问题陈述。\n\n### 步骤1：提取已知条件\n- 一个单一的生存区间 $I$。\n- $K \\in \\mathbb{N}$ 个不相交的高压区域。\n- 在一个高压区域中对 $I$ 进行一次溢出的成本是 $c_p > 0$。在没有任何分裂的情况下，总溢出成本为 $K c_p$。\n- 单次分裂操作的成本是 $c_s > 0$。\n- 为了在一个高压区域中消除一次溢出的需求，恰好需要 2 次分裂。\n- 分裂的总次数是一个非负整数 $S \\in \\mathbb{Z}_{\\ge 0}$。\n- 总期望动态成本是分裂成本与剩余溢出成本之和。\n- 给定一个假设：$c_s \\ll c_p$ 被解释为“如果增加分裂能够以仅消耗这些分裂的成本为代价来消除一次溢出，那么这样做总是更可取的。”这意味着两次分裂的成本小于一次溢出的成本，即 $2c_s  c_p$。\n- 目标是推导出总成本作为 $S$ 的函数，并找到最小化此成本的最优分裂次数 $S^{\\star}$。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题是编译器设计中一个成熟的建模问题，特别是在寄存器分配和代码优化领域。它使用了一个简化但有效的成本模型。\n- **适定性**：该问题提供了一个明确的目标（最小化一个成本函数）和足够的参数来定义该函数。给定的假设 $2c_s  c_p$ 确保了唯一最小值的存在。\n- **客观性**：问题以精确的、量化的术语陈述。\n- **完整性与一致性**：所有必要信息都以符号形式提供。没有矛盾之处。\n\n### 步骤3：结论与行动\n问题是有效的。我们开始求解。\n\n总成本 $C(S)$ 是分裂次数 $S$ 的函数。它是所有分裂的成本与所有剩余溢出的成本之和。\n$$ C(S) = (\\text{Cost of splits}) + (\\text{Cost of remaining spills}) $$\n$S$ 次分裂的成本直接由下式给出：\n$$ \\text{Cost of splits} = S \\cdot c_s $$\n要确定剩余溢出的成本，我们必须首先计算出使用 $S$ 次分裂消除了多少次溢出。问题陈述说明，消除 1 次溢出需要 2 次分裂。因此，通过 $S$ 次分裂，可以潜在消除的溢出次数为 $\\lfloor S/2 \\rfloor$。\n高压区域的总数为 $K$，因此最多可以消除 $K$ 次溢出。实际消除的溢出次数 $n_{\\text{elim}}$ 是可用的能消除溢出的分裂对数量与总溢出次数之间的最小值：\n$$ n_{\\text{elim}}(S) = \\min(K, \\lfloor S/2 \\rfloor) $$\n仍然必要的溢出次数 $n_{\\text{rem}}$ 是初始溢出次数 $K$ 减去已消除的溢出次数：\n$$ n_{\\text{rem}}(S) = K - n_{\\text{elim}}(S) = K - \\min(K, \\lfloor S/2 \\rfloor) $$\n这可以使用恒等式 $\\min(a,b) = a - \\max(0, a-b)$ 重写为 $K - (K - \\max(0, K-\\lfloor S/2 \\rfloor)) = \\max(0, K - \\lfloor S/2 \\rfloor)$。\n剩余溢出的总成本是 $n_{\\text{rem}}(S)$ 乘以每次溢出的成本 $c_p$：\n$$ \\text{Cost of remaining spills} = c_p \\cdot \\max(0, K - \\lfloor S/2 \\rfloor) $$\n将这些部分结合起来，总成本函数 $C(S)$ 为：\n$$ C(S) = S \\cdot c_s + c_p \\cdot \\max(0, K - \\lfloor S/2 \\rfloor) $$\n我们的目标是找到使 $C(S)$ 最小化的整数 $S \\geq 0$。\n\n我们来分析 $C(S)$ 的行为。注意到项 $\\lfloor S/2 \\rfloor$ 对于 $S=2s$ 和 $S=2s+1$ 是相同的，其中 $s$ 是一个非负整数。让我们比较奇数次分裂（$S = 2s+1$）与偶数次分裂（$S = 2s$）的成本。\n$$ C(2s) = (2s)c_s + c_p \\cdot \\max(0, K - \\lfloor (2s)/2 \\rfloor) = 2sc_s + c_p \\cdot \\max(0, K-s) $$\n$$ C(2s+1) = (2s+1)c_s + c_p \\cdot \\max(0, K - \\lfloor (2s+1)/2 \\rfloor) = (2s+1)c_s + c_p \\cdot \\max(0, K-s) $$\n它们的差值为：\n$$ C(2s+1) - C(2s) = \\left((2s+1)c_s + c_p \\cdot \\max(0, K-s)\\right) - \\left(2sc_s + c_p \\cdot \\max(0, K-s)\\right) = c_s $$\n由于 $c_s  0$，我们有 $C(2s+1)  C(2s)$。这意味着对于任何奇数次分裂 $2s+1$，其成本都严格大于 $2s$ 次分裂的成本。一次奇数次的分裂增加了成本，但没有额外消除一次溢出。因此，最优分裂次数 $S^{\\star}$ 不可能是奇数，它必须是一个偶数。\n\n因此，我们可以将搜索范围限制在 $S$ 的偶数值上。设 $S = 2s$，其中 $s$ 是分裂对的数量。这里，$s$ 代表我们选择消除其溢出的高压区域的数量。$s$ 的可能取值为非负整数。\n成本函数变为 $s$ 的函数：\n$$ C(2s) = 2s \\cdot c_s + c_p \\cdot \\max(0, K - s) $$\n我们来分析这个函数在 $s$ 的两种情况下的行为。\n\n情况1：$0 \\le s \\le K$。\n在此范围内，$K-s \\ge 0$，因此 $\\max(0, K-s) = K-s$。成本函数为：\n$$ C(2s) = 2sc_s + c_p(K-s) \\quad \\text{for } 0 \\le s \\le K $$\n我们可以重新整理此式，以观察其对 $s$ 的依赖关系：\n$$ C(2s) = (2c_s - c_p)s + K c_p $$\n这是一个关于 $s$ 的线性函数。其行为取决于斜率 $m = 2c_s - c_p$。问题陈述中提到“如果增加分裂能够以仅消耗这些分裂的成本为代价来消除一次溢出，那么这样做总是更可取的”。这意味着增加两次分裂的成本（$2c_s$）小于节省一次溢出的收益（$c_p$）。在数学上，这表示为不等式 $2c_s  c_p$。\n在此条件下，斜率 $m = 2c_s - c_p$ 是严格为负的。\n一个负斜率的线性函数是严格递减的函数。为了在整数区间 $s \\in [0, K]$ 上最小化此函数，我们必须选择 $s$ 的最大可能值。在此定义域中，最大值为 $s=K$。\n这表明在此范围内的最小成本在 $s=K$ 时取得，对应于 $S=2K$。\n\n情况2：$s  K$。\n在此范围内，$K-s  0$，因此 $\\max(0, K-s) = 0$。成本函数为：\n$$ C(2s) = 2sc_s \\quad \\text{for } s  K $$\n由于 $c_s  0$，这是一个关于 $s$ 的严格递增函数。因此，任何 $s  K$ 的值都会产生比 $s=K$ 时更高的成本。例如，当 $s=K+1$ 时，成本为 $C(2(K+1)) = 2(K+1)c_s = 2Kc_s + 2c_s$。\n在边界点 $s=K$ 处的成本为 $C(2K) = (2c_s - c_p)K + K c_p = 2Kc_s$。\n由于 $C(2(K+1))  C(2K)$，并且当 $s  K$ 时成本持续增加，因此最小值不可能出现在这个区域。\n\n综合两种情况，成本函数 $C(2s)$ 在 $s \\in [0, K]$ 上是严格递减的，在 $s \\in [K, \\infty)$ 上是严格递增的。因此，全局最小值必然出现在点 $s=K$ 处。\n最优分裂对的数量是 $s^{\\star} = K$。\n这对应于最优的总分裂次数 $S^{\\star} = 2s^{\\star} = 2K$。此时，所有 $K$ 个高压区域都通过分裂来处理，生存区间 $I$ 不需要任何溢出。总成本是这 $2K$ 次分裂的成本，即 $2Kc_s$。", "answer": "$$\n\\boxed{2K}\n$$", "id": "3651169"}, {"introduction": "活跃区间分裂在循环中尤其强大，因为微小的低效会被放大。本练习探讨了一个常见场景：一个增加了寄存器压力的循环不变量。你将比较保持该值活跃与分裂其区间并重新物质化它的成本，从而展示分裂如何能够启用其他优化，并显著提升热点代码的性能 [@problem_id:3651136]。", "problem": "考虑以下三地址风格的中间表示（Intermediate Representation (IR)），它用于一个简单的循环，并结合一个具体的机器模型和一个玩具寄存器分配场景，旨在研究生存期分裂和重物质化一个循环不变量值的效果：\n- 代码\n  - 前置头部：计算一个循环不变的类地址常量\n    - $c := \\text{base} + 4096$\n    - $i := 0$\n    - $acc := 0$\n  - 循环体（重复 $T$ 次迭代）：\n    - $t := \\mathrm{load}[p + i]$\n    - $acc := acc + t \\times c$\n    - $i := i + 4$\n    - if $(i  M)$ goto loop head\n- 活跃集假设\n  - 在乘法 $t \\times c$ 之前的程序点，排除 $c$ 后，同时活跃值的集合的势为 $3$：具体为 $\\{acc, i, t\\}$。\n  - 如果 $c$ 在整个循环体中保持活跃，那么在该点的峰值同时活跃集的势为 $4$（上述三个值加上 $c$）。\n  - 假设编译器无法进一步重调度或更改使用来降低该程序点的峰值活跃数。\n- 寄存器和成本模型\n  - 目标机器为此循环提供了 $R = 3$ 个通用寄存器。\n  - 用于溢出的内存操作具有加性成本：每次用于溢出的 $\\mathrm{store}$ 或 $\\mathrm{load}$ 操作成本为 $C_{\\mathrm{mem}} = 6$ 个周期，且是独立且不重叠的。\n  - 单条立即数加法指令（例如，地址计算 $\\mathrm{lea}$）从 $\\text{base}$ 和立即数 $4096$ 重物质化 $c$ 的成本为 $C_{\\mathrm{remat}} = 1$ 个周期。\n  - 循环运行 $T = 100$ 次迭代。\n  - 忽略缓存未命中，并假设所有其他循环指令在所比较的策略中是相同的；只计算下述策略之间有差异的成本。\n- 两种待比较的分配策略\n  - 策略 K (保持)：在前置头部计算一次 $c$，并使 $c$ 在整个循环中保持活跃。因为循环内的峰值活跃数为 $4$ 而 $R = 3$，假设分配器在关键点恰好溢出另一个值，导致每次迭代产生一次 $\\mathrm{store}$ 和一次 $\\mathrm{load}$。\n  - 策略 S (分裂 + 重物质化)：在循环入口处分裂 $c$ 的生存期，使 $c$ 不在循环中保持活跃。而是在每次迭代中，在 $c$ 被使用前通过单条立即数加法指令立即重物质化它。这会将关键点的峰值活跃数降至 $3$，从而消除溢出。\n\n回顾支配活跃性和寄存器分配的基本定义：\n- 如果一个值的当前内容可能在被重新定义之前的某条路径上被使用，则该值在该程序点是活跃的。\n- 一个程序点的同时活跃值的峰值数量，是避免在该点发生溢出所需寄存器数量的下界。\n- 如果同时活跃值的数量超过可用寄存器数量 $k$ 个，那么至少有 $k$ 个值必须被溢出，在这个玩具模型中，当超出量为 $1$ 时，通常每次迭代会引发至少一次 $\\mathrm{store}$ 和一次 $\\mathrm{load}$。\n- 重物质化是重新计算一个廉价的表达式（例如基于不变量的立即数加法），而不是从内存中加载它或使其在寄存器压力高的区域保持活跃。\n\n问题：在上述假设和此成本模型下，关于哪种策略能最小化由寄存器压力引起的动态成本，以及相对于另一种策略的优势有多大，以下哪个陈述是正确的？\n\nA. 在循环入口处分裂 c 的生存期并在每次迭代中使用前立即重物质化它，与保持 c 活跃相比，严格降低了动态成本，对于 T=100 的情况节省了 1101 个周期；在此模型下，它是两种策略中的最优选择。\n\nB. 保持 c 活跃的成本更低，因为在前置头部计算一次 c 节省了 $T \\cdot C_{\\mathrm{remat}} = 100$ 个周期，这超过了溢出流量的 $2T \\cdot C_{\\mathrm{mem}} = 1200$ 个周期；因此它以 1100 个周期的优势胜出。\n\nC. 在假设下，两种策略的成本相等，因为策略 K 中的溢出 $\\mathrm{store}$ 和 $\\mathrm{load}$ 可以被其他指令重叠和隐藏，使其加性成本实际上为 $0$。\n\nD. 分裂 c 的生存期会增加循环回边处的干扰，并强制每次迭代产生两次溢出，成本为 2400 个周期，所以策略 K 严格更优。", "solution": "### 问题验证\n\n#### 步骤 1：提取已知信息\n\n问题提供了以下信息：\n\n*   **代码结构：**\n    *   前置头部：$c := \\text{base} + 4096$; $i := 0$; $acc := 0$\n    *   循环体：$t := \\mathrm{load}[p + i]$; $acc := acc + t \\times c$; $i := i + 4$; if $(i  M)$ goto loop head\n*   **活跃集假设：**\n    *   在乘法 $t \\times c$ 之前的程序点，排除 $c$ 的活跃值集合为 $\\{acc, i, t\\}$，其势为 $3$。\n    *   如果保持 $c$ 活跃，该点的峰值同时活跃集势为 $4$。\n    *   编译器无法通过重调度来降低此峰值活跃数。\n*   **寄存器和成本模型：**\n    *   可用通用寄存器数量：$R = 3$。\n    *   用于溢出的内存操作（store 或 load）成本：$C_{\\mathrm{mem}} = 6$ 个周期。这些成本是加性的且不重叠。\n    *   重物质化 $c$ 的成本：每次实例 $C_{\\mathrm{remat}} = 1$ 个周期。\n    *   循环迭代次数：$T = 100$。\n    *   分析应仅计算两种策略之间有差异的成本。\n*   **分配策略：**\n    *   **策略 K (保持)：** $c$ 在前置头部计算一次。循环内的峰值活跃数为 $4$。由于 $R=3$，这迫使一个值被溢出，每次迭代产生一次 $\\mathrm{store}$ 和一次 $\\mathrm{load}$。\n    *   **策略 S (分裂 + 重物质化)：** $c$ 的生存期被分裂。$c$ 在每次循环迭代中使用前被重物质化。峰值活跃数降至 $3$，从而消除了溢出。\n\n#### 步骤 2：使用提取的已知信息进行验证\n\n*   **科学基础：** 该问题牢固地植根于编译器设计的原理，特别是寄存器分配。生存期、寄存器压力、溢出、生存期分裂和重物质化等概念是该领域的标准主题。成本模型虽然经过简化，但反映了现实中的权衡，即内存访问（$C_{\\mathrm{mem}}=6$）比简单的算术指令（$C_{\\mathrm{remat}}=1$）昂贵得多。该问题在科学上是合理的。\n*   **适定性：** 该问题是适定的。它提供了一个清晰、量化的场景，包含所有必要的参数（$R$, $T$, $C_{\\mathrm{mem}}$, $C_{\\mathrm{remat}}$）和关于每种策略后果的明确假设（溢出次数等）。问题要求对成本进行具体比较，这可以从给定的信息中唯一确定。\n*   **客观性：** 问题陈述是客观的，并使用了编译器理论中的精确术语。它建立了一个“玩具模型”来预先固定复杂编译器启发式（如哪个变量被溢出）的结果，这是创建可解的分析性问题的有效方法。\n\n该问题没有任何无效性缺陷。它是自洽的、一致的、有科学依据且适定的。\n\n#### 步骤 3：结论和行动\n\n问题陈述是**有效的**。现在将进行求解过程。\n\n### 解题推导\n\n任务是比较在 $T=100$ 次迭代中，两种不同寄存器分配策略因寄存器压力产生的总动态成本。我们必须计算两种策略之间所有不同的成本。\n\n**策略 K (保持)：**\n在此策略中，值 $c$ 在前置头部计算一次，并在整个循环执行期间保持在寄存器中。\n1.  **前置头部成本：** 计算 $c := \\text{base} + 4096$ 在循环开始前执行一次。这是一个立即数加法指令，其成本等同于重物质化成本，即 $C_{\\mathrm{remat}} = 1$ 个周期。这是此策略产生的一项成本，在策略 S 中不存在（策略 S 的前置头部没有计算 `c`）。\n2.  **循环体成本：** 问题指出，保持 $c$ 活跃会将同时活跃变量的峰值数量提高到 $4$。由于只有 $R=3$ 个寄存器，必须将一个值溢出到内存。问题明确指出，此溢出在每次迭代中引发一次 $\\mathrm{store}$ 操作和一次 $\\mathrm{load}$ 操作。\n    *   一次 store 的成本：$C_{\\mathrm{mem}} = 6$ 个周期。\n    *   一次 load 的成本：$C_{\\mathrm{mem}} = 6$ 个周期。\n    *   每次迭代的总溢出成本：$C_{\\mathrm{spill\\_iter}} = C_{\\mathrm{mem}} + C_{\\mathrm{mem}} = 6 + 6 = 12$ 个周期。\n3.  **策略 K 的总成本：** 总成本是一次性的前置头部计算成本与所有迭代中累积的溢出成本之和。\n    $$ \\text{Cost}_K = C_{\\mathrm{remat}} + T \\times C_{\\mathrm{spill\\_iter}} $$\n    $$ \\text{Cost}_K = 1 + 100 \\times 12 = 1 + 1200 = 1201 \\text{ 个周期} $$\n\n**策略 S (分裂 + 重物质化)：**\n在此策略中，$c$ 的生存期被分裂，因此它在循环迭代之间不是活跃的。而是在循环内部需要它之前重新计算。\n1.  **前置头部成本：** 前置头部没有计算 $c$。\n2.  **循环体成本：** 问题指出此策略将峰值活跃数降至 $3$。由于有 $R=3$ 个寄存器，避免了溢出。但是，值 $c$ 必须在每次迭代中重新计算。\n    *   每次迭代的重物质化成本：$C_{\\mathrm{remat}} = 1$ 个周期。\n3.  **策略 S 的总成本：** 总成本是在 $T$ 次迭代中每次重物质化 $c$ 的累积成本。\n    $$ \\text{Cost}_S = T \\times C_{\\mathrm{remat}} $$\n    $$ \\text{Cost}_S = 100 \\times 1 = 100 \\text{ 个周期} $$\n\n**比较：**\n我们比较两种策略的总成本：\n*   $\\text{Cost}_K = 1201$ 个周期。\n*   $\\text{Cost}_S = 100$ 个周期。\n\n策略 S 明显比策略 K 的成本更低。使用策略 S 而非策略 K 所实现的总节省为：\n$$ \\text{节省} = \\text{Cost}_K - \\text{Cost}_S = 1201 - 100 = 1101 \\text{ 个周期} $$\n因此，策略 S（分裂 + 重物质化）是两者中的最优选择，它减少了 1101 个周期的动态成本。\n\n### 逐项分析\n\n**A. 在循环入口处分裂 c 的生存期并在每次迭代中使用前立即重物质化它，与保持 c 活跃相比，严格降低了动态成本，对于 T=100 的情况节省了 1101 个周期；在此模型下，它是两种策略中的最优选择。**\n该陈述与我们的推导完全一致。\n*   策略 S 降低了动态成本：$\\text{Cost}_S = 100$ 小于 $\\text{Cost}_K = 1201$。\n*   节省的成本是 $1101$ 个周期。\n*   它是所提出的两种策略中的最优策略。\n该陈述是**正确的**。\n\n**B. 保持 c 活跃的成本更低，因为在前置头部计算一次 c 节省了 $T \\cdot C_{\\mathrm{remat}} = 100$ 个周期，这超过了溢出流量的 $2T \\cdot C_{\\mathrm{mem}} = 1200$ 个周期；因此它以 1100 个周期的优势胜出。**\n该陈述包含多个错误。\n*   “保持 c 活跃...成本更低”：这是错误的。我们的分析表明它更昂贵了 $1101$ 个周期。\n*   “...节省了 $T \\cdot C_{\\mathrm{remat}} = 100$ 个周期...”：这个前提有缺陷。计算一次 $c$ 避免了 $T-1=99$ 次重物质化，在该特定操作上节省了 $99$ 个周期，但它强制产生了 $1200$ 个周期的溢出成本。数字 $100$ 代表策略 S 中重物质化的总成本，而不是策略 K 的节省。\n*   “...这超过了...$1200$ 个周期...”：约 $100$ 个周期的节省不可能超过 $1200$ 个周期的成本。逻辑推理是颠倒的。\n*   “...它以 $1100$ 个周期的优势胜出”：该策略失败了，我们计算出的差额是 $1101$，而不是 $1100$。\n该陈述是**不正确的**。\n\n**C. 在假设下，两种策略的成本相等，因为策略 K 中的溢出 $\\mathrm{store}$ 和 $\\mathrm{load}$ 可以被其他指令重叠和隐藏，使其加性成本实际上为 $0$。**\n该陈述直接与问题的一个前提相矛盾。问题指出，溢出成本是“$C_{\\mathrm{mem}} = 6$ 个周期，独立且不重叠的”。因此，它们的成本不能被视为 $0$。\n该陈述是**不正确的**。\n\n**D. 分裂 c 的生存期会增加循环回边处的干扰，并强制每次迭代产生两次溢出，成本为 2400 个周期，所以策略 K 严格更优。**\n该陈述曲解了生存期分裂的效果。\n*   “分裂 c 的生存期会增加干扰...”：生存期分裂的根本目的和声明的效果是*减少*干扰和寄存器压力。问题明确证实了这一点：“这会将峰值活跃数...降至 $3$”。\n*   “...并强制每次迭代产生两次溢出...”：这是错误的。通过将峰值活跃数降低到与寄存器数量相匹配（$3$），策略 S *消除了*溢出，如问题所述。因此，$2400$ 个周期（$2 \\times (100 \\times 12)$）的成本是毫无根据的。\n*   “...所以策略 K 严格更优”：这个结论是基于错误的前提得出的，与正确结果相反。\n该陈述是**不正确的**。", "answer": "$$\\boxed{A}$$", "id": "3651136"}, {"introduction": "现实世界的程序具有复杂的控制流，包含热路径和冷路径。这个高级练习挑战你在一个基于性能剖析的场景中应用活跃区间分裂，以最小化期望执行成本。你将学习如何策略性地仅在必要时放置重载和存储指令，避免在频繁执行的路径上产生开销，这展示了该技术更为精妙和强大的应用 [@problem_id:3651198]。", "problem": "考虑一个编译器后端，在寄存器分配之后，单个变量 $v$ 已被全局溢出到一个栈槽中。给定一个控制流图（CFG），包含一个入口块、一个热循环和一个带有冷错误路径的循环后分支：\n- 块 $B_0$（入口）：对 $v$ 定义一次，然后跳转到循环前置节点。\n- 循环前置节点 $H$：顺序执行到循环头 $L$。\n- 循环体 $B$：在循环内执行。每次循环迭代恰好包含两次对 $v$ 的使用和一次对 $v$ 的定义，该定义为其下一次迭代更新其值。\n- 循环出口 $X$：从 $X$ 开始，控制流以 $0.99$ 的概率分支到正常路径 $N$（没有对 $v$ 的进一步使用），或以 $0.01$ 的概率分支到冷错误路径 $C$，在路径 $C$ 上恰好有一次对 $v$ 的使用。\n\n假设每次函数调用中，循环恰好迭代 $N = 1000$ 次。假设以下由于溢出和重载引起的动态内存流量的代价模型：\n- 每次从溢出槽加载的代价为 $c_L = 4$ 个周期。\n- 每次存储到溢出槽的代价为 $c_S = 4$ 个周期。\n- 寄存器到寄存器的移动代价为 $c_M = 1$ 个周期，但除非某个选项明确使用它们，否则可以忽略此类移动。\n- 每次函数调用的期望动态代价是所有动态执行的加载和存储的总和，每个都乘以其代价；当分支是概率性的时候，使用其概率。\n\n定义和约束：\n- 生存期分裂创建一个子范围，其中 $v$ 被保存在一个专用寄存器 $t$ 中，并且其使用/定义都引用 $t$；在溢出区域和寄存器内区域的边界处，进入时需要在入口处进行重载（从溢出槽加载到 $t$），如果值对可能随后使用 $v$ 的溢出区域是活跃出口，则在出口处需要写回到溢出槽。\n- 正确性要求任何对 $v$ 的使用都必须观察到该路径上最新的定义。当 $v$ 处于一个纯寄存器子范围时，任何离开该子范围进入溢出区域的路径都必须在溢出区域的使用发生之前，将当前值物化到内存中。\n- 您可以根据需要分裂关键边，以便仅沿着其中一个出向分支放置存储或加载。\n\n目标：提出一种重新分裂和部分重载方案，使得只有 $v$ 的热子范围被保存在寄存器中并重载，而其他区域保持溢出状态，并且在满足正确性的前提下，每次调用的期望动态溢出代价最小化。\n\n哪个选项最能满足目标？\n\nA. 为 $v$ 创建一个覆盖整个循环的纯寄存器子范围。在进入循环之前，在循环前置节点 $H$ 中插入一次重载，将 $v$ 加载到寄存器 $t$ 中。在整个循环中将 $v$ 保存在 $t$ 中，并在 $X$ 中插入一次无条件存储，在分支到 $N$ 或 $C$ 之前将 $t$ 写回到溢出槽。在循环之外（包括在 $C$ 中），保持 $v$ 溢出，并在 $C$ 中的使用前插入一次加载。\n\nB. 为 $v$ 创建一个覆盖整个循环的纯寄存器子范围。在进入循环之前，在循环前置节点 $H$ 中插入一次重载，将 $v$ 加载到 $t$ 中。在整个循环中将 $v$ 保存在 $t$ 中。不要在 $X$ 中进行存储。而是分裂关键边 $X \\rightarrow C$（如果需要），并且只在通往 $C$ 的冷路径上放置一个存储，以将 $v$ 的当前值物化到内存中；然后在 $C$ 中，在其单次使用前执行加载。在循环外的所有地方，包括 $N$ 和 $C$，都保持 $v$ 溢出。\n\nC. 在所有地方都保持 $v$ 溢出。在所有块中，包括循环和冷路径 $C$，在每次使用前立即插入一次重载，在每次定义后立即插入一次存储。\n\nD. 为 $v$ 创建一个每次只跨越单次迭代的纯寄存器子范围：在每次迭代中，在循环头 $L$ 的顶部将 $v$ 重载到 $t$ 中；在迭代内使用和定义 $t$；然后在每次迭代的循环末尾将 $t$ 写回到内存。在循环之外，保持 $v$ 溢出，并在 $C$ 中的使用前插入一次加载。\n\nE. 为 $v$ 创建一个覆盖循环的纯寄存器子范围，在 $H$ 中进行一次重载，在 $X$ 处或之后的所有路径上都没有存储。在其他所有地方保持 $v$ 溢出，并且在 $C$ 中直接使用溢出的值，而不在循环后插入任何额外的存储。\n\n选择既能保持正确性又能根据所述模型和约束最小化每次函数调用的期望动态溢出代价的选项。不给部分分；选择唯一的最佳选项。", "solution": "用户提供了一个关于编译器优化的问题陈述，特别是针对溢出变量的生存期分裂。我将首先验证问题陈述，然后进行严谨的求解。\n\n### 步骤 1：提取给定信息\n\n-   **变量和状态**：单个变量 $v$，全局溢出到一个栈槽中。\n-   **控制流图（CFG）**：\n    -   入口块 $B_0$ 对 $v$ 定义一次。\n    -   一个由前置节点 $H$、循环头 $L$ 和循环体 $B$ 组成的循环。\n    -   循环迭代 $N = 1000$ 次。\n    -   循环体 $B$ 每次迭代包含两次对 $v$ 的使用和一次对 $v$ 的定义。\n    -   循环出口块是 $X$。\n    -   从 $X$ 出发，控制流以 $P(N) = 0.99$ 的概率流向正常路径 $N$。在路径 $N$ 上没有对 $v$ 的进一步使用。\n    -   从 $X$ 出发，控制流以 $P(C) = 0.01$ 的概率流向冷错误路径 $C$。在路径 $C$ 上有一次对 $v$ 的使用。\n-   **代价模型**：\n    -   加载代价：$c_L = 4$ 个周期。\n    -   存储代价：$c_S = 4$ 个周期。\n-   **定义**：\n    -   生存期分裂涉及创建一个子范围，其中 $v$ 被保存在寄存器 $t$ 中。\n    -   进入纯寄存器子范围需要一次重载（从溢出槽加载）。\n    -   如果值对溢出区域是活跃出口，则退出时需要一次存储到溢出槽。\n-   **正确性约束**：任何对 $v$ 的使用都必须观察到其执行路径上最新的定义所产生的值。\n-   **目标**：在保持正确性的前提下，最小化每次函数调用的期望动态溢出代价。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n该问题陈述在编译器构建和优化领域具有科学依据。控制流图、全局溢出、生存期、活跃性分析和生存期分裂等概念都是标准且明确定义的。该问题是适定的：它提供了所有必要的数据（CFG 结构、迭代次数、概率、指令计数和代价），以构建一个可在明确的正确性约束下最小化的目标函数（期望动态代价）。问题以客观、技术性的语言表述。没有矛盾、歧义或缺失信息会妨碍形式化分析。\n\n### 步骤 3：结论和行动\n\n问题是有效的。我现在将通过分析每个提议方案的期望代价来推导解决方案。\n\n### 解决方案推导\n\n目标是最小化期望动态代价，即与溢出变量 $v$ 相关的所有动态执行的加载和存储指令的代价总和。在概率路径上执行的指令的代价由该路径的概率加权。\n\n#### 基准代价（全局溢出）\n\n首先，让我们分析 $v$ 全局溢出时的初始状态代价，这对应于选项 C 中描述的策略。\n1.  **块 $B_0$**：发生一次对 $v$ 的定义。由于 $v$ 的值在第一次循环迭代中被使用，它在 $B_0$ 之后是活跃出口。因此，在 $B_0$ 的定义之后必须跟一个存储指令。\n    -   $B_0$ 中的代价：$1 \\times c_S = 4$ 个周期。每次调用执行一次。\n2.  **循环体 $B$**：有两次使用和一次对 $v$ 的定义。对于全局溢出的变量，每次使用前都有一次加载，每次定义后都有一次存储。\n    -   每次迭代的代价：$2 \\times c_L + 1 \\times c_S = 2 \\times 4 + 1 \\times 4 = 12$ 个周期。\n    -   总循环代价：$N \\times 12 = 1000 \\times 12 = 12000$ 个周期。\n3.  **冷路径 $C$**：有一次对 $v$ 的使用，需要一次前置的加载。此路径以 $0.01$ 的概率被采用。\n    -   路径 $C$ 的期望代价：$P(C) \\times (1 \\times c_L) = 0.01 \\times 4 = 0.04$ 个周期。\n\n完全溢出方案（选项 C）的总期望代价是：\n$C_{total} = C_{B_0} + C_{loop} + E[C_C] = 4 + 12000 + 0.04 = 12004.04$ 个周期。\n\n现在，我们评估每个选项。\n\n#### 逐项分析\n\n**A. 为 $v$ 创建一个覆盖整个循环的纯寄存器子范围。在进入循环之前，在循环前置节点 $H$ 中插入一次重载，将 $v$ 加载到寄存器 $t$ 中。在整个循环中将 $v$ 保存在 $t$ 中，并在 $X$ 中插入一次无条件存储，在分支到 $N$ 或 $C$ 之前将 $t$ 写回到溢出槽。在循环之外（包括在 $C$ 中），保持 $v$ 溢出，并在 $C$ 中的使用前插入一次加载。**\n\n-   **正确性**：\n    -   $B_0$ 中的定义后跟一个存储（代价未包含在此选项中，但对重载是必需的）。$H$ 中的重载正确地将此值加载到寄存器 $t$ 中。\n    -   循环内的所有操作都在 $t$ 上进行，这是正确的。\n    -   $X$ 中的无条件存储将 $t$ 的最终值物化回 $v$ 的溢出槽。\n    -   $C$ 中随后的加载将正确读取此物化值。\n    -   该方案是**正确的**。\n\n-   **代价分析**：\n    1.  $B_0$ 中定义后的存储：执行一次。代价 = $c_S = 4$。（这是一个必要的前提条件）。\n    2.  $H$ 中的重载：执行一次。代价 = $c_L = 4$。\n    3.  循环：所有操作都在寄存器 $t$ 上。代价 = $0$。\n    4.  $X$ 中的无条件存储：执行一次。代价 = $c_S = 4$。\n    5.  $C$ 中的加载：以 $0.01$ 的概率执行。期望代价 = $0.01 \\times c_L = 0.04$。\n    -   总期望代价 (A)：$4 + 4 + 4 + 0.04 = 12.04$ 个周期。\n\n**B. 为 $v$ 创建一个覆盖整个循环的纯寄存器子范围。在进入循环之前，在循环前置节点 $H$ 中插入一次重载，将 $v$ 加载到 $t$ 中。在整个循环中将 $v$ 保存在 $t$ 中。不要在 $X$ 中进行存储。而是分裂关键边 $X \\rightarrow C$（如果需要），并且只在通往 $C$ 的冷路径上放置一个存储，以将 $v$ 的当前值物化到内存中；然后在 $C$ 中，在其单次使用前执行加载。在循环外的所有地方，包括 $N$ 和 $C$，都保持 $v$ 溢出。**\n\n-   **正确性**：\n    -   $H$ 中的重载是正确的。循环中对 $t$ 的操作是正确的。\n    -   从循环退出时，$v$ 的值仅在通往 $C$ 的路径上是活跃的。它在通往 $N$ 的路径上不是活跃的。\n    -   仅在边 $X \\rightarrow C$ 上放置存储，正确地仅在需要时物化值。$C$ 中随后的加载读取正确的值。\n    -   该方案是**正确的**。\n\n-   **代价分析**：\n    1.  $B_0$ 中定义后的存储：执行一次。代价 = $c_S = 4$。\n    2.  $H$ 中的重载：执行一次。代价 = $c_L = 4$。\n    3.  循环：代价 = $0$。\n    4.  边 $X \\rightarrow C$ 上的存储：以 $0.01$ 的概率执行。期望代价 = $0.01 \\times c_S = 0.04$。\n    5.  $C$ 中的加载：以 $0.01$ 的概率执行。期望代价 = $0.01 \\times c_L = 0.04$。\n    -   总期望代价 (B)：$4 + 4 + 0.04 + 0.04 = 8.08$ 个周期。\n\n**C. 在所有地方都保持 $v$ 溢出。在所有块中，包括循环和冷路径 $C$，在每次使用前立即插入一次重载，在每次定义后立即插入一次存储。**\n\n-   **正确性**：这是朴素的、未优化的全局溢出策略。它本质上是正确的，因为每次使用前都有加载，每次定义后都有存储，确保了数据流的一致性。\n    -   该方案是**正确的**。\n\n-   **代价分析**：如上述基准分析中所计算。\n    -   总期望代价 (C)：$12004.04$ 个周期。\n\n**D. 为 $v$ 创建一个每次只跨越单次迭代的纯寄存器子范围：在每次迭代中，在循环头 $L$ 的顶部将 $v$ 重载到 $t$ 中；在迭代内使用和定义 $t$；然后在每次迭代的循环末尾将 $t$ 写回到内存。在循环之外，保持 $v$ 溢出，并在 $C$ 中的使用前插入一次加载。**\n\n-   **正确性**：在每次迭代中，都会重载前一次迭代的值。在迭代内部，对 $t$ 的操作是一致的。该值被写回以供下一次迭代使用。在最后一次迭代之后，正确的值在内存中，可供 $C$ 中的使用。\n    -   该方案是**正确的**。\n\n-   **代价分析**：\n    1.  $B_0$ 中定义后的存储：执行一次。代价 = $c_S = 4$。\n    2.  循环（$1000$ 次迭代）：在每次迭代中，有一次重载和一次存储。\n        -   每次迭代的代价：$c_L + c_S = 4 + 4 = 8$。\n        -   总循环代价：$1000 \\times 8 = 8000$。\n    3.  $C$ 中的加载：以 $0.01$ 的概率执行。期望代价 = $0.01 \\times c_L = 0.04$。\n    -   总期望代价 (D)：$4 + 8000 + 0.04 = 8004.04$ 个周期。\n\n**E. 为 $v$ 创建一个覆盖循环的纯寄存器子范围，在 $H$ 中进行一次重载，在 $X$ 处或之后的所有路径上都没有存储。在其他所有地方保持 $v$ 溢出，并且在 $C$ 中直接使用溢出的值，而不在循环后插入任何额外的存储。**\n\n-   **正确性**：$v$ 的值在循环内被修改了 $1000$ 次，最终值驻留在寄存器 $t$ 中。该选项提议*不进行存储*以将此最终值写回到溢出槽。$v$ 的原始值（循环前的值）仍保留在溢出槽中。$C$ 中的使用将加载这个过时的、不正确的值。这违反了“任何对 v 的使用都必须观察到最新的定义”的正确性约束。\n    -   该方案是**不正确的**。\n\n### 比较与结论\n\n让我们比较正确选项的总期望代价：\n-   代价(A) = $12.04$ 个周期\n-   代价(B) = $8.08$ 个周期\n-   代价(C) = $12004.04$ 个周期\n-   代价(D) = $8004.04$ 个周期\n\n在所有正确选项中，最低的期望代价是 $8.08$ 个周期，由选项 B 实现。该策略之所以优越，是因为它将变量在整个热循环期间都限制在寄存器中，消除了其中的全部 $3000$ 次内存操作，并且它智能地将所需的回写存储操作仅放置在值实际需要的低概率冷路径上，从而避免了在高概率正常路径上的开销。选项 A 不是最优的，因为它的无条件存储是浪费的。选项 C 和 D 由于在循环内部产生内存操作而代价高昂得多。\n\n因此，在这些选项中，选项 B 代表了最优策略。", "answer": "$$\\boxed{B}$$", "id": "3651198"}]}