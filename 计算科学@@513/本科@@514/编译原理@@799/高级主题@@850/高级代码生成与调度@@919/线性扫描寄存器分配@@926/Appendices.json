{"hands_on_practices": [{"introduction": "掌握任何算法的第一步都是通过具体实例来手动模拟其执行过程。本练习将引导你完成线性扫描寄存器分配的核心流程：你将首先从代码中推导出每个临时变量的“生命周期”（即活跃区间），然后逐步模拟线性扫描算法，观察活跃变量集合的变化，并最终确定避免“溢出”（spill）所需的最小寄存器数量。通过这个实践，你将对线性扫描算法如何管理寄存器资源建立起扎实且直观的理解 [@problem_id:3650259]。", "problem": "考虑一个线性中间表示（IR）块，其中临时变量 $t_{1}, t_{2}, \\dots, t_{11}$ 在由整数 $1, 2, \\dots, 12$ 标记的程序点被定义和使用。该IR如下：\n\n在程序点 $1$：$t_{1} \\leftarrow a + b$。\n在程序点 $2$：$t_{2} \\leftarrow t_{1} + c$。\n在程序点 $3$：$t_{3} \\leftarrow t_{1} \\times t_{2}$。\n在程序点 $4$：$t_{4} \\leftarrow t_{3} + d$。\n在程序点 $5$：$t_{5} \\leftarrow t_{2} + t_{4}$。\n在程序点 $6$：$t_{6} \\leftarrow t_{5} + e$。\n在程序点 $7$：$t_{7} \\leftarrow t_{6} + t_{3}$。\n在程序点 $8$：$t_{8} \\leftarrow t_{7} + t_{4}$。\n在程序点 $9$：$t_{9} \\leftarrow t_{8} + t_{2}$。\n在程序点 $10$：$t_{10} \\leftarrow t_{9} + t_{1}$。\n在程序点 $11$：$t_{11} \\leftarrow t_{10} + t_{5}$。\n在程序点 $12$：$\\text{out} \\leftarrow t_{11} + t_{6}$。\n\n假设在一个线性块中，活性和活跃区间的标准定义如下：一个临时变量 $t_{i}$ 的活跃区间是半开区间 $[s_{i}, e_{i})$，其中 $s_{i}$ 是定义 $t_{i}$ 的索引，$e_{i}$ 是 $t_{i}$ 最后一次使用的最大索引加一。\n\n应用线性扫描寄存器分配 (LSRA)。线性扫描寄存器分配 (LSRA) 按 $s_{i}$ 的递增顺序处理区间，维护一个按结束索引排序的活跃区间集合，当处理 $t_i$ 时，使任何满足 $e_{j} \\le s_{i}$ 的活跃区间 $j$ 过期，并且如果在 $t_i$ 开始时（过期处理后）活跃集合的大小为 $k$，则执行溢出决策以在寄存器中最多保留 $k$ 个区间。假设每个临时变量在其区间的整个生命周期内都需要一个寄存器，并忽略任何合并操作。\n\n你的任务：\n- 根据活性的基本原理，从IR中推导出活跃区间 $[s_{i}, e_{i})$。\n- 概念性地跟踪 LSRA 遍历起始点 $s_i$ 的过程，并确定溢出决策何时会作为 $k$ 的函数发生。\n- 最后，计算最小整数 $k^{\\star}$，使得在线性扫描寄存器分配下，该块中任何地方都不会发生溢出决策。\n\n将你的最终答案表示为单个整数 $k^{\\star}$。无需四舍五入，也无单位。你展示的解题过程可以包括指明对于特定的 $k$ 值在何处会发生溢出，但最终答案必须仅为 $k^{\\star}$ 的值。", "solution": "目标是确定使用线性扫描寄存器分配（LSRA）算法，在不发生任何溢出的情况下，为给定的中间表示（IR）块中的所有临时变量分配寄存器所需的最小整数寄存器数量，记为 $k^{\\star}$。\n\n首先，我们必须推导出每个临时变量 $t_i$ 的活跃区间。根据问题定义，活跃区间是一个半开区间 $[s_i, e_i)$，其中 $s_i$ 是 $t_i$ 被定义的程序点，$e_i$ 是 $t_i$ 最后一次使用的最大程序点加一。\n\n我们分析IR，为每个临时变量 $t_i$ 找到其定义点（$s_i$）和所有使用点。最后一个使用点决定了 $e_i$。\n\n- 对于 $t_1$：在 $s_1=1$ 定义。在程序点 $2$、$3$ 和 $10$ 使用。最后一次使用在程序点 $10$，因此 $e_1 = 10+1=11$。区间为 $[1, 11)$。\n- 对于 $t_2$：在 $s_2=2$ 定义。在程序点 $3$、$5$ 和 $9$ 使用。最后一次使用在程序点 $9$，因此 $e_2 = 9+1=10$。区间为 $[2, 10)$。\n- 对于 $t_3$：在 $s_3=3$ 定义。在程序点 $4$ 和 $7$ 使用。最后一次使用在程序点 $7$，因此 $e_3 = 7+1=8$。区间为 $[3, 8)$。\n- 对于 $t_4$：在 $s_4=4$ 定义。在程序点 $5$ 和 $8$ 使用。最后一次使用在程序点 $8$，因此 $e_4 = 8+1=9$。区间为 $[4, 9)$。\n- 对于 $t_5$：在 $s_5=5$ 定义。在程序点 $6$ 和 $11$ 使用。最后一次使用在程序点 $11$，因此 $e_5 = 11+1=12$。区间为 $[5, 12)$。\n- 对于 $t_6$：在 $s_6=6$ 定义。在程序点 $7$ 和 $12$ 使用。最后一次使用在程序点 $12$，因此 $e_6 = 12+1=13$。区间为 $[6, 13)$。\n- 对于 $t_7$：在 $s_7=7$ 定义。唯一的使用在程序点 $8$。最后一次使用在程序点 $8$，因此 $e_7 = 8+1=9$。区间为 $[7, 9)$。\n- 对于 $t_8$：在 $s_8=8$ 定义。唯一的使用在程序点 $9$。最后一次使用在程序点 $9$，因此 $e_8 = 9+1=10$。区间为 $[8, 10)$。\n- 对于 $t_9$：在 $s_9=9$ 定义。唯一的使用在程序点 $10$。最后一次使用在程序点 $10$，因此 $e_9 = 10+1=11$。区间为 $[9, 11)$。\n- 对于 $t_{10}$：在 $s_{10}=10$ 定义。唯一的使用在程序点 $11$。最后一次使用在程序点 $11$，因此 $e_{10} = 11+1=12$。区间为 $[10, 12)$。\n- 对于 $t_{11}$：在 $s_{11}=11$ 定义。唯一的使用在程序点 $12$。最后一次使用在程序点 $12$，因此 $e_{11} = 12+1=13$。区间为 $[11, 13)$。\n\n接下来，我们应用LSRA算法。该算法按起始点 $s_i$ 排序来处理区间。为了在为新区间 $t_i$ 分配寄存器时不发生溢出，可用寄存器的数量 $k$ 必须严格大于 `active` 集合中已有的区间数量（即那些已经开始但尚未结束的区间）。因此，所需的最小寄存器数 $k^{\\star}$ 是在分配一个新区间之前活跃区间的最大数量加一。这等同于找出在程序中任何一点上同时重叠的活跃区间的最大数量。\n\n让我们跟踪LSRA的过程以及在分配每个新区间 $t_i$ 之前 `active` 集合的大小（记为 $|\\text{active}|$）。区间按 $t_1, t_2, \\ldots, t_{11}$ 的顺序进行处理。\n\n1.  处理 $t_1$（在 $s_1=1$ 开始）：`active` 集合为空。$|\\text{active}|=0$。需要 $k > 0$。\n2.  处理 $t_2$（在 $s_2=2$ 开始）：没有区间过期。`active` 集合为 $\\{t_1\\}$。$|\\text{active}|=1$。需要 $k > 1$。\n3.  处理 $t_3$（在 $s_3=3$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2\\}$。$|\\text{active}|=2$。需要 $k > 2$。\n4.  处理 $t_4$（在 $s_4=4$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2, t_3\\}$。$|\\text{active}|=3$。需要 $k > 3$。\n5.  处理 $t_5$（在 $s_5=5$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2, t_3, t_4\\}$。$|\\text{active}|=4$。需要 $k > 4$。\n6.  处理 $t_6$（在 $s_6=6$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2, t_3, t_4, t_5\\}$。$|\\text{active}|=5$。需要 $k > 5$。\n7.  处理 $t_7$（在 $s_7=7$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2, t_3, t_4, t_5, t_6\\}$。$|\\text{active}|=6$。要在不溢出的情况下为 $t_7$ 分配寄存器，我们需要 $k > 6$。这确定了 $k^{\\star} \\ge 7$。分配后，`active` 集合的大小变为 $7$。\n8.  处理 $t_8$（在 $s_8=8$ 开始）：$t_3$ 的区间是 $[3, 8)$。因为 $e_3 = 8 \\le s_8=8$，它会过期并从 `active` 集合中移除。`active` 集合变为 $\\{t_1, t_2, t_4, t_5, t_6, t_7\\}$。$|\\text{active}|=6$。同样，要在不溢出的情况下为 $t_8$ 分配寄存器，我们需要 $k > 6$。这证实了 $k^{\\star} \\ge 7$ 的要求。\n9.  处理 $t_9$（在 $s_9=9$ 开始）：$t_4$ ($[4, 9)$) 和 $t_7$ ($[7, 9)$) 的区间会过期，因为 $e_4=9 \\le 9$ 且 $e_7=9 \\le 9$。`active` 集合变为 $\\{t_1, t_2, t_5, t_6, t_8\\}$。$|\\text{active}|=5$。这需要 $k > 5$。\n10. 处理 $t_{10}$（在 $s_{10}=10$ 开始）：区间 $t_2$ ($[2, 10)$) 和 $t_8$ ($[8, 10)$) 过期。`active` 集合变为 $\\{t_1, t_5, t_6, t_9\\}$。$|\\text{active}|=4$。这需要 $k > 4$。\n11. 处理 $t_{11}$（在 $s_{11}=11$ 开始）：区间 $t_1$ ($[1, 11)$) 和 $t_9$ ($[9, 11)$) 过期。`active` 集合变为 $\\{t_5, t_6, t_{10}\\}$。$|\\text{active}|=3$。这需要 $k > 3$。\n\n遇到的最严格的要求是 $k > 6$，这在处理 $t_7$ 和 $t_8$ 时出现。满足 $k > 6$ 的最小整数 $k$ 是 $7$。\n\n另一种方法是，$k^{\\star}$ 是在任何程序点 $p$ 同时活跃的区间的最大数量。让我们检查在程序点 $p=7$ 处的活跃区间数量：\n- $t_1: [1, 11)$ 在 $7$ 处是活跃的。\n- $t_2: [2, 10)$ 在 $7$ 处是活跃的。\n- $t_3: [3, 8)$ 在 $7$ 处是活跃的。\n- $t_4: [4, 9)$ 在 $7$ 处是活跃的。\n- $t_5: [5, 12)$ 在 $7$ 处是活跃的。\n- $t_6: [6, 13)$ 在 $7$ 处是活跃的。\n- $t_7: [7, 9)$ 在 $7$ 处是活跃的。\n所有七个区间 $\\{t_1, t_2, t_3, t_4, t_5, t_6, t_7\\}$ 在程序点 $7$ 同时活跃。并发活跃的临时变量数量为 $7$。这个峰值压力决定了所需的最小寄存器数量。\n\n因此，避免任何溢出所需的最小寄存器数量是 $7$。", "answer": "$$\\boxed{7}$$", "id": "3650259"}, {"introduction": "在寄存器资源不足时，编译器必须做出艰难的抉择：哪个变量应该被“溢出”到内存？这个决策对程序性能至关重要，尤其是在循环结构中，因为错误的决策会被放大执行成千上万次。本练习 [@problem_id:3650266] 提出了一个嵌套循环的场景，要求你基于一个明确的成本模型，通过量化分析不同溢出选择所带来的动态开销，来找出最优的溢出策略。这能让你深入理解寄存器分配中启发式决策的经济学权衡。", "problem": "一个编译器后端使用线性扫描寄存器分配算法，并在循环边界进行活跃范围切分。考虑以下三层嵌套循环和值的生命周期。在最内层循环中，有 $R=2$ 个可分配的物理寄存器可用于存放三个同时活跃的值 $x$、 $y$ 和 $s$。在最内层循环之外，只有 $x$ 可能是活跃的，并且没有额外的寄存器压力。\n\n程序结构如下，外层循环的迭代次数为 $N_{o}=100$，中层循环为 $N_{m}=50$，内层循环为 $N_{i}=20$：\n\n- 在每次外层循环迭代开始时，定义一次 $x$。值 $x$ 对于中层和内层循环是循环不变量，并且永远不会在它们内部被重新定义。\n- 在每次中层循环迭代开始时，定义一次 $y$。值 $y$ 对于内层循环是循环不变量，并且在关联的中层循环迭代之外不被使用。\n- 在每次中层循环迭代开始时，定义一个累加器 $s$。然后，在每次内层循环迭代中：\n  - 使用一次 $x$ 和一次 $y$ 来计算对 $s$ 的更新。\n  - 每次内层循环迭代更新一次 $s$（因此 $s$ 在内层循环的迭代之间是活跃的）。\n- 每个内层循环完成后，在中层循环体中恰好有一次对 $x$ 的使用。中层循环完成后，在外层循环体中恰好有最后一次对 $x$ 的使用。外层循环的最后一次使用可以重用在最后一个内层循环之后立即执行的任何 $x$ 的重载。\n\n你只被允许在最内层循环的入口和出口处切分活跃范围。在内层循环中，由于 $x$、$y$ 和 $s$ 都同时活跃且 $R=2$，你必须从 $\\{x,y,s\\}$ 中选择一个值在整个内层循环期间溢出到内存。在内层循环之外，你可以将 $x$ 保存在寄存器中而没有额外的压力。\n\n动态溢出代价模型如下：\n\n- 每次执行的对溢出值的加载操作贡献 $1$ 的代价，每次执行的对溢出值的存储操作贡献 $1$ 的代价。总动态溢出代价 $C$ 是在所有迭代中执行的溢出加载和存储操作的总数。\n- 如果 $v \\in \\{x,y\\}$ 在其活跃范围的任何点被溢出，那么在其循环级别定义之后，每次定义循环迭代会执行一次存储，以物化其内存地址。对于 $x$，这是每次外层循环迭代一次；对于 $y$，这是每次中层循环迭代一次。\n- 如果一个值在内层循环中被溢出，并且在给定的中层循环迭代的内层循环体中被使用了 $U$ 次，那么在该中层循环迭代中会产生 $U$ 次加载。\n- 如果 $x$ 在内层循环中被溢出，那么对于每次中层循环迭代，在内层循环完成后，需要一次加载才能在中层循环体中使用一次 $x$。在外层循环结束时对 $x$ 的最后一次使用会重用来自最后一次中层循环迭代的加载，不产生额外的加载代价。\n- 如果 $s$ 在内层循环中没有被保存在寄存器中，那么每次内层循环迭代会执行一次对 $s$ 的加载和一次对 $s$ 的存储。\n\n假设没有其他同时活跃的值，没有函数调用，也没有调用约定效应。选择能够最小化 $C$ 的内层循环切分和溢出位置，并计算最小的 $C$ 作为一个精确整数（内存操作的数量）。不需要四舍五入。将你的最终答案表示为单个数字。", "solution": "在尝试求解之前，必须首先验证问题陈述的科学合理性、完整性和客观性。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n\n问题陈述中提供的明确数据、变量和条件如下：\n- **系统参数：**\n    - 寄存器分配算法：线性扫描，并在循环边界进行活跃范围切分。\n    - 可用物理寄存器数量：$R=2$。\n    - 最内层循环中同时活跃的值：$x$, $y$, $s$。\n- **循环迭代次数：**\n    - 外层循环：$N_{o}=100$。\n    - 中层循环：$N_{m}=50$。\n    - 内层循环：$N_{i}=20$。\n- **值的生命周期和使用模式：**\n    - $x$: 每次外层循环迭代定义一次。每次内层循环迭代使用一次，每次中层循环迭代（在内层循环之后）使用一次。在最后一次中层循环迭代之后有一次最终使用。\n    - $y$: 每次中层循环迭代定义一次。每次内层循环迭代使用一次。\n    - $s$: 每次中层循环迭代定义一次。每次内层循环迭代更新（读取和写入）一次。\n- **溢出策略：**\n    - 活跃范围只能在最内层循环的入口和出口处切分。\n    - 必须从集合 $\\{x, y, s\\}$ 中精确选择一个值，在整个内层循环期间作为溢出值。\n- **溢出代价模型：**\n    - 总动态溢出代价 $C$ 是因溢出而执行的所有加载和存储操作的总和。\n    - 每次加载或存储操作的代价为 $1$。\n    - 如果 $x$ 被溢出，每次外层循环迭代执行一次存储（总共 $N_o$ 次）。\n    - 如果 $y$ 被溢出，每次中层循环迭代执行一次存储（总共 $N_o \\times N_m$ 次）。\n    - 在内层循环中使用一个溢出值，每次使用代价为 $1$ 次加载。\n    - 如果 $x$ 被溢出，其在中层循环体中的使用代价为每次中层循环迭代 $1$ 次加载。对 $x$ 的最后一次使用重用最后一次加载，没有额外代价。\n    - 如果 $s$ 被溢出，内层循环中的每次更新代价为 $1$ 次加载和 $1$ 次存储。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据所需标准对问题进行评估：\n- **科学依据：** 该问题牢固地建立在编译器设计的既定原则之上，特别是寄存器分配。线性扫描算法、活跃范围、溢出和代价模型是计算机科学中标准的、可形式化的概念。该场景是在循环嵌套中寄存器压力超过可用寄存器的经典实例。\n- **适定性：** 该问题提供了一个明确定义的状态、一组清晰的约束条件和一个要最小化的目标函数。可能的溢出选择是离散的（溢出 $x$、$y$ 或 $s$），并且每种选择的代价都可以根据给定数据计算得出。这确保了存在一个唯一的、有意义的解决方案。\n- **客观性：** 问题以精确的、定量的术语陈述。所有操作、它们的频率和代价都被明确定义。没有主观或基于意见的元素。\n- **完整性和一致性：** 问题是自洽的。它提供了所有必要的迭代次数、使用频率和代价规则。约束条件是一致的；例如，有 $3$ 个活跃值（$x, y, s$）但只有 $2$ 个寄存器（$R=2$）的条件正确地确立了溢出一个值的必要性。\n\n**步骤3：结论与行动**\n\n该问题是有效的。它是编译器原理领域内一个定义明确的优化问题。开始求解。\n\n**求解推导**\n\n任务是确定在最内层循环执行期间，应将三个值——$x$、$y$ 或 $s$——中的哪一个溢出，以最小化总动态溢出代价 $C$。我们必须计算三种互斥情况中每一种的代价，并选择代价最小的一种。设这些代价为 $C_x$、$C_y$ 和 $C_s$。\n\n每个循环级别的总执行次数为：\n- 外层循环：$N_o = 100$ 次。\n- 中层循环：$N_o \\times N_m = 100 \\times 50 = 5000$ 次。\n- 内层循环：$N_o \\times N_m \\times N_i = 100 \\times 50 \\times 20 = 100000$ 次。\n\n**情况1：溢出值 $x$**\n\n如果 $x$ 被溢出，产生的代价如下：\n1.  **初始存储：** 每次定义 $x$ 时，会执行一次将其存储到其内存地址的操作。$x$ 在每次外层循环迭代中定义一次。\n    - 存储代价 = $N_o = 100$。\n2.  **内层循环加载：** $x$ 在每次内层循环迭代中使用一次。由于它被溢出，每次使用都需要一次加载。\n    - 内层循环加载代价 = $1 \\times (N_o \\times N_m \\times N_i) = 100000$。\n3.  **中层循环加载：** 在内层循环完成后，$x$ 在中层循环体中使用一次。这在每次中层循环迭代中发生，并需要一次加载。\n    - 中层循环加载代价 = $1 \\times (N_o \\times N_m) = 5000$。\n4.  **外层循环加载：** 对 $x$ 的最后一次使用重用了最后一次中层循环迭代的加载，不产生额外代价。\n\n溢出 $x$ 的总代价 $C_x$ 是这些部分的总和：\n$$C_x = N_o + (N_o \\times N_m \\times N_i) + (N_o \\times N_m)$$\n$$C_x = 100 + (100 \\times 50 \\times 20) + (100 \\times 50) = 100 + 100000 + 5000 = 105100$$\n\n**情况2：溢出值 $y$**\n\n如果 $y$ 被溢出，产生的代价如下：\n1.  **初始存储：** 每次定义 $y$ 时，会执行一次存储操作。$y$ 在每次中层循环迭代中定义一次。\n    - 存储代价 = $N_o \\times N_m = 100 \\times 50 = 5000$。\n2.  **内层循环加载：** $y$ 在每次内层循环迭代中使用一次，每次都需要一次加载。\n    - 内层循环加载代价 = $1 \\times (N_o \\times N_m \\times N_i) = 100000$。\n值 $y$ 在内层循环之外不被使用，因此没有其他溢出代价。\n\n溢出 $y$ 的总代价 $C_y$ 是这些部分的总和：\n$$C_y = (N_o \\times N_m) + (N_o \\times N_m \\times N_i)$$\n$$C_y = (100 \\times 50) + (100 \\times 50 \\times 20) = 5000 + 100000 = 105000$$\n\n**情况3：溢出值 $s$**\n\n如果累加器 $s$ 被溢出，代价模型规定内层循环中的每次更新需要一次加载和一次存储。\n1.  **内层循环加载和存储：** 值 $s$ 在每次内层循环迭代中更新一次。这包括加载旧值，计算新值，以及存储新值。\n    - 每次内层循环迭代的代价 = $1$ 次加载 + $1$ 次存储 = $2$。\n    - 总代价 = $2 \\times (N_o \\times N_m \\times N_i) = 2 \\times 100000 = 200000$。\n没有规定溢出 $s$ 会产生其他代价。\n\n溢出 $s$ 的总代价 $C_s$ 是：\n$$C_s = 2 \\times N_o \\times N_m \\times N_i$$\n$$C_s = 2 \\times (100 \\times 50 \\times 20) = 2 \\times 100000 = 200000$$\n\n**比较与最终答案**\n\n我们比较这三种情况的总动态溢出代价：\n- $C_x = 105100$\n- $C_y = 105000$\n- $C_s = 200000$\n\n通过溢出值 $y$ 可以实现最小代价。\n$$C_{min} = \\min(C_x, C_y, C_s) = \\min(105100, 105000, 200000) = 105000$$\n\n最小动态溢出代价为 $105000$。这个结果是通过在最内层循环中溢出值 $y$，同时将 $x$ 和 $s$ 保留在两个可用的寄存器中得到的。", "answer": "$$\\boxed{105000}$$", "id": "3650266"}, {"introduction": "面对寄存器压力，将变量存入内存再取回并非是唯一的解决方案。对于某些值，特别是那些可以廉价重新计算的常量，原地“重新物质化”（rematerialization）可能比访问缓慢的内存更加高效。本练习 [@problem_id:3650284] 让你扮演编译器的角色，通过计算成本“交叉点”来决定何时应该采用重新物质化策略，而不是传统的溢出策略。这个分析揭示了现代编译器在做出微观优化决策时所依赖的深刻的成本效益分析。", "problem": "考虑一个目标机器，它拥有 $R$ 个可分配的通用寄存器和一个线性扫描寄存器分配器。成本模型如下：每次内存访问（加载或存储）的成本为 $c_{\\text{mem}}$，每条算术/逻辑指令的成本为 $c_{\\text{alu}}$。假设所有内存访问都具有相同的成本 $c_{\\text{mem}}$，并且所有算术/逻辑指令都具有相同的成本 $c_{\\text{alu}}$。\n\n给定以下线性代码片段（伪汇编），其中一个$32$位立即数 $K$ 的常量物化需要恰好 $t=2$ 条算术/逻辑指令（例如，一条高位立即数构建指令和一条立即数加法指令），并且 $K$ 在之后的 $U=5$ 个点被使用：\n- 在程序点 $p_1$ 处，通过物化常量 $K$ 定义了一个可重物质化的值 $k$（这个定义本身使用了程序语义中已有的算术/逻辑指令，不是可选的）。\n- 在程序点 $p_1$ 和程序点 $p_2, p_3, p_4, p_5, p_6$ 之间，值 $k$ 被使用了恰好 $U=5$ 次，在这些点上各使用一次。\n- 由于 $R=2$ 个可分配寄存器的寄存器压力以及其他临时变量（未显示）的活跃范围，线性扫描分配器必须在 $p_1$ 之后立即将 $k$ 溢出；$k$ 无法在其多次使用期间一直驻留在寄存器中。\n\n考虑两种分配策略：\n1. 基准溢出策略：在 $p_1$ 处将 $k$ 存储到其溢出槽，并在其 $U=5$ 次使用的每一次之前立即从内存中重载 $k$。\n2. 重物质化策略：不在 $p_1$ 处存储 $k$，而是在其 $U=5$ 次使用的每一次之前，通过每次使用 $t=2$ 条算术/逻辑指令重新物化 $K$ 来重新计算 $k$，以代替从内存中重载。\n\n假设两种策略之间没有其他成本差异，并假设根据程序语义的要求，在 $p_1$ 处的定义在两种策略中都必须存在，以便初始计算 $k$。重物质化策略减少了内存流量，但增加了指令总数。\n\n将交叉点定义为比率 $r^{\\ast}=\\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$ 的值，在该值下，基准溢出策略的总成本等于重物质化策略的总成本。计算上述场景的 $r^{\\ast}$，并将您的最终答案表示为一个无单位的简化精确表达式。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是有效的。这是编译器优化领域（特别是寄存器分配）中的一个良定问题。所有必要的数据均已提供，目标明确且可形式化。\n\n目标是确定交叉点，即比率 $r^{\\ast} = \\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$，在该点上基准溢出策略的总成本等于重物质化策略的总成本。设 $C_{\\text{spill}}$ 表示溢出策略产生的总额外成本，而 $C_{\\text{remat}}$ 表示重物质化策略的总额外成本。在程序点 $p_1$ 处值 $k$ 的初始定义成本是两种策略所共有的，因此从比较中排除。\n\n首先，我们分析基准溢出策略的成本 $C_{\\text{spill}}$。\n问题陈述指出，由于寄存器压力，值 $k$ 必须在其于 $p_1$ 定义后立即溢出。这意味着分配器会插入一条`store`指令，将值 $k$ 从寄存器写入其在内存中的溢出槽。这个单一操作产生的成本为 $c_{\\text{mem}}$。\n随后，在 $k$ 的 $U=5$ 次使用（在点 $p_2$ 到 $p_6$）的每一次之前，该值必须从内存中读回到寄存器中。这需要在每次使用前插入一条`load`指令。由于有 $U=5$ 次使用，这将导致 $U$ 次加载操作。这些加载的总成本是 $U \\times c_{\\text{mem}}$。\n溢出策略的总额外成本是初始存储成本和后续加载成本的总和：\n$$ C_{\\text{spill}} = 1 \\cdot c_{\\text{mem}} + U \\cdot c_{\\text{mem}} = (U+1) c_{\\text{mem}} $$\n鉴于使用次数为 $U=5$，成本为：\n$$ C_{\\text{spill}} = (5+1) c_{\\text{mem}} = 6 c_{\\text{mem}} $$\n\n接下来，我们分析重物质化策略的成本 $C_{\\text{remat}}$。\n在这种策略中，值 $k$ 在 $p_1$ 定义后不存储到内存中，因此没有`store`成本。在每次使用前，不是从内存加载该值，而是重新计算它。\n值 $k$ 是通过物化一个常量 $K$ 来定义的，这需要 $t=2$ 条算术/逻辑指令。这个重新计算在 $U=5$ 次使用的每一次之前执行。\n额外的算术/逻辑指令总数是使用次数与每次重物质化所需指令数的乘积，即 $U \\times t$。\n单条算术/逻辑指令的成本是 $c_{\\text{alu}}$。因此，重物质化策略的总额外成本是：\n$$ C_{\\text{remat}} = (U \\cdot t) \\cdot c_{\\text{alu}} $$\n给定值 $U=5$ 和 $t=2$，成本为：\n$$ C_{\\text{remat}} = (5 \\cdot 2) c_{\\text{alu}} = 10 c_{\\text{alu}} $$\n\n当两种策略的成本相等时，出现交叉点：\n$$ C_{\\text{spill}} = C_{\\text{remat}} $$\n代入推导出的成本表达式：\n$$ (U+1) c_{\\text{mem}} = (U \\cdot t) c_{\\text{alu}} $$\n我们需要求出比率 $r^{\\ast} = \\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$。我们可以通过重排方程来求得此值：\n$$ r^{\\ast} = \\frac{c_{\\text{mem}}}{c_{\\text{alu}}} = \\frac{U \\cdot t}{U+1} $$\n现在，我们将指定的数值 $U=5$ 和 $t=2$ 代入此表达式：\n$$ r^{\\ast} = \\frac{5 \\cdot 2}{5+1} = \\frac{10}{6} $$\n化简该分数得到最终结果：\n$$ r^{\\ast} = \\frac{5}{3} $$\n该值表示当两种策略成本相等时，内存访问成本与ALU操作成本的比率。", "answer": "$$\\boxed{\\frac{5}{3}}$$", "id": "3650284"}]}