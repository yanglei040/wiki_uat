{"hands_on_practices": [{"introduction": "`if` 转换的一个核心目标是将分支的控制依赖转变为数据依赖，从而消除因分支预测失败带来的性能损失。这个练习将带你亲手实践这一转换过程，通过将一个包含多个条件判断的计算核心改写为使用 `min` 和 `max` 等价形式。通过计算两种不同实现方式（分离的比较和选择指令，以及融合后的 `min`/`max` 指令）下的关键路径延迟，你将能直观地理解编译器识别特定模式（即“惯用型”）并进行指令融合所带来的性能提升。", "problem": "考虑以下标量内核，该内核使用控制相关的更新来钳位和组合整数值：\n\n对于每个索引 $i$，\n- 令 $t \\leftarrow A[i] - B[i]$。\n- 如果 $t  \\mathrm{hi}$，则 $t \\leftarrow \\mathrm{hi}$。\n- 如果 $t  \\mathrm{lo}$，则 $t \\leftarrow \\mathrm{lo}$。\n- 如果 $t  C[i]$，则 $u \\leftarrow C[i]$，否则 $u \\leftarrow t$。\n- 令 $v \\leftarrow u + D[i]$。\n- 如果 $v  k$，则 $R[i] \\leftarrow v$，否则 $R[i] \\leftarrow k$。\n\n假设所有输入 $A[i]$、$B[i]$、$C[i]$、$D[i]$、$\\mathrm{lo}$、$\\mathrm{hi}$ 和 $k$ 在时间 $0$ 时均在寄存器中可用（无内存延迟），并且机器是一个理想的乱序执行核心，具有足够的发射宽度和资源，因此只有真实数据依赖链决定了生成 $R[i]$ 的延迟。编译器面向一个类精简指令集计算 (RISC) 的指令集架构，并可能执行 If-Conversion 以使用谓词执行来消除控制依赖。\n\n给定以下关于谓词执行和惯用法的基本定义和成本模型：\n- 谓词执行将每个控制相关的赋值转换为一个数据相关的操作，该操作使用由比较生成的谓词，例如条件移动（缩写为 cmov）或选择。\n- If-Conversion 后的形式可以使用 min 和 max 代数惯用法来表示：$\\min(x, y)$ 和 $\\max(x, y)$。当条件和操作数的选择与惯用法模式匹配时，编译器会识别这些惯用法。\n- 延迟（寄存器到寄存器），单位为周期：\n  - 整数加法或减法：$L_{a} = 1$。\n  - 生成谓词的比较：$L_{c} = 1$。\n  - 消耗谓词的选择或条件移动：$L_{s} = 2$。\n  - 识别后作为单条指令的融合 min 或 max 惯用法：$L_{mm} = 1$。\n- 微操作 (uop) 计数和融合机会：\n  - 整数加法或减法：$1$ uop。\n  - 比较：$1$ uop。\n  - 选择或条件移动：$1$ uop。\n  - 识别的 min 或 max 惯用法：$1$ uop（在适用时，这会取代 compare+select 对，将两个 uop 减少为一个）。\n  - 在原始的分支代码中，每个紧随其后是条件分支的比较指令都可以在前端宏融合为一个融合微操作以用于取指/发射，但这不会改变真实数据依赖链的延迟。在 If-Conversion 之后，没有分支，因此分支宏融合不适用。\n\n任务：\n- 使用 min 和 max 惯用法重写内核（即，用 $\\min$ 和 $\\max$ 而不是控制流来表示它），并通过 $\\min$ 和 $\\max$ 的定义以及谓词执行的语义来证明其正确性。\n- 在上述成本模型下，计算在以下两种 If-Conversion 实现中，单次迭代生成 $R[i]$ 的关键路径数据依赖长度（以周期为单位）：\n  - 实现 $\\mathcal{S}$：使用比较加选择来实现每个 $\\min$ 或 $\\max$（无惯用法识别）。每个 $\\min$ 或 $\\max$ 的数据依赖贡献是 $L_{c} + L_{s}$。\n  - 实现 $\\mathcal{M}$：将每个 $\\min$ 或 $\\max$ 实现为延迟为 $L_{mm}$ 的已识别融合惯用法指令（启用惯用法识别）。\n  在两种实现中，加法或减法使用 $L_{a}$，并假设所有输入在时间 $0$ 时都已就绪。\n- 量化实现 $\\mathcal{S}$ 和 $\\mathcal{M}$ 中每次迭代的 uop 数量，并简要解释 uop 融合机会与原始分支形式有何不同。\n- 最后，报告一个数字：在给定延迟下，$\\mathcal{S}$ 和 $\\mathcal{M}$ 中每次迭代的最佳情况关键路径延迟（以周期为单位）。\n\n将你的最终答案表示为一个整数周期的数值，答案框内不包含单位或其他额外文本。", "solution": "该问题已经过验证，被认为是科学上合理的、问题定义明确且客观的。它为分析编译器优化及其在模型架构上的性能影响提供了一个清晰、独立且一致的场景。因此，下面提供了完整的解决方案。\n\n标量内核通过一系列涉及条件更新的操作来处理每个元素 $i$。为了分析其在 If-Conversion 下的性能，我们首先使用 $\\min$ 和 $\\max$ 函数将控制相关的逻辑转换为数据流表示。这种转换基于谓词执行的语义，其中条件赋值被数据相关的选择所取代。\n\n对于索引 $i$ 的操作序列是：\n1.  令 $t \\leftarrow A[i] - B[i]$。\n2.  如果 $t > \\mathrm{hi}$，则 $t \\leftarrow \\mathrm{hi}$。\n3.  如果 $t  \\mathrm{lo}$，则 $t \\leftarrow \\mathrm{lo}$。\n4.  如果 $t  C[i]$，则 $u \\leftarrow C[i]$，否则 $u \\leftarrow t$。\n5.  令 $v \\leftarrow u + D[i]$。\n6.  如果 $v  k$，则 $R[i] \\leftarrow v$，否则 $R[i] \\leftarrow k$。\n\n让我们将每个条件步骤转换为其等效的 `min`/`max` 形式：\n\n- 步骤 $1$：一个简单的减法。我们称结果为 $t_0$。\n    $t_0 \\leftarrow A[i] - B[i]$\n\n- 步骤 $2$：“如果 $t > \\mathrm{hi}$ 则 $t \\leftarrow \\mathrm{hi}$” 在 $t$ 的值超过 $\\mathrm{hi}$ 时将其设置为 $\\mathrm{hi}$，否则保持不变。这等同于取当前值和 $\\mathrm{hi}$ 的最小值。\n    $t_1 \\leftarrow \\min(t_0, \\mathrm{hi})$\n\n- 步骤 $3$：“如果 $t  \\mathrm{lo}$ 则 $t \\leftarrow \\mathrm{lo}$” 在 $t$ 的值小于 $\\mathrm{lo}$ 时将其设置为 $\\mathrm{lo}$，否则保持不变。这等同于取当前值和 $\\mathrm{lo}$ 的最大值。\n    $t_2 \\leftarrow \\max(t_1, \\mathrm{lo})$\n    步骤 $2$ 和 $3$ 的组合有效地将值 $t_0$ 钳位在 $[\\mathrm{lo}, \\mathrm{hi}]$ 范围内。\n\n- 步骤 $4$：“如果 $t  C[i]$ 则 $u \\leftarrow C[i]$ 否则 $u \\leftarrow t$” 选择了两个值 $t$ 和 $C[i]$ 中较大的一个。这是最大函数的定义。\n    $u \\leftarrow \\max(t_2, C[i])$\n\n- 步骤 $5$：一个简单的加法。\n    $v \\leftarrow u + D[i]$\n\n- 步骤 $6$：“如果 $v  k$ 则 $R[i] \\leftarrow v$ 否则 $R[i] \\leftarrow k$” 选择了两个值 $v$ 和 $k$ 中较小的一个。这是最小函数的定义。\n    $R[i] \\leftarrow \\min(v, k)$\n\n整个计算可以表示为一个数据流链：\n$t_0 \\leftarrow A[i] - B[i]$\n$t_1 \\leftarrow \\min(t_0, \\mathrm{hi})$\n$t_2 \\leftarrow \\max(t_1, \\mathrm{lo})$\n$u \\leftarrow \\max(t_2, C[i])$\n$v \\leftarrow u + D[i]$\n$R[i] \\leftarrow \\min(v, k)$\n\n由于所有输入（$A[i]$、$B[i]$、$C[i]$、$D[i]$、$\\mathrm{lo}$、$\\mathrm{hi}$、$k$）在时间 $0$ 时都可用，并且我们假设有一个理想的乱序执行核心，因此关键路径延迟由最长的真实数据依赖链决定。在这种情况下，计算构成了一个单一的线性依赖链。总延迟是该链中每个操作延迟的总和。\n\n给定的延迟如下：\n- 整数加法或减法：$L_{a} = 1$ 周期。\n- 比较：$L_{c} = 1$ 周期。\n- 选择/条件移动：$L_{s} = 2$ 周期。\n- 融合的 min/max 惯用法：$L_{mm} = 1$ 周期。\n\n我们现在计算两种指定实现的关键路径延迟。\n\n**实现 $\\mathcal{S}$（无惯用法识别）**：每个 $\\min$ 或 $\\max$ 操作都实现为一个 `compare` 后跟一个 `select`。这样一个序列的延迟是 $L_{c} + L_{s} = 1 + 2 = 3$ 个周期。\n\n1.  $t_0$ 在时间 $T(t_0) = 0 + L_a = 1$ 时就绪。\n2.  $t_1$ 依赖于 $t_0$。$T(t_1) = T(t_0) + (L_c + L_s) = 1 + 3 = 4$。\n3.  $t_2$ 依赖于 $t_1$。$T(t_2) = T(t_1) + (L_c + L_s) = 4 + 3 = 7$。\n4.  $u$ 依赖于 $t_2$。$T(u) = T(t_2) + (L_c + L_s) = 7 + 3 = 10$。\n5.  $v$ 依赖于 $u$。$T(v) = T(u) + L_a = 10 + 1 = 11$。\n6.  $R[i]$ 依赖于 $v$。$T(R[i]) = T(v) + (L_c + L_s) = 11 + 3 = 14$。\n\n实现 $\\mathcal{S}$ 的关键路径延迟是 $14$ 个周期。\n\n**实现 $\\mathcal{M}$（有惯用法识别）**：每个 $\\min$ 或 $\\max$ 操作都实现为延迟为 $L_{mm} = 1$ 个周期的单个融合指令。\n\n1.  $t_0$ 在时间 $T(t_0) = 0 + L_a = 1$ 时就绪。\n2.  $t_1$ 依赖于 $t_0$。$T(t_1) = T(t_0) + L_{mm} = 1 + 1 = 2$。\n3.  $t_2$ 依赖于 $t_1$。$T(t_2) = T(t_1) + L_{mm} = 2 + 1 = 3$。\n4.  $u$ 依赖于 $t_2$。$T(u) = T(t_2) + L_{mm} = 3 + 1 = 4$。\n5.  $v$ 依赖于 $u$。$T(v) = T(u) + L_{a} = 4 + 1 = 5$。\n6.  $R[i]$ 依赖于 $v$。$T(R[i]) = T(v) + L_{mm} = 5 + 1 = 6$。\n\n实现 $\\mathcal{M}$ 的关键路径延迟是 $6$ 个周期。\n\n接下来，我们量化每次迭代的微操作（uop）数量。该内核包含 $1$ 次减法、$1$ 次加法和 $4$ 次 min/max 操作。\n\n- 在实现 $\\mathcal{S}$ 中，每个 `min`/`max` 是一个 `compare`（$1$ uop）加上一个 `select`（$1$ uop），总共 $2$ 个 uop。\n  $\\mathcal{S}$ 的 uop 数量 = $1_{\\text{sub}} + 4 \\times (1_{\\text{cmp}} + 1_{\\text{sel}}) + 1_{\\text{add}} = 1 + 4 \\times 2 + 1 = 10$ 个 uop。\n\n- 在实现 $\\mathcal{M}$ 中，每个 `min`/`max` 是一个单一的融合指令（$1$ uop）。\n  $\\mathcal{M}$ 的 uop 数量 = $1_{\\text{sub}} + 4 \\times (1_{\\text{min/max}}) + 1_{\\text{add}} = 1 + 4 + 1 = 6$ 个 uop。\n\n原始分支代码和 If-Conversion 形式之间的融合机会有显著不同。在原始代码中，主要的融合机会是*宏融合*，即一个 `compare` 指令及其后续的 `conditional branch` 指令在前端被融合成一个单一的 uop 用于取指和解码。这导致执行的 uop 数量是可变的，取决于数据相关的执行路径。相比之下，在 If-Conversion 的实现 $\\mathcal{M}$ 中，机会是*微操作融合*（或指令选择期间的惯用法识别）。一个 `compare`-`select` 模式被一个单一的、专门的 `min` 或 `max` 指令所取代。这种融合对每个此类模式都会发生，导致执行的 uop 总数是固定的，并且在这种情况下更低（$\\mathcal{M}$ 为 $6$ 个 uop，而 $\\mathcal{S}$ 为 $10$ 个）。\n\n最后，最佳情况的关键路径延迟是在实现 $\\mathcal{S}$ 和 $\\mathcal{M}$ 中计算出的延迟的最小值。\n最佳情况延迟 $= \\min(14, 6) = 6$ 个周期。", "answer": "$$\\boxed{6}$$", "id": "3663804"}, {"introduction": "`if` 转换在单指令多数据（Single Instruction, Multiple Data, SIMD）并行计算中尤为重要，因为它能确保所有数据通道同步执行，避免了分支发散。本练习将引导你为一个实际的图像处理任务（阈值化）建立性能模型，用以比较传统的标量分支循环和向量化的谓词执行循环。你将推导出一个加速比公式，该公式依赖于分支预测的成功率（由数据本身的特性决定）和 SIMD 向量的宽度，并通过编程实践来验证你的模型。", "problem": "给定一个应用于图像的带分支的标量阈值化循环，该图像表示为一个包含 $N$ 个像素的一维数组，其中每个像素是一个非负整数强度值。该标量循环将每个像素与一个阈值 $T$ 进行比较，并根据是否满足阈值条件将 $255$ 或 $0$ 写入输出。带分支的标量循环具有以下形式：对于每个索引 $i$，如果 $\\text{in}[i] \\ge T$，则 $\\text{out}[i] \\leftarrow 255$；否则 $\\text{out}[i] \\leftarrow 0$。您的任务是使用单指令多数据（SIMD）的谓词执行来移植此计算，其向量长度为 $VL$（即每个向量操作处理的元素数量），并计算谓词化 SIMD 版本相对于带分支标量版本的期望加速比，该加速比是阈值命中率 $r$（即给定像素满足 $\\text{in}[i] \\ge T$ 的概率）和向量长度 $VL$ 的函数。\n\n本问题的基础由以下经过充分检验的事实和定义构成：\n- 随机变量的期望值是其所有可能值的概率加权平均值。如果一个概率为 $r$ 的事件产生代价 $P$，否则代价为 $0$，那么期望的额外代价是 $r \\cdot P$。\n- 在一个以处理器周期为单位的简单成本模型中，一条指令有关联的周期成本。一个循环的总周期是其组成操作的周期之和。对于每元素的期望成本，当对 $N$ 个独立元素进行聚合时，需除以 $N$。\n- 谓词 SIMD 通过掩码计算和选择操作来替代分支，这些操作对 $VL$ 个元素进行同步处理，使得每元素的成本等于每向量的成本除以 $VL$。\n\n假设使用以下以周期为单位的成本模型，这对于现代乱序超标量处理器是科学上合理的：\n- 对于带分支的标量循环，每个元素产生一个基础成本，等于加载成本 $c_{\\text{ld}}$、比较成本 $c_{\\text{cmp}}$、存储成本 $c_{\\text{st}}$ 和分支解析开销 $c_{\\text{br}}$ 之和。此外，在发生意外的跳转时，会支付分支预测错误的惩罚 $P$。在静态“预测不跳转”的预测器模型下，满足阈值的像素被视为以概率 $r$“跳转”，并期望上产生惩罚 $P$。因此，标量分支循环的每元素期望成本是基础成本加上 $r \\cdot P$。\n- 对于谓词化 SIMD 循环，对于每个包含 $VL$ 个元素的向量，有一次成本为 $C_{\\text{vld}}$ 的向量加载，一次成本为 $C_{\\text{vcmp}}$ 的向量比较，一次成本为 $C_{\\text{vblend}}$ 的向量混合/选择，以及一次成本为 $C_{\\text{vst}}$ 的向量存储。没有数据依赖的分支成本。SIMD 版本的每元素成本是这些每向量成本之和除以 $VL$。\n\n您的任务是：\n1.  根据上述基本事实，推导出带分支标量循环的每元素期望成本，作为 $r$ 的函数。除了基本事实所暗示的公式外，不要使用任何快捷公式。\n2.  根据上述基本事实，推导谓词化 SIMD 循环的每元素成本，作为 $VL$ 的函数。\n3.  将加速比 $S(r, VL)$ 定义为标量每元素期望成本与谓词化 SIMD 每元素成本的比率。\n4.  使用 C 语言（标准 C23）实现一个程序，根据给定的常量，为下面指定的测试套件中的每个测试用例计算 $S(r, VL)$。程序必须生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个加速比值必须打印为四舍五入到六位小数的浮点数。\n\n在您的模型中使用的常量：\n- 每个元素的标量成本：$c_{\\text{ld}} = 1$，$c_{\\text{cmp}} = 1$，$c_{\\text{st}} = 1$，$c_{\\text{br}} = 1$，以及分支预测错误惩罚 $P = 15$。\n- 每个向量的谓词化 SIMD 成本：$C_{\\text{vld}} = 3$，$C_{\\text{vcmp}} = 3$，$C_{\\text{vblend}} = 3$，$C_{\\text{vst}} = 3$。\n\n测试套件（每个用例是一对 $(r, VL)$）：\n- 用例 1：$r = 0$，$VL = 4$。\n- 用例 2：$r = 0.5$，$VL = 4$。\n- 用例 3：$r = 1.0$，$VL = 4$。\n- 用例 4：$r = 0.1$，$VL = 8$。\n- 用例 5：$r = 0.9$，$VL = 8$。\n- 用例 6：$r = 0.5$，$VL = 1$。\n- 用例 7：$r = 0.5$，$VL = 16$。\n- 用例 8：$r = 0.2$，$VL = 16$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[x_1,x_2,\\dots,x_8]$，其中每个 $x_i$ 是为用例 $i$ 计算的、四舍五入到六位小数的加速比。不应打印任何额外的文本。", "solution": "我们首先在每元素和每向量成本的层面上，使用所述的期望值和指令成本聚合的基本原则，对带分支的标量版本和谓词化单指令多数据（SIMD）版本的阈值化循环进行形式化。\n\n对于带分支的标量循环，考虑一个元素。无论分支结果如何，涉及的操作都包括加载、比较、存储以及解析分支指令。设每元素的周期成本分别为 $c_{\\text{ld}}$、$c_{\\text{cmp}}$、$c_{\\text{st}}$ 和 $c_{\\text{br}}$。在静态“预测不跳转”的分支预测器下，分支默认被预测为不发生跳转。当条件为真时，分支发生跳转并被错误预测。如果我们用 $r$（阈值命中率）表示一个元素满足阈值的概率，那么错误预测事件发生的概率为 $r$。设错误预测的惩罚为 $P$ 个周期。根据期望值的定义，由错误预测引起的期望额外成本为 $r \\cdot P$。因此，标量分支循环的每元素期望成本为\n$$\nC_{\\text{branch}}(r) = c_{\\text{ld}} + c_{\\text{cmp}} + c_{\\text{st}} + c_{\\text{br}} + r \\cdot P.\n$$\n使用给定的常量 $c_{\\text{ld}} = 1$、$c_{\\text{cmp}} = 1$、$c_{\\text{st}} = 1$、$c_{\\text{br}} = 1$ 和 $P = 15$，这在数值上简化为\n$$\nC_{\\text{branch}}(r) = 1 + 1 + 1 + 1 + 15 r = 4 + 15 r.\n$$\n\n对于谓词化 SIMD 循环，谓词执行通过计算掩码和选择（混合）来替代分支，一次性对 $VL$ 个元素进行操作。每向量的操作包括一次向量加载、一次向量比较、一次向量混合/选择和一次向量存储。设它们的每向量周期成本分别为 $C_{\\text{vld}}$、$C_{\\text{vcmp}}$、$C_{\\text{vblend}}$ 和 $C_{\\text{vst}}$。由于在谓词执行下这些成本不是数据依赖的，所以每向量的总成本为\n$$\nC_{\\text{SIMD,vector}} = C_{\\text{vld}} + C_{\\text{vcmp}} + C_{\\text{vblend}} + C_{\\text{vst}}.\n$$\n为了获得每元素的成本，将每向量的成本除以每个向量处理的元素数量 $VL$，得到\n$$\nC_{\\text{SIMD,elem}}(VL) = \\frac{C_{\\text{vld}} + C_{\\text{vcmp}} + C_{\\text{vblend}} + C_{\\text{vst}}}{VL}.\n$$\n使用给定的常量 $C_{\\text{vld}} = 3$、$C_{\\text{vcmp}} = 3$、$C_{\\text{vblend}} = 3$ 和 $C_{\\text{vst}} = 3$，我们得到\n$$\nC_{\\text{SIMD,elem}}(VL) = \\frac{3 + 3 + 3 + 3}{VL} = \\frac{12}{VL}.\n$$\n\n将加速比 $S(r, VL)$ 定义为标量每元素期望成本与谓词化 SIMD 每元素成本的比率，即\n$$\nS(r, VL) = \\frac{C_{\\text{branch}}(r)}{C_{\\text{SIMD,elem}}(VL)}.\n$$\n代入上面推导出的表达式，\n$$\nS(r, VL) = \\frac{4 + 15 r}{12 / VL} = \\left(4 + 15 r\\right) \\cdot \\frac{VL}{12}.\n$$\n\n算法上，程序必须为每个测试用例 $(r, VL)$ 执行以下步骤：\n1.  使用 $C_{\\text{branch}}(r) = 4 + 15 r$ 计算 $C_{\\text{branch}}(r)$。\n2.  使用 $C_{\\text{SIMD,elem}}(VL) = 12 / VL$ 计算 $C_{\\text{SIMD,elem}}(VL)$。\n3.  计算 $S(r, VL)$ 为 $C_{\\text{branch}}(r) / C_{\\text{SIMD,elem}}(VL)$。\n4.  打印所得的 $S(r, VL)$，四舍五入到六位小数。\n\n现在我们评估指定的测试套件：\n- 用例 1：$r = 0$，$VL = 4$。$C_{\\text{branch}}(0) = 4 + 15 \\cdot 0 = 4$。$C_{\\text{SIMD,elem}}(4) = 12 / 4 = 3$。$S(0,4) = 4 / 3 \\approx 1.333333$。\n- 用例 2：$r = 0.5$，$VL = 4$。$C_{\\text{branch}}(0.5) = 4 + 15 \\cdot 0.5 = 11.5$。$C_{\\text{SIMD,elem}}(4) = 3$。$S(0.5,4) = 11.5 / 3 \\approx 3.833333$。\n- 用例 3：$r = 1.0$，$VL = 4$。$C_{\\text{branch}}(1.0) = 4 + 15 = 19$。$C_{\\text{SIMD,elem}}(4) = 3$。$S(1.0,4) = 19 / 3 \\approx 6.333333$。\n- 用例 4：$r = 0.1$，$VL = 8$。$C_{\\text{branch}}(0.1) = 4 + 1.5 = 5.5$。$C_{\\text{SIMD,elem}}(8) = 12 / 8 = 1.5$。$S(0.1,8) = 5.5 / 1.5 \\approx 3.666667$。\n- 用例 5：$r = 0.9$，$VL = 8$。$C_{\\text{branch}}(0.9) = 4 + 13.5 = 17.5$。$C_{\\text{SIMD,elem}}(8) = 1.5$。$S(0.9,8) = 17.5 / 1.5 \\approx 11.666667$。\n- 用例 6：$r = 0.5$，$VL = 1$。$C_{\\text{branch}}(0.5) = 11.5$。$C_{\\text{SIMD,elem}}(1) = 12$。$S(0.5,1) = 11.5 / 12 \\approx 0.958333$。\n- 用例 7：$r = 0.5$，$VL = 16$。$C_{\\text{SIMD,elem}}(16) = 12 / 16 = 0.75$。$S(0.5,16) = 11.5 / 0.75 \\approx 15.333333$。\n- 用例 8：$r = 0.2$，$VL = 16$。$C_{\\text{branch}}(0.2) = 4 + 3 = 7$。$C_{\\text{SIMD,elem}}(16) = 0.75$。$S(0.2,16) = 7 / 0.75 \\approx 9.333333$。\n\n程序将计算这些值，并以单个方括号括起来的、逗号分隔的列表形式打印出来，每个值四舍五入到六位小数。", "answer": "[1.333333,3.833333,6.333333,3.666667,11.666667,0.958333,15.333333,9.333333]", "id": "3663829"}, {"introduction": "编译器的任何优化都必须以保证程序正确性为前提。本练习将探讨一个 `if` 转换中至关重要的安全问题：当代码的一个分支包含未定义行为（Undefined Behavior, UB）时，我们还能安全地进行转换吗？通过分析一个在特定路径上会触发除零错误的例子，你将深入理解编译器的“as-if”原则，并认识到看似无害的推测执行（speculative execution）可能会如何违反该原则，从而导致在原本正确的程序路径上产生致命错误。", "problem": "执行 If-Conversion 的编译器使用谓词执行（predicated execution）将控制依赖替换为数据依赖。考虑以下 C 函数，其编写风格旨在避免显式的数字字面量，同时在不评估未定义行为（UB）的执行上保持现实和良定义：\n\n\n```c\nint g(int *p, int r) {\n    if (p) {\n        return *p;\n    } else {\n        return r / (r - r);\n    }\n}\n```\n\n假设一个典型的优化编译器，用于像 C 这样具有未定义行为（UB）语义的语言，以及一个可能支持或不支持故障抑制谓词指令（fault-suppressing predicated instructions）的目标架构。编译器希望对该分支进行 If-Conversion，通过使两个分支臂表现为一个谓词块或一个值选择（value-through-select），来提高指令级并行性。您的任务是根据第一性原理（源语言语义和程序转换的 as-if 规则、架构谓词语义以及可能陷入（trap）的操作的定义），来论证当 UB 仅存在于某些输入的未执行路径上时，此类转换的合法性和风险。特别是，分析一种推测性执行（speculatively executes）两个分支臂的转换，可能会在新情况下暴露 UB 路径的风险，即使原始控制流不会执行它。\n\n下列哪个陈述是正确的？选择所有适用项。\n\nA. 在任何目标上，将分支重写为急切计算两个分支臂，并使用条件移动或选择来挑选最终结果，是语义保持的，因为未使用的结果在影响程序之前就被丢弃了。\n\nB. 如果目标架构的谓词执行保证带有假谓词的指令既不评估其操作数也不引发异常，那么用条件的否定来保护除法操作，可以使得 If-Conversion 对于原始程序未执行 UB 的输入是语义保持的。\n\nC. 即使未执行的路径包含 UB，只要原始控制流阻止了其在给定输入上的执行，编译器就不能引入一种转换，使得该行为在这些输入上变得可观察；as-if 规则要求在有定义行为的执行上保持行为不变。\n\nD. 因为 UB 给予编译器不受限制的自由，它可以假设分母表达式永远不等于 $0$ 并在原始程序中折叠掉该除法，这使得 If-Conversion 总是安全的，无论该除法是否本会被执行。", "solution": "该问题要求分析对一个 C 函数应用 If-Conversion 的合法性，该函数包含一个分支，其中一条路径表现出未定义行为（UB）。需要应用的核心原则是 C 语言的 `as-if` 规则、UB 的语义以及在各种硬件架构上推测性执行的行为。\n\n### 第一步：问题验证\n\n问题陈述是有效的。它提供了一个良定义的 C 函数：\n```c\nint g(int *p, int r) {\n    if (p) {\n        return *p;\n    } else {\n        return r / (r - r);\n    }\n}\n```\n问题正确地指出了关键要素：一个条件分支、一条良定义的路径（`if (p)` 为真），以及一条带有未定义行为的路径（`else`，包含 `r / (r - r)`）。除法 `r / (r - r)` 简化为 `r / 0`。在 C 标准中，整数除以零被明确定义为 UB。问题关注的是在这种情况下，标准编译器优化 If-Conversion 的合法性。这是一个编译器设计中的经典且不简单的问题，需要理解语言语义和硬件现实之间的相互作用。该问题具有科学依据，阐述清晰且客观。\n\n### 第二步：从第一性原理推导\n\n编译器转换的指导原则是 **as-if 规则**。该规则规定，只要转换后程序的可观察行为与原始程序在所有具有定义行为的执行上的可观察行为相同，编译器就可以执行任何转换。可观察行为包括程序终止、I/O 以及对 `volatile` 变量的访问。崩溃或硬件异常构成一种可观察行为。\n\n我们来分析原始函数 `g(p, r)` 的行为：\n1.  **情况：`p` 不为 `NULL`**。条件 `if (p)` 为真。函数执行 `return *p;`。假设 `p` 指向一个有效的 `int`，此执行路径是良定义的。包含除以零的 `else` 块永远不会被执行。可观察行为是函数返回 `p` 指向的值。\n2.  **情况：`p` 为 `NULL`**。条件 `if (p)` 为假。函数尝试执行 `return r / (r - r);`。表达式 `r - r` 保证为 $0$。C 标准规定有符号整数除以零导致未定义行为。在这种情况下，标准对程序的行为没有任何要求。\n\n**If-Conversion 转换：**\nIf-Conversion 旨在移除控制依赖（`if` 语句），并用数据依赖取而代之。这种转换的一般形式涉及推测性地执行两个分支，然后选择正确的结果。对于函数 `g`，这在概念上等同于：\n\n```c\n// If-Conversion 的概念表示\nbool condition = (p != NULL);\nint value_if_true = *p;\nint value_if_false = r / (r - r); // 对 UB 路径的推测性执行\nint result = select(condition, value_if_true, value_if_false);\nreturn result;\n```\n\n关键问题出现在 `p` 不为 `NULL` 的时候。在原始程序中，这是一个良定义的执行。在转换后的程序中，表达式 `value_if_false = r / (r - r);` 总是被求值。在大多数常见的处理器架构上（例如 x86、A32/T32 模式下的 ARM），整数除以零指令会触发一个硬件异常（trap）。这种 trap 通常会导致操作系统终止程序（例如，在类 Unix 系统上会发送 `SIGFPE` 信号）。\n\n因此，对于一个良定义的输入（`p != NULL`），原始程序返回一个值，而简单转换后的程序会崩溃。这是可观察行为的改变，使得这种转换在 `as-if` 规则下是**非法的**。\n\n### 第三步：逐项分析选项\n\n**A. 在任何目标上，将分支重写为急切计算两个分支臂，并使用条件移动或选择来挑选最终结果，是语义保持的，因为未使用的结果在影响程序之前就被丢弃了。**\n\n这个陈述是**错误的**。其推理存在缺陷。它关注的是计算的*结果*被丢弃，但忽略了计算本身的*副作用*。计算 `r / 0` 的行为可能会产生一个可观察的副作用，即导致程序终止的 trap。这个 trap 发生在推测性执行期间，远在结果可能被“丢弃”之前。如上文分析所示，在典型的在除零时会陷入（trap）的目标架构上，这种转换改变了程序在良定义输入（`p != NULL`）下的行为，违反了 as-if 规则。因此，它在“任何目标”上都不是语义保持的。\n\n**B. 如果目标架构的谓词执行保证带有假谓词的指令既不评估其操作数也不引发异常，那么用条件的否定来保护除法操作，可以使得 If-Conversion 对于原始程序未执行 UB 的输入是语义保持的。**\n\n这个陈述是**正确的**。它描述了一种特定的架构特性，称为**故障抑制谓词执行**（例如，在 Intel 的 Itanium 架构中显著采用）。转换在概念上会是这样：\n\n1.  设谓词 `P` 在 `p != NULL` 时为真，否则为假。\n2.  `then` 分支的值被计算：`value_if_true = *p;`。这是安全的，因为它只需要在 `P` 为真时是正确的。\n3.  `else` 分支的计算由否定的谓词 `!P` 保护：`if (!P) value_if_false = r / 0;`\n4.  最后的 `select` 或条件移动指令选择结果。\n\n关键在于 `value_if_false = r / 0;` 的硬件指令会是一个谓词指令。当 `p != NULL` 时，谓词 `!P` 为假。该选项中指定的架构保证意味着，这个带谓词的除零指令会变成一个空操作（no-op）；它不访问其操作数，并且关键的是，不会引发故障。因此，对于良定义的情况（`p != NULL`），转换后的代码不会陷入，并正确地从 `then` 分支产生结果，保持了原始程序的行为。对于 UB 的情况（`p == NULL`），转换后的代码可能会也可能不会陷入，这与原始程序的 UB 是一致的。因此，该转换是语义保持的。\n\n**C. 即使未执行的路径包含 UB，只要原始控制流阻止了其在给定输入上的执行，编译器就不能引入一种转换，使得该行为在这些输入上变得可观察；as-if 规则要求在有定义行为的执行上保持行为不变。**\n\n这个陈述是**正确的**。它是 as-if 规则应用于此场景的一个精确而准确的陈述。\n-   “未执行的路径包含 UB”：这是当 `p != NULL` 时的 `else` 分支。\n-   “原始控制流阻止了其执行”：`if (p)` 检查确保了这一点。\n-   “编译器不能引入一种转换，使得该行为变得可观察”：在先前良定义的执行路径上引入一个 trap（一种可观察行为）是非法的。\n-   “as-if 规则要求在有定义行为的执行上保持行为不变”：这是形式化的理由。\n\n这个陈述正确地指出了使得在此情况下简单 If-Conversion 非法的基本约束。\n\n**D. 因为 UB 给予编译器不受限制的自由，它可以假设分母表达式永远不等于 $0$ 并在原始程序中折叠掉该除法，这使得 If-Conversion 总是安全的，无论该除法是否本会被执行。**\n\n这个陈述是**错误的**。关于 UB 的推理虽然微妙但有根本性的缺陷。当编译器遇到会产生 UB 的代码时，它被允许假设这类代码在任何良定义的程序路径上都**永远不会被执行**。在本例中，`r / (r - r)` 操作仅在 `p` 为 `NULL` 时执行。因此，编译器可以假设对于任何良定义的执行，`p` 永远不为 `NULL`。这可能允许编译器完全消除 `else` 分支，并将函数简化为 `return *p;`。\n\n然而，该选项声称编译器可以“假设分母表达式永远不等于 $0$”。分母是 `r - r`。`r - r` 等于 `0` 是一个数学和逻辑上的确定事实。编译器的推理虽然强大，但不能建立在假设逻辑矛盾（如 `$0 \\ne 0$`）的基础上。编译器的推理是关于程序状态（`p != NULL`），而不是关于违反算术公理。因为该选项中推理的前提是不成立的，所以结论是无效的。", "answer": "$$\\boxed{BC}$$", "id": "3663865"}]}