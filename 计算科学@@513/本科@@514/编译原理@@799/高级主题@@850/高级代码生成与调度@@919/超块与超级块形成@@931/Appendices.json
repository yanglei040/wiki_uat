{"hands_on_practices": [{"introduction": "形成超块并非总是有益的，它涉及到一个权衡：一方面是“热路径”上性能的提升，另一方面是潜在的开销，如代码体积膨胀和偏离路径时的性能损失。本练习将引导你构建一个简洁而强大的量化模型，学习如何基于程序的剖析数据（profiling data）来做出是否形成超块的决策，这是性能优化工程中的一项核心技能。[@problem_id:3673028]", "problem": "考虑在编译器的代码生成阶段，于一个控制流图（CFG）上的踪迹形成过程，其中踪迹是用于指导优化的频繁执行路径。基本块（Basic Block）是具有单一入口和单一出口的线性代码序列；扩展基本块（Extended Basic Block, EBB）是基本块的最大集合，其中控制流仅在第一个块进入；超块 (superblock) 是一个单入口、多出口的区域，通过线性化一条热路径并利用尾部复制（tail duplication）来消除旁路入口而形成；超大块 (hyperblock) 是通过将控制流转换为条件执行（if-转换）来形成一个单入口区域，通常会消除内部的分支。\n\n给定一个控制流图（CFG）的一次剖析运行所得到的块访问计数器，其入口块为 $B_0$，后继为 $B_1$ 和 $B_2$。从 $B_0$ 到 $B_1$ 或 $B_2$ 的分支中，$B_1$ 和 $B_2$ 没有其他前驱。在 $B_1$ 内部，控制流流向 $B_3$ 或 $B_6$；在 $B_2$ 内部，控制流流向 $B_4$ 或 $B_7$。块 $B_3$ 和 $B_4$ 流向一个公共出口块 $B_5$，且 $B_3$ 和 $B_4$ 没有其他前驱。测得的块访问计数器如下：\n- $c_{B_0} = 12000$, $c_{B_1} = 7800$, $c_{B_2} = 4200$,\n- $c_{B_3} = 6630$, $c_{B_6} = 1170$,\n- $c_{B_4} = 3360$, $c_{B_7} = 840$。\n\n考虑两个候选踪迹：\n- $T_1$: $B_0 \\rightarrow B_1 \\rightarrow B_3 \\rightarrow B_5$,\n- $T_2$: $B_0 \\rightarrow B_2 \\rightarrow B_4 \\rightarrow B_5$。\n\n假设每次动态进入该区域时，遵循以下优化成本效益模型：\n- 如果沿选定踪迹形成一个超块，当执行遵循该踪迹时，它将产生 $g_{\\mathrm{SB}} = 3$ 个时钟周期的平均踪迹上调度增益。为消除旁路入口所需的尾部复制，在执行偏离选定踪迹时，会带来 $d = 2$ 个时钟周期的平均踪迹外开销。\n- 如果只形成一个扩展基本块（EBB）（无尾部复制），当执行遵循该踪迹时，它将产生 $g_{\\mathrm{EBB}} = 1$ 个时钟周期的平均踪迹上调度增益，并且不会产生踪迹外开销。\n\n仅使用所描述的块访问计数器和CFG结构：\n- 推断路径概率 $P(T_1)$ 和 $P(T_2)$，方法是将在具有唯一前驱的后继块的块计数器视为边遍历计数，并在每个分支处形成条件概率；将路径概率定义为沿路径的条件分支概率的乘积。\n- 根据期望值推理的基本原理，推导出概率阈值 $P^{\\star}$，使得形成超块（相对于仅形成EBB）所节省的预期净时钟周期为非负。您的推导必须根据 $P(\\text{trace})$ 以及给定的 $g_{\\mathrm{SB}}$、$g_{\\mathrm{EBB}}$ 和 $d$ 来证明何时应优先选择形成扩展基本块，而不是完整的超块。\n\n以无量纲数的形式提供 $P^{\\star}$ 的精确值作为最终答案。无需四舍五入。", "solution": "首先将根据指定标准对问题进行验证。\n\n### 步骤1：提取已知条件\n问题陈述中提供的数据、变量和条件如下：\n- **控制流图（CFG）结构**：\n    - 入口块为 $B_0$。\n    - $B_0$ 分支到 $B_1$ 和 $B_2$。$B_1$ 和 $B_2$ 没有其他前驱。\n    - $B_1$ 分支到 $B_3$ 和 $B_6$。\n    - $B_2$ 分支到 $B_4$ 和 $B_7$。\n    - $B_3$ 和 $B_4$ 都流向一个公共出口块 $B_5$。$B_3$ 和 $B_4$ 没有其他前驱。\n- **块访问计数器**：\n    - $c_{B_0} = 12000$\n    - $c_{B_1} = 7800$\n    - $c_{B_2} = 4200$\n    - $c_{B_3} = 6630$\n    - $c_{B_6} = 1170$\n    - $c_{B_4} = 3360$\n    - $c_{B_7} = 840$\n- **候选踪迹**：\n    - $T_1$: $B_0 \\rightarrow B_1 \\rightarrow B_3 \\rightarrow B_5$\n    - $T_2$: $B_0 \\rightarrow B_2 \\rightarrow B_4 \\rightarrow B_5$\n- **优化成本效益模型**：\n    - 超块踪迹上增益：$g_{\\mathrm{SB}} = 3$ 个时钟周期。\n    - 超块踪迹外开销：$d = 2$ 个时钟周期。\n    - 扩展基本块（EBB）踪迹上增益：$g_{\\mathrm{EBB}} = 1$ 个时钟周期。\n    - 扩展基本块（EBB）踪迹外开销：$0$ 个时钟周期。\n- **任务**：\n    - 推断路径概率 $P(T_1)$ 和 $P(T_2)$。\n    - 推导概率阈值 $P^{\\star}$，使得形成超块相对于EBB所节省的预期净时钟周期为非负。\n    - 提供 $P^{\\star}$ 的精确值。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题的有效性进行评估。\n- **科学基础**：该问题植根于编译器设计和优化这一成熟领域。控制流图（CFG）、基本块、扩展基本块（EBB）、超块和剖析引导优化等概念都是标准且定义明确的。成本效益模型是用于学术分析的合理简化。该问题在科学上是合理的。\n- **良定性**：该问题提供了明确的目标（推导 $P^{\\star}$）、充足的数据以及一个定义明确的数学框架（期望值），以得出一个唯一的解。\n- **客观性**：语言精确且无偏见，使用了计算机科学中的正式定义。\n- **一致性检查**：所提供的块计数器在内部是一致的。\n    - 从 $B_0$ 流出的流量是守恒的：$c_{B_1} + c_{B_2} = 7800 + 4200 = 12000 = c_{B_0}$。\n    - 从 $B_1$ 流出的流量是守恒的：$c_{B_3} + c_{B_6} = 6630 + 1170 = 7800 = c_{B_1}$。\n    - 从 $B_2$ 流出的流量是守恒的：$c_{B_4} + c_{B_7} = 3360 + 840 = 4200 = c_{B_2}$。\n对于当前任务而言，数据是一致且完整的。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将提供完整解答。\n\n### 解答推导\n问题的核心是确定一个概率阈值 $P^{\\star}$，对于给定的踪迹，该阈值证明了形成超块优于形成扩展基本块（EBB）的合理性。这是一个基于期望值分析的经典优化决策。\n\n设 $P(\\text{trace})$ 为执行从 $B_0$ 开始进入该区域后，遵循特定踪迹的概率。这是“踪迹上”的概率。因此，执行偏离该踪迹（“踪迹外”）的概率是 $1 - P(\\text{trace})$。\n\n首先，我们为每种优化策略建立预期净节省时钟周期。设 $P = P(\\text{trace})$。\n\n**扩展基本块（EBB）的预期净节省时钟周期（$E_{\\mathrm{EBB}}$）**\nEBB仅在执行路径保持在踪迹上时，才提供 $g_{\\mathrm{EBB}}$ 个时钟周期的增益。对于踪迹外路径，没有指定的开销。\n预期增益是各个结果按其概率加权的总和：\n$$E_{\\mathrm{EBB}} = (g_{\\mathrm{EBB}} \\times P) + (0 \\times (1 - P)) = g_{\\mathrm{EBB}} P$$\n\n**超块（Superblock）的预期净节省时钟周期（$E_{\\mathrm{SB}}$）**\n超块在踪迹上提供更大的增益 $g_{\\mathrm{SB}}$ 个时钟周期。然而，为消除旁路入口所需的尾部复制过程，会对任何踪迹外执行路径引入 $d$ 个时钟周期的开销。\n因此，预期增益为：\n$$E_{\\mathrm{SB}} = (g_{\\mathrm{SB}} \\times P) - (d \\times (1 - P))$$\n负号表示成本或惩罚。\n\n**概率阈值（$P^{\\star}$）的推导**\n问题要求找到形成超块至少与仅形成EBB一样有益的条件。这被具体描述为“形成超块（相对于仅形成EBB）所节省的预期净时钟周期为非负”的点。这可以转化为不等式：\n$$E_{\\mathrm{SB}} - E_{\\mathrm{EBB}} \\ge 0$$\n\n代入 $E_{\\mathrm{SB}}$ 和 $E_{\\mathrm{EBB}}$ 的表达式：\n$$(g_{\\mathrm{SB}} P - d(1 - P)) - (g_{\\mathrm{EBB}} P) \\ge 0$$\n\n现在我们对 $P$ 求解这个不等式，以找到一般条件。\n$$g_{\\mathrm{SB}} P - d + dP - g_{\\mathrm{EBB}} P \\ge 0$$\n$$P(g_{\\mathrm{SB}} + d - g_{\\mathrm{EBB}}) \\ge d$$\n\n假设 $(g_{\\mathrm{SB}} + d - g_{\\mathrm{EBB}}) > 0$，根据给定值此假设成立（$3 + 2 - 1 = 4 > 0$），我们可以进行除法运算而不改变不等式的方向：\n$$P \\ge \\frac{d}{g_{\\mathrm{SB}} + d - g_{\\mathrm{EBB}}}$$\n\n这个不等式为何时优先选择形成超块提供了依据。如果踪迹概率 $P$ 大于或等于右侧的阈值，则优先选择超块。如果 $P$ 小于此阈值，则优先选择EBB。\n\n问题要求的是概率阈值 $P^{\\star}$，即两种策略产生相同预期收益的特定值。这是盈亏平衡点，通过将不等式设为等式来找到：\n$$P^{\\star} = \\frac{d}{g_{\\mathrm{SB}} + d - g_{\\mathrm{EBB}}}$$\n\n现在，我们将给定的数值代入这个推导出的公式中：\n$g_{\\mathrm{SB}} = 3$\n$d = 2$\n$g_{\\mathrm{EBB}} = 1$\n\n$$P^{\\star} = \\frac{2}{3 + 2 - 1} = \\frac{2}{4} = \\frac{1}{2}$$\n\n因此，如果踪迹的概率为 $0.5$ 或更大，则应形成超块。\n\n为了完整起见，我们可以计算候选踪迹 $T_1$ 和 $T_2$ 的概率 $P(T_1)$ 和 $P(T_2)$，以说明该阈值的应用。踪迹的概率是条件分支概率的乘积。当 $B_i$ 是沿进入 $B_j$ 的路径上 $B_j$ 的唯一前驱时，条件概率 $P(B_j|B_i)$ 可以计算为 $c_{B_j}/c_{B_i}$。问题陈述表明，所有相关分支都属于这种情况。\n\n对于踪迹 $T_1: B_0 \\rightarrow B_1 \\rightarrow B_3 \\rightarrow B_5$：\n该概率是从 $B_0$ 开始进入 $B_3$ 的可能性。由于在踪迹路径上 $B_1$ 是 $B_3$ 的唯一前驱，而 $B_0$ 是 $B_1$ 的唯一前驱，我们有：\n$$P(T_1) = P(B_1|B_0) \\times P(B_3|B_1) = \\frac{c_{B_1}}{c_{B_0}} \\times \\frac{c_{B_3}}{c_{B_1}} = \\frac{c_{B_3}}{c_{B_0}}$$\n$$P(T_1) = \\frac{6630}{12000} = 0.5525$$\n\n对于踪迹 $T_2: B_0 \\rightarrow B_2 \\rightarrow B_4 \\rightarrow B_5$：\n类似地，\n$$P(T_2) = P(B_2|B_0) \\times P(B_4|B_2) = \\frac{c_{B_2}}{c_{B_0}} \\times \\frac{c_{B_4}}{c_{B_2}} = \\frac{c_{B_4}}{c_{B_0}}$$\n$$P(T_2) = \\frac{3360}{12000} = 0.28$$\n\n将这些概率与我们推导出的阈值 $P^{\\star} = 0.5$ 进行比较：\n- 对于 $T_1$，$P(T_1) = 0.5525 > 0.5$，因此形成超块是合理的。\n- 对于 $T_2$，$P(T_2) = 0.28  0.5$，因此形成超块是不合理的；EBB 将是首选的优化方法。\n\n然而，问题只要求推导阈值 $P^{\\star}$ 本身及其值。\n阈值的最终推导表达式为 $P^{\\star} = \\frac{d}{g_{\\mathrm{SB}} + d - g_{\\mathrm{EBB}}}$。\n最终的数值答案是 $\\frac{1}{2}$。", "answer": "$$\n\\boxed{\\frac{1}{2}}\n$$", "id": "3673028"}, {"introduction": "决定了要构建一个超块或超大块之后，下一步就是执行“if-conversion”的转换过程。本练习聚焦于这一转换的核心算法：将控制依赖（control dependencies）转变为基于谓词（predicates）的数据依赖。通过处理一个嵌套的条件分支结构，你将学会如何系统性地推导出正确的布尔条件，用以守护原代码块中指令的执行。[@problem_id:3673048]", "problem": "一个用于谓词化指令集架构（ISA）的编译器试图通过if-conversion将控制流图（CFG）中的多个候选菱形结构合并成一个单一的超大块。给定一个结构化的控制流图（CFG），其基本块和边描述如下。存在一个入口块 $S$，它流向一个基于条件 $c_1$ 的条件分支，其真边指向块 $A$，假边指向块 $B$。从块 $A$ 出发，存在一个基于条件 $c_2$ 的条件分支，其真边指向块 $C$，假边指向块 $D$。从块 $B$ 出发，存在一个基于条件 $c_3$ 的条件分支，其真边指向块 $E$，假边指向块 $F$。$C, D, E, F$ 的所有控制流都汇入一个单一的汇合块 $J$，然后流向出口。假设所有块 $A, B, C, D, E, F$ 除了其内部计算外没有副作用，并且可以被安全地谓词化；同时假设在数据依赖和内存安全条件下，推测执行是合法的，并且汇合点 $J$ 后支配所有 $A, B, C, D, E, F$。\n\n仅使用控制依赖、支配/后支配的基本原则以及用于谓词执行的标准if-conversion语义（不假设任何专门的快捷公式），通过消除内部控制流并代之以谓词，形成一个包含块 $A, B, C, D, E, F$ 的单入口超大块。设入口谓词为 $1$ (真)。定义保护谓词 $p_A, p_B, p_C, p_D, p_E, p_F$，它们分别精确地指示在if-conversion之后，块 $A, B, C, D, E, F$ 中的指令何时被提交。令 $p_1, \\dots, p_6$ 按顺序对应于 $(p_A, p_B, p_C, p_D, p_E, p_F)$。\n\n此外，按如下方式构建由if-conversion过程导出的谓词依赖图：当且仅当 $p_Y$ 是通过在构造过程中沿某一个条件分支对 $p_X$ 进行精化而形成时（即，在由从 $S$ 出发的唯一简单路径上的求值条件序列所引起的精化中，$p_Y$ 是 $p_X$ 的直接子节点），存在一条有向边 $p_X \\to p_Y$。令 $d$ 为集合 $\\{p_A, p_B, p_C, p_D, p_E, p_F\\}$ 中此类有向边的总数。\n\n将最终答案以行矩阵 $\\big(p_1\\;p_2\\;p_3\\;p_4\\;p_5\\;p_6\\;d\\big)$ 的形式给出，其中每个 $p_i$ 必须是基于 $\\{c_1, c_2, c_3\\}$ 的、仅使用 $\\land$、$\\lor$ 和 $\\lnot$ 的简化布尔表达式，且 $d$ 是一个精确的整数。无需四舍五入。不要包含任何单位。", "solution": "该问题陈述已经过验证，被认为是编译器理论领域内一个定义良好、具有科学依据的问题。它提供了一个关于控制流图（CFG）的完整且一致的描述，并要求基于基本原则推导用于if-conversion的保护谓词，以及分析由此产生的谓词依赖图。\n\n任务是通过应用if-conversion，从给定的CFG结构中形成一个单一的超大块。这个过程将控制依赖转换为对谓词的数据依赖。一个基本块的保护谓词决定了该块内的指令结果是否会被提交。一个块的谓词为真，当且仅当原始程序中的控制流会到达该块。\n\n该CFG有一个入口块 $S$，引出一系列嵌套的条件分支。超大块区域的入口有效谓词为真，我们可以表示为 $p_{entry} = 1$。后续块的谓词是通过在CFG的支配树中，逐次精化其唯一前驱的谓词而得出的。\n\nCFG结构如下：\n1. 块 $S$ 基于条件 $c_1$ 进行分支。真路径通向块 $A$，假路径通向块 $B$。\n2. 块 $A$ 基于条件 $c_2$ 进行分支。真路径通向块 $C$，假路径通向块 $D$。\n3. 块 $B$ 基于条件 $c_3$ 进行分支。真路径通向块 $E$，假路径通向块 $F$。\n4. 块 $C$、$D$、$E$ 和 $F$ 都在一个单一的汇合块 $J$ 处合并。\n\n我们现在将为每个块 $A, B, C, D, E, F$ 推导保护谓词。它们被表示为 $p_A, p_B, p_C, p_D, p_E, p_F$，对应于 $p_1, \\dots, p_6$。\n\n1.  **块 $A$ 的谓词 ($p_1 = p_A$)：**\n    如果从 $S$ 出发的控制流采纳了基于 $c_1$ 的分支的真边，则执行块 $A$。该块入口点的谓词是 $1$。因此，执行 $A$ 的条件就是 $c_1$ 为真。\n    $$p_A = 1 \\land c_1 = c_1$$\n\n2.  **块 $B$ 的谓词 ($p_2 = p_B$)：**\n    如果从 $S$ 出发的控制流采纳了基于 $c_1$ 的分支的假边，则执行块 $B$。这意味着条件 $c_1$ 必须为假。\n    $$p_B = 1 \\land (\\lnot c_1) = \\lnot c_1$$\n\n3.  **块 $C$ 的谓词 ($p_3 = p_C$)：**\n    仅当控制流首先到达块 $A$，然后采纳了基于 $c_2$ 的分支的真边时，才执行块 $C$。到达 $C$ 的条件是到达其前驱 $A$ 的条件与从 $A$ 出发的分支条件的合取。\n    $$p_C = p_A \\land c_2 = c_1 \\land c_2$$\n\n4.  **块 $D$ 的谓词 ($p_4 = p_D$)：**\n    如果控制流到达块 $A$，然后采纳了基于 $c_2$ 的分支的假边，则执行块 $D$。这要求 $c_2$ 为假。\n    $$p_D = p_A \\land (\\lnot c_2) = c_1 \\land (\\lnot c_2)$$\n\n5.  **块 $E$ 的谓词 ($p_5 = p_E$)：**\n    如果控制流首先到达块 $B$，然后采纳了基于 $c_3$ 的分支的真边，则执行块 $E$。这要求 $c_3$ 为真。\n    $$p_E = p_B \\land c_3 = (\\lnot c_1) \\land c_3$$\n\n6.  **块 $F$ 的谓词 ($p_6 = p_F$)：**\n    如果控制流到达块 $B$，然后采纳了基于 $c_3$ 的分支的假边，则执行块 $F$。这要求 $c_3$ 为假。\n    $$p_F = p_B \\land (\\lnot c_3) = (\\lnot c_1) \\land (\\lnot c_3)$$\n\n因此，谓词如下：\n$p_1 = c_1$\n$p_2 = \\lnot c_1$\n$p_3 = c_1 \\land c_2$\n$p_4 = c_1 \\land (\\lnot c_2)$\n$p_5 = (\\lnot c_1) \\land c_3$\n$p_6 = (\\lnot c_1) \\land (\\lnot c_3)$\n\n接下来，我们必须构建谓词依赖图并找出边的数量 $d$。问题定义了一条有向边 $p_X \\to p_Y$ 存在，“当且仅当 $p_Y$ 是通过沿某一个条件分支对 $p_X$ 进行精化而形成的”。这对应于块 $Y$ 是块 $X$ 的直接控制流后继，并且 $p_Y = p_X \\land (\\text{分支条件})$ 的情况。我们被要求计算这样的边 $d$ 的数量，其中源谓词和目标谓词都在集合 $\\{p_A, p_B, p_C, p_D, p_E, p_F\\}$ 中。\n\n让我们检查这些精化关系的谓词推导：\n- $p_C = c_1 \\land c_2 = p_A \\land c_2$。因此，$p_C$ 是 $p_A$ 的一个精化。这产生了边 $p_A \\to p_C$。$p_A$ 和 $p_C$ 都在集合中。\n- $p_D = c_1 \\land (\\lnot c_2) = p_A \\land (\\lnot c_2)$。因此，$p_D$ 是 $p_A$ 的一个精化。这产生了边 $p_A \\to p_D$。$p_A$ 和 $p_D$ 都在集合中。\n- $p_E = (\\lnot c_1) \\land c_3 = p_B \\land c_3$。因此，$p_E$ 是 $p_B$ 的一个精化。这产生了边 $p_B \\to p_E$。$p_B$ 和 $p_E$ 都在集合中。\n- $p_F = (\\lnot c_1) \\land (\\lnot c_3) = p_B \\land (\\lnot c_3)$。因此，$p_F$ 是 $p_B$ 的一个精化。这产生了边 $p_B \\to p_F$。$p_B$ 和 $p_F$ 都在集合中。\n\n谓词 $p_A$ 和 $p_B$ 是初始谓词 $1$ 的精化，而初始谓词 $1$ 不在指定的集合中。集合 $\\{p_A, \\dots, p_F\\}$ 中没有其他谓词是另一个谓词的精化。例如，$p_C = c_1 \\land c_2$ 不是 $p_B = \\lnot c_1$ 的精化。\n\n限制在指定节点集合内的谓词依赖图具有以下四条边：\n1. $p_A \\to p_C$\n2. $p_A \\to p_D$\n3. $p_B \\to p_E$\n4. $p_B \\to p_F$\n\n因此，有向边的总数 $d$ 为 $4$。\n\n最终答案是行矩阵 $\\big(p_1\\;p_2\\;p_3\\;p_4\\;p_5\\;p_6\\;d\\big)$，它汇集了推导出的谓词和边的数量。", "answer": "$$ \\boxed{ \\begin{pmatrix} c_1  \\lnot c_1  c_1 \\land c_2  c_1 \\land (\\lnot c_2)  (\\lnot c_1) \\land c_3  (\\lnot c_1) \\land (\\lnot c_3)  4 \\end{pmatrix} } $$", "id": "3673048"}, {"introduction": "编译器的优化并非孤立存在，它们会深刻影响后续的处理阶段。本练习将探讨超块和超大块形成对寄存器分配这一关键阶段的下游影响。通过分析新形成的线性代码序列中变量的存活期（liveness），你将发现这种代码变换如何改变寄存器压力（register pressure），这是决定最终机器码性能的关键因素。[@problem_id:3672986]", "problem": "考虑编译器后端中的一个代码区域，该区域将通过沿热路径形成超块 (superblock)，然后通过 if-转换形成超大块 (hyperblock) 来进行优化。原始区域表示为一个控制流图 (CFG)，其中控制流图是一个有向图，其节点是基本块，边代表可能的控制转移。该代码对变量 $a$、$b$、$c$、$d$（假定为入口处的活跃输入）和临时变量 $t_1,\\dots,t_7$ 使用三地址操作。转换前的 CFG 由以下基本块组成：\n\n- 块 $B_0$：\n  - $t_1 \\leftarrow a + b$\n  - 如果谓词 $p$ 为真，则跳转到 $B_1$，否则跳转到 $B_2$。\n- 块 $B_1$：\n  - $t_2 \\leftarrow t_1 \\times c$\n  - 跳转到 $B_3$。\n- 块 $B_2$：\n  - $t_3 \\leftarrow t_1 + c$\n  - 跳转到 $B_3$。\n- 块 $B_3$：\n  - 根据 $p$ 将 $t_2$ 和 $t_3$ $\\phi$-合并到 $t_4$ 中\n  - 如果谓词 $q$ 为真，则跳转到 $B_4$，否则跳转到 $B_5$。\n- 块 $B_4$：\n  - $t_5 \\leftarrow t_4 + d$\n  - 跳转到 $B_6$。\n- 块 $B_5$：\n  - $t_6 \\leftarrow t_4 \\times d$\n  - 跳转到 $B_6$。\n- 块 $B_6$：\n  - $t_7 \\leftarrow t_5 + t_6$\n  - 返回 $t_7$。\n\n超块 (superblock) 是一个单入口、多出口的区域，通过选择一条热路径并执行尾部复制来消除侧向入口而构建。超大块 (hyperblock) 是一个谓词化的、经过if-转换的区域，它通过在谓词控制下推测执行操作并使用 select 操作合并值来消除内部控制流。在沿热路径 $B_0 \\rightarrow B_1 \\rightarrow B_3 \\rightarrow B_4 \\rightarrow B_6$ 形成超块 (superblock) 并对两个二元分支应用超大块 (hyperblock) if-转换（使得每个条件语句的两侧都在谓词控制下计算它们的值并用 select 操作合并）之后，超块中的代码变成一个带有谓词的单一直线序列：\n\n- 指令 1：$t_1 \\leftarrow a + b$。\n- 指令 2：$t_2 \\leftarrow t_1 \\times c$（由谓词 $p$ 控制）。\n- 指令 3：$t_3 \\leftarrow t_1 + c$（由谓词 $\\lnot p$ 控制）。\n- 指令 4：$t_4 \\leftarrow \\mathrm{select}(p, t_2, t_3)$。\n- 指令 5：$t_5 \\leftarrow t_4 + d$（由谓词 $q$ 控制）。\n- 指令 6：$t_6 \\leftarrow t_4 \\times d$（由谓词 $\\lnot q$ 控制）。\n- 指令 7：$t_7 \\leftarrow t_5 + t_6$。\n- 指令 8：返回 $t_7$。\n\n在转换后的区域中，假设如下：\n- 谓词 $p$ 和 $q$ 保存在一个单独的谓词寄存器文件中，不属于通用寄存器分配的一部分。\n- 对于活跃性分析，如果一个值在从某个程序点开始的某条路径上，在被重新定义之前可能被使用，那么它在该程序点是活跃的。谓词化定义保守地产生在后续合并中可能需要的值，因此 $t_2$ 和 $t_3$ 都被认为是 $\\mathrm{select}$ 操作所使用的，而 $t_5$ 和 $t_6$ 都被认为是最终的加法所使用的。\n- 干涉图 (IG) 为集合 $\\{a,b,c,d,t_1,t_2,t_3,t_4,t_5,t_6,t_7\\}$ 中的每个变量都有一个节点，如果对应的两个值在任何程序点上同时活跃，则一条边连接这两个节点。\n- 寄存器分配器对干涉图使用图着色算法，您必须确定在不发生溢出 (spilling) 的情况下分配所有这些值所需的最小通用寄存器数量。\n\n仅使用上述转换后的直线序列，首先更新由该超块 (superblock) 和超大块 (hyperblock) 形成所引起的活跃性信息和相应的干涉关系，然后确定在不发生溢出的情况下为 $\\{a,b,c,d,t_1,t_2,t_3,t_4,t_5,t_6,t_7\\}$ 中的所有值分配寄存器所需的最小通用寄存器数量。将您的答案表示为单个整数。无需四舍五入。不要包含任何单位。", "solution": "用户希望找到在给定的超大块 (hyperblock) 中为变量分配寄存器而不发生溢出所需的最小寄存器数。这个数字等价于代码的干涉图 $G$ 的色数，记为 $\\chi(G)$。\n\n问题指出，代码已被转换为一个谓词化指令的单一直线序列。这样一个块内变量的干涉图是一个区间图。对于任何区间图 $G$，其色数等于其最大团的大小，即 $\\omega(G)$。干涉图中的一个团对应于在某个程序点上同时活跃的一组变量。因此，任务简化为找到在程序中任何一个点上活跃的变量的最大数量。这也被称为最大寄存器压力。\n\n我们通过从块的末尾向后计算每条指令入口和出口处的活跃变量集来进行活跃性分析。设 $L_{in}(i)$ 和 $L_{out}(i)$ 分别是指令 $i$ 入口和出口处的活跃变量集。设 $\\mathrm{def}(i)$ 是指令 $i$ 定义（写入）的变量集，$\\mathrm{use}(i)$ 是指令 $i$ 使用（读取）的变量集。对于直线指令序列，我们有以下关系：\n$$L_{out}(i) = L_{in}(i+1)$$\n$$L_{in}(i) = (L_{out}(i) \\setminus \\mathrm{def}(i)) \\cup \\mathrm{use}(i)$$\n\n指令序列如下：\n1. $t_1 \\leftarrow a + b$\n2. $t_2 \\leftarrow t_1 \\times c$\n3. $t_3 \\leftarrow t_1 + c$\n4. $t_4 \\leftarrow \\mathrm{select}(p, t_2, t_3)$\n5. $t_5 \\leftarrow t_4 + d$\n6. $t_6 \\leftarrow t_4 \\times d$\n7. $t_7 \\leftarrow t_5 + t_6$\n8. return $t_7$\n\n我们进行向后分析：\n\n- **指令 8 (`return $t_7$`)**: 变量 $t_7$ 被使用。函数返回后，没有局部变量是活跃的。\n  - $L_{out}(8) = \\emptyset$\n  - $L_{in}(8) = (\\emptyset \\setminus \\emptyset) \\cup \\{t_7\\} = \\{t_7\\}$\n\n- **指令 7 (`$t_7 \\leftarrow t_5 + t_6$`)**:\n  - $L_{out}(7) = L_{in}(8) = \\{t_7\\}$\n  - $\\mathrm{def}(7) = \\{t_7\\}$, $\\mathrm{use}(7) = \\{t_5, t_6\\}$\n  - $L_{in}(7) = (\\{t_7\\} \\setminus \\{t_7\\}) \\cup \\{t_5, t_6\\} = \\{t_5, t_6\\}$\n\n- **指令 6 (`$t_6 \\leftarrow t_4 \\times d$`)**:\n  - $L_{out}(6) = L_{in}(7) = \\{t_5, t_6\\}$\n  - $\\mathrm{def}(6) = \\{t_6\\}$, $\\mathrm{use}(6) = \\{t_4, d\\}$\n  - $L_{in}(6) = (\\{t_5, t_6\\} \\setminus \\{t_6\\}) \\cup \\{t_4, d\\} = \\{t_4, t_5, d\\}$\n\n- **指令 5 (`$t_5 \\leftarrow t_4 + d$`)**:\n  - $L_{out}(5) = L_{in}(6) = \\{t_4, t_5, d\\}$\n  - $\\mathrm{def}(5) = \\{t_5\\}$, $\\mathrm{use}(5) = \\{t_4, d\\}$\n  - $L_{in}(5) = (\\{t_4, t_5, d\\} \\setminus \\{t_5\\}) \\cup \\{t_4, d\\} = \\{t_4, d\\}$\n\n- **指令 4 (`$t_4 \\leftarrow \\mathrm{select}(p, t_2, t_3)$`)**:\n  - $L_{out}(4) = L_{in}(5) = \\{t_4, d\\}$\n  - $\\mathrm{def}(4) = \\{t_4\\}$, $\\mathrm{use}(4) = \\{t_2, t_3\\}$\n  - $L_{in}(4) = (\\{t_4, d\\} \\setminus \\{t_4\\}) \\cup \\{t_2, t_3\\} = \\{d, t_2, t_3\\}$\n\n- **指令 3 (`$t_3 \\leftarrow t_1 + c$`)**:\n  - $L_{out}(3) = L_{in}(4) = \\{d, t_2, t_3\\}$\n  - $\\mathrm{def}(3) = \\{t_3\\}$, $\\mathrm{use}(3) = \\{t_1, c\\}$\n  - $L_{in}(3) = (\\{d, t_2, t_3\\} \\setminus \\{t_3\\}) \\cup \\{t_1, c\\} = \\{d, t_1, t_2, c\\}$\n\n- **指令 2 (`$t_2 \\leftarrow t_1 \\times c$`)**:\n  - $L_{out}(2) = L_{in}(3) = \\{d, t_1, t_2, c\\}$\n  - $\\mathrm{def}(2) = \\{t_2\\}$, $\\mathrm{use}(2) = \\{t_1, c\\}$\n  - $L_{in}(2) = (\\{d, t_1, t_2, c\\} \\setminus \\{t_2\\}) \\cup \\{t_1, c\\} = \\{d, t_1, c\\}$\n\n- **指令 1 (`$t_1 \\leftarrow a + b$`)**:\n  - $L_{out}(1) = L_{in}(2) = \\{d, t_1, c\\}$\n  - $\\mathrm{def}(1) = \\{t_1\\}$, $\\mathrm{use}(1) = \\{a, b\\}$\n  - $L_{in}(1) = (\\{d, t_1, c\\} \\setminus \\{t_1\\}) \\cup \\{a, b\\} = \\{a, b, c, d\\}$\n\n每条指令入口处的活跃变量集如下：\n- $L_{in}(1) = \\{a, b, c, d\\}$, 大小为 $4$\n- $L_{in}(2) = \\{t_1, c, d\\}$, 大小为 $3$\n- $L_{in}(3) = \\{t_1, t_2, c, d\\}$, 大小为 $4$\n- $L_{in}(4) = \\{t_2, t_3, d\\}$, 大小为 $3$\n- $L_{in}(5) = \\{t_4, d\\}$, 大小为 $2$\n- $L_{in}(6) = \\{t_4, t_5, d\\}$, 大小为 $3$\n- $L_{in}(7) = \\{t_5, t_6\\}$, 大小为 $2$\n- $L_{in}(8) = \\{t_7\\}$, 大小为 $1$\n\n在任何程序点（即任何 $L_{in}(i)$ 或 $L_{out}(i)$）的所有活跃集中的最大大小决定了最大团的大小，即 $\\omega(G)$。观察到的最大大小为 4。这发生在指令 1 的入口处（活跃集 $\\{a, b, c, d\\}$）和指令 3 的入口处（活跃集 $\\{t_1, t_2, c, d\\}$）。\n\n因此，最大团的大小为 $\\omega(G) = 4$。对于区间图，色数等于团数，所以 $\\chi(G) = \\omega(G) = 4$。这意味着为图着色最少需要 4 个寄存器，这对应于在不发生溢出的情况下为变量分配寄存器。", "answer": "$$\n\\boxed{4}\n$$", "id": "3672986"}]}