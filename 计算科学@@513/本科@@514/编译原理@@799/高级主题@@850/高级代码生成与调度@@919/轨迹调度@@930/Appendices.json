{"hands_on_practices": [{"introduction": "路径调度（Trace Scheduling）的第一步是识别“热路径”——即最可能的执行路径。编译器并非凭空猜测，而是使用基于性能剖析数据的量化启发式方法。本练习 [@problem_id:3676420] 将引导你推导一个常见的评分函数，该函数权衡了优化路径的潜在收益与处理离线（off-trace）执行的成本，从而使编译器能够做出明智的决策。", "problem": "轨迹调度（Trace scheduling）是一种编译技术，它在控制流图（CFG）中选择一条高概率路径（一条轨迹），并应用推测性代码移动来优化该路径，同时用恢复代码补偿非轨迹执行。考虑CFG中的一条边，可以在其上推测性地应用优化。设该边的动态执行概率为 $p$，若在该边上实现优化，估计的周期节省为 $b$（收益），若推测失败，补偿的估计周期开销为 $c$（成本）。假设以下原则成立：\n- 在单条边上进行推测性优化的观察性能影响被建模为一个随机变量，如果该边被执行，其值为 $b$；如果该边未被执行，其值为 $-c$。\n- 预期性能影响是在边执行概率 $p$下的平均值。\n- 在性能影响相互独立的假设下，轨迹内不同边的分数可加性地聚合。\n- 评分函数 $w(p,b,c)$ 对 $b$ 和 $c$ 都是线性的，对 $b$ 严格递增，对 $c$ 严格递减，并满足归一化约束 $w(1,b,0)=b$ 和 $w(0,0,c)=-c$。\n\n任务1：仅使用上述原则和概率论中的期望定义，推导边评分函数 $w(p,b,c)$ 的闭式解析表达式。\n\n任务2：应用您推导的评分函数，在以下CFG中选择主轨迹。该CFG有一个起始节点 $S$，其有两个分支，通向两条在节点 $D$ 重新汇合的不同路径。两个候选轨迹是：\n- 轨迹 $T_1$: $S \\rightarrow B_1 \\rightarrow C \\rightarrow D$\n- 轨迹 $T_2$: $S \\rightarrow B_2 \\rightarrow E \\rightarrow D$\n\n对于每条边，都提供了剖析执行概率 $p$、收益 $b$（以周期为单位）和成本 $c$（以周期为单位）：\n- 边 $e_1: S \\rightarrow B_1$: $p=0.7$, $b=8$, $c=3$\n- 边 $e_2: B_1 \\rightarrow C$: $p=0.9$, $b=5$, $c=2$\n- 边 $e_3: C \\rightarrow D$: $p=0.95$, $b=4$, $c=4$\n- 边 $e_4: S \\rightarrow B_2$: $p=0.3$, $b=12$, $c=9$\n- 边 $e_5: B_2 \\rightarrow E$: $p=0.8$, $b=6$, $c=1$\n- 边 $e_6: E \\rightarrow D$: $p=0.85$, $b=3$, $c=5$\n\n通过对轨迹上的边分数求和来计算每条轨迹的总分，并选择总分较高的轨迹作为主轨迹。报告所选轨迹的总分。以周期为单位表示您的答案。无需四舍五入。", "solution": "该问题被评估为有效，因为它在编译器理论中有科学依据，问题定义良好、客观且自洽。所有必要信息均已提供，且前提与轨迹选择的标准启发式模型一致。\n\n**第1部分：边评分函数的推导**\n\n问题要求基于一组源于概率论的原则来推导边评分函数 $w(p, b, c)$。\n\n第一个原则指出，在单条边上进行推测性优化的性能影响是一个随机变量，我们称之为 $X$。这个随机变量可以取两个值：\n1.  如果优化成功，即边被执行，则获得 $b$ 个周期的收益。此事件的概率为 $p$。\n2.  如果优化不成功（即推测失败），即边未被执行，则产生 $c$ 个周期的成本（表示为负收益 $-c$）。因此，此事件的概率为 $1-p$。\n\n第二个原则指出，评分函数 $w(p, b, c)$ 是预期的性能影响。离散随机变量的期望值是每个可能值与其概率乘积的总和。将此定义应用于随机变量 $X$：\n$$\nE[X] = \\sum_{i} x_i P(X=x_i)\n$$\n在我们的例子中，值为 $b$ 和 $-c$，概率分别为 $p$ 和 $1-p$。\n$$\nw(p, b, c) = E[X] = (b \\cdot p) + ((-c) \\cdot (1-p))\n$$\n简化此表达式，得到评分函数的闭式解析表达式：\n$$\nw(p, b, c) = bp - c(1-p)\n$$\n我们必须根据问题中陈述的其余原则来验证这个推导出的函数。\n- **线性**：函数 $w(p, b, c) = p \\cdot b + (p-1) \\cdot c$ 是 $b$ 和 $c$ 的线性函数。此条件满足。\n- **单调性**：为了检查它是否对 $b$ 严格递增，我们对 $b$ 求偏导数：\n$$\n\\frac{\\partial w}{\\partial b} = p\n$$\n因为 $p$ 是一个概率，所以 $0 \\le p \\le 1$。对于任何有非零执行概率的边（$p>0$），该函数对 $b$ 是严格递增的。\n为了检查它是否对 $c$ 严格递减，我们对 $c$ 求偏导数：\n$$\n\\frac{\\partial w}{\\partial c} = -(1-p) = p-1\n$$\n因为 $p \\le 1$，所以 $p-1 \\le 0$。对于任何推测可能失败的边（$p < 1$），该函数对 $c$ 是严格递减的。两个单调性条件在非平凡情况下都得到满足。\n- **归一化**：我们检查两个归一化约束：\n$$\nw(1, b, 0) = b \\cdot 1 - 0 \\cdot (1-1) = b\n$$\n$$\nw(0, 0, c) = 0 \\cdot 0 - c \\cdot (1-0) = -c\n$$\n两个约束都满足。推导出的函数 $w(p,b,c) = bp - c(1-p)$ 是正确的。\n\n**第2部分：应用于控制流图**\n\n第三个原则指出，一条轨迹的总分是其构成边分数的总和。我们现在将把推导出的评分函数应用于两个候选轨迹 $T_1$ 和 $T_2$ 中的每条边。\n\n**轨迹 $T_1$：$S \\rightarrow B_1 \\rightarrow C \\rightarrow D$**\n该轨迹由边 $e_1$、$e_2$ 和 $e_3$ 组成。\n\n- **边 $e_1: S \\rightarrow B_1$**：$p_1=0.7$, $b_1=8$, $c_1=3$。\n$$\nw_1 = b_1 p_1 - c_1(1-p_1) = 8(0.7) - 3(1-0.7) = 5.6 - 3(0.3) = 5.6 - 0.9 = 4.7\n$$\n- **边 $e_2: B_1 \\rightarrow C$**：$p_2=0.9$, $b_2=5$, $c_2=2$。\n$$\nw_2 = b_2 p_2 - c_2(1-p_2) = 5(0.9) - 2(1-0.9) = 4.5 - 2(0.1) = 4.5 - 0.2 = 4.3\n$$\n- **边 $e_3: C \\rightarrow D$**：$p_3=0.95$, $b_3=4$, $c_3=4$。\n$$\nw_3 = b_3 p_3 - c_3(1-p_3) = 4(0.95) - 4(1-0.95) = 3.8 - 4(0.05) = 3.8 - 0.2 = 3.6\n$$\n\n轨迹 $T_1$ 的总分是各边分数的总和：\n$$\n\\text{Score}(T_1) = w_1 + w_2 + w_3 = 4.7 + 4.3 + 3.6 = 12.6\n$$\n\n**轨迹 $T_2$：$S \\rightarrow B_2 \\rightarrow E \\rightarrow D$**\n该轨迹由边 $e_4$、$e_5$ 和 $e_6$ 组成。\n\n- **边 $e_4: S \\rightarrow B_2$**：$p_4=0.3$, $b_4=12$, $c_4=9$。\n$$\nw_4 = b_4 p_4 - c_4(1-p_4) = 12(0.3) - 9(1-0.3) = 3.6 - 9(0.7) = 3.6 - 6.3 = -2.7\n$$\n- **边 $e_5: B_2 \\rightarrow E$**：$p_5=0.8$, $b_5=6$, $c_5=1$。\n$$\nw_5 = b_5 p_5 - c_5(1-p_5) = 6(0.8) - 1(1-0.8) = 4.8 - 1(0.2) = 4.8 - 0.2 = 4.6\n$$\n- **边 $e_6: E \\rightarrow D$**：$p_6=0.85$, $b_6=3$, $c_6=5$。\n$$\nw_6 = b_6 p_6 - c_6(1-p_6) = 3(0.85) - 5(1-0.85) = 2.55 - 5(0.15) = 2.55 - 0.75 = 1.8\n$$\n\n轨迹 $T_2$ 的总分是这些分数的总和：\n$$\n\\text{Score}(T_2) = w_4 + w_5 + w_6 = -2.7 + 4.6 + 1.8 = 3.7\n$$\n\n**结论**\n\n为了选择主轨迹，我们比较总分：\n$\\text{Score}(T_1) = 12.6$\n$\\text{Score}(T_2) = 3.7$\n\n因为 $12.6 > 3.7$，所以轨迹 $T_1$ 得分更高，被选为主轨迹。题目要求报告所选轨迹的总分。\n所选轨迹 $T_1$ 的总分是 $12.6$ 个周期。", "answer": "$$\n\\boxed{12.6}\n$$", "id": "3676420"}, {"introduction": "一旦选定并优化了一条路径，其整体性能影响取决于程序实际停留在这条“快速通道”上的频率。本练习 [@problem_id:3676416] 使用基础概率论来为预期的执行时间建立模型。通过计算性能对在线（on-trace）概率的敏感性，你将深入理解准确的分支预测和性能剖析数据对于路径调度的有效性是多么关键。", "problem": "一个采用迹调度（trace scheduling）的编译器必须对停留在热迹（hot trace）上与退出到迹外（off-trace）补偿代码的性能影响进行建模。考虑在一个超长指令字（VLIW）处理器上选择并调度了一条热迹，程序的一次迭代或者以概率 $p$ 停留在已调度的迹上，或者以概率 $1-p$ 退出该迹。设随机变量 $T$ 表示执行一次此类迭代的延迟（以周期为单位）。假设在停留在迹上的条件下，延迟为常数 $T_{\\text{trace}}$ 个周期；在退出到迹外的条件下，延迟为常数 $T_{\\text{off}}$ 个周期。\n\n从基础概率论出发，特别是利用针对离散结果划分的全期望定律，推导出期望延迟 $E[T]$ 作为 $p$、$T_{\\text{trace}}$ 和 $T_{\\text{off}}$ 的函数。然后，将期望延迟对在迹概率的灵敏度定义为 $S(p) = \\frac{d}{dp}E[T]$，并计算 $S(p)$ 在基准概率 $p_0$ 处的值。\n\n对于一个具体实例，其中 $T_{\\text{trace}} = 12$ 个周期，$T_{\\text{off}} = 33$ 个周期，以及基准 $p_0 = 0.78$，确定 $S(p_0)$ 的数值。将最终的灵敏度以“周期/单位概率”为单位表示为一个实数。无需四舍五入。", "solution": "首先验证问题以确保其具有科学依据、提法正确且客观。\n\n### 步骤1：提取已知条件\n- 一次迭代停留在已调度迹上的概率是 $p$。\n- 一次迭代退出该迹的概率是 $1-p$。\n- $T$ 是执行一次迭代的延迟（以周期为单位）的随机变量。\n- 在停留在迹上的条件下，延迟为常数 $T_{\\text{trace}}$。\n- 在退出到迹外的条件下，延迟为常数 $T_{\\text{off}}$。\n- 期望延迟的灵敏度定义为 $S(p) = \\frac{d}{dp}E[T]$。\n- 一个具体实例提供了数值：$T_{\\text{trace}} = 12$ 个周期，$T_{\\text{off}} = 33$ 个周期，以及基准在迹概率 $p_0 = 0.78$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题是初等概率论的一个直接应用，用于对编译器设计和计算机体系结构中一个常见的性能权衡进行建模。\n- **有科学依据：** 问题使用了全期望定律，这是概率论的一个基本原理。该迹调度性能模型虽然经过简化，但在概念上是合理的，并反映了现实世界中的工程考虑。\n- **提法正确：** 所有必要的变量、常数和关系都已定义，可以得出一个唯一且有意义的解。问题结构清晰。\n- **客观性：** 问题以精确的技术语言表述，没有主观性或歧义。\n\n### 步骤3：结论与行动\n该问题被认为是**有效的**。将按要求推导解答。\n\n### 期望延迟 $E[T]$ 的推导\n该问题要求使用全期望定律推导期望延迟 $E[T]$。让我们为单次迭代定义一个事件空间的划分。设 $A$ 为执行停留在热迹上的事件，设 $B$ 为执行退出到迹外补偿代码的事件。这两个事件构成了样本空间的一个划分。\n\n这些事件的概率给定如下：\n$P(A) = p$\n$P(B) = 1 - p$\n\n问题陈述，在给定事件的条件下，延迟是一个常数值。\n- 如果事件 $A$ 发生（在迹上），延迟为 $T_{\\text{trace}}$。条件期望为 $E[T | A] = T_{\\text{trace}}$。\n- 如果事件 $B$ 发生（在迹外），延迟为 $T_{\\text{off}}$。条件期望为 $E[T | B] = T_{\\text{off}}$。\n\n全期望定律表明，对于样本空间的一个划分 $\\{A_i\\}$，随机变量 $T$ 的期望值为 $E[T] = \\sum_i E[T | A_i] P(A_i)$。将此定律应用于我们的划分 $\\{A, B\\}$：\n$$E[T] = E[T | A] P(A) + E[T | B] P(B)$$\n代入给定的概率和条件期望，我们得到：\n$$E[T] = T_{\\text{trace}} \\cdot p + T_{\\text{off}} \\cdot (1 - p)$$\n这个表达式可以重新整理，以突出其对 $p$ 的依赖关系：\n$$E[T] = p T_{\\text{trace}} + T_{\\text{off}} - p T_{\\text{off}}$$\n$$E[T] = p (T_{\\text{trace}} - T_{\\text{off}}) + T_{\\text{off}}$$\n这就是期望延迟作为 $p$、$T_{\\text{trace}}$ 和 $T_{\\text{off}}$ 的函数。\n\n### 灵敏度 $S(p)$ 的计算\n灵敏度 $S(p)$ 定义为期望延迟对在迹概率 $p$ 的导数：\n$$S(p) = \\frac{d}{dp}E[T]$$\n我们对 $E[T]$ 的表达式关于 $p$ 求导：\n$$S(p) = \\frac{d}{dp} \\left[ p (T_{\\text{trace}} - T_{\\text{off}}) + T_{\\text{off}} \\right]$$\n由于 $T_{\\text{trace}}$ 和 $T_{\\text{off}}$ 是常数，项 $(T_{\\text{trace}} - T_{\\text{off}})$ 是 $p$ 的常数系数，而项 $T_{\\text{off}}$ 是一个常数。常数的导数为零。\n$$S(p) = (T_{\\text{trace}} - T_{\\text{off}}) \\cdot \\frac{d}{dp}(p) + \\frac{d}{dp}(T_{\\text{off}})$$\n$$S(p) = (T_{\\text{trace}} - T_{\\text{off}}) \\cdot 1 + 0$$\n$$S(p) = T_{\\text{trace}} - T_{\\text{off}}$$\n灵敏度 $S(p)$ 是一个常数，与 $p$ 的值无关。因此，在基准概率 $p_0$ 处计算的灵敏度也是 $T_{\\text{trace}} - T_{\\text{off}}$。\n$$S(p_0) = T_{\\text{trace}} - T_{\\text{off}}$$\n\n### 数值计算\n给定的具体值为 $T_{\\text{trace}} = 12$，$T_{\\text{off}} = 33$，以及 $p_0 = 0.78$。\n将这些值代入 $S(p_0)$ 的表达式中：\n$$S(p_0) = 12 - 33$$\n$$S(p_0) = -21$$\n结果 $-21$ 表示在迹概率 $p$ 每增加一个单位时，期望延迟（以周期为单位）的变化量。负号表示，随着停留在（更快的）迹上的概率增加，总体期望延迟会减少，这是一个逻辑上一致的结果，因为 $T_{\\text{trace}}  T_{\\text{off}}$。", "answer": "$$\\boxed{-21}$$", "id": "3676416"}, {"introduction": "路径调度的加速效果来自于它对指令的大胆重排，即使在编译时无法保证这些指令是相互独立的。本练习 [@problem_id:3676434] 深入探讨了保障这种操作安全的核心机制：带有运行时检查和恢复功能的推测执行。你将为一个充满挑战的场景设计解决方案，即将一次内存读取操作提升到一次内存写入操作之前，同时处理潜在的内存别名问题，并创建必要的补偿代码以确保程序的正确性。", "problem": "在踪迹调度（trace scheduling）中，编译器选择一条可能的路径（即踪迹），并执行激进的、有时是推测性的代码移动，前提是必须保持程序的语义。推理的一个基本依据是依赖模型：对两个内存操作的重排序是合法的，当且仅当它不违反由别名（aliasing）引起的数据依赖。具体来说，对于一个写入字节地址区间 $[P, P + w_s - 1]$ 的存储操作和一个从 $[Q, Q + w_l - 1]$ 读取的加载操作（其中 $P, Q$ 是整数地址，$w_s, w_l$ 是以字节为单位的访问宽度），将加载操作移动到存储操作之前的重排序在语义上是安全的，当且仅当这两个区间不相交，即当且仅当 $[P, P + w_s - 1] \\cap [Q, Q + w_l - 1] = \\emptyset$。当编译时别名分析无法证明不存在别名关系时，可以通过插入运行时检查（RC）和恢复代码来确保推测性移动的正确性。\n\n考虑以下中间表示（三地址形式，仅对标量采用静态单赋值（SSA）形式），其中内存是字节可寻址的，访问可能未对齐。所有地址都是有效的（不会引发故障），且所有内存操作都是顺序一致的。访问大小为 $w_s = 4$ 字节和 $w_l = 4$ 字节。设热踪迹为 $\\text{B0} \\rightarrow \\text{B1} \\rightarrow \\text{B2} \\rightarrow \\text{B4}$。\n\n- $\\text{B0}$ 块：\n  - 1: $t_0 \\leftarrow g(x)$\n  - 2: $\\text{goto B1}$\n\n- $\\text{B1}$ 块：\n  - 3: $*p \\leftarrow h(t_0)$\n  - 4: $\\text{if } c \\text{ then goto B2 else goto B3}$\n\n- $\\text{B2}$ 块 (踪迹上)：\n  - 5: $v \\leftarrow *q$\n  - 6: $y_1 \\leftarrow v + k$\n  - 7: $\\text{goto B4}$\n\n- $\\text{B3}$ 块 (踪迹外)：\n  - 8: $y_2 \\leftarrow y_0 + k$\n  - 9: $\\text{goto B4}$\n\n- $\\text{B4}$ 块：\n  - 10: $y \\leftarrow \\phi(y_1, y_2)$\n\n此处 $p, q$ 是地址值变量，$k$ 是一个标量，$g(\\cdot), h(\\cdot)$ 是无副作用的算术函数。指令 3 的存储操作向地址区间 $[P, P + 3]$ 写入 $w_s = 4$ 字节，其中 $P$ 是 $p$ 的整数值。指令 5 的加载操作从 $[Q, Q + 3]$ 读取 $w_l = 4$ 字节，其中 $Q$ 是 $q$ 的整数值。编译时别名分析产生别名不确定性 $U$，意味着它无法证明在热踪迹上 $[P, P + 3] \\cap [Q, Q + 3] = \\emptyset$。\n\n你的任务是从以下选项中选择一个合法的踪迹调度方案，该方案在热踪迹上将指令 $5$ 的加载操作提升到指令 $3$ 的存储操作之前，并包含一套正确且充分的运行时检查（RC）来验证此推测，以及一个在检查失败时能在所有执行流上保持原始语义的恢复路径大纲。运行时检查应使用关于 $P, Q, w_s, w_l$ 的整数地址比较来表示，并且在给定的假设（字节可寻址内存，可能未对齊的 $4$ 字节访问）下必须是正确的。恢复机制必须确保，在 RC 失败时，可观察到的效果与执行原始程序时相同。\n\n哪个选项是正确的？\n\nA. 调度方案：在 $\\text{B1}$ 中，在新指令 $3'$ 处插入 RC：计算 $P \\leftarrow \\operatorname{uaddr}(p)$ 和 $Q \\leftarrow \\operatorname{uaddr}(q)$，然后测试 $((P + w_s \\le Q) \\lor (Q + w_l \\le P))$。如果 RC 通过，执行新指令 $4'$: $v_{\\text{hoist}} \\leftarrow *$ $q$，然后执行原始指令 $3$: $*$ $p \\leftarrow h(t_0)$，接着是原始分支指令 $4$。在 $\\text{B2}$ 中，用 $5'$: $v \\leftarrow v_{\\text{hoist}}$ 替换 $5$。插入一个恢复块 $\\text{R}$，其大纲如下：在 $3'$ 处的 RC 失败时，跳转到 $\\text{R}$，该块执行原始指令 $3$（存储操作），然后按程序顺序执行原始的控制流和使用点：如果 $c$ 为真，则执行 $v \\leftarrow *$ $q$ 和 $y_1 \\leftarrow v + k$ 并跳转到 $\\text{B4}$；否则，执行 $y_2 \\leftarrow y_0 + k$ 并跳转到 $\\text{B4}$。无其他更改。此处 $\\operatorname{uaddr}(\\cdot)$ 表示指针的无符号整数地址。\n\nB. 调度方案：将指令 $5$ 移动到 $\\text{B0}$ 的末尾（在 $\\text{B1}$ 中的任何代码之前），不加 RC，理由是使用不同 SSA 名称的加载和存储操作可以交换顺序。在 $\\text{B2}$ 中，用提升后的值替换指令 $5$ 的结果。无需恢复，因为加载操作没有副作用。\n\nC. 调度方案：将指令 $5$ 提升到 $\\text{B1}$ 中指令 $3$ 的紧邻位置之前，并插入 RC 测试 $(P \\neq Q)$。如果 RC 通过，则在 $\\text{B2}$ 中使用提升后的值；如果 RC 失败，则顺序执行指令 $3$ 及之后如原始代码一样的部分。不需要单独的恢复块。\n\nD. 调度方案：将指令 $5$ 保持在指令 $3$ 之后，但将其从 $\\text{B2}$ 移动到 $\\text{B1}$ 中分支指令 $4$ 的后面，以便在不知道 $c$ 的值之前执行加载操作。插入 RC 测试 $((P + w_s  Q) \\lor (Q + w_l  P))$。如果 RC 失败，先执行指令 $3$，然后再次执行指令 $5$ 以确保获取最新的值。无需额外恢复，因为加载操作仍在存储操作之后。", "solution": "用户需要找出在踪迹调度中进行推测性代码移动的正确实现方法。具体任务是将一个加载指令在热踪迹上提升到一个存储指令之前，这需要一个运行时检查（RC）和一条恢复路径，以在推测不安全时保持程序语义。\n\n首先，我们确立指导此转换的基本原则。\n程序在 $\\text{B1}$ 块中包含一条存储指令 `$3$: $*p \\leftarrow h(t_0)$`，在 $\\text{B2}$ 块中包含一条加载指令 `$5$: v \\leftarrow *q$`。热踪迹是 $\\text{B0} \\rightarrow \\text{B1} \\rightarrow \\text{B2} \\rightarrow \\text{B4}$。目标是将指令 `$5$` 处的加载操作移动到指令 `$3$` 处的存储操作之前的位置。\n\n存储操作向内存区间 $I_s = [P, P + w_s - 1] = [P, P + 3]$ 写入 `$w_s = 4$` 字节，其中 `$P$` 是指针 `$p$` 中地址的整数值。加载操作从内存区间 $I_l = [Q, Q + w_l - 1] = [Q, Q + 3]$ 读取 `$w_l = 4$` 字节，其中 `$Q$` 是指针 `$q$` 中地址的整数值。\n\n在热踪迹上的原始程序顺序中，加载在存储之后执行。如果内存区间 $I_s$ 和 $I_l$ 重叠，加载操作可能会读取由该存储操作写入的值。这构成了一个真数据依赖，也称为写后读（RAW）依赖。\n\n将加载操作提升到存储操作之前执行，意味着加载操作会在存储有机会更新内存值*之前*读取该值。如果区间 $I_s$ 和 $I_l$ 重叠，这种重排序会改变加载操作读取的值，从而违反程序语义。只有当这两个区间不重叠时，重排序才是合法的。\n\n问题陈述中指出，编译时别名分析无法证明指针 `$p$` 和 `$q$` 不会别名。因此，需要进行推测性执行。加载操作被激进地移动，并插入一个运行时检查（RC）以在执行时验证此推测的安全性。\n\n安全重排序的条件是内存区间不相交，如问题所述：$I_s \\cap I_l = \\emptyset$。对于两个区间 $[a, b]$ 和 $[c, d]$，它们不相交的条件是当且仅当一个区间在另一个区间开始之前结束。将此应用于我们的内存访问，条件是：\n$$(P + w_s - 1  Q) \\lor (Q + w_l - 1  P)$$\n由于内存地址是整数，严格不等式 `$a  b$` 等价于 `$a + 1 \\le b$`。因此，条件可以重写为：\n$$(P + w_s \\le Q) \\lor (Q + w_l \\le P)$$\n给定 `$w_s = 4$` 和 `$w_l = 4$`，正确的运行时检查是：\n$$((P + 4 \\le Q) \\lor (Q + 4 \\le P))$$\n这是 RC 必须测试的条件。如果它的计算结果为真，则推测是安全的，程序可以继续使用推测性加载的值。\n\n如果 RC 失败，则意味着内存区间可能重叠 ($I_s \\cap I_l \\neq \\emptyset$)。为保持原始程序语义，执行必须恢复到原始的、非推测性的顺序。这就是恢复代码的目的。恢复路径必须确保：\n1.  存储操作（`$*p \\leftarrow \\dots$`）被执行。\n2.  原始的控制流（条件分支 `if $c$`）被执行。\n3.  如果原始路径是到 $\\text{B2}$（即 `$c$` 为真），加载操作（`$v \\leftarrow *q$`）在存储操作*之后*执行，并且后续的计算（`$y_1 \\leftarrow v + k$`）被执行。\n4.  如果原始路径是到 $\\text{B3}$（即 `$c$` 为假），$\\text{B3}$ 中的代码正常执行。\n\n最后，我们考虑控制推测。加载操作从一个条件执行块（$\\text{B2}$）被移动到踪迹上的一个无条件执行块（$\\text{B1}$）。这是安全的，因为问题陈述所有内存访问都是有效的（不会引发故障）。\n\n在确立了这些原则之后，我们评估每个选项。\n\n**A. 调度方案：在 $\\text{B1}$ 中，在新指令 $3'$ 处插入 RC：计算 $P \\leftarrow \\operatorname{uaddr}(p)$ 和 $Q \\leftarrow \\operatorname{uaddr}(q)$，然后测试 $((P + w_s \\le Q) \\lor (Q + w_l \\le P))$。如果 RC 通过，执行新指令 $4'$: $v_{\\text{hoist}} \\leftarrow *$ $q$，然后执行原始指令 $3$: $*$ $p \\leftarrow h(t_0)$，接着是原始分支指令 $4$。在 $\\text{B2}$ 中，用 $5'$: $v \\leftarrow v_{\\text{hoist}}$ 替换 $5$。插入一个恢复块 $\\text{R}$，其大纲如下：在 $3'$ 处的 RC 失败时，跳转到 $\\text{R}$，该块执行原始指令 $3$（存储操作），然后按程序顺序执行原始的控制流和使用点：如果 $c$ 为真，则执行 $v \\leftarrow *$ $q$ 和 $y_1 \\leftarrow v + k$ 并跳转到 $\\text{B4}$；否则，执行 $y_2 \\leftarrow y_0 + k$ 并跳转到 $\\text{B4}$。无其他更改。此处 $\\operatorname{uaddr}(\\cdot)$ 表示指针的无符号整数地址。**\n\n*   **运行时检查**：RC 被指定为 `$((P + w_s \\le Q) \\lor (Q + w_l \\le P))$`。这与我们推导出的不相交区间的正确条件完全匹配。\n*   **推测路径（RC 通过）**：代码将加载操作（`$v_{\\text{hoist}} \\leftarrow *q$`）提升到存储操作（`$*p \\leftarrow h(t_0)$`）之前。在块 $\\text{B2}$ 中，使用了提升后的加载结果。这正确地实现了推测性调度。\n*   **恢复路径（RC 失败）**：失败时，跳转到一个恢复块 $\\text{R}$。该块首先执行存储操作（`$*p \\leftarrow h(t_0)$`）。然后，它通过检查 `$c$` 并执行来自块 $\\text{B2}$ 或 $\\text{B3}$ 的相应代码，正确地重建了原始程序的控制流。这忠实地恢复了存储操作之后所有可能控制流的原始程序语义。\n\n此选项提供了一个完全正确且稳健的推测性加载提升实现，包括正确的 RC 和全面的恢复机制。\n\n**结论：正确**\n\n**B. 调度方案：将指令 $5$ 移动到 $\\text{B0}$ 的末尾（在 $\\text{B1}$ 中的任何代码之前），不加 RC，理由是使用不同 SSA 名称的加载和存储操作可以交换顺序。在 $\\text{B2}$ 中，用提升后的值替换指令 $5$ 的结果。无需恢复，因为加载操作没有副作用。**\n\n所提供的理由存在根本性缺陷。静态单赋值（SSA）形式适用于标量值（寄存器或变量），而不适用于通过指针访问的内存位置。指针 `$p$` 和 `$q$` 是不同的 SSA 变量这一事实，并不能提供任何关于它们所指向内存的信息。它们可能是别名，指向相同或重叠的内存区域。在没有运行时检查的情况下重排序一个可能别名的加载和存储操作，违反了数据依赖，在语义上是不正确的。\n\n**结论：不正确**\n\n**C. 调度方案：将指令 $5$ 提升到 $\\text{B1}$ 中指令 $3$ 的紧邻位置之前，并插入 RC 测试 $(P \\neq Q)$。如果 RC 通过，则在 $\\text{B2}$ 中使用提升后的值；如果 RC 失败，则顺序执行指令 $3$ 及之后如原始代码一样的部分。不需要单独的恢复块。**\n\n提议的运行时检查 `$P \\neq Q$` 是不充分的。内存访问宽度为 `$4$` 字节（`$w_s=4, w_l=4$`），且可能未对齐。例如，如果 `$P = 100$` 和 `$Q = 101$`，那么 `$P \\neq Q$`，但存储区间 $[100, 103]$ 和加载区间 $[101, 104]$ 重叠。在存储之前执行加载将是一个错误。检查必须考虑访问宽度，而这个检查没有做到。对恢复的描述也比选项 A 模糊和不完整。\n\n**结论：不正确**\n\n**D. 调度方案：将指令 $5$ 保持在指令 $3$ 之后，但将其从 $\\text{B2}$ 移动到 $\\text{B1}$ 中分支指令 $4$ 的后面，以便在不知道 $c$ 的值之前执行加载操作。插入 RC 测试 $((P + w_s  Q) \\lor (Q + w_l  P))$。如果 RC 失败，先执行指令 $3$，然后再次执行指令 $5$ 以确保获取最新的值。无需额外恢复，因为加载操作仍在存储操作之后。**\n\n该选项在多个方面存在缺陷。\n1.  **调度目标**：主要目标是将加载*提升到存储之上*。此调度方案明确将加载保持在存储*之后*（`Keep $5$ after $3$`），因此未能达到指定目标。\n2.  **调度逻辑**：在一个基本块中将一条指令放在终止分支*之后*在逻辑上是不可能的。这表明对控制流的理解有误。\n3.  **运行时检查**：提议的 RC 是 `$((P + w_s  Q) \\lor (Q + w_l  P))$`。这有细微的错误。如前所述，对于整数地址，正确的边界条件使用 `$\\le$`。例如，如果存储区间是 $[100, 103]$ 而加载区间是 $[104, 107]$，那么 `$P=100$`, `$w_s=4$`, `$Q=104$`。这两个区间是不相交的。然而，`$P+w_s = 104$`，因此条件 `$P+w_s  Q$`（即 `$104  104$`）为假。该检查过于严格，在这种情况下会错误地报告可能存在的别名。\n4.  **恢复**：“无需额外恢复”的理由是基于加载仍在存储之后，但这与跨越潜在数据依赖进行推测性重排序的整个前提相矛盾。\n\n**结论：不正确**\n\n综上所述，只有选项 A 提出了一个能够实现所述目标的调度方案，并配有数学上正确的运行时检查和完整、正确的恢复机制，以在所有执行路径上保持程序语义。", "answer": "$$\\boxed{A}$$", "id": "3676434"}]}