{"hands_on_practices": [{"introduction": "软件流水线性能的第一个基本限制来自于硬件本身。一个循环即使没有任何依赖关系，其执行速度也不可能超过处理器功能单元的供应速度。本练习将引导你通过分析循环对不同计算资源的需求，来计算由资源所决定的最小启动间隔（ResMII），这是确定最终调度方案关键的第一步 [@problem_id:3670535]。", "problem": "一个编译器使用软件流水线技术为一个超长指令字（VLIW）处理器调度一个循环。该处理器每种类型都有多个相同的功能单元。假设循环和机器满足以下条件：\n\n- 该机器有 $U_{\\text{ALU}} = 4$ 个算术逻辑单元（ALU），$U_{\\text{MUL}} = 2$ 个乘法单元，$U_{\\text{MEM}} = 1$ 个内存单元，以及 $U_{\\text{SFU}} = 1$ 个特殊功能单元（SFU）。\n- 给定类型的每个操作在发布时，都将精确地占用一个相应的单元一个周期。忽略所有延迟、循环携带相关、旁路限制以及除了单元数量之外的结构性冒险。假设寄存器数量无限，并且每次迭代都必须执行所述类型的规定数量的操作。\n- 每次迭代的循环体包含 $11$ 个 ALU 操作，$3$ 个乘法操作，$4$ 个内存操作（加载或存储），以及 $1$ 个 SFU 操作。\n\n仅考虑资源因素，确定受资源限制的最小启动间隔（ResMII），其定义为由有限的资源数量所施加的启动间隔的最紧张的下界。同时，请指出在此下界下，哪些单元类型是资源瓶颈。为便于评分，请仅提供 $\\text{ResMII}$ 的数值作为您的最终答案；请在您的计算过程中包含关于瓶颈的推理。请提供一个精确的整数值；无需四舍五入。", "solution": "用户想要确定在一个 VLIW 处理器上，一个经过软件流水线优化的循环的受资源限制的最小启动间隔（$\\text{ResMII}$）。\n\n此问题是编译器理论和计算机体系结构原理的经典应用，特别涉及指令级并行和资源调度。该问题具有科学依据，定义明确，客观，并包含了获得唯一解所需的所有信息。忽略延迟和相关性的简化假设是一种标准的教学工具，用于分离出资源约束的影响。因此，该问题被认为是 **有效的**。\n\n启动间隔，记为 $II$，是在软件流水线循环中连续迭代开始之间的时钟周期数。在稳态下，每 $II$ 个周期启动一个完整的循环迭代。\n\n对于任何给定的功能单元类型 $R$，设 $U_R$ 为可用单元的数量，$N_R$ 为单次循环迭代所需的该类型操作的数量。在启动间隔为 $II$ 的稳态执行中，$II$ 个周期内 $R$ 类型可用的总操作槽位为 $U_R \\times II$。为了维持循环，此容量必须足以容纳每次迭代所需的 $N_R$ 个操作。这导出了每种资源类型 $R$ 的基本资源约束不等式：\n$$N_R \\le U_R \\times II$$\n这个不等式可以重新排列，以找到由资源类型 $R$ 施加的启动间隔的下界：\n$$II \\ge \\frac{N_R}{U_R}$$\n由于启动间隔必须是整数个时钟周期，因此资源类型 $R$ 的最小启动间隔，记为 $MII_R$，是满足此条件的最小整数。这可以通过对该比率取上限（ceiling）得到：\n$$MII_R = \\left\\lceil \\frac{N_R}{U_R} \\right\\rceil$$\n总的受资源限制的最小启动间隔 $\\text{ResMII}$ 是这些单独下界中最严格的一个。也就是说，它是所有资源类型的 $MII_R$ 值中的最大值，因为循环的执行速度只能和其受限制最严重的资源一样快。\n$$\\text{ResMII} = \\max_{R} (MII_R)$$\n问题提供了以下数据：\n- 每次迭代所需的ALU操作数：$N_{\\text{ALU}} = 11$\n- 可用ALU数量：$U_{\\text{ALU}} = 4$\n- 每次迭代所需的乘法操作数：$N_{\\text{MUL}} = 3$\n- 可用乘法单元数量：$U_{\\text{MUL}} = 2$\n- 每次迭代所需的内存操作数：$N_{\\text{MEM}} = 4$\n- 可用内存单元数量：$U_{\\text{MEM}} = 1$\n- 每次迭代所需的SFU操作数：$N_{\\text{SFU}} = 1$\n- 可用SFU数量：$U_{\\text{SFU}} = 1$\n\n我们现在计算每种资源类型的最小启动间隔：\n对于算术逻辑单元（ALU）：\n$$MII_{\\text{ALU}} = \\left\\lceil \\frac{N_{\\text{ALU}}}{U_{\\text{ALU}}} \\right\\rceil = \\left\\lceil \\frac{11}{4} \\right\\rceil = \\lceil 2.75 \\rceil = 3$$\n对于乘法单元（MUL）：\n$$MII_{\\text{MUL}} = \\left\\lceil \\frac{N_{\\text{MUL}}}{U_{\\text{MUL}}} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = \\lceil 1.5 \\rceil = 2$$\n对于内存单元（MEM）：\n$$MII_{\\text{MEM}} = \\left\\lceil \\frac{N_{\\text{MEM}}}{U_{\\text{MEM}}} \\right\\rceil = \\left\\lceil \\frac{4}{1} \\right\\rceil = \\lceil 4 \\rceil = 4$$\n对于特殊功能单元（SFU）：\n$$MII_{\\text{SFU}} = \\left\\lceil \\frac{N_{\\text{SFU}}}{U_{\\text{SFU}}} \\right\\rceil = \\left\\lceil \\frac{1}{1} \\right\\rceil = \\lceil 1 \\rceil = 1$$\n总的 $\\text{ResMII}$ 是这些单个值的最大值：\n$$\\text{ResMII} = \\max(\\{MII_{\\text{ALU}}, MII_{\\text{MUL}}, MII_{\\text{MEM}}, MII_{\\text{SFU}}\\})$$\n$$\\text{ResMII} = \\max(\\{3, 2, 4, 1\\}) = 4$$\n决定 $\\text{ResMII}$ 值的资源类型即为瓶颈。在这种情况下，$MII_{\\text{MEM}} = 4$，是最大值。因此，内存单元是资源瓶颈，因为它对循环的执行速率施加了最严格的约束。所需的 $\\text{ResMII}$ 为 $4$ 个周期。", "answer": "$$\\boxed{4}$$", "id": "3670535"}, {"introduction": "除了硬件资源，软件流水线的另一个核心约束是数据依赖，特别是跨越多次循环迭代的“循环携带依赖”。为了保证计算的正确性，后续迭代必须等待前序迭代的结果。本练习将帮助你理解如何根据依赖的“延迟”($l$)和“距离”($d$)，推导出保证程序正确性的最小启动间隔（RecMII）[@problem_id:3670523]。", "problem": "考虑一个简单的循环，其循环体包含单个操作 $x$，该操作产生一个值，用于计算跨迭代的下一个 $x$ 实例。具体来说，假设一个形式为 $x(i) = f(x(i-2))$ 的循环，其中计算 $f$ 由单个操作 $x$ 实现，其延迟为 $l = 5$ 个周期，循环携带依赖距离为 $d = 2$。编译器尝试使用软件流水线为此循环构建一个模调度，为操作 $x$ 在一个启动间隔 (II) 的内核中分配一个固定的周期偏移量 $t(x)$，其中启动间隔 (II) 是两个连续循环迭代开始之间的周期数。该依赖是从 $x(i-2)$ 到 $x(i)$ 的自依赖，距离为 $d = 2$，延迟为 $l = 5$。\n\n仅使用依赖距离 $d$、延迟 $l$ 和启动间隔 (II) 的基本定义，以及模调度为内核中的每个操作分配单个固定偏移量 $t(x)$（与迭代索引无关）这一事实，判断下列哪些陈述是正确的。\n\nA. 此循环的递推下限强制要求 $II \\ge \\lceil l/d \\rceil = \\lceil 5/2 \\rceil = 3$，因为围绕单个自依赖循环对时间差约束求和得出 $0 \\ge l - d \\cdot II$。\n\nB. $II = 2$ 的模调度仍然可以通过选择偏移量以使 $t(x,i) - t(x,i-2) = 1$ 来满足依赖关系，从而使 $x(i-2)$ 和 $x(i)$ 之间的耗时等于 $5$ 个周期。\n\nC. 一个有效的最小调度模式是 $II = 3$ 且 $t(x) = 0$，因此 $x$ 的连续实例在周期 $\\{0, 3, 6, \\dots\\}$ 开始；从 $x(i-2)$ 到 $x(i)$ 的耗时为 $2 \\cdot II = 6 \\ge l = 5$，满足了依赖关系。\n\nD. 当 $II = 3$ 时，交错模式 $t(x,i) = (i \\bmod 3)$ 是有效的并且可以减少寄存器压力，因为依赖不等式允许对不同的迭代偏移量存在正的裕量 (slack)。\n\nE. 如果资源约束允许，任何 $II \\ge 3$ 都满足依赖关系，并且当 $II = 3$ 时，任何固定的偏移量选择 $t(x) \\in \\{0, 1, 2\\}$ 都会产生一个正确的调度，因为自依赖得到了满足。\n\nF. 最小启动间隔与 $d$ 无关；只有延迟 $l$ 有影响，所以最小 $II$ 是 $\\lceil 5/1 \\rceil = 5$。", "solution": "对问题陈述的有效性进行分析。\n\n**步骤1：提取已知条件**\n- 循环体由单个操作组成，表示为 $x$。\n- 循环计算 $x(i) = f(x(i-2))$。\n- 操作 $x$ 的延迟为 $l = 5$ 个周期。\n- 循环携带依赖是从 $x(i-2)$ 到 $x(i)$ 的自依赖。\n- 依赖距离为 $d = 2$ 次迭代。\n- 调度方法是软件流水线，构建一个模调度。\n- 操作 $x$ 在一个内核中被分配一个固定的周期偏移量 $t(x)$。\n- 启动间隔 $II$ 是两个连续循环迭代开始之间的周期数。\n- 偏移量 $t(x)$ 与迭代索引 $i$ 无关。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 这是一个编译原理中的标准练习题，具体涉及软件流水线的模调度。延迟 ($l$)、依赖距离 ($d$) 和启动间隔 ($II$) 的概念是该领域的基础。该问题在已建立的编译器优化原则框架内被正确地提出。\n- **适定性：** 该问题是适定的。它提供了所有必要的参数（$l=5$, $d=2$）来确定对启动间隔 $II$ 的约束。问题具体，并且基于理论有一个唯一的、可验证的答案。\n- **客观性：** 语言技术性强、精确，且没有主观成分。\n- **不完整或矛盾的设置：** 设置是自洽且完整的。关系 $x(i) = f(x(i-2))$ 被一致地描述为距离 $d=2$ 的自依赖。\n- **不适定或结构不良：** 在编译器设计的背景下，术语是标准的且无歧义的。问题清晰地定义了其术语（例如，“固定的周期偏移量 $t(x)$...与迭代索引无关”）。\n\n**步骤3：结论与行动**\n问题陈述是有效的。将推导解决方案并评估各个选项。\n\n**基本约束的推导**\n\n模调度的核心原则是满足所有数据依赖。设 $T(op, i)$ 为操作 `op` 在迭代 $i$ 中的绝对开始时间。在一个具有固定操作偏移量 $t(op)$ 和启动间隔 $II$ 的模调度中，此开始时间由下式给出：\n$$T(op, i) = t(op) + i \\cdot II$$\n为不失一般性，我们可以将第一次迭代内核的开始时间设置为周期 $0$。\n\n问题描述了操作 $x$ 的一个循环携带自依赖。在迭代 $i-d$ 中由操作 $x$ 产生的值被迭代 $i$ 中的操作 $x$ 消耗。\n- 生产者操作实例是来自迭代 $i-d$ 的 $x$。它在时间 $T(x, i-d) = t(x) + (i-d) \\cdot II$ 开始。\n- 此操作的结果在其延迟 $l$ 之后可用。因此，该值在时间 $T(x, i-d) + l$ 就绪。\n- 消费者操作实例是来自迭代 $i$ 的 $x$。它在时间 $T(x, i) = t(x) + i \\cdot II$ 开始。\n\n为了满足依赖关系，消费者不能在值就绪之前开始：\n$$T(x, i) \\ge T(x, i-d) + l$$\n代入开始时间的表达式：\n$$t(x) + i \\cdot II \\ge (t(x) + (i-d) \\cdot II) + l$$\n$t(x)$ 和 $i \\cdot II$ 项出现在两侧，可以简化：\n$$i \\cdot II \\ge i \\cdot II - d \\cdot II + l$$\n这可以简化为模调度中自依赖的基本递推约束：\n$$d \\cdot II \\ge l$$\n文献中常见的另一种等价表述是，对于从操作 $u$到 $v$，距离为 $d$ 且延迟为 $l$ 的依赖，其偏移量必须满足 $t(v) - t(u) \\ge l - d \\cdot II$。对于自依赖，$u=v=x$，因此 $t(x) - t(x) = 0$，得到 $0 \\ge l - d \\cdot II$，这与 $d \\cdot II \\ge l$ 相同。\n\n使用给定的值 $l=5$ 和 $d=2$：\n$$2 \\cdot II \\ge 5$$\n$$II \\ge \\frac{5}{2} = 2.5$$\n由于启动间隔 $II$ 必须是整数个周期，因此 $II$ 的最小可能值为：\n$$II_{min} = \\lceil 2.5 \\rceil = 3$$\n这个下限被称为递推约束的最小启动间隔 ($RecMII$)。总的最小启动间隔 ($MII$) 是 $RecMII$ 和资源约束的最小启动间隔 ($ResMII$) 中的最大值。由于循环体只有一个操作，资源约束是最小的（如果至少有一个用于 $x$ 的功能单元，则 $ResMII=1$），因此递推是限制因素。因此，最小 $II$ 是 $3$。\n\n**逐项分析**\n\n**A. 此循环的递推下限强制要求 $II \\ge \\lceil l/d \\rceil = \\lceil 5/2 \\rceil = 3$，因为围绕单个自依赖循环对时间差约束求和得出 $0 \\ge l - d \\cdot II$。**\n该陈述以 $0 \\ge l - d \\cdot II$ 的形式给出了基本不等式，这与上面推导出的 $d \\cdot II \\ge l$ 是等价的。它正确地代入了 $l=5$ 和 $d=2$ 的值，得到 $II \\ge 5/2$，然后正确地取天花板函数（向上取整）找到最小整数 $II$，即 $3$。其推理和结果完全正确。\n**结论：正确**\n\n**B. $II = 2$ 的模调度仍然可以通过选择偏移量以使 $t(x,i) - t(x,i-2) = 1$ 来满足依赖关系，从而使 $x(i-2)$ 和 $x(i)$ 之间的耗时等于 $5$ 个周期。**\n这个陈述是错误的，原因有二。首先，如推导所示，任何有效的调度都必须满足 $II \\ge 3$。$II$ 为 $2$ 违反了递推约束 ($2 \\cdot 2 = 4 \\not\\ge 5$)。其次，问题明确定义模调度具有“单个固定偏移量 $t(x)$ ... 与迭代索引无关”。该选项建议使用与迭代相关的偏移量，记为 $t(x,i)$，这与所使用的调度模型的定义相矛盾。\n**结论：错误**\n\n**C. 一个有效的最小调度模式是 $II = 3$ 且 $t(x) = 0$，因此 $x$ 的连续实例在周期 $\\{0, 3, 6, \\dots\\}$ 开始；从 $x(i-2)$ 到 $x(i)$ 的耗时为 $2 \\cdot II = 6 \\ge l = 5$，满足了依赖关系。**\n该陈述提出了一个具体的、有效的调度。最小 $II$ 确实是 $3$。固定偏移量 $t(x)=0$ 是一个有效的选择。当 $t(x)=0$ 和 $II=3$ 时，实例 $i$ 的开始时间是 $T(x,i) = 0 + i \\cdot 3 = 3i$，导致开始时间为 $\\{0, 3, 6, \\dots\\}$。在迭代 $i-2$ 和迭代 $i$ 中操作 $x$ 开始之间经过的时间是 $T(x,i) - T(x,i-2) = 3i - 3(i-2) = 6$。或者，这个耗时总是 $d \\cdot II = 2 \\cdot 3 = 6$ 个周期。依赖关系得到满足，因为这个耗时（$6$ 个周期）大于或等于延迟（$l=5$ 个周期）。该陈述是一个有效最小调度的正确且具体的例证。\n**结论：正确**\n\n**D. 当 $II = 3$ 时，交错模式 $t(x,i) = (i \\bmod 3)$ 是有效的并且可以减少寄存器压力，因为依赖不等式允许对不同的迭代偏移量存在正的裕量 (slack)。**\n这个陈述，与选项 B 类似，提出了一个偏移量依赖于迭代索引 $i$ 的调度方案。这不符合问题中定义的标准模调度（“单个固定偏移量 $t(x)$”）。尽管这种“交错”或“摆动”模调度作为一种更高级的技术确实存在（并且可能确实影响寄存器压力），但该选项在问题指定的约束下错误地将其标记为有效模式。\n**结论：错误**\n\n**E. 如果资源约束允许，任何 $II \\ge 3$ 都满足依赖关系，并且当 $II = 3$ 时，任何固定的偏移量选择 $t(x) \\in \\{0, 1, 2\\}$ 都会产生一个正确的调度，因为自依赖得到了满足。**\n该陈述包含两部分。第一，“任何 $II \\ge 3$ 都满足依赖关系”。依赖不等式是 $2 \\cdot II \\ge 5$。对于任何整数 $II \\ge 3$，这都是成立的（例如，如果 $II=3$，$6 \\ge 5$；如果 $II=4$，$8 \\ge 5$，等等）。这部分是正确的。第二，“当 $II = 3$ 时，任何固定的偏移量选择 $t(x) \\in \\{0, 1, 2\\}$ 都会产生一个正确的调度”。如推导所示，对于自依赖，固定偏移量 $t(x)$ 在不等式中被消去 ($t(x) - t(x) \\ge l - d \\cdot II$)。这意味着 $t(x)$ 的选择不影响递推约束是否被满足。因此，任何固定偏移量的选择对于满足这个特定的依赖都是有效的。集合 $\\{0, 1, 2\\}$ 代表了模 $II=3$ 的所有可能偏移量。这部分也是正确的。\n**结论：正确**\n\n**F. 最小启动间隔与 $d$ 无关；只有延迟 $l$ 有影响，所以最小 $II$ 是 $\\lceil 5/1 \\rceil = 5$。**\n这个陈述是根本错误的。推导 $d \\cdot II \\ge l$ 清楚地表明，最小 $II$ 同时取决于延迟 $l$ 和依赖距离 $d$。该陈述声称 $II$ “与 $d$ 无关”是错误的。然后它错误地假设 $d=1$ 来计算最小 $II$，这与给定的信息 $d=2$ 相矛盾。\n**结论：错误**", "answer": "$$\\boxed{ACE}$$", "id": "3670523"}, {"introduction": "在实践中，选择最佳的启动间隔（$II$）并不仅仅是简单地取RecMII和ResMII的最大值。一个更激进（更小）的$II$虽然理论上能提高吞吐率，但通常会增加同时活跃的变量数量，从而导致寄存器压力过大。本练习模拟了一个真实编译器在性能和寄存器资源之间进行权衡的决策过程，你需要通过计算和比较，选择一个在考虑了寄存器溢出（spilling）代价后，能带来最佳整体性能的$II$ [@problem_id:3670551]。", "problem": "一个循环正在一个带有旋转寄存器堆的处理器上使用软件流水进行模调度。考虑模调度核心的单个逻辑迭代。在此核心中，有三个临时变量，其生存窗口（从定义周期到核心调度中最后一次使用的周期，含两者）的长度分别为 $L_{A} = 5$、$L_{B} = 7$ 和 $L_{C} = 2$ 个周期。在不发生溢出的情况下，两个候选的启动间隔（II）选项，$II = 2$ 和 $II = 3$，就循环依赖和功能单元资源而言都是可行的。该机器对同时活跃的旋转寄存器的最大数量有硬性限制 $R_{\\max} = 7$。\n\n假设稳态下有以下建模假设：\n- 在稳态下，一个临时变量贡献的同时活跃实例数等于其生存窗口内发生的核心启动次数。\n- 对于一个选定的 $II$，如果所有临时变量的同时活跃实例总数超过 $R_{\\max}$，则必须为每个原始循环迭代精确地溢出超出的同时活跃实例数，以满足寄存器限制。溢出一个同时活跃实例会导致在定义之后进行一次存储，在使用之前进行一次加载；由于与其他指令部分重叠，这两个内存操作共同对每个原始迭代施加了 $\\delta = 0.5$ 个周期的摊销稳态开销。\n- 忽略前导码和后继码。使用一个加性稳态成本模型，其中每个原始迭代的估计周期数为 $C(II) = II + \\delta \\cdot s(II)$，其中 $s(II)$ 是为满足该 $II$ 的 $R_{\\max}$ 约束而需要为每个原始迭代溢出的同时活跃实例数。\n\n在两个候选者 $II = 2$ 和 $II = 3$ 中，确定在这些假设下哪个 $II$ 能最小化 $C(II)$。最终答案仅报告所选的 $II$。无需四舍五入，最终答案中不应包含单位。", "solution": "首先验证问题，以确保其科学性、良构性和客观性。\n\n**步骤1：提取已知条件**\n问题陈述中提供了以下数据：\n- 三个临时变量的生存窗口长度：$L_{A} = 5$ 个周期，$L_{B} = 7$ 个周期，$L_{C} = 2$ 个周期。\n- 两个候选启动间隔（II）：$II \\in \\{2, 3\\}$。\n- 同时活跃的旋转寄存器最大数量：$R_{\\max} = 7$。\n- 临时变量同时活跃实例数的模型：其生存窗口内的核心启动次数。\n- 溢出规则：如果所需寄存器总数超过 $R_{\\max}$，则每个原始迭代的溢出次数 $s(II)$ 就是超出的确切数量。\n- 溢出开销：每个原始迭代中每个溢出实例 $\\delta = 0.5$ 个周期。\n- 稳态成本模型：$C(II) = II + \\delta \\cdot s(II)$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在编译器理论，特别是指令级并行的软件流水背景下是良定义的。启动间隔（II）、生存窗口、旋转寄存器和寄存器溢出等概念都是标准的。用于计算寄存器压力和性能成本的模型是一个简化但一致且在该领域常用的公式。对于给定的 $II$，生存窗口长度为 $L$ 的临时变量的同时活跃实例数被正确地建模为 $\\lceil L/II \\rceil$。所有必要的数据都已提供，约束条件清晰，没有矛盾。该问题具有科学性、良构性和客观性。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将提供解答。\n\n目标是确定两个候选启动间隔 $II = 2$ 或 $II = 3$ 中，哪一个能带来更低的每个原始迭代的稳态成本 $C(II)$。该成本是 $II$ 本身以及任何必要的寄存器溢出所带来的开销的函数。\n\n首先，我们必须为每个候选 $II$ 计算所需的总同时活跃寄存器数 $R(II)$。对于生存窗口长度为 $L$ 的单个临时变量，其同时活跃实例数由 $N = \\lceil L/II \\rceil$ 给出。总寄存器需求是所有临时变量的这些值的总和。\n$$R(II) = \\lceil \\frac{L_A}{II} \\rceil + \\lceil \\frac{L_B}{II} \\rceil + \\lceil \\frac{L_C}{II} \\rceil$$\n\n接下来，我们通过将 $R(II)$ 与机器的限制 $R_{\\max}$ 进行比较，来确定所需的溢出次数 $s(II)$。\n$$s(II) = \\max(0, R(II) - R_{\\max})$$\n\n最后，我们使用给定的公式计算每个候选者的成本 $C(II)$。\n$$C(II) = II + \\delta \\cdot s(II)$$\n\n让我们分析这两种情况。\n\n**情况1：$II = 2$**\n给定的生存窗口长度为 $L_{A} = 5$，$L_{B} = 7$ 和 $L_{C} = 2$。\n每个临时变量的活跃实例数为：\n- 对于临时变量 A：$N_A(2) = \\lceil \\frac{L_A}{2} \\rceil = \\lceil \\frac{5}{2} \\rceil = \\lceil 2.5 \\rceil = 3$。\n- 对于临时变量 B：$N_B(2) = \\lceil \\frac{L_B}{2} \\rceil = \\lceil \\frac{7}{2} \\rceil = \\lceil 3.5 \\rceil = 4$。\n- 对于临时变量 C：$N_C(2) = \\lceil \\frac{L_C}{2} \\rceil = \\lceil \\frac{2}{2} \\rceil = \\lceil 1 \\rceil = 1$。\n\n$II=2$ 所需的总寄存器数为：\n$$R(2) = N_A(2) + N_B(2) + N_C(2) = 3 + 4 + 1 = 8$$\n机器的寄存器限制为 $R_{\\max} = 7$。由于 $R(2) = 8 > R_{\\max} = 7$，需要进行寄存器溢出。每个原始迭代的溢出次数为超出的数量：\n$$s(2) = R(2) - R_{\\max} = 8 - 7 = 1$$\n现在我们可以使用开销 $\\delta = 0.5$ 计算 $II = 2$ 的成本：\n$$C(2) = II + \\delta \\cdot s(2) = 2 + (0.5) \\cdot 1 = 2 + 0.5 = 2.5$$\n\n**情况2：$II = 3$**\n给定的生存窗口长度为 $L_{A} = 5$，$L_{B} = 7$ 和 $L_{C} = 2$。\n每个临时变量的活跃实例数为：\n- 对于临时变量 A：$N_A(3) = \\lceil \\frac{L_A}{3} \\rceil = \\lceil \\frac{5}{3} \\rceil = \\lceil 1.66... \\rceil = 2$。\n- 对于临时变量 B：$N_B(3) = \\lceil \\frac{L_B}{3} \\rceil = \\lceil \\frac{7}{3} \\rceil = \\lceil 2.33... \\rceil = 3$。\n- 对于临时变量 C：$N_C(3) = \\lceil \\frac{L_C}{3} \\rceil = \\lceil \\frac{2}{3} \\rceil = \\lceil 0.66... \\rceil = 1$。\n\n$II=3$ 所需的总寄存器数为：\n$$R(3) = N_A(3) + N_B(3) + N_C(3) = 2 + 3 + 1 = 6$$\n机器限制为 $R_{\\max} = 7$。由于 $R(3) = 6 \\le R_{\\max} = 7$，不需要进行寄存器溢出。\n$$s(3) = \\max(0, R(3) - R_{\\max}) = \\max(0, 6 - 7) = 0$$\n$II = 3$ 的成本为：\n$$C(3) = II + \\delta \\cdot s(3) = 3 + (0.5) \\cdot 0 = 3$$\n\n**比较与结论**\n我们比较两个候选启动间隔的成本：\n- 每个原始迭代的周期数 $C(2) = 2.5$。\n- 每个原始迭代的周期数 $C(3) = 3$。\n\n由于 $C(2)  C(3)$，最小化稳态成本的启动间隔是 $II = 2$。尽管较小的 $II$ 会增加寄存器压力并导致溢出，但在这种情况下，较短启动间隔带来的性能增益超过了溢出开销的成本。", "answer": "$$\\boxed{2}$$", "id": "3670551"}]}