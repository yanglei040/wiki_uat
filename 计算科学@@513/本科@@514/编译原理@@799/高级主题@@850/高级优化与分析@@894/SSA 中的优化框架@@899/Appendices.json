{"hands_on_practices": [{"introduction": "稀疏条件常量传播（SCCP）是一种强大的分析技术，它将常量传播与可达性分析相结合。本练习将通过一个具体的例子，向你展示静态单赋值（SSA）形式（特别是 $\\phi$ 函数）如何使 SCCP 能够精确而高效地工作，甚至能够发现并剪除不可达的代码路径。理解 SCCP 的工作原理是掌握许多后续优化的基础。[@problem_id:3660120]", "problem": "给定一个采用静态单赋值（SSA）形式的小程序，它演示了在稀疏条件常量传播（SCCP）下，跨 $\\phi$ 函数的常量折叠是如何进行的。该环境为每个 SSA 值使用标准的三点值格 $\\{\\bot,\\text{constant},\\top\\}$，并维护一个可执行边集来模拟控制流的可行性。连接块中的 $\\phi$ 函数选择与运行时实际采用的控制流前驱相对应的操作数，在 SCCP 下，其值被计算为仅来自可执行前驱的操作数在值格上的交（meet）。假设使用整数布尔值，其中 $0$ 代表假，$1$ 代表真，并进行整数算术运算。控制流图（CFG）和 SSA 代码如下：\n\n- 块 $\\mathrm{B0}$ (入口):\n  - $q \\leftarrow 0$\n  - if $q \\neq 0$ goto $\\mathrm{B4}$ else goto $\\mathrm{B00}$\n- 块 $\\mathrm{B4}$:\n  - $a_4 \\leftarrow 3$\n  - goto $\\mathrm{J}$\n- 块 $\\mathrm{B00}$:\n  - $p \\leftarrow 1$\n  - if $p \\neq 0$ goto $\\mathrm{B1}$ else goto $\\mathrm{B2}$\n- 块 $\\mathrm{B1}$:\n  - $a_1 \\leftarrow 3$\n  - $b_1 \\leftarrow 3$\n  - goto $\\mathrm{J}$\n- 块 $\\mathrm{B2}$:\n  - $a_2 \\leftarrow 3$\n  - $b_2 \\leftarrow 4$\n  - goto $\\mathrm{J}$\n- 块 $\\mathrm{J}$ (前驱 $\\mathrm{B1}$, $\\mathrm{B2}$, $\\mathrm{B4}$ 的连接点):\n  - $a \\leftarrow \\phi(a_1,a_2,a_4)$\n  - $b \\leftarrow \\phi(b_1,b_2)$\n  - $\\mathrm{out} \\leftarrow 10 \\cdot a + b$\n  - return $\\mathrm{out}$\n\n你的任务是，在应用稀疏条件常量传播直至达到不动点，并随后进行标准的代数化简和常量折叠之后，确定该程序返回的数值。你必须基于以下基本定义和事实进行推理：\n\n- 静态单赋值（SSA）形式为每个变量只赋值一次，并使用 $\\phi$ 函数在控制流图的连接点合并来自多个前驱的值。$\\phi$ 函数的语义是产生与实际执行的控制流路径相对应的操作数。\n- 稀疏条件常量传播（SCCP）同时使用值格 $\\{\\bot,\\text{constant},\\top\\}$ 对值信息和对控制流的可执行性进行推理。其传递函数是单调的，分析会迭代至不动点。$\\phi$ 函数的值是其输入操作数值在值格上的交（meet），且仅限于来自可执行前驱的操作数。如果多个可执行的输入操作数是不同的常量，则 $\\phi$ 函数的值变为 $\\top$；如果它们是相等的常量，则其值变为该常量；如果只有一个可执行前驱带有常量值，而所有其他可执行前驱的值都是 $\\bot$，则其值变为该常量。\n\n请从第一性原理出发，并使用上述框架，解释 SCCP 是如何发现和利用以下情况的：\n- 当所有输入操作数都是相同的常量时，如何跨 $\\phi$ 函数进行常量折叠，例如 $a \\leftarrow \\phi(3,3,3)$。\n- 当一个 $\\phi$ 函数在不同的前驱上有不同的常量（例如 $b \\leftarrow \\phi(3,4)$），但其中一个前驱被发现是不可行路径时，算法如何收敛。\n\n计算最终返回的精确整数值 $\\mathrm{out}$。不要四舍五入，也不要包含任何单位。", "solution": "解决方案通过在给定程序上模拟稀疏条件常量传播（SCCP）算法直至达到不动点来展开。该算法为每个变量维护一个值格中的值，并维护一个可执行的 CFG 边集。我们使用工作列表来处理值已改变的变量和新发现的可执行边。\n\n**初始化：**\n1.  所有变量初始化为 $\\bot$：$v(q) = \\bot$，$v(p) = \\bot$，$v(a_1) = \\bot$ 等。\n2.  所有 CFG 边最初都视为不可执行。\n3.  入口块 $\\mathrm{B0}$ 总是可达的。我们将从程序入口到 $\\mathrm{B0}$ 的（概念上的）边添加到可执行边的工作列表中。\n\n**执行跟踪：**\n\n1.  **块 $\\mathrm{B0}$：**算法从访问入口块 $\\mathrm{B0}$ 开始。\n    - 指令 $q \\leftarrow 0$ 被求值。$q$ 的值格从 $\\bot$ 变为常量 $0$。\n    - 条件分支 `if $q \\neq 0$` 被求值。由于 $v(q) = 0$，条件 $0 \\neq 0$ 被静态地确定为假。\n    - 因此，控制流边 $\\mathrm{B0} \\rightarrow \\mathrm{B4}$ 被确定为不可执行。\n    - 边 $\\mathrm{B0} \\rightarrow \\mathrm{B00}$ 被确定为可执行并被处理。\n\n2.  **块 $\\mathrm{B00}$：**算法前进到块 $\\mathrm{B00}$。\n    - 指令 $p \\leftarrow 1$ 将 $p$ 的值格设为常量 $1$。\n    - 条件分支 `if $p \\neq 0$` 被求值。由于 $v(p) = 1$，条件 $1 \\neq 0$ 被静态地确定为真。\n    - 边 $\\mathrm{B00} \\rightarrow \\mathrm{B2}$ 是不可执行的。\n    - 边 $\\mathrm{B00} \\rightarrow \\mathrm{B1}$ 是可执行的并被处理。\n\n3.  **死代码消除：**在此阶段，SCCP 已经证明块 $\\mathrm{B4}$ 和 $\\mathrm{B2}$ 是不可达的。这些块中的任何指令都不会被求值，它们定义的变量将保持其初始值格 $\\bot$。通向它们的控制流路径（$\\mathrm{B0} \\rightarrow \\mathrm{B4}$ 和 $\\mathrm{B00} \\rightarrow \\mathrm{B2}$）在分析连接块 $\\mathrm{J}$ 时被剪除。\n\n4.  **块 $\\mathrm{B1}$：**算法前进到唯一可达的后继块 $\\mathrm{B1}$。\n    - 指令 $a_1 \\leftarrow 3$ 将 $v(a_1)$ 设为常量 $3$。\n    - 指令 $b_1 \\leftarrow 3$ 将 $v(b_1)$ 设为常量 $3$。\n    - 无条件跳转 `goto $\\mathrm{J}$` 使得边 $\\mathrm{B1} \\rightarrow \\mathrm{J}$ 变为可执行。\n\n5.  **块 $\\mathrm{J}$ (连接点)：**算法到达连接点 $\\mathrm{J}$。现在对 $\\phi$ 函数进行求值。SCCP 规则规定，$\\phi$ 函数的交运算仅对与可执行前驱边相对应的操作数执行。\n    - **$a \\leftarrow \\phi(a_1, a_2, a_4)$ 的求值：**\n      $\\mathrm{J}$ 的前驱是 $\\mathrm{B1}$、$\\mathrm{B2}$ 和 $\\mathrm{B4}$。然而，分析已经证明只有边 $\\mathrm{B1} \\rightarrow \\mathrm{J}$ 是可执行的。因此，$a$ 的值完全由来自 $\\mathrm{B1}$ 的操作数决定。\n      $$v(a) = v(a_1) = 3$$\n      变量 $a$ 现在已知为常量 $3$。\n\n    - **关于跨 $\\phi$ 函数进行常量折叠的解释：**\n      问题要求解释 $a \\leftarrow \\phi(3,3,3)$ 的折叠。赋值语句是 $a_1 \\leftarrow 3$，$a_2 \\leftarrow 3$ 和 $a_4 \\leftarrow 3$。在我们的具体案例中，由于只有通过 $\\mathrm{B1}$ 的路径是活动的（live），因此在死代码块中定义的 $a_2$ 和 $a_4$ 的值是无关紧要的。结果仅由 $a_1$ 决定。\n      然而，在一个假设所有三条通往 $\\mathrm{J}$ 的路径都被发现是可执行的场景中，SCCP 会对所有三个赋值进行求值，得到 $v(a_1)=3$, $v(a_2)=3$ 和 $v(a_4)=3$。此时 $\\phi$ 函数的值将是这些常量的交（meet）：\n      $$v(a) = \\text{meet}(v(a_1), v(a_2), v(a_4)) = \\text{meet}(3, 3, 3) = 3$$\n      因此，SCCP 将 $\\phi$ 函数折叠为一个常量，因为相同常量的交运算结果就是该常量本身。\n\n    - **$b \\leftarrow \\phi(b_1, b_2)$ 的求值：**\n      关于 $b$ 的 $\\phi$ 函数文本表明它合并了来自前驱 $\\mathrm{B1}$ 和 $\\mathrm{B2}$ 的值。如前所述，只有通过 $\\mathrm{B1}$ 的路径是可执行的。\n      $$v(b) = v(b_1) = 3$$\n      变量 $b$ 被确定为常量 $3$。\n\n    - **关于在存在不可行路径时算法如何收敛的解释：**\n      问题要求解释 $b \\leftarrow \\phi(3,4)$ 的情况，其中 $b_1 \\leftarrow 3$ 和 $b_2 \\leftarrow 4$。这是 SCCP 强大功能的核心展示。如果通过 $\\mathrm{B1}$ 和 $\\mathrm{B2}$ 的两条路径都是可执行的，求值结果将是：\n      $$v(b) = \\text{meet}(v(b_1), v(b_2)) = \\text{meet}(3, 4) = \\top$$\n      这将意味着 $b$ 不是一个常量。然而，SCCP 对值和控制流的同时分析证明了通过 $\\mathrm{B2}$ 的路径是不可达的。因此，来自这条死路径的操作数 $b_2$ 被排除在交运算之外。算法只考虑来自活动路径的值，结果为 $v(b) = v(b_1) = 3$。这防止了值被保守地变为 $\\top$，从而实现了更精确的常量传播。\n\n6.  **最终计算：**利用不动点值 $v(a)=3$ 和 $v(b)=3$，对块 $\\mathrm{J}$ 中的最后一条指令进行求值：\n    - $\\mathrm{out} \\leftarrow 10 \\cdot a + b$\n    - 使用发现的常量进行计算：$\\mathrm{out} \\leftarrow 10 \\cdot 3 + 3$。\n    - 该表达式被折叠为单个常量：$\\mathrm{out} \\leftarrow 30 + 3 = 33$。\n    - $\\mathrm{out}$ 的值格变为常量 $33$。\n\n程序返回 $\\mathrm{out}$ 的值，SCCP 分析已确定其为 $33$。", "answer": "$$\\boxed{33}$$", "id": "3660120"}, {"introduction": "在 SSA 形式的基础上进行优化是现代编译器的核心。本练习将引导你应用 SSA 的特性来解决一个经典的性能问题：循环不变代码外提（LICM）。你将学习如何利用 SSA 的定义-使用链来严格证明一个表达式在内层循环中是“不变的”，并将其移动到循环外以减少不必要的重复计算，从而显著提升程序性能。[@problem_id:3660080]", "problem": "考虑一个程序片段，其控制流包含一个嵌套循环，外层循环索引为 $i$，内层循环索引为 $j$。该程序在静态单赋值（Static Single Assignment, SSA）形式下运行，其中每个变量只被赋值一次，并且控制流图中的合并点会引入 $\\phi$ 函数。已知内层循环体当前计算一个纯算术表达式 $E(i)$，该表达式仅依赖于外层循环索引 $i$，并且不读取或写入内存。内层循环将结果累加到一个标量 $s$ 中，并递增 $j$ 直到达到其边界。其结构如下：\n\n- 外层循环头包含一个针对 $i$ 的 $\\phi$ 函数，将 $i$ 初始化为 $0$，并在外层循环回边处与递增后的值合并。\n- 内层循环头包含一个针对 $j$ 的 $\\phi$ 函数，将 $j$ 初始化为 $0$，并在内层循环回边处与 $j+1$ 合并。\n- 内层循环还包含一个针对累加器 $s$ 的 $\\phi$ 函数，在循环入口处合并传入值与每次迭代更新后的值。\n- 内层循环体计算 $E(i)$，作为对 $s$ 的每次迭代贡献的一部分。\n- 内层循环条件检查 $j  M(i)$，其中 $M(i)$ 是一个依赖于 $i$ 的循环边界。\n\n假设如下：\n- 静态单赋值（SSA）形式是根据标准定义正确构建的：每个变量只有一个赋值；在控制流连接点，引入 $\\phi$ 函数以在传入值中进行选择；定义支配其所有使用；循环头支配其回边（latches）。\n- $E(i)$ 是一个仅由 $i$ 通过整数运算构成的纯表达式，没有副作用，不访问内存，并且其求值不会抛出异常。\n- 边界函数为 $M(i) = i + 1$。\n- 外层循环的 $i$ 从 $0$ 到 $N-1$ 运行，其中 $N = 100$。\n- 对于每个固定的 $i$，内层循环的 $j$ 从 $0$ 到 $M(i)-1$ 运行。\n- 累加器 $s$ 在内层循环体中通过一个依赖于 $E(i)$ 和 $j$ 的函数进行更新，但该函数不改变 $E(i)$ 相对于 $j$ 的不变性。\n\n从 $\\phi$ 函数在控制流连接点上模拟值选择，以及循环携带依赖在SSA的定义-使用图中沿循环回边表现为一个环这两个基本点出发，执行以下操作：\n\n1. 使用SSA结构以及外层和内层循环头中的 $\\phi$ 函数布局，判断 $E(i)$ 相对于内层循环索引 $j$ 是循环携带的还是在内层循环中不变的。通过SSA中的支配和定义-使用属性进行推理来证明你的答案。\n2. 提出一种优化方案，将 $E(i)$ 的计算从内层循环体下沉到内层循环的前置首部（preheader）中，同时保持程序语义。解释为什么在给定的假设下，这种优化是安全的。\n3. 计算在应用优化之前和之后，整个嵌套循环中 $E(i)$ 的动态求值确切次数。然后，计算该优化消除的 $E(i)$ 的动态求值总次数。将最终消除的次数作为一个实数值提供。最终答案无需四舍五入，也无需单位。", "solution": "这个问题提得很好，并且基于编译器理论的原理，特别是关于静态单赋值（SSA）形式下的程序分析和优化。我们将依次解决问题的三个部分。\n\n1.  判断 $E(i)$ 是否为循环不变量。\n\n一个表达式，如果对于循环 $L$ 的每次执行，在每次迭代中都求值为相同的值，那么它就被定义为相对于循环 $L$ 是循环不变量。在SSA形式的上下文中，如果一条指令的所有操作数都在循环外定义，则该指令是循环不变量。这些操作数要么是常量，要么是循环不修改的全局变量，要么是其定义在循环外部的变量。\n\n所讨论的表达式是 $E(i)$。问题陈述中指出 $E(i)$ 是一个“仅依赖于外层循环索引 $i$”的纯算术表达式。这意味着用于计算 $E(i)$ 的变量集合仅包含 $i$。因此，我们必须分析变量 $i$ 相对于内层循环的定义。\n\n设内层循环为 $L_{inner}$。在 $L_{inner}$ 的整个执行过程中，外层循环索引 $i$ 的值是恒定的。在SSA图中，在 $L_{inner}$ 内部使用的特定版本的 $i$ 的定义发生在进入 $L_{inner}$ 之前。具体来说，对于外层循环的某次给定迭代， $i$ 的值被确定下来。然后，控制流图进入内层循环的前置首部，随后进入内层循环本身。内层循环体内没有对 $i$ 的赋值。根据SSA原则，一个变量的定义必须支配其所有使用。由于 $i$ 的定义在 $L_{inner}$ 外部，所以这个定义支配了 $L_{inner}$ 内部所有对 $i$ 的使用。\n\n如果一个变量在循环 $L$ 的某次迭代中的值是由它在 $L$ 的前一次迭代中的值计算出来的，那么这个变量就与循环 $L$ 存在循环携带依赖。在SSA中，这表现为定义-使用图中一个涉及 $L$ 的循环头中 $\\phi$ 函数的环。问题陈述中指出，内层循环头包含针对索引 $j$ 和累加器 $s$ 的 $\\phi$ 函数。内层循环头中没有针对 $i$ 的 $\\phi$ 函数。这证实了 $i$ 没有由内层循环携带的依赖关系。\n\n由于 $E(i)$ 的唯一变量操作数 $i$ 的定义在内层循环之外，根据定义，表达式 $E(i)$ 相对于内层循环是循环不变量。它不相对于内层循环索引 $j$ 具有循环携带特性。\n\n2.  提出优化方案。\n\n针对所述情况的标准优化是循环不变量代码外提（Loop-Invariant Code Motion, LICM）。这种优化识别出循环内每次迭代都产生相同结果的计算，并将它们移动到循环开始前，只执行一次。\n\n提议的转换是将 $E(i)$ 的计算移出内层循环体，并放入内层循环的前置首部。内层循环前置首部是在每次外层循环迭代中，进入内层循环之前仅执行一次的代码块。具体步骤如下：\n- 引入一个新的临时变量，我们称之为 $t_{inv}$。\n- 计算 $t_{inv} \\leftarrow E(i)$ 被放置在内层循环的前置首部。\n- 内层循环体内部所有对 $E(i)$ 结果的使用都被替换为对 $t_{inv}$ 的使用。\n\n在给定的假设下，此优化是安全的，原因如下：\n- **支配性 (Dominance)**：内层循环的前置首部支配内层循环内的每个块。因此，在前置首部中 $t_{inv}$ 的新定义将支配其在循环内的所有使用，满足了SSA的一个基本要求。\n- **纯洁性 (Purity)**：问题陈述中指出 $E(i)$ 是一个没有副作用（无内存修改、无I/O、无异常）的纯表达式。这保证了移动计算不会改变程序的可观察行为或状态，只会提高性能。\n- **执行保证 (Execution Guarantee)**：一个不变量计算可以被安全地外提，条件是它在原程序中只要进入循环就保证被执行，或者它的执行没有副作用。问题明确指出 $E(i)$ 是纯的，因此即使循环体可能不执行，外提也是安全的。在此特定情况下，内层循环边界为 $M(i) = i+1$。由于外层循环索引 $i$ 的范围是从 $0$ 到 $N-1$（其中 $N=100$），循环边界 $M(i)$ 始终 $\\geq 1$。这意味着对于外层循环的每次迭代，内层循环体都保证至少执行一次。因此，对 $E(i)$ 的计算不是推测性的，外提保证既安全又有利可图。\n\n问题陈述使用了“将计算下沉（sinking）……到内层循环前置首部”的说法。尽管标准编译器文献通常将这种转换称为将代码“提升（hoisting）”或“上提（lifting）”出循环，但所描述的代码移动在功能上是相同且正确的。\n\n3.  计算动态求值次数的减少量。\n\n我们需要计算在应用LICM优化之前和之后，表达式 $E(i)$ 被动态求值的总次数。\n\n**优化前：**\n表达式 $E(i)$ 位于内层循环体内部。因此，内层循环的每次迭代都会对其求值一次。外层循环对 $i \\in \\{0, 1, \\dots, N-1\\}$ 运行，对于每个 $i$，内层循环对 $j \\in \\{0, 1, \\dots, M(i)-1\\}$ 运行。对于给定的 $i$，内层循环的迭代次数是 $M(i)$。\n总求值次数 $C_{before}$ 是外层循环所有迭代中内层循环执行次数的总和。\n给定 $N=100$ 且 $M(i) = i+1$。\n$$C_{before} = \\sum_{i=0}^{N-1} M(i) = \\sum_{i=0}^{N-1} (i+1)$$\n这个和等价于前 $N$ 个正整数之和：\n$$C_{before} = 1 + 2 + 3 + \\dots + N = \\frac{N(N+1)}{2}$$\n代入 $N=100$：\n$$C_{before} = \\frac{100(100+1)}{2} = \\frac{100 \\times 101}{2} = 50 \\times 101 = 5050$$\n\n**优化后：**\n$E(i)$ 的计算已被移至内层循环的前置首部。对于外层循环的每次迭代，这个前置首部恰好执行一次。外层循环运行 $N$ 次。\n因此，总求值次数 $C_{after}$ 为：\n$$C_{after} = \\sum_{i=0}^{N-1} 1 = N$$\n代入 $N=100$：\n$$C_{after} = 100$$\n\n**消除的求值次数：**\n优化所消除的动态求值总次数是优化前后次数之差。\n$$C_{eliminated} = C_{before} - C_{after} = 5050 - 100 = 4950$$\n从解析上讲，这可以表示为：\n$$C_{eliminated} = \\frac{N(N+1)}{2} - N = \\frac{N^2+N-2N}{2} = \\frac{N^2-N}{2} = \\frac{N(N-1)}{2}$$\n当 $N=100$ 时，这证实了结果：\n$$C_{eliminated} = \\frac{100(100-1)}{2} = \\frac{100 \\times 99}{2} = 50 \\times 99 = 4950$$\n该优化总共消除了表达式 $E(i)$ 的 $4950$ 次动态求值。", "answer": "$$\\boxed{4950}$$", "id": "3660080"}, {"introduction": "虽然 SSA 极大地简化了对标量变量的分析，但真实世界的程序充满了更复杂的挑战，例如带有副作用的函数调用。本练习将探讨一个常见的陷阱：当函数修改全局状态时，天真地应用公共子表达式消除（CSE）为何会导致错误。通过这个案例，你将理解为何需要更高级的模型（如内存 SSA 或效果摘要）来确保优化在处理内存和副作用时的安全性和正确性。[@problem_id:3660131]", "problem": "考虑一种语言，它有一个单一的全局整数位置 $H$ 和一个函数 $g(x)$，该函数既读取也写入 $H$。函数 $g(x)$ 的定义如下：它将 $H$ 的值增加 $1$，然后返回 $x + H$。一个程序片段如下：\n- $H := 0$\n- $t_1 := g(a)$\n- if $(c)$ then $H := 0$ end\n- $t_2 := g(a)$\n假设编译器为所有标量变量（例如 $a$, $t_1$, $t_2$, $c$）构建静态单赋值（SSA）形式，但最初不将内存置于 SSA 形式。一个优化器尝试使用值编号（value numbering）进行全局公共子表达式消除（CSE），该方法通过表达式的操作符及其操作数的值编号来为其建立键，并将函数调用视为一个黑盒操作，仅通过其被调用者和参数值编号来识别，除非另有说明。该优化器可以访问可选的效果摘要（effect summaries），当存在时，这些摘要会保守地描述一个函数可能读取或写入哪些内存位置。从第一性原理出发，使用以下事实作为基本依据：\n- 在 SSA 中，每个标量变量只被赋值一次，而支配关系（dominance）则捕捉了定义沿每条路径到达其所有使用点的情况。\n- 当两个计算是引用透明的（referentially transparent），并且在相同的抽象状态下具有相等的输入时，CSE 是正确的，这意味着它们会产生相等的结果而不改变可观察的行为。\n- 副作用（Side effects）会破坏引用透明性，并且对于读或写内存的操作来说，内存是一个隐式操作数。\n- 效果摘要保守地近似了可能读取（may-read）和可能写入（may-write）的集合，使优化能够将内存视为显式操作数。\n构建并分析上述案例，以确定在存在 $g$ 的副作用的情况下，关于消除对 $g(a)$ 的第二次调用或用 $t_1$ 重用 $t_2$ 的安全性，哪些陈述是正确的。选择所有适用的选项。\n\nA. 因为 $a$ 未改变且 $t_1$ 支配 $t_2$，忽略内存的、基于 SSA 的值编号可以安全地将 $t_2$ 替换为 $t_1$ 作为一次有效的 CSE。\n\nB. 使用一个表明 $g$ 可能读写 $H$ 的效果摘要，值编号必须在 $g(a)$ 的键中包含 $H$ 的一个内存版本 $M$；由于 $M$ 在两条调用之间的某些路径上有所不同，因此这些调用不能通过 CSE 合并。\n\nC. 如果性能剖析（profiling）显示带有 $H := 0$ 的分支很少被执行，优化器可以在正确性分析中忽略该分支，并仍然安全地将 $t_2$ 替换为 $t_1$。\n\nD. 在 SSA 中对内存建模（内存 SSA）或使用别名分析（alias analysis）将代表 $H$ 的内存操作数附加到 $g$ 上，可以防止将这两个调用归类为公共子表达式，从而避免不正确的消除。\n\nE. 仅凭 SSA 重命名，将第一个调用 $g(a)$ 重排到初始化语句 $H := 0$ 之上是安全的，因为 $a$ 和 $H$ 在 SSA 中有不同的名称，因此不会互相干扰。", "solution": "所提供问题陈述的有效性得到确认。它在科学上基于编译器优化的原理，问题提出得很好（well-posed），程序片段清晰可分析，并且术语客观。我们可以进行形式化分析。\n\n问题的核心是确定，对一个在全局内存位置 $H$ 上有副作用的函数 $g(x)$ 的两次调用，应用公共子表达式消除（CSE）是否安全。函数 $g(x)$ 的定义是执行两个动作：首先，它增加 $H$ 的值（$H := H + 1$），其次，它返回 $x + H$ 的值。\n\n让我们跟踪程序片段的执行以及全局变量 $H$ 的状态。\n\n1.  $H := 0$\n    内存位置 $H$ 处的整数值被设置为 $0$。\n\n2.  $t_1 := g(a)$\n    调用函数 $g(a)$。\n    - 在 $g$ 内部，$H$ 首先被增加。其值从 $0$ 变为 $0 + 1 = 1$。\n    - 然后，$g$ 返回 $a + H$，其计算结果为 $a + 1$。\n    - 变量 $t_1$ 被赋值为 $a + 1$。\n    - 此语句之后，全局状态是 $H$ 的值为 $1$。\n\n3.  `if (c) then H := 0 end`\n    此语句引入了一个条件分支，导致通往下一条语句有两条可能的控制流路径。\n    - **路径 1 (如果 $c$ 为真):** 执行语句 $H := 0$。$H$ 的值被重置为 $0$。\n    - **路径 2 (如果 $c$ 为假):** `then` 块被跳过。$H$ 的值保持为 $1$。\n\n4.  $t_2 := g(a)$\n    再次调用函数 $g(a)$。其结果取决于 `if` 语句走了哪条路径。\n    - **在路径 1 上：** 在此调用之前 $H$ 为 $0$。\n        - 在 $g$ 内部，$H$ 被增加到 $0 + 1 = 1$。\n        - $g$ 返回 $a + H$，其计算结果为 $a + 1$。\n        - $t_2$ 被赋值为 $a + 1$。\n    - **在路径 2 上：** 在此调用之前 $H$ 为 $1$。\n        - 在 $g$ 内部，$H$ 被增加到 $1 + 1 = 2$。\n        - $g$ 返回 $a + H$，其计算结果为 $a + 2$。\n        - $t_2$ 被赋值为 $a + 2$。\n\n总而言之，$t_1$ 的值始终是 $a + 1$。然而，如果 $c$ 为真，$t_2$ 的值是 $a + 1$，但如果 $c$ 为假，$t_2$ 的值是 $a + 2$。由于在至少一条执行路径上（$c$ 为假的路径）$t_1 \\ne t_2$，因此两个调用点处的表达式 $g(a)$ 在语义上是不等价的。所以，消除第二次调用并将 $t_2$ 替换为 $t_1$ 是一种不安全的优化，会改变程序的可观察行为。\n\n基于此分析，我们评估所提供的每个陈述。\n\n**A. 因为 $a$ 未改变且 $t_1$ 支配 $t_2$，忽略内存的、基于 SSA 的值编号可以安全地将 $t_2$ 替换为 $t_1$ 作为一次有效的 CSE。**\n这个陈述描述了一个天真的优化器的推理过程。变量 $a$ 在两次调用之间确实是循环不变的，且 $t_1$ 的定义支配了 $t_2$ 的定义。一个“忽略内存”的优化器会通过被调用者和参数 $a$ 的值编号来为两个函数调用建立键，即 $(g, \\text{value\\_number}(a))$。由于这些键是相同的，它会错误地将这两个调用识别为公共子表达式。陈述的核心缺陷在于声称这种替换是“安全”的。正如我们的跟踪所证明的，这是不安全的，因为它未能考虑对 $H$ 的副作用，而 $H$ 是 $g(a)$ 的一个隐式输入。副作用破坏引用透明性的原则被违反了。\n**结论：不正确。**\n\n**B. 使用一个表明 $g$ 可能读写 $H$ 的效果摘要，值编号必须在 $g(a)$ 的键中包含 $H$ 的一个内存版本 $M$；由于 $M$ 在两条调用之间的某些路径上有所不同，因此这些调用不能通过 CSE 合并。**\n这个陈述描述了一种正确的、更复杂的优化策略。效果摘要会告知优化器 $g(a)$ 会读写 $H$。为了正确应用 CSE，优化器必须将内存视为一个显式操作数。这通常通过使用内存版本或令牌来建模。\n- 设 $M_0$ 表示初始赋值后 $H=0$ 的内存状态。第一次调用 $g(a)$ 依赖于 $M_0$。\n- 这个调用产生一个新的内存状态 $M_1$，其中 $H=1$。\n- `if` 语句有条件地产生另一个状态 $M_2$，其中 $H=0$。\n- 第二次调用之前的内存状态 $M_3$ 是来自两条路径状态（$M_1$ 和 $M_2$）的合并。这个合并后的状态与初始状态 $M_0$ 是不同的。\n因为第一次调用的输入内存状态（$M_0$）与第二次调用的输入内存状态（$M_3$）不同，所以两次调用的值编号键将不同。因此，优化器将正确地得出结论，它们不是公共子表达式。\n**结论：正确。**\n\n**C. 如果性能剖析（profiling）显示带有 $H := 0$ 的分支很少被执行，优化器可以在正确性分析中忽略该分支，并仍然安全地将 $t_2$ 替换为 $t_1$。**\n这个陈述建议基于性能剖析数据为性能而牺牲健全性（soundness）。编译器正确性要求变换在所有可能的执行路径上都保持程序语义，而不仅仅是最频繁的路径。即使 $c$ 为真的路径很少见，声称正确的优化器也必须处理它。此外，即使在 $c$ 为假的“常见”路径上，我们的分析也显示 $t_1 = a + 1$ 而 $t_2 = a + 2$。因此，在该路径上替换也是不正确的。性能剖析可以指导推测性优化（speculative optimizations）（必须有恢复机制），但不能以“安全”和“正确”为名来为语义上不正确的变换辩护。\n**结论：不正确。**\n\n**D. 在 SSA 中对内存建模（内存 SSA）或使用别名分析（alias analysis）将代表 $H$ 的内存操作数附加到 $g$ 上，可以防止将这两个调用归类为公共子表达式，从而避免不正确的消除。**\n这个陈述描述了两种用于处理内存依赖的标准且健全的编译器框架。\n- **内存 SSA** 是 SSA 对内存的形式化扩展。它为内存状态赋予版本，并在连接点使用 $\\phi$-函数。正如对选项 B 的分析，第一次调用前的内存状态版本将不同于第二次调用前的 $\\phi$-版本，从而区分它们。\n- **带内存操作数的别名分析** 使对内存的依赖变得明确。别名分析识别出 $g$ 访问全局变量 $H$。然后编译器可以将调用建模为仿佛它接受了一个额外的、代表 $H$ 状态的不可见参数，例如 $t_1 := g(a, H_{\\text{in}})$。由于两次调用前 $H$ 的状态不同，因此调用不是相同的，也就不构成公共子表达式。\n两种方法都正确地防止了不安全的 CSE。\n**结论：正确。**\n\n**E. 仅凭 SSA 重命名，将第一个调用 $g(a)$ 重排到初始化语句 $H := 0$ 之上是安全的，因为 $a$ 和 $H$ 在 SSA 中有不同的名称，因此不会互相干扰。**\n这个陈述基于多方面原因是不正确的。首先，重排序是不安全的。原始序列是 $H := 0; t_1 := g(a);$。调用 $g(a)$ 读取了前一条语句写入的 $H$ 值。这构成了一个真正的数据依赖（写后读，或 RAW）。对具有真正依赖的语句进行重排序是非法的，因为它会改变程序语义。其次，其理由是无效的。问题明确指出内存*不*是 SSA 形式，所以 $H$ 没有 SSA 名称。即使有，SSA 重命名也是用于打破伪依赖（读后写和写后写），而不是真正依赖（写后读）。\n**结论：不正确。**", "answer": "$$\\boxed{BD}$$", "id": "3660131"}]}