{"hands_on_practices": [{"introduction": "本练习是理解静态单赋值（SSA）转换的基石。我们将通过一个具体的控制流图（CFG），手动应用经典的基于支配边界的算法，来确定$\\phi$函数的最小化放置位置。通过亲手构建支配树和计算支配边界，你将掌握推理和构建 SSA 形式的核心技能 ([@problem_id:3670674])。", "problem": "考虑一个过程的以下控制流图 (CFG)，其入口块为 $B_1$，出口块为 $B_8$。基本块之间的有向边如下：\n- $B_1 \\to B_2$, $B_1 \\to B_3$\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$, $B_3 \\to B_5$\n- $B_4 \\to B_6$\n- $B_5 \\to B_6$\n- $B_6 \\to B_2$, $B_6 \\to B_7$\n- $B_7 \\to B_8$\n\n每个块包含如下所示的直线代码，其中包含对变量 $x$ 和 $z$ 的赋值：\n- $B_1$: $x := 0$; $z := 0$\n- $B_2$: $x := x + 1$\n- $B_3$: $z := 1$\n- $B_4$: (没有对 $x$ 或 $z$ 的定义)\n- $B_5$: $x := 2$\n- $B_6$: $z := z + x$\n- $B_7$: (没有对 $x$ 或 $z$ 的定义)\n- $B_8$: (没有对 $x$ 或 $z$ 的定义)\n\n任务：\n- 构建以 $B_1$ 为根的 CFG 的支配树。\n- 计算每个块 $B_i$ 的支配边界 $\\mathrm{DF}(B_i)$，其中 $i \\in \\{1,2,3,4,5,6,7,8\\}$。\n- 使用经典的基于迭代支配边界的最小静态单赋值 (SSA) 形式构建方法 (Cytron et al.)，推导变量 $x$ 和 $z$ 的最小 $\\phi$-函数放置。假设遵循以下约定：不执行基于活跃性的剪枝，并且不在已经包含对某个变量定义的块中为该变量插入 $\\phi$-函数。\n\n最后，报告一个单一的数量：为变量 $x$ 和 $z$ 插入的 $\\phi$-函数的总数。请以整数形式提供答案。无需四舍五入，也无需单位。", "solution": "该问题是有效的，因为它是自包含的，在编译器理论中有科学依据，是适定且客观的。它提供了完整的控制流图 (CFG) 和变量定义，可以使用标准算法得到唯一解。\n\n解决方案需要三个主要步骤：\n1. 构建支配树。\n2. 计算所有基本块的支配边界。\n3. 应用迭代支配边界算法来确定 $\\phi$-函数的放置位置。\n\n### 第 1 步：支配树构建\n\n如果从入口块到块 $N$ 的每条路径都必须经过块 $D$，那么块 $D$ 支配块 $N$。块 $N$ 的直接支配者，记为 $\\mathrm{idom}(N)$，是 $N$ 的一个唯一的支配者，它不支配 $N$ 的任何其他支配者。支配树由所有块 $N$ (入口块除外) 的边 $(\\mathrm{idom}(N), N)$ 构成。入口块是 $B_1$。\n\n通过分析给定 CFG 中的路径：\n- $\\mathrm{dom}(B_1) = \\{B_1\\}$。\n- 任何到 $B_2$ 的路径都必须经过 $B_1$。路径可以是 $B_1 \\to B_2$ 或通过循环 $B_1 \\to \\dots \\to B_6 \\to B_2$。所有从入口到 $B_2$ 的路径都必须以 $B_1$ 开始。因此，$\\mathrm{dom}(B_2) = \\{B_1, B_2\\}$，并且 $\\mathrm{idom}(B_2) = B_1$。\n- 任何到 $B_3$ 的路径都必须是 $B_1 \\to B_3$。因此，$\\mathrm{dom}(B_3) = \\{B_1, B_3\\}$，并且 $\\mathrm{idom}(B_3) = B_1$。\n- 到 $B_4$ 的路径有 $B_1 \\to B_2 \\to B_4$ 和 $B_1 \\to B_3 \\to B_4$。在所有到 $B_4$ 的路径上，除了 $B_4$ 本身之外，唯一的公共块是 $B_1$。因此，$\\mathrm{dom}(B_4) = \\{B_1, B_4\\}$，并且 $\\mathrm{idom}(B_4) = B_1$。\n- 任何到 $B_5$ 的路径都必须经过 $B_3$ ($B_1 \\to B_3 \\to B_5$)。因此，$\\mathrm{dom}(B_5) = \\{B_1, B_3, B_5\\}$，并且 $\\mathrm{idom}(B_5) = B_3$。\n- 到 $B_6$ 的路径可以来自 $B_4$ 或 $B_5$。示例路径有 $B_1 \\to B_2 \\to B_4 \\to B_6$ 和 $B_1 \\to B_3 \\to B_5 \\to B_6$。从入口到 $B_6$ 的所有路径上的唯一公共块是 $B_1$。因此，$\\mathrm{dom}(B_6) = \\{B_1, B_6\\}$，并且 $\\mathrm{idom}(B_6) = B_1$。\n- 任何到 $B_7$ 的路径都必须来自 $B_6$。因此，$B_6$ 支配 $B_7$。由于 $B_1$ 支配 $B_6$，所以 $B_1$ 也支配 $B_7$。因此，$\\mathrm{dom}(B_7) = \\{B_1, B_6, B_7\\}$，并且 $\\mathrm{idom}(B_7) = B_6$。\n- 任何到 $B_8$ 的路径都必须来自 $B_7$。因此，$B_7$ 支配 $B_8$。传递性意味着 $B_6$ 和 $B_1$ 也支配 $B_8$。因此，$\\mathrm{dom}(B_8) = \\{B_1, B_6, B_7, B_8\\}$，并且 $\\mathrm{idom}(B_8) = B_7$。\n\n以 $B_1$ 为根的支配树由以下直接支配者关系定义：\n- $\\mathrm{idom}(B_2) = B_1$\n- $\\mathrm{idom}(B_3) = B_1$\n- $\\mathrm{idom}(B_4) = B_1$\n- $\\mathrm{idom}(B_5) = B_3$\n- $\\mathrm{idom}(B_6) = B_1$\n- $\\mathrm{idom}(B_7) = B_6$\n- $\\mathrm{idom}(B_8) = B_7$\n\n### 第 2 步：支配边界计算\n\n一个块 $X$ 的支配边界，记为 $\\mathrm{DF}(X)$，是所有满足以下条件的块 $Y$ 的集合：$X$ 支配 $Y$ 的一个前驱，但 $X$ 并不严格支配 $Y$。如果块 $X$ 支配 $Y$ 且 $X \\neq Y$，则称 $X$ 严格支配 $Y$。\n\n- $\\mathrm{DF}(B_1)$：$B_1$ 严格支配它所支配的每一个块（除了它自己）。不存在一个块 $Y$ 使得 $B_1$ 不严格支配它（除了 $Y=B_1$，它没有前驱）。因此，$\\mathrm{DF}(B_1) = \\emptyset$。\n- $\\mathrm{DF}(B_2)$：$B_2$ 支配 $B_4$ 的一个前驱（即 $B_2$ 本身）。但是，$B_2$ 并不严格支配 $B_4$（因为 $\\mathrm{idom}(B_4)=B_1$）。因此，$B_4 \\in \\mathrm{DF}(B_2)$。不存在其他这样的块。$\\mathrm{DF}(B_2) = \\{B_4\\}$。\n- $\\mathrm{DF}(B_3)$:\n    - 对于 $Y=B_4$，$B_3 \\in \\mathrm{pred}(B_4)$，且 $B_3$ 支配其自身。$B_3$ 并不严格支配 $B_4$。因此，$B_4 \\in \\mathrm{DF}(B_3)$。\n    - 对于 $Y=B_6$，$B_5 \\in \\mathrm{pred}(B_6)$。$B_3$ 支配 $B_5$。$B_3$ 并不严格支配 $B_6$。因此，$B_6 \\in \\mathrm{DF}(B_3)$。\n    - $\\mathrm{DF}(B_3) = \\{B_4, B_6\\}$。\n- $\\mathrm{DF}(B_4)$：$B_4 \\in \\mathrm{pred}(B_6)$。$B_4$ 支配其自身。$B_4$ 并不严格支配 $B_6$。因此，$B_6 \\in \\mathrm{DF}(B_4)$。$\\mathrm{DF}(B_4) = \\{B_6\\}$。\n- $\\mathrm{DF}(B_5)$：$B_5 \\in \\mathrm{pred}(B_6)$。$B_5$ 支配其自身。$B_5$ 并不严格支配 $B_6$。因此，$B_6 \\in \\mathrm{DF}(B_5)$。$\\mathrm{DF}(B_5) = \\{B_6\\}$。\n- $\\mathrm{DF}(B_6)$：由于后向边，$B_6 \\in \\mathrm{pred}(B_2)$。$B_6$ 支配其自身。$B_6$ 并不严格支配 $B_2$。因此，$B_2 \\in \\mathrm{DF}(B_6)$。$B_6$ 严格支配它的另一个后继 $B_7$。$\\mathrm{DF}(B_6) = \\{B_2\\}$。\n- $\\mathrm{DF}(B_7)$：$B_7$ 的唯一后继是 $B_8$，并且 $B_7$ 严格支配 $B_8$。因此，$\\mathrm{DF}(B_7) = \\emptyset$。\n- $\\mathrm{DF}(B_8)$：该块没有后继。因此，$\\mathrm{DF}(B_8) = \\emptyset$。\n\n支配边界总结：\n- $\\mathrm{DF}(B_1) = \\emptyset$\n- $\\mathrm{DF}(B_2) = \\{B_4\\}$\n- $\\mathrm{DF}(B_3) = \\{B_4, B_6\\}$\n- $\\mathrm{DF}(B_4) = \\{B_6\\}$\n- $\\mathrm{DF}(B_5) = \\{B_6\\}$\n- $\\mathrm{DF}(B_6) = \\{B_2\\}$\n- $\\mathrm{DF}(B_7) = \\emptyset$\n- $\\mathrm{DF}(B_8) = \\emptyset$\n\n### 第 3 步：最小 $\\phi$-函数放置\n\n我们使用迭代支配边界 (IDF) 算法。对于每个变量 $v$，我们计算需要 $\\phi$-函数的块的集合 $\\Phi_v$。该算法如下：\n1. 初始化集合 $\\Phi_v = \\emptyset$ 和一个工作列表 $W$，其中包含所有对 $v$ 有初始定义的块。令这个块的集合为 $\\mathrm{Defs}_v$。\n2. 当 $W$ 不为空时，从 $W$ 中取出一个块 $N$。\n3. 对于每个块 $Y \\in \\mathrm{DF}(N)$：如果 $Y \\notin \\Phi_v$ 并且，根据题目约束，$Y \\notin \\mathrm{Defs}_v$，则将 $Y$ 添加到 $\\Phi_v$ 和工作列表 $W$ 中。\n\n**变量 $x$**：\n- 有初始定义的块的集合是 $\\mathrm{Defs}_x = \\{B_1, B_2, B_5\\}$。\n- 初始化：$\\Phi_x = \\emptyset$, $W = \\{B_1, B_2, B_5\\}$。\n- 弹出 $B_1$：$\\mathrm{DF}(B_1) = \\emptyset$。$W = \\{B_2, B_5\\}$。\n- 弹出 $B_2$：$\\mathrm{DF}(B_2) = \\{B_4\\}$。$B_4 \\notin \\mathrm{Defs}_x$ 且 $B_4 \\notin \\Phi_x$。将 $B_4$ 添加到 $\\Phi_x$ 和 $W$。$\\Phi_x = \\{B_4\\}$, $W = \\{B_5, B_4\\}$。\n- 弹出 $B_5$：$\\mathrm{DF}(B_5) = \\{B_6\\}$。$B_6 \\notin \\mathrm{Defs}_x$ 且 $B_6 \\notin \\Phi_x$。将 $B_6$ 添加到 $\\Phi_x$ 和 $W$。$\\Phi_x = \\{B_4, B_6\\}$, $W = \\{B_4, B_6\\}$。\n- 弹出 $B_4$：$\\mathrm{DF}(B_4) = \\{B_6\\}$。$B_6 \\in \\Phi_x$。无变化。$W = \\{B_6\\}$。\n- 弹出 $B_6$：$\\mathrm{DF}(B_6) = \\{B_2\\}$。$B_2 \\in \\mathrm{Defs}_x$。根据题目约束，不添加 $\\phi$-函数。无变化。$W = \\emptyset$。\n- 工作列表为空。变量 $x$ 的最终放置集合为 $\\Phi_x = \\{B_4, B_6\\}$。\n- 变量 $x$ 的 $\\phi$-函数数量：$|\\Phi_x| = 2$。\n\n**变量 $z$**：\n- 有初始定义的块的集合是 $\\mathrm{Defs}_z = \\{B_1, B_3, B_6\\}$。\n- 初始化：$\\Phi_z = \\emptyset$, $W = \\{B_1, B_3, B_6\\}$。\n- 弹出 $B_1$：$\\mathrm{DF}(B_1) = \\emptyset$。$W = \\{B_3, B_6\\}$。\n- 弹出 $B_3$：$\\mathrm{DF}(B_3) = \\{B_4, B_6\\}$。\n    - 对于 $B_4$：$B_4 \\notin \\mathrm{Defs}_z$ 且 $B_4 \\notin \\Phi_z$。将 $B_4$ 添加到 $\\Phi_z$ 和 $W$。$\\Phi_z = \\{B_4\\}$, $W = \\{B_6, B_4\\}$。\n    - 对于 $B_6$：$B_6 \\in \\mathrm{Defs}_z$。不添加 $\\phi$-函数。\n- 弹出 $B_6$：$\\mathrm{DF}(B_6) = \\{B_2\\}$。$B_2 \\notin \\mathrm{Defs}_z$ 且 $B_2 \\notin \\Phi_z$。将 $B_2$ 添加到 $\\Phi_z$ 和 $W$。$\\Phi_z = \\{B_4, B_2\\}$, $W = \\{B_4, B_2\\}$。\n- 弹出 $B_4$：$\\mathrm{DF}(B_4) = \\{B_6\\}$。$B_6 \\in \\mathrm{Defs}_z$。不添加 $\\phi$-函数。$W = \\{B_2\\}$。\n- 弹出 $B_2$：$\\mathrm{DF}(B_2) = \\{B_4\\}$。$B_4 \\in \\Phi_z$。无变化。$W = \\emptyset$。\n- 工作列表为空。变量 $z$ 的最终放置集合为 $\\Phi_z = \\{B_2, B_4\\}$。\n- 变量 $z$ 的 $\\phi$-函数数量：$|\\Phi_z| = 2$。\n\n### 第 4 步：最终计算\n\n插入的 $\\phi$-函数总数是每个变量的计数之和。\n$\\phi$-函数总数 = ($x$ 的数量) + ($z$ 的数量) = $2 + 2 = 4$。\n所需的 $\\phi$-函数为：\n- 对于 $x$：在 $B_4$ 和 $B_6$ 中。\n- 对于 $z$：在 $B_2$ 和 $B_4$ 中。\n\n总数为 $4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3670674"}, {"introduction": "经典的 SSA 构建算法有时会插入一些不必要的$\\phi$函数，因为其对应的变量在程序中实际上是“死的”（dead）。本练习将探讨如何通过结合活性分析（liveness analysis）来构建一种更高效的“剪枝 SSA”（pruned SSA）形式。你将比较经典方法与剪枝方法的$\\phi$函数安插结果，从而深入理解编译器如何避免生成无用代码，并体会不同活性分析策略带来的细微差别 ([@problem_id:3670701])。", "problem": "考虑将一个程序转换为静态单赋值 (SSA) 形式的任务，其中每个变量只被赋值一次，并且 $\\phi$ 函数在连接点合并来自多个前驱的值。请使用以下基本定义作为您推理的基础。\n\n- 控制流图 (CFG) 是一个有向图，其节点是基本块，其边代表块之间可能的控制流。如果从入口到节点 $n$ 的每条路径都包含节点 $d$，则称节点 $d$ 支配节点 $n$。节点 $d$ 的支配边界 (DF) 是这样一组节点 $n$：$d$ 支配 $n$ 的一个前驱，但 $d$ 并不严格支配 $n$。\n- 在通过迭代支配边界的经典 SSA 构建方法中，对于一个变量 $v$，$\\phi$ 函数被插入到包含对 $v$ 赋值的块的 DF 中，并根据需要对新插入的 $\\phi$ 定义进行迭代，直到达到不动点。\n- 剪枝 SSA (Pruned SSA) 会移除那些位于变量 $v$ 在原始程序中不是活跃引入 (live-in) 的块中的 $\\phi$ 函数。如果从某点存在一条到变量 $v$ 的使用的路径，并且在该路径上 $v$ 在使用前没有被重定义，那么 $v$ 在该点是活跃引入的。\n- 考虑一个保守的基于活跃度的剪枝变体，它通过将 $v$ 视为在某个块中是活跃引入的（只要存在从该块到 $v$ 的使用的任何路径）来过近似 $v$ 的活跃度，而忽略了中间的重定义。此变体可能会保留一些被剪枝 SSA 移除的 $\\phi$ 函数。\n\n给定以下 CFG（条件 $p$、$q$、$r$ 是任意布尔表达式；控制边由“goto”转移指定）：\n\n- 块 $B_0$：入口；goto $B_1$。\n- 块 $B_1$：if $p$ then goto $B_2$ else goto $B_3$。\n- 块 $B_2$：$x := 1$; $y := 1$; goto $B_4$。\n- 块 $B_3$：if $q$ then goto $B_5$ else goto $B_6$。\n- 块 $B_5$：$x := 2$; goto $B_4$。\n- 块 $B_6$：$y := 3$; goto $B_4$。\n- 块 $B_4$：$B_2$、$B_5$、$B_6$ 的连接点；goto $B_7$。\n- 块 $B_7$：$y := 4$; if $r$ then goto $B_8$ else goto $B_9$。\n- 块 $B_8$：$x := 5$; $t := x + 1$; goto $B_{10}$。\n- 块 $B_9$：$u := x$; goto $B_{10}$。\n- 块 $B_{10}$：$w := y + 1$; exit。\n\n观察到：\n- 在 $B_2$ 和 $B_6$ 中对 $y$ 的赋值，在任何使用之前，都会在 $B_7$ 中被无条件重定义为 $y := 4$，这使得早期对 $y$ 的赋值成为死亡赋值。因此，$y$ 在 $B_2$ 和 $B_6$ 中有部分死亡赋值。\n- 在 $B_2$ 和 $B_5$ 中对 $x$ 的赋值，在 $B_4 \\rightarrow B_7 \\rightarrow B_9$ 路径上被使用，但在 $B_4 \\rightarrow B_7 \\rightarrow B_8$ 路径上被 $B_8$ 中的赋值重定义。因此，$x$ 有部分死亡赋值。\n\n仅使用上述定义，并从关于支配、支配边界和活跃度的基本原理进行推理：\n- 推导出由经典迭代支配边界方法为 $x$ 和 $y$ 生成的 $\\phi$-插入块集合。将这些集合表示为 $S_x^{\\mathrm{DF}}$ 和 $S_y^{\\mathrm{DF}}$。\n- 使用精确活跃度（即考虑重定义的活跃度）推导出 $x$ 和 $y$ 的剪枝 SSA 的 $\\phi$-插入块集合。将这些集合表示为 $S_x^{\\mathrm{pruned}}$ 和 $S_y^{\\mathrm{pruned}}$。\n- 推导出保守的基于活跃度的剪枝变体为 $x$ 和 $y$ 生成的 $\\phi$-插入块集合（即使用在从使用点传播时忽略重定义的过近似活跃度）。将这些集合表示为 $S_x^{\\mathrm{live}}$ 和 $S_y^{\\mathrm{live}}$。\n\n证明对于上述 CFG，$S_x^{\\mathrm{live}} = S_x^{\\mathrm{pruned}}$ 但 $S_y^{\\mathrm{live}} \\neq S_y^{\\mathrm{pruned}}$。最后，计算标量\n$$E = \\left|S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}}\\right| + \\left|S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}}\\right|$$\n以单个整数形式提供 $E$。无需四舍五入。无需单位。", "solution": "用户希望分析一个控制流图 (CFG)，并使用三种方法确定变量 $x$ 和 $y$ 的 $\\phi$-函数放置位置：经典的迭代支配边界 (DF) 法、剪枝 SSA 法以及一种保守的基于活跃度的剪枝变体。最后，必须计算一个基于剪枝后集合之间差异的标量值 $E$。\n\n这个问题是有效的，因为它定义明确，具有编译器理论的科学基础，并且是自包含的。我将按照以下步骤进行求解：\n1.  分析 CFG 以确定支配关系和支配边界 (DF)。\n2.  应用迭代 DF 算法找到初始的 $\\phi$-插入集合，$S_x^{\\mathrm{DF}}$ 和 $S_y^{\\mathrm{DF}}$。\n3.  对 $x$ 和 $y$ 进行精确活跃度分析，以推导出剪枝后的集合 $S_x^{\\mathrm{pruned}}$ 和 $S_y^{\\mathrm{pruned}}$。\n4.  进行保守的活跃度分析，以推导出集合 $S_x^{\\mathrm{live}}$ 和 $S_y^{\\mathrm{live}}$。\n5.  比较结果并计算 $E$ 的值。\n\n**步骤 1：支配和支配边界分析**\n\nCFG 的结构是已知的。首先，我们确定每个基本块的支配者。如果从入口块 ($B_0$) 到块 $n$ 的每条路径都必须经过块 $d$，则块 $d$ 支配块 $n$。根据 CFG，直接支配者 (`idom`) 如下：\n- $\\mathrm{idom}(B_1) = B_0$\n- $\\mathrm{idom}(B_2) = B_1$\n- $\\mathrm{idom}(B_3) = B_1$\n- $\\mathrm{idom}(B_4) = B_1$\n- $\\mathrm{idom}(B_5) = B_3$\n- $\\mathrm{idom}(B_6) = B_3$\n- $\\mathrm{idom}(B_7) = B_4$\n- $\\mathrm{idom}(B_8) = B_7$\n- $\\mathrm{idom}(B_9) = B_7$\n- $\\mathrm{idom}(B_{10}) = B_7$\n\n节点 $d$ 的支配边界 $\\mathrm{DF}(d)$ 是所有节点 $n$ 的集合，使得 $d$ 支配 $n$ 的一个前驱，但 $d$ 并不严格支配 $n$。我们需要包含对 $x$ 或 $y$ 原始赋值的块的 DF。这些块是 $B_2, B_5, B_6, B_7, B_8$。\n- $\\mathrm{DF}(B_2) = \\{B_4\\}$：$B_2$ 支配其自身（$B_4$ 的一个前驱），但并不严格支配 $B_4$。\n- $\\mathrm{DF}(B_5) = \\{B_4\\}$：$B_5$ 支配其自身（$B_4$ 的一个前驱），但并不严格支配 $B_4$。\n- $\\mathrm{DF}(B_6) = \\{B_4\\}$：$B_6$ 支配其自身（$B_4$ 的一个前驱），但并不严格支配 $B_4$。\n- $\\mathrm{DF}(B_7) = \\{B_{10}\\}$：$B_7$ 支配其后继 $B_8$ 和 $B_9$（$B_{10}$ 的前驱），但 $B_7$ 并不严格支配 $B_{10}$（它是直接支配者）。连接点在 $B_{10}$。\n- $\\mathrm{DF}(B_8) = \\{B_{10}\\}$：$B_8$ 支配其自身（$B_{10}$ 的一个前驱），但并不严格支配 $B_{10}$。\n- 对于迭代算法，我们还需要新 $\\phi$-函数所在块的 DF：\n- $\\mathrm{DF}(B_4) = \\{B_{10}\\}$：$B_4$ 支配 $B_7$，$B_7$ 的后继 $B_8$ 和 $B_9$ 导向连接点 $B_{10}$。$B_4$ 并不严格支配 $B_{10}$。\n- $\\mathrm{DF}(B_{10}) = \\emptyset$。\n\n**步骤 2：经典迭代支配边界 ($S_x^{\\mathrm{DF}}$, $S_y^{\\mathrm{DF}}$)**\n\n我们通过从包含对变量 $v$ 赋值的节点集开始，迭代地将这些节点的支配边界添加到一个工作列表中，直到达到不动点，从而计算出 $v$ 的 $\\phi$-插入节点集。\n\n对于变量 $x$：\n包含原始赋值的块集合是 $A_x = \\{B_2, B_5, B_8\\}$。\n1.  我们计算 DF 的初始块集合是 $A_x$。\n2.  $\\mathrm{DF}(B_2) \\cup \\mathrm{DF}(B_5) \\cup \\mathrm{DF}(B_8) = \\{B_4\\} \\cup \\{B_4\\} \\cup \\{B_{10}\\} = \\{B_4, B_{10}\\}$。令其为 $P_1 = \\{B_4, B_{10}\\}$。\n3.  现在对 $P_1$ 中的新定义进行迭代。$\\mathrm{DF}(B_4) \\cup \\mathrm{DF}(B_{10}) = \\{B_{10}\\} \\cup \\emptyset = \\{B_{10}\\}$。\n4.  这没有向我们的 $\\phi$-节点集合中添加任何新块。过程已达到不动点。\n插入块的集合是 $S_x^{\\mathrm{DF}} = P_1 = \\{B_4, B_{10}\\}$。\n\n对于变量 $y$：\n包含原始赋值的块集合是 $A_y = \\{B_2, B_6, B_7\\}$。\n1.  初始块集合是 $A_y$。\n2.  $\\mathrm{DF}(B_2) \\cup \\mathrm{DF}(B_6) \\cup \\mathrm{DF}(B_7) = \\{B_4\\} \\cup \\{B_4\\} \\cup \\{B_{10}\\} = \\{B_4, B_{10}\\}$。令其为 $P_1 = \\{B_4, B_{10}\\}$。\n3.  对 $P_1$ 进行迭代：$\\mathrm{DF}(B_4) \\cup \\mathrm{DF}(B_{10}) = \\{B_{10}\\} \\cup \\emptyset = \\{B_{10}\\}$。\n4.  没有新块被添加。过程终止。\n插入块的集合是 $S_y^{\\mathrm{DF}} = P_1 = \\{B_4, B_{10}\\}$。\n\n**步骤 3：剪枝 SSA ($S_x^{\\mathrm{pruned}}$, $S_y^{\\mathrm{pruned}}$)**\n\n如果变量在块 $B$ 中不是活跃引入的，剪枝 SSA 会从该块中移除 $\\phi$-函数。我们执行一个标准的反向活跃度分析。如果一个变量的值可能在后继块或之后的某条路径上被读取，则该变量在一个块中是活跃引入的。\n\n对于变量 $x$：\n- $x$ 的向上暴露使用：$B_9$ 中的 $u := x$。$B_8$ 中的使用 ($t := x + 1$) 不是向上暴露的，因为它前面有同一块中的定义 ($x := 5$)。所以，$\\mathrm{use}_x(B_9) = \\{x\\}$。\n- $x$ 的定义：$\\mathrm{def}_x(B_2) = \\{x\\}$, $\\mathrm{def}_x(B_5) = \\{x\\}$, $\\mathrm{def}_x(B_8) = \\{x\\}$。\n- 活跃度计算（从 $B_9$ 反向流动）：\n  - $x$ 在 $B_9$ 中是活跃引入的。\n  - 这使得 $x$ 在 $B_7$ 中是活跃引出的。由于 $B_7$ 没有重定义 $x$，所以 $x$ 在 $B_7$ 中是活跃引入的。\n  - 这使得 $x$ 在 $B_4$ 中是活跃引出的。由于 $B_4$ 没有重定义 $x$，所以 $x$ 在 $B_4$ 中是活跃引入的。\n  - $x$ 的活跃度从 $B_4$ 反向传播到其前驱 $B_2, B_5, B_6$。\n  - 在 $B_2$ 和 $B_5$ 中，$x$ 被重定义，所以活跃度被杀死（$x$ 在 $B_2$ 或 $B_5$ 中不是活跃引入的）。\n  - 在 $B_6$ 中，$x$ 没有被重定义，所以 $x$ 是活跃引入的。\n  - 活跃度从 $B_2, B_3, \\dots$ 向上传播到入口。\n$x$ 是活跃引入的块的集合是 $\\{B_0, B_1, B_3, B_4, B_6, B_7, B_9\\}$。\n- 对 $S_x^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$ 进行剪枝：\n  - $x$ 在 $B_4$ 中是活跃引入的吗？是。我们保留这个 $\\phi$-函数。\n  - $x$ 在 $B_{10}$ 中是活跃引入的吗？否。我们剪枝这个 $\\phi$-函数。\n- 因此，$S_x^{\\mathrm{pruned}} = \\{B_4\\}$。\n\n对于变量 $y$：\n- $y$ 的向上暴露使用：$B_{10}$ 中的 $w := y + 1$。所以，$\\mathrm{use}_y(B_{10}) = \\{y\\}$。\n- $y$ 的定义：$\\mathrm{def}_y(B_2) = \\{y\\}$, $\\mathrm{def}_y(B_6) = \\{y\\}$, $\\mathrm{def}_y(B_7) = \\{y\\}$。\n- 活跃度计算（从 $B_{10}$ 反向流动）：\n  - $y$ 在 $B_{10}$ 中是活跃引入的。\n  - 这使得 $y$ 在其前驱 $B_8$ 和 $B_9$ 中是活跃引出的。由于两者都没有重定义 $y$，所以 $y$ 在 $B_8$ 和 $B_9$ 中都是活跃引入的。\n  - 这使得 $y$ 在 $B_7$ 中是活跃引出的。然而，$B_7$ 包含一个定义 $y := 4$，它杀死了活跃度。因此，$y$ 在 $B_7$ 中不是活跃引入的。\n  - 因为活跃度在 $B_7$ 被杀死，所以它不会再向上游的 CFG 传播。$y$ 在 $B_4$ 或其任何前驱中都不是活跃引入的。\n$y$ 是活跃引入的块的集合是 $\\{B_8, B_9, B_{10}\\}$。\n- 对 $S_y^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$ 进行剪枝：\n  - $y$ 在 $B_4$ 中是活跃引入的吗？否。我们剪枝这个 $\\phi$-函数。\n  - $y$ 在 $B_{10}$ 中是活跃引入的吗？是。我们保留这个 $\\phi$-函数。\n- 因此，$S_y^{\\mathrm{pruned}} = \\{B_{10}\\}$。\n\n**步骤 4：保守的基于活跃度的剪枝 ($S_x^{\\mathrm{live}}$, $S_y^{\\mathrm{live}}$)**\n\n该变体认为，如果存在从块 $B$ 到变量 $v$ 使用点的任何路径，就认为 $v$ 在 $B$ 中是活跃引入的，并忽略重定义。\n\n对于变量 $x$：\n- $x$ 的使用在块 $B_8$ 和 $B_9$ 中。\n- 对 $S_x^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$ 进行剪枝：\n  - 在 $B_4$：存在从 $B_4$ 到 $x$ 使用点的路径（例如，$B_4 \\rightarrow B_7 \\rightarrow B_9$）。因此，$x$ 被认为是活跃引入的。我们保留这个 $\\phi$-函数。\n  - 在 $B_{10}$：没有从 $B_{10}$ 到 $x$ 使用点（$B_8$ 或 $B_9$）的路径。因此，$x$ 不是活跃引入的。我们剪枝这个 $\\phi$-函数。\n- 因此，$S_x^{\\mathrm{live}} = \\{B_4\\}$。\n\n对于变量 $y$：\n- $y$ 的使用在块 $B_{10}$ 中。\n- 对 $S_y^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$ 进行剪枝：\n  - 在 $B_4$：存在从 $B_4$ 到 $y$ 使用点的路径（例如，$B_4 \\rightarrow B_7 \\rightarrow B_8 \\rightarrow B_{10}$）。$B_7$ 中的重定义被忽略。因此，$y$ 被认为是活跃引入的。我们保留这个 $\\phi$-函数。\n  - 在 $B_{10}$：这是包含使用的块，所以存在一条长度为 0 的平凡路径。$y$ 是活跃引入的。我们保留这个 $\\phi$-函数。\n- 因此，$S_y^{\\mathrm{live}} = \\{B_4, B_{10}\\}$。\n\n**步骤 5：比较和最终计算**\n\n我们现在总结结果并计算 $E$。\n- 对于 $x$：$S_x^{\\mathrm{pruned}} = \\{B_4\\}$ 且 $S_x^{\\mathrm{live}} = \\{B_4\\}$。因此，$S_x^{\\mathrm{live}} = S_x^{\\mathrm{pruned}}$。\n- 对于 $y$：$S_y^{\\mathrm{pruned}} = \\{B_{10}\\}$ 且 $S_y^{\\mathrm{live}} = \\{B_4, B_{10}\\}$。因此，$S_y^{\\mathrm{live}} \\neq S_y^{\\mathrm{pruned}}$。该不等式成立，因为对 $y$ 的保守活跃度分析忽略了 $B_7$ 中的重定义 $y := 4$，导致它错误地认为 $y$ 在 $B_4$ 中是活跃引入的，从而未能剪枝那里的 $\\phi$-函数。\n\n最后，我们计算标量 $E$：\n$$ E = \\left|S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}}\\right| + \\left|S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}}\\right| $$\n- $S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}} = \\{B_4\\} \\setminus \\{B_4\\} = \\emptyset$。所以 $\\left|S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}}\\right| = 0$。\n- $S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}} = \\{B_4, B_{10}\\} \\setminus \\{B_{10}\\} = \\{B_4\\}$。所以 $\\left|S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}}\\right| = 1$。\n\n$$ E = 0 + 1 = 1 $$", "answer": "$$\n\\boxed{1}\n$$", "id": "3670701"}, {"introduction": "SSA 是一种中间表示（IR），编译器最终需要将其转换回线性的机器码。本练习聚焦于 SSA “解构”的最后一步：如何将$\\phi$函数转换成一系列的机器指令（如 `mov`）。你将直面并解决“并行复制”（parallel copy）问题，学习如何处理在这一关键阶段出现的循环依赖，从而将抽象的$\\phi$函数落地为具体的代码 ([@problem_id:3670685])。", "problem": "给定一个控制流图，其中有三个前驱块 $B_1$、$B_2$、$B_3$ 汇合到一个汇合块 $J$。程序处于静态单赋值（SSA）形式，并且 $J$ 包含四个定义了 $a_4$、$b_4$、$c_4$ 和 $d_4$ 的 $\\phi$-函数。寄存器分配后，以下寄存器赋值成立：\n\n- 在 $J$ 的入口处，目标赋值如下：$a_4$ 在 $r_1$ 中，$b_4$ 在 $r_2$ 中，$c_4$ 在 $r_3$ 中，$d_4$ 在 $r_4$ 中。\n- 在 $B_1$ 的出口处，活跃的 SSA 名字位于寄存器中：$a_1$ 在 $r_2$ 中，$b_1$ 在 $r_3$ 中，$c_1$ 在 $r_4$ 中，$d_1$ 在 $r_1$ 中。\n- 在 $B_2$ 的出口处，活跃的 SSA 名字位于寄存器中：$a_2$ 在 $r_1$ 中，$b_2$ 在 $r_4$ 中，$c_2$ 在 $r_2$ 中，$d_2$ 在 $r_3$ 中。\n- 在 $B_3$ 的出口处，活跃的 SSA 名字位于寄存器中：$a_3$ 在 $r_3$ 中，$b_3$ 在 $r_2$ 中，$c_3$ 在 $r_1$ 中，$d_3$ 在 $r_4$ 中。\n\n$J$ 中的 $\\phi$-函数如下：\n- $a_4 := \\phi(B_1: a_1, B_2: a_2, B_3: a_3)$\n- $b_4 := \\phi(B_1: b_1, B_2: b_2, B_3: b_3)$\n- $c_4 := \\phi(B_1: c_1, B_2: c_2, B_3: c_3)$\n- $d_4 := \\phi(B_1: d_1, B_2: d_2, B_3: d_3)$\n\n要转换出 SSA 形式，你必须在每个前驱块的末尾插入一个单一的并行复制操作，该操作实现所有以 $J$ 为目标的 $\\phi$ 参数。并行复制是一组赋值，其行为必须如同它们是同时发生的一样。\n\n你需要通过将每个并行复制替换为一系列形式为 mov dest, src 的寄存器到寄存器移动指令来重构非 SSA 代码，同时保持并行复制的语义。每条边上你最多可以使用一个临时寄存器 $t$（不同于 $r_1$、$r_2$、$r_3$、$r_4$），并且你不能插入任何不必要的移动指令。一个恒等赋值（例如，$r_2 := r_2$）不应被生成为一条移动指令。\n\n假设没有其他约束（例如，没有内存溢出，并且在边的结尾代码段内有无限的指令调度自由度），在所有三条边 $B_1 \\to J$、$B_2 \\to J$ 和 $B_3 \\to J$ 上必须插入的移动指令的最小总数是多少？请以整数形式作答。", "solution": "任务是确定在一个特定的汇合点将程序从静态单赋值（SSA）形式转换出来所需的最少寄存器到寄存器 `mov` 指令的总数。这种转换涉及在通向汇合块的控制流边上插入移动指令，以实现 $\\phi$-函数的语义。\n\n解决并行复制 `(d_1, d_2, ..., d_n) := (s_1, s_2, ..., s_n)`（其中 `$d_i$` 是目标寄存器，`$s_i$` 是源寄存器）的通用方法是将其建模为一个有向图。图的节点是寄存器，一条从 `$u$` 到 `$v$` 的有向边（`$u \\to v$`）代表赋值 `$v := u$`。该图可以被划分为不相交的路径和环。\n- 一个恒等赋值（`$d_i := d_i$`）对应一个自环（`$r \\to r$`），需要 `$0$` 次移动。\n- 一组形成路径的赋值可以通过与赋值数量相等的移动次数来解决。\n- 一组形成长度为 `$k > 1$` 的环的赋值需要一个临时寄存器来打破该环。解决这样一个环所需的最少移动次数是 `$k+1$`。\n\n我们将分析三个前驱块 `$B_1, B_2, B_3$` 各自所需的并行复制。\n\n### 边 $B_1 \\to J$\n\n汇合块 `$J$` 处的 $\\phi$-函数指定了来自 `$B_1$` 的哪些 SSA 名字为新的 SSA 名字 `$a_4, b_4, c_4, d_4$` 提供值。`$J$` 入口处和 `$B_1$` 出口处的寄存器分配定义了所需的寄存器到寄存器传输。\n\n- 在 `$J$` 入口处：`$a_4$` 在 `$r_1$` 中，`$b_4$` 在 `$r_2$` 中，`$c_4$` 在 `$r_3$` 中，`$d_4$` 在 `$r_4$` 中。\n- 来自 `$B_1$` 的 $\\phi$-函数：`$a_4 \\leftarrow a_1, b_4 \\leftarrow b_1, c_4 \\leftarrow c_1, d_4 \\leftarrow d_1$`。\n- 在 `$B_1$` 出口处：`$a_1$` 在 `$r_2$` 中，`$b_1$` 在 `$r_3$` 中，`$c_1$` 在 `$r_4$` 中，`$d_1$` 在 `$r_1$` 中。\n\n综合这些信息，我们推导出边 `$B_1 \\to J$` 上所需的并行复制：\n- 为了将 `$a_1$` 移入 `$r_1$`（`$a_4$` 必须在的位置），我们需要 `$r_1 := r_2$`。\n- 为了将 `$b_1$` 移入 `$r_2$`（`$b_4$` 必须在的位置），我们需要 `$r_2 := r_3$`。\n- 为了将 `$c_1$` 移入 `$r_3$`（`$c_4$` 必须在的位置），我们需要 `$r_3 := r_4$`。\n- 为了将 `$d_1$` 移入 `$r_4$`（`$d_4$` 必须在的位置），我们需要 `$r_4 := r_1$`。\n\n这些移动的依赖图包含边 `$r_2 \\to r_1$`、`$r_3 \\to r_2$`、`$r_4 \\to r_3$` 和 `$r_1 \\to r_4$`。它们形成了一个长度为 `$k=4$` 的单一环：`$r_1 \\to r_4 \\to r_3 \\to r_2 \\to r_1$`。使用一个临时寄存器 `$t$`，这个环可以用 `$k+1 = 4+1 = 5$` 次移动来打破。例如：\n1. `mov t, r_1`\n2. `mov r_1, r_2`\n3. `mov r_2, r_3`\n4. `mov r_3, r_4`\n5. `mov r_4, t`\n边 `$B_1 \\to J$` 的移动次数是 `$5$`。\n\n### 边 $B_2 \\to J$\n\n- 来自 `$B_2$` 的 $\\phi$-函数：`$a_4 \\leftarrow a_2, b_4 \\leftarrow b_2, c_4 \\leftarrow c_2, d_4 \\leftarrow d_2$`。\n- 在 `$B_2$` 出口处：`$a_2$` 在 `$r_1$` 中，`$b_2$` 在 `$r_4$` 中，`$c_2$` 在 `$r_2$` 中，`$d_2$` 在 `$r_3$` 中。\n\n边 `$B_2 \\to J$` 上所需的并行复制是：\n- `$r_1 := r_1$` (对于 `$a_4 \\leftarrow a_2$`)\n- `$r_2 := r_4$` (对于 `$b_4 \\leftarrow b_2$`)\n- `$r_3 := r_2$` (对于 `$c_4 \\leftarrow c_2$`)\n- `$r_4 := r_3$` (对于 `$d_4 \\leftarrow d_2$`)\n\n这些移动的依赖图包含：\n- 一个自环 `$r_1 \\to r_1$`，这是一个恒等赋值，需要 `$0$` 次移动。\n- 一个长度为 `$k=3$` 的环：`$r_2 \\to r_3 \\to r_4 \\to r_2$`。这需要 `$k+1 = 3+1 = 4$` 次移动。\n边 `$B_2 \\to J$` 的总移动次数是 `$0 + 4 = 4$`。\n\n### 边 $B_3 \\to J$\n\n- 来自 `$B_3$` 的 $\\phi$-函数：`$a_4 \\leftarrow a_3, b_4 \\leftarrow b_3, c_4 \\leftarrow c_3, d_4 \\leftarrow d_3$`。\n- 在 `$B_3$` 出口处：`$a_3$` 在 `$r_3$` 中，`$b_3$` 在 `$r_2$` 中，`$c_3$` 在 `$r_1$` 中，`$d_3$` 在 `$r_4$` 中。\n\n边 `$B_3 \\to J$` 上所需的并行复制是：\n- `$r_1 := r_3$` (对于 `$a_4 \\leftarrow a_3$`)\n- `$r_2 := r_2$` (对于 `$b_4 \\leftarrow b_3$`)\n- `$r_3 := r_1$` (对于 `$c_4 \\leftarrow c_3$`)\n- `$r_4 := r_4$` (对于 `$d_4 \\leftarrow d_3$`)\n\n这些移动的依赖图包含：\n- 两个自环，`$r_2 \\to r_2$` 和 `$r_4 \\to r_4$`。每个都需要 `$0$` 次移动。\n- 一个长度为 `$k=2$` 的环：`$r_1 \\to r_3 \\to r_1$`。这是一个交换操作，需要 `$k+1 = 2+1 = 3$` 次移动。\n边 `$B_3 \\to J$` 的总移动次数是 `$0 + 0 + 3 = 3$`。\n\n### 总移动次数\n\n移动指令的最小总数是三条边各自所需移动次数的总和。\n总移动次数 = (边 `$B_1 \\to J$` 的移动次数) + (边 `$B_2 \\to J$` 的移动次数) + (边 `$B_3 \\to J$` 的移动次数)\n总移动次数 = `$5 + 4 + 3 = 12$`。", "answer": "$$\n\\boxed{12}\n$$", "id": "3670685"}]}