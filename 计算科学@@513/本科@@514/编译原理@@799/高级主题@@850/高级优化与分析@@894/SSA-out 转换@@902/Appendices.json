{"hands_on_practices": [{"introduction": "从SSA形式转换出来的核心挑战之一是如何将$\\phi$函数所代表的并行复制（parallel copies）转换为一系列顺序的机器指令。这个练习 [@problem_id:3660448] 聚焦于其中最基本也最常见的问题：移动循环（move cycle）。通过分析一个简单的双变量交换场景，你将从第一性原理出发，理解为何需要临时变量以及如何利用它来正确地实现并行语义。", "problem": "考虑一个控制流图，其中有两个前驱块 $B_1$ 和 $B_2$ ，它们都分支到一个连接块 $J$。该程序处于静态单赋值（SSA）形式，其中每个变量只被赋值一次，并且 $J$ 中的 $\\phi$ 节点根据控制流路径选择传入的值。$\\phi$ 节点的语义等同于在进入 $J$ 的边上插入并行复制，这意味着在每条边上所有复制操作都同时执行。\n\n假设程序如下。在 $B_1$ 中：\n$x_1 := \\text{val}_x$，$y_1 := \\text{val}_y$，然后控制流转向 $J$。在 $B_2$ 中：$x_2 := \\text{val}_x'$，$y_2 := \\text{val}_y'$，然后控制流转向 $J$。在 $J$ 中：\n$x_3 := \\phi(y_1, x_2)$ 且 $y_3 := \\phi(x_1, y_2)$，随后使用 $r := x_3 + y_3$。在脱离SSA转换期间，假设采用一种标准的合并策略，该策略旨在将 $x_3$ 映射到非SSA变量 $x$，将 $y_3$ 映射到 $y$，并在 $B_1$ 中将 $x_1$ 映射到 $x$、将 $y_1$ 映射到 $y$（$B_2$ 中情况类似）。在这些假设下，$\\phi$ 赋值在边 $B_1 \\to J$ 上引发了以下并行复制：\n$x \\leftarrow y$ 和 $y \\leftarrow x$，形成一个移动循环。你可以假设所有变量 $x$ 和 $y$ 在边 $B_1 \\to J$ 上都是活跃的。\n\n使用SSA语义和脱离SSA转换的基本原理（并行复制语义和顺序移动实现），构建在 $B_1 \\to J$ 上引发的移动循环，然后推导出一个使用最少临时变量的策略，以顺序移动实现这些并行复制，且不违反程序语义。具体来说，将这些复制建模为一个关于变量的有向图，其中一条边 $u \\to v$ 表示一个必要的移动 $v \\leftarrow u$。根据这些定义，论证如何调度无环移动以及如何打破循环。\n\n计算在上述假设下，正确实现循环 $x \\leftarrow y, y \\leftarrow x$ 所需的最少临时变量数量。你的最终答案必须是一个精确的整数。无需四舍五入。", "solution": "该问题要求分析脱离静态单赋值（SSA）的转换过程，特别是 $\\phi$ 节点引发的并行复制的实现。我们必须确定正确地将一个特定的移动循环序列化所需的最少临时变量数量。\n\n首先，我们根据提供的信息对问题进行形式化设置。程序处于SSA形式。在块 $B_1$ 中，有赋值操作 $x_1 := \\text{val}_x$ 和 $y_1 := \\text{val}_y$。在块 $B_2$ 中，有 $x_2 := \\text{val}_x'$ 和 $y_2 := \\text{val}_y'$。两个块都分支到连接块 $J$。在 $J$ 中，两个 $\\phi$ 节点合并了传入的值：\n$$x_3 := \\phi(y_1, x_2)$$\n$$y_3 := \\phi(x_1, y_2)$$\n$\\phi$ 节点的语义被定义为在传入的控制流边上的并行复制。我们关注的是从 $B_1$ 到 $J$ 的边。对于这条路径，有效的赋值由 $\\phi$ 节点的第一个参数指定：\n$$x_3 \\leftarrow y_1$$\n$$y_3 \\leftarrow x_1$$\n这些赋值必须同时执行。\n\n问题指出，在脱离SSA转换期间，应用了一种合并策略。SSA变量 $\\{x_1, x_2, x_3\\}$ 都被映射到单个非SSA变量 $x$，而 $\\{y_1, y_2, y_3\\}$ 被映射到单个非SSA变量 $y$。将此映射应用于边 $B_1 \\to J$ 的并行复制语义，我们进行替换 $x_3 \\to x$，$y_1 \\to y$，$y_3 \\to y$ 和 $x_1 \\to x$：\n$$x \\leftarrow y$$\n$$y \\leftarrow x$$\n这意味着在遍历从 $B_1$ 到 $J$ 的边时，非SSA变量 $x$ 的值必须更新为 $y$ 的原始值，同时， $y$ 的值必须更新为 $x$ 的原始值。这是一个经典的交换操作。\n\n问题要求将这些复制建模为一个有向图，其中一条边 $u \\to v$ 表示移动 $v \\leftarrow u$。根据这个约定：\n\\begin{itemize}\n    \\item 复制 $x \\leftarrow y$ 由一条从 $y$ 到 $x$ 的有向边表示：$y \\to x$。\n    \\item 复制 $y \\leftarrow x$ 由一条从 $x$ 到 $y$ 的有向边表示：$x \\to y$。\n\\end{itemize}\n最终得到的图包含两个节点 $x$ 和 $y$，以及两条形成长度为2的循环的边：$x \\to y \\to x$。\n\n任务是使用一系列简单的移动指令来实现这些并行复制。让我们将复制前 $x$ 和 $y$ 的值表示为 $x_{old}$ 和 $y_{old}$。期望的最终状态是 $x = y_{old}$ 和 $y = x_{old}$。\n\n让我们考虑尝试使用零个临时变量，仅通过 $x$ 和 $y$ 之间的顺序移动来实现这一点。有两种可能的顺序：\n\n情况1：先执行 $x \\leftarrow y$。\n1. $x := y$：变量 $x$ 现在持有值 $y_{old}$。原始值 $x_{old}$ 被覆盖并丢失。\n2. $y := x$：变量 $y$ 被赋予 $x$ 的当前值，即 $y_{old}$。\n最终状态是 $x = y_{old}$ 和 $y = y_{old}$。这是不正确的，因为 $y$ 应该是 $x_{old}$。\n\n情况2：先执行 $y \\leftarrow x$。\n1. $y := x$：变量 $y$ 现在持有值 $x_{old}$。原始值 $y_{old}$ 被覆盖并丢失。\n2. $x := y$：变量 $x$ 被赋予 $y$ 的当前值，即 $x_{old}$。\n最终状态是 $y = x_{old}$ 和 $x = x_{old}$。这也是不正确的，因为 $x$ 应该是 $y_{old}$。\n\n在这两种情况下，第一个顺序移动都会破坏第二个移动所需的值。这种现象被称为“副本丢失”问题。因此，不可能用零个临时变量正确实现这个特定的移动循环。所需的最少临时变量数量必须大于 $0$。\n\n现在，让我们考虑使用一个临时变量，称之为 $t$。打破移动循环的策略是首先将循环中的一个值保存到临时变量中。\n1. 将一个变量（比如 $x$）的值保存到临时变量中：$t \\leftarrow x$。（$t$ 现在持有 $x_{old}$）\n2. 变量 $x$ 现在可以被安全地覆盖。执行以 $x$ 为目标的移动：$x \\leftarrow y$。（$x$ 现在持有 $y_{old}$，这是正确的）。\n3. 现在需要 $x$ 的原始值来更新 $y$。这个值已保存在 $t$ 中。执行移动：$y \\leftarrow t$。（$y$ 现在持有 $x_{old}$，这是正确的）。\n\n这三个移动的序列（$t \\leftarrow x$，$x \\leftarrow y$，$y \\leftarrow t$）正确地实现了并行交换。最终状态是 $x = y_{old}$ 和 $y = x_{old}$，符合要求。\n\n既然我们已经证明了 $0$ 个临时变量是不够的，而 $1$ 个临时变量是足够的，那么正确实现该循环所需的最少临时变量数量就是 $1$。这是一个通用的结论，用于解决任何长度 $k \\ge 2$ 的单个移动循环；一个临时变量既是必要的也是充分的。", "answer": "$$\n\\boxed{1}\n$$", "id": "3660448"}, {"introduction": "在掌握了移动循环的基本概念后，下一个挑战是在更真实的编译场景中识别并解决它们。本练习 [@problem_id:3660417] 将$\\phi$函数的转换与另一个关键的编译器前端任务——活性分析（liveness analysis）结合起来。你需要首先确定变量的生命周期，然后根据给定的寄存器分配约束，推导出实现$\\phi$函数所需的移动指令，并在此过程中发现并解决一个由寄存器分配冲突引发的移动循环。", "problem": "考虑一个包含四个基本块 $B_0$、$B_1$、$B_2$ 和 $B_3$ 以及一个最终块 $B_4$ 的控制流图。块 $B_0$ 分支到 $B_1$ 或 $B_2$，而 $B_1$ 和 $B_2$ 都执行到汇合块 $B_3$，然后 $B_3$ 再执行到 $B_4$。该程序处于静态单赋值（SSA）形式。各个块中的语句如下：\n\n- 在 $B_1$ 中：首先计算 $x_1$，然后计算 $y_1$，接着使用 $y_1$ 计算 $a_1$，最后使用 $x_1$ 和 $a_1$ 计算 $b_1$；然后分支到 $B_3$。\n- 在 $B_2$ 中：首先计算 $x_2$，然后计算 $y_2$，接着使用 $y_2$ 计算 $a_2$，最后使用 $x_2$ 和 $a_2$ 计算 $b_2$；然后分支到 $B_3$。\n- 在 $B_3$ 中：两个 $\\phi$ 函数及其后续使用：\n  $$p := \\phi(a_1, a_2), \\quad q := \\phi(b_1, b_2),$$\n  之后是\n  $$r := p + q, \\quad t := q,$$\n  然后分支到 $B_4$。\n- 在 $B_4$ 中：\n  $$u := r + t,$$\n  程序结束。\n\n假设目标机器恰好有两个物理寄存器 $R_1$ 和 $R_2$，并且在前驱块 $B_1$ 和 $B_2$ 内部的局部寄存器分配已经固定且不能更改，这是由于与临时变量 $x_1, y_1$ 和 $x_2, y_2$ 的块内干扰（这些临时变量的细节与块间活跃性无关，但强制要求为 $a_i$ 和 $b_i$ 选择不同的寄存器）。固定的分配如下：\n- 在 $B_1$ 中：$a_1$ 在 $R_1$ 中，$b_1$ 在 $R_2$ 中。\n- 在 $B_2$ 中：$a_2$ 在 $R_2$ 中，$b_2$ 在 $R_1$ 中。\n\n任务：\n1. 使用标准的后向活跃性数据流方程，并根据 $\\phi$ 函数的常规语义（每个 $\\phi$ 操作数在其对应的入边上被使用），计算集合 $\\mathrm{live\\_in}(B_1)$、$\\mathrm{live\\_out}(B_1)$、$\\mathrm{live\\_in}(B_2)$、$\\mathrm{live\\_out}(B_2)$、$\\mathrm{live\\_in}(B_3)$ 和 $\\mathrm{live\\_out}(B_3)$。\n2. 在 $B_3$ 处执行 SSA-out 转换，通过在边 $B_1 \\to B_3$ 和 $B_2 \\to B_3$ 上插入最少数量的移动指令，并遵循上述固定的寄存器分配。你可以在 $B_3$ 中将 $p$ 和 $q$ 分配给 $R_1$ 或 $R_2$，但只有两个寄存器，且 $p$ 和 $q$ 在 $B_3$ 中同时活跃。每条边上的移动是为了实现由 $\\phi$ 函数引起的并行复制。如果在寄存器到寄存器的复制中出现环，你可以使用一个临时暂存变量来打破环。确定必须在 $B_3$ 的两条入边上插入的移动指令的最小总数。\n\n将你的最终答案表示为单个整数。无需四舍五入。", "solution": "该问题是有效的。这是一个编译原理中定义明确的练习，具体涉及静态单赋值（SSA）形式下的活跃性分析以及 SSA-out 转换的机制，该转换通过插入复制指令来解析 $\\phi$ 函数。所有给定条件都是一致且自包含的。\n\n问题包含两部分。首先，我们计算指定基本块的活跃集。其次，我们确定在汇合块 $B_3$ 实现 $\\phi$ 函数语义所需的最少移动指令数量。\n\n**第 1 部分：活跃性分析**\n\n我们使用后向数据流分析来计算 live-in 和 live-out 集合。标准的数据流方程是：\n$$ \\mathrm{live\\_out}(B) = \\bigcup_{S \\in \\mathrm{succ}(B)} \\mathrm{live\\_in}(S) $$\n$$ \\mathrm{live\\_in}(B) = \\mathrm{use}(B) \\cup (\\mathrm{live\\_out}(B) - \\mathrm{def}(B)) $$\n其中 $\\mathrm{use}(B)$ 是在块 $B$ 中定义之前就被使用的变量集合，而 $\\mathrm{def}(B)$ 是在块 $B$ 中定义的变量集合。\n\n对于 SSA 形式的程序，$\\phi$ 函数的语义需要特殊处理。位于块 $B$（其前驱为 $P_1, \\dots, P_n$）开头的 $\\phi$ 函数 $v := \\phi(v_1, \\dots, v_n)$ 意味着每个操作数 $v_i$ 在对应的入边 $P_i \\to B$ 上被使用。这意味着 $v_i$ 在块 $P_i$ 的出口处是活跃的。变量 $v$ 在块 $B$ 内部被定义。\n\n让我们从程序的末尾开始，逐块分析控制流图以及变量的使用/定义。\n\n*   **块 $B_4$**：程序在 $B_4$ 之后结束，所以 $\\mathrm{live\\_out}(B_4) = \\emptyset$。\n    $B_4$ 中的语句是 $u := r + t$。\n    定义的变量集合是 $\\mathrm{def}(B_4) = \\{u\\}$。\n    使用的变量集合是 $\\mathrm{use}(B_4) = \\{r, t\\}$。\n    $B_4$ 的 live-in 集合是：\n    $\\mathrm{live\\_in}(B_4) = \\mathrm{use}(B_4) \\cup (\\mathrm{live\\_out}(B_4) - \\mathrm{def}(B_4)) = \\{r, t\\} \\cup (\\emptyset - \\{u\\}) = \\{r, t\\}$。\n\n*   **块 $B_3$**：$B_3$ 的唯一后继是 $B_4$。\n    因此，$\\mathrm{live\\_out}(B_3) = \\mathrm{live\\_in}(B_4) = \\{r, t\\}$。\n    $B_3$ 中的语句是：\n    $1. p := \\phi(a_1, a_2)$\n    $2. q := \\phi(b_1, b_2)$\n    $3. r := p + q$\n    $4. t := q$\n    非-$\\phi$ 语句定义了 $\\mathrm{def}_{non-\\phi}(B_3)=\\{r, t\\}$ 并使用了 $\\mathrm{use}_{non-\\phi}(B_3)=\\{p, q\\}$。$\\phi$ 函数定义了 $\\mathrm{def}_{\\phi}(B_3) = \\{p, q\\}$。在 $B_3$ 中定义的变量总集合是 $\\mathrm{def}(B_3) = \\{p, q, r, t\\}$。\n    在 $B_3$ 中非-$\\phi$ 指令开始处必须活跃的变量集合，可以通过在这些指令中后向传播活跃性来计算：\n    - 在 $t := q$ 之前：活跃集是 $(\\mathrm{live\\_out}(B_3) \\setminus \\{t\\}) \\cup \\{q\\} = (\\{r, t\\} \\setminus \\{t\\}) \\cup \\{q\\} = \\{r, q\\}$。\n    - 在 $r := p + q$ 之前：活跃集是 $(\\{r, q\\} \\setminus \\{r\\}) \\cup \\{p, q\\} = \\{p, q\\}$。\n    这个集合 $\\{p, q\\}$ 代表了在 $\\phi$ 函数求值后必须立即保持活跃的变量。我们将其视为 $\\mathrm{live\\_in}(B_3)$ 的预期含义，因为它反映了该块体的资源需求。\n    所以，$\\mathrm{live\\_in}(B_3) = \\{p, q\\}$。\n\n*   **块 $B_1$**：$B_1$ 的唯一后继是 $B_3$。$B_1$ 出口处的活跃性由边 $B_1 \\to B_3$ 上的使用决定。这些使用由 $B_3$ 中对应于前驱 $B_1$ 的 $\\phi$ 函数的操作数给出。\n    - $p := \\phi(a_1, a_2)$：在来自 $B_1$ 的边上使用 $a_1$。\n    - $q := \\phi(b_1, b_2)$：在来自 $B_1$ 的边上使用 $b_1$。\n    因此，在边 $B_1 \\to B_3$ 上使用的变量集合是 $\\{a_1, b_1\\}$。这构成了 $B_1$ 的 live-out 集合。\n    $\\mathrm{live\\_out}(B_1) = \\{a_1, b_1\\}$。\n    在 $B_1$ 内部，变量 $x_1, y_1, a_1, b_1$ 被定义。$\\mathrm{def}(B_1)=\\{x_1, y_1, a_1, b_1\\}$。\n    问题陈述意味着 $x_1$ 和 $y_1$ 的计算没有使用来自前面块的任何变量，并且它们在同一块内用于计算 $a_1$ 和 $b_1$。没有向上暴露的使用。所以，$\\mathrm{use}(B_1) = \\emptyset$。\n    $B_1$ 的 live-in 集合是：\n    $\\mathrm{live\\_in}(B_1) = \\mathrm{use}(B_1) \\cup (\\mathrm{live\\_out}(B_1) - \\mathrm{def}(B_1)) = \\emptyset \\cup (\\{a_1, b_1\\} - \\{x_1, y_1, a_1, b_1\\}) = \\emptyset$。\n\n*   **块 $B_2$**：对 $B_2$ 的分析与 $B_1$ 对称。其后继是 $B_3$。边 $B_2 \\to B_3$ 上的使用来自 $\\phi$ 函数的第二个操作数：\n    - $p := \\phi(a_1, a_2)$：在来自 $B_2$ 的边上使用 $a_2$。\n    - $q := \\phi(b_1, b_2)$：在来自 $B_2$ 的边上使用 $b_2$。\n    所以，$\\mathrm{live\\_out}(B_2) = \\{a_2, b_2\\}$。\n    在 $B_2$ 内部，变量 $x_2, y_2, a_2, b_2$ 被定义。$\\mathrm{def}(B_2)=\\{x_2, y_2, a_2, b_2\\}$。\n    没有向上暴露的使用，所以 $\\mathrm{use}(B_2) = \\emptyset$。\n    $B_2$ 的 live-in 集合是：\n    $\\mathrm{live\\_in}(B_2) = \\mathrm{use}(B_2) \\cup (\\mathrm{live\\_out}(B_2) - \\mathrm{def}(B_2)) = \\emptyset \\cup (\\{a_2, b_2\\} - \\{x_2, y_2, a_2, b_2\\}) = \\emptyset$。\n\n第 1 部分的活跃集总结：\n- $\\mathrm{live\\_in}(B_1) = \\emptyset$\n- $\\mathrm{live\\_out}(B_1) = \\{a_1, b_1\\}$\n- $\\mathrm{live\\_in}(B_2) = \\emptyset$\n- $\\mathrm{live\\_out}(B_2) = \\{a_2, b_2\\}$\n- $\\mathrm{live\\_in}(B_3) = \\{p, q\\}$\n- $\\mathrm{live\\_out}(B_3) = \\{r, t\\}$\n\n**第 2 部分：SSA-out 转换与移动指令插入**\n\n任务是在块 $B_3$ 处将程序转换出 SSA 形式，方法是在入边 $B_1 \\to B_3$ 和 $B_2 \\to B_3$ 上插入 `move` 指令。这些移动实现了由 $\\phi$ 函数定义的并行赋值。\n$\\phi$ 函数是：\n$p := \\phi(a_1, a_2)$\n$q := \\phi(b_1, b_2)$\n\n在块 $B_3$ 中，变量 $p$ 和 $q$ 同时活跃，因为它们都在语句 $r := p + q$ 中被使用。机器有两个物理寄存器，$R_1$ 和 $R_2$。因此，$p$ 和 $q$ 必须被分配到不同的寄存器。在 $B_3$ 中，$(p, q)$ 有两种可能的分配：$(R_1, R_2)$ 或 $(R_2, R_1)$。我们必须找到一种分配方案，使得在两条边上插入的移动指令总数最小。\n\n**情况 1：在 $B_3$ 中将 $p$ 分配给 $R_1$，$q$ 分配给 $R_2$。**\n\n*   **边 $B_1 \\to B_3$**：\n    复制语义为 $p \\leftarrow a_1$ 和 $q \\leftarrow b_1$。\n    寄存器状态为：\n    - 在 $B_1$ 的末尾：$a_1$ 在 $R_1$ 中，$b_1$ 在 $R_2$ 中。\n    - 在 $B_3$ 的开始：$p$ 必须在 $R_1$ 中，$q$ 必须在 $R_2$ 中。\n    所需的并行复制是 $(R_1, R_2) \\leftarrow (R_1, R_2)$，其中目标寄存器用于 $(p, q)$，源寄存器用于 $(a_1, b_1)$。\n    - $R_1 \\leftarrow R_1$ (对于 $p \\leftarrow a_1$)：这是一个空操作，需要 0 条移动指令。\n    - $R_2 \\leftarrow R_2$ (对于 $q \\leftarrow b_1$)：这是一个空操作，需要 0 条移动指令。\n    此边上的移动总数：$0$。\n\n*   **边 $B_2 \\to B_3$**：\n    复制语义为 $p \\leftarrow a_2$ 和 $q \\leftarrow b_2$。\n    寄存器状态为：\n    - 在 $B_2$ 的末尾：$a_2$ 在 $R_2$ 中，$b_2$ 在 $R_1$ 中。\n    - 在 $B_3$ 的开始：$p$ 必须在 $R_1$ 中，$q$ 必须在 $R_2$ 中。\n    所需的并行复制是 $(R_1, R_2) \\leftarrow (R_2, R_1)$。\n    - $R_1 \\leftarrow R_2$ (对于 $p \\leftarrow a_2$)。\n    - $R_2 \\leftarrow R_1$ (对于 $q \\leftarrow b_2$)。\n    这是一个寄存器交换。要使用 `move` 指令实现它，我们需要一个临时暂存位置（我们称之为 $T$），这是问题所允许的。\n    $1. T \\leftarrow R_1$\n    $2. R_1 \\leftarrow R_2$\n    $3. R_2 \\leftarrow T$\n    此边上的移动总数：$3$。\n\n此分配方案的移动总数为 $0 + 3 = 3$。\n\n**情况 2：在 $B_3$ 中将 $p$ 分配给 $R_2$，$q$ 分配给 $R_1$。**\n\n*   **边 $B_1 \\to B_3$**：\n    复制语义为 $p \\leftarrow a_1$ 和 $q \\leftarrow b_1$。\n    寄存器状态为：\n    - 在 $B_1$ 的末尾：$a_1$ 在 $R_1$ 中，$b_1$ 在 $R_2$ 中。\n    - 在 $B_3$ 的开始：$p$ 必须在 $R_2$ 中，$q$ 必须在 $R_1$ 中。\n    所需的并行复制是 $(R_2, R_1) \\leftarrow (R_1, R_2)$。这是一个交换。\n    这需要使用一个临时变量进行 3 次移动。\n    此边上的移动总数：$3$。\n\n*   **边 $B_2 \\to B_3$**：\n    复制语义为 $p \\leftarrow a_2$ 和 $q \\leftarrow b_2$。\n    寄存器状态为：\n    - 在 $B_2$ 的末尾：$a_2$ 在 $R_2$ 中，$b_2$ 在 $R_1$ 中。\n    - 在 $B_3$ 的开始：$p$ 必须在 $R_2$ 中，$q$ 必须在 $R_1$ 中。\n    所需的并行复制是 $(R_2, R_1) \\leftarrow (R_2, R_1)$。\n    - $R_2 \\leftarrow R_2$ (对于 $p \\leftarrow a_2$)：空操作，0 条移动指令。\n    - $R_1 \\leftarrow R_1$ (对于 $q \\leftarrow b_2$)：空操作，0 条移动指令。\n    此边上的移动总数：$0$。\n\n此分配方案的移动总数为 $3 + 0 = 3$。\n\n在块 $B_3$ 中，对 $p$ 和 $q$ 的两种可能的寄存器分配方案都会导致总共需要 3 条移动指令。因此，最小移动总数为 3。", "answer": "$$\\boxed{3}$$", "id": "3660417"}, {"introduction": "最后的练习 [@problem_id:3660351] 将带你进入一个更复杂的并行复制场景，这在处理大型代码块时很常见。你将面对一个由多个$\\phi$函数产生的复杂依赖图，其中包含长度不同且相互独立的多个移动循环。这个任务旨在训练你系统性地分解问题、识别并独立解决每个循环的能力，并在此过程中优化临时寄存器的使用，以最低的成本完成整个并行复制任务。", "problem": "考虑一个静态单赋值 (SSA) 形式的控制流汇合块 $B$，它有两个前驱 $P$ 和 $Q$。块 $B$ 包含六个 $\\phi$-函数，其中三个通过共享来自 $P$ 的相同传入 SSA 版本，在边 $P \\to B$ 上形成了一个 $\\phi$-网。这些 $\\phi$-函数及其传入参数如下：\n- $x_{1} \\gets \\phi(P: a,\\; Q: e)$\n- $x_{2} \\gets \\phi(P: a,\\; Q: f)$\n- $x_{3} \\gets \\phi(P: a,\\; Q: g)$\n- $x_{4} \\gets \\phi(P: b,\\; Q: h)$\n- $x_{5} \\gets \\phi(P: c,\\; Q: i)$\n- $x_{6} \\gets \\phi(P: d,\\; Q: j)$\n\n假设寄存器分配由一个到机器寄存器 $R_{0}, R_{1}, R_{2}, R_{3}, R_{4}, R_{5}$ 的映射 $\\rho(\\cdot)$ 预先确定，具体如下：\n- 来自 $P$ 的源：$\\rho(a)=R_{0},\\; \\rho(b)=R_{1},\\; \\rho(c)=R_{2},\\; \\rho(d)=R_{3}$。\n- 来自 $Q$ 的源：$\\rho(e)=R_{2},\\; \\rho(f)=R_{3},\\; \\rho(g)=R_{1},\\; \\rho(h)=R_{0},\\; \\rho(i)=R_{5},\\; \\rho(j)=R_{4}$。\n- 在 $B$ 中的目标：$\\rho(x_{1})=R_{1},\\; \\rho(x_{2})=R_{2},\\; \\rho(x_{3})=R_{3},\\; \\rho(x_{4})=R_{0},\\; \\rho(x_{5})=R_{4},\\; \\rho(x_{6})=R_{5}$。\n\n脱离 SSA 形式的转换是通过在每条传入边上插入一个并行复制来执行的，该并行复制实现了那条边上的 $\\phi$-函数所指定的同步赋值。并行复制语义要求在写入任何左侧值之前，必须从其源读取所有右侧值。实现模型只允许形式为 $u := v$ 的寄存器到寄存器的移动指令，只有一个额外的临时寄存器 $T$（它不是 $R_{0},\\ldots,R_{5}$ 中的任何一个），并且没有可用的交换指令。\n\n仅从 SSA $\\phi$ 语义和并行复制语义的定义出发，不假设任何特定的快捷公式，确定在最优调度下，实现在 $P \\to B$ 和 $Q \\to B$ 两条边上脱离 SSA 的并行复制所需的寄存器到寄存器移动指令的最小总数。该最优调度需利用边 $P \\to B$ 上 $a$ 的 $\\phi$-网共享特性，以避免不必要的保存和重新加载。答案以单个整数形式给出。无需四舍五入，不涉及物理单位。", "solution": "问题要求确定为具有两个前驱边 $P \\to B$ 和 $Q \\to B$ 的汇合块 $B$ 实现脱离 SSA 的并行复制所需的寄存器到寄存器移动指令的最小总数。我们必须分别分析每条边并将其成本相加。该分析必须源自并行复制的语义，而不依赖于任何未说明的特定公式。并行复制规定，在修改任何目标寄存器之前，必须读取所有源值。\n\n**对边 $P \\to B$ 的分析**\n\n首先，我们形式化边 $P \\to B$ 上所需的并行复制。$\\phi$-函数定义了以下赋值：\n- $x_{1} \\gets a$\n- $x_{2} \\gets a$\n- $x_{3} \\gets a$\n- $x_{4} \\gets b$\n- $x_{5} \\gets c$\n- $x_{6} \\gets d$\n\n应用给定的寄存器分配映射 $\\rho(\\cdot)$，我们将这些赋值转换为寄存器到寄存器的传输：\n- $\\rho(x_{1}) \\gets \\rho(a) \\implies R_{1} := R_{0}$\n- $\\rho(x_{2}) \\gets \\rho(a) \\implies R_{2} := R_{0}$\n- $\\rho(x_{3}) \\gets \\rho(a) \\implies R_{3} := R_{0}$\n- $\\rho(x_{4}) \\gets \\rho(b) \\implies R_{0} := R_{1}$\n- $\\rho(x_{5}) \\gets \\rho(c) \\implies R_{4} := R_{2}$\n- $\\rho(x_{6}) \\gets \\rho(d) \\implies R_{5} := R_{3}$\n\n为了确定最小的移动序列，我们构建一个依赖图 $G_P = (V, E)$，其中 $V$ 是寄存器集合 $\\{R_{0}, R_{1}, R_{2}, R_{3}, R_{4}, R_{5}\\}$，一条边 $(u, v) \\in E$ 表示一个复制操作 $v := u$。这些边是：\n- $R_{0} \\to R_{1}$\n- $R_{0} \\to R_{2}$\n- $R_{0} \\to R_{3}$\n- $R_{1} \\to R_{0}$\n- $R_{2} \\to R_{4}$\n- $R_{3} \\to R_{5}$\n\n分析 $G_P$ 的结构：\n该图揭示了寄存器 $R_{0}$ 和 $R_{1}$ 之间存在一个2-环（即 $R_{0} \\to R_{1}$ 和 $R_{1} \\to R_{0}$）。解决这样的环需要打破它，因为如果先执行其中任何一个复制，都会破坏另一个复制所需的值。这使得使用临时寄存器 $T$ 成为必要。\n\n寄存器 $R_{0}$ 是这个环的一部分，同时也是三个不同复制（$\\phi$-网）的源。寄存器 $R_{1}$ 也是该环的一部分。为了打破这个环，我们必须保存 $R_{0}$ 或 $R_{1}$ 的值。由于 $R_{0}$ 中的值是三个目标（$R_{1}, R_{2}, R_{3}$）所需要的，而它自己的目标寄存器将被来自 $R_{1}$ 的值覆盖，因此最优策略是将 $R_{0}$ 的值保存到临时寄存器 $T$ 中。这次单一的保存使得该值可以用于其所有预定目标。\n\n1.  $T := R_{0}$：保存 $R_{0}$ 的值（来自变量 $a$）。这花费 1 次移动。\n\n这次移动之后，所需的并行传输集合在概念上被转换了。任何需要 $R_{0}$ 原始值的传输现在都需要来自 $T$ 的值。新的传输集合是：\n- $R_{1} := T$\n- $R_{2} := T$\n- $R_{3} := T$\n- $R_{0} := R_{1}$\n- $R_{4} := R_{2}$\n- $R_{5} := R_{3}$\n\n这个新传输集合的依赖图是无环的。我们现在可以生成一个遵守剩余依赖关系的移动序列。如果一个复制操作 $d := s$ 的目标 $d$ 不是任何其他待处理复制的源，那么该操作就可以被执行。\n- 复制操作 $R_{0} := R_{1}$、$R_{4} := R_{2}$ 和 $R_{5} := R_{3}$ 的目标（$R_{0}, R_{4}, R_{5}$）不是任何其他剩余复制的源。然而，它们的源（$R_{1}, R_{2}, R_{3}$）是其他复制的目标。为了遵守并行复制语义，我们必须在这些寄存器被覆盖之前，执行使用 $R_1, R_2, R_3$ 原始值的复制操作。\n\n一个有效的最小移动序列构建如下：\n1.  $T := R_{0}$：保存 $R_{0}$ 的值。（1 次移动）\n2.  $R_{0} := R_{1}$：现在将 $R_{1}$ 的值复制到 $R_{0}$。这是安全的，因为 $R_{0}$ 的原始值在 $T$ 中。（1 次移动）\n3.  $R_{4} := R_{2}$：将 $R_{2}$ 的原始值复制到 $R_{4}$。这必须在 $R_{2}$ 被更新之前发生。（1 次移动）\n4.  $R_{5} := R_{3}$：将 $R_{3}$ 的原始值复制到 $R_5$。这必须在 $R_{3}$ 被更新之前发生。（1 次移动）\n5.  $R_{1} := T$：将保存的 $R_{0}$ 的值复制到 $R_{1}$。与步骤1和2一起，这完成了 $R_0$ 和 $R_1$ 的循环交换。（1 次移动）\n6.  $R_{2} := T$：将保存的 $R_{0}$ 的值复制到 $R_{2}$。（1 次移动）\n7.  $R_{3} := T$：将保存的 $R_{0}$ 的值复制到 $R_{3}$。（1 次移动）\n\n这个序列正确地实现了所有传输。总移动次数为 7 次。这是最小的，因为有 6 个基本赋值要执行，而单个环需要一个额外的移动来使用临时寄存器打破它。\n\n**对边 $Q \\to B$ 的分析**\n\n接下来，我们形式化边 $Q \\to B$ 的并行复制。$\\phi$-函数定义了以下赋值：\n- $x_{1} \\gets e$\n- $x_{2} \\gets f$\n- $x_{3} \\gets g$\n- $x_{4} \\gets h$\n- $x_{5} \\gets i$\n- $x_{6} \\gets j$\n\n应用寄存器分配映射 $\\rho(\\cdot)$：\n- $\\rho(x_{1}) \\gets \\rho(e) \\implies R_{1} := R_{2}$\n- $\\rho(x_{2}) \\gets \\rho(f) \\implies R_{2} := R_{3}$\n- $\\rho(x_{3}) \\gets \\rho(g) \\implies R_{3} := R_{1}$\n- $\\rho(x_{4}) \\gets \\rho(h) \\implies R_{0} := R_{0}$\n- $\\rho(x_{5}) \\gets \\rho(i) \\implies R_{4} := R_{5}$\n- $\\rho(x_{6}) \\gets \\rho(j) \\implies R_{5} := R_{4}$\n\n复制操作 $R_{0} := R_{0}$ 是一个空操作，需要 0 次移动。我们分析剩下的五个非平凡传输。依赖图 $G_Q$ 由以下边组成：\n- $R_{2} \\to R_{1}$\n- $R_{3} \\to R_{2}$\n- $R_{1} \\to R_{3}$\n- $R_{5} \\to R_{4}$\n- $R_{4} \\to R_{5}$\n\n图 $G_Q$ 分解为两个不相交的组件：\n1.  一个3-环：$R_{1} \\to R_{3} \\to R_{2} \\to R_{1}$。\n2.  一个2-环：$R_{4} \\leftrightarrow R_{5}$。\n\n我们必须使用临时寄存器 $T$ 来解决每个环。由于这些组件是不相交的，我们可以顺序地解决它们，并重用 $T$。\n\n为了解决 $\\{R_{1}, R_{2}, R_{3}\\}$ 上的3-环（涉及3个寄存器），我们需要 $3+1 = 4$ 次移动：\n1.  $T := R_{1}$（保存环中任一寄存器的值，例如 $R_1$）\n2.  $R_{1} := R_{2}$\n3.  $R_{2} := R_{3}$\n4.  $R_{3} := T$（恢复保存的值以完成循环）\n这个子问题花费 4 次移动。\n\n为了解决 $\\{R_{4}, R_{5}\\}$ 上的2-环（涉及2个寄存器），我们需要 $2+1 = 3$ 次移动。寄存器 $T$ 此时可以再次使用。\n1.  $T := R_{4}$（保存 $R_4$ 的值）\n2.  $R_{4} := R_{5}$\n3.  $R_{5} := T$（恢复保存的值）\n这个子问题花费 3 次移动。\n\n边 $Q \\to B$ 的总移动次数是每个不相交组件的移动次数之和：$4 + 3 = 7$。\n\n**最小总移动次数**\n\n最小总移动次数是每条边所需移动次数的总和：\n总移动次数 = ($P \\to B$ 的移动次数) + ($Q \\to B$ 的移动次数) = $7 + 7 = 14$。\n\n最终答案是 14。", "answer": "$$\\boxed{14}$$", "id": "3660351"}]}