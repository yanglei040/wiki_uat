{"hands_on_practices": [{"introduction": "理解了何时可以省略 $\\phi$-函数后，我们来探讨其放置的连锁效应。本练习展示了一个包含两个连续汇合点的控制流图，旨在阐明为何 $\\phi$-函数放置算法必须是迭代的 [@problem_id:3684224]。我们将看到，在一个汇合点插入 $\\phi$-函数会创建一个新的“虚拟”定义，这个定义会影响后续代码，但我们也会发现这个过程是会收敛的，从而避免了在每个汇合点都插入 $\\phi$-函数。", "problem": "考虑以下控制流图 (CFG)，该图描述了一个操作单个标量变量 $x$ 并在最后使用 $x$ 的过程。图中的节点是基本块 $B_0, B_1, B_2, B_3, B_4, B_5, B_6, B_7$，边表示控制流。流程和赋值如下：\n\n- $B_0$：入口；为 $x$ 赋一个初始值（视为一次定义），然后跳转到 $B_1$。\n- $B_1$：一个条件分支，分裂成两个互斥的后继节点 $B_2$ 和 $B_3$。\n- $B_2$：赋值 $x := 1$，然后跳转到 $B_4$。\n- $B_3$：不对 $x$ 赋值，然后跳转到 $B_4$。\n- $B_4$：来自 $B_2$ 和 $B_3$ 的路径的第一个重汇合点；然后第二个条件分支分裂成 $B_5$ 和 $B_6$，两者互斥。\n- $B_5$：不对 $x$ 赋值，然后跳转到 $B_7$。\n- $B_6$：不对 $x$ 赋值，然后跳转到 $B_7$。\n- $B_7$：来自 $B_5$ 和 $B_6$ 的路径的第二个重汇合点；$B_7$ 中包含对 $x$ 的一次使用（因此 $x$ 在进入 $B_7$ 的两条边上都是活跃的），然后过程退出。\n\n假设目标是使用标准的基于支配和支配边界的放置策略，为 $x$ 构建一个最小化的、经过剪枝的静态单赋值 (SSA) 形式。回顾核心定义：\n\n- 支配 (Dominance)：如果从入口到节点 $n$ 的每一条路径都经过节点 $d$，则称 $d$ 支配 $n$。严格支配 (Strict dominance) 排除 $d = n$ 的情况。\n- 一个节点 $d$ 的支配边界 (Dominance frontier)：节点集合 $n$，其中 $d$ 支配 $n$ 的一个前驱，但 $d$ 并不严格支配 $n$。\n- 最小化 SSA $\\phi$-函数放置 (剪枝)：对于每个变量，在其定义点的迭代支配边界上放置 $\\phi$-函数，但仅限于该变量在该处是入口活跃 (live-in) 的情况。\n\n仅基于这些基础，变量 $x$ 的 $\\phi$-函数需要在哪里放置？\n\nA. 仅在 $B_4$ 处为 $x$ 放置一个 $\\phi$-函数；在 $B_7$ 处不需要为 $x$ 放置 $\\phi$-函数。\n\nB. 在 $B_4$ 和 $B_7$ 处都为 $x$ 放置 $\\phi$-函数。\n\nC. 仅在 $B_7$ 处为 $x$ 放置一个 $\\phi$-函数；在 $B_4$ 处不需要为 $x$ 放置 $\\phi$-函数。\n\nD. 在任何块中都不需要为 $x$ 放置 $\\phi$-函数，因为每个分支点都有一个分支不对 $x$ 进行赋值。", "solution": "### 步骤 1：提取已知信息\n问题提供了关于一个控制流图 (CFG) 和一个标量变量 $x$ 的以下信息：\n1.  **节点（基本块）**：$B_0, B_1, B_2, B_3, B_4, B_5, B_6, B_7$。\n2.  **控制流**：\n    - $B_0$ 是入口块，只有一个后继节点 $B_1$。\n    - $B_1$ 是一个条件分支，有两个后继节点 $B_2$ 和 $B_3$。\n    - $B_2$ 只有一个后继节点 $B_4$。\n    - $B_3$ 只有一个后继节点 $B_4$。\n    - $B_4$ 是一个条件分支，有两个后继节点 $B_5$ 和 $B_6$。\n    - $B_5$ 只有一个后继节点 $B_7$。\n    - $B_6$ 只有一个后继节点 $B_7$。\n    - $B_7$ 是出口块。\n3.  **对 $x$ 的赋值（定义）**：\n    - $B_0$ 包含对 $x$ 的一次定义。\n    - $B_2$ 包含对 $x$ 的一次定义（具体为 $x := 1$）。\n    - $B_3, B_5, B_6$ 不包含对 $x$ 的定义。\n4.  **$x$ 的使用**：\n    - $B_7$ 包含对 $x$ 的一次使用。\n5.  **SSA 构建规则**：\n    - **支配 (Dominance)**：如果从入口到节点 $n$ 的每一条路径都经过节点 $d$，则称 $d$ 支配 $n$。严格支配 (Strict dominance) 意味着 $d \\neq n$。\n    - **一个节点 $d$ 的支配边界 (DF)**，$DF(d)$：节点集合 $n$，其中 $d$ 支配 $n$ 的一个前驱，但 $d$ 并不严格支配 $n$。\n    - **放置规则**：在变量定义点的迭代支配边界 ($IDF$) 上放置 $\\phi$-函数。\n    - **剪枝规则**：只有当变量在某个块的入口是活跃 (live-in) 的时，才在该块放置 $\\phi$-函数。\n\n### 步骤 2：使用提取的已知信息进行验证\n问题陈述描述了编译器优化中的一个标准场景，特别是静态单赋值 (SSA) 形式的构建。\n-   **科学依据**：控制流图、支配、支配边界、活跃性分析和 $\\phi$-函数的概念是编译器理论中基础且成熟的原则。该问题在科学上是合理的。\n-   **良构的 (Well-Posed)**：CFG 被完全描述，定义和使用点被指定，$\\phi$-函数的放置算法被明确定义。这种结构允许推导出唯一的解决方案。\n-   **客观性**：问题使用精确、形式化的计算机科学术语陈述，没有歧义或主观论断。\n\n该问题是自包含的、逻辑一致的，并基于已确立的计算机科学原理。它不违反任何无效性标准。\n\n### 步骤 3：结论和行动\n问题陈述是**有效的**。将推导出解决方案。\n\n### 解题推导\n\n任务是通过计算变量 $x$ 定义点的经过剪枝的迭代支配边界，来找到 $\\phi$-函数的放置位置。\n\n**1. 识别定义点**\n问题指出变量 $x$ 在块 $B_0$ 和 $B_2$ 中被定义。设 $S$ 为 $x$ 的定义块集合。\n$$S = \\{B_0, B_2\\}$$\n\n**2. 分析 CFG 并计算支配节点**\nCFG 结构如下：\n- $B_0$ (入口) $\\to B_1$\n- $B_1 \\to B_2$, $B_1 \\to B_3$\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$  ($B_4$ 是一个汇合点)\n- $B_4 \\to B_5$, $B_4 \\to B_6$\n- $B_5 \\to B_7$\n- $B_6 \\to B_7$  ($B_7$ 是一个汇合点)\n- $B_7$ 是出口。\n\n我们确定每个块的支配节点集。如果从入口到 $n$ 的所有路径都包含 $d$，则称节点 $d$ 支配 $n$，记为 $d \\text{ dom } n$。\n- $\\text{dom}(B_0) = \\{B_0\\}$\n- $\\text{dom}(B_1) = \\{B_0, B_1\\}$\n- $\\text{dom}(B_2) = \\{B_0, B_1, B_2\\}$\n- $\\text{dom}(B_3) = \\{B_0, B_1, B_3\\}$\n- $\\text{dom}(B_4) = \\{B_0, B_1, B_4\\}$ (直接支配节点是 $B_1$)\n- $\\text{dom}(B_5) = \\{B_0, B_1, B_4, B_5\\}$ (直接支配节点是 $B_4$)\n- $\\text{dom}(B_6) = \\{B_0, B_1, B_4, B_6\\}$ (直接支配节点是 $B_4$)\n- $\\text{dom}(B_7) = \\{B_0, B_1, B_4, B_7\\}$ (直接支配节点是 $B_4$)\n\n**3. 计算支配边界 (DF)**\n一个节点 $d$ 的支配边界 $DF(d)$ 是所有节点 $n$ 的集合，满足 $d$ 支配 $n$ 的一个前驱，但 $d$ 不严格支配 $n$。我们需要计算定义集 $S=\\{B_0, B_2\\}$ 中节点的 DF。\n\n- **$DF(B_0)$**：入口节点 $B_0$ 严格支配它所支配的每个节点（除了它自己）。它没有前驱节点。其支配边界为空。\n$$DF(B_0) = \\emptyset$$\n\n- **$DF(B_2)$**：我们寻找节点 $n$，使得 $B_2$ 支配 $n$ 的一个前驱，但并不严格支配 $n$。\n    - $B_2$ 唯一支配的节点是它自己。所以我们只需要检查 $B_2$ 的后继节点。\n    - $B_2$ 的后继是 $n=B_4$。$B_4$ 的一个前驱是 $p=B_2$。\n    - $B_2$ 是否支配 $p=B_2$？是的，这是平凡的。\n    - $B_2$ 是否严格支配 $n=B_4$？不是，因为 $B_2$ 不在 $\\text{dom}(B_4) = \\{B_0, B_1, B_4\\}$ 中。\n    - 因此，$B_4$ 在 $B_2$ 的支配边界中。\n$$DF(B_2) = \\{B_4\\}$$\n\n**4. 计算迭代支配边界 (IDF)**\n$\\phi$-函数的候选节点集是定义点的迭代支配边界 $IDF(S)$。我们从初始定义点的 DF 开始，然后迭代地添加新加入节点的 DF，直到达到一个不动点。\n设 $W_0 = S = \\{B_0, B_2\\}$。设 $\\Phi_0 = \\emptyset$。该算法计算 $\\Phi = IDF(S)$。\n\n迭代 1：\n- 计算 $DF(S) = DF(B_0) \\cup DF(B_2) = \\emptyset \\cup \\{B_4\\} = \\{B_4\\}$。\n- 需要 $\\phi$-函数的新节点集是 $\\Phi_1 = \\{B_4\\}$。这些是新的“定义”。\n- 我们需要查看在 $B_4$ 放置一个 $\\phi$-函数是否会强制在别处放置另一个 $\\phi$-函数。我们计算 $\\Phi_1$ 中节点的 DF。\n\n迭代 2：\n- 计算 $DF(B_4)$：我们寻找节点 $n$，使得 $B_4$ 支配 $n$ 的一个前驱，但并不严格支配 $n$。\n    - 唯一可能的候选者是汇合点 $B_7$，因为它是唯一一个其前驱（$B_5, B_6$）被 $B_4$ 支配的汇合点。\n    - 我们来检查 $n=B_7$。它的前驱是 $p_1=B_5$ 和 $p_2=B_6$。\n    - $B_4$ 是否支配 $p_1=B_5$？是的，$\\text{dom}(B_5) = \\{B_0, B_1, B_4, B_5\\}$。\n    - $B_4$ 是否严格支配 $n=B_7$？是的，因为 $B_4 \\in \\text{dom}(B_7)$ 且 $B_4 \\neq B_7$。\n    - 进入支配边界的条件是“$d$ 不严格支配 $n$”。这个条件是假的。\n    - 所以，$B_7$ 不在 $DF(B_4)$ 中。同样的逻辑也适用于通过 $B_6$ 的路径。\n    - 没有其他节点需要检查。因此，$DF(B_4)$ 是空的。\n$$DF(B_4) = \\emptyset$$\n- 下一组节点是 $\\Phi_2 = \\Phi_1 \\cup DF(B_4) = \\{B_4\\} \\cup \\emptyset = \\{B_4\\}$。\n- 由于 $\\Phi_2 = \\Phi_1$，迭代已经收敛。\n\n最小化 SSA 算法建议在集合 $IDF(S) = \\{B_4\\}$ 中的节点处放置 $\\phi$-函数。\n\n**5. 基于活跃性应用剪枝**\n问题指定了剪枝的 SSA 形式。一个变量 $x$ 在块 $B$ 处的 $\\phi$-函数仅在 $x$ 在 $B$ 的入口是活跃的 (live-in) 时才是必要的。如果从该块的入口到变量的一次使用存在一条路径，且路径上没有对该变量的重新定义，则该变量在该块的入口是活跃的。\n\n- 我们有一个 $\\phi$-函数的候选块：$B_4$。\n- 我们必须检查 $x$ 在 $B_4$ 的入口是否是活跃的。\n- 问题指出在 $B_7$ 中有对 $x$ 的一次使用。\n- 从 $B_4$ 的入口到 $B_7$ 中的使用有两条路径：\n    - 路径 1：$B_4 \\to B_5 \\to B_7$。\n    - 路径 2：$B_4 \\to B_6 \\to B_7$。\n- 这些路径上的块（$B_5, B_6$）没有重新定义 $x$。\n- 因此，从 $B_4$ 的入口到 $x$ 的一次使用存在一条无定义的路径，这意味着 $x$ 在 $B_4$ 的入口是活跃的。\n- $B_4$ 处的 $\\phi$-函数不会被剪枝。\n\n**结论**\n需要为 $x$ 放置 $\\phi$-函数的最终块集合是 $\\{B_4\\}$。在 $B_7$ 处不需要 $\\phi$-函数，因为它不在原始定义点的迭代支配边界中。直观地看，任何进入 $B_4$ 的 $x$ 的值（这将是一个单一版本 $x' = \\phi(x_{from\\_B2}, x_{from\\_B3})$）都会在不被重新定义的情况下通过两个分支（$B_4 \\to B_5$ 和 $B_4 \\to B_6$）。因此，相同版本的 $x$（即 $x'$）会沿着两条入边到达 $B_7$，使得在 $B_7$ 放置 $\\phi$-函数是多余的。\n\n### 逐项分析\n\n**A. 仅在 $B_4$ 处为 $x$ 放置一个 $\\phi$-函数；在 $B_7$ 处不需要为 $x$ 放置 $\\phi$-函数。**\n这与我们推导出的结果完全一致。迭代支配边界的计算在 $B_4$ 处放置了一个 $\\phi$-函数。活跃性分析确认了它的必要性。计算还表明 $B_7$ 不在定义点的 IDF 中，因此不会在那里放置 $\\phi$-函数。\n**结论：正确。**\n\n**B. 在 $B_4$ 和 $B_7$ 处都为 $x$ 放置 $\\phi$-函数。**\n这是不正确的。如推导所示，$B_7$ 不在定义点 $\\{B_0, B_2\\}$ 的迭代支配边界中。具体来说，$DF(B_4)$ 是空的，因为 $B_4$ 严格支配 $B_7$。因此，标准算法不会在 $B_7$ 处放置 $\\phi$-函数。\n**结论：不正确。**\n\n**C. 仅在 $B_7$ 处为 $x$ 放置一个 $\\phi$-函数；在 $B_4$ 处不需要为 $x$ 放置 $\\phi$-函数。**\n这是不正确的。在 $B_4$ 处需要一个 $\\phi$-函数，因为它是来自两个不同 $x$ 定义的控制流路径合并的第一个块。通过 $B_2$ 的路径携带了 $x$ 的新值，而通过 $B_3$ 的路径携带了来自 $B_0$ 的旧值。$\\phi$-函数对于合并这些版本至关重要。我们的计算证实了这一点（$B_4 \\in DF(B_2)$）。\n**结论：不正确。**\n\n**D. 在任何块中都不需要为 $x$ 放置 $\\phi$-函数，因为每个分支点都有一个分支不对 $x$ 进行赋值。**\n这个推论是错误的。当一个条件分支重新定义一个变量而另一个分支不重新定义时，几乎总是在汇合点需要一个 $\\phi$-函数。不重新定义变量的分支只是传播了该变量的一个旧版本，这个旧版本必须与来自另一个分支的新版本合并。这正是汇合点 $B_4$ 的情况。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3684224"}, {"introduction": "最后的练习将前面的概念应用到一个更复杂的真实场景中：一个包含嵌套条件的循环。循环结构因其“后向边”（back edge）的存在，对 $\\phi$-函数的放置提出了特殊要求，即需要在循环头处理循环携带的依赖关系 [@problem_id:3684217]。通过解决这个问题，你将掌握在复杂的控制流中，如何系统地运用迭代支配边界算法，同时处理来自条件分支和循环的变量值合并。", "problem": "考虑以下程序片段及其相关的控制流图 (CFG)。静态单赋值 (SSA) 形式要求每个变量只被赋值一次，合并点由希腊字母phi ($\\phi$) 表示。您将使用支配和支配边界的概念来分析变量 $best$ 的 $\\phi$ 函数的放置位置。\n\n用基本块表示的程序片段：\n- 块 $B_{E}$ (入口): 直接进入循环前置头部。\n- 块 $B_{S}$ (循环前置头部): 通过 $best \\leftarrow s$ 初始化 $best$，然后将控制权转移到循环头部。\n- 块 $B_{H}$ (循环头部): 测试循环条件 $i  n$；如果为真，控制流进入循环体；如果为假，控制流转向出口。\n- 块 $B_{B}$ (循环体设置): 计算一个候选值 $a$ 并将控制权转移到一个条件块。\n- 块 $B_{C}$ (条件): 测试一个谓词 $p$；如果为真，跳转到 $B_{T}$；如果为假，跳转到 $B_{F}$。\n- 块 $B_{T}$ (then分支): 通过 $best \\leftarrow f_{1}(a)$ 更新 $best$，然后跳转到汇合点 $B_{J}$。\n- 块 $B_{F}$ (带有嵌套条件的else分支): 测试另一个谓词 $q$；如果为真，跳转到 $B_{F\\_T}$；如果为假，跳转到 $B_{F\\_F}$。\n- 块 $B_{F\\_T}$ (嵌套的then分支): 通过 $best \\leftarrow f_{2}(a)$ 更新 $best$，然后跳转到汇合点 $B_{J}$。\n- 块 $B_{F\\_F}$ (嵌套的else分支): 保持 $best$ 不变，然后跳转到汇合点 $B_{J}$。\n- 块 $B_{J}$ (条件的汇合点): 从 $B_{T}$、$B_{F\\_T}$ 和 $B_{F\\_F}$ 接收控制流；然后跳转到循环尾部。\n- 块 $B_{L}$ (循环尾部): 递增 $i$ 并分支回到 $B_{H}$，形成循环的回边。\n- 块 $B_{X}$ (出口): 当 $B_{H}$ 将循环条件评估为假时到达。\n\n边如下：\n- $B_{E} \\rightarrow B_{S}$\n- $B_{S} \\rightarrow B_{H}$\n- $B_{H} \\rightarrow B_{B}$ 为真时，以及 $B_{H} \\rightarrow B_{X}$ 为假时\n- $B_{B} \\rightarrow B_{C}$\n- $B_{C} \\rightarrow B_{T}$ 为真时，以及 $B_{C} \\rightarrow B_{F}$ 为假时\n- $B_{F} \\rightarrow B_{F\\_T}$ 为真时，以及 $B_{F} \\rightarrow B_{F\\_F}$ 为假时\n- $B_{T} \\rightarrow B_{J}$, $B_{F\\_T} \\rightarrow B_{J}$, $B_{F\\_F} \\rightarrow B_{J}$\n- $B_{J} \\rightarrow B_{L}$\n- $B_{L} \\rightarrow B_{H}$\n\n假设是标准的结构化控制流，因此循环头部 $B_{H}$ 支配循环体中的所有块（$B_{B}$, $B_{C}$, $B_{T}$, $B_{F}$, $B_{F\\_T}$, $B_{F\\_F}$, $B_{J}$, $B_{L}$），并且 $B_{S}$ 支配 $B_{H}$。变量 $best$ 在 $B_{S}$ 中定义，并可能在 $B_{T}$ 和 $B_{F\\_T}$ 中被重新定义，而在 $B_{F\\_F}$ 中保持不变。\n\n使用核心定义：\n- 如果从入口到块 $Y$ 的每条路径都经过块 $X$，则块 $X$ 支配块 $Y$。\n- 块 $X$ 的支配边界，记为 $\\mathrm{DF}(X)$，是所有块 $Y$ 的集合，其中 $X$ 支配 $Y$ 的一个前驱，但 $X$ 并不严格支配 $Y$。\n- 变量的最小 $\\phi$ 函数放置是通过在其所有定义块集合的迭代支配边界处插入 $\\phi$ 函数来获得的。\n\n将这些定义应用于变量 $best$，确定在最小SSA放置下，必须在循环头部 $B_{H}$ 和汇合点 $B_{J}$ 为 $best$ 插入的 $\\phi$ 函数总数。请用一个整数表示您的最终答案。不需要四舍五入，也不需要单位。只提供在 $B_{H}$ 和 $B_{J}$ 处为 $best$ 插入的 $\\phi$ 函数的总数。", "solution": "用户希望根据静态单赋值（SSA）形式的原则，确定变量 `best` 在特定位置（即循环头部 $B_{H}$ 和汇合块 $B_{J}$）所需的 $\\phi$ 函数总数。最小 $\\phi$ 函数放置的标准算法涉及计算包含该变量定义的所有基本块集合的迭代支配边界。\n\n首先，我们识别出变量 `best` 被赋值的块的集合，我们称之为 $S_{defs}$。根据问题描述，`best` 在 $B_{S}$ 中被初始化，并在 $B_{T}$ 和 $B_{F\\_T}$ 中被重新定义。\n因此，定义块的集合是：\n$$S_{defs} = \\{B_{S}, B_{T}, B_{F\\_T}\\}$$\n\n需要 $\\phi$ 函数的最小块集合，记为 $\\Phi$，是 $S_{defs}$ 的迭代支配边界，写作 $\\mathrm{DF}^{+}(S_{defs})$。我们使用迭代工作列表算法来计算这个集合。\n\n设 $\\Phi$ 是需要 $\\phi$ 函数的块的集合，设 $W$ 是一个工作列表，其中包含其支配边界需要处理的块。\n\n1.  **初始化:**\n    *   $\\Phi = \\emptyset$\n    *   $W = S_{defs} = \\{B_{S}, B_{T}, B_{F\\_T}\\}$\n\n该算法通过从工作列表 $W$ 中重复取出一个块 $X$，并将其支配边界 $\\mathrm{DF}(X)$ 中的块添加到 $\\Phi$ 中来进行。任何新添加到 $\\Phi$ 中的块（即原先不在 $\\Phi$ 中）也会被添加到工作列表 $W$ 中。当 $W$ 为空时，过程终止。\n\n要执行此算法，我们必须首先计算相关块的支配边界。一个块 $X$ 的支配边界 $\\mathrm{DF}(X)$ 是所有块 $Y$ 的集合，满足 $X$ 支配 $Y$ 的一个前驱，但 $X$ 并不严格支配 $Y$。\n\n我们来分析初始工作列表中各块的支配边界：\n\n*   **$\\mathrm{DF}(B_{S})$**: 块 $B_{S}$ 是循环前置头部。它支配循环内的所有块以及循环出口块。从 $B_S$ 开始的路径仅在循环头部 $B_H$ 与其他路径合并。然而，在 $B_H$ 处的合并是来自 $B_S$ 的路径和来自 $B_L$ 的回边路径之间的合并。在 $B_H$ 处需要 $\\phi$ 函数是由于循环内部的定义所致，这由循环内部某个块（具体是 $B_L$，或通过传播，是 $B_J$）的支配边界所捕获。对于 $B_S$ 本身的定义，它有一条“无阻碍”的支配路径。形式上，对于任何由 $B_S$ 支配的块 $P$ 的后继 $Y$，$B_S$ 也严格支配 $Y$。因此，它的支配边界为空。$\\mathrm{DF}(B_{S}) = \\emptyset$。\n\n*   **$\\mathrm{DF}(B_{T})$**: 块 $B_{T}$ 有一个后继 $B_{J}$。$B_J$ 是一个汇合点，来自 $B_T$、$B_{F\\_T}$ 和 $B_{F\\_F}$ 的控制流在此合并。在 $B_{T}$ 中的定义需要在这个合并点处有一个 $\\phi$ 函数。形式上，$B_T$ 支配其自身（$B_J$ 的一个前驱），但 $B_T$ 并不严格支配 $B_J$（在支配树中，它们是在其共同的直接支配者 $B_C$ 下的兄弟节点）。因此，$B_{J} \\in \\mathrm{DF}(B_{T})$。由于 $B_J$ 是唯一的后继，所以 $\\mathrm{DF}(B_{T}) = \\{B_{J}\\}$。\n\n*   **$\\mathrm{DF}(B_{F\\_T})$**: 与 $B_{T}$ 类似，块 $B_{F\\_T}$ 的后继是 $B_J$。$B_{F\\_T}$ 支配其自身，但不严格支配汇合块 $B_{J}$。因此，$B_{J} \\in \\mathrm{DF}(B_{F\\_T})$，且 $\\mathrm{DF}(B_{F\\_T}) = \\{B_{J}\\}$。\n\n现在，我们执行 $\\mathrm{DF}^{+}(S_{defs})$ 的迭代计算：\n\n**初始状态:** $\\Phi = \\emptyset$, $W = \\{B_{S}, B_{T}, B_{F\\_T}\\}$\n\n**第1步:** 从 $W$ 中取出 $B_S$。\n*   $W = \\{B_{T}, B_{F\\_T}\\}$。\n*   $\\mathrm{DF}(B_{S}) = \\emptyset$。$\\Phi$ 和 $W$ 无变化。\n\n**第2步:** 从 $W$ 中取出 $B_T$。\n*   $W = \\{B_{F\\_T}\\}$。\n*   $\\mathrm{DF}(B_{T}) = \\{B_{J}\\}$。\n*   $B_{J}$ 不在 $\\Phi$ 中。我们更新 $\\Phi = \\Phi \\cup \\{B_{J}\\} = \\{B_{J}\\}$。\n*   我们将 $B_{J}$ 添加到工作列表：$W = W \\cup \\{B_{J}\\} = \\{B_{F\\_T}, B_{J}\\}$。\n\n**第3步:** 从 $W$ 中取出 $B_{F\\_T}$。\n*   $W = \\{B_{J}\\}$。\n*   $\\mathrm{DF}(B_{F\\_T}) = \\{B_{J}\\}$。\n*   $B_{J}$ 已经在 $\\Phi$ 中。无变化。\n\n**第4步:** 从 $W$ 中取出 $B_{J}$。\n*   $W = \\emptyset$。\n*   在 $B_J$ 处放置一个 $\\phi$ 函数实际上在 $B_J$ 处创建了一个 `best` 的新定义。我们现在必须通过计算 $\\mathrm{DF}(B_{J})$ 来找出这个新定义在何处需要更多的 $\\phi$ 函数。\n*   块 $B_J$ 之后是循环尾部 $B_L$，它有一条到循环头部 $B_H$ 的回边。在 $B_J$ 定义的值在通过 $B_L$ 后仍然活跃并到达 $B_H$。在 $B_H$，这条路径与来自循环前置头部 $B_S$ 的路径合并。因此，$B_H$ 位于一个从循环内部传播值的块的支配边界中。形式上，$\\mathrm{DF}(B_J) = \\{B_H\\}$。\n*   $B_{H}$ 不在 $\\Phi$ 中。我们更新 $\\Phi = \\Phi \\cup \\{B_{H}\\} = \\{B_{J}, B_{H}\\}$。\n*   我们将 $B_{H}$ 添加到工作列表：$W = W \\cup \\{B_{H}\\} = \\{B_{H}\\}$。\n\n**第5步:** 从 $W$ 中取出 $B_{H}$。\n*   $W = \\emptyset$。\n*   我们需要计算 $\\mathrm{DF}(B_{H})$。由于 $B_H$ 是一个循环头部，在 $B_H$ 处的定义（例如它自己的 $\\phi$ 函数）会随着循环被携带并与自身重新合并。这意味着 $B_H$ 在其自身的支配边界中。所以，$\\mathrm{DF}(B_{H}) = \\{B_{H}\\}$。\n*   $B_{H}$ 已经在 $\\Phi$ 中。无变化。\n\n工作列表 $W$ 现在为空，因此算法终止。变量 `best` 需要 $\\phi$ 函数的最终块集合是 $\\Phi = \\{B_{J}, B_{H}\\}$。\n\n问题要求在块 $B_{H}$ 和 $B_{J}$ 处为 `best` 放置的 $\\phi$ 函数总数。根据我们的结果，在 $B_J$ 处放置一个 $\\phi$ 函数，在 $B_H$ 处放置一个 $\\phi$ 函数。\n\n因此，总数是 $1 + 1 = 2$。", "answer": "$$\\boxed{2}$$", "id": "3684217"}]}