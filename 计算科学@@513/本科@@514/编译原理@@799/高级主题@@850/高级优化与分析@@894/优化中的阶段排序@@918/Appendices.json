{"hands_on_practices": [{"introduction": "代码规范化是编译器用来简化中间表示的一种常用技术。在这个练习中 ([@problem_id:3662645])，你将探索一个规范化遍（pass）如何通过应用代数规则来标准化表达式，从而为后续的模式匹配优化创造新的机会。通过比较不同阶段排序的结果，你将亲眼见证一个遍如何“启用”另一个遍。", "problem": "考虑一个优化编译器，它作用于一个简单表达式语言的抽象语法树 (AST)，该语言有三种节点：变量、整数常量以及二元运算符 $\\mathrm{Add}$ 和 $\\mathrm{Mul}$。一个编译器遍 $O_{\\mathrm{Canonicalize}}$ 通过应用遵循语义的等式公理来为表达式生成一种规范形式。一个编译器遍 $O_{\\mathrm{PatternMatch}}$ 应用由模式 $P$ 驱动的单个窥孔重写。\n\n基础和核心定义：\n- 表达式是基于签名 $\\{\\mathrm{Add}, \\mathrm{Mul}\\}$ 的树，其叶节点来自变量和整数常量。\n- 遍 $O_{\\mathrm{Canonicalize}}$ 在每个节点（后序）上将以下汇合的、保持语义的规则应用至饱和，从而定义了一个规范化函数 $C$：\n  1. 交换律归一化：对于 $\\mathrm{Add}(u,v)$ 和 $\\mathrm{Mul}(u,v)$，将 $u$ 递归地规范化为 $u'$，将 $v$ 递归地规范化为 $v'$，然后对序对 $(u',v')$ 进行排序，使得相对于下面定义的固定全序 $\\preceq$ 满足 $u' \\preceq v'$。\n  2. 中性元消除：$\\mathrm{Add}(u,0) \\to u$、$\\mathrm{Add}(0,u) \\to u$、$\\mathrm{Mul}(u,1) \\to u$、$\\mathrm{Mul}(1,u) \\to u$ 以及 $\\mathrm{Mul}(u,0) \\to 0$、$\\mathrm{Mul}(0,u) \\to 0$。\n  3. 对于具有两个常量子节点的二元节点进行常量折叠：当 $m$ 和 $n$ 是整数常量时，$\\mathrm{Add}(m,n) \\to m+n$ 以及 $\\mathrm{Mul}(m,n) \\to m \\cdot n$。\n- 规范化表达式上的全序 $\\preceq$ 定义如下：常量按数值大小排序；变量按名称的字典序排序；复合节点按三元组 $(\\mathrm{op}, u', v')$ 的字典序排序，其中 $\\mathrm{op} \\in \\{\\mathrm{Add}, \\mathrm{Mul}\\}$ 按名称字符串排序，而 $u',v'$ 是递归比较的规范化子节点。这在交换律下确定了一个确定性的操作数顺序。\n- 遍 $O_{\\mathrm{PatternMatch}}$ 仅在每个顶层表达式的根部尝试匹配单个模式 $P \\colon \\mathrm{Add}(E,E)$，其中 $E$ 表示任意子树。当模式匹配时，一次重写便符合资格（例如，重写为 $\\mathrm{Mul}(2,E)$），但对于本问题，只有成功匹配的数量是重要的。\n- 对于给定的程序表达式序列，将 $m(P)$ 定义为在单次 $O_{\\mathrm{PatternMatch}}$ 遍中匹配 $P$ 的顶层根的数量。\n\n考虑两种阶段顺序：\n- 顺序 $\\mathcal{A}$：首先将 $O_{\\mathrm{Canonicalize}}$ 应用于每个顶层表达式，然后将 $O_{\\mathrm{PatternMatch}}$ 在结果集中每个顶层表达式的根部应用一次；令所得计数为 $m_{\\mathcal{A}}(P)$。\n- 顺序 $\\mathcal{B}$：首先将 $O_{\\mathrm{PatternMatch}}$ 在每个原始顶层表达式的根部应用一次，然后应用 $O_{\\mathrm{Canonicalize}}$；令所得计数为 $m_{\\mathcal{B}}(P)$。\n\n考虑以下12个顶层中间表示 (IR) 表达式的列表（每个都以前缀形式表示为 $\\mathrm{Add}(\\cdot,\\cdot)$ 或 $\\mathrm{Mul}(\\cdot,\\cdot)$），其中 $a,b,c,d,f,g,h,i,j,k,m,p$ 是不同的变量，而 $0,1,2,3$ 是整数常量：\n- $E_{1} = \\mathrm{Add}(\\mathrm{Mul}(a,b),\\mathrm{Mul}(b,a))$。\n- $E_{2} = \\mathrm{Add}(\\mathrm{Add}(a,0),a)$。\n- $E_{3} = \\mathrm{Add}(\\mathrm{Mul}(c,1),c)$。\n- $E_{4} = \\mathrm{Add}(\\mathrm{Add}(a,b),\\mathrm{Add}(b,a))$。\n- $E_{5} = \\mathrm{Add}(\\mathrm{Mul}(2,d),\\mathrm{Add}(d,d))$。\n- $E_{6} = \\mathrm{Add}(\\mathrm{Mul}(0,p),p)$。\n- $E_{7} = \\mathrm{Add}(\\mathrm{Mul}(f,1),\\mathrm{Mul}(1,f))$。\n- $E_{8} = \\mathrm{Add}(\\mathrm{Add}(g,1),\\mathrm{Add}(1,g))$。\n- $E_{9} = \\mathrm{Add}(\\mathrm{Mul}(3,h),\\mathrm{Mul}(h,3))$。\n- $E_{10} = \\mathrm{Add}(\\mathrm{Add}(i,j),\\mathrm{Add}(i,j))$。\n- $E_{11} = \\mathrm{Add}(\\mathrm{Add}(k,0),\\mathrm{Add}(0,k))$。\n- $E_{12} = \\mathrm{Add}(\\mathrm{Mul}(1,\\mathrm{Add}(m,0)),\\mathrm{Add}(0,\\mathrm{Add}(1,m)))$。\n\n计算此程序如上定义的序对 $\\big(m_{\\mathcal{A}}(P), m_{\\mathcal{B}}(P)\\big)$，并将最终结果表示为行矩阵。不需要四舍五入。答案中不要包含任何单位。", "solution": "问题要求计算一个数值对 $(m_{\\mathcal{A}}(P), m_{\\mathcal{B}}(P))$，它表示在两种不同的编译器阶段顺序 $\\mathcal{A}$ 和 $\\mathcal{B}$ 下，模式 $P \\colon \\mathrm{Add}(E,E)$ 的成功匹配次数。如果一个顶层表达式的形式为 $\\mathrm{Add}(E,E)$，即两个相同子树的加法，则模式 $P$ 匹配该表达式。\n\n两种阶段顺序是：\n- 顺序 $\\mathcal{A}$：将规范化遍 $O_{\\mathrm{Canonicalize}}$ 应用于所有表达式，然后应用模式匹配遍 $O_{\\mathrm{PatternMatch}}$。匹配的数量为 $m_{\\mathcal{A}}(P)$。\n- 顺序 $\\mathcal{B}$：将模式匹配遍 $O_{\\mathrm{PatternMatch}}$ 应用于所有原始表达式，然后应用规范化遍 $O_{\\mathrm{Canonicalize}}$。匹配的数量为 $m_{\\mathcal{B}}(P)$。\n\n令 $C(e)$ 表示表达式 $e$ 应用遍 $O_{\\mathrm{Canonicalize}}$ 后的规范形式。规范化的规则是：基于全序 $\\preceq$ 的交换律排序、中性元消除和常量折叠。排序顺序 $\\preceq$ 定义为常量（按值）$\\prec$ 变量（按字典序）$\\prec$ 复合节点。复合节点按运算符名称（即 $\\mathrm{Add} \\prec \\mathrm{Mul}$）的字典序，然后递归地按其子节点排序。\n\n首先，我们计算顺序 $\\mathcal{B}$ 的 $m_{\\mathcal{B}}(P)$。\n在此顺序中，模式匹配遍 $O_{\\mathrm{PatternMatch}}$ 首先应用于原始的12个表达式列表。计数 $m_{\\mathcal{B}}(P)$ 是在任何转换之前，语法上匹配 $\\mathrm{Add}(E,E)$ 的表达式数量。\n\n我们检查 $i \\in \\{1, \\dots, 12\\}$ 的每个表达式 $E_i$：\n- $E_1, \\dots, E_9$：根节点 $\\mathrm{Add}$ 的两个子节点在语法上不相同。例如，在 $E_1 = \\mathrm{Add}(\\mathrm{Mul}(a,b),\\mathrm{Mul}(b,a))$ 中，子节点 $\\mathrm{Mul}(a,b)$ 和 $\\mathrm{Mul}(b,a)$ 是不同的抽象语法树。这些都不匹配。\n- $E_{10} = \\mathrm{Add}(\\mathrm{Add}(i,j),\\mathrm{Add}(i,j))$：左子节点 $\\mathrm{Add}(i,j)$ 与右子节点 $\\mathrm{Add}(i,j)$ 在语法上相同。这是一个匹配。\n- $E_{11} = \\mathrm{Add}(\\mathrm{Add}(k,0),\\mathrm{Add}(0,k))$：子节点 $\\mathrm{Add}(k,0)$ 和 $\\mathrm{Add}(0,k)$ 在语法上不相同。不匹配。\n- $E_{12} = \\mathrm{Add}(\\mathrm{Mul}(1,\\mathrm{Add}(m,0)),\\mathrm{Add}(0,\\mathrm{Add}(1,m)))$：子节点在语法上不相同。不匹配。\n\n只有一个表达式 $E_{10}$ 以其原始形式匹配模式 $P$。因此，顺序 $\\mathcal{B}$ 的计数为 $m_{\\mathcal{B}}(P) = 1$。\n\n其次，我们计算顺序 $\\mathcal{A}$ 的 $m_{\\mathcal{A}}(P)$。\n在此顺序中，我们首先将规范化遍 $O_{\\mathrm{Canonicalize}}$ 应用于每个表达式 $E_i$ 以获得其规范形式 $C(E_i)$。然后，我们检查 $C(E_i)$ 是否匹配模式 $\\mathrm{Add}(E,E)$。\n\n我们分析每个表达式的规范形式：\n- $E_1 = \\mathrm{Add}(\\mathrm{Mul}(a,b),\\mathrm{Mul}(b,a))$：$C(\\mathrm{Mul}(a,b)) = \\mathrm{Mul}(a,b)$（假设 $a \\preceq b$）。$C(\\mathrm{Mul}(b,a))$ 在排序后也变为 $\\mathrm{Mul}(a,b)$。所以，$C(E_1) = \\mathrm{Add}(\\mathrm{Mul}(a,b),\\mathrm{Mul}(a,b))$。这匹配 $P$。\n- $E_2 = \\mathrm{Add}(\\mathrm{Add}(a,0),a)$：通过中性元消除，$C(\\mathrm{Add}(a,0)) = a$。所以，$C(E_2) = \\mathrm{Add}(a,a)$。这匹配 $P$。\n- $E_3 = \\mathrm{Add}(\\mathrm{Mul}(c,1),c)$：通过中性元消除，$C(\\mathrm{Mul}(c,1)) = c$。所以，$C(E_3) = \\mathrm{Add}(c,c)$。这匹配 $P$。\n- $E_4 = \\mathrm{Add}(\\mathrm{Add}(a,b),\\mathrm{Add}(b,a))$：$C(\\mathrm{Add}(a,b)) = \\mathrm{Add}(a,b)$（假设 $a \\preceq b$）。$C(\\mathrm{Add}(b,a))$ 在排序后变为 $\\mathrm{Add}(a,b)$。所以，$C(E_4) = \\mathrm{Add}(\\mathrm{Add}(a,b),\\mathrm{Add}(a,b))$。这匹配 $P$。\n- $E_5 = \\mathrm{Add}(\\mathrm{Mul}(2,d),\\mathrm{Add}(d,d))$：规范化的子节点是 $C(\\mathrm{Mul}(2,d)) = \\mathrm{Mul}(2,d)$ 和 $C(\\mathrm{Add}(d,d)) = \\mathrm{Add}(d,d)$。根据 $\\preceq$，$\\mathrm{Add} \\prec \\mathrm{Mul}$，所以 $\\mathrm{Add}(d,d) \\preceq \\mathrm{Mul}(2,d)$。对子节点排序后得到 $C(E_5) = \\mathrm{Add}(\\mathrm{Add}(d,d), \\mathrm{Mul}(2,d))$。子节点不相同。不匹配。\n- $E_6 = \\mathrm{Add}(\\mathrm{Mul}(0,p),p)$：根据吸收元规则，$C(\\mathrm{Mul}(0,p)) = 0$。表达式变为 $\\mathrm{Add}(0,p)$，规范化后为 $p$。最终形式不是一个 $\\mathrm{Add}$ 节点。不匹配。\n- $E_7 = \\mathrm{Add}(\\mathrm{Mul}(f,1),\\mathrm{Mul}(1,f))$：$C(\\mathrm{Mul}(f,1)) = f$ 并且 $C(\\mathrm{Mul}(1,f)) = f$。所以，$C(E_7) = \\mathrm{Add}(f,f)$。这匹配 $P$。\n- $E_8 = \\mathrm{Add}(\\mathrm{Add}(g,1),\\mathrm{Add}(1,g))$：$1 \\preceq g$，所以 $C(\\mathrm{Add}(g,1)) = \\mathrm{Add}(1,g)$。$C(\\mathrm{Add}(1,g))$ 已经是规范形式。所以，$C(E_8) = \\mathrm{Add}(\\mathrm{Add}(1,g),\\mathrm{Add}(1,g))$。这匹配 $P$。\n- $E_9 = \\mathrm{Add}(\\mathrm{Mul}(3,h),\\mathrm{Mul}(h,3))$：$3 \\preceq h$，所以 $C(\\mathrm{Mul}(h,3)) = \\mathrm{Mul}(3,h)$。$C(\\mathrm{Mul}(3,h))$ 已经是规范形式。所以，$C(E_9) = \\mathrm{Add}(\\mathrm{Mul}(3,h),\\mathrm{Mul}(3,h))$。这匹配 $P$。\n- $E_{10} = \\mathrm{Add}(\\mathrm{Add}(i,j),\\mathrm{Add}(i,j))$：假设 $i \\preceq j$，则 $C(\\mathrm{Add}(i,j)) = \\mathrm{Add}(i,j)$。子节点相同且已是规范形式。其形式保持为 $\\mathrm{Add}(\\mathrm{Add}(i,j),\\mathrm{Add}(i,j))$。这匹配 $P$。\n- $E_{11} = \\mathrm{Add}(\\mathrm{Add}(k,0),\\mathrm{Add}(0,k))$：$C(\\mathrm{Add}(k,0)) = k$ 并且 $C(\\mathrm{Add}(0,k)) = k$。所以，$C(E_{11}) = \\mathrm{Add}(k,k)$。这匹配 $P$。\n- $E_{12} = \\mathrm{Add}(\\mathrm{Mul}(1,\\mathrm{Add}(m,0)),\\mathrm{Add}(0,\\mathrm{Add}(1,m)))$：\n  - 左子节点：$C(\\mathrm{Mul}(1, \\mathrm{Add}(m,0))) = C(\\mathrm{Mul}(1, C(\\mathrm{Add}(m,0)))) = C(\\mathrm{Mul}(1,m)) = m$。\n  - 右子节点：$C(\\mathrm{Add}(0, \\mathrm{Add}(1,m))) = C(\\mathrm{Add}(0, C(\\mathrm{Add}(1,m)))) = C(\\mathrm{Add}(0, \\mathrm{Add}(1,m))) = \\mathrm{Add}(1,m)$。\n  - 表达式变为 $\\mathrm{Add}(m, \\mathrm{Add}(1,m))$。我们对子节点进行排序。因为变量 $\\prec$ 复合节点，所以 $m \\preceq \\mathrm{Add}(1,m)$。子节点已经有序。最终形式是 $C(E_{12}) = \\mathrm{Add}(m, \\mathrm{Add}(1,m))$。子节点不相同。不匹配。\n\n规范化后匹配模式 $P$ 的表达式是 $E_1, E_2, E_3, E_4, E_7, E_8, E_9, E_{10}, E_{11}$。共有9个这样的表达式。\n因此，顺序 $\\mathcal{A}$ 的计数为 $m_{\\mathcal{A}}(P) = 9$。\n\n结果序对为 $(m_{\\mathcal{A}}(P), m_{\\mathcal{B}}(P)) = (9, 1)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n9  1\n\\end{pmatrix}\n}\n$$", "id": "3662645"}, {"introduction": "并非所有的优化遍都能和谐共存；有时，它们的顺序会引发冲突。这个实践 ([@problem_id:3662669]) 呈现了一个经典场景：函数内联可能会干扰尾调用优化（TCO）。你将分析一个看似有益的内联决策如何破坏了 TCO 所需的特定语法模式，从而导致程序栈使用方面产生截然不同的结果。", "problem": "考虑以下一个程序的简化中间表示，该程序所用的语言具有可调用函数和返回。最大栈深度定义为执行期间同时存活的激活记录的最大数量，对于程序 $P$ 表示为 $d(P)$。如果函数返回的恰好是调用表达式的值而没有进一步的计算，则该调用处于尾部位置。尾调用优化 (Tail-Call Optimization, TCO) 是一种将尾递归函数重写为循环的优化，从而将栈深度限制在一个常数。内联展开 (Inline Expansion, Inlining) 是一种在调用点用函数体替换对小函数的调用的优化。\n\n您将分析尾调用优化和内联展开之间的阶段排序交互作用。程序 $P_{n}$ 由一个整数 $n \\geq 1$ 参数化，并由两个函数组成：\n- 一个恒等辅助函数 $I(x)$，它返回其参数。\n- 一个尾递归函数 $F(i,a)$，它迭代 $i$ 次，递增一个累加器 $a$：\n$$\nI(x) \\triangleq x\n$$\n$$\nF(i,a) \\triangleq\n\\begin{cases}\na,  \\text{if } i = 0 \\\\\nI\\big(F(i-1,a+1)\\big),  \\text{if } i > 0\n\\end{cases}\n$$\n入口点是 $F(n,0)$。\n\n编译器有两个优化过程：\n- $O_{\\mathrm{TailCallOpt}}$ (尾调用优化, TCO)：此过程仅当函数 $G$ 在尾部位置返回形如 $G(\\ldots)$ 的直接调用表达式时，才会重写该函数，也就是说，语法形式必须是 $\\,\\texttt{return}\\;G(\\ldots)\\,$，没有中间的临时赋值，也没有返回后的收尾代码。当适用于 $F$ 中的自调用时，该过程将递归转换为循环，从而对所有 $n$ 产生常数栈深度 $1$。\n- $O_{\\mathrm{Inline}}$ (内联展开)：此过程在 $I$ 的调用点将其内联。将 $I$ 内联到 $F$ 中，会将形如 $\\,\\texttt{return}\\;I(F(\\ldots))\\,$ 的尾返回转换为一个两步序列：将递归调用的结果赋给一个临时变量，然后返回该临时变量，即 $\\,\\texttt{tmp} \\leftarrow F(\\ldots);\\;\\texttt{return}\\;\\texttt{tmp}\\,$。根据规定的 $O_{\\mathrm{TailCallOpt}}$ 规则，这种形式在语法上不被识别为尾调用，因此之后不会执行尾调用重写。\n\n假设采用传统的调用栈语义，在没有尾调用优化的情况下，每次递归调用都会增加一个激活记录，因此在没有尾调用优化的情况下计算 $F(n,0)$ 会在最深处（计算初始帧在内）产生 $n+1$ 的栈深度。\n\n设 $d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n})$ 表示先运行 $O_{\\mathrm{Inline}}$ 再运行 $O_{\\mathrm{TailCallOpt}}$ 时的最大栈深度，设 $d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n})$ 表示先运行 $O_{\\mathrm{TailCallOpt}}$ 再运行 $O_{\\mathrm{Inline}}$ 时的最大栈深度。\n\n对于特定输入 $n = 1024$，计算比率\n$$\nR \\triangleq \\frac{d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n})}{d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n})}.\n$$\n提供 $R$ 的最终数值。无需四舍五入。以纯数字形式表示答案，不带单位。", "solution": "用户希望我解决一个关于编译器阶段排序的问题。\n\n## 任务\n问题要求计算一个比率 $R$，该比率与程序 $P_n$ 在两种不同编译器优化序列下的最大栈深度有关：尾调用优化 (TCO) 和内联展开 (Inlining)。\n\n### 问题验证\n首先，我将验证问题陈述。\n\n**步骤 1：提取已知条件**\n- 由 $n \\geq 1$ 参数化的程序 $P_n$。\n- 函数：\n    - 恒等函数：$I(x) \\triangleq x$\n    - 递归函数：$F(i,a) \\triangleq \\begin{cases} a,  \\text{if } i = 0 \\\\ I\\big(F(i-1,a+1)\\big),  \\text{if } i > 0 \\end{cases}$\n- 程序入口点：$F(n,0)$\n- 最大栈深度：$d(P)$，同时存在的激活记录的最大数量。\n- 基础栈深度：对于 $F(n,0)$，在没有 TCO 的情况下，最大栈深度为 $n+1$。\n- 优化 $O_{\\mathrm{TailCallOpt}}$ (TCO)：将语法形式为 `return G(...)` 的自递归函数 `G` 重写为循环，从而得到常数栈深度 $1$。\n- 优化 $O_{\\mathrm{Inline}}$ (内联展开)：用 `I` 的函数体替换其调用。问题明确指出，将 `I` 内联到 `F` 中会将形如 `return I(F(...))` 的返回转换为序列 `tmp ← F(...); return tmp`，这被明确定义为 $O_{\\mathrm{TailCallOpt}}$ 无法识别的语法形式。\n- 先 `Inline` 后 `TCO` 的栈深度：$d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n})$。\n- 先 `TCO` 后 `Inline` 的栈深度：$d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n})$。\n- 参数的具体值：$n = 1024$。\n- 目标：计算比率 $R \\triangleq \\frac{d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n})}{d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n})}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上基于编译器设计的原理，特别是阶段排序问题。内联、尾调用优化和栈深度的概念都是标准的。在本问题的背景下，这些优化如何运作以及如何相互作用的规则都已明确定义。虽然 $O_{\\mathrm{Inline}}$ 过程的定义行为被特意设计为“悲观的”（即它主动妨碍另一个优化），但这是在构建问题以说明此类交互时常用的一种技巧。问题陈述清晰，目标明确，并包含足够的信息以得出唯一解。需要仔细阅读以综合这些规则。TCO 适用于“$F$ 中的自调用”这一陈述意味着，即使语法看起来是 `return I(F(...))`，编译器也被设计为能够优化原始函数。这表明 TCO 过程足够强大，可以识别恒等函数包装器，这在优化编译器中是一个现实的功能。因此，该问题并非自相矛盾，但需要仔细推导。\n\n**步骤 3：结论与行动**\n问题是有效的。我将继续进行解答。\n\n### 解法\n目标是为 $n = 1024$ 计算比率 $R = \\frac{d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n})}{d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n})}$。这需要计算两种不同优化序列的最大栈深度。\n\n**1. $O_{\\mathrm{Inline}} \\rightarrow O_{\\mathrm{TailCallOpt}}$ 阶段顺序分析**\n\n首先，我们分析内联过程在尾调用优化过程之前运行的情况。\n\n- **应用 $O_{\\mathrm{Inline}}$：** 编译器处理原始程序 $P_n$。函数 $F$ 中的递归情况由表达式 `return I(F(i-1, a+1))` 定义。问题为 $O_{\\mathrm{Inline}}$ 过程如何转换此确切结构提供了一条特定规则：它被重写为一个使用临时变量的两步序列。\n  原始代码 `return I(F(i-1, a+1))` 被转换为 `tmp ← F(i-1, a+1); return tmp`。\n  此过程结束后，函数 $F$ 已被修改为一个新函数，我们称之为 $F'$，其返回语句不再是纯粹的递归形式。\n\n- **应用 $O_{\\mathrm{TailCallOpt}}$：** 编译器的第二个过程是 TCO。它分析修改后的函数 $F'$。$O_{\\mathrm{TailCallOpt}}$ 的规则是，它仅适用于具有 `return G(...)` 这种直接自递归调用语法形式的函数。$F'$ 的递归部分现在是 `tmp ← F'(i-1, a+1); return tmp`。正如问题陈述明确说明的那样，这种形式不被 $O_{\\mathrm{TailCallOpt}}$ 过程识别。因此，尾调用优化不会被应用。\n\n- **最终栈深度：** 由于没有执行 TCO，程序以标准的基于栈的递归方式执行。问题陈述指出，在没有 TCO 的情况下执行 $F(n,0)$ 会产生 $n+1$ 的最大栈深度。$O_{\\mathrm{Inline}}$ 的转换并未改变递归调用结构，只改变了其语法表示，因此这个栈深度计算仍然成立。\n  因此，此阶段顺序的最大栈深度为：\n  $$d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n}) = n+1$$\n\n**2. $O_{\\mathrm{TCO}} \\rightarrow O_{\\mathrm{Inline}}$ 阶段顺序分析**\n\n接下来，我们分析尾调用优化过程在内联过程之前运行的情况。\n\n- **应用 $O_{\\mathrm{TailCallOpt}}$：** 编译器首先处理原始程序 $P_n$。$F$ 中的递归步骤是 `return I(F(i-1, a+1))`。$O_{\\mathrm{TailCallOpt}}$ 的优化规则要求语法匹配 `return G(...)` 形式的函数 `G`。表面上看，代码 `return I(F(...))` 与 `return F(...)` 不匹配。然而，问题提供的线索表明此优化意在成功：它将 TCO 描述为重写“尾递归函数”，并提到其适用于“$F$ 中的自调用”。一个一致的解释是，$O_{\\mathrm{TailCallOpt}}$ 过程能够“看穿”恒等函数 `I`，实际上为其模式匹配的目的将 `I(F(...))` 视为 `F(...)`。这对于优化编译器来说是一个合理的假设。\n  在此解释下，TCO 过程将 $F$ 识别为一个尾递归函数。问题陈述指出，该优化随后“将递归转换为循环，从而对所有 $n$ 产生常数栈深度 $1$”。因此，函数 $F$ 被重写为一个迭代的、非递归的函数 $F_{\\text{loop}}$，它不再包含对自己或对 `I` 的调用。\n\n- **应用 $O_{\\mathrm{Inline}}$：** 第二个过程是内联。编译器接收到带有优化后函数 $F_{\\text{loop}}$ 的程序。由于 TCO 过程消除了递归调用 `I(F(...))`，因此在主计算循环中不再有函数 `I` 的调用点。因此，$O_{\\mathrm{Inline}}$ 过程没有代码可以转换，不起任何作用。\n\n- **最终栈深度：** 最终的程序包含 $F$ 的迭代版本。执行此函数涉及单个函数调用 $F_{\\text{loop}}(n,0)$，该函数随后进行迭代而无需创建新的栈帧。如问题所述，最大栈深度为常数。\n  因此，此阶段顺序的最大栈深度为：\n  $$d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n}) = 1$$\n\n**3. 最终计算**\n\n我们需要计算在特定情况 $n = 1024$ 下的比率 $R$。\n\n- 分子是 $d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{1024}) = n+1 = 1024+1 = 1025$。\n- 分母是 $d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{1024}) = 1$。\n\n比率为：\n$$R = \\frac{d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{1024})}{d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{1024})} = \\frac{1025}{1} = 1025$$\n这个结果表明，对于给定的程序，两种编译器优化之间存在显著的阶段排序依赖性。`TCO -> Inline` 的顺序显然更优，因为它在栈空间方面产生了更高效的程序。", "answer": "$$\\boxed{1025}$$", "id": "3662669"}, {"introduction": "许多优化的最终目标是提高执行速度，而这一因素深受指令调度等后端阶段的影响。这个问题 ([@problem_id:3662593]) 要求你分析一个程序段的关键路径，它决定了程序的最短执行时间。你将计算在调度前应用死代码消除（DCE）如何为调度器解除约束，从而使其能够生成更快的程序。", "problem": "考虑编译器中死代码消除 (DCE) 和指令调度 (IS) 之间的阶段顺序。在没有副作用和内存非易失性的假设下，死代码消除 (DCE) 会移除那些对任何外部可观察的程序状态没有贡献的计算。指令调度 (IS) 根据数据依赖对指令进行排序，但不会改变延迟或依赖关系。将一个基本块的依赖结构建模为一个有向无环图 (DAG)，其节点是指令，边编码了真数据依赖。程序块 $P$ 的关键路径长度 $\\chi(P)$ 定义为 DAG 中所有从源到汇的路径上指令延迟之和的最大值。\n\n设 $P$ 为以下单个基本块（静态单赋值 (SSA) 形式），由两个独立的链组成。所有操作都是纯操作，内存读取是非易失性、在边界内的，且不会产生陷阱。只有变量 $y$ 在块退出时是活跃的；所有其他临时变量都是死的（在块之后从未被使用）：\n\n活跃链：\n- $I_{1}: r_{a} \\leftarrow \\mathrm{ld}(a)$，延迟为 $5$，\n- $I_{2}: r_{b} \\leftarrow \\mathrm{ld}(b)$，延迟为 $5$，\n- $I_{3}: s_{1} \\leftarrow r_{a} + r_{b}$，延迟为 $1$，\n- $I_{4}: m_{1} \\leftarrow s_{1} \\times c$，延迟为 $3$，\n- $I_{5}: y \\leftarrow m_{1} + d$，延迟为 $1$ (活跃的)。\n\n死链：\n- $I_{6}: r_{e} \\leftarrow \\mathrm{ld}(e)$，延迟为 $5$，\n- $I_{7}: t_{1} \\leftarrow r_{e} \\times f$，延迟为 $3$，\n- $I_{8}: t_{2} \\leftarrow t_{1} / g$，延迟为 $10$，\n- $I_{9}: t_{3} \\leftarrow t_{2} + h$，延迟为 $1$，\n- $I_{10}: t \\leftarrow t_{3} - k$，延迟为 $1$ (死的；$t$ 未被使用)。\n\n假设调度器在当前存在的指令上构建其 DAG，且机器有足够的资源，使得调度长度的下界为 $\\chi(P)$，且不能短于 $\\chi(P)$。考虑两种阶段顺序：\n- $O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}$：先对原始块执行指令调度，然后运行 DCE。\n- $O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}$：先对原始块运行 DCE，然后执行指令调度。\n\n计算减少量 $R$，定义为\n$$\nR \\equiv \\chi_{O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}}(P) - \\chi_{O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}}(P),\n$$\n并将最终答案以周期为单位表示为一个精确整数（无舍入）。", "solution": "我们从核心定义开始。该块的指令级依赖结构是一个有向无环图 (DAG)，其中每条指令是一个由其延迟加权的节点，边代表真数据依赖。关键路径长度 $\\chi(P)$ 是 DAG 中所有从源到汇的路径上节点延迟之和的最大值。指令调度 (IS) 遵循依赖关系和延迟；在资源充足的情况下，调度长度不能短于 DAG 的关键路径。死代码消除 (DCE) 会移除那些结果对任何活跃输出没有贡献且没有副作用的节点，从而可能缩减 DAG 及其关键路径。\n\n我们分析这两个独立的链。\n\n活跃链：\n- $I_{1}$ ($5$) 和 $I_{2}$ ($5$) 都为 $I_{3}$ ($1$) 提供输入。由于 $I_{3}$ 同时依赖于 $r_{a}$ 和 $r_{b}$，到达 $I_{3}$ 的时间是其前驱节点到达时间的最大值。$I_{1}$ 和 $I_{2}$ 都是源节点，因此它们的值准备好的最早时间各为 $5$。因此，$s_{1}$ 在 $I_{3}$ 处准备好的最早时间是 $5 + 1 = 6$。\n- $I_{4}$ ($3$) 依赖于 $I_{3}$，所以它沿最长路径的完成时间是 $6 + 3 = 9$。\n- $I_{5}$ ($1$) 依赖于 $I_{4}$，所以它沿最长路径的完成时间是 $9 + 1 = 10$。\n\n因此，活跃链的关键路径长度为\n$$\n\\chi_{\\text{live}} = 10.\n$$\n\n死链：\n这个链是线性的，所以我们将其延迟相加：\n- $I_{6}$ ($5$) $\\rightarrow$ $I_{7}$ ($3$): $5 + 3 = 8$,\n- $\\rightarrow I_{8}$ ($10$): $8 + 10 = 18$,\n- $\\rightarrow I_{9}$ ($1$): $18 + 1 = 19$,\n- $\\rightarrow I_{10}$ ($1$): $19 + 1 = 20$.\n\n因此，\n$$\n\\chi_{\\text{dead}} = 20.\n$$\n\n由于这两个链是独立的，整个 DAG 的关键路径 $\\chi(P)$ 是调度时图中存在的两个链的关键路径的最大值。\n\n对于阶段顺序 $O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}$，调度首先在包含两个链的原始块上运行。因此，调度器的 DAG 包含死链。调度时的关键路径是\n$$\n\\chi_{O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}}(P) = \\max\\left(\\chi_{\\text{live}}, \\chi_{\\text{dead}}\\right) = \\max(10, 20) = 20.\n$$\n\n对于阶段顺序 $O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}$，死代码消除首先运行。死链中的所有操作都是纯操作，链的结果 $t$ 未被使用，内存读取是非易失性且不会产生陷阱的，因此 DCE 会移除 $I_6$ 到 $I_{10}$。调度器随后在只包含活跃链的简化块上操作。调度时的关键路径变为\n$$\n\\chi_{O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}}(P) = \\chi_{\\text{live}} = 10.\n$$\n\n根据定义，减少量 $R$ 是\n$$\nR \\equiv \\chi_{O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}}(P) - \\chi_{O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}}(P) = 20 - 10 = 10.\n$$\n\n因此，在指令调度之前执行死代码消除，会使调度器可用的关键路径长度减少 $10$ 个周期。", "answer": "$$\\boxed{10}$$", "id": "3662593"}]}