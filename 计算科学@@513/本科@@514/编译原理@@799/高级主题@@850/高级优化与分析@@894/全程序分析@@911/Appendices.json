{"hands_on_practices": [{"introduction": "编译器优化的一个基本目标是常量折叠，即在编译时计算出表达式的值。当这个过程涉及函数调用时，我们需要一种方法来总结函数对其输入的影响。本练习将引导你使用范围分析（一种抽象释义的形式）来实现跨过程常量传播，从而让你亲身体验如何为函数创建摘要并利用它们进行全程序优化。[@problem_id:3682735]", "problem": "考虑一个编译器原理中的简单全程序分析任务，其目标是使用范围摘要对算术表达式执行过程间常量折叠。该程序由四个过程和一个主过程组成，其操作语义通过整数上的赋值语句描述如下：\n\n- 过程 $f$ 接受一个整数参数 $a$ 并执行：\n  $r_1 \\leftarrow a + a$，$r_2 \\leftarrow r_1 + 3$，并返回 $r_2$。\n- 过程 $g$ 接受一个整数参数 $b$ 并执行：\n  $t \\leftarrow b + 2$，$u \\leftarrow t + b$，并返回 $u + 1$。\n- 过程 $h$ 不接受参数并返回 $0$。\n- 过程 $k$ 不接受参数并返回 $1$。\n- 主过程执行：\n  $x \\leftarrow f(h())$，$y \\leftarrow g(k())$，并返回 $x + y$。\n\n你的任务是使用抽象解释来构建一个过程间范围分析，以实现常量折叠。从抽象解释的核心定义开始，使用区间抽象域，将具体语义映射到抽象传递函数，为过程 $f$、$g$、$h$ 和 $k$ 推导出可靠的范围摘要，然后在主过程中跨调用组合这些摘要，以获得 $x$、$y$ 以及最终 $x + y$ 的抽象值。\n\n假设区间抽象域由所有满足 $l \\leq u$ 的闭整数区间 $[l,u]$ 组成，按其具体化上的子集关系排序，并且算术是标准整数算术。仅使用来自具体语义的可靠推理来推导每个抽象传递函数；不要假设任何预先给定的快捷公式。明确说明为什么组合分析会为 $x$ 和 $y$ 产生单元素区间，并解释为什么这足以进行常量折叠。\n\n在此过程间范围分析下，主过程中的表达式 $x + y$ 可以被折叠为哪个常量值？请用一个精确的整数表示你的最终答案，不要四舍五入。", "solution": "用户希望我解决一个关于过程间常量折叠的问题。\n\n### 步骤1：提取已知条件\n- 过程 $f(a)$：$r_1 \\leftarrow a + a$，$r_2 \\leftarrow r_1 + 3$，返回 $r_2$。\n- 过程 $g(b)$：$t \\leftarrow b + 2$，$u \\leftarrow t + b$，返回 $u + 1$。\n- 过程 $h()$：返回 $0$。\n- 过程 $k()$：返回 $1$。\n- 主过程：$x \\leftarrow f(h())$，$y \\leftarrow g(k())$，返回 $x + y$。\n- 抽象域：满足 $l \\leq u$ 的闭整数区间 $[l, u]$。\n- 分析任务：执行过程间范围分析，以找到 $x+y$ 的常量值。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，是抽象解释的一个标准应用，而抽象解释是编译器理论和静态程序分析中一种成熟的技术。问题陈述清晰，有一组明确的过程和确定的分析目标。语言客观而精确。问题是自包含的，并提供了推导解决方案所需的所有必要信息。没有违反任何科学定律，且设置是内部一致的。\n\n### 步骤3：结论与行动\n问题有效。我将继续进行解答。\n\n该问题要求基于抽象解释进行过程间范围分析。我们首先定义抽象解释框架的各个组件。\n\n抽象域是闭整数区间的集合，记为 $\\mathcal{D} = \\{ [l, u] \\mid l, u \\in \\mathbb{Z}, l \\leq u \\} \\cup \\{ \\bot \\}$，其中 $\\mathbb{Z}$ 是整数集，$\\bot$ 表示不可达状态。具体化函数 $\\gamma: \\mathcal{D} \\to \\mathcal{P}(\\mathbb{Z})$ 将一个抽象值映射到它所代表的具体整数值的集合：\n$\\gamma([l, u]) = \\{ z \\in \\mathbb{Z} \\mid l \\leq z \\leq u \\}$\n$\\gamma(\\bot) = \\emptyset$\n\n我们必须为程序中的操作定义抽象传递函数。唯一的算术运算是加法。对于抽象值为 $[l_1, u_1]$ 和 $[l_2, u_2]$ 的两个变量，它们的和 $v_1 + v_2$ 可以取任何具体值 $z = z_1 + z_2$，其中 $z_1 \\in \\gamma([l_1, u_1])$ 并且 $z_2 \\in \\gamma([l_2, u_2])$。$z$ 的最小可能值为 $l_1 + l_2$，最大值为 $u_1 + u_2$。因此，加法的可靠抽象传递函数（用 $\\oplus$ 表示）是：\n$$[l_1, u_1] \\oplus [l_2, u_2] = [l_1 + l_2, u_1 + u_2]$$\n常量表示为单元素区间。例如，常量 $c$ 由抽象值 $[c, c]$ 表示。\n\n接下来，我们为每个过程推导范围摘要。摘要是一个函数，它将输入参数的抽象值映射到返回结果的抽象值。\n\n**过程 $h()$**：\n此过程不接受参数并返回常量 $0$。\n具体返回值的集合是 $\\{0\\}$。\n包含此集合的最精确的抽象值是区间 $[0, 0]$。\n因此，$h$ 的摘要是 $S_h() = [0, 0]$。\n\n**过程 $k()$**：\n此过程不接受参数并返回常量 $1$。\n具体返回值的集合是 $\\{1\\}$。\n最精确的抽象值是区间 $[1, 1]$。\n因此，$k$ 的摘要是 $S_k() = [1, 1]$。\n\n**过程 $f(a)$**：\n此过程接受一个整数参数 $a$。设 $a$ 的抽象值为 $[l_a, u_a]$。\n1.  第一个语句是 $r_1 \\leftarrow a + a$。\n    $r_1$ 的抽象值计算为 $[l_a, u_a] \\oplus [l_a, u_a] = [l_a + l_a, u_a + u_a] = [2l_a, 2u_a]$。\n2.  第二个语句是 $r_2 \\leftarrow r_1 + 3$。常量 $3$ 的抽象值是 $[3, 3]$。\n    $r_2$ 的抽象值计算为 $[2l_a, 2u_a] \\oplus [3, 3] = [2l_a + 3, 2u_a + 3]$。\n3.  过程返回 $r_2$。\n$f$ 的摘要是输入抽象状态的函数：$S_f([l_a, u_a]) = [2l_a + 3, 2u_a + 3]$。\n\n**过程 $g(b)$**：\n此过程接受一个整数参数 $b$。设 $b$ 的抽象值为 $[l_b, u_b]$。\n1.  第一个语句：$t \\leftarrow b + 2$。$2$ 的抽象值是 $[2, 2]$。\n    $t$ 的抽象值是 $[l_b, u_b] \\oplus [2, 2] = [l_b + 2, u_b + 2]$。\n2.  第二个语句：$u \\leftarrow t + b$。\n    $u$ 的抽象值是 $[l_b + 2, u_b + 2] \\oplus [l_b, u_b] = [(l_b + 2) + l_b, (u_b + 2) + u_b] = [2l_b + 2, 2u_b + 2]$。\n3.  过程返回 $u + 1$。$1$ 的抽象值是 $[1, 1]$。\n    抽象返回值是 $[2l_b + 2, 2u_b + 2] \\oplus [1, 1] = [2l_b + 3, 2u_b + 3]$。\n$g$ 的摘要是输入抽象状态的函数：$S_g([l_b, u_b]) = [2l_b + 3, 2u_b + 3]$。\n\n现在，我们使用这些摘要来分析 `main` 过程，以确定 $x$ 和 $y$ 的抽象值。\n\n**对 $x \\leftarrow f(h())$ 的分析**：\n1.  $f$ 的参数是调用 $h()$ 的结果。我们使用 $h$ 的摘要来找到其抽象返回值：$S_h() = [0, 0]$。\n2.  这个抽象值 $[0, 0]$ 成为分析 $f$ 的输入。我们将 $f$ 的摘要应用于参数 $a$ 的输入抽象值 $[0, 0]$。因此，我们设置 $l_a = 0$ 和 $u_a = 0$。\n3.  $x$ 的抽象值是 $S_f([0, 0]) = [2(0) + 3, 2(0) + 3] = [3, 3]$。\n$x$ 的抽象值是单元素区间 $[3, 3]$。\n\n**对 $y \\leftarrow g(k())$ 的分析**：\n1.  $g$ 的参数是调用 $k()$ 的结果。我们使用 $k$ 的摘要：$S_k() = [1, 1]$。\n2.  这个抽象值 $[1, 1]$ 成为分析 $g$ 的输入。我们将 $g$ 的摘要应用于参数 $b$ 的输入抽象值 $[1, 1]$。因此，我们设置 $l_b = 1$ 和 $u_b = 1$。\n3.  $y$ 的抽象值是 $S_g([1, 1]) = [2(1) + 3, 2(1) + 3] = [2 + 3, 2 + 3] = [5, 5]$。\n$y$ 的抽象值是单元素区间 $[5, 5]$。\n\n**最终返回值**：\n主过程返回表达式 $x + y$ 的值。我们使用我们为 $x$ 和 $y$ 找到的抽象值来计算这个和的抽象值。\n$x+y$ 的抽象值是 $[3, 3] \\oplus [5, 5] = [3 + 5, 3 + 5] = [8, 8]$。\n\n分析得出结论，表达式 $x + y$ 的计算结果为抽象值 $[8, 8]$。一个单元素区间 $[c, c]$ 表示该变量或表达式只能持有唯一的具体值 $c$。在这种情况下，$x$ 总是 $3$，$y$ 总是 $5$，它们的和 $x+y$ 总是 $8$。这使得编译器可以执行常量折叠，将整个表达式 $x+y$ 替换为常量整数 $8$。\n\n因此，表达式 $x+y$ 可以被折叠的常量值是 $8$。", "answer": "$$\n\\boxed{8}\n$$", "id": "3682735"}, {"introduction": "在处理包含高阶函数（即函数可以作为参数传递或作为返回值）的程序时，一个核心挑战是确定在每个调用点可能调用哪些函数。本练习将介绍控制流分析（CFA），这是一种用于构建程序调用图的关键技术。通过比较 $0$-CFA 和 $1$-CFA 的精度，你将深入理解分析的成本与精度之间的权衡。[@problem_id:3682742]", "problem": "考虑以下用于具有高阶函数的传值调用函数式核心语言的小型一阶语法。为了便于识别，函数抽象由 $L_i$ 标记，调用点由 $c_i$ 标记。该程序是完整的、封闭的，并且除了返回值之外没有其他副作用。算术运算是原生的，与调用目标近似无关。\n\n程序：\n- let id = (label $L_1$) fun x -> x\n- let make_inc = (label $L_2$) fun n -> (label $L_3$) fun y -> y + n\n- let compose = (label $L_4$) fun f g -> (label $L_5$) fun x -> f ((call $c_7$) g x)  其中 f 的应用位于 (call $c_8$)\n- let chooser = (label $L_6$) fun f g cond -> if cond then f else g\n- main:\n  - let inc1 = (call $c_1$) make_inc $1$\n  - let inc2 = (call $c_2$) make_inc $2$\n  - let comp = (call $c_3$) compose inc1 id\n  - let chosen = (call $c_4$) chooser inc2 inc1 input_cond\n  - let r1 = (call $c_5$) comp $10$\n  - let r2 = (call $c_6$) chosen $20$\n\n假设：\n- 变量 input_cond 是一个未知的布尔输入；分析必须保守地假设在 $L_6$ 处的两个分支都是可能的。\n- 调用图的边形式为 $c \\to \\alpha$，其中 $c$ 是调用点标记，$\\alpha$ 是一个抽象函数。在 $k$-CFA (控制流分析)下，一个抽象函数由一个序对 $(L_i, \\kappa)$ 表示，其中 $L_i$ 是一个 lambda 标记，$\\kappa$ 是一个长度最多为 $k$ 的调用串，它概括了在闭包分配时（而非调用时）动态调用栈上最近的调用点。对于 $0$-CFA，所有函数的 $\\kappa$ 都是空字符串 $\\epsilon$；对于 $1$-CFA，$\\kappa$ 是闭包分配时最近的调用点。\n- 顶层函数 $L_1$, $L_2$, $L_4$, $L_6$ 在一个特定的初始上下文中分配，可以被视为单例。\n- 全程序分析意味着所有绑定都在分析的作用域内；算术和条件求值除了将值流向函数参数外，不影响调用目标。\n\n任务：\n仅使用上面陈述的全程序 $k$-CFA 的核心定义（在分配时使用长度为 $k$ 的调用串将闭包抽象为 $(L_i,\\kappa)$，抽象值通过绑定的单调传播，以及对未知条件的保守处理），推导出在 $0$-CFA 和 $1$-CFA 下，调用点 $c_5$, $c_6$, $c_7$ 和 $c_8$ 的调用目标近似。然后，选择正确总结了最终调用图边的选项。\n\n选项：\nA. 在 $0\\text{-CFA}$ 下：\n- $c_5 \\to L_5$，$c_6 \\to L_3$，$c_7 \\to L_1$，$c_8 \\to L_3$。\n在 $1\\text{-CFA}$ 下：\n- $c_5 \\to (L_5@c_3)$，$c_6 \\to \\{ (L_3@c_1), (L_3@c_2) \\}$，$c_7 \\to L_1$，$c_8 \\to (L_3@c_1)$。\n\nB. 在 $0\\text{-CFA}$ 下：\n- $c_5 \\to L_5$，$c_6 \\to L_3$，$c_7 \\to L_1$，$c_8 \\to L_3$。\n在 $1\\text{-CFA}$ 下：\n- $c_5 \\to (L_5@c_3)$，$c_6 \\to (L_3@c_1)$ 仅，$c_7 \\to L_1$，$c_8 \\to \\{ (L_3@c_1), (L_3@c_2) \\}$。\n\nC. 在 $0\\text{-CFA}$ 下：\n- $c_5 \\to L_5$，$c_6 \\to L_3$，$c_7 \\to \\{L_1, L_3\\}$，$c_8 \\to L_3$。\n在 $1\\text{-CFA}$ 下：\n- $c_5 \\to (L_5@c_5)$，$c_6 \\to \\{ (L_3@c_1), (L_3@c_2) \\}$，$c_7 \\to L_1$，$c_8 \\to (L_3@c_3)$。\n\nD. 在 $0\\text{-CFA}$ 下：\n- $c_5 \\to L_5$，$c_6 \\to L_3$，$c_7 \\to L_1$，$c_8 \\to L_3$。\n在 $1\\text{-CFA}$ 下：\n- $c_5 \\to (L_5@c_3)$，$c_6 \\to \\{ (L_3@c_1), (L_3@c_2) \\}$，$c_7 \\to L_1$，$c_8 \\to (L_3@c_2)$。\n\n选择唯一的最佳答案。", "solution": "问题陈述是全程序控制流分析（$k$-CFA）的一个有效应用，这是编译理论中的一种标准技术。定义、程序结构和假设都是自包含的、有科学依据且良构的。我们开始进行分析。\n\n该分析的关键在于追踪可以绑定到每个变量的抽象值集合。一个抽象值代表一个函数（闭包）。对于 $0$-CFA，一个抽象值就是函数定义（lambda 抽象）的标记 $L_i$。对于 $1$-CFA，一个抽象值是一个序对 $(L_i, \\kappa)$，其中 $L_i$ 是标记，$\\kappa$ 是闭包分配时长度为 1 的调用点上下文。顶层函数（$L_1, L_2, L_4, L_6$）被认为是在一个特殊的初始上下文中分配的，因此对于 $1$-CFA，它们的抽象值实际上是 $(L_i, \\epsilon)$，我们将其简记为 $L_i$。调用图的边 $c \\to \\alpha$ 表示在调用点 $c$ 的调用可以以抽象函数 $\\alpha$ 为目标。令 $\\mathcal{V}(x)$ 表示变量 $x$ 的抽象值集合。\n\n### I. $0$-CFA 分析 ($k=0$)\n在 $0$-CFA 中，抽象值就是 lambda 标记，例如 $L_i$。上下文被忽略。\n\n1.  **初始绑定**：顶层函数被绑定到它们各自的标记上。\n    -   $\\mathcal{V}(\\text{id}) = \\{L_1\\}$\n    -   $\\mathcal{V}(\\text{make_inc}) = \\{L_2\\}$\n    -   $\\mathcal{V}(\\text{compose}) = \\{L_4\\}$\n    -   $\\mathcal{V}(\\text{chooser}) = \\{L_6\\}$\n\n2.  `let inc1 = (call $c_1$) make_inc $1$`: 调用函数 `make_inc`。其抽象值为 $L_2$。此调用创建并返回一个标记为 $L_3$ 的 lambda 的闭包。在 $0$-CFA 中，此闭包的抽象值就是 $L_3$。\n    -   $\\mathcal{V}(\\text{inc1}) = \\{L_3\\}$。\n\n3.  `let inc2 = (call $c_2$) make_inc $2$`: 从 $0$-CFA 的角度来看，这与 `inc1` 的创建是相同的。对 `make_inc` ($L_2$) 的调用返回一个 $L_3$ 的闭包。\n    -   $\\mathcal{V}(\\text{inc2}) = \\{L_3\\}$。\n\n4.  `let comp = (call $c_3$) compose inc1 id`: 调用函数 `compose` ($L_4$)。其参数 `f` 和 `g` 分别被绑定到 `inc1` 和 `id` 的抽象值。在此调用内部，$\\mathcal{V}(f) = \\mathcal{V}(\\text{inc1}) = \\{L_3\\}$ 且 $\\mathcal{V}(g) = \\mathcal{V}(\\text{id}) = \\{L_1\\}$。该函数返回一个标记为 $L_5$ 的 lambda 的闭包。\n    -   $\\mathcal{V}(\\text{comp}) = \\{L_5\\}$。返回的闭包捕获了环境，其中 $\\mathcal{V}(f) = \\{L_3\\}$ 且 $\\mathcal{V}(g) = \\{L_1\\}$。\n\n5.  `let chosen = (call $c_4$) chooser inc2 inc1 input_cond`: 调用函数 `chooser` ($L_6$) 。其参数 `f` 和 `g` 被绑定到 `inc2` 和 `inc1` 的抽象值。在此调用内部，$\\mathcal{V}(f) = \\mathcal{V}(\\text{inc2}) = \\{L_3\\}$ 且 $\\mathcal{V}(g) = \\mathcal{V}(\\text{inc1}) = \\{L_3\\}$。由于 `input_cond` 未知，分析必须保守，并假设结果可以来自 `if` 语句的任一分支。返回值的集合是 $\\mathcal{V}(f) \\cup \\mathcal{V}(g) = \\{L_3\\} \\cup \\{L_3\\} = \\{L_3\\}$。\n    -   $\\mathcal{V}(\\text{chosen}) = \\{L_3\\}$。\n\n现在，我们确定调用目标。\n-   **调用点 $c_5$**: `(call $c_5$) comp $10$`. 被调用的函数是 `comp`，且 $\\mathcal{V}(\\text{comp}) = \\{L_5\\}$。\n    -   调用目标是 $L_5$。因此，**$c_5 \\to L_5$**。\n-   **调用点 $c_6$**: `(call $c_6$) chosen $20$`. 被调用的函数是 `chosen`，且 $\\mathcal{V}(\\text{chosen}) = \\{L_3\\}$。\n    -   调用目标是 $L_3$。因此，**$c_6 \\to L_3$**。\n-   **调用点 $c_7, c_8$**: 这些位于 $L_5$ 的函数体内，当在 $c_5$ 处调用 `comp` 时执行。我们使用创建 $L_5$ 闭包时捕获的环境（步骤 4）。\n    -   在那个环境中，$\\mathcal{V}(g) = \\{L_1\\}$ 且 $\\mathcal{V}(f) = \\{L_3\\}$。\n    -   表达式是 `f ((call $c_7$) g x)`。\n    -   对于**调用点 $c_7$**，调用函数 `g`。目标由 $\\mathcal{V}(g)$ 给出。因此，**$c_7 \\to L_1$**。\n    -   外部调用是 `(call $c_8$) f ...`。对于**调用点 $c_8$**，调用函数 `f`。目标由 $\\mathcal{V}(f)$ 给出。因此，**$c_8 \\to L_3$**。\n\n**$0$-CFA 总结：** $c_5 \\to L_5$, $c_6 \\to L_3$, $c_7 \\to L_1$, $c_8 \\to L_3$.\n\n### II. $1$-CFA 分析 ($k=1$)\n在 $1$-CFA 中，一个抽象值是 lambda 标记及其分配点上下文的序对 $(L_i, c_j)$。我们将其表示为 $L_i@c_j$。\n\n1.  **初始绑定**：与 $0$-CFA 相同，顶层函数具有空上下文。\n    -   $\\mathcal{V}(\\text{id}) = \\{L_1\\}$\n    -   $\\mathcal{V}(\\text{make_inc}) = \\{L_2\\}$\n    -   $\\mathcal{V}(\\text{compose}) = \\{L_4\\}$\n    -   $\\mathcal{V}(\\text{chooser}) = \\{L_6\\}$\n\n2.  `let inc1 = (call $c_1$) make_inc $1$`: 在调用点 $c_1$ 调用函数 `make_inc` ($L_2$)。在此调用内部，分配了一个 $L_3$ 的闭包。分配上下文是当前调用点 $c_1$。\n    -   $\\mathcal{V}(\\text{inc1}) = \\{L_3@c_1\\}$。\n\n3.  `let inc2 = (call $c_2$) make_inc $2$`: 在调用点 $c_2$ 调用函数 `make_inc` ($L_2$) 。在 $c_2$ 的上下文中分配了一个 $L_3$ 的闭包。\n    -   $\\mathcal{V}(\\text{inc2}) = \\{L_3@c_2\\}$。\n    -   注意，$\\mathcal{V}(\\text{inc1})$ 和 $\\mathcal{V}(\\text{inc2})$ 现在是不同的抽象值。\n\n4.  `let comp = (call $c_3$) compose inc1 id`: 在调用点 $c_3$ 调用 `compose` ($L_4$) 。它在 $c_3$ 的上下文中为 $L_5$ 分配一个闭包。\n    -   $\\mathcal{V}(\\text{comp}) = \\{L_5@c_3\\}$。\n    -   这个闭包 $L_5@c_3$ 的捕获环境将 `f` 绑定到 $\\mathcal{V}(\\text{inc1}) = \\{L_3@c_1\\}$，将 `g` 绑定到 $\\mathcal{V}(\\text{id}) = \\{L_1\\}$。\n\n5.  `let chosen = (call $c_4$) chooser inc2 inc1 input_cond`: 在 $c_4$ 调用 `chooser` ($L_6$) 。参数被绑定为 $\\mathcal{V}(f) = \\mathcal{V}(\\text{inc2}) = \\{L_3@c_2\\}$ 和 $\\mathcal{V}(g) = \\mathcal{V}(\\text{inc1}) = \\{L_3@c_1\\}$。保守的 `if` 返回两个分支的抽象值的并集。\n    -   $\\mathcal{V}(\\text{chosen}) = \\mathcal{V}(f) \\cup \\mathcal{V}(g) = \\{L_3@c_2\\} \\cup \\{L_3@c_1\\} = \\{L_3@c_1, L_3@c_2\\}$。\n\n现在，我们确定调用目标。\n-   **调用点 $c_5$**: `(call $c_5$) comp $10$`. 函数是 `comp`，其 $\\mathcal{V}(\\text{comp}) = \\{L_5@c_3\\}$。\n    -   调用目标是 $L_5@c_3$。因此，**$c_5 \\to (L_5@c_3)$**。\n-   **调用点 $c_6$**: `(call $c_6$) chosen $20$`. 函数是 `chosen`，其 $\\mathcal{V}(\\text{chosen}) = \\{L_3@c_1, L_3@c_2\\}$。\n    -   有两个可能的目标。因此，**$c_6 \\to \\{(L_3@c_1), (L_3@c_2)\\}$**。\n-   **调用点 $c_7, c_8$**: 这些位于在 $c_5$ 调用的闭包 $L_5@c_3$ 的函数体内。我们使用这个特定闭包被创建时（步骤 4）所捕获的环境。\n    -   在那个环境中，$\\mathcal{V}(f) = \\{L_3@c_1\\}$ 且 $\\mathcal{V}(g) = \\{L_1\\}$。\n    -   对于**调用点 $c_7$**，调用 `g`。目标来自 $\\mathcal{V}(g)$。因此，**$c_7 \\to L_1$**。\n    -   对于**调用点 $c_8$**，调用 `f`。目标来自 $\\mathcal{V}(f)$。因此，**$c_8 \\to (L_3@c_1)$**。\n\n**$1$-CFA 总结：** $c_5 \\to (L_5@c_3)$, $c_6 \\to \\{(L_3@c_1), (L_3@c_2)\\}$, $c_7 \\to L_1$, $c_8 \\to (L_3@c_1)$.\n\n### III. 选项评估\n\n-   **选项 A**：\n    -   在 $0$-CFA 下：$c_5 \\to L_5$, $c_6 \\to L_3$, $c_7 \\to L_1$, $c_8 \\to L_3$.\n    -   在 $1$-CFA 下：$c_5 \\to (L_5@c_3)$, $c_6 \\to \\{(L_3@c_1), (L_3@c_2)\\}$, $c_7 \\to L_1$, $c_8 \\to (L_3@c_1)$.\n    -   这完全符合我们为 $0$-CFA 和 $1$-CFA 推导出的结果。\n    -   结论：**正确**。\n\n-   **选项 B**：\n    -   在 $1$-CFA 下，它声称 $c_6 \\to (L_3@c_1)$ 仅成立。这是不正确的。对 `chooser` 的分析表明 $\\mathcal{V}(\\text{chosen})$ 同时包含 $L_3@c_1$ 和 $L_3@c_2$。\n    -   它还声称 $c_8 \\to \\{(L_3@c_1), (L_3@c_2)\\}$。这是不正确的。`comp` 的闭包（$L_5@c_3$）是在一个上下文中创建的，在该上下文中其参数 `f` 仅被绑定到 `inc1`（$L_3@c_1$）。\n    -   结论：**不正确**。\n\n-   **选项 C**：\n    -   在 $0$-CFA 下，它声称 $c_7 \\to \\{L_1, L_3\\}$。这是不正确的。在 `comp` 闭包内部，参数 `g` 明确地被绑定到 `id` ($L_1$) 。\n    -   在 $1$-CFA 下，它声称 $c_5 \\to (L_5@c_5)$。这是不正确的。闭包的抽象值由其分配上下文决定，而不是其调用上下文。`comp` 的闭包（$L_5$）是在调用点 $c_3$ 分配的。\n    -   结论：**不正确**。\n\n-   **选项 D**：\n    -   在 $1$-CFA 下，它声称 $c_8 \\to (L_3@c_2)$。这是不正确的。`comp` 的闭包（$L_5@c_3$）有一个捕获的环境，其中 `f` 绑定到 `inc1`，其抽象值为 $L_3@c_1$，而不是 `inc2` ($L_3@c_2$) 。\n    -   结论：**不正确**。\n\n只有选项 A 为两种分析提供了正确的调用目标近似。", "answer": "$$\\boxed{A}$$", "id": "3682742"}, {"introduction": "程序切片是全程序分析的一项强大应用，对于调试、代码理解和重构至关重要。通过后向切片，我们可以精确回答“程序中哪些部分的代码可能影响了某个特定变量的值？”这个问题。本练习将让你动手实践，从一个给定的切片标准出发，通过追踪数据和控制依赖关系，从整个程序中分离出一个相关的代码子集。[@problem_id:3682778]", "problem": "考虑一个小型的带有全局变量和四个函数的过程式程序。切片准则 (slicing criterion) 是函数 $main$ 返回的输出值。要求您在全程序分析 (whole-program analysis) 下执行后向切片 (backward slice)，移除不相关的函数和全局变量。假设所有函数都会终止，没有异常，并且所有调用都是严格的（被调用者在调用者继续执行前完全执行）。使用标准的过程式切片 (interprocedural slicing) 语义：当且仅当语句与切片准则存在数据依赖或控制依赖时，该语句才被保留在切片中。如果一个语句定义的值被切片中的另一个语句后续使用，则存在数据依赖 (data dependence)；如果一个语句的结果决定了切片中的某个语句是否执行，则存在控制依赖 (control dependence)。将以下每个行项目视为单个源级别的语句。一个语句是以下之一：全局初始化（赋值）、函数局部赋值（包括算术运算）、出现在赋值右侧的函数调用、条件测试（“if”谓词本身）或返回语句。不要将“else”标签计为一个独立的语句。\n\n全局变量（每行是一个独立的语句）：\n- $G1$: $A := 5$\n- $G2$: $B := 10$\n- $G3$: $C := 0$\n- $G4$: $D := 7$\n\n函数 $square(x)$:\n- $S1$: $r := x \\times x$\n- $S2$: $C := C + 1$\n- $S3$: return $r$\n\n函数 $noise(y)$:\n- $N1$: $B := B + y$\n- $N2$: return $B$\n\n函数 $choose(p)$:\n- $H1$: if $p > 0$\n- $H2$: return $p$  (then-分支)\n- $H3$: return $D$  (else-分支)\n\n函数 $unusedGlobalFun()$:\n- $U1$: $A := A + B$\n- $U2$: return $A$\n\n函数 $main()$:\n- $M1$: $t1 := square(A)$\n- $M2$: $t2 := choose(t1 - B)$\n- $M3$: if $(t2 \\bmod 2 = 0)$\n- $M4$: $z := square(t2)$\n- $M5$: return $z - D$  (then-分支)\n- $M7$: $noise(t2)$      (else-分支)\n- $M8$: return $t2 + A$  (else-分支)\n\n针对 $main$ 的输出（即 $main$ 返回的值）执行全程序后向切片。根据与此切片准则的数据或控制依赖关系，从切片中移除任何不相关的函数和任何全局初始化。计算移除后后向切片中剩余的语句数量。用一个精确的整数来表示您的最终答案。不需要四舍五入，也不需要单位。", "solution": "用户要求我对一个小型的过程式程序执行全程序后向切片。\n\n**1. 理解目标：**\n核心任务是确定程序中哪些语句与 `main` 函数的最终输出相关。这是一个经典的后向切片问题。我需要计算切片中剩余的语句数量。\n\n**2. 定义切片准则：**\n问题陈述：“切片准则是函数 $main$ 返回的输出值”。这意味着我需要将 `main` 中*所有*的返回语句作为切片的起点。\n- `$M5: return z - D$`\n- `$M8: return t2 + A$`\n\n**3. 定义切片规则：**\n- **后向切片：** 我从准则开始，向后追溯。\n- **全程序分析：** 我必须跨越函数边界（过程间）。\n- **依赖关系：** 如果*已在切片中*的另一条语句对某条语句有数据或控制依赖，那么该语句就在切片中。\n    - **数据依赖：** 如果 `S_i` 定义了一个变量 `v`，`S_j` 使用了 `v`，并且从 `S_i` 到 `S_j` 存在一条路径，其间 `v` 未被重新定义，则 `S_j` 对 `S_i` 存在数据依赖。\n    - **控制依赖：** 如果 `S_i` 是一个谓词，它决定了 `S_j` 是否执行，则 `S_j` 对 `S_i` 存在控制依赖。\n\n**4. 切片的初始集合：**\n切片准则包含 `main` 中的两个返回语句。\n- `$M5: return z - D$`\n- `$M8: return t2 + A$`\n\n令 `S` 为切片中的语句集合。\n初始时，`S = {M5, M8}`。\n\n**5. 迭代切片过程：**\n我将从初始集合开始向后追溯，添加 `$M5$` 和 `$M8$` 所依赖的语句。然后，我将添加这些新语句所依赖的语句，依此类推，直到没有新语句可以添加为止。\n\n**第 1 轮迭代：分析 `$M5$` 和 `$M8$` 的依赖关系**\n\n*   **分析 `$M5: \\text{return } z - D$`：**\n    *   **数据依赖：** `$M5$` 使用变量 `$z$` 和 `$D$`。\n        *   `$z$` 在哪里定义？`$M4: z := \\text{square}(t2)$`。所以，`$M4$` 在切片中。\n        *   `$D$` 在哪里定义？全局初始化 `$G4: D := 7$`。所以，`$G4$` 在切片中。\n    *   **控制依赖：** `$M5$` 位于 `if` 语句 `$M3: \\text{if } (t2 \\bmod 2 = 0)$` 的 `then` 分支内。因此，`$M5$` 对 `$M3$` 存在控制依赖。所以，`$M3$` 在切片中。\n    *   **加入切片的新语句：** `{$M4$, $G4$, $M3$}`。\n\n*   **分析 `$M8: \\text{return } t2 + A$`：**\n    *   **数据依赖：** `$M8$` 使用变量 `$t2$` 和 `$A$`。\n        *   `$t2$` 在哪里定义？`$M2: t2 := \\text{choose}(t1 - B)$`。所以，`$M2$` 在切片中。\n        *   `$A$` 在哪里定义？全局初始化 `$G1: A := 5$`。所以，`$G1$` 在切片中。\n    *   **控制依赖：** `$M8$` 位于 `if` 语句 `$M3: \\text{if } (t2 \\bmod 2 = 0)$` 的 `else` 分支内。因此，`$M8$` 对 `$M3$` 存在控制依赖。所以，`$M3$` 在切片中（它已被加入，但这确认了其重要性）。\n    *   **加入切片的新语句：** `{$M2$, $G1$}`。\n\n*   **当前切片 `S`：** `{$M5$, $M8$, $M4$, $G4$, $M3$, $M2$, $G1$}`。\n\n**第 2 轮迭代：分析新加入语句（`$M4$`、`$M3$`、`$M2$`）的依赖关系**\n\n*   **分析 `$M4: z := \\text{square}(t2)$`：**\n    *   **数据依赖：** `$M4$` 使用变量 `$t2$` 并调用函数 `square`。\n        *   `$t2$` 在哪里定义？`$M2: t2 := \\text{choose}(t1 - B)$`。`$M2$` 已在切片中。\n        *   调用 `square(t2)` 意味着我们现在必须对 `square` 函数以其返回值为准则进行切片。\n        *   让我们以 `square` 的返回值（`$r$`）为准则来分析它。\n            *   从 `$S3: \\text{return } r$` 开始。`$S3$` 在切片中。\n            *   `$S3$` 使用 `$r$`。`$r$` 在 `$S1: r := x \\times x$` 中定义。所以，`$S1$` 在切片中。\n            *   `$S1$` 使用 `$x$`。`$x$` 是 `square` 的形式参数。在调用点 `$M4$` 的实际参数是 `$t2$`。由于 `$t2$` 的定义已在追踪中（`$M2$`），依赖关系通过参数传递流动。\n            *   `$S2: C := C + 1$` 呢？该语句修改了全局变量 `$C$`，但不影响返回值 `$r$`。返回值 `$r$` 不依赖于 `$C$`。所以 `$S2$` 不在切片中。全局初始化 `$G3: C := 0$` 也不在切片中（除非有其他东西需要它，但这似乎不太可能）。\n        *   **从 `square` 加入切片的新语句：** `{$S3$, $S1$}`。\n\n*   **分析 `$M3: \\text{if } (t2 \\bmod 2 = 0)$`：**\n    *   **数据依赖：** `$M3$` 使用变量 `$t2$`。\n        *   `$t2$` 在哪里定义？`$M2: t2 := \\text{choose}(t1 - B)$`。`$M2$` 已在切片中。\n    *   **没有从 `$M3$` 的依赖关系中添加新语句。**\n\n*   **分析 `$M2: t2 := \\text{choose}(t1 - B)$`：**\n    *   **数据依赖：** `$M2$` 使用变量 `$t1$` 和 `$B$`，并调用函数 `choose`。\n        *   `$t1$` 在哪里定义？`$M1: t1 := \\text{square}(A)$`。所以，`$M1$` 在切片中。\n        *   `$B$` 在哪里定义？全局初始化 `$G2: B := 10$`。所以，`$G2$` 在切片中。\n        *   调用 `choose(t1 - B)` 意味着我们必须对 `choose` 函数以其返回值为准则进行切片。\n        *   让我们以 `choose` 的返回值为准则来分析它。`choose` 有两个返回语句。\n            *   从 `{$H2: \\text{return } p, $H3: \\text{return } D$}` 开始。所以，`{$H2$, $H3$}` 在切片中。\n            *   `$H2$` 使用 `$p$`。`$p$` 是形式参数。其定义通过调用点进行追踪。\n            *   `$H3$` 使用 `$D$`。`$D$` 是一个全局变量。其定义是 `$G4: D := 7$`。`$G4$` 已在切片中。\n            *   `$H2$` 和 `$H3$` 对谓词 `$H1: \\text{if } p > 0$` 存在控制依赖。所以，`$H1$` 在切片中。\n            *   `$H1$` 使用 `$p$`。`$p$` 是形式参数。\n        *   **从 `choose` 加入切片的新语句：** `{$H2$, $H3$, $H1$}`。\n\n*   **当前切片 `S`：** `{$M5$, $M8$, $M4$, $G4$, $M3$, $M2$, $G1$, $S3$, $S1$, $M1$, $G2$, $H2$, $H3$, $H1$}`。\n\n**第 3 轮迭代：分析新加入语句（`$M1$`）的依赖关系**\n\n*   **分析 `$M1: t1 := \\text{square}(A)$`：**\n    *   **数据依赖：** `$M1$` 使用变量 `$A$` 并调用函数 `square`。\n        *   `$A$` 在哪里定义？`$G1: A := 5$`。`$G1$` 已在切片中。\n        *   调用 `square(A)` 意味着我们必须再次对 `square` 函数以其返回值为准则进行切片。我们在分析 `$M4$` 时已经做过，并发现语句 `{$S1$, $S3$}` 是相关的。这些已在切片中。这个调用点只是确认了它们的相关性。参数 `$A$` 被使用，其定义 `$G1$` 已在切片中。\n    *   **没有从 `$M1$` 的依赖关系中添加新语句。**\n\n迭代过程已经稳定。没有更多的语句可以添加到切片中。\n\n**对所有程序语句的最终审查**\n\n我们现在将每个语句分类为在切片中（IN）或不在切片中（OUT）。\n\n*   **全局变量：**\n    *   `$G1: A := 5$`：**IN**。`$A$` 的值在 `$M8$` 中被使用，并在 `$M1$` 中传递给 `square`，这影响了 `$t1$`、`$t2$`，并因此影响了两个返回路径。\n    *   `$G2: B := 10$`：**IN**。`$B$` 的值在 `$M2$` 中用于计算传递给 `choose` 的参数，从而决定了 `$t2$`。\n    *   `$G3: C := 0$`：**OUT**。它初始化了全局变量 `$C$`，`$C$` 仅在 `$S2$` 中被修改。由于 `$S2$` 不影响 `square` 的返回值，`$S2$` 不在切片中，`$G3$` 也不在。\n    *   `$G4: D := 7$`：**IN**。`$D$` 的值在返回语句 `$M5$` 和返回语句 `$H3$` 中被使用，这两者都在切片中。\n\n*   **函数 `square(x)`：**\n    *   `$S1: r := x \\times x$`：**IN**。它定义了 `$r$`，`$r$` 在返回语句 `$S3$` 中被使用。\n    *   `$S2: C := C + 1$`：**OUT**。它修改了全局变量 `$C$`，但这对返回值 `$r$` 或切片中的任何其他语句没有数据或控制影响。\n    *   `$S3: \\text{return } r$`：**IN**。其返回值被调用者 `$M1$` 和 `$M4$` 使用，它们的结果对最终输出至关重要。\n\n*   **函数 `noise(y)`：**\n    *   `$M7: \\text{noise}(t2)$` 是调用点。此语句在 `$M3$` 的 `else` 分支中，该分支导向返回语句 `$M8: \\text{return } t2 + A$`。函数 `noise` 修改了全局变量 `$B$`。然而，在 `$M7$` 之后，`$B$` 的值没有被切片中的任何语句再次使用。具体来说，`$M8$` 不使用 `$B$`。因此，`noise` 的副作用与切片准则无关。`$M7$` **OUT**。因此，整个 `noise` 函数（`$N1$`, `$N2$`）都是不相关的，也是 **OUT**。\n\n*   **函数 `choose(p)`：**\n    *   `$H1: \\text{if } p > 0$`：**IN**。它决定了 `choose` 返回哪个值，直接影响 `$t2$`。\n    *   `$H2: \\text{return } p$`：**IN**。它是函数的返回路径之一。\n    *   `$H3: \\text{return } D$`：**IN**。它是另一个返回路径。\n    整个 `choose` 函数都是相关的，因为它的返回值决定了 `$t2$` 的值，而 `$t2$` 对于 `main` 中的控制流和数据流至关重要。\n\n*   **函数 `unusedGlobalFun()`：**\n    *   该函数在程序中从未被调用。因此它是不相关的，其所有语句（`$U1$`, `$U2$`）都是 **OUT**。\n\n*   **函数 `main()`：**\n    *   `$M1: t1 := \\text{square}(A)$`：**IN**。它定义了 `$t1$`，`$t1$` 在 `$M2$` 中被使用。\n    *   `$M2: t2 := \\text{choose}(t1 - B)$`：**IN**。它定义了 `$t2$`，`$t2$` 在 `$M3$`、`$M4$` 和 `$M8$` 中被使用。\n    *   `$M3: \\text{if } (t2 \\bmod 2 = 0)$`：**IN**。它控制 `main` 中的两个返回路径哪一个被执行。\n    *   `$M4: z := \\text{square}(t2)$`：**IN**。它定义了 `$z$`，`$z$` 在返回语句 `$M5$` 中被使用。\n    *   `$M5: \\text{return } z - D$`：**IN**。它是切片准则的一部分。\n    *   `$M7: \\text{noise}(t2)$`：**OUT**。如上所述，其副作用与切片无关。\n    *   `$M8: \\text{return } t2 + A$`：**IN**。它是切片准则的一部分。\n\n**切片中语句的最终计数**\n\n我们对包含在切片中的语句数量进行求和：\n*   全局变量：`$G1$`, `$G2$`, `$G4$` (3 个语句)\n*   函数 `square`：`$S1$`, `$S3$` (2 个语句)\n*   函数 `choose`：`$H1$`, `$H2$`, `$H3$` (3 个语句)\n*   函数 `main`：`$M1$`, `$M2$`, `$M3$`, `$M4$`, `$M5$`, `$M8$` (6 个语句)\n\n总计数 = $3 + 2 + 3 + 6 = 14$。", "answer": "$$\n\\boxed{14}\n$$", "id": "3682778"}]}