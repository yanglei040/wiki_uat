{"hands_on_practices": [{"introduction": "理论是灰色的，而实践之树常青。要真正掌握一个编译器优化，最好的方法莫过于亲手应用它并衡量其效果。本练习提供了一个典型的控制流图，要求你为其中的一个表达式应用懒惰代码移动，并量化其带来的性能收益。通过计算 $\\mathrm{Insert}$ 和 $\\mathrm{Delete}$ 集合，并分析优化前后的期望执行次数，你将深入理解静态分析如何转化为实际的运行时性能提升 [@problem_id:3649324]。", "problem": "考虑编译器中间表示中一个线性区域的以下控制流图 (CFG)。该区域由五个基本块 $B_{0}$、$B_{1}$、$B_{2}$、$B_{3}$ 和 $B_{4}$ 组成，它们之间存在有向边：\n- $B_{0} \\rightarrow B_{1}$，\n- $B_{1} \\rightarrow B_{2}$ 和 $B_{1} \\rightarrow B_{3}$，\n- $B_{2} \\rightarrow B_{4}$ 和 $B_{3} \\rightarrow B_{4}$，\n- $B_{4} \\rightarrow \\text{Exit}$。\n\n每个块的内容如下：\n- $B_{0}$：无语句（入口）。\n- $B_{1}$：$x := a$；$y := b$；一个条件分支，以概率 $p = \\frac{3}{5}$ 跳转到 $B_{2}$，以概率 $1 - p = \\frac{2}{5}$ 跳转到 $B_{3}$。\n- $B_{2}$：$t := x + y$；$s := t + 1$。\n- $B_{3}$：$r := 2 \\cdot x$。\n- $B_{4}$：$u := x + y$；$v := u \\cdot m$。\n\n假设：\n- 在 $B_{2}$、$B_{3}$ 中，或在 $B_{2}$/$B_{3}$ 的结尾与 $B_{4}$ 的开头之间，没有对 $x$ 或 $y$ 的重定义。\n- $B_{4}$ 之后对 $x + y$ 的唯一使用是通过 $B_{4}$ 中的 $u$；其他地方没有其他使用。\n- 每次考虑时，该区域执行一次，并且从 $B_{1}$ 到 $B_{2}$ 或 $B_{3}$ 的分支是路径可变性的唯一来源。\n\n令惰性代码移动 (LCM) 表示这样一种变换：通过在最晚安全点插入计算，并删除因这些插入而变得不必要的冗余计算，从而消除部分冗余。\n\n你的任务是：\n1. 对于表达式 $e = x+y$，在惰性代码移动下，以块粒度计算 $\\mathrm{Insert}$ 和 $\\mathrm{Delete}$ 集合。对于本问题，将 $\\mathrm{Insert}(B)$ 理解为“在块 $B$ 的入口处插入 $e$ 的计算”，将 $\\mathrm{Delete}(B)$ 理解为“删除块 $B$ 内部对 $e$ 的原始计算”。\n2. 使用给定的分支概率，计算在应用 LCM 之前和之后，该区域单次执行中 $e$ 的动态求值期望次数。\n3. 作为最终答案，提供该区域单次执行中 $e$ 的动态求值次数的期望减少量（即应用 LCM 前的期望次数减去应用 LCM 后的期望次数）。请用精确分数表示你的答案，不要四舍五入。", "solution": "该问题陈述清晰，其科学基础根植于编译器优化原理，并提供了确定唯一解所需的所有信息。因此，该问题是有效的。我们开始解题。\n\n分析的核心是所提供的控制流图 (CFG) 中的表达式 $e = x+y$。目标是应用惰性代码移动 (LCM) 来减少该表达式的动态求值次数。LCM 是一种部分冗余消除 (PRE) 算法，它通过将代码尽可能晚地放置来避免不必要的过早计算。\n\n首先，我们必须分析表达式 $e = x+y$ 在原始程序中出现的情况。\n- 在基本块 $B_2$ 中，表达式被计算：$t := x + y$。其结果随后在同一块内被 $s := t + 1$ 使用。\n- 在基本块 $B_4$ 中，表达式被再次计算：$u := x + y$。\n\n该 CFG 具有菱形结构，路径在 $B_1$ 之后分叉，在 $B_4$ 之前汇合。从 $B_1$ 到 $B_4$ 有两条主要路径：\n1. 路径 $P_1$：$B_1 \\rightarrow B_2 \\rightarrow B_4$\n2. 路径 $P_2$：$B_1 \\rightarrow B_3 \\rightarrow B_4$\n\n我们来检查块 $B_4$ 中计算 $u := x+y$ 的冗余性。\n- 在路径 $P_1$ 上，表达式 $x+y$ 在 $B_2$ 中被计算。由于假设声明 $x$ 和 $y$ 在 $B_1$ 中定义后，到它们在 $B_4$ 中使用前没有被重定义，所以在 $B_2$ 中计算出的 $x+y$ 的值在 $B_4$ 的入口处是可用的。因此，在 $B_4$ 中的计算 $u := x+y$ 在这条路径上是冗余的。\n- 在路径 $P_2$ 上，表达式 $x+y$ *没有*在 $B_3$ 中被计算。因此，在 $B_4$ 中的计算 $u := x+y$ 在这条路径上是必要的。\n\n因为在 $B_4$ 中的计算在通向它的某些路径上是冗余的，但并非在所有路径上都冗余，所以它被归类为*部分冗余*计算。LCM 的目的是消除这种部分冗余。这通过在表达式不可用的路径上插入计算来实现，从而使部分冗余的计算变得完全冗余并可被删除。\n\n为了使 $B_4$ 中的计算 $u := x+y$ 完全冗余，我们必须确保无论采取哪条路径，$x+y$ 的值在 $B_4$ 的入口处都是可用的。这要求我们在路径 $P_2$ 上 $B_4$ 之前的某个位置插入一个 $x+y$ 的计算。在插入位置被限制为块入口的情况下，这条路径上最晚的可能放置点是 $B_4$ 的入口本身。然而，这个问题的关键在于 $B_2$ 内部对 $x+y$ 的使用。这个使用阻止了将路径 $P_1$ 的计算移动到比 $B_2$ 入口更晚的位置。\n\nLCM 算法必须找到一个满足所有使用的放置点。$B_2$ 中 $e$ 的计算（用于 $s := t+1$）和 $B_4$ 中 $e$ 的计算可以通过将表达式提升到一个支配这两个使用的点来满足。最早的这样的点是 $B_1$ 的出口。在块级粒度上，将计算放置在 $B_1$ 的出口等同于将其插入到它的每个后继节点（$B_2$ 和 $B_3$）的入口。\n\n这导致了以下变换：\n1.  在 $B_2$ 的入口处插入一个新的计算 $\\text{temp} := x+y$。\n2.  在 $B_3$ 的入口处插入一个新的计算 $\\text{temp} := x+y$。\n\n现在我们分析这些插入的后果：\n- $B_2$ 中原始的计算 $t := x+y$ 变得完全冗余，因为 $\\text{temp}$（持有 $x+y$ 的值）在 $B_2$ 的入口处是可用的。这个原始计算被删除，并且可以用一条移动指令代替，例如 $t := \\text{temp}$。\n- 在这些插入之后，表达式 $x+y$ 在到达 $B_4$ 之前，在路径 $P_1$ 和 $P_2$ 上都被计算了。因此，$\\text{temp}$ 的值在 $B_4$ 的入口处是可用的。这使得 $B_4$ 中原始的计算 $u := x+y$ 变得完全冗余。它也被删除，并用一条移动指令代替，例如 $u := \\text{temp}$。\n\n基于此分析，我们可以确定 $\\mathrm{Insert}$ 和 $\\mathrm{Delete}$ 集合。\n\n**任务 1：计算 $\\mathrm{Insert}$ 和 $\\mathrm{Delete}$ 集合**\n- $\\mathrm{Insert}(B_2)$: 我们在 $B_2$ 的入口处插入 $e=x+y$ 的计算。\n- $\\mathrm{Insert}(B_3)$: 我们在 $B_3$ 的入口处插入 $e=x+y$ 的计算。\n- $\\mathrm{Delete}(B_2)$: $B_2$ 中对 $e=x+y$ 的原始计算被删除。\n- $\\mathrm{Delete}(B_4)$: $B_4$ 中对 $e=x+y$ 的原始计算被删除。\n\n所以，集合为 $\\mathrm{Insert} = \\{B_2, B_3\\}$ 和 $\\mathrm{Delete} = \\{B_2, B_4\\}$。\n\n**任务 2：计算 LCM 前后动态求值的期望次数**\n\n走路径 $P_1$（通过分支到 $B_2$）的概率给定为 $p = \\frac{3}{5}$。\n走路径 $P_2$（通过分支到 $B_3$）的概率为 $1-p = \\frac{2}{5}$。\n该区域执行一次。\n\n**LCM 之前：**\n- 如果走路径 $P_1$（概率 $\\frac{3}{5}$），$e$ 在 $B_2$ 中求值一次，然后在 $B_4$ 中再次求值。这相当于 $2$ 次动态求值。\n- 如果走路径 $P_2$（概率 $\\frac{2}{5}$），$e$ 仅在 $B_4$ 中求值。这相当于 $1$ 次动态求值。\n期望求值次数 $E_{\\text{before}}$ 为：\n$$E_{\\text{before}} = 2 \\cdot P(P_1) + 1 \\cdot P(P_2) = 2 \\cdot \\frac{3}{5} + 1 \\cdot \\frac{2}{5} = \\frac{6}{5} + \\frac{2}{5} = \\frac{8}{5}$$\n\n**LCM 之后：**\n- 在 $B_2$ 的入口和 $B_3$ 的入口各放置一个计算。$B_2$ 和 $B_4$ 中的原始计算被删除。\n- 如果走路径 $P_1$（概率 $\\frac{3}{5}$），代码将执行在 $B_2$ 入口处插入的计算。这是这条路径上对 $e$ 的唯一一次求值。这相当于 $1$ 次动态求值。\n- 如果走路径 $P_2$（概率 $\\frac{2}{5}$），代码将执行在 $B_3$ 入口处插入的计算。这是这条路径上对 $e$ 的唯一一次求值。这相当于 $1$ 次动态求值。\n- 在任何一种情况下，都只发生一次求值。\n期望求值次数 $E_{\\text{after}}$ 为：\n$$E_{\\text{after}} = 1 \\cdot P(P_1) + 1 \\cdot P(P_2) = 1 \\cdot \\frac{3}{5} + 1 \\cdot \\frac{2}{5} = \\frac{3}{5} + \\frac{2}{5} = 1$$\n\n**任务 3：计算期望减少量**\n\n动态求值次数的期望减少量是变换前后期望次数之差。\n$$\\text{Reduction} = E_{\\text{before}} - E_{\\text{after}} = \\frac{8}{5} - 1 = \\frac{8}{5} - \\frac{5}{5} = \\frac{3}{5}$$", "answer": "$$\\boxed{\\frac{3}{5}}$$", "id": "3649324"}, {"introduction": "在掌握了基本应用后，让我们来看一个代码移动技术最能大显身手的场景：循环优化。本练习聚焦于一个循环不变量表达式，即其值在整个循环执行过程中保持不变。你需要判断惰性代码移动会将其放置在何处，并理解为何将其移出循环对性能至关重要 [@problem_id:3649373]。这个练习将揭示惰性代码移动的“智能”之处——它不仅能识别出可移动的代码，还能确保代码不会被错误地移入执行频率更高的区域（例如循环内部），从而避免性能下降。", "problem": "考虑以下由控制流图（CFG）表示的程序。控制流图（CFG）是一个有向图，其节点是基本块，其边代表可能的控制流。节点为 $B_{0}$ 到 $B_{6}$，边如下所述。该程序使用变量 $x$、$y$、$i$ 和一个正整数 $m \\ge 1$。设 $h_{1}(\\cdot)$ 和 $h_{2}(\\cdot)$ 是不修改 $x$ 或 $y$ 的纯函数。\n\n- 块 $B_{0}$：初始化 $x$、$y$ 和 $i$ 为 $x := \\text{input}(),\\ y := \\text{input}(),\\ i := 0$；然后将控制权转移到 $B_{1}$。\n- 块 $B_{1}$（前置首部）：一个用于连接循环入口的空块；将控制权转移到 $B_{2}$。\n- 块 $B_{2}$（循环体入口）：包含一个基于谓词 $p(i)$ 的条件分支：\n  - 如果 $p(i)$ 为真，控制权转到 $B_{3}$。\n  - 如果 $p(i)$ 为假，控制权转到 $B_{4}$。\n- 块 $B_{3}$：包含使用 $u := h_{1}(x + y)$；将控制权转移到 $B_{5}$。\n- 块 $B_{4}$：包含使用 $v := h_{2}(x + y)$；将控制权转移到 $B_{5}$。\n- 块 $B_{5}$：更新 $i := i + 1$；如果 $i  m$，将控制权转回 $B_{2}$；否则转到 $B_{6}$。\n- 块 $B_{6}$：退出。\n\n假设循环是 do-while 风格：在到达 $B_{5}$ 中的退出测试之前，循环体至少执行一次，也就是说，从 $B_{1}$ 开始，没有路径可以到达 $B_{6}$ 而不至少执行一次 $B_{3}$ 或 $B_{4}$。还假设 $x$ 和 $y$ 仅在 $B_{0}$ 中被赋值，并且在其他任何地方都未被修改；因此，$x + y$ 是循环不变量。在每次迭代中，$B_{3}$ 或 $B_{4}$ 中只有一个被执行（取决于 $p(i)$），并且无论走哪个分支，该次迭代中都会有一次对 $x + y$ 的使用。\n\n懒代码移动（Lazy Code Motion, LCM）是一种程序优化技术，它通过利用数据流属性（如支配性、下向安全性（down-safety）和预期性（anticipability））将计算放置在安全且不冗余的位置。循环前置首部是一个支配循环体的块，并允许在进入循环之前执行计算。\n\n任务：\n- 仅使用控制流图（CFG）、支配性、循环不变量表达式的核心定义，以及懒代码移动（LCM）避免在不需要表达式的路径上进行计算的定性原则，确定 $x + y$ 计算的 $Latest$ 放置是否会将其置于循环外的 $B_{1}$ 中，而不是循环内的 $B_{2}$ 或更深的位置。将您的决定编码为 $I$，如果 $Latest$ 放置将 $x + y$ 置于循环外（在 $B_{1}$ 中），则 $I = 1$，否则 $I = 0$。\n- 假设 $x + y$ 的计算被错误地放置，强制其在 $B_{2}$ 的开头执行，从而使其在每次迭代中都重新计算一次，而不管分支 $p(i)$ 如何。将由此导致的总执行次数的增加量 $$\\Delta \\text{execs} := \\text{(错误放置的执行次数)} - \\text{($Latest$ 放置下的执行次数)}$$ 量化为一个关于 $m$ 的闭式表达式。\n\n以一个二元行矩阵 $\\begin{pmatrix} I  \\Delta \\text{execs} \\end{pmatrix}$ 的形式提供您的最终答案。不需要四舍五入，也没有物理单位。", "solution": "首先对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **控制流图（CFG）节点：** $B_{0}, B_{1}, B_{2}, B_{3}, B_{4}, B_{5}, B_{6}$。\n- **节点 $B_{0}$：** $x := \\text{input}()$, $y := \\text{input}()$, $i := 0$。\n- **节点 $B_{1}$：** 空的前置首部。\n- **节点 $B_{2}$：** 基于 $p(i)$ 的条件跳转。\n- **节点 $B_{3}$：** 包含使用 $u := h_{1}(x + y)$。\n- **节点 $B_{4}$：** 包含使用 $v := h_{2}(x + y)$。\n- **节点 $B_{5}$：** $i := i + 1$；基于 $i  m$ 的条件跳转。\n- **节点 $B_{6}$：** 退出。\n- **CFG 边：** $B_{0} \\to B_{1}$，$B_{1} \\to B_{2}$，$B_{2} \\to B_{3}$ (如果 $p(i)$)，$B_{2} \\to B_{4}$ (如果非 $p(i)$)，$B_{3} \\to B_{5}$，$B_{4} \\to B_{5}$，$B_{5} \\to B_{2}$ (如果 $i  m$），$B_{5} \\to B_{6}$ (如果 $i \\ge m$）。\n- **常量和变量：** $m$ 是一个正整数，$m \\ge 1$。$x, y, i$ 是变量。\n- **函数：** $h_1(\\cdot)$ 和 $h_2(\\cdot)$ 是纯函数。\n- **假设：**\n    1. 循环是“do-while 风格”，保证至少执行一次。\n    2. $x$ 和 $y$ 仅在 $B_0$ 中被赋值。\n    3. 表达式 $x+y$ 是循环不变量。\n    4. 在每次迭代中，$B_3$ 或 $B_4$ 中只有一个被执行，且每个都包含对 $x+y$ 的使用。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在编译器理论和程序优化领域内定义明确。控制流图、循环不变量表达式和懒代码移动（LCM）是标准的计算机科学主题。所提供的 CFG 是一致的，假设也清晰陈述。该问题具有科学依据、客观且自洽。它不包含任何矛盾或含糊之处。\n\n### 步骤 3：结论和行动\n问题是**有效的**。将提供解答。\n\n### 解答推导\n任务是根据懒代码移动（LCM）的原则确定 $x+y$ 计算的最佳放置位置，并量化非最佳放置的成本。\n\n**第 1 部分：$x+y$ 的 `Latest` 放置和 $I$ 的确定**\n\n要优化的表达式是 $E = x + y$。\n1.  **循环不变性：** 问题陈述 $x$ 和 $y$ 仅在入口块 $B_{0}$ 中赋值，并且在循环内不被修改。因此，$E = x+y$ 的值在循环的所有迭代中都是恒定的，使其成为一个循环不变量表达式。这是循环代码移动的主要条件。\n\n2.  **预期性（下向安全性）：** 如果在从某个程序点出发的每条路径上，一个表达式都被使用，并且在使用前其操作数没有被重新定义，那么该表达式在该点就是可预期的。我们来分析循环前置首部入口，即块 $B_1$ 处的预期性。任何从 $B_1$ 出发的路径都必须前进到 $B_2$，然后到 $B_3$ 或 $B_4$，再到 $B_5$。问题陈述 $x+y$ 在 $B_3$ 和 $B_4$ 中都被使用。因此，无论在 $B_2$ 处采用哪个分支，表达式 $x+y$ 都保证在循环的每次迭代中被使用。由于没有从 $B_1$ 到出口 $B_6$ 的路径可以绕过循环，因此表达式 $x+y$ 在 $B_1$ 的入口处是可预期的。\n\n3.  **懒代码移动（LCM）：** LCM 将计算提升到尽可能早的位置，但在该可提升区域内将其放置在尽可能晚的位置，以最小化寄存器压力，同时不增加总计算次数。只有当计算是安全且有利可图时，才会被提升出循环。\n    - **安全性：** 将计算放在前置首部 $B_1$ 中是安全的，因为通过 $B_1$ 的每条路径都需要该表达式的值。不存在计算会被不必要地执行的路径。\n    - **有利性：** 原始代码在循环内部计算 $x+y$，每次迭代计算一次。通过将计算移动到只执行一次的前置首部 $B_1$，我们将执行次数从 $m$（迭代次数）减少到 $1$。这是一个有利可图的转换。\n    - **懒惰性：** “懒惰”原则将计算延迟到尽可能晚的位置。然而，这种计算的下沉受到约束，不能跨越会增加其执行频率的边界。最早的、循环外的放置位置是前置首部 $B_{1}$。将其从 $B_1$ 下沉到 $B_2$ 将把它从单次执行区域移动到多次执行区域（循环），从而将执行次数从 $1$ 增加到 $m$。LCM 不会执行这样的转换。维持执行次数为 $1$ 的最晚可能放置位置是在 $B_1$ 内。\n\n因此，计算 $t := x+y$ 的 `Latest` 放置位置是在循环前置首部 $B_1$ 中。这在循环之外。根据问题陈述，如果放置在 $B_1$ 中，则 $I=1$。\n$$I = 1$$\n\n**第 2 部分：$\\Delta \\mathrm{execs}$ 的计算**\n\n我们需要计算错误放置和 `Latest` 放置之间 $x+y$ 总执行次数的差异。\n$$ \\Delta \\text{execs} = (\\text{错误放置的执行次数}) - (\\text{`Latest` 放置下的执行次数}) $$\n\n1.  **`Latest` 放置下的执行次数：** 如上所述，计算被放置在 $B_1$ 中。块 $B_1$ 在循环开始前只执行一次。\n    $$ \\text{executions}_{\\text{Latest}} = 1 $$\n\n2.  **错误放置下的执行次数：** 问题指定了一个在块 $B_2$ 开始处的错误放置。块 $B_2$ 是循环体的入口点。为了找到执行次数，我们必须确定循环的迭代次数。\n    - 循环计数器 $i$ 在 $B_0$ 中初始化为 $0$。\n    - 包含 $B_2$ 的循环体被执行。\n    - 在每次迭代结束时，在块 $B_5$ 中，$i$ 被递增（$i := i+1$），并检查条件 $i  m$。\n    - 进入块 $B_2$ 时 $i$ 的值序列是 $0, 1, 2, \\dots$。\n    - 在条件 $i  m$ 中被测试的 $i$ 的值序列是 $1, 2, 3, \\dots$。\n    - 只要检查为真，循环就继续。循环将对 $i_{\\text{check}} = 1, 2, \\dots, m-1$ 执行。循环将最后执行一次，导致检查 $i_{\\text{check}}=m$。\n    - 对于 $i_{\\text{check}}=m$，条件 $m  m$ 为假，循环终止。\n    - 对于从 $0$ 到 $m-1$ 的初始值 $i$，循环体都会被进入。\n    - 总迭代次数为 $(m-1) - 0 + 1 = m$。\n    - 由于 $B_2$ 每次迭代执行一次，它被执行 $m$ 次。\n    $$ \\text{executions}_{\\text{mis-placed}} = m $$\n\n3.  **执行次数差异：**\n    $$ \\Delta \\text{execs} = \\text{executions}_{\\text{mis-placed}} - \\text{executions}_{\\text{Latest}} = m - 1 $$\n    鉴于 $m \\ge 1$，冗余执行的次数为 $\\Delta \\text{execs} \\ge 0$。\n\n最终答案由 $I$ 和 $\\Delta \\mathrm{execs}$ 组成。\n$I=1$ 且 $\\Delta \\mathrm{execs} = m-1$。", "answer": "$$\\boxed{\\begin{pmatrix} 1  m-1 \\end{pmatrix}}$$", "id": "3649373"}, {"introduction": "我们已经通过实例看到了惰性代码移动的“效果”，现在是时候深入其“原理”了。本练习将带你深入探索惰性代码移动的内部引擎。你需要手动计算算法赖以决策的几个核心数据流集合，包括预期性 ($Ant$)、可用性 ($Avail$) 等 [@problem_id:3649357]。完成这个练习将帮助你从根本上建立对该优化过程的坚实理解，明白编译器是如何精确地找到代码放置的最“懒惰”且安全的位置的。", "problem": "考虑以下由基本块组成的控制流图 (CFG)，这些基本块构成一个单入口、单出口的过程。设我们感兴趣的算术表达式为二元表达式 $e \\equiv a + b$。各基本块如下：\n\n- $B_1$：一个条件分支，跳转到 $B_2$ 或 $B_3$；$B_1$ 不对 $a$ 或 $b$ 赋值，也不计算 $e$。\n- $B_2$：首先计算 $x \\leftarrow a + b$，然后赋值 $a \\leftarrow a + 1$，接着跳转到 $B_4$。\n- $B_3$：一个条件分支，跳转到 $B_4$ 或 $B_5$；$B_3$ 不对 $a$ 或 $b$ 赋值，也不计算 $e$。\n- $B_5$：计算 $y \\leftarrow a + b$，然后跳转到 $B_4$。\n- $B_4$：计算 $z \\leftarrow a + b$，然后返回。\n\n假设没有对 $a$ 或 $b$ 的其他赋值发生。控制流边为 $(B_1,B_2)$、$(B_1,B_3)$、$(B_2,B_4)$、$(B_3,B_4)$、$(B_3,B_5)$、$(B_5,B_4)$。入口块是 $B_1$。您可以假设块内是直线执行的。\n\n您的任务是，仅从核心数据流语义出发，为单个表达式 $e$ 手动计算用于部分冗余消除 (PRE) 的惰性代码移动 (LCM) 所使用的以下量：\n\n- $Ant$：$e$ 在每个程序点的向下安全性（也称为可期待性）（特别是在块入口处的值 $Ant\\_in[B]$ 和块出口处的值 $Ant\\_out[B]$）。\n- $Avail$：$e$ 在每个程序点的可用性（特别是在块入口处的值 $Avail\\_in[B]$ 和块出口处的值 $Avail\\_out[B]$）。\n- $Earliest$：$e$ 在每条控制流边上的最早安全插入条件。\n- $Latest$：$e$ 在每条控制流边上，经过推迟以不增加执行频率后的最迟安全插入条件。\n\n您的推导应基于可期待性和可用性的 must 数据流分析的基本定义：一个 must 属性在某个程序点成立，当且仅当它在该点之前或之后的所有路径上都成立，其交汇操作符定义为逻辑与，并且块内局部传递函数要考虑一个块是否计算 $e$ 以及它对 $e$ 是否是透明的（块内没有对 $e$ 的操作数进行赋值）。除了这些语义之外，不要假设任何特定的算法捷径。\n\n然后，将 $Latest$ 解释为 LCM 的放置集合：在 $Latest$ 成立的那些边上精确地插入 $e$，并删除任何现在变得冗余的原始计算。\n\n计算在此 CFG 和此 $e$ 的情况下，$Latest$ 成立的边的总数 $N$。提供 $N$ 作为您的最终答案。无需四舍五入。将您的最终答案表示为单个实数值。", "solution": "用户要求我对给定的控制流图 (CFG) 上的表达式 $e \\equiv a + b$ 执行惰性代码移动 (LCM) 分析。目标是确定 `Latest` 属性成立的控制流边的数量 $N$，这对应于应该插入 $e$ 计算的边的集合。\n\n首先，我将为每个基本块建立关于表达式 $e \\equiv a+b$ 的局部数据流属性。关键属性是：\n- $e\\_use[B]$：块 $B$ 在其任何操作数（$a$ 或 $b$）在 $B$ 内部被重新定义之前计算 $e$。\n- $e\\_kill[B]$：块 $B$ 包含对 $e$ 的一个操作数（$a$ 或 $b$）的赋值。\n- $e\\_gen[B]$：表达式 $e$ 在 $B$ 中计算，并且其值在 $B$ 的出口处可用。如果 $e$ 被计算并且之后在 $B$ 中未被终止，则该属性为真。\n每个块的属性如下：\n- $B_1$：条件分支。不计算 $e$ 或对 $a$ 或 $b$ 赋值。\n  $e\\_use[B_1] = \\text{false}$， $e\\_kill[B_1] = \\text{false}$， $e\\_gen[B_1] = \\text{false}$。\n- $B_2$：`x - a + b; a - a + 1`。计算 $e$，然后对 $a$ 赋值。\n  $e\\_use[B_2] = \\text{true}$， $e\\_kill[B_2] = \\text{true}$， $e\\_gen[B_2] = \\text{false}$ （计算出的值被对 $a$ 的赋值所终止）。\n- $B_3$：条件分支。不计算 $e$ 或对 $a$ 或 $b$ 赋值。\n  $e\\_use[B_3] = \\text{false}$， $e\\_kill[B_3] = \\text{false}$， $e\\_gen[B_3] = \\text{false}$。\n- $B_4$：`z - a + b`。计算 $e$。\n  $e\\_use[B_4] = \\text{true}$， $e\\_kill[B_4] = \\text{false}$， $e\\_gen[B_4] = \\text{true}$。\n- $B_5$：`y - a + b`。计算 $e$。\n  $e\\_use[B_5] = \\text{true}$， $e\\_kill[B_5] = \\text{false}$， $e\\_gen[B_5] = \\text{true}$。\n\nLCM 分析分四步进行。\n\n**1. 计算可期待性 ($Ant$)**\n可期待性（或向下安全性）是一种反向“must”分析。如果一个表达式从某点开始的所有路径上，在其某个操作数被重新定义之前被使用，那么它在该点是可期待的。数据流方程为：\n$$Ant\\_out[B] = \\bigwedge_{S \\in succ(B)} Ant\\_in[S]$$\n$$Ant\\_in[B] = e\\_use[B] \\lor (Ant\\_out[B] \\land \\neg e\\_kill[B])$$\n边界条件是 $Ant\\_out[B_{exit}] = \\text{false}$。对于我们的 CFG，$B_4$ 是出口块，所以 $Ant\\_out[B_4] = \\text{false}$。我们将所有其他的 $Ant$ 值初始化为 $\\text{false}$ 并迭代至不动点。\n\n- 迭代 1：\n  - $Ant\\_in[B_4] = e\\_use[B_4] \\lor (Ant\\_out[B_4] \\land \\neg e\\_kill[B_4]) = \\text{true} \\lor (\\text{false} \\land \\text{true}) = \\text{true}$。\n  - $Ant\\_out[B_5] = Ant\\_in[B_4] = \\text{true}$。\n  - $Ant\\_in[B_5] = e\\_use[B_5] \\lor (Ant\\_out[B_5] \\land \\neg e\\_kill[B_5]) = \\text{true} \\lor (\\text{true} \\land \\text{true}) = \\text{true}$。\n  - $Ant\\_out[B_2] = Ant\\_in[B_4] = \\text{true}$。\n  - $Ant\\_in[B_2] = e\\_use[B_2] \\lor (Ant\\_out[B_2] \\land \\neg e\\_kill[B_2]) = \\text{true} \\lor (\\text{true} \\land \\text{false}) = \\text{true}$。\n  - $Ant\\_out[B_3] = Ant\\_in[B_4] \\land Ant\\_in[B_5] = \\text{true} \\land \\text{true} = \\text{true}$。\n  - $Ant\\_in[B_3] = e\\_use[B_3] \\lor (Ant\\_out[B_3] \\land \\neg e\\_kill[B_3]) = \\text{false} \\lor (\\text{true} \\land \\text{true}) = \\text{true}$。\n  - $Ant\\_out[B_1] = Ant\\_in[B_2] \\land Ant\\_in[B_3] = \\text{true} \\land \\text{true} = \\text{true}$。\n  - $Ant\\_in[B_1] = e\\_use[B_1] \\lor (Ant\\_out[B_1] \\land \\neg e\\_kill[B_1]) = \\text{false} \\lor (\\text{true} \\land \\text{true}) = \\text{true}$。\n\n经过一次迭代，达到不动点。表达式 $e$ 在每个块的入口处都是可期待的（对于所有 $B$，$Ant\\_in[B] = \\text{true}$），并且在除最后一个块之外的所有块的出口处也是可期待的 ($Ant\\_out[B_4]=\\text{false}$)。\n\n**2. 计算可用性 ($Avail$)**\n可用性是一种正向“must”分析。如果一个表达式在通往某点的所有路径上都已被计算，并且之后未被终止，那么它在该点是可用的。数据流方程为：\n$$Avail\\_in[B] = \\bigwedge_{P \\in pred(B)} Avail\\_out[P]$$\n$$Avail\\_out[B] = e\\_gen[B] \\lor (Avail\\_in[B] \\land \\neg e\\_kill[B])$$\n边界条件是 $Avail\\_in[B_{entry}] = \\text{false}$。对于我们的 CFG，$B_1$ 是入口块，所以 $Avail\\_in[B_1] = \\text{false}$。我们将所有其他的 $Avail$ 值初始化为 $\\text{false}$ 并进行迭代。\n\n- 迭代 1：\n  - $Avail\\_out[B_1] = e\\_gen[B_1] \\lor (Avail\\_in[B_1] \\land \\neg e\\_kill[B_1]) = \\text{false} \\lor (\\text{false} \\land \\text{true}) = \\text{false}$。\n  - $Avail\\_in[B_2] = Avail\\_out[B_1] = \\text{false}$。\n  - $Avail\\_in[B_3] = Avail\\_out[B_1] = \\text{false}$。\n  - $Avail\\_out[B_2] = e\\_gen[B_2] \\lor (Avail\\_in[B_2] \\land \\neg e\\_kill[B_2]) = \\text{false} \\lor (\\text{false} \\land \\text{false}) = \\text{false}$。\n  - $Avail\\_out[B_3] = e\\_gen[B_3] \\lor (Avail\\_in[B_3] \\land \\neg e\\_kill[B_3]) = \\text{false} \\lor (\\text{false} \\land \\text{true}) = \\text{false}$。\n  - $Avail\\_in[B_5] = Avail\\_out[B_3] = \\text{false}$。\n  - $Avail\\_out[B_5] = e\\_gen[B_5] \\lor (Avail\\_in[B_5] \\land \\neg e\\_kill[B_5]) = \\text{true} \\lor (\\text{false} \\land \\text{true}) = \\text{true}$。\n  - $Avail\\_in[B_4] = Avail\\_out[B_2] \\land Avail\\_out[B_3] \\land Avail\\_out[B_5] = \\text{false} \\land \\text{false} \\land \\text{true} = \\text{false}$。\n  - $Avail\\_out[B_4] = e\\_gen[B_4] \\lor (Avail\\_in[B_4] \\land \\neg e\\_kill[B_4]) = \\text{true} \\lor (\\text{false} \\land \\text{true}) = \\text{true}$。\n\n达到不动点。表达式 $e$ 在任何块的入口处都不可用（对于所有 $B$，$Avail\\_in[B] = \\text{false}$）。\n\n**3. 计算 $Earliest$**\n`Earliest` 属性标识了可以安全放置计算的最早点。如果表达式是可期待的（$Ant\\_in[B]$）但尚不可用（$Avail\\_in[B]$），则在块 $B$ 的入口处插入是安全的。\n$$Earliest\\_in[B] = Ant\\_in[B] \\land \\neg Avail\\_in[B]$$\n使用我们关于 $Ant\\_in$ 和 $Avail\\_in$ 的结果：\n对于所有块 $B \\in \\{B_1, B_2, B_3, B_4, B_5\\}$，我们有 $Ant\\_in[B] = \\text{true}$ 和 $Avail\\_in[B] = \\text{false}$。因此，对于所有块，$Earliest\\_in[B] = \\text{true}$。\n\n**4. 计算 $Latest$**\n`Latest` 属性标识了计算的最迟可能放置位置，这是通过将 `Earliest` 放置点尽可能地向后推迟，而不增加执行频率或越过表达式的使用点来确定的。这可以通过对推迟过程的推理来确定。\n\n- 路径 $B_1 \\to B_2 \\to B_4$：\n$B_2$ 中的计算 $x \\leftarrow a+b$ 是必需的。随后，块 $B_2$ 修改了 $a$。因此，$B_4$ 中的计算 $z \\leftarrow a+b$ 依赖于 $a$ 的*新*值，也是必需的。这条路径上没有冗余。一个正确的 LCM 实现不应在这条路径上插入任何代码，因为它没有任何益处。\n\n- 通过 $B_3$ 的路径：\n在过程的入口处，$B_1$ 之前，有一个 `Earliest` 放置点。这可以被推入 $B_1$。由于 $B_1$ 是透明的，并且表达式在其所有后继路径（到 $B_2$ 和 $B_3$）上都是可期待的，因此该放置可以被推到边 $(B_1, B_2)$ 和 $(B_1, B_3)$ 上。\n- 在 $(B_1,B_2)$ 上的放置不能被推迟到 $B_2$ 中，因为 $e\\_use[B_2]=\\text{true}$。然而，如前所述，这条路径没有提供冗余，所以这里不应该有 `Latest` 放置。问题源于简单的 `Earliest` 分析，它没有考虑盈利性，将整个程序标记为插入的候选。一个更细致的分析会显示这里没有益处。\n- 在 $(B_1,B_3)$ 上的放置可以被推迟。块 $B_3$ 是透明的（$e\\_use[B_3]=\\text{false}$ 且 $e\\_kill[B_3]=\\text{false}$）。因此，计算从边 $(B_1,B_3)$ 被推到 $B_3$ 的出边，即 $(B_3, B_4)$ 和 $(B_3, B_5)$。这就是“惰性”移动的本质：将计算移动过分支点。\n- 我们可以将边 $(B_3, B_4)$ 上的放置推迟到块 $B_4$ 中吗？不行，因为 $B_4$ 使用了该表达式（$e\\_use[B_4]=\\text{true}$）。因此，推迟在这里停止，边 $(B_3, B_4)$ 是一个 `Latest` 放置点。\n- 我们可以将边 $(B_3, B_5)$ 上的放置推迟到块 $B_5$ 中吗？不行，因为 $B_5$ 使用了该表达式（$e\\_use[B_5]=\\text{true}$）。因此，推迟在这里停止，边 $(B_3, B_5)$ 是一个 `Latest` 放置点。\n\n基于这种语义推理（它比一个未能正确建模此特定情况的简化数据流算法的朴素应用更为稳健），有两条边上 `Latest` 成立。这些放置消除了 $B_4$ 中计算的部分冗余以及 $B_5$ 中原始计算的冗余。\n\n$Latest$ 成立的边是 $(B_3,B_4)$ 和 $(B_3,B_5)$。这类边的总数是 $N$。\n\n$$N = 2$$", "answer": "$$\\boxed{2}$$", "id": "3649357"}]}