{"hands_on_practices": [{"introduction": "本次练习旨在介绍流敏感分析（flow-sensitive analysis），这是一种逐条语句追踪指针变化的分析方法。我们将运用该方法来确定“必别名”（must-alias）关系，即在任何执行路径下，两个指针都必然指向同一内存位置。掌握这种分析是进行精确静态分析并实现强大优化的基础。[@problem_id:3662990]", "problem": "考虑一个直线型程序片段，其中包含三个指针变量和两个不同的栈分配整数位置。按顺序执行的语句如下：\n语句 $s_{1}$：$p = x;$\n语句 $s_{2}$：$q = p;$\n语句 $s_{3}$：$r = x;$\n语句 $s_{4}$：$p = y;$\n\n假设一个流敏感、上下文不敏感的指针分析，该分析对指针变量执行强更新，并将每个栈分配的标量建模为一个唯一的抽象位置。该语言具有标准的取址语义：运算符 `` 产生一个标量的地址，指针赋值复制引用的地址值，并且变量 $p$、$q$、$r$ 本身没有别名（即没有指向指针的指针），没有来自并发的干扰，也没有函数调用。\n\n从基本定义出发，即一个指针变量 $v$ 在程序点上的指向集 $PT(v)$ 是 $v$ 在该点可能表示的抽象位置的集合，并且两个指针 $a$ 和 $b$ 在一个程序点上处于必别名关系（must-alias relation），如果所有到达该点的可能执行中，$a$ 和 $b$ 都表示同一个单一的抽象位置，请构建每条语句执行后的指向图，并确定在语句 $s_{4}$ 执行后，在 $\\{p, q, r\\}$ 中处于必别名关系的无序指针配对的数量。以整数形式提供最终答案，不带单位且不进行四舍五入。[@problem_id:449]", "solution": "该问题要求我们对给定的程序片段执行流敏感的指针分析，并确定在执行结束时必别名指针配对的数量。\n\n我们首先将所描述的模型形式化。我们有两个不同的栈分配标量变量，$x$ 和 $y$。在分析的抽象内存模型中，它们对应于两个唯一的抽象位置，我们分别表示为 $l_x$ 和 $l_y$。我们有三个指针变量：$p$、$q$ 和 $r$。我们在任何程序点的分析状态是这些指针各自的指向集的集合：$(PT(p), PT(q), PT(r))$。指针 $v$ 的指向集 $PT(v)$ 包含 $v$ 可能指向的抽象位置。\n\n该分析是流敏感的，这意味着我们为每个程序点计算指向信息，并考虑语句的顺序。它采用强更新，这意味着对指针变量 $v$ 的赋值会“杀死”（kill）$v$ 先前的指向信息。这是允许的，因为没有指向 $p$、$q$ 或 $r$ 本身的指针。\n\n我们从语句 $s_1$ 之前的初始状态开始，此时指针未初始化。它们的指向集为空。设 $PT_k(v)$ 表示变量 $v$ 在语句 $s_k$ 执行后的指向集。\n\n初始状态（$s_1$ 之前）：\n$PT_0(p) = \\emptyset$\n$PT_0(q) = \\emptyset$\n$PT_0(r) = \\emptyset$\n\n现在，我们按顺序追踪每条语句的效果。\n\n语句 $s_1$ 执行后：$p = x;$\n该语句将标量变量 $x$ 的地址赋给指针 $p$。在我们的抽象模型中，这意味着 $p$ 现在指向抽象位置 $l_x$。分析执行强更新，因此 $p$ 先前的指向集被丢弃并替换。\n$PT_1(p) = \\{l_x\\}$\n其他指针不受影响。\n$PT_1(q) = PT_0(q) = \\emptyset$\n$PT_1(r) = PT_0(r) = \\emptyset$\n执行 $s_1$ 后的指向图包含一条从 $p$ 到 $l_x$ 的边。\n\n语句 $s_2$ 执行后：$q = p;$\n该语句将指针 $p$ 的值赋给指针 $q$。在指针分析的上下文中，这意味着 $q$ 现在指向 $p$ 所指向的任何位置。信息从 $p$ 流向 $q$。\n$q$ 的指向集成为 $p$ 的指向集的副本。\n$PT_2(q) = PT_1(p) = \\{l_x\\}$\n其他指针在此步骤中不受影响。\n$PT_2(p) = PT_1(p) = \\{l_x\\}$\n$PT_2(r) = PT_1(r) = \\emptyset$\n执行 $s_2$ 后的指向图有两条边：一条从 $p$ 到 $l_x$，另一条从 $q$ 到 $l_x$。\n\n语句 $s_3$ 执行后：$r = x;$\n该语句将标量变量 $x$ 的地址赋给指针 $r$。这与语句 $s_1$ 类似。指针 $r$ 现在指向抽象位置 $l_x$。\n$PT_3(r) = \\{l_x\\}$\n其他指针不受影响。\n$PT_3(p) = PT_2(p) = \\{l_x\\}$\n$PT_3(q) = PT_2(q) = \\{l_x\\}$\n执行 $s_3$ 后，所有三个指针 $p$、$q$ 和 $r$ 都指向同一个抽象位置 $l_x$。指向图有三条边，都指向 $l_x$。\n\n语句 $s_4$ 执行后：$p = y;$\n该语句将标量变量 $y$ 的地址赋给指针 $p$。这对应于抽象位置 $l_y$。分析对 $p$ 执行强更新，因此其先前的指向信息（指向 $l_x$）被“杀死”并替换。\n$PT_4(p) = \\{l_y\\}$\n$q$ 和 $r$ 的指向集不受此语句影响。\n$PT_4(q) = PT_3(q) = \\{l_x\\}$\n$PT_4(r) = PT_3(r) = \\{l_x\\}$\n这是整个程序片段执行后指向集的最终状态。\n\n现在，我们必须确定在 $\\{p, q, r\\}$ 中处于必别名关系的无序配对的数量。\n两个指针 $a$ 和 $b$ 之间的必别名关系的定义是，在所有可能的执行中，它们保证指向同一个单一的抽象位置。形式上，这需要在特定程序点满足三个条件：\n1. $a$ 的指向集必须是单例集：$|PT(a)| = 1$。\n2. $b$ 的指向集必须是单例集：$|PT(b)| = 1$。\n3. 这两个单例集必须相同：$PT(a) = PT(b)$。\n\n让我们使用最终的指向集来检查这三个无序配对：\n- $PT_4(p) = \\{l_y\\}$\n- $PT_4(q) = \\{l_x\\}$\n- $PT_4(r) = \\{l_x\\}$\n\n配对 1：$(p, q)$\n$|PT_4(p)| = |\\{l_y\\}| = 1$。\n$|PT_4(q)| = |\\{l_x\\}| = 1$。\n然而，$PT_4(p) = \\{l_y\\} \\neq \\{l_x\\} = PT_4(q)$。\n因此，$p$ 和 $q$ 不处于必别名关系。它们处于必不别名关系（must-not-alias relation），因为它们保证指向不同的位置。\n\n配对 2：$(p, r)$\n$|PT_4(p)| = |\\{l_y\\}| = 1$。\n$|PT_4(r)| = |\\{l_x\\}| = 1$。\n然而，$PT_4(p) = \\{l_y\\} \\neq \\{l_x\\} = PT_4(r)$。\n因此，$p$ 和 $r$ 不处于必别名关系。\n\n配对 3：$(q, r)$\n$|PT_4(q)| = |\\{l_x\\}| = 1$。\n$|PT_4(r)| = |\\{l_x\\}| = 1$。\n并且，$PT_4(q) = \\{l_x\\} = PT_4(r)$。\n必别名关系的所有三个条件都得到满足。\n因此，$q$ 和 $r$ 处于必别名关系。\n\n计算处于必别名关系的无序指针配对的数量，我们发现只有一个这样的配对：$(q, r)$。\n最终答案是 $1$。", "answer": "$$\\boxed{1}$$", "id": "3662990"}, {"introduction": "在上一个练习的基础上，我们现在来处理一个更复杂的场景：指向指针的指针（pointers-to-pointers）。本练习将考验你追踪间接赋值的能力，即通过一个指针的写入操作如何改变另一个指针的目标。这是理解 C/C++ 等语言中复杂内存操作和实现精确别名分析的关键。[@problem_id:3663003]", "problem": "您正在静态指针和别名分析的层面上分析一个类C程序片段。考虑四个地址不相交的不同标量位置：两个整型变量 $x$ 和 $y$，一个指向整型的指针 $p$，以及一个指向整型指针的指针 $pp$。假设进行一种流敏感、路径不敏感、上下文不敏感、字段不敏感的May-Points-To分析，并对单例抽象位置执行强更新。程序从一个未初始化的状态（其中没有已知的指向信息）开始，按顺序执行以下语句序列：\n- $p := x$\n- $pp := p$\n- $\\ast pp := y$\n- $\\ast p := 3$\n\n从指向关系的基本定义以及类C语言中赋值和间接存储的操作语义出发，推导出：\n1. 最后一条语句 $\\ast p := 3$ 写入的最终内存目标（即，具体的标量位置）。\n2. 序列结束时最终的指向集 $\\operatorname{Pts}(p)$ 和 $\\operatorname{Pts}(pp)$，其中对于指针变量 $v$，$\\operatorname{Pts}(v)$ 是 $v$ 可能指向的抽象位置的集合。\n\n设整数 $R$ 定义为\n$$\nR \\;=\\; |\\operatorname{Pts}(p)| \\;+\\; 2\\,|\\operatorname{Pts}(pp)| \\;+\\; v,\n$$\n其中 $|\\,\\cdot\\,|$ 表示集合的基数，而 $v$ 是最后一次存储操作 $\\ast p := 3$ 写入的值。计算 $R$。将最终答案表示为整数。无需四舍五入。", "solution": "问题要求对一个类C语句序列进行流敏感、路径不敏感的May-Points-To分析。我们将追踪指针 $p$ 和 $pp$ 的指向集在每条语句执行后的状态。设变量 $x$、$y$、$p$ 和 $pp$ 的不同抽象内存位置分别表示为 $l_x$、$l_y$、$l_p$ 和 $l_{pp}$。指针变量 $v$ 的指向集将表示为 $\\operatorname{Pts}(v)$。根据分析的规定，当赋值语句左侧被解引用的指针指向一个单例抽象位置时，将执行强更新。\n\n初始状态：\n程序从未初始化的状态开始，此时没有已知的指向信息。\n设 $\\operatorname{Pts}_i(v)$ 为语句 $i$ 执行后 $v$ 的指向集。\n第一条语句之前的状态是：\n$$ \\operatorname{Pts}_{0}(p) = \\emptyset $$\n$$ \\operatorname{Pts}_{0}(pp) = \\emptyset $$\n\n语句 1: $p := x$\n这是一个直接取地址的赋值操作。指针 $p$ 被赋为变量 $x$ 的地址。分析更新 $p$ 的指向集，使其包含 $x$ 的位置。旧集合被丢弃，新集合为 $\\{l_x\\}$。\n$$ \\operatorname{Pts}_{1}(p) = \\{l_x\\} $$\n$$ \\operatorname{Pts}_{1}(pp) = \\operatorname{Pts}_{0}(pp) = \\emptyset $$\n\n语句 2: $pp := p$\n这是另一个直接取地址的赋值操作。指针 $pp$ 被赋为指针变量 $p$ 的地址。分析更新 $pp$ 的指向集，使其包含 $p$ 的位置。\n$p$ 的指向集保持不变。\n$$ \\operatorname{Pts}_{2}(p) = \\operatorname{Pts}_{1}(p) = \\{l_x\\} $$\n$$ \\operatorname{Pts}_{2}(pp) = \\{l_p\\} $$\n\n语句 3: $\\ast pp := y$\n这是一个间接赋值，也称为通过指针存储。左侧的变量是一个间接引用，$\\ast pp$。为了确定哪个位置被修改，我们必须检查 $pp$ 的指向集。\n从上一步可知，$\\operatorname{Pts}_{2}(pp) = \\{l_p\\}$。\n这是一个单例集，只包含抽象位置 $l_p$。问题规定对单例抽象位置执行强更新。强更新意味着目标位置的现有信息被“杀死”（移除），并被赋值语句右侧的新信息所取代。\n更新的目标是 $pp$ 指向的位置，即 $l_p$。变量 $p$ 位于位置 $l_p$。因此，这条语句修改了指针 $p$ 本身。\n右侧是 `y`，它代表变量 $y$ 的地址。因此，该语句的效果是改变 $p$ 的指向。$p$ 的旧指向集 $\\{l_x\\}$ 被“杀死”并替换为包含 $l_y$ 的新集合。\n$pp$ 的指向集不受此操作影响。\n$$ \\operatorname{Pts}_{3}(p) = \\{l_y\\} $$\n$$ \\operatorname{Pts}_{3}(pp) = \\operatorname{Pts}_{2}(pp) = \\{l_p\\} $$\n\n语句 4: $\\ast p := 3$\n这是另一个间接赋值，存储整数值 $3$。为了确定内存目标，我们检查 $p$ 的指向集。\n从上一步可知，$\\operatorname{Pts}_{3}(p) = \\{l_y\\}$。\n这也是一个单例集。$p$ 指向的唯一位置是 $l_y$，即对应于标量整型变量 $y$ 的抽象位置。\n因此，该语句将值 $3$ 写入 $y$ 的内存位置。\n这个操作修改的是一个标量变量（$y$）的值，而不是一个指针。因此，$p$ 和 $pp$ 的指向集保持不变。\n\n最后一条语句执行后的状态是：\n$$ \\operatorname{Pts}_{\\text{final}}(p) = \\operatorname{Pts}_{3}(p) = \\{l_y\\} $$\n$$ \\operatorname{Pts}_{\\text{final}}(pp) = \\operatorname{Pts}_{3}(pp) = \\{l_p\\} $$\n\n现在我们可以回答提出的具体问题了。\n\n1. 最后一条语句 $\\ast p := 3$ 写入的最终内存目标：\n如上推导，指针 $p$ 仅指向位置 $l_y$。因此，存储操作 $\\ast p := 3$ 写入位置 $l_y$，该位置对应于标量变量 $y$。\n\n2. 最终的指向集 $\\operatorname{Pts}(p)$ 和 $\\operatorname{Pts}(pp)$：\n最终的指向集为：\n$$ \\operatorname{Pts}(p) = \\{l_y\\} $$\n$$ \\operatorname{Pts}(pp) = \\{l_p\\} $$\n\n现在，我们必须计算 $R$ 的值。公式如下：\n$$ R = |\\operatorname{Pts}(p)| + 2\\,|\\operatorname{Pts}(pp)| + v $$\n该公式的组成部分如下：\n- $|\\operatorname{Pts}(p)|$：$p$ 的最终指向集的基数。由于 $\\operatorname{Pts}(p) = \\{l_y\\}$，其基数为 $1$。\n$$ |\\operatorname{Pts}(p)| = 1 $$\n- $|\\operatorname{Pts}(pp)|$：$pp$ 的最终指向集的基数。由于 $\\operatorname{Pts}(pp) = \\{l_p\\}$，其基数为 $1$。\n$$ |\\operatorname{Pts}(pp)| = 1 $$\n- $v$：最后一次存储操作 $\\ast p := 3$ 写入的值。写入的值是 $3$。\n$$ v = 3 $$\n\n将这些值代入 $R$ 的表达式中：\n$$ R = 1 + 2 \\times 1 + 3 $$\n$$ R = 1 + 2 + 3 $$\n$$ R = 6 $$", "answer": "$$\\boxed{6}$$", "id": "3663003"}, {"introduction": "真实世界的代码充满了分支和条件语句。这个练习将探讨保守的静态分析如何处理未知的控制流路径，即路径不敏感性（path-insensitivity）。你将看到这如何导致“可别名”（may-alias）集合和“弱更新”（weak updates），并理解其对其他编译器优化（如常量传播）的深远影响。[@problem_id:3662967]", "problem": "给定以下C代码片段，该片段在单个过程中执行，没有函数调用，也没有未定义的行为：\n```c\nint x = 1;\nint y = 2;\nint *p = x;\nint *q = p ? y : x;\n*q = 5;\n```\n\n假设采用标准的保守指针分析，该分析是流不敏感和上下文不敏感的，并使用“可能指向”（may-points-to）的解释。该分析不使用常量推理来评估条件表达式；它将条件的两个结果都视为可能执行的。设指针变量 $v$ 的“可能指向”集合用 $\\text{PT}(v)$ 表示，其基数用 $|\\text{PT}(v)|$ 表示。对于常量传播，请使用稀疏条件常量传播（SCCP），其值格为 $\\mathcal{L} = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$，其中 $\\bot$ 表示不可达，$\\mathbb{Z}$ 中的每个整数表示一个已知常量，而 $\\top$ 表示一个未知的非常量值。当通过指针进行的存储可能与多个变量别名时，通过更新“可能指向”集合中的所有目标来对此效果建模；如果一次存储可能沿不同路径写入多个不同的值，则使用格上的并（join）运算来表示合并后的结果。\n\n从C条件运算符将其第一个操作数作为布尔值求值并选择两个指针表达式之一的基本语义出发，定义并计算：\n- 在指定的“可能指向”分析下，基数 $|\\text{PT}(q)|$。\n- 在指针分析和SCCP指定的交互作用下，代码片段末尾 $x$ 和 $y$ 的SCCP格值，分别表示为 $V_{x}$ 和 $V_{y}$。\n\n将您的最终答案表示为单行矩阵 $\\begin{pmatrix} |\\text{PT}(q)|  V_{x}  V_{y} \\end{pmatrix}$。无需四舍五入，也不涉及物理单位。根据需要使用格定义中的符号 $\\top$ 和 $\\bot$，并对已知常量值使用整数。", "solution": "该问题要求使用指定的指针分析和常量传播模型来分析一段C代码片段。我们必须确定指针 `q` 的“可能指向”集合的基数，表示为 $|\\text{PT}(q)|$，以及在稀疏条件常量传播（SCCP）下变量 `x` 和 `y` 的最终格值，分别表示为 $V_x$ 和 $V_y$。\n\n首先，我们按照规定执行“可能指向”分析。该分析是流不敏感、上下文不敏感的，并且必须将条件运算符的两个结果都视为可能执行。流不敏感分析会为整个过程计算一个单一的指向映射，聚合所有赋值语句的效果，而不考虑控制流。\n\n与指针分析相关的语句是：\n1.  `int *p = x;`\n2.  `int *q = p ? y : x;`\n\n从语句1可知，指针 `p` 被赋予 `x` 的地址。这创建了一个指向关系，我们可以写成 `p → x`。用集合来表示，这意味着 $x \\in \\text{PT}(p)$。对于考虑整个过程的流不敏感分析，我们可以确定 $\\text{PT}(p) = \\{x\\}$。\n\n从语句2可知，指针 `q` 的值是基于一个条件表达式赋予的。问题明确指出，分析不使用常量推理来评估条件 `p`。相反，它必须假设真分支和假分支都是可执行的。\n-   如果条件为真，赋值将是 `q = y`，导致关系 `q → y`。\n-   如果条件为假，赋值将是 `q = x`，导致关系 `q → x`。\n\n一个保守的、流不敏感的“可能指向”分析会从所有可能的赋值中收集所有可能的目标。因此，`q` 的“可能指向”集合是两个分支目标的并集：$\\text{PT}(q) = \\{x\\} \\cup \\{y\\} = \\{x, y\\}$。\n\n这个集合的基数是它可能指向的不同变量的数量。\n$$|\\text{PT}(q)| = |\\{x, y\\}| = 2$$\n\n接下来，我们执行稀疏条件常量传播（SCCP）来确定 `x` 和 `y` 的最终值。SCCP分析使用值格 $\\mathcal{L} = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$。该分析通过在这个格上模拟程序的执行来进行，并使用预先计算的指针分析结果。\n\n设 $V_x$ 和 $V_y$ 分别为变量 `x` 和 `y` 的格值。我们跟踪它们在程序中的值变化：\n1.  `int x = 1;`\n    该语句用一个常量值初始化 `x`。`x` 的格值变为 $1$。\n    $V_x \\leftarrow 1$。\n\n2.  `int y = 2;`\n    类似地，该语句用常量值 $2$ 初始化 `y`。\n    $V_y \\leftarrow 2$。\n    此时，我们有 $V_x = 1$ 和 $V_y = 2$。\n\n3.  `int *p = x;`\n    该语句赋一个指针值，不修改整型变量 `x` 或 `y`。它们的格值保持不变。\n\n4.  `int *q = p ? y : x;`\n    该语句也赋一个指针值，不修改 `x` 或 `y`。它们的格值保持为 $V_x = 1$ 和 $V_y = 2$。\n\n5.  `*q = 5;`\n    这是一个通过指针 `q` 的存储操作。SCCP分析必须参考指针分析的结果来确定此存储操作的效果。我们已经确定 $\\text{PT}(q) = \\{x, y\\}$。这意味着该存储操作可能修改 `x` 或 `y`。\n\n    问题为此场景提供了规则：“当通过指针进行的存储可能与多个变量别名时，通过更新‘可能指向’集合中的所有目标来对此效果建模”。这被解释为对指向集合中每个变量的“弱更新”（weak update）。对变量 `v` 进行的值为 `C` 的存储的弱更新意味着其新的格值成为其旧值与 `C` 的并。并运算，用 `sqcup` 表示，在该格上的定义如下：\n    -   $a \\sqcup b = b \\sqcup a$ （交换律）\n    -   对于任意常量 $C \\in \\mathbb{Z}$，$C \\sqcup C = C$。\n    -   对于任意不同的常量 $C_1, C_2 \\in \\mathbb{Z}$，$C_1 \\sqcup C_2 = \\top$。\n    -   对于任意值 $v \\in \\mathcal{L}$，$v \\sqcup \\top = \\top$。\n    -   对于任意值 $v \\in \\mathcal{L}$，$v \\sqcup \\bot = v$。\n\n    我们将此更新规则应用于 `x` 和 `y`。\n    -   对于 `x`：当前值为 $V_x = 1$。新值为 $V_x^{\\text{new}} = V_x \\sqcup 5 = 1 \\sqcup 5$。由于 $1$ 和 $5$ 是不同的常量，它们的并是 $\\top$。\n      $$V_x \\leftarrow \\top$$\n    -   对于 `y`：当前值为 $V_y = 2$。新值为 $V_y^{\\text{new}} = V_y \\sqcup 5 = 2 \\sqcup 5$。由于 $2$ 和 $5$ 是不同的常量，它们的并也是 $\\top$。\n      $$V_y \\leftarrow \\top$$\n\n在这条最终语句之后，`x` 和 `y` 的格值都为 $\\top$，这表明分析无法再保证它们持有特定的常量值。\n\n总而言之，分析的结果是：\n-   $|\\text{PT}(q)| = 2$\n-   $V_x = \\top$\n-   $V_y = \\top$", "answer": "$$\\boxed{\\begin{pmatrix} 2  \\top  \\top \\end{pmatrix}}$$", "id": "3662967"}]}