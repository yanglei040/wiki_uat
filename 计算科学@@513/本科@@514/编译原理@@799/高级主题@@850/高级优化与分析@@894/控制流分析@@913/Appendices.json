{"hands_on_practices": [{"introduction": "将代码转换为静态单赋值（SSA）形式是许多强大编译器优化的基础步骤。此转换的关键在于精确地放置 $\\phi$-函数，这些函数在控制流的汇合点合并变量的不同版本。本练习 [@problem_id:3633415] 将指导你系统地运用支配边界来确定放置这些 $\\phi$-函数的最小且正确的位置。", "problem": "一个编译器必须将一个带有分支和循环的直线式程序转换为静态单赋值（SSA）形式，通过在会合点插入适当的 $\\phi$-函数。使用以下伪代码定义一个控制流图（CFG），然后执行控制流分析，通过迭代支配边界过程来确定最小的 $\\phi$-函数放置。\n\n带有标记基本块的程序：\n- $B_{0}$: 入口；$x := 0$; 转到 $B_{1}$。\n- $B_{1}$: 如果 $c_{1}$ 则转到 $B_{2}$ 否则转到 $B_{3}$。\n- $B_{2}$: $x := 1$; $y := a$; 转到 $B_{4}$。\n- $B_{3}$: $y := b$; 转到 $B_{4}$。\n- $B_{4}$: 循环头；如果 $c_{2}$ 则转到 $B_{5}$ 否则转到 $B_{6}$。\n- $B_{5}$: $x := x + 1$; 转到 $B_{7}$。\n- $B_{6}$: $y := y + 1$; 转到 $B_{7}$。\n- $B_{7}$: 如果 $c_{3}$ 则转到 $B_{4}$ 否则转到 $B_{8}$。\n- $B_{8}$: $z := x + y$; 转到 $B_{9}$。\n- $B_{9}$: 出口。\n\n控制流图（CFG）的边是： $B_{0} \\to B_{1}$; $B_{1} \\to B_{2}$; $B_{1} \\to B_{3}$; $B_{2} \\to B_{4}$; $B_{3} \\to B_{4}$; $B_{4} \\to B_{5}$; $B_{4} \\to B_{6}$; $B_{5} \\to B_{7}$; $B_{6} \\to B_{7}$; $B_{7} \\to B_{4}$; $B_{7} \\to B_{8}$; $B_{8} \\to B_{9}$。\n\n任务：\n1. 使用支配和支配边界的基本定义，计算CFG中每个基本块 $B_{i}$ 的支配边界 $\\mathrm{DF}(B_{i})$。\n2. 使用静态单赋值（SSA）的定义和迭代支配边界算法，确定仅针对变量 $x$ 和 $y$ 的最小 $\\phi$-函数放置。在迭代时将 $\\phi$-函数视为定义。\n3. 提供为变量 $x$ 和 $y$ 在所有块中插入的 $\\phi$-函数的总数。\n\n答案格式要求：\n- 你的最终答案必须是一个整数，等于插入的 $\\phi$-函数的总数。", "solution": "用户希望找出将给定程序转换为变量 $x$ 和 $y$ 的静态单赋值（SSA）形式所需的最小 $\\phi$-函数数量。这涉及到执行控制流分析，特别是计算支配点和支配边界。\n\n### 第 1 步：提取已知信息\n题目提供了以下信息：\n- **基本块**：一组 10 个基本块，标记为 $B_{0}$ 到 $B_{9}$。\n- **程序逻辑**：\n    - $B_{0}$: 入口；$x := 0$; 转到 $B_{1}$。\n    - $B_{1}$: 如果 $c_{1}$ 则转到 $B_{2}$ 否则转到 $B_{3}$。\n    - $B_{2}$: $x := 1$; $y := a$; 转到 $B_{4}$。\n    - $B_{3}$: $y := b$; 转到 $B_{4}$。\n    - $B_{4}$: 循环头；如果 $c_{2}$ 则转到 $B_{5}$ 否则转到 $B_{6}$。\n    - $B_{5}$: $x := x + 1$; 转到 $B_{7}$。\n    - $B_{6}$: $y := y + 1$; 转到 $B_{7}$。\n    - $B_{7}$: 如果 $c_{3}$ 则转到 $B_{4}$ 否则转到 $B_{8}$。\n    - $B_{8}$: $z := x + y$; 转到 $B_{9}$。\n    - $B_{9}$: 出口。\n- **控制流图（CFG）的边**：\n$B_{0} \\to B_{1}$, $B_{1} \\to B_{2}$, $B_{1} \\to B_{3}$, $B_{2} \\to B_{4}$, $B_{3} \\to B_{4}$, $B_{4} \\to B_{5}$, $B_{4} \\to B_{6}$, $B_{5} \\to B_{7}$, $B_{6} \\to B_{7}$, $B_{7} \\to B_{4}$, $B_{7} \\to B_{8}$, $B_{8} \\to B_{9}$。\n- **任务**：\n    1. 计算每个基本块 $B_{i}$ 的支配边界 $\\mathrm{DF}(B_{i})$。\n    2. 确定变量 $x$ 和 $y$ 的最小 $\\phi$-函数放置。\n    3. 提供为 $x$ 和 $y$ 插入的 $\\phi$-函数的总数。\n\n### 第 2 步：使用提取的已知信息进行验证\n- **科学依据**：该问题基于编译器理论中的标准概念，即控制流图、支配点、支配边界和静态单赋值（SSA）形式。这些都是计算机科学中已确立的基础课题。\n- **良构性**：CFG被明确定义，并且使用迭代支配边界计算最小SSA形式的算法是确定性的。这确保了存在唯一且有意义的解。\n- **客观性**：该问题使用编译器理论的形式化方法陈述，不包含主观或模糊的语言。\n- **完整性和一致性**：所有必要的信息（基本块、CFG边、变量赋值）都已提供。块逻辑的描述与指定的CFG边一致。\n- **结论**：该问题是有效的。这是应用编译器优化算法的一个标准练习。\n\n### 第 3 步：判定与行动\n该问题是有效的。我将继续提供完整解答。\n\n### 解答\n\n解答按要求分为三个主要部分：计算支配边界、确定 $\\phi$-函数的放置，以及计算 $\\phi$-函数的总数。\n\n#### 第 1 部分：支配和支配边界\n\n为了计算支配边界，我们必须首先计算CFG中每个基本块的支配点集合。如果从入口块（$B_{0}$）到块 $N$ 的每条路径都必须经过块 $D$，则块 $D$ 支配块 $N$。支配关系可以使用标准的迭代数据流分析算法计算。\n\n**支配点集合：**\n迭代算法收敛到以下支配点集合 $\\mathrm{DOM}(B_{i})$：\n- $\\mathrm{DOM}(B_{0}) = \\{B_{0}\\}$\n- $\\mathrm{DOM}(B_{1}) = \\{B_{0}, B_{1}\\}$\n- $\\mathrm{DOM}(B_{2}) = \\{B_{0}, B_{1}, B_{2}\\}$\n- $\\mathrm{DOM}(B_{3}) = \\{B_{0}, B_{1}, B_{3}\\}$\n- $\\mathrm{DOM}(B_{4}) = \\{B_{0}, B_{1}, B_{4}\\}$ (注意：$B_{4}$ 是一个循环头，它的直接支配点是 $B_1$)\n- $\\mathrm{DOM}(B_{5}) = \\{B_{0}, B_{1}, B_{4}, B_{5}\\}$\n- $\\mathrm{DOM}(B_{6}) = \\{B_{0}, B_{1}, B_{4}, B_{6}\\}$\n- $\\mathrm{DOM}(B_{7}) = \\{B_{0}, B_{1}, B_{4}, B_{7}\\}$\n- $\\mathrm{DOM}(B_{8}) = \\{B_{0}, B_{1}, B_{4}, B_{7}, B_{8}\\}$\n- $\\mathrm{DOM}(B_{9}) = \\{B_{0}, B_{1}, B_{4}, B_{7}, B_{8}, B_{9}\\}$\n\n**支配边界 ($\\mathrm{DF}$):**\n一个节点 $N$ 的支配边界，记作 $\\mathrm{DF}(N)$，是所有节点 $Y$ 的集合，使得 $N$ 支配 $Y$ 的一个直接前驱，但 $N$ 并不严格支配 $Y$。如果一个节点 $N$ 支配 $Y$ 且 $N \\neq Y$，则称 $N$ 严格支配 $Y$。我们用 $N \\text{ sdom } Y$ 表示严格支配。\n定义为：$\\mathrm{DF}(N) = \\{ Y \\mid \\exists P \\in \\mathrm{pred}(Y) \\text{ such that } N \\in \\mathrm{DOM}(P) \\text{ and } N \\notin \\mathrm{sdom}(Y) \\}$。\n\n将此定义应用于每个块 $B_{i}$：\n- $\\mathrm{DF}(B_{0}) = \\emptyset$：入口节点有一个空的支配边界。\n- $\\mathrm{DF}(B_{1}) = \\emptyset$：虽然 $B_{1}$ 是一个分支点，但它所支配的任何节点（除了它自己），它也都严格支配。\n- $\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$：对于边 $B_{2} \\to B_{4}$，$B_{2}$ 支配其自身（前驱 $P=B_2$），但 $B_2$ 并不严格支配 $B_4$。因此，$B_{4} \\in \\mathrm{DF}(B_{2})$。\n- $\\mathrm{DF}(B_{3}) = \\{B_{4}\\}$：类似地，对于边 $B_{3} \\to B_{4}$，$B_{3}$ 支配 $B_{3}$ 但不严格支配 $B_{4}$。\n- $\\mathrm{DF}(B_{4}) = \\{B_{4}\\}$：对于回环边 $B_{7} \\to B_{4}$，$B_{4}$ 支配前驱 $B_{7}$。但是，$B_{4}$ 不严格支配其自身。因此，$B_{4} \\in \\mathrm{DF}(B_{4})$。\n- $\\mathrm{DF}(B_{5}) = \\{B_{7}\\}$：对于边 $B_{5} \\to B_{7}$，$B_{5}$ 支配 $B_{5}$ 但不严格支配 $B_{7}$。\n- $\\mathrm{DF}(B_{6}) = \\{B_{7}\\}$：类似地，对于边 $B_{6} \\to B_{7}$，$B_{6}$ 支配 $B_{6}$ 但不严格支配 $B_{7}$。\n- $\\mathrm{DF}(B_{7}) = \\{B_{4}\\}$：对于回环边 $B_{7} \\to B_{4}$，$B_{7}$ 支配其前驱 $B_{7}$，但不严格支配 $B_{4}$。\n- $\\mathrm{DF}(B_{8}) = \\emptyset$：$B_{8}$ 严格支配其唯一的后继 $B_{9}$。\n- $\\mathrm{DF}(B_{9}) = \\emptyset$：出口节点没有后继。\n\n#### 第 2 部分：最小 $\\phi$-函数放置\n\n我们使用迭代支配边界算法来找到需要为变量 $x$ 和 $y$ 设置 $\\phi$-函数的最小节点集。如果节点 $N$ 位于任何包含变量 $V$ 定义的块的支配边界中，则节点 $N$ 需要一个变量 $V$ 的 $\\phi$-函数。这个过程是迭代的，因为 $\\phi$-函数本身也是一个定义。\n\n令 $A_{V}$ 为包含变量 $V$ 原始定义的块的集合。\n需要变量 $V$ 的 $\\phi$-函数的节点集合 $\\Phi(V)$ 是以下序列的极限：\n$\\Phi_{0}(V) = \\emptyset$\n$\\Phi_{i+1}(V) = \\mathrm{DF}(A_{V} \\cup \\Phi_{i}(V))$\n\n**变量 $x$:**\n包含 $x$ 原始定义的块的集合是 $A_{x} = \\{B_{0}, B_{2}, B_{5}\\}$。\n我们初始化一个工作列表 $W = A_{x} = \\{B_{0}, B_{2}, B_{5}\\}$ 和一个包含 $\\phi$-函数的块的集合 $P_{x} = \\emptyset$。\n- **迭代 1**：\n    - 处理 $B_{0} \\in W$。$\\mathrm{DF}(B_{0}) = \\emptyset$。\n    - 处理 $B_{2} \\in W$。$\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$。由于 $B_{4} \\notin P_{x}$，我们在 $B_{4}$ 为 $x$ 添加一个 $\\phi$-函数。更新 $P_{x} = \\{B_{4}\\}$ 并将 $B_{4}$ 添加到工作列表 $W$ 中。\n    - 处理 $B_{5} \\in W$。$\\mathrm{DF}(B_{5}) = \\{B_{7}\\}$。由于 $B_{7} \\notin P_{x}$，我们在 $B_{7}$ 为 $x$ 添加一个 $\\phi$-函数。更新 $P_{x} = \\{B_{4}, B_{7}\\}$ 并将 $B_{7}$ 添加到 $W$ 中。\n- **迭代 2**：工作列表现在包含 $\\{B_{4}, B_{7}\\}$。\n    - 处理 $B_{4} \\in W$。$\\mathrm{DF}(B_{4}) = \\{B_{4}\\}$。$B_{4}$ 已经在 $P_{x}$ 中，所以没有变化。\n    - 处理 $B_{7} \\in W$。$\\mathrm{DF}(B_{7}) = \\{B_{4}\\}$。$B_{4}$ 已经在 $P_{x}$ 中，所以没有变化。\n工作列表现在为空。算法终止。\n需要为 $x$ 设置 $\\phi$-函数的最小块集合是 $\\{B_{4}, B_{7}\\}$。\n\n**变量 $y$:**\n包含 $y$ 原始定义的块的集合是 $A_{y} = \\{B_{2}, B_{3}, B_{6}\\}$。\n初始化工作列表 $W = A_{y} = \\{B_{2}, B_{3}, B_{6}\\}$ 和 $P_{y} = \\emptyset$。\n- **迭代 1**：\n    - 处理 $B_{2} \\in W$。$\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$。由于 $B_{4} \\notin P_{y}$，在 $B_{4}$ 为 $y$ 添加一个 $\\phi$-函数。更新 $P_{y} = \\{B_{4}\\}$ 并将 $B_{4}$ 添加到 $W$ 中。\n    - 处理 $B_{3} \\in W$。$\\mathrm{DF}(B_{3}) = \\{B_{4}\\}$。$B_{4}$ 已经在 $P_{y}$ 中，所以没有变化。\n    - 处理 $B_{6} \\in W$。$\\mathrm{DF}(B_{6}) = \\{B_{7}\\}$。由于 $B_{7} \\notin P_{y}$，在 $B_{7}$ 为 $y$ 添加一个 $\\phi$-函数。更新 $P_{y} = \\{B_{4}, B_{7}\\}$ 并将 $B_{7}$ 添加到 $W$ 中。\n- **迭代 2**：工作列表现在包含 $\\{B_{4}, B_{7}\\}$。\n    - 处理 $B_{4} \\in W$。$\\mathrm{DF}(B_{4}) = \\{B_{4}\\}$。$B_{4}$ 已经在 $P_{y}$ 中，所以没有变化。\n    - 处理 $B_{7} \\in W$。$\\mathrm{DF}(B_{7}) = \\{B_{4}\\}$。$B_{4}$ 已经在 $P_{y}$ 中，所以没有变化。\n工作列表现在为空。算法终止。\n需要为 $y$ 设置 $\\phi$-函数的最小块集合是 $\\{B_{4}, B_{7}\\}$。\n\n#### 第 3 部分：$\\phi$-函数的总数\n\n基于第 2 部分的分析：\n- 变量 $x$ 的 $\\phi$-函数数量：$2$ 个（一个在 $B_{4}$ 中，一个在 $B_{7}$ 中）。\n- 变量 $y$ 的 $\\phi$-函数数量：$2$ 个（一个在 $B_{4}$ 中，一个在 $B_{7}$ 中）。\n\n为变量 $x$ 和 $y$ 插入的 $\\phi$-函数的总数是这些计数的总和。\n总数 = $2 + 2 = 4$。", "answer": "$$\\boxed{4}$$", "id": "3633415"}, {"introduction": "尽管许多优化算法在结构化循环上表现良好，但真实世界的代码可能包含复杂的控制流，例如使用 `goto` 语句跳转到循环中间，从而形成所谓的不可约图。本练习 [@problem_id:3633353] 将展示这样一个场景，要求你首先识别其不可约性，然后应用一种标准的编译器转换技术——节点分裂——来恢复图的可约结构，从而使其能够进行后续分析。", "problem": "考虑一个简单程序的以下控制流图（CFG），其基本块由节点表示，控制转移由有向边表示。入口块标记为 $1$。节点集为 $V=\\{1,2,3,4,5\\}$，边集为 \n$$E=\\{(1,2),(1,4),(2,3),(3,2),(3,5),(4,3)\\}$$。\n假设所有块都代表基本块，除了指定的边之外，没有与控制流分析相关的副作用。边 $(i,j)$ 表示可能从块 $i$ 到块 $j$ 的控制转移。\n\n从支配节点（如果从入口节点到 $n$ 的每条路径都包含 $d$，则 $d$ 支配 $n$）、回边（一条边 $(t,h)$，其中 $h$ 支配 $t$）、自然循环（对于一条回边 $(t,h)$，包含 $h$ 和所有不经过 $h$ 就能到达 $t$ 的节点的最小集合），以及可约性（每个循环都有一个唯一的、支配循环体的头节点）的核心定义出发，完全根据这些定义完成以下任务，不要引用任何未证明的定理。\n\n首先，通过识别一个强连通分量来证明给定的CFG是不可约的，该分量的节点不共享一个作为唯一入口的单一支配节点，并说明该分量中不存在由回边引发的自然循环。\n\n接下来，通过一次节点分裂步骤将该CFG转换为可约图，该步骤消除了一个进入循环体的非支配入口：沿来自节点 $4$ 的入边分裂节点 $3$，引入一个标记为 $6$ 的新节点，将边 $(4,3)$ 替换为 $(4,6)$，并将节点 $3$ 的出边复制给节点 $6$。转换后的节点集和边集因此为\n$$V'=\\{1,2,3,4,5,6\\},\\quad E'=\\{(1,2),(1,4),(2,3),(3,2),(3,5),(4,6),(6,2),(6,5)\\}$$。\n\n然后，根据第一性原理计算转换后CFG中所有节点的支配节点集，识别所有回边，并确定转换后CFG中存在的所有自然循环头节点。令 $S$ 表示转换后CFG中所有不同自然循环头节点的数字标签之和。\n\n计算 $S$。你的最终答案应以单个整数形式提供。无需四舍五入。", "solution": "该问题陈述具有科学依据，表述清晰，客观且完整。它提出了一系列来自编译器理论中关于控制流分析的标准任务。定义、图结构和所需的转换都得到了严格的规定。因此，该问题是有效的，可以构建一个完整的解决方案。\n\n按照指示，解决方案分为两个主要部分：首先，分析原始控制流图（CFG）以证明其不可约性；其次，分析转换后的CFG以计算所需的总和 $S$。\n\n### 第一部分：初始CFG分析\n\n初始CFG由节点集 $V=\\{1,2,3,4,5\\}$，边集 $E=\\{(1,2),(1,4),(2,3),(3,2),(3,5),(4,3)\\}$ 和入口节点 $1$ 定义。\n\n为了分析图的结构，我们首先计算每个节点的支配节点集。一个节点 $d$ 支配节点 $n$ 当且仅当从入口节点（$1$）到 $n$ 的每一条路径都包含 $d$。根据这个定义，每个节点都支配其自身。\n\n*   $\\text{dom}(1)$: 节点 $1$ 是入口节点。其支配节点集为 $\\text{dom}(1) = \\{1\\}$。\n*   $\\text{dom}(2)$: 节点 $2$ 的唯一前驱是节点 $1$。因此，从 $1$ 到 $2$ 的每条路径都形如 $(1, \\dots, 1, 2)$。唯一的简单路径是 $(1,2)$。因此，$\\text{dom}(2) = \\{1, 2\\}$。\n*   $\\text{dom}(4)$: 节点 $4$ 的唯一前驱是节点 $1$。唯一的简单路径是 $(1,4)$。因此，$\\text{dom}(4) = \\{1, 4\\}$。\n*   $\\text{dom}(3)$: 节点 $3$ 有两个前驱，$2$ 和 $4$。从 $1$ 到 $3$ 至少有两条不同的路径：$P_1 = (1, 2, 3)$ 和 $P_2 = (1, 4, 3)$。$P_1$ 上的节点集为 $\\{1, 2, 3\\}$。$P_2$ 上的节点集为 $\\{1, 4, 3\\}$。这些节点集的交集为 $\\{1, 3\\}$。任何其他到 $3$ 的路径，例如包含循环 $(2,3,2)$ 的路径，会增加节点但不会改变这个交集。因此，$\\text{dom}(3) = \\{1, 3\\}$。\n*   $\\text{dom}(5)$: 节点 $5$ 的唯一前驱是节点 $3$。因此，任何到 $5$ 的路径都必须是一条到 $3$ 的路径后跟边 $(3,5)$。这意味着任何支配 $3$ 的节点也必定支配 $5$。因此，$\\text{dom}(5) = \\text{dom}(3) \\cup \\{5\\} = \\{1, 3, 5\\}$。\n\n强连通分量（SCC）是一个最大子图，其中每个节点都可以从其他任何节点到达。在给定的CFG中，节点 $2$ 和 $3$ 形成一个SCC，因为存在从 $2$ 到 $3$ 的路径（边 $(2,3)$）和从 $3$ 到 $2$ 的路径（边 $(3,2)$）。这个SCC是 $\\{2, 3\\}$。\n\n一个不可约图包含一个具有多个从循环外部进入的入口点的循环，使得没有单一的入口节点能够支配循环内的所有其他节点。SCC $\\{2, 3\\}$ 代表了这样一个循环结构。我们识别其入口点：\n1.  节点 $2$ 是一个入口，因为存在入边 $(1,2)$，其中节点 $1$ 在SCC之外。\n2.  节点 $3$ 是一个入口，因为存在入边 $(4,3)$，其中节点 $4$ 在SCC之外。\n\n这个循环有两个入口节点，$2$ 和 $3$。要使图是可约的，其中一个必须作为唯一的头节点来支配整个循环。我们来检查入口节点和循环体 $\\{2,3\\}$ 之间的支配关系：\n*   $2$ 是否支配 $3$？否，因为 $\\text{dom}(3) = \\{1, 3\\}$，其中不包含 $2$。\n*   $3$ 是否支配 $2$？否，因为 $\\text{dom}(2) = \\{1, 2\\}$，其中不包含 $3$。\n\n由于由SCC $\\{2,3\\}$ 形成的循环没有单一的、起支配作用的入口节点，所以该CFG是不可约的。\n\n最后，我们必须说明不存在由回边引发的自然循环。回边是一条边 $(t,h)$，其中头节点 $h$ 支配尾节点 $t$。我们检查 $E$ 中的每一条边：\n*   $(1,2)$: $2 \\notin \\text{dom}(1)$。\n*   $(1,4)$: $4 \\notin \\text{dom}(1)$。\n*   $(2,3)$: $3 \\notin \\text{dom}(2)$。\n*   $(3,2)$: $2 \\notin \\text{dom}(3)$，因为 $\\text{dom}(3) = \\{1, 3\\}$。\n*   $(3,5)$: $5 \\notin \\text{dom}(3)$。\n*   $(4,3)$: $3 \\notin \\text{dom}(4)$。\n\n在 $E$ 中没有满足条件 $h \\in \\text{dom}(t)$ 的边 $(t,h)$。因此，原始CFG没有回边。由于根据所给定义，自然循环是由回边引发的，所以该CFG不包含自然循环。\n\n### 第二部分：转换后CFG分析\n\n节点分裂转换产生了一个新的CFG，其节点为 $V'=\\{1,2,3,4,5,6\\}$，边为 $E'=\\{(1,2),(1,4),(2,3),(3,2),(3,5),(4,6),(6,2),(6,5)\\}$。入口节点仍然是 $1$。通过将边 $(4,3)$ 重定向到一个新节点 $6$（该节点作为 $3$ 在该特定入口路径上的一个副本），解决了进入 $\\{2,3\\}$ 循环的多入口结构问题。\n\n我们为这个转换后的图重新计算支配节点集：\n*   $\\text{dom}(1) = \\{1\\}$。\n*   $\\text{dom}(4)$: 唯一的路径是 $(1,4)$，所以 $\\text{dom}(4) = \\{1, 4\\}$。\n*   $\\text{dom}(6)$: 唯一的路径是 $(1,4,6)$，所以 $\\text{dom}(6) = \\text{dom}(4) \\cup \\{6\\} = \\{1, 4, 6\\}$。\n*   $\\text{dom}(2)$: 节点 $2$ 的前驱是 $1$, $3$ 和 $6$。从入口出发有两条简单路径：$P_1 = (1,2)$ 和 $P_2 = (1,4,6,2)$。$P_1$ 上的节点是 $\\{1,2\\}$，$P_2$ 上的节点是 $\\{1,4,6,2\\}$。它们的交集是 $\\{1,2\\}$。任何涉及循环 $(2,3,2)$ 的路径必须首先到达 $2$，因此交集仍然是 $\\{1,2\\}$。因此，$\\text{dom(2)} = \\{1, 2\\}$。\n*   $\\text{dom}(3)$: 节点 $3$ 的唯一前驱是节点 $2$。因此，$\\text{dom}(3) = \\text{dom}(2) \\cup \\{3\\} = \\{1, 2, 3\\}$。\n*   $\\text{dom}(5)$: 节点 $5$ 的前驱是 $3$ 和 $6$。路径可以经由节点 $3$ 到达（例如 $P_3 = (1,2,3,5)$），也可以经由节点 $6$ 到达（例如 $P_4 = (1,4,6,5)$）。$P_3$ 上的节点是 $\\{1,2,3,5\\}$，$P_4$ 上的节点是 $\\{1,4,6,5\\}$。这些节点集的交集是 $\\{1,5\\}$。所以，$\\text{dom}(5) = \\{1, 5\\}$。\n\n接下来，我们使用新的支配节点集在转换后的图中识别回边。我们检查 $E'$ 中的每条边 $(t,h)$，看是否满足 $h \\in \\text{dom}(t)$：\n*   $(1,2)$: $2 \\notin \\text{dom}(1)$。\n*   $(1,4)$: $4 \\notin \\text{dom}(1)$。\n*   $(2,3)$: $3 \\notin \\text{dom}(2)$。\n*   $(3,2)$: 这里，$t=3$ 且 $h=2$。我们检查是否有 $2 \\in \\text{dom}(3)$。因为 $\\text{dom}(3)=\\{1,2,3\\}$，该条件满足。因此，$(3,2)$ 是一条回边。\n*   $(3,5)$: $5 \\notin \\text{dom}(3)$。\n*   $(4,6)$: $6 \\notin \\text{dom}(4)$。\n*   $(6,2)$: $2 \\notin \\text{dom}(6)$。\n*   $(6,5)$: $5 \\notin \\text{dom}(6)$。\n\n转换后的CFG中恰好有一条回边：$(3,2)$。\n\n自然循环由回边定义。自然循环的头节点是回边的头。对于回边 $(3,2)$，头节点是 $2$。由于只有一条回边，因此只有一个自然循环，从而也只有一个自然循环头节点。不同的自然循环头节点的集合是 $\\{2\\}$。\n\n问题要求计算 $S$，即所有不同自然循环头节点的数字标签之和。由于只有一个这样的头节点，即节点 $2$，所以总和就是其标签值。\n$$S = 2$$", "answer": "$$\\boxed{2}$$", "id": "3633353"}, {"introduction": "SSA 理论为*在何处*放置 $\\phi$-函数提供了明确的规则，但在实现它们*如何*接收参数的实践中，会暴露出更细微的挑战。本练习 [@problem_id:3633367] 聚焦于“关键边”问题——即连接多出口基本块与多入口基本块的边——它为放置必要的数据移动指令带来了歧义。你将分析为何这些边会引发问题，并了解边分裂技术如何为此提供一个清晰有效的解决方案。", "problem": "控制流图 (CFG) 是一个有向图 $G=(V,E)$，其顶点 $V$ 是基本块，边 $E$ 表示可能的控制转移；它有一个唯一的入口块 $b_{\\text{entry}} \\in V$。如果从 $b_{\\text{entry}}$ 到节点 $n \\in V$ 的每一条路径都包含节点 $d \\in V$，那么节点 $d$ 支配节点 $n$。如果 $u$ 有多个后继，$v$ 有多个前驱，则边 $\\langle u,v \\rangle \\in E$ 被称为关键边。边分裂通过插入一个新的块 $w$ 来替换边 $\\langle u,v \\rangle$，使得 $\\langle u,v \\rangle$ 被移除，同时添加 $\\langle u,w \\rangle$ 和 $\\langle w,v \\rangle$。静态单赋值 (SSA) 形式在合并点使用 $\\phi$ 函数 ($\\phi$)；在块 $h$ 处的 $\\phi$ 函数会根据控制流到达 $h$ 时所经过的前驱来选择其参数之一。\n\n考虑一个程序 $\\mathcal{P}$，它有基本块 $b_s, b_h, b_t, b_f, b_l, b_m, b_e$ 和如下的边：\n- $b_s \\to b_h$\n- $b_h \\to b_t$ 和 $b_h \\to b_f$\n- $b_t \\to b_l$\n- $b_f \\to b_l$\n- $b_l \\to b_h$ 和 $b_l \\to b_m$\n- $b_m \\to b_e$\n\n假设块中有以下语句（采用三地址风格），其中 $p$ 和 $q$ 是布尔变量，$x$ 是一个整数：\n- 在 $b_s$ 中： $x := 0$\n- 在 $b_h$ 中： if $p$ then goto $b_t$ else goto $b_f$\n- 在 $b_t$ 中： $x := x + 1$; goto $b_l$\n- 在 $b_f$ 中： goto $b_l$\n- 在 $b_l$ 中： if $q$ then goto $b_h$ else goto $b_m$\n- 在 $b_m$ 中： use$(x)$; goto $b_e$\n\n当将 $\\mathcal{P}$ 转换为静态单赋值 (SSA) 形式时，一个 $\\phi$ 函数 $\\phi(x_{\\text{pre}}, x_{\\text{back}})$ 被放置在 $b_h$ 中，以合并来自入边 $b_s \\to b_h$（“前置首部”贡献 $x_{\\text{pre}}$）和 $b_l \\to b_h$（“回边”贡献 $x_{\\text{back}}$）的 $x$ 的值。一些 SSA 构造方法使用边局部的“参数移动”来实现 $\\phi$ 函数，即对于每个进入 $\\phi$ 块 $h$ 的入边 $\\langle u,h \\rangle$，它们将输入值的副本插入到一个特定于该边的临时变量中，该操作必须且仅当控制流沿着 $\\langle u,h \\rangle$ 流动时才执行。\n\n选择所有正确的选项：\n\nA. 边 $b_l \\to b_h$ 是关键边；通过插入一个新的块 $b_{lh}$ 来分裂它，用 $b_l \\to b_{lh}$ 和 $b_{lh} \\to b_h$ 替换 $b_l \\to b_h$，会产生两条非关键边，并创建一个当且仅当控制流从 $b_l$ 流向 $b_h$ 时才执行的唯一程序点，同时保持原始节点间的支配关系不变。\n\nB. 对于在 $b_h$ 处的 $\\phi$ 函数放置，如果我们不分裂 $b_l \\to b_h$，将回边参数移动操作放在 $b_l$ 内部是语义上安全的，因为 $b_l$ 中的条件语句确保了该移动操作仅在 $q$ 为真时执行。\n\nC. 如果我们不分裂 $b_l \\to b_h$ 并且将回边参数移动操作放在 $b_l$ 内部，那么存在一个 $p$ 为假且 $q$ 为假的执行路径，在该路径中，移动操作会沿着 $b_l \\to b_m$ 执行，并干扰在 $b_m$ 中 $use(x)$ 处看到的 $x$ 的版本，从而违反了 $\\phi$ 参数的路径敏感语义。这展示了一个反例：边局部的移动操作必须被放置在一条非关键边上，以确保它只在相应的边被采用时执行。\n\nD. 分裂边 $b_t \\to b_l$ 和 $b_f \\to b_l$ 是消除与 $\\mathcal{P}$ 中 $b_h$ 处的 $\\phi$ 函数放置相关的所有关键边的充分必要条件。\n\n通过选择所有正确的选项来回答。从第一性原理出发证明你的选择：使用关键边、边分裂、支配的定义，以及依赖于控制流实际到达前驱的 $\\phi$ 选择语义。", "solution": "该问题陈述已经过验证，被认为是合理、定义明确且基于编译器理论的既定原则。我们可以进行分析。\n\n首先，我们分析所提供的控制流图（CFG）的结构。顶点集为 $V = \\{b_s, b_h, b_t, b_f, b_l, b_m, b_e\\}$。边集为 $E = \\{\\langle b_s, b_h \\rangle, \\langle b_h, b_t \\rangle, \\langle b_h, b_f \\rangle, \\langle b_t, b_l \\rangle, \\langle b_f, b_l \\rangle, \\langle b_l, b_h \\rangle, \\langle b_l, b_m \\rangle, \\langle b_m, b_e \\rangle\\}$。入口块是 $b_{\\text{entry}} = b_s$。\n\n为了识别关键边，我们必须确定每个块的后继和前驱数量。\n令 $\\text{succ}(u)$ 为块 $u$ 的后继集合，$\\text{pred}(v)$ 为块 $v$ 的前驱集合。\n- $\\text{succ}(b_s) = \\{b_h\\}$，所以 $|\\text{succ}(b_s)| = 1$。\n- $\\text{succ}(b_h) = \\{b_t, b_f\\}$，所以 $|\\text{succ}(b_h)| = 2$。\n- $\\text{succ}(b_t) = \\{b_l\\}$，所以 $|\\text{succ}(b_t)| = 1$。\n- $\\text{succ}(b_f) = \\{b_l\\}$，所以 $|\\text{succ}(b_f)| = 1$。\n- $\\text{succ}(b_l) = \\{b_h, b_m\\}$，所以 $|\\text{succ}(b_l)| = 2$。\n- $\\text{succ}(b_m) = \\{b_e\\}$，所以 $|\\text{succ}(b_m)| = 1$。\n- $\\text{succ}(b_e) = \\emptyset$，所以 $|\\text{succ}(b_e)| = 0$。\n\n- $\\text{pred}(b_s) = \\emptyset$，所以 $|\\text{pred}(b_s)| = 0$。\n- $\\text{pred}(b_h) = \\{b_s, b_l\\}$，所以 $|\\text{pred}(b_h)| = 2$。\n- $\\text{pred}(b_t) = \\{b_h\\}$，所以 $|\\text{pred}(b_t)| = 1$。\n- $\\text{pred}(b_f) = \\{b_h\\}$，所以 $|\\text{pred}(b_f)| = 1$。\n- $\\text{pred}(b_l) = \\{b_t, b_f\\}$，所以 $|\\text{pred}(b_l)| = 2$。\n- $\\text{pred}(b_m) = \\{b_l\\}$，所以 $|\\text{pred}(b_m)| = 1$。\n- $\\text{pred}(b_e) = \\{b_m\\}$，所以 $|\\text{pred}(b_e)| = 1$。\n\n一条边 $\\langle u,v \\rangle$ 被定义为关键边，如果 $|\\text{succ}(u)|  1$ 且 $|\\text{pred}(v)|  1$。\n让我们检查从有多个后继的块（$b_h, b_l$）发出的边：\n- $\\langle b_h, b_t \\rangle$：$|\\text{succ}(b_h)|=2$，但 $|\\text{pred}(b_t)|=1$。不是关键边。\n- $\\langle b_h, b_f \\rangle$：$|\\text{succ}(b_h)|=2$，但 $|\\text{pred}(b_f)|=1$。不是关键边。\n- $\\langle b_l, b_h \\rangle$：$|\\text{succ}(b_l)|=2$ 且 $|\\text{pred}(b_h)|=2$。这条边是 **关键边**。\n- $\\langle b_l, b_m \\rangle$：$|\\text{succ}(b_l)|=2$，但 $|\\text{pred}(b_m)|=1$。不是关键边。\n\nCFG中唯一的关键边是 $\\langle b_l, b_h \\rangle$。\n\n在边 $\\langle u,v \\rangle$ 上为 $\\phi$ 函数放置参数移动（例如 `t := x`）的问题在于，这个移动必须*仅*在控制流遍历这条特定边时执行。\n- 如果放置在块 $u$ 的末尾，它将对所有离开 $u$ 的路径执行。如果 $|\\text{succ}(u)|1$，这对于不通向 $v$ 的路径是不正确的。这被称为“丢失副本”问题。\n- 如果放置在块 $v$ 的开头，它将对所有进入 $v$ 的路径执行。如果 $|\\text{pred}(v)|1$，这对于不来自 $u$ 的路径是不正确的。这被称为“错误副本”或“不安全副本”问题。\n关键边同时表现出这两种情况，使得将移动操作放置在 $u$ 或 $v$ 中都变得不可能。标准的解决方案是边分裂。\n\n现在我们评估每个选项。\n\n**A. 边 $b_l \\to b_h$ 是关键边；通过插入一个新的块 $b_{lh}$ 来分裂它，用 $b_l \\to b_{lh}$ 和 $b_{lh} \\to b_h$ 替换 $b_l \\to b_h$，会产生两条非关键边，并创建一个当且仅当控制流从 $b_l$ 流向 $b_h$ 时才执行的唯一程序点，同时保持原始节点间的支配关系不变。**\n\n1.  **关键性**：如上所述，$|\\text{succ}(b_l)| = 2$ 且 $|\\text{pred}(b_h)| = 2$，因此边 $\\langle b_l, b_h \\rangle$ 确实是关键边。这部分是正确的。\n2.  **边分裂**：我们用一个新块 $b_{lh}$ 和两条新边 $\\langle b_l, b_{lh} \\rangle$、$\\langle b_{lh}, b_h \\rangle$ 来替换 $\\langle b_l, b_h \\rangle$。\n    - 对于新边 $\\langle b_l, b_{lh} \\rangle$：$|\\text{succ}(b_l)|$ 仍然是 2（现在指向 $b_{lh}$ 和 $b_m$）。然而，$b_{lh}$ 只有一个前驱 $b_l$，所以 $|\\text{pred}(b_{lh})| = 1$。这条边不是关键边。\n    - 对于新边 $\\langle b_{lh}, b_h \\rangle$：$b_{lh}$ 只有一个后继 $b_h$，所以 $|\\text{succ}(b_{lh})| = 1$。尽管 $|\\text{pred}(b_h)|$ 仍然是 2（现在来自 $b_s$ 和 $b_{lh}$），但这条边不是关键边。\n    - 这部分是正确的。\n3.  **唯一程序点**：新块 $b_{lh}$ 位于替换了边 $\\langle b_l, b_h \\rangle$ 的唯一路径段上。因此，它当且仅当控制流从 $b_l$ 流向 $b_h$ 时执行。这是 SSA 构建中边分裂的主要目的。这部分是正确的。\n4.  **支配关系**：支配是关于从入口块出发的所有路径的属性。在现有边 $\\langle b_l, b_h \\rangle$ 上插入一个块 $b_{lh}$ 并不会在原始节点之间创建任何新路径，也不会从现有路径中移除任何原始节点。因此，如果一个节点 $d$ 在分裂前支配一个节点 $n$（即 $d$ 在从 $b_s$ 到 $n$ 的每一条路径上），那么在分裂后它仍然在每一条这样的路径上。原始集合 $V$ 中节点之间的支配关系得以保留。这部分是正确的。\n\n由于选项 A 中的所有声明都是正确的，所以该选项是正确的。\nA 的结论：**正确**。\n\n**B. 对于在 $b_h$ 处的 $\\phi$ 函数放置，如果我们不分裂 $b_l \\to b_h$，将回边参数移动操作放在 $b_l$ 内部是语义上安全的，因为 $b_l$ 中的条件语句确保了该移动操作仅在 $q$ 为真时执行。**\n\n基本块是具有单一入口点和单一出口点的指令序列。块 $b_l$ 包含条件分支 `if q then goto b_h else goto b_m` 的逻辑。根据定义，任何放置在块 $b_l$ *内部*的指令都必须在这个分支发生之前执行。如果我们将参数移动（例如 `t := x`）放在 $b_l$ 内部，它将在每次进入 $b_l$ 时执行，无论 $q$ 是真还是假。然后控制流将继续到 $b_h$ 或 $b_m$。该移动操作仅在通往 $b_h$ 的路径上才需要。在通往 $b_m$ 的路径上执行它是一个语义错误（“丢失副本”问题，如果临时变量被重用，会导致不正确的程序状态）。“条件语句确保了该移动操作仅在 q 为真时执行”这一前提是对基本块和 CFG 工作原理的误解。条件语句决定的是在块中指令执行*之后*采取哪条路径。\nB 的结论：**不正确**。\n\n**C. 如果我们不分裂 $b_l \\to b_h$ 并且将回边参数移动操作放在 $b_l$ 内部，那么存在一个 $p$ 为假且 $q$ 为假的执行路径，在该路径中，移动操作会沿着 $b_l \\to b_m$ 执行，并干扰在 $b_m$ 中 $use(x)$ 处看到的 $x$ 的版本，从而违反了 $\\phi$ 参数的路径敏感语义。这展示了一个反例：边局部的移动操作必须被放置在一条非关键边上，以确保它只在相应的边被采用时执行。**\n\n这个选项直接驳斥了选项 B。我们来分析这个声明。\n1.  **放置位置**：用于 $b_h$ 处 $\\phi$ 函数的回边参数移动被放置在 $b_l$ 内部。这个移动是特定于边 $\\langle b_l, b_h \\rangle$ 的。\n2.  **执行路径**：考虑一个 $p$ 为假且 $q$ 为假的执行过程。\n    - 执行从 $b_s$ 开始。让我们追踪 $x$ 的值。$b_s: x := 0$。\n    - 控制流 $b_s \\to b_h$。\n    - 在 $b_h$，$p$ 条件为假，所以控制流向 $b_f$。$x$ 的值为 0。\n    - 控制流 $b_f \\to b_l$。\n    - 在 $b_l$，被错误放置的参数移动操作执行。这个移动是为到 $b_h$ 的回边准备的，所以它会复制 $x$ 的当前值。\n    - 然后，对条件 $q$ 进行求值。由于 $q$ 为假，控制流向 $b_m$。\n3.  **违反**：这个在语义上属于边 $\\langle b_l, b_h \\rangle$ 的参数移动操作，在一条通往 $b_m$ 的路径上被执行了。这直接违反了 $\\phi$ 函数参数的路径敏感语义，该语义要求为特定路径所做的准备工作只能在该路径上执行。虽然“干扰在 $b_m$ 中 $use(x)$ 处看到的 $x$ 的版本”这一说法可能有不同的解释（例如，直接的值损坏 vs. 用一个活跃但不需要的临时变量污染状态），但论证的核心是违反了路径敏感语义。在编译的这个阶段，这种违反是一个根本性的错误。\n4.  **结论**：最后的陈述，“边局部的移动操作必须被放置在一条非关键边上，以确保它只在相应的边被采用时执行”，是从这个反例中得出的正确原则。边分裂是创建这样一条非关键边的机制。\n\n逻辑是合理的：一个特定于从具有多个出口的块中出来的一条路径的操作，不能被放置在该块内部。\nC 的结论：**正确**。\n\n**D. 分裂边 $b_t \\to b_l$ 和 $b_f \\to b_l$ 是消除与 $\\mathcal{P}$ 中 $b_h$ 处的 $\\phi$ 函数放置相关的所有关键边的充分必要条件。**\n\n1.  **相关性**：所讨论的 $\\phi$ 函数位于块 $b_h$。该 $\\phi$ 函数的输入对应于 $b_h$ 的入边，即 $\\langle b_s, b_h \\rangle$ 和 $\\langle b_l, b_h \\rangle$。因此，唯一的“相关”关键边是这两条中的一条。\n2.  **识别**：我们已经确定 $\\langle b_s, b_h \\rangle$ 不是关键边，而 $\\langle b_l, b_h \\rangle$ 是关键边。所以，唯一相关的关键边是 $\\langle b_l, b_h \\rangle$。\n3.  **提议的动作**：该选项提议分裂 $\\langle b_t, b_l \\rangle$ 和 $\\langle b_f, b_l \\rangle$。这些是进入 $b_l$ 的边。这个动作可能与 $b_l$ 处的 $\\phi$ 函数有关，但与 $b_h$ 处的无关。\n4.  **充分性**：分裂 $\\langle b_t, b_l \\rangle$ 和 $\\langle b_f, b_l \\rangle$ 不会改变 $b_l$ 的后继数量（$|\\text{succ}(b_l)| = 2$），也不会改变 $b_h$ 的前驱数量（$|\\text{pred}(b_h)| = 2$）。因此，边 $\\langle b_l, b_h \\rangle$ 仍然是关键边。提议的动作不充分。\n5.  **必要性**：这个动作不是必要的。解决 $b_h$ 处 $\\phi$ 函数问题的必要动作是分裂关键边 $\\langle b_l, b_h \\rangle$。分裂进入 $b_l$ 的边是无关的。\n\n该选项提议对图的错误部分进行操作，因此既不必要也不充分。\nD 的结论：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3633367"}]}