{"hands_on_practices": [{"introduction": "第一个练习将带你直接应用流动依赖的基本定义。通过分析一个带有非单位步长的简单循环，你将练习识别依赖的源和汇，并计算其“归一化”距离。这个距离对于理解依赖操作之间相隔多少次迭代至关重要。[@problem_id:3635366]", "problem": "考虑一个单循环程序片段，其归纳变量 $i$ 的步长为 $2$：\n给定整数 $L$ 和 $U$，满足 $L \\le U$ 和 $L \\equiv U \\pmod{2}$，循环以 $i \\in \\{L, L+2, L+4, \\dots, U\\}$ 执行迭代，并执行单条语句 $S$：$A[i] \\leftarrow A[i-2]$。假设数组 $A[\\cdot]$ 已分配足够大的空间，以使所有引用的索引都有效。使用一维迭代空间中循环携带流（真）依赖的基本定义——即，当且仅当在迭代 $i'$ 中写入的内存位置随后在迭代 $i$ 中被读取，且在循环的执行顺序中 $i'  i$ 时，从语句 $S$ 的迭代 $i'$ 到语句 $S$ 的迭代 $i$ 存在依赖关系——来确定在给定步长为 $2$ 的情况下，以迭代次数为单位表示的归一化循环携带流依赖距离 $d$。也就是说，计算常数 $d$，使得对于所有实现该依赖的迭代 $i$，源迭代索引满足 $i' = i - 2$ 且 $d = \\frac{i - i'}{2}$。\n你的最终答案必须是这个单一整数 $d$（无单位）。无需四舍五入。", "solution": "首先评估问题的有效性。\n\n**步骤 1：提取已知条件**\n- 循环特性：单循环。\n- 归纳变量：$i$。\n- 步长：$2$。\n- 循环范围边界：整数 $L$ 和 $U$。\n- 循环范围条件：$L \\le U$ 且 $L \\equiv U \\pmod{2}$。\n- $i$ 的迭代集合：$\\{L, L+2, L+4, \\dots, U\\}$。\n- 循环体中的语句：$S: A[i] \\leftarrow A[i-2]$。\n- 数组假设：$A[\\cdot]$ 足够大，以防止越界访问。\n- 循环携带流依赖的定义：如果同一个内存位置在迭代 $i'$ 中被写入，并在迭代 $i$ 中被读取，且在循环的执行顺序中 $i'  i$，则存在从 $S$ 的迭代 $i'$ 到 $S$ 的迭代 $i$ 的依赖关系。\n- 目标变量：归一化循环携带流依赖距离 $d$。\n- 给定的源迭代关系：对于所有实现的依赖，$i' = i - 2$。\n- 给定的归一化距离公式：$d = \\frac{i - i'}{2}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题基于编译器设计的原理，特别是数据依赖分析。诸如“循环携带流依赖”、“归纳变量”、“步长”和“归一化依赖距离”等术语在此上下文中都是标准且定义明确的。问题设定是自洽的、一致的，并提供了推导解决方案所需的所有必要信息。条件 $L \\le U$ 和 $L \\equiv U \\pmod{2}$ 确保了循环的良好行为。问题是客观的且可形式化的。问题确实提供了依赖关系 $i' = i - 2$，这通常是需要推导出来的。然而，根据基本定义验证此关系是确认问题内部一致性的一个有效步骤。接下来的任务是使用这个已确认的关系来计算归一化距离，这考验了对归一化距离定义的理解。该问题并非无关紧要或不适定的。\n\n**步骤 3：结论与行动**\n该问题被视为有效。将提供解决方案。\n\n**求解推导**\n目标是为给定的循环结构和语句确定归一化的循环携带流依赖距离，记为 $d$。\n\n分析的核心在于流（或真）依赖的定义。如果语句 $S_1$ 写入一个内存位置，该位置随后被语句 $S_2$ 读取，并且 $S_1$ 在 $S_2$ 之前执行，那么从 $S_1$ 到 $S_2$ 就存在流依赖。当 $S_1$ 和 $S_2$ 是同一语句 $S$ 但在不同的循环迭代中时，这种依赖称为循环携带依赖。\n\n设源迭代由 $i'$ 索引，宿迭代由 $i$ 索引。对于循环携带依赖，执行顺序要求 $i'  i$。循环对 $i \\in \\{L, L+2, \\dots, U\\}$ 执行。\n\n循环内的单条语句是 $S: A[i] \\leftarrow A[i-2]$。\n在任何给定的迭代 $k$ 中，该语句执行两次内存访问：\n1.  对由数组索引 $k$ 寻址的内存位置进行写操作。这是“DEF”（定义）或写集合：$DEF(k) = \\{A[k]\\}$。\n2.  从由数组索引 $k-2$ 寻址的内存位置进行读操作。这是“USE”（使用）或读集合：$USE(k) = \\{A[k-2]\\}$。\n\n如果迭代 $i'$ 中写入的位置与迭代 $i$ 中读取的位置相同（其中 $i'  i$），则存在从迭代 $i'$ 到迭代 $i$ 的循环携带流依赖。\n在数学上，这意味着 $DEF(i') \\cap USE(i) \\neq \\emptyset$。\n\n- 在迭代 $i'$ 中写入的内存位置是 $A[i']$。\n- 在迭代 $i$ 中读取的内存位置是 $A[i-2]$。\n\n要使它们是同一位置，它们的索引必须相等：\n$$i' = i - 2$$\n\n这个方程建立了依赖的源迭代和宿迭代之间的关系。这一推导证实了问题陈述中提供的关系。\n\n接下来，我们必须验证此关系是否对应于一个有效的循环携带依赖。条件是源迭代必须在宿迭代之前执行。在这个单循环中，这意味着 $i'  i$。代入我们推导出的关系，我们检查：\n$$i - 2  i$$\n这个不等式总是成立的。因此，从迭代 $i-2$ 到迭代 $i$ 存在一个循环携带流依赖。对于任何迭代 $i$，只要 $i-2$ 也是循环中一个有效的前序迭代，该依赖就会实现。第一个这样的情况是 $i = L+2$，它依赖于迭代 $i' = L$。\n\n问题要求的是归一化的循环携带依赖距离 $d$。依赖距离是宿迭代和源迭代索引之间的差值，即 $\\Delta i = i - i'$。\n$$\\Delta i = i - (i - 2) = 2$$\n归一化依赖距离是依赖距离除以循环步长。循环归纳变量 $i$ 以步长 $s=2$ 递增。归一化距离计算的是依赖的内存访问之间相隔了多少个循环*步*（或迭代）。\n\n问题提供了归一化距离 $d$ 的明确公式：\n$$d = \\frac{i - i'}{2}$$\n将依赖距离 $i - i' = 2$ 的值代入此公式可得：\n$$d = \\frac{2}{2}$$\n$$d = 1$$\n\n归一化依赖距离是一个常数值 $1$。这表示每次迭代中的读访问（从第二次迭代开始）都依赖于循环执行序列中紧邻的前一次迭代的写访问。", "answer": "$$\\boxed{1}$$", "id": "3635366"}, {"introduction": "这个实践问题揭示了一个关键点：循环的迭代方向可以完全改变其内部的数据依赖关系。通过比较两个执行相同语句但顺序相反的循环，你将看到一个流动依赖如何转变为反依赖，从而彻底改变程序的最终结果及其并行化潜力。[@problem_id:3635271]", "problem": "考虑一个长度为 $N+1$ 的数组 $A$，其有效索引为 $1,2,\\dots,N+1$，其中 $N \\ge 1$。假设每次迭代只有一次赋值操作，不存在指针别名，并且读取 $A[N+1]$ 是良定义的。分析以下两个循环的数据依赖关系及其产生的语义：\n(1) 降序循环：for $i$ from $N$ down to $1$，执行 $A[i] = A[i+1]$。\n(2) 升序循环：for $i$ from $1$ up to $N$，执行 $A[i] = A[i+1]$。\n使用编译器分析中数据依赖的标准定义：真（流）依赖（true (flow) dependence），从一次写操作到后续对同一位置的读操作；反依赖（anti dependence），从一次读操作到后续对同一位置的写操作；以及输出依赖（output dependence），从一次写操作到后续对同一位置的写操作；循环携带依赖（loop-carried dependence）是指源和汇发生在不同迭代中的依赖。对于一维循环，定义依赖距离为 $\\Delta = i_{\\text{sink}} - i_{\\text{source}}$，方向定义为：如果 $i_{\\text{source}}  i_{\\text{sink}}$ 则为 $$，如果 $i_{\\text{source}} > i_{\\text{sink}}$ 则为 $$，如果相等则为 $=$。\n\n下列哪个陈述是正确的？\n\nA. 在降序循环中，存在一个从迭代 $i$（写 $A[i]$）到迭代 $i-1$（读 $A[i]$，即 $A[(i-1)+1]$）的循环携带真（流）依赖，其方向为 $$，依赖距离为 $\\Delta = -1$。由于这个真依赖，朴素的并行化是不安全的，并且在循环完成后，$A[1],A[2],\\dots,A[N]$ 的值都等于原始的 $A[N+1]$。\n\nB. 在降序循环中，唯一的循环携带依赖是一个从迭代 $i$到迭代 $i+1$ 关于 $A[i+1]$ 的反依赖；因此朴素的并行化是安全的，并且在循环完成后，$A[1],A[2],\\dots,A[N]$ 的值分别等于原始的 $A[2],A[3],\\dots,A[N+1]$。\n\nC. 在升序循环中，存在一个从迭代 $i$（读 $A[i+1]$）到迭代 $i+1$（写 $A[i+1]$）的循环携带反依赖，其方向为 $$，依赖距离为 $\\Delta = +1$。不存在循环携带真依赖。朴素的并行化是不安全的，除非通过重命名将读写分离（例如，从一个副本中读取），并且在循环完成后，对于所有 $i \\in \\{1,\\dots,N\\}$，$A[i]$ 的值都等于原始的 $A[i+1]$。\n\nD. 在升序循环中，存在一个从迭代 $i+1$到迭代 $i$ 关于 $A[i+1]$ 的循环携带真（流）依赖，其方向为 $$；这即使使用重命名也强制顺序执行，并且在循环完成后，$A[1],A[2],\\dots,A[N]$ 的值都等于原始的 $A[N+1]$。", "solution": "问题陈述定义明确、自成一体，并基于编译器理论的原理，特别是数据依赖分析。所有术语都是标准的，循环结构清晰。该问题是有效的，可以按所述方式解决。\n\n我们将分别分析每个循环的数据依赖。每个循环中的语句是 $S_i: A[i] = A[i+1]$，其中 $S_i$ 表示在迭代 $i$ 中的语句实例。如果两个语句实例 $S_{i_1}$ 和 $S_{i_2}$ 访问相同的内存位置，并且其中至少一个是写操作，那么它们之间就存在依赖关系。对于循环携带依赖，必须有 $i_1 \\neq i_2$，并且 $S_{i_1}$ 必须在 $S_{i_2}$ 之前执行。\n\n### 循环 (1) 分析：降序循环\n循环是：`for i from N down to 1, execute A[i] = A[i+1]`。\n迭代序列为 $i = N, N-1, \\dots, 1$。如果 $i_1 > i_2$，则迭代 $i_1$ 在迭代 $i_2$ 之前执行。\n在迭代 $i$ 中的语句 $S_i$ 写入内存位置 $A[i]$ 并从内存位置 $A[i+1]$ 读取。\n\n**1. 真（流）依赖 (写 $\\rightarrow$ 读):**\n如果 $S_{i_1}$ 写入的位置被 $S_{i_2}$ 稍后读取，则存在从 $S_{i_1}$ 到 $S_{i_2}$ 的真依赖。\n这要求 $S_{i_1}$ 写入的位置（即 $A[i_1]$）与 $S_{i_2}$ 读取的位置（即 $A[i_2+1]$）相同。\n依赖的条件是 $i_1 = i_2 + 1$。\n执行顺序要求 $i_1 > i_2$。条件 $i_1 = i_2 + 1$ 满足这个要求。\n因此，存在循环携带真依赖。依赖的源在迭代 $i_1$ 中，汇在迭代 $i_2 = i_1 - 1$ 中。\n我们将源迭代设为 $i_{\\text{source}} = i$。那么汇迭代就是 $i_{\\text{sink}} = i-1$。\n- 依赖是从迭代 $i$ 中对 $A[i]$ 的写操作到迭代 $i-1$ 中对 $A[(i-1)+1] = A[i]$ 的读操作。\n- 依赖距离：$\\Delta = i_{\\text{sink}} - i_{\\text{source}} = (i-1) - i = -1$。\n- 依赖方向：由于 $i_{\\text{source}} > i_{\\text{sink}}$，方向为 $$。\n\n这种依赖创建了一个链条：在迭代 $i-1$ 中计算的值依赖于在迭代 $i$ 中计算的值。\n我们来追踪执行过程：\n- $i=N$：$A[N]$ 被赋为 $A[N+1]$ 的原始值。\n- $i=N-1$：$A[N-1]$ 被赋为 $A[N]$ 的值，而 $A[N]$ 刚刚被更新为 $A[N+1]$ 的原始值。\n- 这个过程持续到 $i=1$，此时 $A[1]$ 被赋为 $A[2]$ 的值，而 $A[2]$ 也已经被更新为 $A[N+1]$ 的原始值。\n因此，循环结束后，所有元素 $A[1], A[2], \\dots, A[N]$ 都将持有 $A[N+1]$ 的原始值。循环携带真依赖的存在使得朴素的并行化不安全。\n\n**2. 反依赖 (读 $\\rightarrow$ 写):**\n如果 $S_{i_1}$ 读取的位置被 $S_{i_2}$ 稍后写入，则存在从 $S_{i_1}$ 到 $S_{i_2}$ 的反依赖。\n这要求 $A[i_1+1]$（被 $S_{i_1}$ 读取）与 $A[i_2]$（被 $S_{i_2}$ 写入）是相同的位置。\n条件是 $i_1 + 1 = i_2$。\n执行顺序要求 $i_1 > i_2$。然而，$i_1 + 1 = i_2$ 意味着 $i_1  i_2$。这是一个矛盾。因此，不存在循环携带反依赖。\n\n**3. 输出依赖 (写 $\\rightarrow$ 写):**\n如果 $S_{i_1}$ 和 $S_{i_2}$ 都写入相同的位置，则存在输出依赖。这要求 $A[i_1]$ 与 $A[i_2]$ 是相同的位置，因此 $i_1 = i_2$。这不是一个循环携带依赖，因为循环携带依赖要求 $i_1 \\neq i_2$。\n\n### 循环 (2) 分析：升序循环\n循环是：`for i from 1 up to N, execute A[i] = A[i+1]`。\n迭代序列为 $i = 1, 2, \\dots, N$。如果 $i_1  i_2$，则迭代 $i_1$ 在迭代 $i_2$ 之前执行。\n\n**1. 真（流）依赖 (写 $\\rightarrow$ 读):**\n如果 $S_{i_1}$ 中的写操作（写入 $A[i_1]$）与 $S_{i_2}$ 中的读操作（从 $A[i_2+1]$ 读取）是同一位置，则存在从 $S_{i_1}$ 到 $S_{i_2}$ 的真依赖。\n条件是 $i_1 = i_2 + 1$。\n执行顺序要求 $i_1  i_2$。条件 $i_1 = i_2+1$ 意味着 $i_1 > i_2$。这是一个矛盾。因此，不存在循环携带真依赖。\n\n**2. 反依赖 (读 $\\rightarrow$ 写):**\n如果 $S_{i_1}$ 中的读操作（从 $A[i_1+1]$ 读取）与 $S_{i_2}$ 中的写操作（写入 $A[i_2]$）是同一位置，则存在从 $S_{i_1}$ 到 $S_{i_2}$ 的反依赖。\n条件是 $i_1 + 1 = i_2$。\n执行顺序要求 $i_1  i_2$。条件 $i_1 + 1 = i_2$ 满足这个要求。\n因此，存在循环携带反依赖。源在迭代 $i_1$ 中，汇在迭代 $i_2 = i_1+1$ 中。\n我们将源迭代设为 $i_{\\text{source}} = i$。那么汇迭代就是 $i_{\\text{sink}} = i+1$。\n- 依赖是从迭代 $i$ 中对 $A[i+1]$ 的读操作到迭代 $i+1$ 中对 $A[i+1]$ 的写操作。\n- 依赖距离：$\\Delta = i_{\\text{sink}} - i_{\\text{source}} = (i+1) - i = +1$。\n- 依赖方向：由于 $i_{\\text{source}}  i_{\\text{sink}}$，方向为 $$。\n\n不存在真依赖意味着在迭代 $i$ 中读取的 $A[i+1]$ 的值始终是循环开始前存在的值。因此，在顺序执行后，对于所有 $i \\in \\{1, \\dots, N\\}$，$A[i]$ 将等于 $A[i+1]$ 的原始值。这相当于一个内存复制操作。\n反依赖的存在使得朴素的并行化不安全，因为并发执行可能允许迭代 $i+1$ 在迭代 $i$ 从 $A[i+1]$ 读取之前就对其进行写入。这种依赖可以通过私有化或数组扩展（例如，首先将所有读取的值复制到一个临时数组中）等技术来消除，从而实现安全的并行化。\n\n**3. 输出依赖 (写 $\\rightarrow$ 写):**\n与降序循环中一样，这要求 $i_1 = i_2$，因此不是一个循环携带依赖。\n\n### 逐个选项评估\n\n**A. 在降序循环中，存在一个从迭代 $i$（写 $A[i]$）到迭代 $i-1$（读 $A[i]$，即 $A[(i-1)+1]$）的循环携带真（流）依赖，其方向为 $$，依赖距离为 $\\Delta = -1$。由于这个真依赖，朴素的并行化是不安全的，并且在循环完成后，$A[1],A[2],\\dots,A[N]$ 的值都等于原始的 $A[N+1]$。**\n- 此陈述准确地描述了我们在降序循环中识别出的真依赖：从迭代 $i$ 到 $i-1$，关于位置 $A[i]$。\n- 方向 ``（因为 $i > i-1$）和距离 $\\Delta = -1$ 是正确的。\n- 由于这个真依赖，朴素并行化不安全的结论是正确的。\n- 根据我们的执行追踪，$A[1], \\dots, A[N]$ 都等于原始的 $A[N+1]$ 的最终状态也是正确的。\n结论：**正确**。\n\n**B. 在降序循环中，唯一的循环携带依赖是一个从迭代 $i$到迭代 $i+1$ 关于 $A[i+1]$ 的反依赖；因此朴素的并行化是安全的，并且在循环完成后，$A[1],A[2],\\dots,A[N]$ 的值分别等于原始的 $A[2],A[3],\\dots,A[N+1]$。**\n- 此陈述声称反依赖是唯一的依赖。我们的分析表明存在真依赖而没有反依赖。\n- 由于存在真依赖，并行化是安全的说法是不正确的。\n- 所声称的最终状态是升序循环逻辑应用时会发生的情况，这对于降序循环的顺序执行是不适用的。\n结论：**不正确**。\n\n**C. 在升序循环中，存在一个从迭代 $i$（读 $A[i+1]$）到迭代 $i+1$（写 $A[i+1]$）的循环携带反依赖，其方向为 $$，依赖距离为 $\\Delta = +1$。不存在循环携带真依赖。朴素的并行化是不安全的，除非通过重命名将读写分离（例如，从一个副本中读取），并且在循环完成后，对于所有 $i \\in \\{1,\\dots,N\\}$，$A[i]$ 的值都等于原始的 $A[i+1]$。**\n- 此陈述正确地识别了从迭代 $i$ 到 $i+1$ 关于位置 $A[i+1]$ 的反依赖。\n- 方向 ``（因为 $i  i+1$）和距离 $\\Delta = +1$ 是正确的。\n- 不存在循环携带真依赖的说法是正确的。\n- 朴素并行化不安全但可以通过重命名使其安全的结论是正确的。\n- 对于 $i \\in \\{1,\\dots,N\\}$，$A[i]$ 等于原始 $A[i+1]$ 的最终状态是正确的。\n结论：**正确**。\n\n**D. 在升序循环中，存在一个从迭代 $i+1$到迭代 $i$ 关于 $A[i+1]$ 的循环携带真（流）依赖，其方向为 $$；这即使使用重命名也强制顺序执行，并且在循环完成后，$A[1],A[2],\\dots,A[N]$ 的值都等于原始的 $A[N+1]$。**\n- 此陈述声称升序循环中存在真依赖。我们的分析表明这是错误的。\n- 对于流依赖，在升序循环中从迭代 $i+1$ 到 $i$ 的依赖是不可能的，因为源（$i+1$）在汇（$i$）之后执行。\n- 即使使用重命名也强制顺序执行的结论是真依赖的特征，而这里并不存在真依赖。\n- 所述的最终状态是降序循环的，而不是升序循环的。\n结论：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3635271"}, {"introduction": "数据依赖分析的应用超出了单个循环的范畴，它也是优化连续循环序列的关键。本练习要求你将三个连续循环之间的依赖关系建模成一个图，以帮助你将它们之间的数据流可视化。你将从中识别出一个依赖环路，这是一个基本概念，它解释了为什么某些循环融合变换是非法的，因为它们会破坏原始程序的语义。[@problem_id:3635326]", "problem": "考虑三个长度为 $N$ 的数组 $A$、$B$ 和 $C$，$N$ 为一个正整数。假设所有数组都是不同的，不存在别名，并且内存语义在迭代中是顺序和一致的。以下三个循环按程序顺序执行，其中 $i$ 从 $0$ 到 $N-1$：\n- 循环 $L_{1}$：$S_{1}(i): A[i] = B[i]$，\n- 循环 $L_{2}$：$S_{2}(i): B[i] = C[i]$，\n- 循环 $L_{3}$：$S_{3}(i): C[i] = A[i]$。\n\n从编译器原理中数据依赖的基本定义出发，即流依赖（真依赖）、反依赖（读后写）和输出依赖（写后写），为固定的迭代 $i$ 构建语句 $S_{1}$、$S_{2}$ 和 $S_{3}$ 之间的语句级数据依赖图。然后，在数组级别上抽象出一个值依赖图，其中有向边 $X \\to Y$ 表示计算 $Y[i]$ 直接使用了同一迭代中的 $X[i]$ 的值。利用这个数组级值依赖图，判断是否存在有向环，该环会阻止将 $L_{1}$、$L_{2}$ 和 $L_{3}$ 合法地融合成一个保留顺序语义的单一循环体。作为最终结果，计算数组级值依赖图中所存在的最小有向环的长度。如果不存在环，则报告 $0$。以一个不带单位的整数形式给出最小有向环的长度。", "solution": "用户希望我分析三个循环序列中的数据依赖关系，并确定特定依赖图中最小环的长度。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件**\n- 三个不同的、无别名的数组：$A$、$B$、$C$。\n- 数组长度：$N$，一个正整数。\n- 循环按程序顺序执行（$L_1$，然后 $L_2$，然后 $L_3$）。\n- 循环 $L_1$：对于 $i$ 从 $0$ 到 $N-1$，$S_1(i): A[i] = B[i]$。\n- 循环 $L_2$：对于 $i$ 从 $0$ 到 $N-1$，$S_2(i): B[i] = C[i]$。\n- 循环 $L_3$：对于 $i$ 从 $0$ 到 $N-1$，$S_3(i): C[i] = A[i]$。\n- 任务：为固定的迭代 $i$ 构建一个“数组级值依赖图”。\n- 图边的定义：如果计算 $Y[i]$ 直接使用了同一迭代中 $X[i]$ 的值，则存在一条有向边 $X \\to Y$。\n- 任务：使用此图确定是否存在有向环，该环会阻止循环的合法融合。\n- 任务：计算此图中最小有向环的长度。如果不存在环，则长度为 $0$。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于编译器设计的原理，特别是数据依赖分析和循环变换。流依赖、反依赖和输出依赖的概念及其在循环融合中的作用是该领域的标准内容。\n- **问题定义良好：** 该问题是自包含的，并提供了得出唯一解所需的所有必要定义、变量和约束。无别名和顺序执行的假设是清晰的。\n- **客观性：** 该问题以精确、正式的语言陈述，没有主观或含糊的术语。\n\n**1.3. 结论与行动**\n问题有效。我将继续进行解答。\n\n### 步骤2：解答\n\n问题要求构建一种特定类型的依赖图并分析其中的环。首先，让我们回顾一下数据依赖的基本定义。如果语句 $S_b$ 和语句 $S_a$ 在程序执行顺序中存在一条从 $S_a$ 到 $S_b$ 的路径，它们都访问同一内存位置，并且其中至少一次访问是写操作，那么语句 $S_b$ 对语句 $S_a$ 存在数据依赖。这里主要相关的依赖类型是流依赖。\n\n- **流依赖（真依赖）：** 如果语句 $S_a$ 写入一个内存位置，而语句 $S_b$ 随后读取该位置，则 $S_b$ 对 $S_a$ 存在流依赖。这代表了值从生产者到消费者的流动。\n\n问题要求构建一个“数组级值依赖图”，并明确定义了它：“有向边 $X \\to Y$ 表示计算 $Y[i]$ 直接使用了同一迭代中的 $X[i]$ 的值。”这是一个在数组级别上的流依赖图，源于赋值语句的语法。该图的节点是数组本身：$A$、$B$ 和 $C$。我们现在通过检查每个语句来构建该图的边。\n\n1.  **语句 $S_1(i): A[i] = B[i]$**\n    此语句计算数组元素 $A[i]$ 的一个新值。此计算中使用的值是从 $B[i]$ 读取的。根据给定定义，这建立了从数组 $B$ 到数组 $A$ 的值依赖。我们将其表示为一条有向边：\n    $$ B \\to A $$\n\n2.  **语句 $S_2(i): B[i] = C[i]$**\n    此语句计算数组元素 $B[i]$ 的一个新值。使用的值是从 $C[i]$ 读取的。这建立了从数组 $C$ 到数组 $B$ 的值依赖。我们将其表示为一条有向边：\n    $$ C \\to B $$\n\n3.  **语句 $S_3(i): C[i] = A[i]$**\n    此语句计算数组元素 $C[i]$ 的一个新值。使用的值是从 $A[i]$ 读取的。这建立了从数组 $A$ 到数组 $C$ 的值依赖。我们将其表示为一条有向边：\n    $$ A \\to C $$\n\n得到的数组级值依赖图有三个节点（$A, B, C$）和三条有向边：\n- $E_1: A \\to C$\n- $E_2: C \\to B$\n- $E_3: B \\to A$\n\n问题指出，此图中的有向环会阻止循环的合法融合。我们现在必须分析此图是否存在有向环。有向环是图中一条起点和终点相同的路径。\n\n通过检查这些边，我们可以追踪以下路径：\n- 从节点 $A$ 开始。\n- 沿着边 $A \\to C$。\n- 从节点 $C$，沿着边 $C \\to B$。\n- 从节点 $B$，沿着边 $B \\to A$。\n\n这条路径 $A \\to C \\to B \\to A$ 返回到起始节点 $A$，因此它是一个有向环。像这样的流依赖环表明，在一个融合的循环中，对迭代 $i$ 的每个数组新值的计算都依赖于来自同一次迭代 $i$ 的另一个新值，这导致了循环等待，从而阻止了简单的串行执行在不进行变换（如使用临时变量）的情况下保持原始程序的语义。\n\n环的长度是它包含的边的数量。我们识别出的环 $A \\to C \\to B \\to A$ 由三条边 $E_1$、$E_2$ 和 $E_3$ 组成。因此，其长度为 $3$。\n\n我们必须找到*最小*有向环的长度。让我们检查是否存在长度更小的环。\n- 长度为 $1$ 的环（自环）需要一条像 $X \\to X$ 这样的边，这对应于形式为 $X[i] = f(..., X[i], ...)$ 的语句。我们的语句中没有这种形式。\n- 长度为 $2$ 的环需要一对边 $X \\to Y$ 和 $Y \\to X$。让我们检查我们的边：\n    - 我们有 $A \\to C$。我们有 $C \\to A$ 吗？没有，我们有 $C \\to B$。\n    - 我们有 $C \\to B$。我们有 $B \\to C$ 吗？没有，我们有 $B \\to A$。\n    - 我们有 $B \\to A$。我们有 $A \\to B$ 吗？没有，我们有 $A \\to C$。\n    因此，不存在长度为 $2$ 的环。\n\n图中存在的唯一环就是我们找到的那个，$A \\to C \\to B \\to A$。由于不存在长度为 $1$ 或 $2$ 的环，所以最小有向环的长度为 $3$。", "answer": "$$\n\\boxed{3}\n$$", "id": "3635326"}]}