{"hands_on_practices": [{"introduction": "这个练习将向您展示条件常量传播 (Conditional Constant Propagation, CCP) 的核心机制。我们将看到，当一个分支条件在编译时可以被计算为一个常量时，编译器是如何将其中一个分支识别为“不可达”的，从而简化后续的 $\\phi$ 函数。理解这一过程是掌握 CCP 如何消除死代码和优化程序流的关键第一步 [@problem_id:3630643]。", "problem": "考虑以下处于静态单赋值（SSA）形式的程序及其菱形控制流图（CFG）。该程序在合并点使用 SSA $\\phi$-函数的标准语义。您需要应用条件常量传播（CCP）来确定在出口处计算出的常量值。\n\n代码块与语句：\n- 入口块 $B_{0}$：\n  - $a_{0} := 7$\n  - $b_{0} := a_{0} - a_{0}$\n  - $\\text{if } (b_{0} == 1) \\text{ then goto } B_{1} \\text{ else goto } B_{2}$\n- Then 块 $B_{1}$：\n  - $c_{1} := 11$\n  - $\\text{goto } B_{3}$\n- Else 块 $B_{2}$：\n  - $c_{2} := 17$\n  - $\\text{goto } B_{3}$\n- 合并块 $B_{3}$：\n  - $c_{3} := \\phi(c_{1}, c_{2})$\n  - $r := 3 c_{3} - 2$\n\n您必须根据数据流分析的基本定义（应用于 CCP）进行推理：\n- CCP 的值域是三点常量传播格 $D = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$，其中 $\\bot$ 表示“未初始化/不可达”，任何 $z \\in \\mathbb{Z}$ 表示一个已知的整数常量，而 $\\top$ 表示“未知/非常量”。\n- 转移函数使用标准算术语义评估对已知常量的操作。\n- 具有已知常量谓词的条件分支决定了边的可行性和可达性。\n- SSA $\\phi$-函数产生来自实际可行的前驱的输入值；如果多个可行的前驱提供相同的已知常量，则结果是该常量；否则，如果存在多个可行的前驱，但它们的值不同或不是常量，则结果为 $\\top$。\n\n从这些基础出发，在给定的菱形 CFG 上模拟 CCP。$B_{0}$ 中的守卫条件可能会产生一个矛盾，影响其中一个分支的可达性。在 CCP 稳定并且所有可能的常量折叠都执行完毕后，计算在块 $B_{3}$ 出口处 $r$ 的确切值。\n\n给出您的最终答案，一个精确的整数。无需四舍五入。", "solution": "该问题要求应用条件常量传播（CCP）算法到一个处于静态单赋值（SSA）形式的给定程序，以确定变量 $r$ 的最终值。CCP 算法将常量传播与可达性分析相结合。每个变量的分析状态都维持在三点格 $D = \\{\\bot, \\mathbb{Z}, \\top\\}$ 上，其中 $\\bot$ 表示变量未初始化或其定义代码不可达，任何整数 $z \\in \\mathbb{Z}$ 代表一个已知的常量值，而 $\\top$ 表示一个非常量值。\n\n分析过程通过模拟程序的执行进行，更新变量的格值并确定控制流路径的可行性。我们为所有变量维护一个格值映射，并将其初始化为 $\\bot$：\n$Val(a_{0}) = \\bot$, $Val(b_{0}) = \\bot$, $Val(c_{1}) = \\bot$, $Val(c_{2}) = \\bot$, $Val(c_{3}) = \\bot$, $Val(r) = \\bot$。\n\n我们还跟踪每个基本块的可达性。最初，只有入口块 $B_{0}$ 是可达的。\n\n1.  **分析入口块 $B_0$**：\n    此块是入口点，因此是可达的。我们按顺序分析其语句。\n    -   语句 $a_{0} := 7$：变量 $a_{0}$ 被赋予常量值 $7$。它的格值从 $\\bot$ 更新为 $7$。因此，$Val(a_{0}) = 7$。\n    -   语句 $b_{0} := a_{0} - a_{0}$：将减法转移函数应用于 $a_{0}$ 的格值。由于 $Val(a_{0}) = 7$ 是一个已知常量，表达式求值为 $7 - 7 = 0$。变量 $b_{0}$ 的格值从 $\\bot$ 更新为 $0$。因此，$Val(b_{0}) = 0$。\n    -   语句 $\\text{if } (b_{0} == 1) \\text{ then goto } B_{1} \\text{ else goto } B_{2}$：这是一个条件分支。谓词涉及变量 $b_{0}$，我们已知其常量值为 $Val(b_{0}) = 0$。条件被评估为 $0 == 1$，这明确地是 `false`。\n    -   根据 CCP 的原理，具有已知常量谓词的条件分支决定了边的可行性。由于谓词为假，到块 $B_{1}$ 的 `then` 分支被确定为不可执行，而到块 $B_{2}$ 的 `else` 分支被确定为可执行。\n    -   这意味着块 $B_{1}$ 是不可达的，而块 $B_{2}$ 是可达的。\n\n2.  **分析 Then 块 $B_1$**：\n    -   根据对 $B_{0}$ 的分析，块 $B_{1}$ 是不可达的。因此，在抽象解释期间，其内部的语句永远不会被执行。\n    -   语句 $c_{1} := 11$ 不会被处理。\n    -   $c_{1}$ 的格值保持其初始状态 $Val(c_{1}) = \\bot$。\n\n3.  **分析 Else 块 $B_2$**：\n    -   该块通过从 $B_{0}$ 出发的边是可达的。我们分析其语句。\n    -   语句 $c_{2} := 17$：变量 $c_{2}$ 被赋予常量值 $17$。它的格值从 $\\bot$ 更新为 $17$。因此，$Val(c_{2}) = 17$。\n    -   语句 $\\text{goto } B_{3}$：这是一个无条件跳转。从 $B_{2}$到 $B_{3}$ 的边是可执行的，这使得合并块 $B_{3}$ 变为可达。\n\n4.  **分析合并块 $B_3$**：\n    -   该块是可达的。我们分析其语句。\n    -   语句 $c_{3} := \\phi(c_{1}, c_{2})$：这个 SSA $\\phi$-函数合并来自前驱块 $B_{1}$ 和 $B_{2}$ 的值。$\\phi$-函数的 CCP 规则是只考虑来自可行前驱路径的输入。\n    -   来自 $B_{1}$ 的前驱路径是不可执行的。因此，在 $B_{1}$ 中定义的 $c_{1}$ 的值是无关的。它的格值是 $\\bot$。\n    -   来自 $B_{2}$ 的前驱路径是可执行的。沿此路径提供的值是 $c_{2}$，我们已知 $Val(c_{2}) = 17$。\n    -   由于只有一条可行路径到达 $\\phi$-函数，$\\phi$-函数的结果是来自那条单一路径的值。因此，$c_{3}$ 取 $c_{2}$ 的值。\n    -   $c_{3}$ 的格值从 $\\bot$ 更新为 $17$。因此，$Val(c_{3}) = 17$。\n    -   语句 $r := 3 c_{3} - 2$：应用此算术表达式的转移函数。我们使用为 $c_{3}$ 确定的常量值 $17$。\n    -   表达式求值为 $3 \\times 17 - 2 = 51 - 2 = 49$。\n    -   $r$ 的格值从 $\\bot$ 更新为 $49$。因此，$Val(r) = 49$。\n\n算法已达到不动点，因为没有循环且所有可达块都已被处理。变量的最终格值是：\n$Val(a_{0}) = 7$\n$Val(b_{0}) = 0$\n$Val(c_{1}) = \\bot$\n$Val(c_{2}) = 17$\n$Val(c_{3}) = 17$\n$Val(r) = 49$\n\n在块 $B_{3}$ 出口处 $r$ 的值是由 CCP 计算出的常量值，即 $49$。", "answer": "$$\\boxed{49}$$", "id": "3630643"}, {"introduction": "在掌握了基础的分支剪枝后，这个练习将展示 CCP 的“传播”特性。您将观察到一个连锁反应：一个常量的确定会触发另一个新常量的计算，这个新常量又使得后续的条件判断变得确定。这个过程清晰地揭示了 CCP 是一个迭代分析，它能逐步发掘并应用代码中的优化机会 [@problem_id:3630625]。", "problem": "给定以下以静态单赋值（SSA）形式表示的直线程序（SSA代表Static Single Assignment），该程序具有显式控制流和卫式更新。假设算术和比较运算具有通常的整数语义。程序的入口将一个常量赋给参数，然后评估一个可能更新该值的卫式比较。在卫式判断之后，该值与零进行比较，并返回一个最终值。\n\n程序（标签是为了便于阅读；所有变量都采用SSA形式）：\n- 入口（Entry）：定义 $x_0 := 1$ 并跳转到 $B_1$。\n- 代码块 $B_1$：评估卫式条件：如果 $(x_0 > 0)$ 则跳转到 $B_2$，否则跳转到 $B_3$。\n- 代码块 $B_2$：计算卫式更新 $x_1 := x_0 - 1$ 并跳转到 $B_4$。\n- 代码块 $B_3$：计算备选更新 $x_2 := x_0 + 2$ 并跳转到 $B_4$。\n- 代码块 $B_4$：使用 $\\phi$-函数合并值 $x_3 := \\phi(B_2: x_1,\\; B_3: x_2)$；然后如果 $(x_3 == 0)$ 则赋值 $y_1 := 7$ 并跳转到 $B_5$，否则赋值 $y_2 := 9$ 并跳转到 $B_5$。\n- 代码块 $B_5$：使用 $\\phi$-函数合并 $y$ 值 $y_3 := \\phi(B_4\\_\\text{true}: y_1,\\; B_4\\_\\text{false}: y_2)$；计算 $z_1 := y_3 + x_3$ 并返回 $z_1$。\n\n从头开始应用条件常量传播算法，从标准的值格开始，其中每个SSA变量取抽象值 $\\bot$、一个具体的整数常量 $c$ 或 $\\top$ 中的一个，同时通过在操作数为常量时评估卫式条件来确定控制流的可执行性。迭代直至达到不动点，在此过程中进行常量折叠、移除不可执行代码并简化 $\\phi$-函数。\n\n在条件常量传播所蕴含的所有常量折叠和不可达代码消除之后，程序返回的单个整数值是多少？请提供确切的整数；无需四舍五入。", "solution": "我们应用条件常量传播（CCP）算法。我们维护一个从 SSA 变量到其在格 {$\\bot$, $c$, $\\top$} 中抽象值的映射，并跟踪控制流图边的可执行性。\n\n**初始化：**\n- 所有 SSA 变量（$x_0, x_1, x_2, x_3, y_1, y_2, y_3, z_1$）都被初始化为抽象值 $\\bot$。\n- `Entry` 块是可执行的，因此其指令被放入一个工作列表。第一条指令是 $x_0 := 1$。\n\n**步骤 1：传播初始常量**\n- 指令：在 `Entry` 中的 $x_0 := 1$。\n- 我们评估右侧，即常量 $1$。\n- $x_0$ 的抽象值从 $\\bot$ 更新为 $1$。\n- 控制流从 `Entry` 转移到 $B_1$。$B_1$ 中的指令 `if ($x_0 > 0$)` 使用了 $x_0$，因此它被添加到工作列表中。\n\n**步骤 2：评估第一个条件分支**\n- 指令：在 $B_1$ 中的 `if ($x_0 > 0$)`。\n- 我们获取 $x_0$ 的抽象值，即 $1$。\n- 条件变为 $1 > 0$，其结果为 `true`。\n- 由于条件是一个常量 `true`，我们可以确定控制流。从 $B_1$ 到 $B_2$ 的边被标记为可执行。从 $B_1$ 到 $B_3$ 的边被标记为不可执行。\n- 代码块 $B_3$ 及其中的所有指令都变得不可达。因此，赋值语句 $x_2 := x_0 + 2$ 将不会被执行。\n- 可达块 $B_2$ 中的指令 $x_1 := x_0 - 1$ 被添加到工作列表中。\n\n**步骤 3：通过 'then' 分支进行传播**\n- 指令：在 $B_2$ 中的 $x_1 := x_0 - 1$。\n- $x_0$ 的值是 $1$。表达式变为 $1 - 1$，其结果为 $0$。\n- $x_1$ 的抽象值从 $\\bot$ 更新为 $0$。\n- 代码块 $B_2$ 无条件跳转到 $B_4$。$x_1$ 的使用点在 $B_4$ 开头的 $x_3$ 的 $\\phi$-函数中，因此这被添加到工作列表中。\n\n**步骤 4：评估第一个 $\\phi$-函数**\n- 指令：在 $B_4$ 中的 $x_3 := \\phi(B_2: x_1, B_3: x_2)$。\n- 我们通过检查来自可执行前驱块的输入来评估 $\\phi$-函数。\n- 前驱 $B_2$ 是可达的。来自此路径的值是 $x_1$，其抽象值为 $0$。\n- 前驱 $B_3$ 是不可达的。\n- 由于只有一条路径到达该 $\\phi$-函数是可执行的，该 $\\phi$-函数坍缩为来自那条单一路径的值。\n- $x_3$ 的抽象值从 $\\bot$ 更新为 $0$。\n- 使用 $x_3$ 的指令，即 `if ($x_3 == 0$)` 和 $z_1 := y_3 + x_3$，被添加到工作列表中。\n\n**步骤 5：评估第二个条件分支**\n- 指令：在 $B_4$ 中的 `if ($x_3 == 0$)`。\n- $x_3$ 的抽象值是 $0$。\n- 条件变为 $0 == 0$，其结果为 `true`。\n- 采用 'true' 路径，使得指令 $y_1 := 7$ 变为可执行。\n- 不采用 'false' 路径，使得指令 $y_2 := 9$ 变为不可达。\n- 指令 $y_1 := 7$ 被添加到工作列表中。\n\n**步骤 6：传播新的常量**\n- 指令：$y_1 := 7$。\n- $y_1$ 的抽象值从 $\\bot$ 更新为 $7$。\n- $y_1$ 的使用点在 $B_5$ 中 $y_3$ 的 $\\phi$-函数中，因此该指令被添加到工作列表中。\n\n**步骤 7：评估第二个 $\\phi$-函数**\n- 指令：在 $B_5$ 中的 $y_3 := \\phi(B_4\\_\\text{true}: y_1, B_4\\_\\text{false}: y_2)$。\n- 我们通过检查其输入来评估 $\\phi$-函数。\n- 对应于 $B_4\\_\\text{true}$ 的路径是可执行的。来自此路径的值是 $y_1$，其抽象值为 $7$。\n- 对应于 $B_4\\_\\text{false}$ 的路径是不可执行的。$y_2$ 的值保持为 $\\bot$。\n- 该 $\\phi$-函数再次坍缩为来自单一可执行路径的值。\n- $y_3$ 的抽象值从 $\\bot$ 更新为 $7$。\n- 使用 $y_3$ 的指令 $z_1 := y_3 + x_3$ 已在工作列表中，所以我们现在处理它。\n\n**步骤 8：计算最终值**\n- 指令：在 $B_5$ 中的 $z_1 := y_3 + x_3$。\n- 我们获取操作数的抽象值。$y_3$ 的值是 $7$，而 $x_3$ 的值是 $0$。\n- 表达式变为 $7 + 0$，其结果为 $7$。\n- $z_1$ 的抽象值从 $\\bot$ 更新为 $7$。\n- $z_1$ 是程序返回的值。\n\n**不动点：**\n工作列表现在为空。所有可达指令都已被评估，并且所有可达SSA变量的抽象值都已确定为常量。不会再有任何变化。算法已达到不动点。\n\n优化后的程序已简化为一系列直线计算：\n1. $x_0 := 1$\n2. $x_1 := 1 - 1 = 0$\n3. $x_3 := 0$ (来自简化的 $\\phi$-函数)\n4. $y_1 := 7$\n5. $y_3 := 7$ (来自简化的 $\\phi$-函数)\n6. $z_1 := 7 + 0 = 7$\n7. 返回 $z_1$\n\n返回值为 $7$。", "answer": "$$\\boxed{7}$$", "id": "3630625"}, {"introduction": "这个练习将挑战一个更复杂的场景，它揭示了 CCP 中“条件”二字的真正威力。在这个问题中，一个变量在合并了多条路径后似乎不再是常量（即其值为 $\\top$）。然而，通过分析后续的控制流守卫（conditional guards），我们可以反推出，只有某个特定的初始值才能使程序执行到特定代码块。这充分体现了 CCP 的路径敏感性，即利用路径信息将看似不确定的值重新精确化为常量 [@problem_id:3630560]。", "problem": "编译器对一个程序应用静态单赋值 (SSA) 形式的稀疏条件常量传播 (SCCP)。SCCP 使用一个三点格来表示值状态，其元素为 $\\bot$ (未定义)、常量 $c \\in \\mathbb{Z}$ 和 $\\top$ (过度定义)。它使用偏好更精确信息的交（meet）运算符，以及条件边可行性来限制考虑哪些流入 $\\phi$-函数和使用的值。SSA 的语义是每个变量名只被精确赋值一次，并且 $\\phi$-函数合并来自不同控制流前驱的值。\n\n考虑以下 SSA 形式的控制流图 (CFG)，其中所有分支在执行时互斥并到达一个公共汇合点，且变量 $x$ 为整数类型：\n\n- 入口块 $\\mathrm{E}$ 非确定性地分裂到三个前驱块 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$。\n- 在 $\\mathrm{A}$ 中：赋值 $x_{\\mathrm{A}} := 1$ 并 $\\mathrm{goto}$ 汇合点 $\\mathrm{J}$。\n- 在 $\\mathrm{B}$ 中：赋值 $x_{\\mathrm{B}} := 2$ 并 $\\mathrm{goto}$ 汇合点 $\\mathrm{J}$。\n- 在 $\\mathrm{C}$ 中：赋值 $x_{\\mathrm{C}} := 3$ 并 $\\mathrm{goto}$ 汇合点 $\\mathrm{J}$。\n- 在汇合块 $\\mathrm{J}$ 中：定义 $x := \\phi(x_{\\mathrm{A}}, x_{\\mathrm{B}}, x_{\\mathrm{C}})$，然后根据守卫条件分支 `if (x > 1) goto T1 else goto F1`。\n- 在块 $\\mathrm{T1}$ 中：根据守卫条件分支 `if (x  3) goto U else goto F2`。\n- 在块 $\\mathrm{U}$ 中：计算 $y := 3x^{2} - 5x + 7$ 然后停止。\n- 在块 $\\mathrm{F1}$ 和 $\\mathrm{F2}$ 中：不计算 $y$ 直接停止。\n\n从上述基本的 SCCP 定义（值格 $\\{\\bot, c, \\top\\}$、SSA $\\phi$-语义以及通过评估守卫条件得出的控制流边可行性）出发，通过对可行前驱取交集来确定 SCCP 在块 $\\mathrm{U}$ 处为 $x$ 推导出的值，然后计算在块 $\\mathrm{U}$ 处 $y := 3x^{2} - 5x + 7$ 的结果值。\n\n请将 $y$ 的最终答案以单个实数值的形式给出。无需四舍五入。", "solution": "该问题要求我们追踪稀疏条件常量传播 (SCCP) 算法，以确定块 $\\mathrm{U}$ 中变量 $y$ 的值。SCCP 是一种乐观算法，它同时确定控制流的可达性和变量的值。\n\n算法开始时，所有变量的格值为 $\\bot$ (未定义)，并且所有控制流边都被视为不可执行。分析从入口块 $\\mathrm{E}$ 开始。\n\n1.  **初始传播：** 入口块 $\\mathrm{E}$ 无条件地将控制权转移到块 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$。因此，边 $\\mathrm{E} \\to \\mathrm{A}$、$\\mathrm{E} \\to \\mathrm{B}$ 和 $\\mathrm{E} \\to \\mathrm{C}$ 被标记为可执行。\n    *   在块 $\\mathrm{A}$ 中，变量 $x_{\\mathrm{A}}$ 被赋以常量值 $1$。其格值变为 $1$。\n    *   在块 $\\mathrm{B}$ 中，$x_{\\mathrm{B}}$ 被赋以 $2$。其格值变为 $2$。\n    *   在块 $\\mathrm{C}$ 中，$x_{\\mathrm{C}}$ 被赋以 $3$。其格值变为 $3$。\n    *   由于块 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$ 都进入汇合块 $\\mathrm{J}$，因此边 $\\mathrm{A} \\to \\mathrm{J}$、$\\mathrm{B} \\to \\mathrm{J}$ 和 $\\mathrm{C} \\to \\mathrm{J}$ 也被标记为可执行。\n\n2.  **在块 J 处的 Phi-函数求值：** 块 $\\mathrm{J}$ 可从三个可执行的前驱块到达：$\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$。$x$ 的值由 $\\phi$-函数确定：$x := \\phi(x_{\\mathrm{A}}, x_{\\mathrm{B}}, x_{\\mathrm{C}})$。$\\phi$-函数的值是其所有来自可执行前驱路径的参数值的交（用 $\\sqcap$ 表示）。\n    \n    输入的格值为 $1$、$2$ 和 $3$。交运算定义为：如果 $c_1=c_2$，则 $c_1 \\sqcap c_2 = c_1$；如果 $c_1 \\neq c_2$，则 $c_1 \\sqcap c_2 = \\top$。\n    \n    在块 $\\mathrm{J}$ 处 $x$ 的值计算如下：\n    $$ \\text{val}(x) = \\text{val}(x_{\\mathrm{A}}) \\sqcap \\text{val}(x_{\\mathrm{B}}) \\sqcap \\text{val}(x_{\\mathrm{C}}) = 1 \\sqcap 2 \\sqcap 3 $$\n    由于这些常量不相等，交运算的结果是 $\\top$ (过度定义)。\n    $$ \\text{val}(x) = \\top $$\n\n3.  **条件分支传播：** 一个朴素的 SCCP 应用会将 $\\text{val}(x) = \\top$ 传播到所有 $x$ 的使用点。这意味着条件 `if (x > 1)` 和 `if (x  3)` 无法解析为常量布尔值。算法将不得不假设每个条件语句的两个分支都是可执行的。这将意味着块 $\\mathrm{U}$ 是可达的，但由于 $\\text{val}(x) = \\top$，会导致 $\\text{val}(y)=\\top$，这不是一个数值答案。\n\n    然而，SCCP 中的“条件”一词意味着更强大的分析。该算法明白，要到达程序中的某个点，特定条件必须求值为真。我们必须确定 *在块 $\\mathrm{U}$ 处* $x$ 的具体值。\n\n4.  **对块 U 的路径敏感推导：**\n    *   从 $\\mathrm{J}$ 到达块 $\\mathrm{T1}$，条件 $(x > 1)$ 必须为真。\n    *   从 $\\mathrm{T1}$ 到达块 $\\mathrm{U}$，条件 $(x  3)$ 必须为真。\n    *   因此，对于任何到达块 $\\mathrm{U}$ 的执行路径，该路径上 $x$ 的值必须满足组合条件 $(x > 1) \\land (x  3)$。\n\n5.  **提炼 x 的值：** 进入块 $\\mathrm{J}$ 时 $x$ 可能的常量值是 $\\{1, 2, 3\\}$，分别对应来自块 $\\{\\mathrm{A}, \\mathrm{B}, \\mathrm{C}\\}$ 的路径。我们分析这些初始值中哪些与到达块 $\\mathrm{U}$ 所需的条件一致。\n    *   如果 $x=1$（来自路径 $\\mathrm{A}$），条件 $(x > 1)$ 为假。程序将走 `else` 分支到 $\\mathrm{F1}$。块 $\\mathrm{U}$ 不可达。\n    *   如果 $x=2$（来自路径 $\\mathrm{B}$），条件 $(x > 1)$ 为真。控制权传递到 $\\mathrm{T1}$。在 $\\mathrm{T1}$ 中，条件 $(x  3)$ 也为真。控制权传递到 $\\mathrm{U}$。此路径是可行的。\n    *   如果 $x=3$（来自路径 $\\mathrm{C}$），条件 $(x > 1)$ 为真。控制权传递到 $\\mathrm{T1}$。在 $\\mathrm{T1}$ 中，条件 $(x  3)$ 为假。程序走 `else` 分支到 $\\mathrm{F2}$。块 $\\mathrm{U}$ 不可达。\n    \n    分析表明，唯一能够到达块 $\\mathrm{U}$ 的路径是源自块 $\\mathrm{B}$ 的那条。因此，SCCP 可以推断出，如果执行到达块 $\\mathrm{U}$，那么 $x$ 的值必须是 $2$。\n\n6.  **最终计算：** 根据在块 $\\mathrm{U}$ 处推导出的值 $x=2$，我们可以计算 $y$ 的值。\n    $$ y := 3x^{2} - 5x + 7 $$\n    代入 $x=2$：\n    $$ y = 3(2)^{2} - 5(2) + 7 $$\n    $$ y = 3(4) - 10 + 7 $$\n    $$ y = 12 - 10 + 7 $$\n    $$ y = 2 + 7 $$\n    $$ y = 9 $$\n\n在块 $\\mathrm{U}$ 中计算出的 $y$ 的值为 $9$。", "answer": "$$\\boxed{9}$$", "id": "3630560"}]}