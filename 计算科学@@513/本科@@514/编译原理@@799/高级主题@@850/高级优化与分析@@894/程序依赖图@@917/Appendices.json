{"hands_on_practices": [{"introduction": "构建程序依赖图（PDG）的第一步是准确识别控制依赖关系。这个练习 [@problem_id:3664766] 提供了一个包含嵌套循环和条件语句的复杂代码片段，旨在通过动手实践来巩固你对控制依赖形式化定义的理解。通过基于后支配（post-dominance）关系来确定哪些语句的执行由哪些分支谓词控制，你将掌握构建PDG控制依赖部分的核心技能。", "problem": "给定以下带有行号标签的命令式伪代码结构化片段。所有赋值和条件都以数学符号表示，并且为了清晰起见，每个可执行行都标记为 $L_{k}$。在 return 语句后紧接着有一个单一的出口节点 $E$。\n\n$L_{1}$: $s := 0$\n\n$L_{2}$: $i := 0$\n\n$L_{3}$: while ($i  n$) do\n- $L_{4}$: if ($p(i)$) then\n  - $L_{5}$: $s := s + a[i]$\n  - $L_{6}$: if ($q(i)$) then\n    - $L_{7}$: $s := s + 1$\n    else\n    - $L_{9}$: $s := s - 1$\n- else\n  - $L_{12}$: $j := 0$\n  - $L_{13}$: while ($j  m$) do\n    - $L_{14}$: if ($r(j)$) then\n      - $L_{15}$: $s := s + b[j]$\n    end if\n    - $L_{17}$: $j := j + 1$\n  end while\n- end if\n- $L_{20}$: $i := i + 1$\nend while\n\n$L_{22}$: return $s$\n\n$E$: exit\n\n为此代码片段构建控制流图（CFG），然后构建程序依赖图（PDG），仅关注控制依赖。在具有指定出口节点的 CFG 上，使用基于后支配节点的标准控制依赖定义。具体来说，当且仅当存在 $X$ 的一个后继节点 $W$，使得 $Y$ 后支配 $W$ 但 $Y$ 不后支配 $X$ 时，节点 $Y$ 控制依赖于节点 $X$。当且仅当从 $V$到 $E$ 的每条路径都经过 $U$ 时，节点 $U$ 后支配节点 $V$。\n\n将每个谓词行（$L_{3}$, $L_{4}$, $L_{6}$, $L_{13}$, $L_{14}$）和每个可执行语句行（$L_{1}$, $L_{2}$, $L_{5}$, $L_{7}$, $L_{9}$, $L_{12}$, $L_{15}$, $L_{17}$, $L_{20}$, $L_{22}$）视为 PDG 节点。忽略任何特殊的入口节点，并且不要从一个虚拟的起始节点添加控制依赖边。不要将出口节点 $E$ 作为 PDG 节点。\n\n您的任务：基于上述定义和此代码的 CFG，识别 PDG 中的所有控制依赖边，并计算这些边的总数。以精确整数形式提供最终答案（不要四舍五入）。", "solution": "用户希望确定给定代码片段的程序依赖图（PDG）中控制依赖边的总数。该分析将基于所提供的、使用后支配节点的控制依赖定义。\n\n解决过程包括三个连续的步骤：\n1.  为给定代码构建控制流图（CFG）。\n2.  确定 CFG 中每个节点的后支配节点集。\n3.  应用给定的控制依赖定义来识别所有控制依赖边并进行计数。\n\n### 步骤 1：构建控制流图（CFG）\n\nCFG 的节点对应于伪代码的带标签行和一个单一的出口节点 $E$。边代表了这些行之间的控制流。\n\nCFG 的边如下所示：\n- $L_{1} \\to L_{2}$\n- $L_{2} \\to L_{3}$\n- $L_{3} \\to L_{4}$（`while` 的真分支）\n- $L_{3} \\to L_{22}$（`while` 的假分支）\n- $L_{4} \\to L_{5}$（`if p(i)` 的真分支）\n- $L_{4} \\to L_{12}$（`if p(i)` 的假分支）\n- $L_{5} \\to L_{6}$\n- $L_{6} \\to L_{7}$（`if q(i)` 的真分支）\n- $L_{6} \\to L_{9}$（`if q(i)` 的假分支）\n- $L_{7} \\to L_{20}$（`if q(i)` 真分支的结尾）\n- $L_{9} \\to L_{20}$（`if q(i)` 假分支的结尾）\n- $L_{12} \\to L_{13}$\n- $L_{13} \\to L_{14}$（`while` 的真分支）\n- $L_{13} \\to L_{20}$（`while` 的假分支）\n- $L_{14} \\to L_{15}$（`if r(j)` 的真分支）\n- $L_{14} \\to L_{17}$（`if r(j)` 的假分支）\n- $L_{15} \\to L_{17}$（`if r(j)` 真分支的结尾）\n- $L_{17} \\to L_{13}$（循环返回）\n- $L_{20} \\to L_{3}$（循环返回）\n- $L_{22} \\to E$\n\n### 步骤 2：确定后支配节点\n\n如果从节点 $V$ 到出口节点 $E$ 的每条路径都包含节点 $U$，则节点 $U$ 后支配节点 $V$。我们将 $V$ 的后支配节点集表示为 $\\text{pdom}(V)$。我们将此定义应用于 CFG 中的每个节点。\n\n- $\\text{pdom}(E) = \\{E\\}$\n- 从 $L_{22}$ 出发，到 $E$ 的唯一路径是 $L_{22} \\to E$。因此，$\\text{pdom}(L_{22}) = \\{L_{22}, E\\}$。\n- 从代码中的任何节点出发，到 $E$ 的每条路径都必须经过 $L_{22}$。所以，$L_{22}$ 后支配所有其他节点。\n- 从外部 `while` 循环内的任何节点（从 $L_4$ 到 $L_{20}$）出发，任何路径最终都必须通过边 $L_3 \\to L_{22}$ 退出循环。因此，$L_3$ 是循环体中任何导致返回到它的节点（例如 $L_{20}$）的后支配节点。\n- 通过系统地分析 CFG，我们确定每个相关节点的后支配节点集：\n  - $\\text{pdom}(L_{22}) = \\{L_{22}, E\\}$\n  - $\\text{pdom}(L_{20}) = \\{L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{17}) = \\{L_{17}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{15}) = \\{L_{15}\\} \\cup \\text{pdom}(L_{17}) = \\{L_{15}, L_{17}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{14})$：从 $L_{14}$ 出发的路径在 $L_{17}$ 处汇合。所以，$\\text{pdom}(L_{14}) = \\{L_{14}\\} \\cup \\text{pdom}(L_{17}) = \\{L_{14}, L_{17}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$。\n  - $\\text{pdom}(L_{13})$：从 $L_{13}$ 出发的路径可以循环，但最终必须退出到 $L_{20}$。所以，$\\text{pdom}(L_{13}) = \\{L_{13}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{13}, L_{20}, L_{3}, L_{22}, E\\}$。\n  - $\\text{pdom}(L_{12}) = \\{L_{12}\\} \\cup \\text{pdom}(L_{13}) = \\{L_{12}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{9}) = \\{L_{9}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{9}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{7}) = \\{L_{7}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{7}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{6})$：从 $L_6$ 出发的路径在 $L_{20}$ 处汇合。所以，$\\text{pdom}(L_{6}) = \\{L_{6}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{6}, L_{20}, L_{3}, L_{22}, E\\}$。\n  - $\\text{pdom}(L_{5}) = \\{L_{5}\\} \\cup \\text{pdom}(L_{6}) = \\{L_{5}, L_{6}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{4})$：从 $L_4$ 出发的路径在 $L_{20}$ 处汇合。所以，$\\text{pdom}(L_{4}) = \\{L_{4}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{4}, L_{20}, L_{3}, L_{22}, E\\}$。\n  - $\\text{pdom}(L_{3})$：从 $L_3$ 出发的路径可以循环，但最终必须退出到 $L_{22}$。所以，$\\text{pdom}(L_{3}) = \\{L_{3}\\} \\cup \\text{pdom}(L_{22}) = \\{L_{3}, L_{22}, E\\}$。\n\n### 步骤 3：应用控制依赖的定义\n\n问题陈述：“当且仅当存在 $X$ 的一个后继节点 $W$，使得 $Y$ 后支配 $W$ 但 $Y$ 不后支配 $X$ 时，节点 $Y$ 控制依赖于节点 $X$。”我们用 $X \\to_c Y$ 来表示这种关系。我们将此定义应用于每个谓词节点 $X$。\n\n**1. $X = L_3$ (谓词 `while i  n`)**\n- $X$ 的后继节点：$W_T = L_4$，$W_F = L_{22}$。\n- 条件：$Y \\notin \\text{pdom}(L_3) = \\{L_3, L_{22}, E\\}$。\n- 对于 $W = L_4$：$Y \\in \\text{pdom}(L_4) = \\{L_4, L_{20}, L_3, L_{22}, E\\}$。同时满足这两个条件的节点是 $Y=L_4$ 和 $Y=L_{20}$。\n- 对于 $W = L_{22}$：$Y \\in \\text{pdom}(L_{22}) = \\{L_{22}, E\\}$。没有节点 $Y$ 能同时满足这两个条件。\n- 边：$(L_3, L_4), (L_3, L_{20})$。总计：2。\n\n**2. $X = L_4$ (谓词 `if p(i)`)**\n- $X$ 的后继节点：$W_T = L_5$，$W_F = L_{12}$。\n- 条件：$Y \\notin \\text{pdom}(L_4) = \\{L_4, L_{20}, L_3, L_{22}, E\\}$。\n- 对于 $W = L_5$：$Y \\in \\text{pdom}(L_5) = \\{L_5, L_6, L_{20}, L_3, L_{22}, E\\}$。同时满足这两个条件的节点是 $Y=L_5$ 和 $Y=L_6$。\n- 对于 $W = L_{12}$：$Y \\in \\text{pdom}(L_{12}) = \\{L_{12}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。同时满足这两个条件的节点是 $Y=L_{12}$ 和 $Y=L_{13}$。\n- 边：$(L_4, L_5), (L_4, L_6), (L_4, L_{12}), (L_4, L_{13})$。总计：4。\n\n**3. $X = L_6$ (谓词 `if q(i)`)**\n- $X$ 的后继节点：$W_T = L_7$, $W_F = L_9$。\n- 条件：$Y \\notin \\text{pdom}(L_6) = \\{L_6, L_{20}, L_3, L_{22}, E\\}$。\n- 对于 $W = L_7$：$Y \\in \\text{pdom}(L_7) = \\{L_7, L_{20}, L_3, L_{22}, E\\}$。同时满足这两个条件的节点是 $Y=L_7$。\n- 对于 $W = L_9$：$Y \\in \\text{pdom}(L_9) = \\{L_9, L_{20}, L_3, L_{22}, E\\}$。同时满足这两个条件的节点是 $Y=L_9$。\n- 边：$(L_6, L_7), (L_6, L_9)$。总计：2。\n\n**4. $X = L_{13}$ (谓词 `while j  m`)**\n- $X$ 的后继节点：$W_T = L_{14}$, $W_F = L_{20}$。\n- 条件：$Y \\notin \\text{pdom}(L_{13}) = \\{L_{13}, L_{20}, L_3, L_{22}, E\\}$。\n- 对于 $W = L_{14}$：$Y \\in \\text{pdom}(L_{14}) = \\{L_{14}, L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。同时满足这两个条件的节点是 $Y=L_{14}$ 和 $Y=L_{17}$。\n- 对于 $W = L_{20}$：$Y \\in \\text{pdom}(L_{20}) = \\{L_{20}, L_3, L_{22}, E\\}$。没有节点 $Y$ 能同时满足这两个条件。\n- 边：$(L_{13}, L_{14}), (L_{13}, L_{17})$。总计：2。\n\n**5. $X = L_{14}$ (谓词 `if r(j)`)**\n- $X$ 的后继节点：$W_T = L_{15}$, $W_F = L_{17}$。\n- 条件：$Y \\notin \\text{pdom}(L_{14}) = \\{L_{14}, L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。\n- 对于 $W = L_{15}$：$Y \\in \\text{pdom}(L_{15}) = \\{L_{15}, L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。同时满足这两个条件的节点是 $Y=L_{15}$。\n- 对于 $W = L_{17}$：$Y \\in \\text{pdom}(L_{17}) = \\{L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。没有节点 $Y$ 能同时满足这两个条件，因为任何这样的 $Y$ 也都在 $\\text{pdom}(L_{14})$ 中。\n- 边：$(L_{14}, L_{15})$。总计：1。\n\n### 最终计数\n将每个谓词节点的控制依赖边数量相加：\n- 来自 $L_3$：$2$ 条边\n- 来自 $L_4$：$4$ 条边\n- 来自 $L_6$：$2$ 条边\n- 来自 $L_{13}$：$2$ 条边\n- 来自 $L_{14}$：$1$ 条边\n\n总边数 = $2 + 4 + 2 + 2 + 1 = 11$。", "answer": "$$\\boxed{11}$$", "id": "3664766"}, {"introduction": "理解程序依赖图不仅在于如何构建它，更在于如何利用它来分析和指导代码变换。这个练习 [@problem_id:3664735] 探讨了一项关键的编译器优化技术——“if-conversion”（谓词化），它将分支结构转化为无分支的直线代码。通过分析这种变换前后PDG的变化，你将深刻理解控制依赖如何转化为数据依赖，这是利用现代处理器特性的重要手段。", "problem": "考虑以下结构化代码片段及其控制流图 (CFG)：\n\n- 代码：\n  - if ($x  0$) then { $y := x + 1$ } else { $y := 0$ }\n  - $z := y * 2$\n\n- CFG 节点和边：\n  - $B_0$ (入口) $\\to B_1$\n  - $B_1$：条件为 ($x  0$)，真边指向 $B_2$，假边指向 $B_3$\n  - $B_2$：$y := x + 1$，然后 $\\to B_4$\n  - $B_3$：$y := 0$，然后 $\\to B_4$\n  - $B_4$：$z := y * 2$，然后退出\n\n使用编译器理论中的标准定义：\n\n- 程序依赖图 (PDG) 中的控制依赖：一个节点 $Y$ 控制依赖于一个节点 $X$，当且仅当 (i) 存在一条从 $X$ 到 $Y$ 的路径，在该路径上 $Y$ 后支配除 $X$ 之外的所有节点，并且 (ii) $Y$ 不后支配 $X$。\n- 控制流图 (CFG) 中的后支配：如果从节点 $B$ 到出口的每条路径都包含节点 $A$，则节点 $A$ 后支配节点 $B$。\n\n现在执行一次 if-转换 (谓词化)，通过引入谓词 $p := (x  0)$ 和一个直线计算\n$y := \\text{select}(p, x + 1, 0)$，\n来移除分支，随后是\n$z := y * 2$。\n假设 $\\text{select}(p, t, e)$ 在 $p$ 为真时表示值 $t$，在 $p$ 为假时表示值 $e$。\n\n问题：哪个陈述正确地描述了 if-转换前后 $PDG$ 中的控制依赖关系，并指定了正确的 $PDG$ 更新以反映基于分支的控制依赖的移除？\n\n选择一项：\n\nA. if-转换前：存在从分支节点 $B_1$ 到 $y := x + 1$ (在 $B_2$ 中) 和到 $y := 0$ (在 $B_3$ 中) 的控制依赖边，但没有到 $z := y * 2$ (在 $B_4$ 中) 的控制依赖边。if-转换后：基于分支的控制依赖被移除；没有控制依赖从 $p$ 发出，并且 $PDG$ 增加了一个从 $p$ 的定义到定义 $y$ 的 $\\text{select}$ 的数据依赖。\n\nB. if-转换前：存在从 $B_1$ 到 $y := x + 1$、到 $y := 0$ 以及到 $z := y * 2$ 的控制依赖边。if-转换后：控制依赖仍然存在，因为 $z$ 在语义上仍然依赖于该条件，所以 $PDG$ 保留了从 $p$ 到 $z$ 的控制依赖。\n\nC. if-转换前：只有 $y := 0$ 控制依赖于 $B_1$，因为它位于假边上；$y := x + 1$ 不存在控制依赖。if-转换后：$y$ 和 $z$ 都控制依赖于 $p$。\n\nD. if-转换前：不存在控制依赖，因为两个分支都在 $B_4$ 处重新汇合。if-转换后：引入一个从 $p$ 到 $z$ 的控制依赖，因为 $z$ 跟在 $y$ 的选择之后。", "solution": "### 解题推导\n\n#### 第 1 部分：if-转换前的分析\n\n我们必须使用给定的定义来确定原始 CFG 中的控制依赖。这首先需要建立后支配关系。$\\text{exit}$ 节点是 CFG 的唯一出口点。\n\n1.  **后支配分析**：\n    -   从 $B_1$、$B_2$ 或 $B_3$ 出发的任何路径都必须经过 $B_4$ 才能到达 $\\text{exit}$ 节点。例如，从 $B_1$ 到 $\\text{exit}$ 有两条路径：$B_1 \\to B_2 \\to B_4 \\to \\text{exit}$ 和 $B_1 \\to B_3 \\to B_4 \\to \\text{exit}$。两条路径都包含 $B_4$。因此，$B_4$ 后支配 $B_1$、$B_2$ 和 $B_3$。\n    -   $B_2$ 是否后支配 $B_1$？不，因为存在一条从 $B_1$ 到 $\\text{exit}$ 的路径绕过了 $B_2$（即通过 $B_3$ 的路径）。\n    -   $B_3$ 是否后支配 $B_1$？不，因为存在一条从 $B_1$ 到 $\\text{exit}$ 的路径绕过了 $B_3$（即通过 $B_2$ 的路径）。\n\n2.  **控制依赖分析**：我们应用定义：如果 (i) 存在一条从 $X$ 到 $Y$ 的路径，其中 $Y$ 后支配 $X$ 和 $Y$ 之间的所有节点，并且 (ii) $Y$ 不后支配 $X$，则 $Y$ 控制依赖于 $X$。令 $X = B_1$。\n\n    -   **$B_2$ (包含 $y := x + 1$) 是否控制依赖于 $B_1$？**\n        -   (i) 考虑路径 $B_1 \\to B_2$。没有中间节点，因此 $B_2$ 后支配 $B_1$ 和 $B_2$ 之间所有节点的条件是空洞地为真。\n        -   (ii) $B_2$ 是否不后支配 $B_1$？是的，如上所述。\n        -   结论：**是**，$B_2$ 控制依赖于 $B_1$。存在一条从 $B_1$ 到 $B_2$ 的控制依赖边。\n\n    -   **$B_3$ (包含 $y := 0$) 是否控制依赖于 $B_1$？**\n        -   (i) 考虑路径 $B_1 \\to B_3$。没有中间节点，因此该条件是空洞地为真。\n        -   (ii) $B_3$ 是否不后支配 $B_1$？是的，如上所述。\n        -   结论：**是**，$B_3$ 控制依赖于 $B_1$。存在一条从 $B_1$ 到 $B_3$ 的控制依赖边。\n\n    -   **$B_4$ (包含 $z := y * 2$) 是否控制依赖于 $B_1$？**\n        -   (i) 考虑路径 $B_1 \\to B_2 \\to B_4$。中间节点是 $B_2$。$B_4$ 是否后支配 $B_2$？是的。该条件对于此路径成立。\n        -   (ii) $B_4$ 是否不后支配 $B_1$？不，这是错误的。我们已经确定 $B_4$ *确实*后支配 $B_1$，因为所有从 $B_1$ 出发的路径都必须经过 $B_4$。\n        -   结论：**否**，$B_4$ 不控制依赖于 $B_1$，因为条件 (ii) 不满足。\n\n    **转换前总结**：$B_2$ 和 $B_3$ 中的语句控制依赖于 $B_1$ 中的分支。$B_4$ 中的语句则不依赖。\n\n#### 第 2 部分：if-转换后的分析\n\n代码被转换为一个直线序列：\n1.  $p := (x > 0)$\n2.  $y := \\text{select}(p, x + 1, 0)$\n3.  $z := y * 2$\n\n1.  **控制流**：这个指令序列构成一个单一的基本块。现在的 CFG 非常简单：$B'_{entry} \\to B'_{code} \\to B'_{exit}$。没有分支。\n\n2.  **控制依赖**：由于转换后的 CFG 中没有条件分支，因此不存在其他节点的执行在控制流意义上依赖于某个节点的情况。由分支产生的控制依赖概念在直线代码中是不存在的。因此，转换后的程序中不存在控制依赖。\n\n3.  **PDG 更新**：从 $B_1$ 到 $B_2$ 和 $B_3$ 的原始控制依赖被移除。if-转换的目的就是将控制依赖转换为数据依赖。\n    -   $y$ 的值现在依赖于谓词 $p$ 的值。这创建了一个从 $p$ 的定义 ($p := (x > 0)$) 到其在 $\\text{select}$ 指令 ($y := \\text{select}(p, ...)$) 中的使用的**数据依赖**。\n    -   从 $y$ 的定义到其在 $z := y * 2$ 中的使用的数据依赖仍然存在。\n\n    **转换后总结**：基于分支的控制依赖被消除。它们被一个新的、从谓词定义到其使用的数据依赖所取代。\n\n### 逐项分析\n\n-   **A. if-转换前：存在从分支节点 $B_1$ 到 $y := x + 1$ (在 $B_2$ 中) 和到 $y := 0$ (在 $B_3$ 中) 的控制依赖边，但没有到 $z := y * 2$ (在 $B_4$ 中) 的控制依赖边。if-转换后：基于分支的控制依赖被移除；没有控制依赖从 $p$ 发出，并且 $PDG$ 增加了一个从 $p$ 的定义到定义 $y$ 的 $\\text{select}$ 的数据依赖。**\n    -   “转换前”的描述与我们的推导完全一致。$B_2$ 和 $B_3$ 控制依赖于 $B_1$，但 $B_4$ 不依赖。\n    -   “转换后”的描述也完全一致。if-转换移除了分支及其相关的控制依赖。形式模型用对谓词 $p$ 的数据依赖来替代它。\n    -   **结论：正确。**\n\n-   **B. if-转换前：存在从 $B_1$ 到 $y := x + 1$、到 $y := 0$ 以及到 $z := y * 2$ 的控制依赖边。if-转换后：控制依赖仍然存在，因为 $z$ 在语义上仍然依赖于该条件，所以 $PDG$ 保留了从 $p$ 到 $z$ 的控制依赖。**\n    -   “转换前”部分不正确。它错误地声称 $z := y * 2$ (在 $B_4$ 中) 控制依赖于 $B_1$。如前所示，$B_4$ 后支配 $B_1$，这违反了控制依赖的定义。\n    -   “转换后”部分不正确。它混淆了语义依赖与控制依赖的形式化定义。if-转换后，没有分支，因此没有控制依赖。语义上的联系由数据依赖来捕获。\n    -   **结论：不正确。**\n\n-   **C. if-转换前：只有 $y := 0$ 控制依赖于 $B_1$，因为它位于假边上；$y := x + 1$ 不存在控制依赖。if-转换后：$y$ 和 $z$ 都控制依赖于 $p$。**\n    -   “转换前”部分不正确。控制依赖的定义对称地适用于不后支配该分支的真假后继路径。$B_2$ 和 $B_3$ 都控制依赖于 $B_1$。\n    -   “转换后”部分不正确。如对选项 B 的解释，转换后的直线代码中不存在控制依赖。\n    -   **结论：不正确。**\n\n-   **D. if-转换前：不存在控制依赖，因为两个分支都在 $B_4$ 处重新汇合。if-转换后：引入一个从 $p$ 到 $z$ 的控制依赖，因为 $z$ 跟在 $y$ 的选择之后。**\n    -   “转换前”部分不正确。$B_4$ 处的重新汇合是 $B_4$ *不*控制依赖于 $B_1$ 的原因，但这恰恰是发散路径上的节点*是*控制依赖的原因。该陈述误解了重新汇合的后果。\n    -   “转换后”部分不正确。它错误地指出引入了一个*控制*依赖。if-转换是用*数据*依赖取代控制依赖。\n    -   **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3664735"}, {"introduction": "程序依赖图在发掘并行性方面扮演着至关重要的角色，尤其是在分析循环的迭代间依赖时。这个练习 [@problem_id:3664740] 将焦点转向PDG中的数据依赖，特别是“循环携带依赖”（loop-carried dependence）。通过分析数组下标来检测是否存在跨迭代的真数据依赖（流依赖），你可以直接判断一个循环是否可以被安全地自动并行化，这是编译器优化中最具挑战性也最有价值的任务之一。", "problem": "考虑以下关于整数归纳变量 $i$ 的单循环：\n- 对于 $i$ 从 $2$ 到 $N-1$（其中 $N \\geq 6$），执行由三个语句组成的循环体：\n  - $S_1$：$X[i+2] := Y[i] + Z[i-1]$，\n  - $S_2$：$Y[i+1] := X[i] + W[i]$，\n  - $S_3$：$Z[i-1] := Y[i-2] + 5$。\n假设数组 $X$、$Y$、$Z$ 和 $W$ 的大小和初始化均已设置，以使所有使用的下标都有效，并且其语义遵循具有单语句赋值执行和在每次迭代内严格按 $S_1$、$S_2$、$S_3$ 顺序求值的语言中循环的标准顺序语义。\n\n在程序依赖图（PDG）中，节点对应于语句 $S_1$、$S_2$ 和 $S_3$，边表示控制依赖和数据依赖。当源语句写入一个内存位置，而后续的汇语句读取该位置时，就存在从源语句到汇语句的真数据依赖（流依赖）。当源和汇位于不同的迭代中时，存在循环携带的真数据依赖。为了确定并行化的合法性，可以忽略反依赖和输出依赖，因为它们可以通过重命名来消除。\n\n仅使用真数据依赖、循环携带依赖的基本定义，以及“两个数组访问当且仅当下标相等时引用相同的内存位置”这一事实，分析由循环体导出的 PDG 以：\n- 基于 $S_1$、$S_2$ 和 $S_3$ 中的数组下标，提取循环携带的真数据依赖距离集合。\n- 令 $\\mathcal{D}$ 表示此循环中存在的所有循环携带真依赖的正整数距离 $d$ 的集合。如果 $\\mathcal{D}$ 非空，定义 $d^{\\star}$ 为 $\\mathcal{D}$ 的最小元素。\n- 在标准语义下，定义跨迭代并行化循环的合法性指示符 $L$ 为：如果循环可以合法地并行化（即不存在循环携带的真数据依赖），则 $L=1$；否则 $L=0$。\n\n将您的最终答案以包含 $d^{\\star}$ 和 $L$ 的行矩阵形式给出。无需四舍五入，也无需单位。如果 $\\mathcal{D}$ 为空，则按惯例取 $d^{\\star}$ 为 $0$。", "solution": "用户要求分析一段代码片段，以找到循环携带的真数据依赖。\n\n**计划：**\n1.  **识别潜在依赖：** 需要检查所有语句对（$S_1$、$S_2$、$S_3$）之间的真数据依赖（写后读）。如果迭代 $j$ 中的语句 $S_i$ 写入一个内存位置，而迭代 $l$ 中的语句 $S_k$ 随后读取该位置，则存在从 $S_i$ 到 $S_k$ 的依赖。\n2.  **系统性分析：** 将检查所有9个可能的语句对组合。\n3.  **表示法：** 将迭代 $i$ 中语句 $S_k$ 的一个实例表示为 $S_k(i)$。如果 $S_a(i)$ 写入一个位置，$S_b(j)$ 读取该位置，并且 $S_b(j)$ 在 $S_a(i)$ 之后执行，那么就存在从 $S_a(i)$ 到 $S_b(j)$ 的依赖。\n4.  **执行顺序：** 在一次迭代 $i$ 中，顺序是 $S_1(i)$、$S_2(i)$、$S_3(i)$。对于不同的迭代 $i$ 和 $j$（其中 $i  j$），迭代 $i$ 中的所有语句都在迭代 $j$ 中的所有语句之前执行。\n5.  **循环携带 vs 循环无关：** 如果依赖关系在同一次迭代中的语句之间（$i=j$），则它是循环无关的。如果依赖关系在不同迭代中的语句之间（$i  j$），则它是循环携带的。问题要求的是循环携带依赖，其距离为 $d = j - i$。\n\n**分解语句：**\n*   $S_1$: $X[i+2] := \\dots$ (写入 $X$)\n*   $S_1$: $\\dots := Y[i] + Z[i-1]$ (从 $Y$ 和 $Z$ 读取)\n*   $S_2$: $Y[i+1] := \\dots$ (写入 $Y$)\n*   $S_2$: $\\dots := X[i] + W[i]$ (从 $X$ 和 $W$ 读取)\n*   $S_3$: $Z[i-1] := \\dots$ (写入 $Z$)\n*   $S_3$: $\\dots := Y[i-2] + 5$ (从 $Y$ 读取)\n\n**寻找循环携带的真数据依赖 ($i  j$)**\n\n**情况1：$S_1 \\to S_2$ (写(X) $\\to$ 读(X))**\n*   $S_1(i)$ 写入 $X[i+2]$。\n*   $S_2(j)$ 读取 $X[j]$。\n*   要存在依赖，内存位置必须相同：$i+2 = j$。\n*   因为我们正在寻找循环携带依赖，所以需要 $i  j$。\n*   将 $j = i+2$ 代入 $i  j$ 得到 $i  i+2$，这始终为真。\n*   依赖距离为 $d = j - i = (i+2) - i = 2$。\n*   这是一个从 $S_1$ 到 $S_2$ 的循环携带真数据依赖，距离为 $d=2$。\n\n**情况2：$S_2 \\to S_1$ (写(Y) $\\to$ 读(Y))**\n*   $S_2(i)$ 写入 $Y[i+1]$。\n*   $S_1(j)$ 读取 $Y[j]$。\n*   要存在依赖：$i+1 = j$。\n*   我们需要 $i  j$。将 $j = i+1$ 代入得到 $i  i+1$，这为真。\n*   依赖距离为 $d = j - i = (i+1) - i = 1$。\n*   这是一个从 $S_2$ 到 $S_1$ 的循环携带真数据依赖，距离为 $d=1$。\n\n**情况3：$S_2 \\to S_3$ (写(Y) $\\to$ 读(Y))**\n*   $S_2(i)$ 写入 $Y[i+1]$。\n*   $S_3(j)$ 读取 $Y[j-2]$。\n*   要存在依赖：$i+1 = j-2$，这意味着 $j = i+3$。\n*   我们需要 $i  j$。将 $j = i+3$ 代入得到 $i  i+3$，这为真。\n*   依赖距离为 $d = j - i = (i+3) - i = 3$。\n*   这是一个从 $S_2$ 到 $S_3$ 的循环携带真数据依赖，距离为 $d=3$。\n\n**情况4：$S_3 \\to S_1$ (写(Z) $\\to$ 读(Z))**\n*   $S_3(i)$ 写入 $Z[i-1]$。\n*   $S_1(j)$ 读取 $Z[j-1]$。\n*   要存在依赖：$i-1 = j-1$，这意味着 $i=j$。\n*   这是一个循环无关依赖，而非循环携带依赖。然而，在同一次迭代 $i$ 中，$S_1(i)$ 在 $S_3(i)$ *之前*执行。因此，不存在从 $S_3(i)$ 到 $S_1(i)$ 的真（流）依赖。对于流依赖 $S_3(i) \\to S_1(j)$，必须有 $i  j$。但数组下标要求 $i=j$，这是一个矛盾。因此，不存在这样的真依赖。\n\n**其他情况：**\n通过检查所有其他语句对和数组的组合（例如，$S_1 \\to S_3$, $S_3 \\to S_2$ 等），可以发现它们之间没有共享相同的数组进行写后读操作，因此不存在其他真数据依赖。\n\n**循环携带真数据依赖总结：**\n1.  在数组 $X$ 上：$S_1(i) \\to S_2(i+2)$。依赖距离 $d_1 = 2$。\n2.  在数组 $Y$ 上：$S_2(i) \\to S_1(i+1)$。依赖距离 $d_2 = 1$。\n3.  在数组 $Y$ 上：$S_2(i) \\to S_3(i+3)$。依赖距离 $d_3 = 3$。\n\n**计算最终结果：**\n\n1.  **$\\mathcal{D}$**: 循环携带真依赖的正整数距离 $d$ 的集合。\n    *   根据我们的分析，$\\mathcal{D} = \\{1, 2, 3\\}$。\n\n2.  **$d^{\\star}$**: $\\mathcal{D}$ 的最小元素。\n    *   因为 $\\mathcal{D} = \\{1, 2, 3\\}$，所以 $d^{\\star} = \\min(\\mathcal{D}) = 1$。\n\n3.  **$L$**: 合法性指示符。\n    *   如果循环可以合法地并行化（没有循环携带的真数据依赖），则 $L=1$；否则 $L=0$。\n    *   因为我们发现了循环携带的真数据依赖（$\\mathcal{D}$ 非空），所以该循环不能直接并行化。\n    *   因此，$L=0$。\n\n**最终答案**\n最终答案应为一个行矩阵，包含 $d^{\\star}$ 和 $L$。\n因此，答案是 $(1, 0)$。", "answer": "$$\\boxed{\\begin{pmatrix}1  0\\end{pmatrix}}$$", "id": "3664740"}]}