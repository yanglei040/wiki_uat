{"hands_on_practices": [{"introduction": "本章的第一个实践是基础性的。你将扮演一位编译器设计者，从零开始构建一个简单的数据流分析来追踪变量的空值状态。通过这个练习 [@problem_id:3659400]，你将揭开编译器如何在程序的控制流图中对变量属性进行形式化推理的神秘面纱，并亲自应用这些规则来识别可以被安全消除的空指针检查。", "problem": "您将在抽象解释和单調数据流框架的框架内，使用两个抽象集合 $\\text{MayNull}$ 和 $\\text{MustNonNull}$，构建并应用一个流敏感、路径不敏感的数据流分析，用于空检查消除。该分析必须从第一性原理推导得出：根据抽象事实对具体执行的过近似来形式化健全性，并使用在合适格上的单调转换函数。假设每条语句具有单赋值语义（无并发），给定变量内具有精确的别名关系，并且对象分配总是返回一个非空引用。程序变量的全集为 $V = \\{x,y,z\\}$。在唯一入口处的初始抽象状态为 $\\text{MayNull} = \\emptyset$ 和 $\\text{MustNonNull} = \\emptyset$。\n\n考虑以下带有条件语句的顺序程序，这些条件语句构成一个控制流图（除非选择分支，否则控制流将顺序执行，并且每个条件语句的两个分支在指定的末端汇合）。此处 $\\texttt{new}$ 表示一次新的非空分配，$\\texttt{null}$ 表示空引用，$\\texttt{check}(v)$ 表示在解引用之前对变量 $v$ 进行的运行时空检查。布尔值 $p$ 和 $q$ 是任意的，并且对于分析是未知的。\n\n($1$) $x := \\texttt{new}$\n\n($2$) $y := \\texttt{null}$\n\n($3$) $\\texttt{check}(x)$\n\n($4$) $\\texttt{check}(y)$\n\n($5$) if $(p)$ then\n\n($6$) $\\quad y := x$\n\n($7$) $\\quad \\texttt{check}(y)$\n\n($8$) else\n\n($9$) $\\quad x := \\texttt{null}$\n\n($10$) $\\quad \\texttt{check}(x)$\n\n($11$) end-if\n\n($12$) $z := y$\n\n($13$) $\\texttt{check}(z)$\n\n($14$) if $(q)$ then\n\n($15$) $\\quad x := \\texttt{new}$\n\n($16$) end-if\n\n($17$) $\\texttt{check}(x)$\n\n($18$) $y := \\texttt{new}$\n\n($19$) $\\texttt{check}(y)$\n\n($20$) $x := y$\n\n($21$) $\\texttt{check}(x)$\n\n任务：\n- 根据“每个具体的空值行为都必须被抽象事实安全地过近似”这一健全性要求，为语句 $x := \\texttt{new}$、$x := \\texttt{null}$ 和 $x := y$ 推导出最小健全转换函数（更新规则），并推导一个用于在控制流汇合点合并抽象状态的合并（join）操作符。您的推导必须从健全过近似和单调性的形式化定义开始。\n- 将您推导出的规则应用于由行 ($1$)–($21$) 定义的控制流图，以计算每个 $\\texttt{check}(\\cdot)$ 位置之前的抽象状态。\n- 一个检查 $\\texttt{check}(v)$ 是可消除的，当且仅当在检查点之前的瞬间 $v \\in \\text{MustNonNull}$。使用您计算出的抽象状态，确定在行 ($3$)、($4$)、($7$)、($10$)、($13$)、($17$)、($19$) 和 ($21$) 的检查中有多少是可消除的。\n\n答案格式：\n- 您的最终答案应为一个整数，等于可消除检查的总数。\n- 无需单位。", "solution": "该问题是有效的。它构成了一个在静态程序分析方面的定义明确的练习，而静态程序分析是编译器设计和计算机科学的核心课题。该问题在科学上基于抽象解释和单调数据流框架的理论。它提供了一套完整的规范，包括程序的控制流图、抽象域、初始条件和解题标准，使其自洽且良定。所用语言客观且形式化。\n\n### 1. 数据流分析的形式化\n\n该分析是流敏感和路径不敏感的。我们的目标是确定每个程序变量是否可能持有 `null` 值。\n\n#### 1.1. 抽象域和格\n在任何给定点，程序的状态由一对集合 $(M_N, M_{NN})$ 来抽象，其中 $V = \\{x, y, z\\}$ 是所有程序变量的集合。\n- $M_N \\subseteq V$ 是**可能为 null** 的变量集合。如果存在至少一条到达当前程序点的路径，在该路径上变量 $v$ 可能被赋为 `null` 值，则 $v$ 属于 $M_N$。\n- $M_{NN} \\subseteq V$ 是**必须非 null** 的变量集合。如果在所有到达当前程序点的路径上，变量 $v$ 都被赋予防保证为非空的值，则 $v$ 属于 $M_{NN}$。\n\n一个一致的抽象状态 $(M_N, M_{NN})$ 必须满足 $M_N \\cap M_{NN} = \\emptyset$，因为一个变量不能同时“必须非 null”和“可能为 null”。\n\n所有抽象状态的集合构成一个格。偏序 $\\sqsubseteq$ 定义如下：\n$(M_{N1}, M_{NN1}) \\sqsubseteq (M_{N2}, M_{NN2})$ 当且仅当 $M_{N1} \\subseteq M_{N2}$ 且 $M_{NN1} \\supseteq M_{NN2}$。\n这个序关系捕捉了精度的概念。如果一个状态在格中“更高”（精度更低），意味着它在 `MayNull` 集合中包含更多变量，在 `MustNonNull` 集合中包含更少变量，这代表了更大的不确定性。\n- 顶元素 $\\top$ 代表最大的不确定性，为 $(V, \\emptyset)$。\n- 程序入口处分析的初始状态给定为 $(\\emptyset, \\emptyset)$。\n\n#### 1.2. Join 操作符\n在一个控制流合并点，我们必须合并来自所有入路径的信息。设 $(M_{N1}, M_{NN1})$ 和 $(M_{N2}, M_{NN2})$ 是来自两个入控制流路径的抽象状态。结果状态 $(M_N, M_{NN})$ 必须是两者的健全过近似。这通过计算两个状态的最小上界（join）来实现，记为 $\\sqcup$。\n\n$$(M_N, M_{NN}) = (M_{N1}, M_{NN1}) \\sqcup (M_{N2}, M_{NN2})$$\n\n- 对于 `MayNull` 集合：如果在*任何*一条入路径上一个变量可能为 null，那么在 join 之后它就可能为 null。为保持健全性，我们取并集：$M_N = M_{N1} \\cup M_{N2}$。\n- 对于 `MustNonNull` 集合：只有一个变量在*所有*入路径上都必须非 null 时，它在 join 之后才必须非 null。为保持健全性，我们取交集：$M_{NN} = M_{NN1} \\cap M_{NN2}$。\n\n因此，join 操作符为：\n$$(M_{N1}, M_{NN1}) \\sqcup (M_{N2}, M_{NN2}) = (M_{N1} \\cup M_{N2}, M_{NN1} \\cap M_{NN2})$$\n\n#### 1.3. 转换函数\n转换函数 $F_s$ 将语句 $s$ 之前的抽象状态 $(M_N^{in}, M_{NN}^{in})$ 映射到其后的抽象状态 $(M_N^{out}, M_{NN}^{out})$。这些函数必须相对于格序 $\\sqsubseteq$ 是健全且单调的。设输入状态为 $(M_N, M_{NN})$。\n\n**1. 语句: $v := \\texttt{new}$**\n- 具体语义：变量 $v$ 被赋予一个新的、非空的值。\n- 健全性：赋值后，$v$ 必须非空。因此，$v$ 必须在新的 `MustNonNull` 集合中，且不能在新的 `MayNull` 集合中。其他变量的状态保持不变。\n- 推导：\n  - $M_N^{out} = M_N \\setminus \\{v\\}$\n  - $M_{NN}^{out} = M_{NN} \\cup \\{v\\}$\n- 单调性：给定 $(M_{N1}, M_{NN1}) \\sqsubseteq (M_{N2}, M_{NN2})$，我们有 $M_{N1} \\subseteq M_{N2}$ 且 $M_{NN1} \\supseteq M_{NN2}$。应用该函数，$M_{N1}^{out} = M_{N1} \\setminus \\{v\\}$ 且 $M_{N2}^{out} = M_{N2} \\setminus \\{v\\}$，所以 $M_{N1}^{out} \\subseteq M_{N2}^{out}$。同样，$M_{NN1}^{out} = M_{NN1} \\cup \\{v\\}$ 且 $M_{NN2}^{out} = M_{NN2} \\cup \\{v\\}$，所以 $M_{NN1}^{out} \\supseteq M_{NN2}^{out}$。该函数是单调的。\n\n**2. 语句: $v := \\texttt{null}$**\n- 具体语义：变量 $v$ 被赋予 `null` 值。\n- 健全性：赋值后，$v$ 必定为 null，所以它“可能为 null”。它不再能是“必须非 null”。\n- 推导：\n  - $M_N^{out} = M_N \\cup \\{v\\}$\n  - $M_{NN}^{out} = M_{NN} \\setminus \\{v\\}$\n- 单调性：给定 $(M_{N1}, M_{NN1}) \\sqsubseteq (M_{N2}, M_{NN2})$，我们有 $M_{N1} \\subseteq M_{N2}$ 且 $M_{NN1} \\supseteq M_{NN2}$。应用该函数，$M_{N1}^{out} = M_{N1} \\cup \\{v\\}$ 且 $M_{N2}^{out} = M_{N2} \\cup \\{v\\}$，所以 $M_{N1}^{out} \\subseteq M_{N2}^{out}$。同样，$M_{NN1}^{out} = M_{NN1} \\setminus \\{v\\}$ 且 $M_{NN2}^{out} = M_{NN2} \\setminus \\{v\\}$，所以 $M_{NN1}^{out} \\supseteq M_{NN2}^{out}$。该函数是单调的。\n\n**3. 语句: $v_1 := v_2$**\n- 具体语义：变量 $v_1$ 被赋予变量 $v_2$ 的值。\n- 健全性：$v_1$ 的新属性必须是 $v_2$ 属性的健全近似。$v_1$ 的旧属性被“杀死”（kill）。\n- 推导：\n  - 我们首先移除关于 $v_1$ 的任何现有信息：$M_{N,temp} = M_N \\setminus \\{v_1\\}$, $M_{NN,temp} = M_{NN} \\setminus \\{v_1\\}$。\n  - 如果 $v_2$ 可能为 null (即 $v_2 \\in M_N$)，那么 $v_1$ 现在也可能为 null：$M_N^{out} = M_{N,temp} \\cup (\\{v_1\\} \\text{ if } v_2 \\in M_N \\text{ else } \\emptyset)$。\n  - 如果 $v_2$ 必须非 null (即 $v_2 \\in M_{NN}$)，那么 $v_1$ 现在也必须非 null：$M_{NN}^{out} = M_{NN,temp} \\cup (\\{v_1\\} \\text{ if } v_2 \\in M_{NN} \\text{ else } \\emptyset)$。\n- 单调性：在思考过程中已证明推导是单调的，并且它遵循集合并集和条件的属性。\n\n**4. 语句: $\\texttt{check}(v)$**\n该语句不改变程序状态。它是一个断言。转换函数是恒等函数：$F_{\\texttt{check}(v)}(M_N, M_{NN}) = (M_N, M_{NN})$。该检查是可消除的，当且仅当 $v \\in M_{NN}^{in}$。\n\n### 2. 程序的数据流分析\n我们计算每行入口处的抽象状态 $(M_N, M_{NN})$。第 ($1$) 行的初始状态是 $(\\emptyset, \\emptyset)$。\n\n- **第 ($1$) 行之前：** $(\\emptyset, \\emptyset)$\n- ($1$) $x := \\texttt{new}$。输出状态：$(\\emptyset \\setminus \\{x\\}, \\emptyset \\cup \\{x\\}) = (\\emptyset, \\{x\\})$。\n- **第 ($2$) 行之前：** $(\\emptyset, \\{x\\})$\n- ($2$) $y := \\texttt{null}$。输出状态：$(\\emptyset \\cup \\{y\\}, \\{x\\} \\setminus \\{y\\}) = (\\{y\\}, \\{x\\})$。\n- **第 ($3$) 行之前：** $(\\{y\\}, \\{x\\})$\n- ($3$) $\\texttt{check}(x)$。$x \\in M_{NN}$ 吗？是的，$x \\in \\{x\\}$。**($3$) 处的检查是可消除的。** 输出状态：$(\\{y\\}, \\{x\\})$。\n- **第 ($4$) 行之前：** $(\\{y\\}, \\{x\\})$\n- ($4$) $\\texttt{check}(y)$。$y \\in M_{NN}$ 吗？不是，$y \\notin \\{x\\}$。检查不可消除。输出状态：$(\\{y\\}, \\{x\\})$。\n- **第 ($5$) 行之前：** $(\\{y\\}, \\{x\\})$\n- ($5$) `if (p) then`。状态 $(\\{y\\}, \\{x\\})$ 传播到两个分支。\n  - **`then` 分支 (行 $6-7$):**\n    - **第 ($6$) 行之前：** $(\\{y\\}, \\{x\\})$\n    - ($6$) $y := x$。$x$ 的属性：$x \\notin M_N, x \\in M_{NN}$。$y$ 的新属性：$y \\notin M_N, y \\in M_{NN}$。输出状态：$(\\emptyset, \\{x, y\\})$。\n    - **第 ($7$) 行之前：** $(\\emptyset, \\{x, y\\})$\n    - ($7$) $\\texttt{check}(y)$。$y \\in M_{NN}$ 吗？是的，$y \\in \\{x, y\\}$。**($7$) 处的检查是可消除的。** 输出状态：$(\\emptyset, \\{x, y\\})$。\n    - **`then` 分支结束时的状态：** $S_{then} = (\\emptyset, \\{x, y\\})$。\n  - **`else` 分支 (行 $9-10$):**\n    - **第 ($9$) 行之前：** $(\\{y\\}, \\{x\\})$\n    - ($9$) $x := \\texttt{null}$。输出状态：$(\\{y\\} \\cup \\{x\\}, \\{x\\} \\setminus \\{x\\}) = (\\{x, y\\}, \\emptyset)$。\n    - **第 ($10$) 行之前：** $(\\{x, y\\}, \\emptyset)$\n    - ($10$) $\\texttt{check}(x)$。$x \\in M_{NN}$ 吗？不是，$x \\notin \\emptyset$。检查不可消除。输出状态：$(\\{x, y\\}, \\emptyset)$。\n    - **`else` 分支结束时的状态：** $S_{else} = (\\{x, y\\}, \\emptyset)$。\n- **第 ($12$) 行之前：** 第 ($11$) 行 `if` 之后的合并点。我们计算 $S_{then} \\sqcup S_{else}$。\n  - $(\\emptyset, \\{x, y\\}) \\sqcup (\\{x, y\\}, \\emptyset) = (\\emptyset \\cup \\{x, y\\}, \\{x, y\\} \\cap \\emptyset) = (\\{x, y\\}, \\emptyset)$。\n- ($12$) $z := y$。$y$ 的属性：$y \\in M_N, y \\notin M_{NN}$。$z$ 的新属性：$z \\in M_N, z \\notin M_{NN}$。输出状态：$(\\{x, y\\} \\cup \\{z\\}, \\emptyset) = (\\{x, y, z\\}, \\emptyset)$。\n- **第 ($13$) 行之前：** $(\\{x, y, z\\}, \\emptyset)$\n- ($13$) $\\texttt{check}(z)$。$z \\in M_{NN}$ 吗？不是，$z \\notin \\emptyset$。检查不可消除。输出状态：$(\\{x, y, z\\}, \\emptyset)$。\n- **第 ($14$) 行之前：** $(\\{x, y, z\\}, \\emptyset)$\n- ($14$) `if (q) then`。状态 $(\\{x, y, z\\}, \\emptyset)$ 传播到 `then` 分支（行 $15$）和顺序执行路径。\n  - **`then` 分支 (行 $15$):**\n    - **第 ($15$) 行之前：** $(\\{x, y, z\\}, \\emptyset)$\n    - ($15$) $x := \\texttt{new}$。输出状态：$(\\{x, y, z\\} \\setminus \\{x\\}, \\emptyset \\cup \\{x\\}) = (\\{y, z\\}, \\{x\\})$。\n    - **`then` 分支结束时的状态：** $S_{then2} = (\\{y, z\\}, \\{x\\})$。\n  - **顺序执行路径：** 状态不变。$S_{skip} = (\\{x, y, z\\}, \\emptyset)$。\n- **第 ($17$) 行之前：** 第 ($16$) 行 `if` 之后的合并点。我们计算 $S_{then2} \\sqcup S_{skip}$。\n  - $(\\{y, z\\}, \\{x\\}) \\sqcup (\\{x, y, z\\}, \\emptyset) = (\\{y, z\\} \\cup \\{x, y, z\\}, \\{x\\} \\cap \\emptyset) = (\\{x, y, z\\}, \\emptyset)$。\n- ($17$) $\\texttt{check}(x)$。$x \\in M_{NN}$ 吗？不是，$x \\notin \\emptyset$。检查不可消除。输出状态：$(\\{x, y, z\\}, \\emptyset)$。\n- **第 ($18$) 行之前：** $(\\{x, y, z\\}, \\emptyset)$\n- ($18$) $y := \\texttt{new}$。输出状态：$(\\{x, y, z\\} \\setminus \\{y\\}, \\emptyset \\cup \\{y\\}) = (\\{x, z\\}, \\{y\\})$。\n- **第 ($19$) 行之前：** $(\\{x, z\\}, \\{y\\})$\n- ($19$) $\\texttt{check}(y)$。$y \\in M_{NN}$ 吗？是的，$y \\in \\{y\\}$。**($19$) 处的检查是可消除的。** 输出状态：$(\\{x, z\\}, \\{y\\})$。\n- **第 ($20$) 行之前：** $(\\{x, z\\}, \\{y\\})$\n- ($20$) $x := y$。$y$ 的属性：$y \\notin M_N, y \\in M_{NN}$。$x$ 的新属性：$x \\notin M_N, x \\in M_{NN}$。输出状态：$(\\{z\\}, \\{y\\} \\cup \\{x\\}) = (\\{z\\}, \\{x, y\\})$。\n- **第 ($21$) 行之前：** $(\\{z\\}, \\{x, y\\})$\n- ($21$) $\\texttt{check}(x)$。$x \\in M_{NN}$ 吗？是的，$x \\in \\{x, y\\}$。**($21$) 处的检查是可消除的。**\n\n### 3. 结论\n通过此分析确定为可消除的空检查位于以下行：\n- 第 ($3$) 行：$\\texttt{check}(x)$\n- 第 ($7$) 行：$\\texttt{check}(y)$\n- 第 ($19$) 行：$\\texttt{check}(y)$\n- 第 ($21$) 行：$\\texttt{check}(x)$\n\n可消除的检查总数为 $4$。", "answer": "$$\\boxed{4}$$", "id": "3659400"}, {"introduction": "在脑海中建立起基本的分析框架后，我们现在来探讨任何优化都必须面对的关键问题：正确性。这个问题 [@problem_id:3659368] 提出了一个看似直接但实际上错误的优化，其原因在于一个微妙的副作用。它将挑战你批判性地思考“可观察行为”的真正含义，以及为什么编译器在进行转换时必须如此保守。", "problem": "给定一种类 Java 的中间语言，其可观察语义如下。调用日志记录例程 $\\mathsf{log}(s)$ 会将字符串 $s$ 追加到外部可见的输入/输出 (I/O) 轨迹中，并且没有其他效果。当且仅当 $p = \\texttt{null}$ 时，字段读取 $p.f$ 会抛出 $\\mathsf{NullPointerException}$（缩写为 NPE）。一个程序在初始状态 $\\sigma$ 下的可观察行为是一个序对 $(\\tau, o)$，其中 $\\tau$ 是通过调用 $\\mathsf{log}$ 写入轨迹的字符串序列，而 $o$ 是正常返回值或像 $\\mathsf{NPE}$ 这样的异常标签。当且仅当对于所有初始状态 $\\sigma$，两个程序 $S$ 和 $S'$ 产生相同的 $(\\tau, o)$ 时，它们被认为是可观察等价的。\n\n一个优化编译器提议通过依赖解引用点的隐式 NPE 来消除显式的空检查。考虑以下源程序 $S$ 及其通过此优化生成的转换后版本 $S'$：\n- $S$: \n  if $(p == \\texttt{null})$ $\\{$ $\\mathsf{log}(\"about\\text{-}to\\text{-}throw\")$ $\\}$; $x := p.f$;\n- $S'$: \n  $x := p.f$;\n\n假设初始状态 $\\sigma$ 将 $p$ 绑定到 $\\texttt{null}$，并且所有其他变量与本次讨论无关。编译器声称 $S$ 和 $S'$ 是可观察等价的，因为 $p.f$ 处的隐式 NPE 包含了显式检查。\n\n你的任务：\n- 仅使用上述基本语义定义（轨迹作为有序的 I/O 事件序列，当 $p = \\texttt{null}$ 时对 $p.f$ 抛出异常，以及可观察等价性定义为对所有初始状态轨迹和结果的相等性），判断以下哪些陈述是正确的。\n\n选项：\nA. 一个禁止此消除的通用正确性法则是：一个保持语义的转换必须对每个初始状态，都保持外部可观察动作的序列和顺序，以及终止的类型（正常值或异常）。由于当 $p = \\texttt{null}$ 时，$S$ 在 NPE 之前产生一个包含一次 $\\mathsf{log}$ 调用的轨迹，而 $S'$ 不产生这样的 $\\mathsf{log}$，因此在这种情况下不允许该优化。\n\nB. 该消除总是正确的，因为 $p.f$ 中的隐式空检查包含了任何显式检查，并且解引用之前的任何日志记录相对于 NPE 都是不可观察的。\n\nC. 如果静态分析证明在所有路径上，解引用处的 $p \\neq \\texttt{null}$（例如，$p$ 被支配性证明为非空），则该消除是正确的，因为那时 $S$ 中的分支是不可达的，并且不会发生可观察的 $\\mathsf{log}$。\n\nD. 只要日志记录函数是幂等的，该消除就是正确的，因为移除一个幂等的副作用不会改变可观察行为。\n\nE. 该消除被静态单赋值（SSA）形式所禁止，因为 SSA 表示法不允许移除保护解引用的条件语句。\n\n选择所有适用的选项。", "solution": "必须首先验证问题陈述的科学合理性、完整性和清晰性。\n\n### 步骤 1：提取已知条件\n该问题提供了以下定义和程序规范：\n- **可观察语义**：\n    - 调用 $\\mathsf{log}(s)$ 会将字符串 $s$ 追加到外部可见的 I/O 轨迹 $\\tau$ 中。\n    - 当且仅当 $p = \\texttt{null}$ 时，字段读取 $p.f$ 会抛出 $\\mathsf{NullPointerException}$ ($\\mathsf{NPE}$)。\n    - 一个程序在初始状态 $\\sigma$ 下的可观察行为是序对 $(\\tau, o)$，其中 $\\tau$ 是轨迹， $o$ 是结果（正常值或异常）。\n- **可观察等价性**：当且仅当对于所有初始状态 $\\sigma$，两个程序 $S$ 和 $S'$ 产生相同的序对 $(\\tau, o)$ 时，它们是可观察等价的。\n- **程序 $S$**：`if (p == null) { log(\"about-to-throw\"); }; x := p.f;`\n- **程序 $S'$**：`x := p.f;`\n- **条件**：一个初始状态 $\\sigma$，其中 $p$ 被绑定到 $\\texttt{null}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题位于程序设计语言语义和编译器理论的形式化框架内。\n- **科学依据**：操作语义、可观察行为（轨迹和终止）以及可观察等价性的定义在该领域是标准的。空指针解引用的行为模型与像 Java 这样的真实世界语言一致。该问题是科学合理的。\n- **问题定义良好**：问题陈述清晰。它提供了一套完整的公理（语义定义），并要求在这些公理下对两个具体程序的等价性进行逻辑推导。这种结构允许一个唯一且可验证的解决方案。\n- **客观性**：该问题使用精确、形式化的语言，避免了任何主观性或模糊性。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。这是理论计算机科学中一个定义明确的问题。我现在将着手解决。\n\n### 推导\n核心任务是确定从程序 $S$ 到 $S'$ 的转换是否保持语义，根据所提供的定义，这意味着它们必须是可观察等价的。只有当两个程序对**所有**初始状态 $\\sigma$ 都产生相同的可观察行为 $(\\tau, o)$ 时，它们才是可观察等价的。\n\n让我们分析在指定的初始状态 $\\sigma$（其中 $p = \\texttt{null}$）下的行为。\n\n**程序 $S$ 的分析**：\n1. 执行语句 `if (p == null)`。由于 $p = \\texttt{null}$，条件为真。\n2. 执行条件语句的主体 `log(\"about-to-throw\")`。这将字符串 `\"about-to-throw\"` 追加到 I/O 轨迹 $\\tau$ 中。轨迹变为 $\\tau = \\langle \\text{\"about-to-throw\"} \\rangle$。\n3. 执行下一条语句 `x := p.f`。由于 $p = \\texttt{null}$，此操作抛出 $\\mathsf{NullPointerException}$ ($\\mathsf{NPE}$)。程序因异常而终止。\n4. $S$ 在此初始状态下的可观察行为是序对 $(\\tau, o) = (\\langle \\text{\"about-to-throw\"} \\rangle, \\mathsf{NPE})$。\n\n**程序 $S'$ 的分析**：\n1. 执行语句 `x := p.f`。\n2. 由于 $p = \\texttt{null}$，此操作抛出 $\\mathsf{NPE}$。程序因异常而终止。没有进行任何 $\\mathsf{log}$ 调用。\n3. 轨迹 $\\tau$ 为空，即 $\\tau = \\langle \\rangle$。\n4. $S'$ 在此初始状态下的可观察行为是序对 $(\\tau, o) = (\\langle \\rangle, \\mathsf{NPE})$。\n\n**比较**：\n对于 $p = \\texttt{null}$ 的初始状态，可观察行为是：\n- $S$：$(\\langle \\text{\"about-to-throw\"} \\rangle, \\mathsf{NPE})$\n- $S'$：$(\\langle \\rangle, \\mathsf{NPE})$\n\n这些序对不相同，因为它们的第一个分量（轨迹）不同：$\\langle \\text{\"about-to-throw\"} \\rangle \\neq \\langle \\rangle$。\n\n由于存在至少一个初始状态，使得 $S$ 和 $S'$ 产生不同的可观察行为，因此它们**不是**可观察等价的。编译器提议的优化在一般情况下是不正确的。\n\n### 逐项分析选项\n\n**A. 一个禁止此消除的通用正确性法则是：一个保持语义的转换必须对每个初始状态，都保持外部可观察动作的序列和顺序，以及终止的类型（正常值或异常）。由于当 $p = \\texttt{null}$ 时，$S$ 在 NPE 之前产生一个包含一次 $\\mathsf{log}$ 调用的轨迹，而 $S'$ 不产生这样的 $\\mathsf{log}$，因此在这种情况下不允许该优化。**\n这个陈述准确地反映了问题中提供的可观察等价性的定义。“外部可观察动作的序列和顺序”对应于轨迹 $\\tau$，“终止的类型”对应于结果 $o$。然后，该分析正确地将此规则应用于 $p = \\texttt{null}$ 的情况，并指出轨迹不同。如上文推导所示，轨迹的这种差异证明了程序是不等价的。因此，该优化是不被允许的这一结论是正确的。\n**结论：正确**\n\n**B. 该消除总是正确的，因为 $p.f$ 中的隐式空检查包含了任何显式检查，并且解引用之前的任何日志记录相对于 NPE 都是不可观察的。**\n这个陈述提出的主张与问题的基本前提直接矛盾。问题明确地将由 $\\mathsf{log}$ 调用生成的 I/O 轨迹 $\\tau$ 定义为程序可观察行为的一个组成部分。因此，声称日志记录是“不可观察的”是错误的。轨迹的差异正是该转换不正确的原因。\n**结论：不正确**\n\n**C. 如果静态分析证明在所有路径上，解引用处的 $p \\neq \\texttt{null}$（例如，$p$ 被支配性证明为非空），则该消除是正确的，因为那时 $S$ 中的分支是不可达的，并且不会发生可观察的 $\\mathsf{log}$。**\n让我们分析在所有可能到达此代码的执行中，已知 $p \\neq \\texttt{null}$ 的情况。\n- 在程序 $S$ 中，条件 `if (p == null)` 将始终为假。因此，`if` 块内的 $\\mathsf{log}$ 调用是不可达的，永远不会执行。程序继续执行 `x := p.f`，该语句正常执行（不抛出 $\\mathsf{NPE}$）。产生的轨迹 $\\tau$ 为空，$\\langle \\rangle$。\n- 在程序 $S'$ 中，语句 `x := p.f` 正常执行，因为 $p \\neq \\texttt{null}$。产生的轨迹 $\\tau$ 也为空，$\\langle \\rangle$。\n在这种情况下，对于任何给定的非空 $p$ 值，两个程序都产生相同的空轨迹，并正常终止，同时为 $x$ 赋相同的值。因此，在 $p$ 被证明为非空的条件下，两个程序 $S$ 和 $S'$ 确实是可观察等价的。该陈述正确地指出了一个使优化有效的条件。\n**结论：正确**\n\n**D. 只要日志记录函数是幂等的，该消除就是正确的，因为移除一个幂等的副作用不会改变可观察行为。**\n幂等性意味着一个操作无论应用一次还是多次，其效果都相同（例如，$f(f(x)) = f(x)$）。给定的 $\\mathsf{log}(s)$ 函数是向轨迹*追加*内容。调用它两次，例如 $\\mathsf{log}(\"a\")$; $\\mathsf{log}(\"a\")$，会产生轨迹 $\\langle \"a\", \"a\" \\rangle$，这与单次调用产生的轨迹 $\\langle \"a\" \\rangle$ 不同。因此，$\\mathsf{log}$ 函数不是幂等的。此外，所讨论的转换是从一次调用变为零次调用。移除唯一的一次 $\\mathsf{log}$ 调用，将可观察轨迹从 $\\langle \\text{\"about-to-throw\"} \\rangle$ 变为 $\\langle \\rangle$，无论是否具有幂等性，这都是一个可观察的差异。该推理在多个方面存在缺陷。\n**结论：不正确**\n\n**E. 该消除被静态单赋值（SSA）形式所禁止，因为 SSA 表示法不允许移除保护解引用的条件语句。**\n这个陈述错误地将一个语义约束归因于中间表示（IR）的句法属性。静态单赋值（SSA）是 IR 的一个属性，它通过要求每个变量只被赋值一次来简化数据流分析。虽然编译器使用 SSA 来启用和简化各种优化，但 SSA 形式本身并不内在地“禁止”或“不允许”特定的转换。转换的正确性是由语言的语义决定的，而不是由 IR 的选择决定的。这个转换是不正确的，因为它违反了语义等价性，而这一事实与程序是用 SSA 形式还是其他 IR 表示无关。\n**结论：不正确**", "answer": "$$\\boxed{AC}$$", "id": "3659368"}, {"introduction": "现在，让我们将所学知识应用到最优化的“沃土”之一：循环。这个练习 [@problem_id:3659411] 探讨了编译器如何利用循环携带的数据流信息来消除那些在每次迭代中都会重复执行的冗余检查。你将分析不同的循环转换策略，以提高代码的运行效率。", "problem": "考虑一个带指针和堆分配的一阶命令式语言，并假设编译器使用单静态赋值（SSA）形式并构建控制流图（CFG）。一个指针变量 $p$ 初始可能为 null，一个长度为 $n$ 的数组 $A$ 将在一个循环中被填充。该循环的写法如下：对于从 $0$ 到 $n-1$ 的每个迭代索引 $i$，循环体执行一次检查和可能的初始化，然后解引用 $p$：\n- 如果 $p$ 为 null，则赋值 $p := \\text{init}()$，其中 $\\text{init}()$ 返回一个新分配的、非 null 的指针。\n- 从 $p$ 读取一个字段，并使用 $p$ 写入 $A[i]$。\n\n假设以下事实成立，这些事实在编译器正确性论证中被广泛使用：\n- 循环至少执行一次，即 $n \\ge 1$。\n- 函数 $\\text{init}()$ 返回一个非 null 指针，不抛出异常，并且除了分配一个新对象外没有其他外部可见的副作用（除了创建对象外，没有会改变程序 I/O 或全局状态的可观察交互）。\n- 除了所描述的条件初始化外，循环体中没有任何地方对 $p$ 写入 null 的赋值。没有其他别名会写入 $p$ 或可能导致 $p$ 变为 null 的内存。\n- 对 $p$ 的解引用操作要求 $p \\neq \\text{null}$ 才是安全的；只有当在所有到达该解引用点的动态执行路径上，$p$ 都可被证明为非 null 时，移除 null 检查才是健全的。\n\n在这些假设下，编译器旨在通过循环携带依赖来消除冗余的 null 检查：$p$ 在第一次迭代后（如果初始为 null）变为非 null，并在之后保持非 null。以下哪项源码到源码的转换相对于原始程序语义是健全的，并允许在后续迭代中消除 null 检查？\n\nA. 将循环拆分为一次保留了条件初始化和解引用的“预热”迭代，然后是一个针对剩余迭代的第二个循环，在第二个循环中移除了对 $p$ 的 null 检查，因为在所有后续迭代中 $p$ 都可被证明为非 null。\n\nB. 在没有任何保护性转换的情况下，为所有迭代移除循环内部对 $p$ 的 null 检查；也就是说，假设在第一次迭代的解引用点 $p$ 是非 null 的。\n\nC. 在循环前引入一个前置首部守卫：如果 $p$ 为 null，则在进入循环前执行一次 $p := \\text{init}()$；然后在循环内部为所有迭代消除对 $p$ 的 null 检查，因为此时在循环首部 $p$ 已为非 null。依赖 $n \\ge 1$ 来保持相对于第一次迭代的原始分配时机。\n\nD. 在循环前置首部中无条件地赋值 $p := \\text{init}()$（覆盖任何非 null 的 $p$），然后移除循环内部所有对 $p$ 的 null 检查。\n\n选择所有适用的选项。请基于 SSA、CFG 和循环的数据流属性，从上述定义和给定假设出发，提供你的推理，不要使用任何专门的快捷公式。所有变量和常量均指此处定义的程序实体，$i$、$n$ 和数值边界应按书面形式视为数学量。", "solution": "用户希望我扮演一位一丝不苟的 STEM 教授，批判性地验证一个关于编译器优化的给定问题陈述，然后提供详细的解决方案。\n\n### 步骤 1：提取已知条件\n\n问题陈述提供了以下信息：\n- 上下文是一个带指针和堆分配的一阶命令式语言。\n- 编译器使用单静态赋值（SSA）形式并构建控制流图（CFG）。\n- 一个指针变量 $p$ 初始可能为 null。\n- 一个循环填充一个长度为 $n$ 的数组 $A$。\n- 循环使用索引 $i$ 从 $0$ 到 $n-1$ 进行迭代。\n- 循环体包含以下逻辑：\n  - 如果 $p$ 为 null，则赋值 $p := \\text{init}()$。\n  - 从 $p$ 读取一个字段并写入 $A[i]$。\n- 以下假设成立：\n  1.  循环至少执行一次，即 $n \\ge 1$。\n  2.  函数 $\\text{init}()$ 返回一个新分配的、非 null 的指针。它没有其他外部可见的副作用。\n  3.  循环体内没有将 null 写入 $p$ 的赋值，也没有其他别名可能导致 $p$ 变为 null。\n  4.  解引用 $p$ 要求 $p \\neq \\text{null}$ 才是安全的。只有在所有到达解引用点的执行路径上 $p$ 都可被证明为非 null 时，消除 null 检查才是健全的。\n\n任务是确定给定的源码到源码转换中哪些是健全的，并允许消除冗余的 null 检查。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准评估问题陈述。\n\n-   **科学基础**：该问题牢固地建立在编译器理论的既定原则之上，特别是程序分析和优化。诸如 CFG、SSA、null 检查消除、循环不变量代码外提和循环剥离等概念都是该领域的标准课题。这些假设对于定义一个可处理的分析问题是现实的。该问题具有科学基础。\n-   **适定性**：该问题是适定的。程序的初始状态、转换规则以及正确性标准（健全性、保留程序语义）都得到了明确定义。这些假设，特别是 $n \\ge 1$ 和 $\\text{init}()$ 的行为，对于保证可以进行有意义的分析至关重要。可以确定一组唯一的正确和不正确选项。\n-   **客观性**：语言精确且无偏见。诸如“健全的”、“可证明为非 null”、“循环携带依赖”和“原始程序语义”等术语在计算机科学中具有标准的、客观的含义。该问题是客观的。\n\n该问题没有表现出任何无效性缺陷：\n1.  **科学/事实不健全**：没有违反任何科学原则。\n2.  **不可形式化/不相关**：该问题与编译器原理直接相关并且是可形式化的。\n3.  **不完整/矛盾的设置**：设置是完整且一致的。假设被明确列出。\n4.  **不现实/不可行**：该场景是编译器设计中一个常见且实际的问题。\n5.  **不适定/结构不良**：该问题结构良好。\n6.  **伪深刻/琐碎**：该问题需要对数据流分析和循环转换有扎实的理解，因此并非琐碎。\n7.  **超出科学可验证性范围**：转换的正确性可以通过对程序语义的逻辑推理来验证。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。现在开始求解过程。\n\n### 推导与选项分析\n\n首先，我们分析原始循环中指针 $p$ 的数据流属性。令 $p_i$ 表示在第 $i$ 次迭代开始时，循环首部的指针 $p$ 的值。令 $p'_i$ 表示在第 $i$ 次迭代中，经过条件初始化块后 $p$ 的值。\n\n第 $i$ 次迭代的循环体如下：\n```\n// At loop header for iteration i, p has value p_i\nif (p_i == null) {\n  p = init(); // Now p is non-null\n} else {\n  // p remains p_i, which is non-null\n}\n// p is now non-null. Let this value be p'_i.\n// ... dereference p ...\n// The value of p at the end of the iteration is p'_i.\n// This value is carried to the next iteration: p_{i+1} = p'_i.\n```\n\n-   **迭代 $i=0$**：$p_0$ 是循环开始前 $p$ 的值，可能为 null 或非 null。\n    -   如果 $p_0$ 为 null，它被赋值为 $\\text{init}()$ 返回的非 null 结果。\n    -   如果 $p_0$ 为非 null，它保持不变。\n    在任何一种情况下，条件块之后 $p$ 的值 $p'_0$ 都保证是非 null 的。后续的解引用是安全的。\n\n-   **迭代 $i=1$**：本次迭代开始时 $p$ 的值 $p_1$ 是上一次迭代结束时的值，即 $p'_0$。由于 $p'_0$ 可被证明为非 null，因此 $p_1$ 也可被证明为非 null。\n\n-   **归纳步骤**：假设对于某个 $k \\ge 1$，$p_k$ 是非 null 的。条件 `p_k == null` 将为假。因此，$p$ 不会被重新赋值，其值保持为 $p_k$。条件块之后的值 $p'_k$ 等于 $p_k$，因此是非 null 的。传递给下一次迭代的值是 $p_{k+1} = p'_k$，它也是非 null 的。\n\n通过归纳法，对于所有迭代 $i \\ge 1$，指针 $p$ 在循环首部都可被证明为非 null。因此，除了第一次迭代（$i=0$）外，null 检查 `if (p == null)` 对于所有其他迭代都是冗余的。转换的目标是在保留程序语义的同时消除这个冗余检查。\n\n现在我们评估每个选项：\n\n**A. 将循环拆分为一次保留了条件初始化和解引用的“预热”迭代，然后是一个针对剩余迭代的第二个循环，在第二个循环中移除了对 $p$ 的 null 检查，因为在所有后续迭代中 $p$ 都可被证明为非 null。**\n\n这种转换被称为循环剥离（loop peeling），将产生如下结构的代码：\n```\n// Iteration i=0 (peeled)\nif (n >= 1) { // This check is implied since we only execute if the loop runs at all.\n  if (p == null) {\n    p = init();\n  }\n  // ... dereference p ...\n  // A[0] = p->field;\n}\n\n// Loop for remaining iterations i=1 to n-1\nfor (i = 1; i  n; i++) {\n  // No null check needed, as p is provably non-null from the first iteration.\n  // ... dereference p ...\n  // A[i] = p->field;\n}\n```\n-   **健全性**：这种转换是健全的。第一次迭代只执行一次（因为给定 $n \\ge 1$）并保持了原始逻辑，确保了在解引用前 $p$ 是非 null 的。在这次单独的迭代之后，$p$ 被保证为非 null。因此，覆盖迭代 $1$ 到 $n-1$ 的第二个循环可以安全地省略 null 检查。如果 $n=1$，第二个循环不执行，这是正确的。原始程序的语义被完美保留。\n-   **结论**：**正确**。\n\n**B. 在没有任何保护性转换的情况下，为所有迭代移除循环内部对 $p$ 的 null 检查；也就是说，假设在第一次迭代的解引用点 $p$ 是非 null 的。**\n\n这种转换导致：\n```\nfor (i = 0; i  n; i++) {\n  // Null check removed\n  // ... dereference p ...\n  // A[i] = p->field;\n}\n```\n-   **健全性**：这种转换是不健全的。问题陈述明确允许 $p$ 初始为 null。如果循环开始前 $p$ 确实为 null，那么在第一次迭代（$i=0$）中，程序将尝试解引用一个 null 指针，导致运行时错误。这违反了安全要求。\n-   **结论**：**不正确**。\n\n**C. 在循环前引入一个前置首部守卫：如果 $p$ 为 null，则在进入循环前执行一次 $p := \\text{init}()$；然后在循环内部为所有迭代消除对 $p$ 的 null 检查，因为此时在循环首部 $p$ 已为非 null。依赖 $n \\ge 1$ 来保持相对于第一次迭代的原始分配时机。**\n\n这种转换是循环不变量代码外提的一种形式，将导致：\n```\n// Preheader\nif (p == null) {\n  p = init();\n}\n\n// Loop body\nfor (i = 0; i  n; i++) {\n  // Null check removed\n  // ... dereference p ...\n  // A[i] = p->field;\n}\n```\n-   **健全性**：我们来分析其语义。\n    1.  经过前置首部守卫后，在循环开始前 $p$ 保证为非 null。因此，在循环内部移除 null 检查对于所有迭代都是安全的。\n    2.  我们必须检查将初始化 `p := init()` 移出循环是否保留了原始语义。在原始程序中，如果 $p$ 为 null，`init()` 会在第一次迭代（$i=0$）期间、第一次解引用之前被调用。因为问题陈述中 $n \\ge 1$，我们知道循环体将至少执行一次，因此如果 $p$ 为 null，`init()` 将被调用。该转换将此调用从第一次迭代的*内部*移动到循环的*正前方*。问题陈述指出，`init()` 除了分配之外没有其他外部可见的副作用。这意味着分配的精确时机（在迭代 0 之前 vs 在迭代 0 期间）对程序的输出没有可观察的影响，因为分配的对象从迭代 0 开始以相同的方式被使用。如果 $p$ 初始为非 null，则原始程序和转换后的程序都不会调用 `init()`。因此，程序在这两种情况下的行为都得以保留。\n-   **结论**：**正确**。\n\n**D. 在循环前置首部中无条件地赋值 $p := \\text{init}()$（覆盖任何非 null 的 $p$），然后移除循环内部所有对 $p$ 的 null 检查。**\n\n这种转换导致：\n```\n// Preheader\np = init(); // Unconditional assignment\n\n// Loop body\nfor (i = 0; i  n; i++) {\n  // Null check removed\n  // ... dereference p ...\n  // A[i] = p->field;\n}\n```\n-   **健全性**：这种转换是不健全的。考虑 $p$ 初始为非 null，指向一个特定的、预先存在的对象。原始程序将使用这个原始对象执行循环，因为 `if (p == null)` 检查将为假。然而，转换后的程序会无条件地用 `init()` 返回的新对象的指针覆盖 $p$。循环将在此新对象上操作。这改变了程序的基本行为，因为从 `p-field` 读取的数据将来自与原始程序意图不同的对象。它还会导致原始对象丢失（如果这是指向它的唯一指针，则会造成内存泄漏）。这违反了保留原始程序语义的要求。\n-   **结论**：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3659411"}]}