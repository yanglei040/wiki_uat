{"hands_on_practices": [{"introduction": "在C语言等底层语言中，函数指针是实现回调和动态行为的强大工具，但它们也给静态分析带来了巨大挑战。为了精确构建调用图，编译器必须首先进行指针分析，以确定每个函数指针可能指向哪些函数。本练习 [@problem_id:3625920] 将引导你手动执行一次经典的Andersen风格指针分析，通过处理结构体、指针赋值和别名等情况，亲身体验从复杂的指针关系中解析间接调用目标的过程。", "problem": "一个编译器必须为一个 C 程序构建一个保守调用图，该程序使用存储在结构体中并通过结构体访问的函数指针。假设该分析是一种全程序、流不敏感、上下文不敏感、基于包含的点对分析（通常称为 Andersen 风格分析）。该分析对结构体是字段敏感的（每个不同分配点或变量的每个不同结构体字段都会产生其自己的抽象字段位置），但数组元素以折叠方式建模，即每个数组变量对应一个单一的抽象数组元素位置。函数名被建模为抽象函数标签位置。该分析遵循以下基本规则，这些规则在本问题中被视为核心定义：\n\n- 取地址：如果赋值形式为 `x = `，则 y 的抽象位置被包含在点对集 $\\mathrm{Pt}(x)$ 中。\n- 复制：如果赋值形式为 `x = y`，则 $\\mathrm{Pt}(x) \\supseteq \\mathrm{Pt}(y)$。\n- 通过指向结构体字段的指针进行存储：如果赋值为 `x->f = y`，则对于 $\\mathrm{Pt}(x)$ 中的每个抽象位置 $o$，关系 $\\mathrm{Pt}(o.f) \\supseteq \\mathrm{Pt}(y)$ 成立。如果 y 是一个函数名，则将该函数标签包含在 $\\mathrm{Pt}(o.f)$ 中。\n- 从结构体字段加载：如果赋值为 `x = y->f`，则对于 $\\mathrm{Pt}(y)$ 中的每个抽象位置 $o$，关系 $\\mathrm{Pt}(x) \\supseteq \\mathrm{Pt}(o.f)$ 成立。\n- 折叠数组：对于数组变量 arr，所有元素写入 `arr[i] = y` 都会更新一个单一的抽象元素位置 $\\text{arr}[\\ast]$，因此 $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\mathrm{Pt}(y)$；读取 `x = arr[i]` 会从 $\\mathrm{Pt}(\\text{arr}[\\ast])$ 加载。\n\n根据上述点对语义，对于一个间接调用点处的函数指针表达式的点对集中的每个函数，调用图中都包含一条从该调用点到相应函数标签的有向边。共享相同被调用者但源自不同调用点的两条边被计为不同的边。设调用点标识为 $c_{1}$ 和 $c_{2}$。\n\n考虑以下 C 程序片段（仅显示类型和语句；其他代码如函数体与本分析无关）：\n\n```c\ntypedef void (*F)(int);\n\nvoid A(int x) {}\nvoid B(int x) {}\nvoid C(int x) {}\nvoid D(int x) {}\n\nstruct S { F f; };\nstruct T { struct S *ps; F g; };\n\nint main() {\n  struct S s1, s2, s3;\n  struct T t1, t2;\n  struct S *p, *q;\n  struct T *pt;\n  struct S *arr[2];\n\n  s1.f = A;\n  s2.f = B;\n  s3.f = C;\n\n  t1.ps = \n  t2.ps = \n\n  p = \n  q = p;\n  q->f = B;\n\n  t1.g = D;\n\n  arr[0] = \n  arr[1] = t2.ps;\n\n  if (/* unknown */) { pt =  } else { pt =  }\n\n  /* c1 */ pt->ps->f(/* arg */);\n  /* c2 */ arr[i]->f(/* arg */);\n}\n```\n\n仅使用上述基本规则，推导出解析两个间接调用点 $c_{1}$ 和 $c_{2}$ 的潜在目标所需的最不保守的点对信息：\n- $c_{1}$ 是调用 pt-ps-f(...)\n- $c_{2}$ 是调用 arr[i]-f(...)\n\n将数组 arr 视为折叠成一个单一的抽象元素位置 $\\text{arr}[\\ast]$，并假设 $i$ 在编译时是未知的。同时假设分析不会添加任何隐式的空值或未初始化的值；存在的抽象位置仅由程序中的赋值和函数标签引入。\n\n从基本原理出发，计算该分析所蕴含的间接调用图不同边的总数，将边计为有序对 $(c_{j}, \\text{callee})$。请以单个精确整数（不进行四舍五入）的形式给出最终答案。", "solution": "问题要求为给定的 C 程序片段构建一个保守调用图。分析方法被指定为一种全程序、流不敏感、上下文不敏感、基于包含的点对分析。这是一种标准的 Andersen 风格分析。该分析被进一步定义为对结构体是字段敏感的，但对数组是字段不敏感的（折叠的）。\n\n首先，我们必须验证问题陈述。\n1.  **提取已知条件**：问题提供了一个 C 代码片段，一套用于点对分析的特定规则（取地址、复制、存储、加载、数组折叠），以及一个根据点对集构建调用图边的定义。目标是计算由两个指定的调用点 $c_1$ 和 $c_2$ 产生的间接调用图边的总数。\n2.  **验证**：该问题在编译器静态分析这个成熟的领域具有科学依据。Andersen 风格分析的规则是标准的。问题是适定的，提供了所有必要信息以根据给定规则推导出唯一解。语言客观而精确。该问题不违反任何无效标准。\n3.  **结论**：问题有效。\n\n我们现在开始解题。该分析是流不敏感的，因此我们将 `main` 函数中的所有赋值作为一个必须同时成立的单一约束集来处理。点对关系是基于包含的，意味着一个抽象位置的点对集（表示为 $\\mathrm{Pt}(L)$）只会随着约束的增加而增长。\n\n让我们定义抽象位置。栈上分配的结构体变量 `s1`, `s2`, `s3`, `t1`, 和 `t2` 是不同的抽象位置，我们将其表示为 $s_1, s_2, s_3, t_1, t_2$。它们的字段产生不同的抽象字段位置，例如 $s_1.f, t_1.ps$。函数名 `A`, `B`, `C`, `D` 代表不同的函数标签位置。指针变量 `p`, `q`, `pt` 拥有点对集 $\\mathrm{Pt}(p)$, $\\mathrm{Pt}(q)$, $\\mathrm{Pt}(pt)$。数组 `arr` 被折叠成一个单一的抽象元素位置 $\\text{arr}[\\ast]$。\n\n我们通过对每个赋值语句应用给定规则来推导点对集：\n1.  `s1.f = A;`：这创建了关系 $A \\in \\mathrm{Pt}(s_1.f)$。\n2.  `s2.f = B;`：这创建了关系 $B \\in \\mathrm{Pt}(s_2.f)$。\n3.  `s3.f = C;`：这创建了关系 $C \\in \\mathrm{Pt}(s_3.f)$。\n4.  `t1.ps = `：根据取地址规则，可得 $s_1 \\in \\mathrm{Pt}(t_1.ps)$。\n5.  `t2.ps = `：类似地，可得 $s_2 \\in \\mathrm{Pt}(t_2.ps)$。\n6.  `p = `：取地址规则意味着 $s_1 \\in \\mathrm{Pt}(p)$。\n7.  `q = p;`：复制规则规定 $\\mathrm{Pt}(q) \\supseteq \\mathrm{Pt}(p)$。根据上一步，这意味着 $s_1 \\in \\mathrm{Pt}(q)$。\n8.  `q->f = B;`：这是一个通过指针存储的规则。对于 $\\mathrm{Pt}(q)$ 中的每个抽象位置 $o$，我们添加约束 $\\mathrm{Pt}(o.f) \\supseteq \\{B\\}$。由于 $\\mathrm{Pt}(q) = \\{s_1\\}$，这意味着 $\\mathrm{Pt}(s_1.f) \\supseteq \\{B\\}$。因为分析是基于包含的，我们将其与约束 (1) 结合，得到 $\\mathrm{Pt}(s_1.f) = \\{A, B\\}$。\n9.  `t1.g = D;`：这意味着 $D \\in \\mathrm{Pt}(t_1.g)$。此信息不用于目标调用点，但是完整分析状态的一部分。\n10. `arr[0] = `：折叠数组规则意味着 $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\{s_3\\}$。\n11. `arr[1] = t2.ps;`：这是从一个结构体字段复制到一个折叠数组元素。它转化为约束 $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\mathrm{Pt}(t_2.ps)$。根据约束 (5)，$\\mathrm{Pt}(t_2.ps)=\\{s_2\\}$，所以我们有 $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\{s_2\\}$。与 (10) 结合，我们得到 $\\mathrm{Pt}(\\text{arr}[\\ast]) = \\{s_2, s_3\\}$。\n12. `if (/*...*/) { pt =  } else { pt =  }`：流不敏感意味着两个分支都被考虑。这给出了两个约束：$t_1 \\in \\mathrm{Pt}(pt)$ 和 $t_2 \\in \\mathrm{Pt}(pt)$。因此，$\\mathrm{Pt}(pt) = \\{t_1, t_2\\}$。\n\n与调用点相关的最终点对集总结如下：\n- $\\mathrm{Pt}(pt) = \\{t_1, t_2\\}$\n- $\\mathrm{Pt}(t_1.ps) = \\{s_1\\}$\n- $\\mathrm{Pt}(t_2.ps) = \\{s_2\\}$\n- $\\mathrm{Pt}(s_1.f) = \\{A, B\\}$\n- $\\mathrm{Pt}(s_2.f) = \\{B\\}$\n- $\\mathrm{Pt}(s_3.f) = \\{C\\}$\n- $\\mathrm{Pt}(\\text{arr}[\\ast]) = \\{s_2, s_3\\}$\n\n现在我们为每个调用点解析调用目标。\n\n**调用点 $c_1$: `pt->ps->f(/* arg */)`**\n被调用的函数由表达式 `pt->ps->f` 的点对集决定。我们一步步地解析这个表达式。\n首先，我们找到 `pt->ps` 指向的位置集合。让我们使用一个临时的抽象指针 `temp_1`。表达式 `temp_1 = pt->ps` 对应于一个加载操作 `x = y->f`，其中 $x$ 是 `temp_1`，$y$ 是 `pt`，$f$ 是 `ps`。\n规则是：对于每个 $o \\in \\mathrm{Pt}(pt)$，我们有 $\\mathrm{Pt}(\\text{temp}_1) \\supseteq \\mathrm{Pt}(o.ps)$。\n- $\\mathrm{Pt}(pt) = \\{t_1, t_2\\}$。\n- 对于 $o = t_1$，我们将 $\\mathrm{Pt}(t_1.ps) = \\{s_1\\}$ 添加到 $\\mathrm{Pt}(\\text{temp}_1)$ 中。\n- 对于 $o = t_2$，我们将 $\\mathrm{Pt}(t_2.ps) = \\{s_2\\}$ 添加到 $\\mathrm{Pt}(\\text{temp}_1)$ 中。\n- 因此，`pt->ps` 的位置集合是 $\\mathrm{Pt}(\\text{temp}_1) = \\{s_1, s_2\\}$。\n\n接下来，我们解析调用目标 `temp_1->f`。潜在被调用者的集合是 $\\mathrm{Pt}(\\text{temp}_1)$ 中每个位置的 `.f` 字段的点对集的并集。\n- 对于位置 $s_1 \\in \\mathrm{Pt}(\\text{temp}_1)$，被调用者来自 $\\mathrm{Pt}(s_1.f) = \\{A, B\\}$。\n- 对于位置 $s_2 \\in \\mathrm{Pt}(\\text{temp}_1)$，被调用者来自 $\\mathrm{Pt}(s_2.f) = \\{B\\}$。\n$c_1$ 的总目标集是并集 $\\{A, B\\} \\cup \\{B\\} = \\{A, B\\}$。\n这产生了两个不同的调用图边：$(c_1, A)$ 和 $(c_1, B)$。\n\n**调用点 $c_2$: `arr[i]->f(/* arg */)`**\n函数由 `arr[i]->f` 的点对集决定。\n首先，我们解析 `arr[i]`。让它由一个临时指针 `temp_2` 表示。这是一个数组加载 `x = arr[i]`，其中 $x$ 是 `temp_2`。\n折叠数组的规则是 $\\mathrm{Pt}(\\text{temp}_2) \\supseteq \\mathrm{Pt}(\\text{arr}[\\ast])$。\n- 我们已经确定 $\\mathrm{Pt}(\\text{arr}[\\ast]) = \\{s_2, s_3\\}$。\n- 因此，`arr[i]` 的位置集合是 $\\mathrm{Pt}(\\text{temp}_2) = \\{s_2, s_3\\}$。\n\n接下来，我们解析调用目标 `temp_2->f`。被调用者是 $\\mathrm{Pt}(\\text{temp}_2)$ 中每个位置的 `.f` 字段的点对集的并集。\n- 对于位置 $s_2 \\in \\mathrm{Pt}(\\text{temp}_2)$，被调用者来自 $\\mathrm{Pt}(s_2.f) = \\{B\\}$。\n- 对于位置 $s_3 \\in \\mathrm{Pt}(\\text{temp}_2)$，被调用者来自 $\\mathrm{Pt}(s_3.f) = \\{C\\}$。\n$c_2$ 的总目标集是并集 $\\{B\\} \\cup \\{C\\} = \\{B, C\\}$。\n这产生了两个不同的调用图边：$(c_2, B)$ 和 $(c_2, C)$。\n\n**边的总数**\n问题明确指出，即使被调用者相同，来自不同调用点的边也是不同的。不同的边是：\n1.  $(c_1, A)$\n2.  $(c_1, B)$\n3.  $(c_2, B)$\n4.  $(c_2, C)$\n\n间接调用图不同边的总数是每个调用点边数的总和：$2 + 2 = 4$。", "answer": "$$\\boxed{4}$$", "id": "3625920"}, {"introduction": "当间接调用通过数组索引（如`a[i]()`）发生时，精确确定`i`的值往往是不可能的。为了保证安全性，编译器采用抽象解释等技术来保守地估计索引的范围。本练习 [@problem_id:3625866] 让你扮演编译器的角色，使用区间分析来确定函数指针数组中所有可能的调用目标，从而理解如何在信息不完全的情况下构建一个安全的调用图。", "problem": "您正在为一个使用函数指针数组执行间接调用的程序构建一个上下文不敏感的调用图。该调用图定义在函数集合上，其中函数为节点。如果调用者函数 $X$ 内部存在至少一个可能调用被调用者函数 $Y$ 的调用点，则从 $X$ 到 $Y$ 存在一条有向边。对于通过函数指针数组元素 $a[r]$ 进行调用的调用点，如果其数组索引 $r$ 在编译时无法精确得知，您将使用抽象解释中的区间抽象：该索引被保守地近似为一个整数区间 $[l,u]$，意味着任何 $r \\in \\{l,l+1,\\dots,u\\}$ 都是可能的。您必须从所在的调用者函数向可能位于 $a[r]$（对于某个 $r \\in [l,u]$）中的每个函数添加边。如果同一调用者内部的多个调用点可能到达同一个被调用者，您只需在该调用者和被调用者之间添加一条边。假设使用从零开始的索引、包含边界，以及一个标准的、类似于 C 语言的内存模型，且 $a$ 没有别名。\n\n全局数组 $a$ 的长度为 $12$，其内容为编译时常量，如下所示（等于 $\\mathtt{NULL}$ 的条目表示一个静态已知的空指针，它不能被调用，因此不贡献任何目标）：\n- $a[0] = u_{0}$，$a[1] = u_{1}$，$a[2] = u_{1}$，$a[3] = u_{2}$，\n- $a[4] = \\mathtt{NULL}$，$a[5] = u_{3}$，$a[6] = u_{3}$，\n- $a[7] = u_{4}$，$a[8] = u_{5}$，$a[9] = u_{5}$，\n- $a[10] = u_{6}$，$a[11] = \\mathtt{NULL}$。\n\n有三个调用者函数 $F$、$G$ 和 $H$，每个函数都包含通过 $a[\\cdot]$ 的间接调用点，其区间信息由编译器的区间分析得知，如下所示：\n- 在 $F$ 内部有两个间接调用点：一个通过 $a[i]$ 调用，其中 $i \\in [3,8]$；另一个通过 $a[j]$ 调用，其中 $j \\in [5,10]$。\n- 在 $G$ 内部有一个间接调用点：它通过 $a[k]$ 调用，其中 $k \\in [0,4]$。\n- 在 $H$ 内部有一个间接调用点：它通过 $a[m]$ 调用，其中 $m \\in [7,11]$。\n\n仅使用上述调用图的基本定义和基于区间的保守间接调用解析方法，确定由于这些间接调用而必须添加到调用图中的不同“调用者-被调用者”边的总数。即使同一调用者内部的多个调用点可以到达同一个被调用者，每对 $(\\text{caller},\\text{callee})$ 也最多只计数一次。请以单个整数形式提供最终答案。无需四舍五入。", "solution": "我们从核心定义开始。在一个函数集合上定义的调用图中，如果调用者函数中存在一个可能调用被调用者函数的调用点，那么就有一条从调用者到被调用者的有向边。对于通过函数指针数组元素 $a[r]$ 进行的间接调用，若其索引被近似为一个区间 $[l,u]$，那么为了保证可靠性（soundness），需要从所在的调用者向可能位于 $a[r]$（对于某个 $r \\in \\{l,l+1,\\dots,u\\}$）中的每个函数添加边，其中不包括值为 $\\mathtt{NULL}$ 的条目。在上下文不敏感的调用图中，同一调用者内部的多个调用点到达同一个被调用者，只会在该调用者和被调用者之间贡献一条边。因此，对于每个调用者，我们必须计算其所有调用点上潜在目标函数的并集，并计算不同目标的数量；然后我们将这些数量对所有调用者求和，因为边被定义为 $(\\text{caller},\\text{callee})$ 对。\n\n我们已知 $a$ 的确切内容：\n- $a[0] = u_{0}$，\n- $a[1] = u_{1}$，\n- $a[2] = u_{1}$，\n- $a[3] = u_{2}$，\n- $a[4] = \\mathtt{NULL}$，\n- $a[5] = u_{3}$，\n- $a[6] = u_{3}$，\n- $a[7] = u_{4}$，\n- $a[8] = u_{5}$，\n- $a[9] = u_{5}$，\n- $a[10] = u_{6}$，\n- $a[11] = \\mathtt{NULL}$。\n\n我们现在逐一分析每个调用者。\n\n对于调用者 $F$，有两个调用点，其索引区间分别为 $[3,8]$ 和 $[5,10]$。\n- 对于 $i \\in [3,8]$，索引为 $3,4,5,6,7,8$，可能的目标条目为 $a[3]=u_{2}$、$a[4]=\\mathtt{NULL}$、$a[5]=u_{3}$、$a[6]=u_{3}$、$a[7]=u_{4}$、$a[8]=u_{5}$。排除 $\\mathtt{NULL}$ 后，可能的目标集合是 $\\{u_{2},u_{3},u_{4},u_{5}\\}$。\n- 对于 $j \\in [5,10]$，索引为 $5,6,7,8,9,10$，目标条目为 $a[5]=u_{3}$、$a[6]=u_{3}$、$a[7]=u_{4}$、$a[8]=u_{5}$、$a[9]=u_{5}$、$a[10]=u_{6}$。此范围内没有 $\\mathtt{NULL}$ 条目，因此目标集合是 $\\{u_{3},u_{4},u_{5},u_{6}\\}$。\n- 对 $F$ 内部的两个调用点取并集，得到 $\\{u_{2},u_{3},u_{4},u_{5},u_{6}\\}$。\n因此，$F$ 贡献了到 $5$ 个不同被调用者的边。\n\n对于调用者 $G$，有一个调用点，其 $k \\in [0,4]$，即索引为 $0,1,2,3,4$。目标条目为 $a[0]=u_{0}$、$a[1]=u_{1}$、$a[2]=u_{1}$、$a[3]=u_{2}$、$a[4]=\\mathtt{NULL}$。排除 $\\mathtt{NULL}$ 后，可能的目标集合是 $\\{u_{0},u_{1},u_{2}\\}$。因此，$G$ 贡献了到 $3$ 个不同被调用者的边。\n\n对于调用者 $H$，有一个调用点，其 $m \\in [7,11]$，即索引为 $7,8,9,10,11$。目标条目为 $a[7]=u_{4}$、$a[8]=u_{5}$、$a[9]=u_{5}$、$a[10]=u_{6}$、$a[11]=\\mathtt{NULL}$。排除 $\\mathtt{NULL}$ 后，可能的目标集合是 $\\{u_{4},u_{5},u_{6}\\}$。因此，$H$ 贡献了到 $3$ 个不同被调用者的边。\n\n因为调用图是定义在“调用者-被调用者”对上的，并且我们对每个调用者最多计数每对一次，所以由于这些间接调用而添加的不同边的总数是每个调用者的不同目标集大小的总和：\n$$\n|E| \\;=\\; 5 \\;+\\; 3 \\;+\\; 3 \\;=\\; 11.\n$$\n不需要在不同调用者之间进行进一步的去重，因为根据定义，具有不同调用者的对是不同的边。因此，总数为 $11$。", "answer": "$$\\boxed{11}$$", "id": "3625866"}, {"introduction": "面向对象语言的调用图构建与C语言有很大不同，其核心在于解析动态派发（虚调用）。本练习 [@problem_id:3625899] 聚焦于一种重要的分析技术——快速类型分析（RTA），它利用程序中实际创建的对象类型信息来精确化调用目标。你将通过分析一个包含继承、方法重写以及`this`和`super`调用的Java风格程序，来掌握区分和解析不同类型调用的方法。", "problem": "考虑一种类Java的、单继承、名义类型、静态类型的面向对象语言，其中所有实例方法都是虚方法，并且 `super.m()` 形式的表达式使用直接超类解析规则。假设采用全程序、上下文不敏感、流不敏感的快速类型分析（RTA），其定义如下：对于实例方法体内的某个调用点，该调用点的接收者类型集合 $T(\\text{this})$ 是指在被分析的程序中，可能动态调用其所在方法的运行时类的集合。对于一个虚调用 `this.m()`，调用图会为每个接收者类 $R \\in T(\\text{this})$ 添加一条边，指向动态查找为该接收者选择的唯一目标；如果不同的接收者映射到同一个目标方法，重复的边将被合并。对于一个超类调用 `super.m()`，调用图会添加一条单独的边，指向在包含该调用的类的直接超类中定义的方法体；这个目标不依赖于 $T(\\text{this})$。\n\n类层次结构和方法如下（方法体是无关紧要的，除非它们包含调用）：\n- 类 A 定义了实例方法 m()、n() 和 k()。\n- 类 B 继承自 A 并重写了 m() 和 n()。类 B 还额外定义了一个实例方法 t()，其方法体按顺序包含四个调用点：`super.m()`、`this.m()`、`super.n()`、`this.n()`。\n- 类 C 继承自 B 并重写了 m()，但没有重写 n()。\n- 类 D 继承自 B 并重写了 n()，但没有重写 m()。\n\n入口点执行的分配和调用如下：\n- 分配一个 B 的实例和一个 C 的实例。\n- 在这两个已分配的实例上调用 t() (例如，通过静态类型为 B 的变量)。\n- D 的实例从未被分配，也没有其他分配或调用。\n\n仅使用上述语义和单继承的基本动态方法查找规则——即，在一个动态类为 $R$ 的接收者上的虚调用，会通过搜索 $R$、然后是它的超类，以此类推，解析到在静态接收者类型中声明的方法的最具体重写版本——构建由 B.t() 方法体中的四个调用点贡献的调用图边。在指定的快速类型分析下，计算由这四个调用点添加的不同调用图边的总数。用一个整数表达你的答案。不需要四舍五入。", "solution": "首先验证问题，以确保其自洽、有科学依据且定义良好。\n\n### 步骤 1：提取已知条件\n- **语言和语义**：一种类Java的、单继承、名义类型、静态类型的面向对象语言。所有实例方法都是虚方法。`super.m()` 调用解析到包含该调用点的类的直接超类中的方法。\n- **分析类型**：全程序、上下文不敏感、流不敏感的快速类型分析（RTA）。\n- **RTA对虚调用的定义**：对于方法内的虚调用 `this.m()`，调用图为每个运行时类 $R \\in T(\\text{this})$ 包含一条边，指向通过动态查找解析出的目标方法。$T(\\text{this})$ 是可以调用所在方法的运行时类的集合。指向同一目标的重复边将被合并。\n- **RTA对超类调用的定义**：对于 `super.m()` 调用，会添加一条单独的边，指向在词法上出现该调用的类的直接超类中定义的方法。此解析独立于 $T(\\text{this})$。\n- **类层次结构**：\n    - `class A` 定义了方法 $m()$、$n()$ 和 $k()$。\n    - `class B extends A` 重写了 $m()$ 和 $n()$。它定义了一个新方法 $t()$，其方法体包含调用：`super.m()`、`this.m()`、`super.n()`、`this.n()`。\n    - `class C extends B` 重写了 $m()$。它没有重写 $n()$。\n    - `class D extends B` 重写了 $n()$。它没有重写 $m()$。\n- **程序执行（入口点）**：\n    - 分配了一个类 $B$ 的实例。\n    - 分配了一个类 $C$ 的实例。\n    - 方法 $t()$ 在 $B$ 的实例和 $C$ 的实例上都被调用。\n    - 类 $D$ 的实例从未被分配。\n    - 程序中没有发生其他分配或调用。\n- **任务**：确定由 $B.t()$ 方法体内的四个调用点添加的不同调用图边的总数。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题定义明确，并基于编译器设计和程序分析的既定原则。\n- **科学依据**：该问题描述了快速类型分析（RTA）和标准的面向对象分派语义（虚调用和超类调用），这些都是编译器理论中的核心概念。该模型是对此类分析工作方式的简化但准确的表示。\n- **定义良好**：类层次结构、方法定义和程序行为都得到了精确的规定。构建调用图的规则是明确的。这种设置允许一个唯一且可确定的解。\n- **客观和完整**：问题以形式化、无歧义的术语陈述。执行分析所需的所有必要信息都已提供。没有矛盾之处。\n\n### 步骤 3：结论和行动\n问题有效。将提供一个有理有据的解决方案。\n\n### 解决方案\n目标是计算源自方法 $B.t()$ 中四个调用点的不同调用图边的数量。这需要确定方法 $B.t()$ 的可能运行时接收者类型集合，然后根据快速类型分析（RTA）的规则分析每个调用点。\n\n**1. 确定 $B.t()$ 的接收者类型集合**\n方法 $B.t()$ 的 RTA 接收者类型集合，记为 $T(\\text{this})$，是指方法 $t()$ 在其上被动态调用的所有对象的运行时类的集合。\n- 程序分配了一个类 $B$ 的实例，并在其上调用 $t()$。接收者的动态类型是 $B$。在 $B$ 对象上对 $t()$ 进行动态分派时，从类 $B$ 开始。由于 $B$ 定义了 $t()$，调用解析为 $B.t()$。因此，$B \\in T(\\text{this})$。\n- 程序分配了一个类 $C$ 的实例，并在其上调用 $t()$。接收者的动态类型是 $C$。在 $C$ 对象上对 $t()$ 进行动态分派时，从类 $C$ 开始。类 $C$ 没有定义 $t()$，因此搜索进入其超类 $B$。类 $B$ 定义了 $t()$，因此调用解析为 $B.t()$。因此，$C \\in T(\\text{this})$。\n- 类 $D$ 的实例从未被分配，因此它不能成为任何方法调用的接收者。\n根据全程序信息，可能动态调用 $B.t()$ 的运行时类的集合是 $\\{B, C\\}$。因此，对于 $B.t()$ 内的所有调用点，接收者类型集合为 $T(\\text{this}) = \\{B, C\\}$。\n\n**2. 分析 $B.t()$ 中的调用点**\n$B.t()$ 的方法体包含四个调用点。我们逐一分析以确定它们贡献的调用图边。\n\n**调用点 1: `super.m()`**\n- 根据 RTA 对 `super` 调用的规则，目标由词法上下文静态确定。\n- 调用 `super.m()` 出现在方法 $B.t()$ 中，该方法在类 $B$ 中定义。\n- $B$ 的直接超类是 $A$。\n- 调用解析为类 $A$ 中 $m()$ 的实现。\n- 这向调用图添加一条边：$B.t() \\rightarrow A.m()$。\n\n**调用点 2: `this.m()`**\n- 这是一个虚调用。目标取决于 $T(\\text{this}) = \\{B, C\\}$ 中的类型。\n- 对于运行时类型为 $B$ 的接收者：对 $m()$ 的动态查找从类 $B$ 开始。类 $B$ 重写了 $m()$。目标是 $B.m()$。这添加了边 $B.t() \\rightarrow B.m()$。\n- 对于运行时类型为 $C$ 的接收者：对 $m()$ 的动态查找从类 $C$ 开始。类 $C$ 重写了 $m()$。目标是 $C.m()$。这添加了边 $B.t() \\rightarrow C.m()$。\n- 这两个目标 $B.m()$ 和 $C.m()$ 是不同的。因此，该调用点贡献了两条不同的边。\n\n**调用点 3: `super.n()`**\n- 这是另一个 `super` 调用，静态解析。\n- 该调用位于类 $B$ 的方法中。直接超类是 $A$。\n- 调用解析为类 $A$ 中 $n()$ 的实现。\n- 这向调用图添加一条边：$B.t() \\rightarrow A.n()$。\n\n**调用点 4: `this.n()`**\n- 这是一个虚调用。目标取决于 $T(\\text{this}) = \\{B, C\\}$ 中的类型。\n- 对于运行时类型为 $B$ 的接收者：对 $n()$ 的动态查找从类 $B$ 开始。类 $B$ 重写了 $n()$。目标是 $B.n()$。这添加了边 $B.t() \\rightarrow B.n()$。\n- 对于运行时类型为 $C$ 的接收者：对 $n()$ 的动态查找从类 $C$ 开始。类 $C$ 没有重写 $n()$ ，因此搜索继续到其超类 $B$。类 $B$ 重写了 $n()$。目标是 $B.n()$。\n- 运行时类型 $B$ 和 $C$ 都解析到同一个目标方法 $B.n()$。RTA 定义规定重复的边将被合并。\n- 因此，该调用点只贡献一条不同的边：$B.t() \\rightarrow B.n()$。\n\n**3. 不同边的总和**\n我们列出由四个调用点从源 $B.t()$ 贡献的所有唯一边：\n1. 来自 `super.m()`: $B.t() \\rightarrow A.m()$\n2. 来自 `this.m()`: $B.t() \\rightarrow B.m()$\n3. 来自 `this.m()`: $B.t() \\rightarrow C.m()$\n4. 来自 `super.n()`: $B.t() \\rightarrow A.n()$\n5. 来自 `this.n()`: $B.t() \\rightarrow B.n()$\n\n所有五个目标方法（$A.m()$、$B.m()$、$C.m()$、$A.n()$ 和 $B.n()$）都是不同的实现。因此，这五条边是不同的。\n添加的不同调用图边的总数是每次分析得出的边的总和：来自 `super.m()` 的 $1$ 条边，来自 `this.m()` 的 $2$ 条边，来自 `super.n()` 的 $1$ 条边，以及来自 `this.n()` 的 $1$ 条边。\n总边数 = $1 + 2 + 1 + 1 = 5$。", "answer": "$$\n\\boxed{5}\n$$", "id": "3625899"}]}