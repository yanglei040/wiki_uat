{"hands_on_practices": [{"introduction": "过程间分析的一个核心任务是总结函数对程序状态的影响。修改-引用（Mod-Ref）分析是理解函数副作用（side effects）的基石，它能确定一个函数可能读取或写入哪些全局变量或内存位置。这项实践将指导你为一个简单的程序手动计算Mod-Ref集，并利用这些信息来推断函数是否为“纯函数”，这对于许多编译器优化（如公共子表达式消除和代码移动）至关重要。通过这个练习，你将掌握在上下文不敏感的设定下，如何系统地聚合整个调用图（call graph）上的程序效应。[@problem_id:3647898]", "problem": "给定一个关于整数的小型函数库，用于研究过程间分析的基础。该程序具有全局符号，划分如下：\n- 可变全局变量：$G_a$, $G_b$。\n- 只读常量：$C_a$, $C_b$。\n- 一个伪全局变量 $I$，它总结了所有输入/输出 (I/O) 效应。\n\n定义了以下函数（所有算术运算都是纯整数算术且会终止）：\n- $f_1(x)$：返回 $x + C_a$。\n- $f_2(x)$：赋值 $G_a := G_a + 1$ 并返回 $x$。\n- $f_3(x)$：计算 $t := f_1(x)$ 并返回 $t + C_b$。\n- $f_4(x)$：如果 $x$ 是奇数，则赋值 $G_b := x$；在所有情况下都返回 $f_2(x)$。\n- $f_5(x)$：返回 $f_3(x) + f_1(0)$。\n- $f_6(x)$：读取 $G_b$ 的当前值并返回 $x + G_b$。\n- $f_7(x)$：执行 $print(x)$（建模为 I/O 效应）并返回 $x$。\n- $f_8(x)$：返回 $f_5(x) + f_6(0) - f_2(0)$。\n\n假设一个全程序、上下文不敏感、流不敏感的 mod-ref 分析。对于每个函数 $f$，分析会计算两个集合：$\\mathrm{Mod}(f)$，即 $f$ 可能写入的全局变量集合；以及 $\\mathrm{Ref}(f)$，即 $f$ 可能读取的全局变量集合。这些集合由以下基本规则定义：\n- 如果 $f$ 的函数体直接写入一个全局变量 $g$，则 $g \\in \\mathrm{Mod}(f)$；如果它直接读取一个全局变量 $g$，则 $g \\in \\mathrm{Ref}(f)$。\n- 如果 $f$ 调用函数 $h$，则 $\\mathrm{Mod}(h) \\subseteq \\mathrm{Mod}(f)$ 且 $\\mathrm{Ref}(h) \\subseteq \\mathrm{Ref}(f)$。\n- 对于条件控制流，分析会对所有分支取集合的并集（流不敏感性）。\n- 内置的 $print$ 函数被建模为 $\\mathrm{Mod}(\\text{print}) = \\{I\\}$ 和 $\\mathrm{Ref}(\\text{print}) = \\varnothing$。\n- 一个函数 $f$ 被认为是纯函数，当且仅当 $\\mathrm{Mod}(f) = \\varnothing$ 且 $\\mathrm{Ref}(f) \\subseteq \\{C_a, C_b\\}$；也就是说，它不写入任何可变全局变量或 $I$，并且只读取只读常量。\n\n将两个函数 $f$ 和 $g$ 在参数 $x$ 上的复合定义为 $(f \\circ g)(x) = f(g(x))$。\n\n任务：\n- 仅使用上述定义，推断所有 $i \\in \\{1,2,3,4,5,6,7,8\\}$ 的 $\\mathrm{Mod}(f_i)$ 和 $\\mathrm{Ref}(f_i)$，并确定哪些函数是纯函数。\n- 令 $S = \\{f_1,f_2,f_3,f_4,f_5,f_6,f_7,f_8\\}$。使用相同的分析方法，如果一个复合函数 $f \\circ g$ 在过程间 mod-ref 规则下满足纯度标准，则它被认为是纯函数。令 $N$ 为有序对 $(f,g) \\in S \\times S$ 的数量，使得 $f \\circ g$ 通过此分析可被证明为纯函数。\n- 计算 $N$ 的值。以单个整数形式提供您的答案。无需四舍五入。", "solution": "用户要求我解决一个基于编译器设计中过程间静态分析原理的问题。该问题被认为是有效的，因为它在科学上基于已建立的编译器理论，其规则清晰一致，表述客观，是一个良构问题。它要求系统地应用所提供的 mod-ref 分析和函数纯度的定义来得出一个数值结果。\n\n该分析被定义为全程序、上下文不敏感和流不敏感的 mod-ref 分析。函数 $f$ 的集合 $\\mathrm{Mod}(f)$ 和 $\\mathrm{Ref}(f)$ 是通过聚合函数体本身以及它传递性调用的所有函数的效应来计算的。对于一个调用了函数集合 $H$ 的函数 $f$，规则如下：\n$$ \\mathrm{Mod}(f) = (\\text{direct modifications in } f) \\cup \\bigcup_{h \\in H} \\mathrm{Mod}(h) $$\n$$ \\mathrm{Ref}(f) = (\\text{direct references in } f) \\cup \\bigcup_{h \\in H} \\mathrm{Ref}(h) $$\n由于整个程序的源代码都是可用的，这些集合可以通过求解该方程组的最小不动点来确定。函数 $f_1, \\dots, f_8$ 之间的调用图是一个有向无环图 (DAG)，因此我们可以按照调用图的逆拓扑排序进行单次遍历来计算这些集合。\n\n首先，我们确定每个函数的直接效应和调用：\n- $f_1(x)$：读取 $C_a$。无调用。直接-Mod: $\\varnothing$，直接-Ref: $\\{C_a\\}$。\n- $f_2(x)$：读取并写入 $G_a$。无调用。直接-Mod: $\\{G_a\\}$，直接-Ref: $\\{G_a\\}$。\n- $f_3(x)$：调用 $f_1$。读取 $C_b$。直接-Mod: $\\varnothing$，直接-Ref: $\\{C_b\\}$。调用: $\\{f_1\\}$。\n- $f_4(x)$：写入 $G_b$（流不敏感性意味着我们包含所有分支的效应）。调用 $f_2$。直接-Mod: $\\{G_b\\}$，直接-Ref: $\\varnothing$。调用: $\\{f_2\\}$。\n- $f_5(x)$：调用 $f_3$ 和 $f_1$。直接-Mod: $\\varnothing$，直接-Ref: $\\varnothing$。调用: $\\{f_1, f_3\\}$。\n- $f_6(x)$：读取 $G_b$。无调用。直接-Mod: $\\varnothing$，直接-Ref: $\\{G_b\\}$。\n- $f_7(x)$：调用 `print`。问题陈述 $\\mathrm{Mod}(\\text{print}) = \\{I\\}$ 和 $\\mathrm{Ref}(\\text{print}) = \\varnothing$。直接-Mod: $\\varnothing$，直接-Ref: $\\varnothing$。调用: $\\{\\text{print}\\}$。\n- $f_8(x)$：调用 $f_5, f_6, f_2$。直接-Mod: $\\varnothing$，直接-Ref: $\\varnothing$。调用: $\\{f_2, f_5, f_6\\}$。\n\n现在，我们通过沿调用图向上传播效应来计算每个函数的最终 $\\mathrm{Mod}$ 和 $\\mathrm{Ref}$ 集合。\n\n1.  **没有调用其他 $f_i$ 的函数（调用图的叶节点）：**\n    -   $f_1$: $\\mathrm{Mod}(f_1) = \\varnothing$；$\\mathrm{Ref}(f_1) = \\{C_a\\}$。\n    -   $f_2$: $\\mathrm{Mod}(f_2) = \\{G_a\\}$；$\\mathrm{Ref}(f_2) = \\{G_a\\}$。\n    -   $f_6$: $\\mathrm{Mod}(f_6) = \\varnothing$；$\\mathrm{Ref}(f_6) = \\{G_b\\}$。\n    -   $f_7$: $\\mathrm{Mod}(f_7) = \\mathrm{Mod}(\\text{print}) = \\{I\\}$；$\\mathrm{Ref}(f_7) = \\mathrm{Ref}(\\text{print}) = \\varnothing$。\n\n2.  **调用上述函数的函数：**\n    -   $f_3$ 调用 $f_1$：\n        $\\mathrm{Mod}(f_3) = \\mathrm{Mod}(f_1) = \\varnothing$。\n        $\\mathrm{Ref}(f_3) = \\{C_b\\} \\cup \\mathrm{Ref}(f_1) = \\{C_b\\} \\cup \\{C_a\\} = \\{C_a, C_b\\}$。\n    -   $f_4$ 调用 $f_2$：\n        $\\mathrm{Mod}(f_4) = \\{G_b\\} \\cup \\mathrm{Mod}(f_2) = \\{G_b\\} \\cup \\{G_a\\} = \\{G_a, G_b\\}$。\n        $\\mathrm{Ref}(f_4) = \\mathrm{Ref}(f_2) = \\{G_a\\}$。\n\n3.  **调用上述函数的函数：**\n    -   $f_5$ 调用 $f_3$ 和 $f_1$：\n        $\\mathrm{Mod}(f_5) = \\mathrm{Mod}(f_3) \\cup \\mathrm{Mod}(f_1) = \\varnothing \\cup \\varnothing = \\varnothing$。\n        $\\mathrm{Ref}(f_5) = \\mathrm{Ref}(f_3) \\cup \\mathrm{Ref}(f_1) = \\{C_a, C_b\\} \\cup \\{C_a\\} = \\{C_a, C_b\\}$。\n\n4.  **顶层函数：**\n    -   $f_8$ 调用 $f_5, f_6, f_2$：\n        $\\mathrm{Mod}(f_8) = \\mathrm{Mod}(f_5) \\cup \\mathrm{Mod}(f_6) \\cup \\mathrm{Mod}(f_2) = \\varnothing \\cup \\varnothing \\cup \\{G_a\\} = \\{G_a\\}$。\n        $\\mathrm{Ref}(f_8) = \\mathrm{Ref}(f_5) \\cup \\mathrm{Ref}(f_6) \\cup \\mathrm{Ref}(f_2) = \\{C_a, C_b\\} \\cup \\{G_b\\} \\cup \\{G_a\\} = \\{G_a, G_b, C_a, C_b\\}$。\n\n接下来，我们确定哪些函数是纯函数。一个函数 $f$ 是纯函数，如果 $\\mathrm{Mod}(f) = \\varnothing$ 且 $\\mathrm{Ref}(f) \\subseteq \\{C_a, C_b\\}$。\n-   $f_1$: $\\mathrm{Mod}(f_1) = \\varnothing$ 且 $\\mathrm{Ref}(f_1) = \\{C_a\\} \\subseteq \\{C_a, C_b\\}$。**纯函数**。\n-   $f_2$: $\\mathrm{Mod}(f_2) = \\{G_a\\} \\neq \\varnothing$。非纯函数。\n-   $f_3$: $\\mathrm{Mod}(f_3) = \\varnothing$ 且 $\\mathrm{Ref}(f_3) = \\{C_a, C_b\\} \\subseteq \\{C_a, C_b\\}$。**纯函数**。\n-   $f_4$: $\\mathrm{Mod}(f_4) = \\{G_a, G_b\\} \\neq \\varnothing$。非纯函数。\n-   $f_5$: $\\mathrm{Mod}(f_5) = \\varnothing$ 且 $\\mathrm{Ref}(f_5) = \\{C_a, C_b\\} \\subseteq \\{C_a, C_b\\}$。**纯函数**。\n-   $f_6$: $\\mathrm{Mod}(f_6) = \\varnothing$ 但 $\\mathrm{Ref}(f_6) = \\{G_b\\} \\not\\subseteq \\{C_a, C_b\\}$。非纯函数。\n-   $f_7$: $\\mathrm{Mod}(f_7) = \\{I\\} \\neq \\varnothing$。非纯函数。\n-   $f_8$: $\\mathrm{Mod}(f_8) = \\{G_a\\} \\neq \\varnothing$。非纯函数。\n\n纯函数的集合是 $P = \\{f_1, f_3, f_5\\}$。\n\n最后的任务是找到有序对 $(f, g) \\in S \\times S$ 的数量 $N$，使得复合函数 $(f \\circ g)(x) = f(g(x))$ 可被证明为纯函数。为了分析 $f \\circ g$，我们将其概念化为一个新函数 $h(x)$，其函数体由对 $f$ 和 $g$ 的调用组成。由于分析的上下文不敏感和流不敏感特性，$h$ 的效应是其组成调用的效应的并集。\n$$ \\mathrm{Mod}(f \\circ g) = \\mathrm{Mod}(f) \\cup \\mathrm{Mod}(g) $$\n$$ \\mathrm{Ref}(f \\circ g) = \\mathrm{Ref}(f) \\cup \\mathrm{Ref}(g) $$\n要使 $f \\circ g$ 为纯函数，它必须满足纯度条件：\n1.  $\\mathrm{Mod}(f \\circ g) = \\mathrm{Mod}(f) \\cup \\mathrm{Mod}(g) = \\varnothing$。这当且仅当 $\\mathrm{Mod}(f) = \\varnothing$ 且 $\\mathrm{Mod}(g) = \\varnothing$ 时成立。\n2.  $\\mathrm{Ref}(f \\circ g) = \\mathrm{Ref}(f) \\cup \\mathrm{Ref}(g) \\subseteq \\{C_a, C_b\\}$。这当且仅当 $\\mathrm{Ref}(f) \\subseteq \\{C_a, C_b\\}$ 且 $\\mathrm{Ref}(g) \\subseteq \\{C_a, C_b\\}$ 时成立。\n\n这两个条件合在一起，等价于声明函数 $f$ 和函数 $g$ 本身都必须是纯函数。因此，我们正在寻找有序对 $(f, g)$ 的数量，其中 $f$ 和 $g$ 都是纯函数集合 $P$ 的元素。\n纯函数的集合是 $P = \\{f_1, f_3, f_5\\}$，其大小为 $|P| = 3$。\n此类有序对的数量是笛卡尔积 $P \\times P$ 的大小。\n$$ N = |P \\times P| = |P| \\times |P| = 3 \\times 3 = 9 $$\n$N$ 的值为 $9$。", "answer": "$$\n\\boxed{9}\n$$", "id": "3647898"}, {"introduction": "虽然函数摘要为过程间分析提供了有效途径，但简单的上下文不敏感分析存在精度限制。这个思想实验利用污点分析（taint analysis）来揭示上下文不敏感分析的一个典型陷阱：产生“不可实现路径”（unrealizable paths）或“伪路径”（spurious paths）。你将看到，当分析忽略了函数调用的“调用-返回”匹配原则时，一个调用上下文中的数据（例如，一个被污染的值）会如何在分析模型中错误地“泄露”到另一个完全不相关的调用上下文中，从而导致误报（false positives）。理解这个问题是认识到更精确的上下文敏感分析为何必要的第一步。[@problem_id:3647942]", "problem": "考虑以下具有显式源和返回值的程序骨架。变量名、函数名和常量都是数学实体，并以 LaTeX 格式书写。\n\n函数 $id$ 接受两个参数 $x$ 和 $d$，其定义如下：\n- 如果 $d = 0$，返回 $x$。\n- 否则，返回 $id(x, d - 1)$。\n\n过程 $callerTainted$：\n- $a := \\text{source}()$，它返回一个受污染的整数，\n- $r_1 := id(a, 1)$，\n- $\\text{sinkTainted}(r_1)$。\n\n过程 $callerClean$：\n- $b := 0$，\n- $r_2 := id(b, 1)$，\n- $y := r_2$。\n\n过程 $main$：\n- 调用 $callerTainted$，\n- 调用 $callerClean$。\n\n假设一个标准的过程间控制流图 (ICFG) 模型，其中调用边将调用点连接到被调用者的入口，返回边将被调用者的出口连接回调用者的返回点。一条有效的过程间路径遵循匹配的调用-返回规则：每次返回都必须回到发出最近的未匹配调用的动态调用者（即，对应于下推系统的括号良匹配条件）。\n\n现在考虑一种过程间污点分析，在存在递归的情况下，该分析在ICFG上执行图可达性分析，但忽略了返回至调用者的匹配约束，实际上将返回边视为可以连接到同一函数的任何调用后位置的普通边（即返回的调用点不敏感性）。污点源是 $callerTainted$ 中的 $\\text{source}()$。根据上述定义，$id$ 函数返回其参数，因此污点会沿着定值-使用链和 $id$ 的返回进行传播。\n\n在“忽略返回至调用者匹配”这一近似下，哪个陈述正确地描述了分析结果？\n\nA. 只有 $r_1$ 被污染；在健全和不健全的分析下，$y$ 都保持未污染状态，因为递归不影响返回的传播。\n\nB. $y$ 被虚假地污染：从 $callerTainted$ 中对 $id$ 的递归调用产生的一条不匹配的返回路径，可以流向 $callerClean$ 中的调用后位置，从而过度污染 $r_2$，并因此污染 $y$。\n\nC. 即使在返回正确匹配的情况下，$r_1$ 和 $r_2$ 也都被合理地污染；递归导致 $id$ 在所有上下文中都返回一个受污染的值。\n\nD. 在任何过程间分析下，没有变量被污染，因为返回不会跨过程边界传播污点。", "solution": "该问题陈述经证实是科学上合理、表述清晰且客观的。它描述了静态程序分析中的一个标准场景，特别是过程间污点分析，并探讨了一种常见的精度与性能权衡所带来的后果。\n\n问题的核心在于理解一种过程间污点分析的行为，该分析对函数返回使用了一种简化的模型。该分析在过程间控制流图 (ICFG) 上执行图可达性分析，但它“忽略了返回至调用者的匹配约束”。这意味着当一个函数（例如 `$f$`）返回时，分析假设控制流（以及数据流）可以继续到程序中*任何*对 `$f$` 的调用之后的语句，而不仅仅是启动当前 `$f$` 执行的那一次调用。这是一种上下文不敏感性。\n\n让我们逐步追踪分析过程。\n\n程序执行始于 `main`，它首先调用 `callerTainted`，然后调用 `callerClean`。\n\n1.  **对 `callerTainted` 的分析：**\n    *   语句 `$a := \\text{source}()$` 被执行。根据定义，赋给 `$a$` 的值是受污染的。\n    *   通过 `$r_1 := id(a, 1)$` 调用函数 `$id$`。由于 `$a$` 受污染，`$id$` 的第一个参数（我们称之为 `$x$`）也变得受污染。第二个参数 `$d$` 是 `$1$`。\n    *   在 `$id(x, 1)$` 内部，条件 `$d = 0$` 为假。函数递归调用自身：`$id(x, d - 1)`，即 `$id(x, 0)$`。`$x$` 的受污染值被传递给这个递归调用。\n    *   在 `$id(x, 0)$` 内部，条件 `$d = 0$` 为真。函数返回其参数 `$x$`。由于 `$x$` 受污染，`$id$` 的返回值也受污染。\n    *   这个受污染的值从递归调用返回到外层的 `$id(x, 1)`，然后外层函数立即返回它。\n    *   在顶层调用 `$id(a, 1)$` 的出口点，返回一个受污染的值。\n\n2.  **对返回流和 `callerClean` 的分析：**\n    *   一个健全的、遵循匹配的调用-返回对的分析，会将这个受污染的返回值仅传播到其在 `callerTainted` 中对应的调用点。这将污染 `$r_1$`，并且对 `callerTainted` 的分析将结束。随后对 `callerClean` 的分析将从没有受污染数据开始。\n    *   然而，问题指定了一种**忽略返回至调用者匹配约束**的分析。该分析模型将 `$id$` 的出口连接到所有可能的返回点。\n    *   程序包含两个对 `$id$` 的顶层调用点：\n        1.  在 `callerTainted` 中：`$r_1 := id(a, 1)$`。设其返回点为 `$RS_1$`。\n        2.  在 `callerClean` 中：`$r_2 := id(b, 1)$`。设其返回点为 `$RS_2$`。\n    *   当 `$id$` 的出口产生一个受污染的值时（源于 `callerTainted` 中的调用），不健全的分析会创建到 `$RS_1$` 和 `$RS_2$` 的数据流路径。\n    *   到 `$RS_1$` 的路径是合理的。它导致 `$r_1$` 被赋予受污染的值。\n    *   到 `$RS_2$` 的路径是虚假的。它创建了一个“串扰”或“不可实现路径”，使得一个函数调用（`$id(a, 1)$`）的结果看起来像是另一个完全不同的调用（`$id(b, 1)$`）的结果。\n    *   由于这条虚假路径，分析得出结论，认为 `callerClean` 中的调用 `$id(b, 1)$` 可以返回一个受污染的值。\n    *   因此，变量 `$r_2$` 被标记为受污染。\n    *   下一条语句是 `$y := r_2$`。由于这个定值-使用关系，污点从 `$r_2$` 传播到 `$y$`。\n    *   因此，在这种分析中 `$y$` 变得受污染。这是一个假阳性，因为程序的任何实际执行都不会导致 `$y$` 持有受污染的值。\n\n总而言之，由于无法区分函数 `$id$` 的不同调用上下文，所指定的分析正确地将 `$r_1$` 识别为受污染，但错误地将 `$r_2$` 和 `$y$` 识别为受污染。\n\n现在，我们评估每个选项：\n\n**A. 只有 $r_1$ 被污染；在健全和不健全的分析下，$y$ 都保持未污染状态，因为递归不影响返回的传播。**\n这个陈述是**不正确的**。虽然在健全分析下 `$y$` 会保持未污染，但问题明确描述了一种允许不匹配返回的不健全分析。如上所述，这种特定的不健全性导致 `$y$` 被虚假地污染。其给出的理由也是有缺陷的；递归与从不同上下文调用的共享函数的组合，恰恰暴露了分析模型的不精确性。\n\n**B. $y$ 被虚假地污染：从 $callerTainted$ 中对 $id$ 的递归调用产生的一条不匹配的返回路径，可以流向 $callerClean$ 中的调用后位置，从而过度污染 $r_2$，并因此污染 $y$。**\n这个陈述是**正确的**。它准确地描述了结果（`$y$` 被虚假地污染）以及导致该结果的确切机制。分析创建了一条从 `callerTainted` 中启动的调用链到 `callerClean` 中返回点的“不匹配的返回路径”。这导致了 `$r_2$` 以及随后的 `$y$` 被污染。这与我们的推导完全一致。\n\n**C. 即使在返回正确匹配的情况下，$r_1$ 和 $r_2$ 也都被合理地污染；递归导致 $id$ 在所有上下文中都返回一个受污染的值。**\n这个陈述是**不正确的**。`$r_2$`（以及 `$y$`）的污染不是合理的；它是由分析的不精确性导致的假阳性。一个具有“正确匹配的返回”（即健全的、上下文敏感的分析）的分析会发现，`callerClean` 中的调用 `$id(b, 1)$` 仅在干净数据（`$b=0$`）上操作，因此其返回值是干净的。递归不会导致一个函数在所有上下文中都被污染，只会在其输入受污染的上下文中被污染。\n\n**D. 在任何过程间分析下，没有变量被污染，因为返回不会跨过程边界传播污点。**\n这个陈述是**不正确的**。它做出了一个与问题陈述中给出的前提相矛盾的事实性声明。问题明确指出，“污点会沿着定值-使用链和 $id$ 的返回进行传播”。函数 `$id$` 是其第一个参数的恒等函数，因此它是一个精确地将数据（以及污点）从其参数传播到其返回值，跨越过程边界的典型函数示例。因此，`$r_1$` 必须被污染。", "answer": "$$\\boxed{B}$$", "id": "3647942"}, {"introduction": "现在，让我们将过程间分析的原理应用于一个高度实用的场景：确保程序正确地遵守API协议。无论是文件句柄、数据库连接还是硬件锁，许多资源都必须遵循严格的使用流程（例如，`打开-写入-关闭`）。此练习将一个资源生命周期建模为一个类型状态机（type-state machine），并要求你应用过程间数据流分析来跟踪资源在函数调用链中的状态。通过将函数总结为状态转换器，你的分析将能够自动检测出那些违反协议的危险操作，例如对一个已经关闭的文件进行写入，从而展示出这些技术在发现真实世界软件缺陷中的强大威力。[@problem_id:3647964]", "problem": "给定一个针对单一资源的简单类型状态协议，其状态和操作定义如下。资源类型状态由有限集 $\\{U,O,X,E\\}$ 建模，其中 $U$ 表示未打开， $O$ 表示已打开， $X$ 表示已关闭，而 $E$ 是一个错误汇集状态。预期的协议是对一个未打开的资源精确调用一次 open 以进入状态 $O$，在状态 $O$ 时可以调用任意次 write，以及从状态 $O$ 精确调用一次 close 以进入状态 $X$。在不允许操作的状态下应用任何操作，都会立即将抽象状态转换为 $E$，这是一种误用。一旦进入 $E$ 状态，在任何操作下，抽象状态都保持为 $E$，并且对 $E$ 的操作不会产生额外的误用报告。原始操作对单例状态具有逐点效应：\n- $T_{\\mathrm{open}}(U)=O$, $T_{\\mathrm{open}}(O)=E$, $T_{\\mathrm{open}}(X)=E$, $T_{\\mathrm{open}}(E)=E$.\n- $T_{\\mathrm{write}}(O)=O$, $T_{\\mathrm{write}}(U)=E$, $T_{\\mathrm{write}}(X)=E$, $T_{\\mathrm{write}}(E)=E$.\n- $T_{\\mathrm{close}}(O)=X$, $T_{\\mathrm{close}}(U)=E$, $T_{\\mathrm{close}}(X)=E$, $T_{\\mathrm{close}}(E)=E$.\n\n考虑以下伪代码程序，其中 $b_1$ 和 $b_2$ 是非确定性布尔值（两个分支都被认为是可能的），调用是对单个共享资源 $r$ 的引用传递：\n\nproc h(r):\n  write(r)\n\nproc k(r):\n  if b2? then close(r) else write(r)\n\nproc f(r):\n  if b1? then open(r)\n  h(r)\n\nproc g(r):\n  f(r)\n  k(r)\n\nmain:\n  r := new Resource()  // initial state is U\n  g(r)\n  close(r)\n\n我们在单调数据流分析的框架下，执行一个前向、流敏感、上下文不敏感的May分析。抽象域为 $D=\\mathcal{P}(\\{U,O,X,E\\})$，单状态转换函数被逐点提升，因此对于 $S \\subseteq \\{U,O,X,E\\}$，$T_{\\mathrm{op}}(S)=\\bigcup_{s \\in S} \\{T_{\\mathrm{op}}(s)\\}$。在一个过程中，控制流连接点通过对 $D$ 的集合并集来建模。在调用点，使用过程间摘要：每个过程 $p \\in \\{h,k,f,g\\}$ 由一个单调转换器 $\\tau_p:D \\to D$ 进行摘要，该转换器将调用入口处的抽象输入状态映射到返回时的抽象输出状态。如果在某个特定操作点，存在一个可达的非错误抽象状态 $s \\in \\{U,O,X\\}$，而协议不允许在该状态下执行该操作，则该操作点会被标记为误用。在状态 $E$ 执行的操作不会产生新的误用标记。\n\n从 main 入口处的初始抽象状态 $\\{U\\}$ 开始，根据单调数据流框架和过程间摘要的第一性原理，推导出摘要 $\\tau_h$、$\\tau_k$、$\\tau_f$ 和 $\\tau_g$，然后计算 main 的最后 close 点的抽象状态。利用这些结果，确定整个程序中被标记为误用的不同操作点的集合。作为最终答案，报告被标记的不同操作点的数量。你的答案必须是一个不带单位的整数。如果你选择用文字写出数字，也请在括号中包含数字。不需要四舍五入。", "solution": "问题要求我们对给定程序执行前向、流敏感、上下文不敏感的May数据流分析，以识别类型状态协议的误用。我们必须首先验证问题陈述。\n\n### 第1步：提取给定信息\n- **类型状态模型**：状态集合为 $\\{U, O, X, E\\}$，其中 $U$ 是未打开， $O$ 是已打开， $X$ 是已关闭， $E$ 是错误汇集状态。\n- **状态转换函数**：原始操作对单例状态 $s$ 引起以下状态转换：\n  - $T_{\\mathrm{open}}(U)=O$, $T_{\\mathrm{open}}(O)=E$, $T_{\\mathrm{open}}(X)=E$, $T_{\\mathrm{open}}(E)=E$.\n  - $T_{\\mathrm{write}}(O)=O$, $T_{\\mathrm{write}}(U)=E$, $T_{\\mathrm{write}}(X)=E$, $T_{\\mathrm{write}}(E)=E$.\n  - $T_{\\mathrm{close}}(O)=X$, $T_{\\mathrm{close}}(U)=E$, $T_{\\mathrm{close}}(X)=E$, $T_{\\mathrm{close}}(E)=E$.\n- **程序伪代码**：\n  ```\n  proc h(r):\n    write(r)\n  \n  proc k(r):\n    if b2? then close(r) else write(r)\n  \n  proc f(r):\n    if b1? then open(r)\n    h(r)\n  \n  proc g(r):\n    f(r)\n    k(r)\n  \n  main:\n    r := new Resource()  // initial state is U\n    g(r)\n    close(r)\n  ```\n  $b_1$ 和 $b_2$ 是非确定性布尔值。资源 $r$ 通过引用共享。\n- **数据流分析框架**：\n  - **方向**：前向。\n  - **敏感性**：流敏感，上下文不敏感。\n  - **分析类型**：May分析。\n  - **抽象域**：$D=\\mathcal{P}(\\{U,O,X,E\\})$，即状态的幂集。\n  - **连接操作符**：在控制流连接点使用集合并集（$\\cup$）。\n  - **转换函数提升**：对于 $S \\in D$，$T_{\\mathrm{op}}(S)=\\bigcup_{s \\in S} \\{T_{\\mathrm{op}}(s)\\}$。\n  - **过程间策略**：摘要。每个过程 $p$ 由一个单调转换器 $\\tau_p:D \\to D$ 进行摘要。\n- **误用定义**：如果在某个操作点的入口处，其抽象状态 $S$ 包含一个非错误状态 $s \\in \\{U,O,X\\}$，而该操作在该状态下不被允许，则该操作点会被标记为误用。从状态 $E$ 执行的操作不会产生新的误用标记。\n- **初始条件**：资源 $r$ 在 `main` 中以状态 $\\{U\\}$ 开始。\n\n### 第2步：使用提取的给定信息进行验证\n该问题在科学上基于静态程序分析和编译器理论的既定原则。它使用了标准术语（流敏感性、上下文不敏感性、May分析、单调数据流框架）。整个设置是完整且内部一致的。目标定义明确。语言客观而精确。问题是适定的；通过系统地应用定义的分析规则可以得出唯一解。没有违反验证标准。\n\n### 第3步：结论与行动\n问题有效。我们开始求解。\n\n### 详细解法\n\n分析首先根据调用图以自底向上的方式推导每个过程的摘要转换器，然后对 `main` 过程进行自顶向下的分析以发现误用。\n\n**形式化准备**\n抽象域是格 $(D, \\subseteq)$，其中 $D = \\mathcal{P}(\\{U, O, X, E\\})$。连接操作符是 $\\cup$。操作的转换函数按定义提升到集合上。\n对于前置状态为 $S$ 的操作 `op`，其误用条件为：\n- `open(r)`：如果 $S \\cap \\{O, X\\} \\neq \\emptyset$，则为误用。\n- `write(r)`：如果 $S \\cap \\{U, X\\} \\neq \\emptyset$，则为误用。\n- `close(r)`：如果 $S \\cap \\{U, X\\} \\neq \\emptyset$，则为误用。\n\n**过程摘要的推导**\n设 $S_{in} \\in D$ 为过程入口处的抽象状态。\n\n1.  **`proc h(r)` 的摘要：**\n    该过程包含单个操作 `write(r)`。输出状态是应用 `write` 转换函数到输入状态的结果。\n    $$ \\tau_h(S_{in}) = T_{\\mathrm{write}}(S_{in}) $$\n\n2.  **`proc k(r)` 的摘要：**\n    该过程有一个非确定性分支。对于May分析，我们考虑两条路径并连接其结果。\n    - `then` 分支：`close(r)`。状态变为 $T_{\\mathrm{close}}(S_{in})$。\n    - `else` 分支：`write(r)`。状态变为 $T_{\\mathrm{write}}(S_{in})$。\n    摘要是两个分支结果的并集。\n    $$ \\tau_k(S_{in}) = T_{\\mathrm{close}}(S_{in}) \\cup T_{\\mathrm{write}}(S_{in}) $$\n\n3.  **`proc f(r)` 的摘要：**\n    该过程也包含一个非确定性分支，后跟一个对 `h` 的调用。\n    - `then` 分支：`open(r)`。状态变为 $T_{\\mathrm{open}}(S_{in})$。\n    - `else` 分支：状态保持为 $S_{in}$。\n    调用 `h(r)` 之前的状态是 `if-else` 结构产生状态的连接：$S_{before\\_h} = S_{in} \\cup T_{\\mathrm{open}}(S_{in})$。\n    `f` 的输出是将摘要 $\\tau_h$ 应用于此状态的结果。\n    $$ \\tau_f(S_{in}) = \\tau_h(S_{in} \\cup T_{\\mathrm{open}}(S_{in})) = T_{\\mathrm{write}}(S_{in} \\cup T_{\\mathrm{open}}(S_{in})) $$\n\n4.  **`proc g(r)` 的摘要：**\n    该过程由一系列对 `f` 和 `k` 的调用组成。\n    - 首先，调用 `f(r)`。此调用后的状态是 $S_{after\\_f} = \\tau_f(S_{in})$。\n    - 然后，以 $S_{after\\_f}$ 为输入调用 `k(r)`。最终状态是 $\\tau_k(S_{after\\_f})$。\n    `g` 的摘要是 `f` 和 `k` 摘要的复合。\n    $$ \\tau_g(S_{in}) = \\tau_k(\\tau_f(S_{in})) = \\tau_k(T_{\\mathrm{write}}(S_{in} \\cup T_{\\mathrm{open}}(S_{in}))) $$\n\n**`main` 的前向分析**\n我们现在从 `main` 的入口开始跟踪执行。\n\n1.  `r := new Resource()`：$r$ 的抽象状态变为 $S_0 = \\{U\\}$。\n\n2.  调用 `g(r)`：以输入状态 $S_{g,in} = S_0 = \\{U\\}$ 执行对 `g` 的分析。\n    - 以输入 $S_{f,in} = \\{U\\}$ 调用 `f(r)`。\n        - 在 `f` 内部：存在一个非确定性选择。\n            - `then` 分支（`open(r)` 在点 `f1`）：\n                - 前置状态：$\\{U\\}$。误用检查：$\\{U\\} \\cap \\{O, X\\} = \\emptyset$。**没有误用**。\n                - 后置状态：$T_{\\mathrm{open}}(\\{U\\}) = \\{O\\}$。\n            - `else` 分支：状态保持为 $\\{U\\}$。\n        - 调用 `h(r)` 之前的状态是连接结果：$S_{h,in} = \\{O\\} \\cup \\{U\\} = \\{U, O\\}$。\n        - 以输入 $S_{h,in} = \\{U, O\\}$ 调用 `h(r)`。\n            - 在 `h` 内部，在 `write(r)` 处（点 `h1`）：\n                - 前置状态：$\\{U, O\\}$。误用检查：$\\{U, O\\} \\cap \\{U, X\\} = \\{U\\} \\neq \\emptyset$。**在 `h1` 处标记了误用**。\n                - 后置状态：$T_{\\mathrm{write}}(\\{U, O\\}) = T_{\\mathrm{write}}(\\{U\\}) \\cup T_{\\mathrm{write}}(\\{O\\}) = \\{E\\} \\cup \\{O\\} = \\{O, E\\}$。\n        - 从 `h` 返回到 `f` 的状态是 $\\{O, E\\}$。这也是 `f` 的退出状态，所以 $\\tau_f(\\{U\\}) = \\{O, E\\}$。\n    - 在 `g` 中，`f(r)` 返回后的状态是 $S_{g,mid} = \\{O, E\\}$。\n    - 以输入 $S_{k,in} = \\{O, E\\}$ 调用 `k(r)`。\n        - 在 `k` 内部：存在一个非确定性选择。\n            - `then` 分支（`close(r)` 在点 `k1`）：\n                - 前置状态：$\\{O, E\\}$。误用检查：$\\{O, E\\} \\cap \\{U, X\\} = \\emptyset$。**没有误用**。\n                - 后置状态：$T_{\\mathrm{close}}(\\{O, E\\}) = T_{\\mathrm{close}}(\\{O\\}) \\cup T_{\\mathrm{close}}(\\{E\\}) = \\{X\\} \\cup \\{E\\} = \\{X, E\\}$。\n            - `else` 分支（`write(r)` 在点 `k2`）：\n                - 前置状态：$\\{O, E\\}$。误用检查：$\\{O, E\\} \\cap \\{U, X\\} = \\emptyset$。**没有误用**。\n                - 后置状态：$T_{\\mathrm{write}}(\\{O, E\\}) = T_{\\mathrm{write}}(\\{O\\}) \\cup T_{\\mathrm{write}}(\\{E\\}) = \\{O\\} \\cup \\{E\\} = \\{O, E\\}$。\n        - 在 `k` 出口处的状态是连接结果：$\\{X, E\\} \\cup \\{O, E\\} = \\{O, X, E\\}$。因此，$\\tau_k(\\{O, E\\}) = \\{O, X, E\\}$。\n    - 从 `k` 返回到 `g`（并因此退出 `g`）的状态是 $\\{O, X, E\\}$。所以，$\\tau_g(\\{U\\}) = \\{O, X, E\\}$。\n\n3.  在 `main` 中，`g(r)` 返回后的抽象状态是 $S_1 = \\{O, X, E\\}$。这是一个要求得到的中间结果：`main` 的最后 `close` 点的抽象状态。\n\n4.  执行 `close(r)`（在 `main` 中的点 `m2`）：\n    - 前置状态：$\\{O, X, E\\}$。\n    - 误用检查：$\\{O, X, E\\} \\cap \\{U, X\\} = \\{X\\} \\neq \\emptyset$。**在 `m2` 处标记了误用**。\n    - 后置状态：$T_{\\mathrm{close}}(\\{O, X, E\\}) = T_{\\mathrm{close}}(\\{O\\}) \\cup T_{\\mathrm{close}}(\\{X\\}) \\cup T_{\\mathrm{close}}(\\{E\\}) = \\{X\\} \\cup \\{E\\} \\cup \\{E\\} = \\{X, E\\}$。\n\n**结论**\n分析揭示了两个不同操作点的误用：\n1.  过程 `h` 中的 `write(r)` 操作（点 `h1`）。\n2.  `main` 中的最后 `close(r)` 操作（点 `m2`）。\n\n被标记的不同操作点总数为 $2$。", "answer": "$$\\boxed{2}$$", "id": "3647964"}]}