{"hands_on_practices": [{"introduction": "我们的第一个练习是模拟编译器的基本工作流程。我们将手动追踪一个常量值如何在一系列嵌套的函数调用中被传递和计算，从而实现跨过程的常量折叠。这个练习将让你直观地感受到，当函数参数是编译期常量时，编译器如何一步步地“预计算”出结果，将抽象的分析过程变得具体而清晰。[@problem_id:3648241]", "problem": "考虑无符号$32$位整数以及常用的位运算符：按位与 $\\mathbin{\\}$、按位或 $\\mathbin{|}$、异或 $\\oplus$、逻辑右移 $\\gg$ 和左移 $\\ll$。假设一个纯粹的、无副作用的程序由以下函数组成，这些函数被建模为作用于无符号$32$位整数的数学函数：\n- $g(x) \\triangleq x \\mathbin{\\} 0x\\mathrm{FF}$。\n- $h(z) \\triangleq g(z) \\mathbin{|} \\big((z \\gg 8) \\mathbin{\\} 0x\\mathrm{0F}\\big)$。\n- $f(p) \\triangleq \\big(\\big(g(p) + g(0x\\mathrm{1234})\\big) \\oplus h\\big(p \\mathbin{|} 0x\\mathrm{00F0}\\big)\\big) \\mathbin{\\} 0x\\mathrm{7F}$。\n\n该程序的入口点计算 $f(0x\\mathrm{5600})$。请仅使用关于数据流分析和上述运算符语义的基本原理，解释过程间常量传播如何发现并在对 $g$ 和 $h$ 的调用中折叠常量，包括将 $g(0x\\mathrm{1234})$ 跨过程折叠为 $0x\\mathrm{34}$。然后，通过完全应用这些常量折叠，确定 $f(0x\\mathrm{5600})$ 返回的确切值。\n\n请将最终答案表示为一个精确的十进制整数。无需四舍五入。", "solution": "该问题要求解释过程间常量传播 (ICP) 如何确定 $f(0x\\mathrm{5600})$ 的值，并计算出这个值。这个过程涉及跨函数边界跟踪常量值，以及折叠其操作数均为常量的表达式。\n\n首先，我们将按照要求，从基本原理出发，对过程间常量传播进行简要概述。ICP 是一种编译器优化技术，它将常量传播扩展到单个函数的边界之外。它作为一种数据流分析来运作，其目标是确定在程序中的每个点，一个变量是否持有一个特定的常量值。该分析通常为每个变量使用一个可能值的格（lattice），通常由三个级别组成：\n1.  $\\top$ (Top)：值已知不是单个常量（它可能在运行时变化）。\n2.  一组常量值 $c_1, c_2, \\ldots$。\n3.  $\\bot$ (Bottom)：值未知或未初始化。\n\n分析是迭代进行的。当一个函数，比如 $q(\\text{params})$，以常量参数调用时，例如 $q(c_1, c_2)$，分析可以创建一个 $q$ 的特化版本，其中其形式参数被这些常量值替换。这允许在 $q$ 的函数体内进行常量折叠。如果分析确定这个 $q$ 的特化版本总是返回一个常量值 $R$，那么调用点 $q(c_1, c_2)$ 就可以直接被 $R$ 替换。这种替换是过程间常量折叠的本质。\n\n现在，我们应用这个过程来计算 $f(0x\\mathrm{5600})$。入口点是表达式 $f(p)$，其中参数 $p$ 的常量值为 $0x\\mathrm{5600}$。$f(p)$ 的定义是：\n$$f(p) \\triangleq \\big(\\big(g(p) + g(0x\\mathrm{1234})\\big) \\oplus h\\big(p \\mathbin{|} 0x\\mathrm{00F0}\\big)\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n将 $p = 0x\\mathrm{5600}$ 代入，得到：\n$$f(0x\\mathrm{5600}) = \\big(\\big(g(0x\\mathrm{5600}) + g(0x\\mathrm{1234})\\big) \\oplus h\\big(0x\\mathrm{5600} \\mathbin{|} 0x\\mathrm{00F0}\\big)\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n\n分析通过对可化简为常量的子表达式进行求值来推进。\n\n1.  **分析调用 $g(0x\\mathrm{1234})$**。参数 $0x\\mathrm{1234}$ 是一个常量。编译器分析 $g(x) \\triangleq x \\mathbin{\\} 0x\\mathrm{FF}$ 的函数体，其中 $x = 0x\\mathrm{1234}$。\n    $$g(0x\\mathrm{1234}) = 0x\\mathrm{1234} \\mathbin{\\} 0x\\mathrm{FF}$$\n    在二进制中，这是 $0001\\,0010\\,0011\\,0100_2 \\mathbin{\\} 1111\\,1111_2$，结果是 $0011\\,0100_2$。\n    $$g(0x\\mathrm{1234}) = 0x\\mathrm{34}$$\n    ICP 确定 $g(0x\\mathrm{1234})$ 返回常量 $0x\\mathrm{34}$。这个调用随后被折叠，将 $g(0x\\mathrm{1234})$ 替换为 $0x\\mathrm{34}$。\n\n2.  **分析传递给 $h$ 的参数**。参数是 $p \\mathbin{|} 0x\\mathrm{00F0}$。因为 $p$ 是常量 $0x\\mathrm{5600}$，这个表达式可以被折叠。\n    $$0x\\mathrm{5600} \\mathbin{|} 0x\\mathrm{00F0} = 0101\\,0110\\,0000\\,0000_2 \\mathbin{|} 0000\\,0000\\,1111\\,0000_2 = 0101\\,0110\\,1111\\,0000_2 = 0x\\mathrm{56F0}$$\n    对 $h$ 的调用变为 $h(0x\\mathrm{56F0})$。\n\n3.  现在 $f$ 的主表达式被简化为：\n    $$f(0x\\mathrm{5600}) = \\big(\\big(g(0x\\mathrm{5600}) + 0x\\mathrm{34}\\big) \\oplus h(0x\\mathrm{56F0})\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n\n4.  **分析调用 $g(0x\\mathrm{5600})$**。参数是常量 $0x\\mathrm{5600}$。\n    $$g(0x\\mathrm{5600}) = 0x\\mathrm{5600} \\mathbin{\\} 0x\\mathrm{FF} = 0x\\mathrm{00}$$\n    这个调用被折叠为常量 $0x\\mathrm{00}$。\n\n5.  **分析调用 $h(0x\\mathrm{56F0})$**。参数是常量 $0x\\mathrm{56F0}$。其定义是 $h(z) \\triangleq g(z) \\mathbin{|} \\big((z \\gg 8) \\mathbin{\\} 0x\\mathrm{0F}\\big)$。当 $z=0x\\mathrm{56F0}$ 时，表达式变为：\n    $$h(0x\\mathrm{56F0}) = g(0x\\mathrm{56F0}) \\mathbin{|} \\big((0x\\mathrm{56F0} \\gg 8) \\mathbin{\\} 0x\\mathrm{0F}\\big)$$\n    这需要对 $g(0x\\mathrm{56F0})$ 进行内部分析：\n    $$g(0x\\mathrm{56F0}) = 0x\\mathrm{56F0} \\mathbin{\\} 0x\\mathrm{FF} = 0x\\mathrm{F0}$$\n    表达式的另一部分被折叠：\n    $$0x\\mathrm{56F0} \\gg 8 = 0x\\mathrm{56}$$\n    $$(0x\\mathrm{56F0} \\gg 8) \\mathbin{\\} 0x\\mathrm{0F} = 0x\\mathrm{56} \\mathbin{\\} 0x\\mathrm{0F} = 0101\\,0110_2 \\mathbin{\\} 0000\\,1111_2 = 0000\\,0110_2 = 0x\\mathrm{06}$$\n    将这些值代回到 $h$ 的表达式中：\n    $$h(0x\\mathrm{56F0}) = 0x\\mathrm{F0} \\mathbin{|} 0x\\mathrm{06} = 1111\\,0000_2 \\mathbin{|} 0000\\,0110_2 = 1111\\,0110_2 = 0x\\mathrm{F6}$$\n    调用 $h(0x\\mathrm{56F0})$ 被折叠为常量 $0x\\mathrm{F6}$。\n\n6.  **最终计算**。所有函数调用都已被折叠为常量。我们将这些值代回到 $f(0x\\mathrm{5600})$ 的表达式中：\n    $$f(0x\\mathrm{5600}) = \\big((0x\\mathrm{00} + 0x\\mathrm{34}) \\oplus 0x\\mathrm{F6}\\big) \\mathbin{\\} 0x\\mathrm{7F}$$\n    现在，我们执行最后的算术和位运算。\n    - 加法: $0x\\mathrm{00} + 0x\\mathrm{34} = 0x\\mathrm{34}$。\n    - 异或: $0x\\mathrm{34} \\oplus 0x\\mathrm{F6}$。在二进制中：\n      $0x\\mathrm{34} = 0011\\,0100_2$\n      $0x\\mathrm{F6} = 1111\\,0110_2$\n      $0x\\mathrm{34} \\oplus 0x\\mathrm{F6} = 1100\\,0010_2 = 0x\\mathrm{C2}$。\n    - 按位与: $0x\\mathrm{C2} \\mathbin{\\} 0x\\mathrm{7F}$。在二进制中：\n      $0x\\mathrm{C2} = 1100\\,0010_2$\n      $0x\\mathrm{7F} = 0111\\,1111_2$\n      $0x\\mathrm{C2} \\mathbin{\\} 0x\\mathrm{7F} = 0100\\,0010_2 = 0x\\mathrm{42}$。\n\n最终值为 $0x\\mathrm{42}$。题目要求答案为十进制。我们将十六进制结果转换为十进制：\n$$0x\\mathrm{42} = 4 \\times 16^1 + 2 \\times 16^0 = 64 + 2 = 66$$\n因此，$f(0x\\mathrm{5600})$ 返回的值是 $66$。", "answer": "$$\\boxed{66}$$", "id": "3648241"}, {"introduction": "在实际程序中，同一个函数常常在不同的地方被以不同的参数调用。这个练习将带我们探索“上下文敏感”分析的威力。我们将看到，通过为每个不同的调用点（或上下文）分别进行分析，编译器可以获得更精确的信息，从而实现更深度的优化。你会发现，区分调用上下文是提升优化效果的关键一步。[@problem_id:3648314]", "problem": "一门语言使用传值调用（call-by-value），支持纯函数（pure functions）和默认参数值。考虑以下用一阶、无副作用的伪代码编写的程序。如果一个调用省略了带有默认值的形参的实参，那么被调用者的形参将取其默认值。所有算术运算都是在整数上进行的。\n\n- 函数定义：\n  - $\\;k(v)$:\n    - if $\\;v \\bmod 2 = 1\\;$ then return $\\;v\\;$ else return $\\;2 \\times v$.\n  - $\\;h(u)$:\n    - return $\\;u^{2} - 2u + 1$.\n  - $\\;g(x = 5)$:\n    - let $\\;y := x + 3$.\n    - if $\\;y  10\\;$ then let $\\;z := y \\times 2\\;$ else let $\\;z := y - 4$.\n    - return $\\;h(z) + k(x)$.\n\n- 主程序：\n  - let $\\;a := g()$.\n  - let $\\;b := g(7)$.\n  - let $\\;c := a + 2 \\times b$.\n  - output $\\;c$.\n\n使用在过程间控制流图（ICFG）上具有每个调用点上下文敏感性的过程间常量传播，以及标准常量传播格（其元素为 $\\;\\{\\bot\\;\\} \\cup \\mathbb{Z} \\cup \\{\\top\\;\\}$，对于任意整数 $\\;n\\;$ 排序为 $\\;\\bot \\sqsubset n \\sqsubset \\top\\;$），将常量从实参（包括调用 $\\;g()\\;$ 中的默认绑定）传播到 $\\;g\\;$ 的函数体中，然后再传播到 $\\;h\\;$ 和 $\\;k\\;$ 中，并在格值为已知整数时执行常量折叠。假设没有别名（aliasing），没有异常，并且控制流图（CFG）仅包含所示的分支。\n\n在完全应用所述的过程间常量传播和常量折叠后，运行时计算出的 $\\;c\\;$ 的精确值是多少？请给出您的答案，为一个精确的整数，无需四舍五入。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于编译器理论的原理，特别是静态分析和优化。该问题是适定（well-posed）的，所有必要的函数、调用点和分析规则（具有每个调用点上下文敏感性的过程间常量传播）都已明确定义，从而可以推导出一个唯一的、确定性的解决方案。\n\n目标是确定在应用过程间常量传播和常量折叠后变量 $c$ 的值。分析将通过在提供的伪代码上模拟这种优化技术来进行。该技术要求在每个函数调用的特定上下文中进行分析，该上下文由其在特定调用点的实参的常量值定义。\n\n主程序包含三个顺序赋值：\n1. `let a := g()`\n2. `let b := g(7)`\n3. `let c := a + 2 * b`\n\n我们将按顺序分析每个赋值。\n\n**1. 对 `let a := g()` 的分析**\n\n该语句涉及对函数 $g$ 的调用，但没有显式参数。根据问题描述，将使用默认参数值。因此，对于此调用点，函数 $g$ 的形参 $x$ 被绑定到常量值 $5$。我们现在在 $x=5$ 的情况下分析 $g$ 的函数体。\n\n- **`let y := x + 3`**：当 $x=5$ 时，此表达式被常量折叠为 $y := 5 + 3$，得到 $y=8$。\n- **`if y  10`**：条件变为 $8  10$，其计算结果为真。分析沿着 `then` 分支进行。\n- **`let z := y \\times 2`**：当 $y=8$ 时，此表达式被常量折叠为 $z := 8 \\times 2$，得到 $z=16$。\n- **`return h(z) + k(x)`**：返回表达式涉及两个函数调用。我们用传播的常量值作为它们的参数来分析每一个调用。\n  - **调用 `h(z)`**：由于 $z=16$，这变成对 $h(16)$ 的调用。\n    - 在 $h(u)$ 的函数体中，形参 $u$ 被绑定到 $16$。\n    - 返回表达式是 $u^2 - 2u + 1$。这可以简化为 $(u-1)^2$。\n    - 代入 $u=16$，我们得到 $(16-1)^2 = 15^2 = 225$。\n    - 调用 $h(16)$ 返回常量值 $225$。\n  - **调用 `k(x)`**：由于 $x=5$，这变成对 $k(5)$ 的调用。\n    - 在 $k(v)$ 的函数体中，形参 $v$ 被绑定到 $5$。\n    - 条件是 $v \\bmod 2 = 1$。代入 $v=5$，我们得到 $5 \\bmod 2 = 1$，这是真的。\n    - 执行 `then` 分支，即 `return v`。\n    - 调用 $k(5)$ 返回常量值 $5$。\n- **`g()` 的最终返回值**：表达式 `h(z) + k(x)` 用返回的常量进行计算：$225 + 5 = 230$。\n\n因此，在过程间常量传播和折叠之后，赋值语句 `let a := g()` 被有效地转换为 `let a := 230`。\n\n**2. 对 `let b := g(7)` 的分析**\n\n该语句涉及对函数 $g$ 的调用，并带有显式参数 $7$。对于此调用点，形参 $x$ 被绑定到常量值 $7$。我们现在在 $x=7$ 的情况下分析 $g$ 的函数体。\n\n- **`let y := x + 3`**：当 $x=7$ 时，此表达式被常量折叠为 $y := 7 + 3$，得到 $y=10$。\n- **`if y  10`**：条件变为 $10  10$，其计算结果为假。分析沿着 `else` 分支进行。\n- **`let z := y - 4`**：当 $y=10$ 时，此表达式被常量折叠为 $z := 10 - 4$，得到 $z=6$。\n- **`return h(z) + k(x)`**：我们用新的传播常量来分析这些函数调用。\n  - **调用 `h(z)`**：由于 $z=6$，这变成对 $h(6)$ 的调用。\n    - 在 $h(u)$ 的函数体中，$u$ 被绑定到 $6$。\n    - 返回表达式 $(u-1)^2$ 变为 $(6-1)^2 = 5^2 = 25$。\n    - 调用 $h(6)$ 返回常量值 $25$。\n  - **调用 `k(x)`**：由于 $x=7$，这变成对 $k(7)$ 的调用。\n    - 在 $k(v)$ 的函数体中，$v$ 被绑定到 $7$。\n    - 条件 $v \\bmod 2 = 1$ 变为 $7 \\bmod 2 = 1$，这是真的。\n    - 执行 `then` 分支，返回 $v$。\n    - 调用 $k(7)$ 返回常量值 $7$。\n- **`g(7)` 的最终返回值**：表达式 `h(z) + k(x)` 用返回的常量进行计算：$25 + 7 = 32$。\n\n因此，赋值语句 `let b := g(7)` 被有效地转换为 `let b := 32`。\n\n**3. 对 `let c := a + 2 * b` 的分析**\n\n在程序的这一点上，优化器已经确定 $a=230$ 和 $b=32$。最后的赋值可以进行常量折叠。\n\n- **`let c := a + 2 * b`**：代入 $a$ 和 $b$ 的常量值，我们得到 `c := 230 + 2 * 32`。\n- 根据运算顺序，首先执行乘法：$2 \\times 32 = 64$。\n- 表达式变为 `c := 230 + 64`。\n- 最后的加法得到 $c := 294$。\n\n经过这些优化后，在运行时为 $c$ 计算出的值是 $294$。", "answer": "$$\\boxed{294}$$", "id": "3648314"}, {"introduction": "如果编译器没有某个函数的源代码（例如，一个来自预编译库的函数），优化还能进行吗？这个练习将介绍“函数摘要”这一强大概念。我们将看到，即便一个函数的内部实现是未知的，一个关于其行为的精确摘要也能帮助优化器做出关键推断，例如识别并删除不可达的代码分支。这展示了过程间分析在模块化和大型项目中应用的核心思想。[@problem_id:3648217]", "problem": "考虑一个对整型变量的过程间常量传播分析，该分析使用经典的常量传播格。单个变量的格定义为 $D = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$，其中 $\\bot$ 表示无信息，每个 $c \\in \\mathbb{Z}$ 表示常量 $c$，而 $\\top$ 表示冲突或未知信息。其偏序关系为，对于任意 $c \\in \\mathbb{Z}$，$\\bot \\leq c \\leq \\top$；同时，$\\bot \\leq \\top$ 且对于所有 $c \\in \\mathbb{Z}$ 均有 $c \\leq \\top$。并算子（join operator）在环境上逐点定义，对于单个变量 $v$ 而言：$c \\sqcup c = c$，$c \\sqcup c' = \\top$（当 $c \\neq c'$ 时），$c \\sqcup \\bot = c$，$c \\sqcup \\top = \\top$，其他情况对称定义。赋值和算术运算的转换函数是常量传播的标准函数（例如，对于赋值语句 $v := n$ 且 $n \\in \\mathbb{Z}$，转换函数将 $v$ 设置为 $n$；对于二元操作 $v := a \\,\\text{op}\\, b$，如果 $a$ 和 $b$ 都是常量，则转换函数将 $v$ 设置为求值后的常量，否则设置为 $\\top$）。\n\n给定以下两个针对整数的操作过程：\n- 过程 $g$ 接受一个整数输入 $y$ 并返回一个整数。分析无法得知 $g$ 的函数体，但它有一个摘要 $S_{g}$，该摘要足够可靠和精确，可以保证以下属性：$S_{g}$ 断言 $g(2) \\neq 0$。\n- 过程 $f$ 定义如下（使用伪代码，所有整型字面量均为数学常数）：\n  1. 令 $r := 9$。\n  2. 如果 $g(x) = 0$ 则设置 $r := x + 7$。\n  3. 返回 $r$。\n\n假设过程间常量传播分析在参数值级别上是上下文敏感的，并且在分析对 $g$ 的调用时使用 $S_{g}$。分析从一个初始环境开始运行，在该环境中，对 $f$ 的调用点处，我们有常量 $x = 2$，即输入环境将 $x$ 映射到 $2$。\n\n使用上述格和转换语义作为基本依据，当 $x = 2$ 且摘要 $S_{g}$ 成立时，确定分析为过程 $f$ 出口处的 $r$ 值推断出的常量。请以单个整数的形式提供最终结果。无需四舍五入。答案应表示为不带任何单位的纯数字。", "solution": "首先验证问题，以确保其具有科学依据、良构且客观。\n\n### 步骤 1：提取已知条件\n-   **格：** 常量传播格为 $D = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$。\n-   **偏序：** 对于任意常量 $c \\in \\mathbb{Z}$，有 $\\bot \\leq c \\leq \\top$。\n-   **并算子（$\\sqcup$）：** 逐点定义。对于单个变量：$c \\sqcup c = c$；$c \\sqcup c' = \\top$（当 $c \\neq c'$）；$c \\sqcup \\bot = c$；$c \\sqcup \\top = \\top$。\n-   **转换函数：** 常量传播的标准函数。对于赋值语句 $v := n$ 且 $n \\in \\mathbb{Z}$， $v$ 的值变为 $n$。对于 $v := a \\,\\text{op}\\, b$，如果 $a$ 和 $b$ 是已知常量，则 $v$ 的值是该运算的结果，否则为 $\\top$。\n-   **过程 $g(y)$：** 函数体未知。\n-   **过程 $g$ 的摘要 $S_g$：** 该摘要断言 $g(2) \\neq 0$。\n-   **过程 $f(x)$：**\n    1.  `Let r := 9.`\n    2.  `If g(x) = 0 then set r := x + 7.`\n    3.  `Return r.`\n-   **分析上下文：** 分析是过程间的且上下文敏感的（具体来说，对参数的常量值敏感）。它使用摘要 $S_g$。\n-   **初始条件：** 对过程 $f$ 的分析始于一个初始环境，其中变量 $x$ 的常量值为 $2$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在编译器设计和程序分析领域内是良构的，特别关注于抽象解释和数据流分析。\n-   **科学依据：** 该问题使用了标准的常量传播格及其相关语义，这些是编译原理中的基本概念。使用函数摘要进行过程间分析的思想也是一种标准且经过充分研究的技术。其前提在计算机科学领域是可靠的。\n-   **良构性：** 该问题提供了所有必要信息：分析的初始状态、待分析的代码、抽象域（格）以及操作的语义（转换函数）。对于不透明过程 $g$ 的摘要提供了解决条件分支所需的精确信息。可以确定唯一的结果。\n-   **客观性：** 该问题以程序分析领域通用的精确、形式化语言陈述。它没有歧义和主观论断。\n\n### 步骤 3：结论与行动\n该问题是有效的。可以构建一个有理有据的解法。\n\n### 解题过程\n\n任务是确定在分析从输入 $x$ 为常量 $2$ 的信息开始时，为过程 $f$ 出口处的变量 $r$ 推断出的常量值。\n\n设环境（或抽象状态）是一个从变量到格 $D$ 中值的映射。分析过程如下：\n\n1.  **进入过程 $f$：** 分析是上下文敏感的，并且正在对一个参数 $x$ 已知为 $2$ 的 $f$ 调用进行分析。在 $f$ 开始时的初始环境是 $\\sigma_{0} = \\{x \\to 2\\}$。所有其他局部变量（如 $r$）都隐含地处于 $\\bot$。\n\n2.  **分析第 1 行：`Let r := 9.`**\n    这是一个常量赋值。该语句的转换函数更新了环境。$r$ 的值被设置为常量 $9$。环境变为：\n    $$ \\sigma_{1} = \\sigma_{0}[r \\to 9] = \\{x \\to 2, r \\to 9\\} $$\n\n3.  **分析第 2 行：`If g(x) = 0 then set r := x + 7.`**\n    分析必须评估分支条件 `g(x) = 0`。\n    -   从环境 $\\sigma_1$ 中，分析知道 $x$ 是常量 $2$。因此，函数调用实际上是 $g(2)$。\n    -   问题指出，分析使用过程 $g$ 的摘要 $S_{g}$。摘要 $S_{g}$ 断言 $g(2) \\neq 0$。\n    -   这意味着在 $x=2$ 的特定上下文中，条件 `g(x) = 0` 保证求值为 **false**。\n    -   一个可靠的静态分析可以利用此信息确定条件语句的 `then` 分支是一条不可行路径。当 $x=2$ 时，该路径永远不会被执行。\n\n4.  **控制流和状态合并：**\n    分析推断出控制流将始终绕过 `then` 代码块，并沿着隐式的 `else` 路径继续。\n    -   **来自 `then` 分支的状态：** 由于此路径不可达，它对条件语句之后的状态没有贡献。在数据流框架中，其输出状态可以被认为是所有变量的底元素，即 $\\sigma_{then} = \\{x \\to \\bot, r \\to \\bot\\}$，表示没有执行流到达这一点。\n    -   **来自 `else` 分支的状态：** `else` 分支被执行。进入此路径的环境是 $\\sigma_1 = \\{x \\to 2, r \\to 9\\}$。隐式的 `else` 代码块不包含任何语句，因此离开此路径的环境保持不变：$\\sigma_{else} = \\sigma_1 = \\{x \\to 2, r \\to 9\\}$。\n    -   在 `if-then` 语句之后的程序点的环境是所有传入控制流路径（`then` 和 `else` 分支）的环境的并集。\n    $$ \\sigma_{2} = \\sigma_{then} \\sqcup \\sigma_{else} $$\n    我们对每个变量逐点执行并操作：\n    -   对于 $x$：$\\sigma_2(x) = \\sigma_{then}(x) \\sqcup \\sigma_{else}(x) = \\bot \\sqcup 2 = 2$。\n    -   对于 $r$：$\\sigma_2(r) = \\sigma_{then}(r) \\sqcup \\sigma_{else}(r) = \\bot \\sqcup 9 = 9$。\n    因此，条件语句之后的环境是 $\\sigma_{2} = \\{x \\to 2, r \\to 9\\}$。$r$ 的值仍然是 $9$。\n\n5.  **分析第 3 行：`Return r.`**\n    该过程返回变量 $r$ 的值。此时，分析已确定在当前环境 $\\sigma_2$ 中，$r$ 的值是常量 $9$。\n\n因此，过程间常量传播分析推断出，对于输入 $x=2$，过程 $f$ 出口处 $r$ 的值是常量 $9$。", "answer": "$$\\boxed{9}$$", "id": "3648217"}]}