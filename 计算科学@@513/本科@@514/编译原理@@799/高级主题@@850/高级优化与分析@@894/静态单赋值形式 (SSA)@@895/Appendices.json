{"hands_on_practices": [{"introduction": "静态单赋值（SSA）形式的核心在于如何处理来自不同控制流路径的变量值。本练习 [@problem_id:3671616] 以一个常见的 `switch-case` 结构为背景，帮助你理解为何以及在何处需要放置 $\\phi$ 函数来正确合并变量的多个版本。通过解决这个问题，你将掌握处理条件赋值后控制流汇合点的基本原则。", "problem": "考虑以下控制流片段，并假设必须构建静态单赋值（SSA）形式。假设控制流图有一个块 $B_{\\text{entry}}$，在 switch 语句之前 $x$ 的当前版本是 $x_0$。然后控制流转到 $B_{\\text{sw}}$，它根据 case 分支到四个后继块：$B_1$ 对应 case 1，$B_2$ 对应 case 2，$B_3$ 对应 case 3，以及 $B_{\\text{def}}$ 对应 default。每个 case 都以一个 $break$ 语句结束，跳转到唯一的汇合块 $B_{\\text{merge}}$，之后有一个对 $x$ 的使用。代码骨架如下：\n- 在 $B_1$ 中：$x := 10$。\n- 在 $B_2$ 中：没有对 $x$ 的赋值。\n- 在 $B_3$ 中：$x := x + 1$。\n- 在 $B_{\\text{def}}$ 中：没有对 $x$ 的赋值。\n- 在 $B_{\\text{merge}}$ 中：使用 $x$（例如，$y := x$）。\n\n假设 $a$ 是 switch 的选择器，并且根据 $a$ 的值，控制流恰好到达 $B_1$、$B_2$、$B_3$ 或 $B_{\\text{def}}$ 中的一个。没有贯穿（fall-through）；每个 case 都有一个明确的 $break$ 跳转到 $B_{\\text{merge}}$。任务是决定 $x$ 的 $\\phi$ 节点相对于 $B_{\\text{merge}}$ 应该放在哪里，以及如何处理那些在 case 块中没有对 $x$ 赋值的前驱（包括 default 分支）。\n\n哪个选项最能满足 SSA 属性并保持程序语义？\n\nA. 在 $B_{\\text{merge}}$ 中为 $x$ 插入一个单一的 $\\phi$ 节点，每个前驱边对应一个参数。使用来自每个前驱的到达版本：如果一个前驱对 $x$ 进行了赋值，则传递该新版本；如果一个前驱没有对 $x$ 赋值（包括 default 分支），则传递来自 $B_{\\text{entry}}$ 的传入版本 $x_0$。\n\nB. 在每个 case 块内部插入 $\\phi$ 节点以将 $x$ 与 $x_0$ 局部合并，并且不在 $B_{\\text{merge}}$ 放置任何 $\\phi$ 节点；$B_{\\text{merge}}$ 中的使用可以直接引用 $x_0$。\n\nC. 仅当每个 case（包括 default 分支）都对 $x$ 赋值时，才在 $B_{\\text{merge}}$ 处为 $x$ 插入 $\\phi$ 节点。如果有任何 case 没有对 $x$ 赋值，则省略 $\\phi$ 节点，并让 switch 之后的使用引用 $x_0$。\n\nD. 在 $B_{\\text{merge}}$ 中为 $x$ 插入一个 $\\phi$ 节点，但对于任何没有赋值的前驱（包括 default 分支），首先在该前驱中插入一个哑复制 $x := x$ 以创建一个新版本，从而使所有 $\\phi$ 参数都是每个边唯一的不同版本。", "solution": "用户希望我验证并解决一个关于为给定代码片段构建静态单赋值（SSA）形式的问题。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n1.  **控制流图（CFG）结构**：\n    *   一个入口块 $B_{\\text{entry}}$。\n    *   一个 switch 块 $B_{\\text{sw}}$，是 $B_{\\text{entry}}$ 的后继。\n    *   $B_{\\text{sw}}$ 有四个互斥的后继块：$B_1$、$B_2$、$B_3$ 和 $B_{\\text{def}}$。\n    *   一个唯一的汇合块 $B_{\\text{merge}}$，由于 `break` 语句，它是所有四个块（$B_1$、$B_2$、$B_3$、$B_{\\text{def}}$）的后继。\n2.  **变量和赋值**：\n    *   我们关注的变量是 $x$。\n    *   从 $B_{\\text{entry}}$ 到达 $B_{\\text{sw}}$ 的 $x$ 的版本是 $x_0$。\n    *   在块 $B_1$ 中：$x$ 被赋值为 $10$（$x := 10$）。\n    *   在块 $B_2$ 中：没有对 $x$ 的赋值。\n    *   在块 $B_3$ 中：$x$ 被赋值为 $x + 1$（$x := x + 1$）。\n    *   在块 $B_{\\text{def}}$ 中：没有对 $x$ 的赋值。\n3.  **变量使用**：\n    *   在块 $B_{\\text{merge}}$ 中有对 $x$ 的使用。\n\n**步骤2：使用提取的已知条件进行验证**\n\n1.  **科学依据**：该问题植根于编译器理论，这是计算机科学中一个成熟的子领域。静态单赋值（SSA）形式是现代编译器用于优化的标准中间表示。所描述的控制流结构（switch-case 语句）是一种基本的编程构造。该问题在科学和技术上是合理的。\n2.  **适定性**：该问题清晰明确地描述了控制流图及其内部的赋值。它要求应用 SSA 变换的正确方法，这是一个定义明确的算法。关于在何处放置 $\\phi$ 节点以及它们的参数应该是什么的问题，基于标准的 SSA 构建原则（特别是支配边界的概念），有一个唯一的正确答案。\n3.  **客观性**：该问题使用精确的技术术语（例如，“控制流图”、“静态单赋值”、“$\\phi$ 节点”、“前驱”）进行陈述。它没有任何主观或模棱两可的语言。\n\n所有其他有效性标准（完整性、一致性、可行性等）都得到满足。该问题是编译器构造中一个标准的、教科书式的练习。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。我将继续推导解决方案并评估各个选项。\n\n### 解决方案推导\n\n静态单赋值（SSA）形式的核心原则是，每个变量在静态程序文本中只被赋值一次。为了在存在控制流的情况下实现这一点，在控制流图的汇合点引入了称为 $\\phi$ 函数的特殊函数。\n\n如果变量 $v$ 的多个不同定义从其前驱到达块 $B$，则在块 $B$ 处放置一个用于变量 $v$ 的 $\\phi$ 函数。更正式地说，如果基本块 $Y$ 位于包含 $v$ 定义的块 $X$ 的支配边界中，则需要在 $Y$ 处为变量 $v$ 设置一个 $\\phi$ 节点。\n\n1.  **识别汇合点和前驱**：块 $B_{\\text{merge}}$ 是一个汇合点。它的前驱是 $B_1$、$B_2$、$B_3$ 和 $B_{\\text{def}}$。\n\n2.  **识别赋值**：在块 $B_1$ 和 $B_3$ 中存在对变量 $x$ 的赋值。\n\n3.  **确定是否需要 $\\phi$ 节点**：由于在汇合点 $B_{\\text{merge}}$ 之前的块中存在对 $x$ 的赋值，并且根据所走的路径，不同版本的 $x$ 将到达 $B_{\\text{merge}}$，因此需要在 $B_{\\text{merge}}$ 的入口处为 $x$ 设置一个 $\\phi$ 函数。块 $B_1$ 和 $B_3$ 都定义了 $x$，它们的支配边界都包含 $B_{\\text{merge}}$。\n\n4.  **重命名变量并构建 $\\phi$ 函数**：让我们追踪 $x$ 的版本。\n    *   进入 switch 结构的版本是 $x_0$。此版本在 $B_1$、$B_2$、$B_3$ 和 $B_{\\text{def}}$ 的入口处均可用。\n    *   **路径1（通过 $B_1$）**：创建了一个新版本的 $x$。我们称之为 $x_1$。\n        $$x_1 := 10$$\n        从 $B_1$ 到达 $B_{\\text{merge}}$ 的 $x$ 的版本是 $x_1$。\n    *   **路径2（通过 $B_2$）**：没有对 $x$ 的新赋值发生。从 $B_2$ 到达 $B_{\\text{merge}}$ 的 $x$ 的版本是进入 $B_2$ 的版本，即 $x_0$。\n    *   **路径3（通过 $B_3$）**：使用传入版本 $x_0$ 创建了一个新版本的 $x$。我们称之为 $x_3$。\n        $$x_3 := x_0 + 1$$\n        从 $B_3$ 到达 $B_{\\text{merge}}$ 的 $x$ 的版本是 $x_3$。\n    *   **路径4（通过 $B_{\\text{def}}$）**：与 $B_2$ 类似，没有对 $x$ 的新赋值发生。从 $B_{\\text{def}}$ 到达 $B_{\\text{merge}}$ 的 $x$ 的版本是 $x_0$。\n\n5.  **组装 $\\phi$ 节点**：在 $B_{\\text{merge}}$ 处的 $\\phi$ 函数将有四个参数，每个前驱路径一个，按前驱的顺序排列。它定义了一个新版本的 $x$，我们称之为 $x_4$。\n    $$x_4 := \\phi(x_1, x_0, x_3, x_0)$$\n    参数分别对应于从 $B_1$、$B_2$、$B_3$ 和 $B_{\\text{def}}$ 到达的版本。\n\n6.  **更新使用**：在 $B_{\\text{merge}}$ 内部对 $x$ 的使用现在必须引用这个新定义的版本 $x_4$。例如：\n    $$y := x_4$$\n\n这种构造正确地保持了程序的语义，同时满足了单赋值属性。\n\n### 逐项分析\n\n**A. 在 $B_{\\text{merge}}$ 中为 $x$ 插入一个单一的 $\\phi$ 节点，每个前驱边对应一个参数。使用来自每个前驱的到达版本：如果一个前驱对 $x$ 进行了赋值，则传递该新版本；如果一个前驱没有对 $x$ 赋值（包括 default 分支），则传递来自 $B_{\\text{entry}}$ 的传入版本 $x_0$。**\n此选项完美地描述了上面推导出的构建最小化 SSA 形式的标准、正确过程。一个单一的 $\\phi$ 节点被放置在汇合点 $B_{\\text{merge}}$。它的参数是到达每个前驱路径末端的特定版本的 $x$：对于有赋值的路径是新创建的版本（来自 $B_1$ 的 $x_1$ 和来自 $B_3$ 的 $x_3$），对于没有赋值的路径是预先存在的版本（$x_0$）。\n结论：**正确**。\n\n**B. 在每个 case 块内部插入 $\\phi$ 节点以将 $x$ 与 $x_0$ 局部合并，并且不在 $B_{\\text{merge}}$ 放置任何 $\\phi$ 节点；$B_{\\text{merge}}$ 中的使用可以直接引用 $x_0$。**\n这从根本上是错误的。$\\phi$ 节点放置在控制流汇合点（具有多个前驱的块），而不是在简单的顺序块内。块 $B_1$、$B_2$、$B_3$ 和 $B_{\\text{def}}$ 都只有一个前驱（$B_{\\text{sw}}$），因此在那里不需要也没有意义设置 $\\phi$ 节点。此外，不在 $B_{\\text{merge}}$ 放置 $\\phi$ 节点而使用 $x_0$ 将会忽略 $B_1$ 和 $B_3$ 中的赋值，从而违反程序语义。switch 之后 $x$ 的值取决于执行了哪个 case。\n结论：**错误**。\n\n**C. 仅当每个 case（包括 default 分支）都对 $x$ 赋值时，才在 $B_{\\text{merge}}$ 处为 $x$ 插入 $\\phi$ 节点。如果有任何 case 没有对 $x$ 赋值，则省略 $\\phi$ 节点，并让 switch 之后的使用引用 $x_0$。**\n这是错误的。如果汇合点之前的任何路径中对变量有*至少一个*赋值，从而导致多个到达定义，那么 $\\phi$ 节点就是必需的。它并不要求*每条*路径都包含赋值。省略 $\\phi$ 节点将导致不正确的数据流，因为程序将无法解释在 $B_1$ 和 $B_3$ 中赋的新值。\n结论：**错误**。\n\n**D. 在 $B_{\\text{merge}}$ 中为 $x$ 插入一个 $\\phi$ 节点，但对于任何没有赋值的前驱（包括 default 分支），首先在该前驱中插入一个哑复制 $x := x$ 以创建一个新版本，从而使所有 $\\phi$ 参数都是每个边唯一的不同版本。**\n这描述了一种可能但非最优的构建 SSA 形式的方法。它将涉及在 $B_2$ 中插入 $x_2 := x_0$ 和在 $B_{\\text{def}}$ 中插入 $x_5 := x_0$，从而得到 $\\phi(x_1, x_2, x_3, x_5)$。虽然这也产生了一个有效的 SSA 表示并保留了语义，但它引入了不必要的复制指令和变量版本。标准的 SSA 构建算法旨在实现*最小化 SSA*，它避免了这种多余的添加。选项 A 中描述的方法是规范的、更高效的最小化 SSA 形式。因此，与 D 相比，选项 A 是对正确过程的*更好*描述。\n结论：**错误**。与 A 中描述的最小化 SSA 形式相比，这是一种非标准且次优的方法。", "answer": "$$\\boxed{A}$$", "id": "3671616"}, {"introduction": "当程序包含循环以及 `break` 和 `continue` 等非结构化控制转移时，SSA 的构建会变得更加复杂。本练习 [@problem_id:3671619] 挑战你分析一个带有复杂控制流的程序，并系统地应用支配边界算法来确定所有必需的 $\\phi$ 函数位置。这个实践将深化你对 SSA 构建算法在处理实际代码中复杂情况时如何保证正确性的理解。", "problem": "一个优化编译器将程序转换为静态单赋值（SSA）形式，在该形式中，每个变量只被赋值一次，并且在控制流连接点处，不同到达定义的合并通过 $\\phi$-函数来表示。编译器使用控制流图（CFG）作为结构基础，并遵循标准的支配和支配边界方法来放置 $\\phi$-函数，并通过活性分析进行剪枝，即仅当变量在某个连接点是活跃的（live）时，才为其插入 $\\phi$-函数。考虑以下结构化程序，它同时使用了循环以及通过 break 和 continue 进行的控制转移：\n- 输入：一个整数 $n$ 和一个从 $0$ 开始索引的整数数组 $A[\\,]$。\n- 变量：整数 $x$、$y$、$i$。\n- 初始化：$x \\leftarrow 0$; $i \\leftarrow 0$。\n- 循环：while $\\big(i  n\\big)$ do\n  1. 如果 $\\big(A[i] > 0\\big)$ 则 $x \\leftarrow x + 1$ 否则 $x \\leftarrow x + A[i]$。\n  2. 如果 $\\big(A[i] = 0\\big)$ 则 break。\n  3. 如果 $\\big((A[i] \\bmod 2) = 0\\big)$ 则 $i \\leftarrow i + 1$; continue。\n  4. $y \\leftarrow x + i$。\n  5. $i \\leftarrow i + 1$。\n- 循环退出后，返回 $x$。\n假设采用常规的结构化翻译方法生成控制流图（CFG），其中：\n- 循环条件构成一个循环头，它有两个前驱：一个唯一的循环前置节点（preheader）和一个或多个循环回边（backedge）。\n- 第一个条件（步骤1）是一个在步骤2之前重新汇合的 if-else 结构。\n- 步骤2中的 break 将控制权转移到唯一的循环出口块，当循环条件不满足时，循环头也会通过直通（fall-through）路径将控制权转移到该出口块。\n- 步骤3中的 continue 沿着一条回边将控制权转移到循环头。\n使用标准的基于支配和支配边界的 $\\phi$-函数放置方法（如 Cytron 等人所述），并构建剪枝后的 SSA（即仅在变量活跃的地方插入 $\\phi$-函数），确定在整个程序中，特别是针对变量 $x$，必须插入的 $\\phi$-函数的最少总数，包括由于 break 路径而在循环头和循环出口处插入的函数。以整数形式提供最终答案。无需四舍五入。", "solution": "该问题要求在将给定程序转换为剪枝后的静态单赋值（SSA）形式时，确定变量 $x$ 所需的 $\\phi$-函数的最少数量。根据题意，完成此任务的标准算法包括两个主要阶段：\n1.  使用支配边界准则放置 $\\phi$-函数。\n2.  对已插入的、但其对应变量不活跃的 $\\phi$-函数进行剪枝。\n\n我们将系统地遵循这些步骤。\n\n首先，我们根据程序结构和给定的翻译规则构建控制流图（CFG）。我们定义以下基本块：\n-   `B_Init`：包含初始赋值 $x \\leftarrow 0$ 和 $i \\leftarrow 0$。它是循环的前置节点（preheader）。\n-   `B_Header`：循环头，用于评估条件 $i  n$。\n-   `B_IfBody`：循环体的入口，包含第一个条件测试 $A[i] > 0$。\n-   `B_Then`：第一个条件的 'then' 分支，包含 $x \\leftarrow x + 1$。\n-   `B_Else`：第一个条件的 'else' 分支，包含 $x \\leftarrow x + A[i]$。\n-   `B_Join1`：第一个 `if-else` 语句的重新汇合点。\n-   `B_BreakTest`：包含用于 `break` 的第二个条件测试 $A[i] = 0$。\n-   `B_ContTest`：包含用于 `continue` 的第三个条件测试 $(A[i] \\bmod 2) = 0$。\n-   `B_Continue`：包含 $i \\leftarrow i + 1$ 和 `continue` 跳转。\n-   `B_BodyEnd`：包含循环体的最后部分，$y \\leftarrow x + i$ 和 $i \\leftarrow i + 1$。\n-   `B_Exit`：唯一的循环出口块，包含 `return x`。\n\n控制流如下：\n-   `B_Init` $\\rightarrow$ `B_Header`\n-   `B_Header` $\\rightarrow$ `B_IfBody` (如果 $i  n$)\n-   `B_Header` $\\rightarrow$ `B_Exit` (如果 $i \\ge n$)\n-   `B_IfBody` $\\rightarrow$ `B_Then` (如果 $A[i] > 0$)\n-   `B_IfBody` $\\rightarrow$ `B_Else` (如果 $A[i] \\le 0$)\n-   `B_Then` $\\rightarrow$ `B_Join1`\n-   `B_Else` $\\rightarrow$ `B_Join1`\n-   `B_Join1` $\\rightarrow$ `B_BreakTest`\n-   `B_BreakTest` $\\rightarrow$ `B_Exit` (如果 $A[i] = 0$，`break` 路径)\n-   `B_BreakTest` $\\rightarrow$ `B_ContTest` (如果 $A[i] \\ne 0$)\n-   `B_ContTest` $\\rightarrow$ `B_Continue` (如果 $(A[i] \\bmod 2) = 0$)\n-   `B_ContTest` $\\rightarrow$ `B_BodyEnd` (如果 $(A[i] \\bmod 2) \\ne 0$)\n-   `B_Continue` $\\rightarrow$ `B_Header` (回边)\n-   `B_BodyEnd` $\\rightarrow$ `B_Header` (回边)\n\nSSA 构建的核心原则是，对于任何汇集了变量 $v$ 的不同到达定义的节点 $N$，都需要为 $v$ 在该节点处设置一个 $\\phi$-函数。所有此类节点 $N$ 的集合恰好是包含 $v$ 赋值的节点集合的迭代支配边界，记为 $DF^+$。\n\n变量 $x$ 的赋值（定义）出现在三个块中：\n-   `B_Init`：$x \\leftarrow 0$\n-   `B_Then`：$x \\leftarrow x + 1$\n-   `B_Else`：$x \\leftarrow x + A[i]$\n\n令 $S = \\{ \\text{B\\_Init, B\\_Then, B\\_Else} \\}$ 为包含 $x$ 定义的块的集合。我们必须计算 $DF^+(S)$。这是通过迭代完成的。令 $\\Phi$ 为放置 $\\phi$-函数的块的集合。初始时，$\\Phi = \\emptyset$。\n\n1.  **初始 $\\phi$-函数放置：** 我们计算 $S$ 中各块的支配边界。\n    -   `B_Then` 和 `B_Else` 中的定义是不同的。它们都到达 `B_Join1`，这是这些块之后的第一个控制流汇合点。形式上，`B_Join1` 位于 `B_Then` 和 `B_Else` 的支配边界中。因此，必须在 `B_Join1` 处为 $x$ 放置一个 $\\phi$-函数。\n    $\\Phi_1 = DF(\\text{B\\_Then}) \\cup DF(\\text{B\\_Else}) = \\{ \\text{B\\_Join1} \\}$。\n    所以，在 `B_Join1` 处放置一个 $\\phi$-函数。这是我们的第一个 $\\phi$-函数。\n\n2.  **迭代 $\\phi$-函数放置：** 在 `B_Join1` 处放置 $\\phi$-函数实际上在该块创建了一个新的 $x$ 的定义。我们现在必须考虑 `B_Join1` 的支配边界。\n    -   `B_Init` 中（循环外）对 $x$ 的定义和 `B_Join1` 中（循环内，通过来自 `B_Continue` 和 `B_BodyEnd` 的回边流回）对 $x$ 的新定义都到达了 `B_Header`。因此，`B_Header` 是这些定义的连接点。形式上，`B_Header` 位于 `B_Join1`（以及循环内的其他块）的支配边界中。因此，在 `B_Header` 处需要一个 $\\phi$-函数。\n    -   `break` 语句创建了一条从 `B_BreakTest` 到 `B_Exit` 的路径。此路径上 $x$ 的值来自 `B_Join1` 处的定义。正常的循环终止路径是从 `B_Header` 到 `B_Exit`。此路径上 $x$ 的值来自 `B_Header` 处的 $\\phi$-函数。这两个不同的 $x$ 的定义在 `B_Exit` 处相遇。因此，`B_Exit` 是一个连接点。形式上，`B_Exit` 位于 `B_Join1` 的支配边界中。\n    所以，我们有 $\\Phi_2 = DF(\\text{B\\_Join1}) = \\{ \\text{B\\_Header, B\\_Exit} \\}$。我们将这两个块添加到我们的 $\\phi$-函数位置集合中。这是我们的第二个和第三个 $\\phi$-函数。\n\n3.  **进一步迭代：** 我们现在必须考虑新的 $\\phi$-函数位置 `B_Header` 和 `B_Exit` 的支配边界。\n    -   `DF(\\text{B\\_Header}) = \\emptyset`。`B_Header` 处的定义不会创建更多的连接点。\n    -   `DF(\\text{B\\_Exit}) = \\emptyset`。这个块是这部分控制流的终点。\n    迭代终止。在未剪枝的 SSA 形式中，需要为 $x$ 放置 $\\phi$-函数的块集合是 $\\{ \\text{B\\_Join1, B\\_Header, B\\_Exit} \\}$。这总共是 $3$ 个 $\\phi$-函数。\n\n现在，我们必须应用剪枝规则：只有当变量 $x$ 在块 $N$ 的入口处是“活跃的”（live）时，才在该块为 $x$ 插入 $\\phi$-函数。如果一个变量的当前值可能在未来被使用，则该变量是活跃的。我们检查 $x$ 在三个候选块入口处的活性。\n\n$x$ 的使用出现在：\n-   `B_Then`：在表达式 $x + 1$ 中。\n-   `B_Else`：在表达式 $x + A[i]$ 中。\n-   `B_BodyEnd`：在表达式 $x + i$ 中。\n-   `B_Exit`：在表达式 `return x` 中。\n\n-   **在 `B_Join1` 处的活性：** 在 `B_Join1` 的入口处，$x$ 是否活跃？是的。有一条从 `B_Join1` 到 `B_BodyEnd` 的路径，其中 $x$ 被用来计算 $y$。也有一条通过 `break` 从 `B_Join1` 到 `B_Exit` 的路径，其中 $x$ 在 `return` 语句中被使用。因为存在未来的使用，所以 $x$ 是活跃的。`B_Join1` 处的 $\\phi$-函数**不被剪枝**。\n\n-   **在 `B_Header` 处的活性：** 在 `B_Header` 的入口处，$x$ 是否活跃？是的。进入循环头的 $x$ 值可以在第一次迭代中被 `B_Then` 或 `B_Else` 使用。它也可以在循环通过 `B_Header` $\\rightarrow$ `B_Exit` 路径终止后被使用，该路径上有 `return x` 语句。因为存在未来的使用，所以 $x$ 是活跃的。`B_Header` 处的 $\\phi$-函数**不被剪枝**。\n\n-   **在 `B_Exit` 处的活性：** 在 `B_Exit` 的入口处，$x$ 是否活跃？是的。`B_Exit` 块本身包含语句 `return x`，这是对 $x$ 的一次使用。如果一个变量在块中被使用（在任何重新定义之前），那么它在该块的入口处总是活跃的。`B_Exit` 处的 $\\phi$-函数**不被剪枝**。\n\n由于 $x$ 在所有三个块——`B_Join1`、`B_Header` 和 `B_Exit`——的入口处都是活跃的，因此通过支配边界准则放置的 $\\phi$-函数都没有被剪枝。\n\n因此，变量 $x$ 所需的 $\\phi$-函数的最少总数为 $3$。", "answer": "$$\\boxed{3}$$", "id": "3671619"}, {"introduction": "$\\phi$ 函数是一个强大的抽象概念，但在生成最终的机器代码时，我们必须将其转换为具体的指令。本练习 [@problem_id:3671657] 关注 SSA 的“后端”过程：$\\phi$ 函数的消除。它要求你将 $\\phi$ 函数的并行赋值语义转换成一系列串行的寄存器移动指令，并解决由此产生的依赖冲突，让你一窥编译器如何将高级中间表示映射到真实的硬件上。", "problem": "在静态单赋值 (SSA) 形式中，基本块入口处的 $\\phi$-函数的语义要求，当控制沿某条前驱边转移时，每个 $\\phi$-节点都精确地选择沿该边产生的值，就好像所有被选择的赋值都在块入口处同时发生一样。假设 $B$ 是一个汇合块，其前驱为 $P_1$ 和 $P_2$。块 $B$ 包含三个分别用于变量 $x$、$y$ 和 $z$ 的 $\\phi$-节点。在 $B$ 中，一个目标寄存器分配方案已经确定：$x$ 被分配给寄存器 $r_2$，$y$ 被分配给 $r_3$，而 $z$ 被分配给 $r_1$。在每个前驱的末尾，供给这些 $\\phi$-节点的值位于以下机器寄存器中：\n\n- 沿着边 $P_1 \\to B$：$x_1$ 在 $r_1$ 中，$y_1$ 在 $r_2$ 中，$z_1$ 在 $r_3$ 中。\n- 沿着边 $P_2 \\to B$：$x_2$ 在 $r_2$ 中，$y_2$ 在 $r_1$ 中，$z_2$ 在 $r_3$ 中。\n\n为了消除这些 $\\phi$-节点，您需要将它们降解为每条边上的并行复制操作，这些操作将源寄存器中的值移动到它们在 $B$ 中的目标寄存器。边上的并行复制集必须通过在该边上执行的一系列形式为 $a := b$ 的具体移动指令来实现，这些指令共同保持了同时语义。如果源寄存器和目标寄存器相同，您可以省略该移动指令。您可以使用一个且仅一个全新的临时寄存器 $t$（它不同于 $r_1$、$r_2$ 和 $r_3$）来打破复制依赖中的环；在每条边上都可以独立地使用 $t$。将边上的“额外移动”定义为超出该边并行复制集所蕴含的非恒等复制数量的任何已执行移动。\n\n任务：\n- 对于每条边 $P_i \\to B$（$i \\in \\{1,2\\}$），根据指定的寄存器位置，推导出由三个 $\\phi$-节点引出的并行复制集。\n- 在每条边上提出一个有效的顺序移动调度，该调度要实现其并行复制集，通过仅在绝对必要时使用 $t$ 来避免破坏性的环，并最小化该边上的额外移动数量。\n- 在遵循这些规则的所有有效调度中，确定两条边 $P_1 \\to B$ 和 $P_2 \\to B$ 上额外移动的最小总数。\n\n请提供一个整数作为您的最终答案，该整数等于两条边上额外移动的最小总数。无需四舍五入。", "solution": "该问题要求我们确定将基本块 $B$ 入口处的 $\\phi$-函数降解为其前驱边 $P_1 \\to B$ 和 $P_2 \\to B$ 上的顺序移动指令所需的“额外移动”的最小总数。额外移动被定义为超出给定边上非恒等复制数量的任何已执行移动。\n\n首先，我们来确定目标状态。在块 $B$ 的入口处，变量 $x$、$y$ 和 $z$ 的值必须分别位于寄存器 $r_2$、$r_3$ 和 $r_1$ 中。$\\phi$-函数定义了使用哪些前驱的值：\n- $x_{B} = \\phi(x_1 \\text{ from } P_1, x_2 \\text{ from } P_2)$\n- $y_{B} = \\phi(y_1 \\text{ from } P_1, y_2 \\text{ from } P_2)$\n- $z_{B} = \\phi(z_1 \\text{ from } P_1, z_2 \\text{ from } P_2)$\n\n我们分别分析每条前驱边。\n\n**对边 $P_1 \\to B$ 的分析**\n\n在来自前驱 $P_1$ 的边上，$x_1$、$y_1$ 和 $z_1$ 的值是 $\\phi$-函数的源。问题陈述了它们在块 $P_1$ 末尾的位置：\n- $x_1$ 在寄存器 $r_1$ 中。\n- $y_1$ 在寄存器 $r_2$ 中。\n- $z_1$ 在寄存器 $r_3$ 中。\n\n为了在块 $B$ 的入口处建立所需的状态，必须在边 $P_1 \\to B$ 上进行以下同时赋值（称为并行复制）：\n- $B$ 中 $x$ 的值（在 $r_2$ 中）必须来自 $x_1$（在 $r_1$ 中）。这意味着需要复制 $r_2 := r_1$。\n- $B$ 中 $y$ 的值（在 $r_3$ 中）必须来自 $y_1$（在 $r_2$ 中）。这意味着需要复制 $r_3 := r_2$。\n- $B$ 中 $z$ 的值（在 $r_1$ 中）必须来自 $z_1$（在 $r_3$ 中）。这意味着需要复制 $r_1 := r_3$。\n\n这条边的并行复制集是 $\\{r_2 := r_1, r_3 := r_2, r_1 := r_3\\}$。这三个都是非恒等复制。为了用顺序移动指令实现这一点，我们必须分析依赖关系。对于每个复制操作 $r_d := r_s$，都存在一个依赖关系 $r_s \\to r_d$，因为需要 $r_s$ 中的原始值。其依赖图如下：\n$r_1 \\to r_2$\n$r_2 \\to r_3$\n$r_3 \\to r_1$\n\n这些依赖关系形成一个长度为3的环：$r_1 \\to r_2 \\to r_3 \\to r_1$。直接的顺序实现，例如 $r_2 := r_1$，会破坏 $r_1$ 中后续复制操作所需的值。这样的环使得使用所提供的临时寄存器 $t$ 成为“绝对必要”。\n\n为了打破一个长度为 $k \\ge 2$ 的环，使用一个临时寄存器的最优序列需要 $k+1$ 次移动。在这里，$k=3$。一个最小化的移动调度是：\n1. $t := r_3$（保存 $z_1$ 的值）\n2. $r_3 := r_2$（将 $y_1$ 的值移动到其目标 $r_3$）\n3. $r_2 := r_1$（将 $x_1$ 的值移动到其目标 $r_2$）\n4. $r_1 := t$（将保存的 $z_1$ 的值移动到其目标 $r_1$）\n\n非恒等复制的数量是 $3$。执行的顺序移动指令数量是 $4$。额外移动的数量是二者之差：$4 - 3 = 1$。这是该边上可能的最小值，因为需要一次额外移动来打破环。\n\n**对边 $P_2 \\to B$ 的分析**\n\n在来自前驱 $P_2$ 的边上，$x_2$、$y_2$ 和 $z_2$ 的值是源。它们在块 $P_2$ 末尾的位置是：\n- $x_2$ 在寄存器 $r_2$ 中。\n- $y_2$ 在寄存器 $r_1$ 中。\n- $z_2$ 在寄存器 $r_3$ 中。\n\n边 $P_2 \\to B$ 的并行复制也以类似方式推导得出：\n- $B$ 中 $x$ 的值（在 $r_2$ 中）必须来自 $x_2$（在 $r_2$ 中）。这意味着需要复制 $r_2 := r_2$。\n- $B$ 中 $y$ 的值（在 $r_3$ 中）必须来自 $y_2$（在 $r_1$ 中）。这意味着需要复制 $r_3 := r_1$。\n- $B$ 中 $z$ 的值（在 $r_1$ 中）必须来自 $z_2$（在 $r_3$ 中）。这意味着需要复制 $r_1 := r_3$。\n\n并行复制集是 $\\{r_2 := r_2, r_3 := r_1, r_1 := r_3\\}$。\n问题允许我们省略源和目标相同的移动。因此，移动指令 $r_2 := r_2$ 不被执行。非恒等复制的集合是 $\\{r_3 := r_1, r_1 := r_3\\}$。\n\n这两个复制的依赖图是：\n$r_1 \\to r_3$\n$r_3 \\to r_1$\n\n这形成一个长度为2的环：$r_1 \\to r_3 \\to r_1$。这代表一个交换操作。与前一种情况一样，环的存在使得使用临时寄存器 $t$ 成为必要。为了打破这个长度为 $k=2$ 的环，我们需要 $k+1=3$ 次顺序移动。一个最小化的移动调度是：\n1. $t := r_1$（保存 $y_2$ 的值）\n2. $r_1 := r_3$（将 $z_2$ 的值移动到其目标 $r_1$）\n3. $r_3 := t$（将保存的 $y_2$ 的值移动到其目标 $r_3$）\n\n非恒等复制的数量是 $2$。执行的顺序移动指令数量是 $3$。额外移动的数量是二者之差：$3 - 2 = 1$。这是可能的最小值，因为需要一次额外移动来解决这个交换环。\n\n**最小额外移动总数**\n\n最小额外移动总数是每条边所需的最小额外移动数量之和。\n- 边 $P_1 \\to B$ 的最小额外移动数：$1$。\n- 边 $P_2 \\to B$ 的最小额外移动数：$1$。\n\n两条边上的最小额外移动总数是 $1 + 1 = 2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3671657"}]}